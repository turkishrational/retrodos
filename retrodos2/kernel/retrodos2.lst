     1                                  ; ****************************************************************************
     2                                  ; RETRODOS.SYS (MSDOS 2.0 Kernel) - RETRO DOS v2.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 18/07/2018
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 04/02/2018 (Retro DOS 1.0), 24/02/2018 (Retro DOS 2.0)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.11  
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm retrodos.s -l retrodos.lst -o MSDOS.SYS)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; This assembly file has three parts: (BIOS+SYSINIT+KERNEL in one kernel file)
    13                                  ; 1a) IBMBIO.COM (IO.SYS) part from beginning to '%incbin MSDOS.BIN'
    14                                  ; 1b) SYSINIT part (at the end of IBMBIO.COM/IO.SYS) as '%incbin SYSINIT.BIN'		
    15                                  ; 2) MSDOS.SYS (MSDOS 2.0 Kernel) as included binary file (MSDOS.BIN).
    16                                  ; source : 'retrodos.s' (main), 'sysinit.s' (included), 'msdos.s' (included)	
    17                                  ;
    18                                  ; (Note: RETRO DOS 2.0 boot sector code will load 'MSDOS.SYS' at 1000h:0000h)
    19                                  ; (Original MSDOS 2.0 IBMBIO.COM loads/runs its own init code at 0070h:0000h)
    20                                  
    21                                  ;=============================================================================
    22                                  ; Modified from 'retrodos.s', Retro DOS v1.0 Kernel ("IBMBIO.COM") Source code
    23                                  ; by Erdogan Tan, 20/02/2018
    24                                  ;=============================================================================
    25                                  
    26                                  SECTOR_SIZE     equ     0200h		; size of a sector
    27                                  PAUSE_KEY       equ     7200h		; scancode + charcode of PAUSE key
    28                                  KEYBUF_NEXT     equ     041Ah		; next character in keyboard buffer
    29                                  KEYBUF_FREE     equ     041Ch		; next free slot in keyboard buffer
    30                                  KEYBUF          equ     041Eh		; keyboard buffer data
    31                                  LOGICAL_DRIVE   equ     0504h		; linear address of logical drive byte
    32                                  ;DOS_SEGMENT	equ     00BFh ; v1.1	; segment in which DOS will run
    33                                  DOS_SEGMENT	equ     00C4h		; Retro DOS v1.0 - 13/02/2018
    34                                  BIO_SEGMENT     equ     0060h		; segment in which BIO is running
    35                                  
    36                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "DISKPRM.INC" - 24/07/1987)
    37                                  ; The following structure defines the disk parameter table
    38                                  ; pointed to by Interrupt vector 1EH (location 0:78H)
    39                                  
    40                                  struc	DISK_PARMS
    41 00000000 <res 00000001>          .DISK_SPECIFY_1:  resb	1
    42 00000001 <res 00000001>          .DISK_SPECIFY_2:  resb	1
    43 00000002 <res 00000001>          .DISK_MOTOR_WAIT: resb  1	; Wait till motor off
    44 00000003 <res 00000001>          .DISK_SECTOR_SIZ: resb 	1	; Bytes/Sector (2 = 512)
    45 00000004 <res 00000001>          .DISK_EOT:	  resb  1	; Sectors per track (MAX)
    46 00000005 <res 00000001>          .DISK_RW_GAP:	  resb  1	; Read Write Gap
    47 00000006 <res 00000001>          .DISK_DTL:	  resb	1
    48 00000007 <res 00000001>          .DISK_FORMT_GAP:  resb  1	; Format Gap Length
    49 00000008 <res 00000001>          .DISK_FILL:	  resb  1	; Format Fill Byte
    50 00000009 <res 00000001>          .DISK_HEAD_STTL:  resb  1	; Head Settle Time (MSec)
    51 0000000A <res 00000001>          .DISK_MOTOR_STRT: resb  1	; Motor start delay
    52                                  .size:
    53                                  endstruc
    54                                  
    55                                  ROMStatus	equ	1
    56                                  ROMRead 	equ	2
    57                                  ROMWrite	equ	3
    58                                  ROMVerify	equ	4
    59                                  ROMFormat	equ	5  
    60                                  
    61                                  ; 24/02/2018 (Retro DOS 2.0 - MSDOS 3.3 "MSBDS.INC" - 24/07/1987)
    62                                  ; -------------------------------------------------------------------------
    63                                  ;  BDS is the Bios Data Structure.
    64                                  ;
    65                                  ;  There is one BDS for each logical drive in the system.  All the BDS's
    66                                  ;  are linked together in a list with the pointer to the first BDS being
    67                                  ;  found in START_BDS.	The BDS hold various values important to the disk
    68                                  ;  drive.  For example there is a field for last time accesses.  As actions
    69                                  ;  take place in the system the BDS are update to reflect the actions.
    70                                  ;  For example is there is a read to a disk the last access field for the
    71                                  ;  BDS for that drive is update to the current time.
    72                                  ;
    73                                  ; Values for various flags in BDS.Flags.
    74                                  ;
    75                                  
    76                                  fNon_Removable	    equ     01H 	;For non-removable media
    77                                  fChangeline	    equ     02H 	;If changeline supported on drive
    78                                  RETURN_FAKE_BPB     equ     04H 	; When set, don't do a build BPB
    79                                  					; just return the fake one
    80                                  GOOD_TRACKLAYOUT    equ     08H 	; The track layout has no funny sectors
    81                                  fI_Am_Mult	    equ     10H 	;If more than one logical for this physical
    82                                  fI_Own_Physical     equ     20H 	;Signify logical owner of this physical
    83                                  fChanged	    equ     40H 	;Indicates media changed
    84                                  SET_DASD_true	    equ     80H 	; Set DASD before next format
    85                                  fChanged_By_Format  equ    100h
    86                                  
    87                                  ;
    88                                  ; Various form factors to describe media
    89                                  ;
    90                                  
    91                                  ff48tpi 	    equ     0
    92                                  ff96tpi 	    equ     1
    93                                  ffSmall 	    equ     2
    94                                  ffHardFile	    equ     5
    95                                  ffOther 	    equ     7
    96                                  ; MSDOS 6.0 ("MSBDS.INC", 1991)
    97                                  ff288		    equ     9	; 2.88 MB drive
    98                                  ; Retro DOS v2.0 fetaure only !
    99                                  ff144		    equ	   10	; 1.44 MB drive			
   100                                  
   101                                  struc	BDS	; BDS_Type
   102 00000000 <res 00000004>          .Link:		resd 1		; Link to next BDS
   103 00000004 <res 00000001>          .DriveNum:	resb 1		; Physical drive number
   104 00000005 <res 00000001>          .DriveLet:	resb 1		; DOS drive number
   105 00000006 <res 00000002>          .BytePerSec:	resw 1		; number of bytes/sec
   106 00000008 <res 00000001>          .SecPerClus:	resb 1		; sec per allocation unit
   107 00000009 <res 00000002>          .RESSEC:	resw 1		; number of reserved sectors
   108 0000000B <res 00000001>          .cFAT:		resb 1		; number of fats
   109 0000000C <res 00000002>          .cDir:		resw 1		; number of directory entries
   110 0000000E <res 00000002>          .DRVLIM:	resw 1		; number of sectors on medium
   111 00000010 <res 00000001>          .Mediad:	resb 1		; media descriptor byte
   112 00000011 <res 00000002>          .cSecFat: 	resw 1		; number of sectors/fat
   113 00000013 <res 00000002>          .SECLIM:	resw 1		; sectors per track
   114 00000015 <res 00000002>          .HDLIM:		resw 1		; max number of heads
   115 00000017 <res 00000002>          .HIDSEC:	resw 1		; number of hidden sectors
   116 00000019 <res 00000001>          .FatSiz:	resb 1		; flags...
   117 0000001A <res 00000002>          .Opcnt:		resw 1		; Open ref. count
   118 0000001C <res 0000000C>          .Volid:		resb 12		; volume ID of medium
   119 00000028 <res 00000001>          .FormFactor:	resb 1		; form factor index
   120 00000029 <res 00000002>          .Flags:		resw 1		; various flags
   121 0000002B <res 00000002>          .cCyln:		resw 1		; max number of cylinders
   122 0000002D <res 00000002>          .RBytePerSec:	resw 1		; Recommended BPB
   123 0000002F <res 00000001>          .RSecPerClus:	resb 1
   124 00000030 <res 00000002>          .RRESSEC: 	resw 1
   125 00000032 <res 00000001>          .RcFAT:		resb 1
   126 00000033 <res 00000002>          .RcDir:		resw 1
   127 00000035 <res 00000002>          .RDRVLIM: 	resw 1
   128 00000037 <res 00000001>          .Rmediad: 	resb 1
   129 00000038 <res 00000002>          .RcSecFat:	resw 1
   130 0000003A <res 00000002>          .RSECLIM: 	resw 1
   131 0000003C <res 00000002>          .RHDLIM:	resw 1
   132 0000003E <res 00000002>          .RHIDSEC: 	resw 1
   133 00000040 <res 00000002>          .RHHIDSEC:	resw 1
   134 00000042 <res 00000004>          .RLOGSEC: 	resd 1
   135 00000046 <res 00000006>          .Reserve: 	resb 6		; Reserved for future
   136 0000004C <res 00000001>          .Track:		resb 1		; last track accessed on drive
   137 0000004D <res 00000002>          .TIM_LO:	resw 1		; Time of last access. Keep
   138 0000004F <res 00000002>          .TIM_HI:	resw 1		; these contiguous.
   139                                  endstruc
   140                                  
   141                                  BPBSize	equ	BDS.Track - BDS.RBytePerSec 
   142                                  				; size in bytes of RecBPB area in the BDS
   143                                  
   144                                  ; 23/03/2018
   145                                  
   146                                  ;STATIC REQUEST HEADER (DEVSYM.INC, MSDOS 6.0, 1991)
   147                                  STRUC SRHEAD
   148 00000000 <res 00000001>          .REQLEN:	resb 1		;LENGTH IN BYTES OF REQUEST BLOCK
   149 00000001 <res 00000001>          .REQUNIT:	resb 1		;DEVICE UNIT NUMBER
   150 00000002 <res 00000001>          .REQFUNC:	resb 1		;TYPE OF REQUEST
   151 00000003 <res 00000002>          .REQSTAT:	resw 1		;STATUS WORD
   152 00000005 <res 00000008>          	       	resb 8		;RESERVED FOR QUEUE LINKS
   153                                  .size:
   154                                  endstruc
   155                                  
   156                                  ; GENERIC IOCTL REQUEST STRUCTURE (DEVSYM.INC, MSDOS 6.0, 1991)
   157                                  ;	SEE THE DOS 4.0 DEVICE DRIVER SPEC FOR FURTHER ELABORATION.
   158                                  ;
   159                                  struc IOCTL_REQ
   160                                  	       ;DB    (SIZE SRHEAD) DUP(?)
   161 00000000 <res 0000000D>          		resb SRHEAD.size	
   162                                  			    	; GENERIC IOCTL ADDITION.
   163 0000000D <res 00000001>          .MAJORFUNCTION:	resb 1		;FUNCTION CODE
   164 0000000E <res 00000001>          .MINORFUNCTION:	resb 1		;FUNCTION CATEGORY
   165 0000000F <res 00000002>          .REG_SI:	resw 1
   166 00000011 <res 00000002>          .REG_DI:	resw 1
   167 00000013 <res 00000004>          .GENERICIOCTL_PACKET: resd 1	; POINTER TO DATA BUFFER
   168                                  endstruc
   169                                  
   170                                  ; GENERIC IOCTL CATEGORY CODES  (IOCTL.INC, MSDOS 6.0, 1991)
   171                                  IOC_OTHER	EQU	0	; Other device control J.K. 4/29/86
   172                                  IOC_SE		EQU	1	; SERIAL DEVICE CONTROL
   173                                  IOC_TC		EQU	2	; TERMINAL CONTROL
   174                                  IOC_SC		EQU	3	; SCREEN CONTROL
   175                                  IOC_KC		EQU	4	; KEYBOARD CONTROL
   176                                  IOC_PC		EQU	5	; PRINTER CONTROL
   177                                  IOC_DC		EQU	8	; DISK CONTROL (SAME AS RAWIO)
   178                                  
   179                                  ; DEFINITIONS FOR IOCTL_REQ.MINORFUNCTION
   180                                  GEN_IOCTL_WRT_TRK   EQU   40H
   181                                  GEN_IOCTL_RD_TRK    EQU   60H
   182                                  GEN_IOCTL_FN_TST    EQU   20H	; USED TO DIFF. BET READS AND WRTS
   183                                  
   184                                  ;struc A_RETRYCOUNT  ; (IOCTL.INC, MSDOS 6.0, 1991)
   185                                  ;.RC_COUNT:	resw 	1
   186                                  ;endstruc
   187                                  
   188                                  ; 27/03/2018 - DEVSYM.INC - MSDOS 3.3 - 24/07/1987
   189                                  
   190                                  ;
   191                                  ; ATTRIBUTE BIT MASKS
   192                                  ;
   193                                  ; CHARACTER DEVICES:
   194                                  ;
   195                                  ; BIT 15 -> MUST BE 1
   196                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   197                                  ;     13 -> 1 IF THE DEVICE SUPPORTS OUTPUT-UNTIL-BUSY
   198                                  ;     12 -> UNUSED
   199                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE
   200                                  ;     10 -> MUST BE 0
   201                                  ;      9 -> MUST BE 0
   202                                  ;      8 -> UNUSED
   203                                  ;      7 -> UNUSED
   204                                  ;      6 -> UNUSED
   205                                  ;      5 -> UNUSED
   206                                  ;      4 -> 1 IF DEVICE IS RECIPIENT OF INT 29H
   207                                  ;      3 -> 1 IF DEVICE IS CLOCK DEVICE
   208                                  ;      2 -> 1 IF DEVICE IS NULL DEVICE
   209                                  ;      1 -> 1 IF DEVICE IS CONSOLE OUTPUT
   210                                  ;      0 -> 1 IF DEVICE IS CONSOLE INPUT
   211                                  ;
   212                                  ; BLOCK DEVICES:
   213                                  ;
   214                                  ; BIT 15 -> MUST BE 0
   215                                  ;     14 -> 1 IF THE DEVICE UNDERSTANDS IOCTL CONTROL STRINGS
   216                                  ;     13 -> 1 IF THE DEVICE DETERMINES MEDIA BY EXAMINING THE FAT ID BYTE.
   217                                  ;	    THIS REQUIRES THE FIRST SECTOR OF THE FAT TO *ALWAYS* RESIDE IN
   218                                  ;	    THE SAME PLACE.
   219                                  ;     12 -> UNUSED
   220                                  ;     11 -> 1 IF THE DEVICE UNDERSTANDS OPEN/CLOSE/REMOVABLE MEDIA
   221                                  ;     10 -> MUST BE 0
   222                                  ;      9 -> MUST BE 0
   223                                  ;      8 -> UNUSED
   224                                  ;      7 -> UNUSED
   225                                  ;      6 -> IF DEVICE HAS SUPPORT FOR GETMAP/SETMAP OF LOGICAL DRIVES.
   226                                  ;	    IF THE DEVICE UNDERSTANDS GENERIC IOCTL FUNCTION CALLS.
   227                                  ;      5 -> UNUSED
   228                                  ;      4 -> UNUSED
   229                                  ;      3 -> UNUSED
   230                                  ;      2 -> UNUSED
   231                                  ;      1 -> UNUSED
   232                                  ;      0 -> UNUSED
   233                                  ;
   234                                  
   235                                  DEVTYP	       EQU   8000H	    ; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   236                                  CHARDEV        EQU   8000H
   237                                  DEVIOCTL       EQU   4000H	    ; BIT 14 - CONTROL MODE BIT
   238                                  ISFATBYDEV     EQU   2000H	    ; BIT 13 - DEVICE USES FAT ID BYTES,
   239                                  				    ;  COMP MEDIA.
   240                                  OUTTILBUSY     EQU   2000H	    ; OUTPUT UNTIL BUSY IS ENABLED
   241                                  ISNET	       EQU   1000H	    ; BIT 12 - 1 IF A NET DEVICE, 0 IF
   242                                  				    ;  NOT.  CURRENTLY BLOCK ONLY.
   243                                  DEVOPCL        EQU   0800H	    ; BIT 11 - 1 IF THIS DEVICE HAS
   244                                  				    ;  OPEN,CLOSE AND REMOVABLE MEDIA
   245                                  				    ;  ENTRY POINTS, 0 IF NOT
   246                                  
   247                                  EXTENTBIT      EQU   0400H	    ; BIT 10 - CURRENTLY 0 ON ALL DEVS
   248                                  				    ;  THIS BIT IS RESERVED FOR FUTURE USE
   249                                  				    ;  TO EXTEND THE DEVICE HEADER BEYOND
   250                                  				    ;  ITS CURRENT FORM.
   251                                  
   252                                  ; NOTE BIT 9 IS CURRENTLY USED ON IBM SYSTEMS TO INDICATE "DRIVE IS SHARED".
   253                                  ;    SEE IOCTL FUNCTION 9. THIS USE IS NOT DOCUMENTED, IT IS USED BY SOME
   254                                  ;    OF THE UTILITIES WHICH ARE SUPPOSED TO FAIL ON SHARED DRIVES ON SERVER
   255                                  ;    MACHINES (FORMAT,CHKDSK,RECOVER,..).
   256                                  
   257                                  DEV320	       EQU   0040H	    ;BIT 6 - FOR BLOCK DEVICES, THIS
   258                                  				    ;DEVICE SUPPORTS SET/GET MAP OF
   259                                  				    ;LOGICAL DRIVES, AND SUPPORTS
   260                                  				    ;GENERIC IOCTL CALLS.
   261                                  				    ;FOR CHARACTER DEVICES, THIS
   262                                  				    ;DEVICE SUPPORTS GENERIC IOCTL.
   263                                  				    ;THIS IS A DOS 3.2 DEVICE DRIVER.
   264                                  ISSPEC	       EQU   0010H	    ;BIT 4 - THIS DEVICE IS SPECIAL
   265                                  ISCLOCK        EQU   0008H	    ;BIT 3 - THIS DEVICE IS THE CLOCK DEVICE.
   266                                  ISNULL	       EQU   0004H	    ;BIT 2 - THIS DEVICE IS THE NULL DEVICE.
   267                                  ISCOUT	       EQU   0002H	    ;BIT 1 - THIS DEVICE IS THE CONSOLE OUTPUT.
   268                                  ISCIN	       EQU   0001H	    ;BIT 0 - THIS DEVICE IS THE CONSOLE INPUT.
   269                                  
   270                                  
   271                                  ; 19/03/2018
   272                                  
   273                                  ;*********************************************************************
   274                                  ;	BDS structure for mini disk
   275                                  ;*********************************************************************	  
   276                                  									  
   277                                  struc	BDSM	; BDSM_type							  
   278 00000000 <res 00000002>          .mLink:		resw	1 ; DW -1		;Link to next structure   
   279 00000002 <res 00000002>          		resw	1 ; DW ?						  
   280 00000004 <res 00000001>          .mDriveNum:	resb	1 ; DB 80h		;Int 13 Drive Number	  
   281 00000005 <res 00000001>          .mDriveLet:	resb	1 ; DB 3		;Logical Drive Number	  
   282 00000006 <res 00000002>          .mBytePerSec:	resw 	1 ; DW 512						  
   283 00000008 <res 00000001>          .mSecPerClus:	resb	1 ; DB 1		;Sectors/allocation unit  
   284 00000009 <res 00000002>          .mRESSEC:	resw	1 ; DW 1		;Reserved sectors for DOS 
   285 0000000B <res 00000001>          .mcFAT:		resb	1 ; DB 2		;No. of allocation tables 
   286 0000000C <res 00000002>          .mcDIR:		resw	1 ; DW 16		;Number of directory entries
   287 0000000E <res 00000002>          .mDRVLIM:	resw 	1 ; DW 0		;Num of sectors (at 512 bytes each)
   288 00000010 <res 00000001>          .mMediad:	resb	1 ; DB 11111000b	;Media descriptor	  
   289 00000011 <res 00000002>          .mcSecFat:	resw 	1 ; DW 1		;Number of FAT sectors	  
   290 00000013 <res 00000002>          .mSECLIM:	resw 	1 ; DW 0		;Sector limit		  
   291 00000015 <res 00000002>          .mHDLIM:	resw	1 ; DW 0		;Head limit		  
   292 00000017 <res 00000002>          .mHIDSEC:	resw 	1 ; DW 0		;Hidden sector count	  
   293 00000019 <res 00000001>          .mFatSiz:	resb 	1 ; DB 0		;TRUE => bigfat 	  
   294 0000001A <res 00000002>          .mOPCNT:	resw	1 ; DW 0		;Open Ref. Count	  
   295 0000001C <res 0000000B>          .mVOLID:	resb   11 ; DB "NO NAME    "    ;Volume ID for this disk  
   296 00000027 <res 00000001>          		resb 	1 ; DB 0		;ASCIZII for "NO NAME    "
   297 00000028 <res 00000001>          .mFormFactor:	resb 	1 ; DB 3		;Form Factor		  
   298 00000029 <res 00000002>          .mFLAGS:	resw	1 ; DW 0020H		;Various Flags		  
   299 0000002B <res 00000002>          .mcCyln:	resw	1 ; DW 40		;max number of cylinders  
   300 0000002D <res 0000001F>          .mRecBPB:	resb   31 ; DB 31 DUP (0) 	;Recommended BPB for drive
   301 0000004C <res 00000001>          .mTrack:	resb	1 ; DB -1						  
   302 0000004D <res 00000002>          .isMini:	resw	1 ; DW 1		;Overlapping TIM_LOH	  
   303 0000004F <res 00000002>          .Hidden_Trks:	resw 	1 ; DW 0		;Overlapping TIM_HIH	  
   304                                  									  
   305                                  ;.TIM_LOH:	resw	1 ; DW -1		;Keep these two contiguous (?)   
   306                                  ;.TIM_HIH:	resw	1 ; DW -1
   307                                  .size:							  
   308                                  
   309                                  endstruc
   310                                  							  
   311                                  ;******************************************************************************
   312                                  Max_mini_dsk_num equ	23		; Max # of mini disk bios can support
   313                                  
   314                                  
   315                                  KERNEL_SEGMENT	equ 0070h  ; Retro DOS v2.0 - 17/03/2018
   316                                  
   317                                  ;-----------------------------------------------------------------------------
   318                                  ; Start of code
   319                                  ;-----------------------------------------------------------------------------
   320                                  
   321                                          	[ORG 0]			; segment 0x0060
   322                                  
   323                                  ;-----------------------------------------------------------------------------
   324                                  ; MSDATA.INC - MSDOS 3.3 BIOS - 24/07/1987
   325                                  ;-----------------------------------------------------------------------------
   326                                  ; 21/03/2018 - Retro DOS v2.0
   327                                  
   328                                  START$:
   329 00000000 E90D0A                  		JMP	INIT		; START$ patch by init to point to
   330                                  					; hdrive BPB
   331                                  
   332                                  SYS_INIT_START EQU SYSINIT_START - START$
   333                                  KERNEL_BYTES EQU END_OF_KERNEL - START$
   334                                  MSDOS_BIN_ADDRESS EQU MSDOS_BIN_OFFSET - START$
   335                                  
   336                                  %define SYSINITSEG SYS_INIT_START >> 4  ; 26/03/2018
   337                                  %define MSDOS_BIN_SEGMENT MSDOS_BIN_ADDRESS >> 4 ; 26/03/2018 
   338                                  %define KERNEL_SIZE KERNEL_BYTES >> 1 ; Retro DOS v2.0 - 26/03/2018
   339                                  
   340                                  
   341                                  ;----------------------------------------------------------------------------
   342                                  ;
   343                                  ;		Command Jump Tables
   344                                  ;
   345                                  ;     These tables hold the entry points for the various service routines
   346                                  ; for the different drivers.  The index in the table is the command code for
   347                                  ; that funcion plus two.  For example the command code for Read (input) is 4,
   348                                  ; The 6th (4 plus 2) entry in the table DSKTBL is DSK$READ - the command to
   349                                  ; read a disk.	Commands which do not exist for a device are filled with
   350                                  ; exit (e.g. MediaCheck for CONTBL).  The first entry in the table is the
   351                                  ; largest command code implemented for that device.  This value is used
   352                                  ; for error checking.  If new command codes are added then the first entry
   353                                  ; in the table must be incremented.
   354                                  ;
   355                                  ;	BEWARE - These tables overlap somewhat! -c.p.
   356                                  ;
   357                                  
   358                                  
   359 00000003 90                      align 2
   360                                  
   361                                  		; 08/04/2018
   362                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
   363                                  		; ((Disassembler: IDA Pro Free))
   364                                  
   365                                  ;
   366                                  ; Disk:
   367                                  ;
   368                                  
   369                                  DSKTBL:
   370 00000004 [C608]                  		DW	DSK$INIT	; Code	0: INIT
   371 00000006 [1C06]                  		DW	MEDIA$CHK	; code	1: Media Check
   372 00000008 [8506]                  		DW	GET$BPB 	; code	2: BUILD BPB
   373 0000000A [CF03]                  		DW	CMDERR		; code	3: IOCTL input
   374 0000000C [EB06]                  		DW	DSK$READ	; code	4: INPUT
   375 0000000E [CB03]                  		DW	BUS$EXIT	; code	5: NONDESTRUCITVE INPUT, NO WAIT
   376 00000010 [E503]                  		DW	EXIT		; code	6: INPUT STATUS
   377 00000012 [E503]                  		DW	EXIT		; code	7: INPUT FLUSH
   378 00000014 [D906]                  		DW	DSK$WRIT	; code	8: OUTPUT
   379 00000016 [D006]                  		DW	DSK$WRITV	; code	9: OUTPUT with verify
   380                                  
   381                                  ;
   382                                  ; Console:
   383                                  ;
   384                                  
   385                                  CONTBL:
   386 00000018 [E503]                  		DW	EXIT
   387 0000001A [E503]                  		DW	EXIT
   388 0000001C [E503]                  		DW	EXIT
   389 0000001E [CF03]                  		DW	CMDERR
   390 00000020 [0B04]                  		DW	CON$READ
   391 00000022 [3504]                  		DW	CON$RDND
   392 00000024 [E503]                  		DW	EXIT
   393 00000026 [5A04]                  		DW	CON$FLSH
   394 00000028 [7104]                  		DW	CON$WRIT
   395 0000002A [7104]                  		DW	CON$WRIT
   396                                  
   397                                  ;
   398                                  ; Auxilary:
   399                                  ;
   400                                  
   401                                  AUXTBL:
   402 0000002C [E503]                  		DW	EXIT
   403 0000002E [E503]                  		DW	EXIT
   404 00000030 [E503]                  		DW	EXIT
   405 00000032 [CF03]                  		DW	CMDERR
   406 00000034 [8504]                  		DW	AUX$READ
   407 00000036 [AE04]                  		DW	AUX$RDND
   408 00000038 [E503]                  		DW	EXIT
   409 0000003A [E704]                  		DW	AUX$FLSH
   410 0000003C [F004]                  		DW	AUX$WRIT
   411 0000003E [F004]                  		DW	AUX$WRIT
   412 00000040 [D004]                  		DW	AUX$WRST
   413                                  
   414                                  ;
   415                                  ; Clock:
   416                                  ;
   417                                  
   418                                  TIMTBL:
   419 00000042 [E503]                  		DW	EXIT
   420 00000044 [E503]                  		DW	EXIT
   421 00000046 [E503]                  		DW	EXIT
   422 00000048 [CF03]                  		DW	CMDERR
   423 0000004A [C105]                  		DW	TIM$READ
   424 0000004C [CB03]                  		DW	BUS$EXIT
   425 0000004E [E503]                  		DW	EXIT
   426 00000050 [E503]                  		DW	EXIT
   427 00000052 [6005]                  		DW	TIM$WRIT
   428 00000054 [6005]                  		DW	TIM$WRIT
   429                                  
   430                                  ;
   431                                  ; Printer:
   432                                  ;
   433                                  
   434                                  PRNTBL:
   435 00000056 [E503]                  		DW	EXIT			;INIT
   436 00000058 [E503]                  		DW	EXIT
   437 0000005A [E503]                  		DW	EXIT
   438 0000005C [CF03]                  		DW	CMDERR
   439 0000005E [DC03]                  		DW	EXIT$ZER		;INDICATE ZERO CHARS READ
   440 00000060 [CB03]                  		DW	BUS$EXIT
   441 00000062 [E503]                  		DW	EXIT
   442 00000064 [E503]                  		DW	EXIT
   443 00000066 [1405]                  		DW	PRN$WRIT
   444 00000068 [1405]                  		DW	PRN$WRIT
   445 0000006A [3005]                  		DW	PRN$STAT
   446 0000006C [E503]                  		DW	EXIT
   447                                  
   448                                  ;
   449                                  ; PTRSAV - pointer save
   450                                  ;
   451                                  ;   This variable holds the pointer to the Request Header passed by a
   452                                  ; program wishing to use a device driver.  When the strategy routine is
   453                                  ; called it puts the address of the Request header in this variable and
   454                                  ; returns.
   455                                  ;
   456                                  
   457                                  	;EVENB
   458                                  PTRSAV:
   459 0000006E 00000000                		DD	0
   460                                  
   461                                  AUXBUF:
   462                                  		;DB	0,0,0,0	; SET OF 1 BYTE BUFFERS FOR COM 1,2,3, AND 4
   463 00000072 0000                    		DB	0, 0  ; 08/04/2018 (IBMDOS 2.1)
   464                                  
   465                                  ;
   466                                  ; AUXNUM holds the number of the printer or AUX device requested.  For
   467                                  ; example if printer 2 was called (PRN2$IN) AUXNUM is set to be one; with
   468                                  ; line printer 3 AUXNUM is set to 2.  With this set the printer device driver
   469                                  ; can tell which printer to command applies to.
   470                                  ;
   471                                  ; WARNING!!!  These are addressed together in GETDX
   472                                  ;
   473                                  
   474                                  	;EVENB
   475                                  
   476                                  AUXNUM:
   477 00000074 00                      		DB	0
   478 00000075 00                      		DB	0
   479                                  
   480                                  ;
   481                                  ; Device Header for the CON Device Driver
   482                                  ;
   483                                  
   484                                  	;EVENB
   485                                  
   486                                  ;align 2
   487                                  
   488                                  CONHeader:
   489                                  		;DD	AUXDEV2
   490 00000076 [8800]                  		DW	AUXDEV2
   491 00000078 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   492 0000007A 1380                    		DW	1000000000010011B	; Con in and con out + special
   493 0000007C [5603]                  		DW	STRATEGY		; Strategy entry point
   494 0000007E [6103]                  		DW	CON$IN			; interrupt entry point
   495 00000080 434F4E2020202020        		DB	'CON     '              ; device name
   496                                  
   497                                  
   498                                  ;
   499                                  ; Device Header for device "AUX"
   500                                  ;
   501                                  
   502                                  	;EVENB
   503                                  ;align 2
   504                                  
   505                                  AUXDEV2:					;HEADER FOR DEVICE "AUX"
   506                                  		;DD	PRNDEV2
   507 00000088 [9A00]                  		DW	PRNDEV2
   508 0000008A 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   509 0000008C 0080                    		DW	1000000000000000B	; attribute word, character device
   510 0000008E [5603]                  		DW	STRATEGY		; device strategy routine
   511 00000090 [6703]                  		DW	AUX0$IN 		; device interrupt routine
   512 00000092 4155582020202020        		DB	'AUX     '              ; device name
   513                                  
   514                                  
   515                                  ;
   516                                  ; Device Header for device PRN
   517                                  ;
   518                                  
   519                                  	;EVENB
   520                                  ;align 2
   521                                  
   522                                  PRNDEV2:					 ;HEADER FOR DEVICE "PRN"
   523                                  		;DD	TIMDEV
   524 0000009A [AC00]                  		DW	TIMDEV
   525 0000009C 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   526                                  		;DW	CHARDEV + OUTTILBUSY + DEV320
   527 0000009E 0080                    		DW	1000000000000000B	; 08/04/2018 (IBMDOS 2.1)
   528 000000A0 [5603]                  		DW	STRATEGY
   529 000000A2 [7803]                  		DW	PRN0$IN
   530 000000A4 50524E2020202020        		DB	'PRN     '
   531                                  
   532                                  
   533                                  ;
   534                                  ; Device Header for device CLOCK$
   535                                  ;
   536                                  
   537                                  	;EVENB
   538                                  ;align 2
   539                                  
   540                                  TIMDEV:
   541                                  		;DD	DSKDEV
   542 000000AC [BE00]                  		DW	DSKDEV
   543 000000AE 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   544 000000B0 0880                    		DW	1000000000001000B
   545 000000B2 [5603]                  		DW	STRATEGY
   546 000000B4 [8D03]                  		DW	TIM$IN
   547 000000B6 434C4F434B242020        		DB	'CLOCK$  '
   548                                  
   549                                  ;
   550                                  ; Device Header for disk devices
   551                                  ;
   552                                  ;	Device attribute bits:
   553                                  ;		Bit 6 - DOS 3.2 Bit
   554                                  ;
   555                                  
   556                                  	;EVENB
   557                                  ;align 2
   558                                  
   559                                  DSKDEV:
   560                                  		;DD	COM1DEV
   561 000000BE [DC00]                  		DW	COM1DEV
   562 000000C0 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   563                                  		;DW	0000100001000000B	; DOS 3.2
   564 000000C2 0000                    		DW	0		; 08/04/2018 (IBMDOS 2.1)
   565 000000C4 [5603]                  		DW	STRATEGY		; strategy routine
   566 000000C6 [9303]                  		DW	DSK$IN			; Interrupt entry point
   567                                  
   568                                  ;
   569                                  ; maximum number of drives
   570                                  ;
   571                                  
   572                                  DRVMAX:
   573 000000C8 04                      		DB	4
   574                                  
   575                                  ;
   576                                  ; Last drive accessed
   577                                  ;
   578                                  
   579                                  		; 09/04/2018
   580                                  ;MEDIACHK_DRV:  ;; 13/04/2018
   581                                  ;		DB	0
   582                                  		
   583                                  TIM_LO:
   584 000000C9 FFFF                    		Dw	0FFFFh
   585                                  TIM_HI:
   586 000000CB FFFF                    		Dw	0FFFFh
   587                                  WRTVERIFY:
   588                                  RFLAG:
   589 000000CD 02                      		DB	ROMRead		;2 for read, 3 for write
   590                                  VERIFY:
   591 000000CE 00                      		DB	0		;1 if verify after write
   592                                  Single:
   593 000000CF 00                      		DB	0
   594                                  CURSECBUF:
   595 000000D0 00                      		DB	0
   596                                  SECCNT:
   597 000000D1 0000                    		DW	0
   598                                  HARDNUM:
   599 000000D3 63                      		DB	99		;logical drive number of first hardfile	
   600                                  DRVNUM:
   601 000000D4 00                      		DB	0
   602                                  CURHD:
   603 000000D5 00                      		DB	0
   604                                  CURSEC:
   605 000000D6 00                      		DB	0
   606                                  CURTRK:
   607 000000D7 0000                    		DW	0
   608                                  SPSAV:
   609 000000D9 0000                    		DW	0
   610                                  
   611                                  ;
   612                                  ; Device Header for device "COM1"
   613                                  ;
   614                                  
   615                                  	;EVENB
   616                                  
   617 000000DB 90                      align 2
   618                                  
   619                                  COM1DEV:
   620                                  		;DD	LPT1DEV
   621 000000DC [EE00]                  		DW	LPT1DEV
   622 000000DE 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   623 000000E0 0080                    		DW	1000000000000000B ; attribute word, character device
   624 000000E2 [5603]                  		DW	STRATEGY	; device strategy routine
   625 000000E4 [6703]                  		DW	AUX0$IN 	; device interrupt routine
   626 000000E6 434F4D3120202020        		DB	'COM1    '	; device name
   627                                  
   628                                  
   629                                  ;
   630                                  ; Device Header for device LPT1
   631                                  ;
   632                                  
   633                                  	;EVENB
   634                                  ;align 2
   635                                  
   636                                  LPT1DEV:
   637                                  		;DD	LPT2DEV
   638 000000EE [0001]                  		DW	LPT2DEV
   639 000000F0 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   640                                  		;DW	CHARDEV + OUTTILBUSY + DEV320
   641 000000F2 0080                    		DW	1000000000000000B ; 08/04/2018 (IBMDOS 2.1)
   642 000000F4 [5603]                  		DW	STRATEGY
   643 000000F6 [7803]                  		DW	PRN0$IN
   644 000000F8 4C50543120202020        		DB	'LPT1    '
   645                                  
   646                                  
   647                                  ;
   648                                  ; Device Header for device LPT2
   649                                  ;
   650                                  
   651                                  	;EVENB
   652                                  ;align 2
   653                                  LPT2DEV:
   654                                  		;DD	LPT3DEV
   655 00000100 [1201]                  		DW	LPT3DEV
   656 00000102 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   657                                  		;DW	CHARDEV + OUTTILBUSY + DEV320
   658 00000104 0080                    		DW	1000000000000000B ; 08/04/2018 (IBMDOS 2.1)
   659 00000106 [5603]                  		DW	STRATEGY
   660 00000108 [7E03]                  		DW	PRN1$IN
   661 0000010A 4C50543220202020        		DB	'LPT2    '
   662                                  
   663                                  ;
   664                                  ; Device Header for device LPT3
   665                                  ;
   666                                  
   667                                  	;EVENB
   668                                  ;align 2
   669                                  
   670                                  LPT3DEV:
   671                                  		;DD	COM2DEV
   672 00000112 [2401]                  		DW	COM2DEV
   673 00000114 7000                    		DW	KERNEL_SEGMENT ; 27/03/2018
   674                                  		;DW	CHARDEV + OUTTILBUSY + DEV320
   675 00000116 0080                    		DW	1000000000000000B ; 08/04/2018 (IBMDOS 2.1)
   676 00000118 [5603]                  		DW	STRATEGY
   677 0000011A [8403]                  		DW	PRN2$IN
   678 0000011C 4C50543320202020        		DB	'LPT3    '
   679                                  
   680                                  
   681                                  ;
   682                                  ; Device Header for device "COM2"
   683                                  ;
   684                                  
   685                                  	;EVENB
   686                                  
   687                                  ;align 2
   688                                  
   689                                  COM2DEV:
   690 00000124 FFFF                    		Dw	-1 ; 08/04/2018 (IBMDOS 2.1)
   691 00000126 7000                    		DW	KERNEL_SEGMENT
   692 00000128 0080                    		DW	1000000000000000B	; attribute word, character device
   693 0000012A [5603]                  		DW	STRATEGY		; device strategy routine
   694 0000012C [6D03]                  		DW	AUX1$IN 		; device interrupt routine
   695 0000012E 434F4D3220202020        		DB	'COM2    '              ; device name
   696                                  
   697                                  
   698                                  ; Some floppy drives do not have changeline support.  The result is a
   699                                  ; large amount of inefficiency in the code.  A media-check always returns
   700                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
   701                                  ; always discard any cached data.
   702                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
   703                                  ; The following three items are used to do this.  The logical door latch is
   704                                  ; based on the premise that it is not physically possible to change floppy
   705                                  ; disks in a drive in under two seconds (most people take about 10).  The
   706                                  ; logical door latch is implemented by saving the time of the last successful
   707                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
   708                                  ; current time is compared to the saved time.  If less than two seconds have
   709                                  ; passed then the value "No Change" is returned.  If more than two seconds
   710                                  ; have passed the value "Don't Know" is returned.
   711                                  ;    There is one complecation to this algorithm.  Some programs change the
   712                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
   713                                  ; This possiblity is detected by counting the number of disk operations
   714                                  ; which occur without any time passing.  If this count exceeds the value of
   715                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
   716                                  ; Know".  The variable "AccessCount" is used to keep track of the number
   717                                  ; of disk operation which occur without the time changing.
   718                                  ;
   719                                  
   720                                  AccessCount:
   721 00000136 00                      		DB	0		; number of times media check called
   722                                  TIM_DRV:
   723 00000137 FF                      		DB	-1		; time when last disk I/O was performed
   724                                  ;
   725                                  ;FlagBits:
   726                                  ;		DW	0		; Bits to set in flag field when doing
   727                                  ;					; a Set_Changed_DL
   728                                  ;
   729                                  ;MedByt:
   730                                  ;		DB	0		; hold media byte from floppy
   731                                  ;
   732                                  ;		;EVENB
   733                                  ;align 2
   734                                  ;WRTVERIFY:
   735                                  ;RFLAG:
   736                                  ;		DB	ROMRead		;2 for read, 3 for write
   737                                  ;VERIFY:
   738                                  ;		DB	0		;1 if verify after write
   739                                  ;
   740                                  ;SECCNT:
   741                                  ;		DW	0
   742                                  ;
   743                                  ;
   744                                  ;HARDNUM:
   745                                  ;		DB	99		;logical drive number of first hardfile
   746                                  
   747                                  ;
   748                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
   749                                  ; have to be made to read the diskette.  Consequently a large head settle
   750                                  ; time was always used in the I/O operations.  To get around this problem
   751                                  ; we need to continually adjust the head settle time.  The following
   752                                  ; algorithm is used:
   753                                  ;
   754                                  ;   Get the current head settle value.
   755                                  ;   If it is 1, then
   756                                  ;	set slow = 15
   757                                  ;   else
   758                                  ;	set slow = value
   759                                  ;   ...
   760                                  ;   if we are seeking and writing then
   761                                  ;	use slow
   762                                  ;   else
   763                                  ;	use fast
   764                                  ;   ...
   765                                  ;   restore current head settle value
   766                                  ;
   767                                  
   768                                  ;MotorStartup:
   769                                  ;		DB	0			; value from table
   770                                  ;SettleCurrent:
   771                                  ;		DB	0			; value from table
   772                                  ;SettleSlow:
   773                                  ;		DB	0			; slow settle value
   774                                  ;
   775                                  ;NextSpeed:
   776                                  ; 		DB	0			; value of speed to be used
   777                                  ;
   778                                  ;Save_head_sttl:
   779                                  ;		DB	0			;used by READ_SECTOR routine
   780                                  ;
   781                                  
   782                                  EOT:
   783 00000138 09                      		DB	9
   784                                  
   785                                  ;
   786                                  ; pointer to Disk Parameter Table
   787                                  ;
   788                                  ;
   789                                  ;		;EVENB
   790                                  ;align 2
   791                                  ;DPT:
   792                                  ;		dd	0
   793                                  
   794                                  ; 23/03/2018
   795                                  
   796                                  ;
   797                                  ; The following two sets of variables are used to hold values for
   798                                  ; disk I/O operations
   799                                  ; Keep the next two items contiguous - see IOCTL_Block for reason
   800                                  
   801                                  ;
   802                                  ;CURSEC:	
   803                                  ;		DB	0			; current sector
   804                                  ;CURHD:
   805                                  ;		DB	0			; current head
   806                                  ;CURTRK:
   807                                  ;		DW	0			; current track
   808                                  ;SPSAV:
   809                                  ;		DW	0			; save the stack pointer
   810                                  
   811                                  ;
   812                                  ; The following are used for IOCTL function calls
   813                                  ;
   814                                  
   815                                  ;FORMT_EOT:
   816                                  ;		DB	8			; EOT used for format
   817                                  ;HDNUM:
   818                                  ;		DB	0			; Head number
   819                                  ;TRKNUM:
   820                                  ;		DW	0			; Track being manipulated
   821                                  ;GAP_PATCH:
   822                                  ;		DB	50h			; Format gap patched into DPT
   823                                  
   824                                  ;
   825                                  ; Disk errors returned from the IBM rom
   826                                  ;
   827                                  
   828                                  ERRIN:
   829 00000139 80                      		DB	80H			; no response
   830 0000013A 40                      		DB	40H			; seek failure
   831 0000013B 10                      		DB	10H			; bad CRC
   832 0000013C 08                      		DB	8			; DMA overrun
   833 0000013D 06                      		DB	6			; media change
   834 0000013E 04                      		DB	4			; sector not found
   835 0000013F 03                      		DB	3			; write attempt to write-protect disk
   836                                  LSTERR:
   837 00000140 00                      		DB	0			; all other errors
   838                                  
   839                                  ;
   840                                  ; returned error code corresponding to above errors
   841                                  ;
   842                                  
   843                                  ERROUT:
   844 00000141 02                      		DB	2			; no response
   845 00000142 06                      		DB	6			; seek failure
   846 00000143 04                      		DB	4			; bad CRC
   847 00000144 04                      		DB	4			; DMA overrun
   848 00000145 0F                      		DB	15			; invalid media change
   849 00000146 08                      		DB	8			; sector not found
   850 00000147 00                      		DB	0			; write attempt on write-protect disk
   851 00000148 0C                      		DB	12			; general error
   852                                  
   853                                  NUMERR	EQU	ERROUT-ERRIN
   854                                  
   855                                  
   856 00000149 90                      align 2
   857                                  
   858                                  ;-------------------------------------------------------------
   859                                  ;
   860                                  ; DiskSector is a 512 byte sector into which the boot sector
   861                                  ; is read.  It is also used as read sector for DMA check for
   862                                  ; hard disk.
   863                                  
   864                                  DiskSector:
   865                                  		;db	11 dup(?)	   ; take care of 3 jump bytes plus OEM name.
   866 0000014A 00<rept>                		times	11 db 0
   867                                  BPB_In_Sector:
   868 00000155 0000                    		dw	0
   869                                  SECPERCLUSINSECTOR:
   870 00000157 00                      		db	0
   871 00000158 0000                    		dw	0
   872 0000015A 00                      		db	0
   873 0000015B 0000                    		dw	0
   874 0000015D 0000                    		dw	0
   875                                  mediabyte:
   876 0000015F 00                      		db	0
   877 00000160 0000                    		dw	0
   878 00000162 0000                    		dw	0
   879 00000164 0000                    		dw	0
   880 00000166 0000                    		dw	0
   881 00000168 00                      		db	0
   882                                  		;db	512-($-DiskSector) dup (?)
   883 00000169 00<rept>                		times	512-($-DiskSector) db 0
   884                                  
   885                                  	
   886                                  ;
   887                                  ; ALTAH is a single character buffer used to handle special keys.
   888                                  ;
   889                                  
   890                                  ALTAH:
   891 0000034A 00                      		DB	0			;Special key handling
   892                                  
   893                                  ;
   894                                  ; The following variable can be modified via IOCTL sub-function 16. In this
   895                                  ; way, the wait can be set to suit the speed of the particular printer being
   896                                  ; used. One for each printer device.
   897                                  ;
   898                                  
   899                                  PRINTDEV:
   900 0000034B 00                      		DB	0		; Index into following array
   901                                  
   902                                  ;EVENB
   903                                  align 2
   904                                  
   905                                  WAIT_COUNT:
   906                                  		;DW	4 dup (50h)	; Array of Retry counts for printer
   907 0000034C 5000<rept>              		times	4 dw 50h	 	
   908                                  
   909                                  ;
   910                                  ; DAYCNT is the number of days since 1-1-80.
   911                                  ; Each time the clock is read it is necessary to check if another day has
   912                                  ; passed.  The ROM only returns the day rollover once so if it is missed
   913                                  ; the time will be off by a day.
   914                                  ;
   915                                  
   916                                  ;EVENB
   917                                  ;align 2
   918                                  
   919                                  DAYCNT:
   920 00000354 0000                    		DW	0
   921                                  
   922                                  ;-----------------------------------------------------------------------------
   923                                  ; MSBIO1.ASM  - MSDOS 3.3 - 24/07/1987
   924                                  ;-----------------------------------------------------------------------------
   925                                  ; 23/03/2018 - Retro DOS v2.0
   926                                  
   927                                  ;
   928                                  ; The next nine equ's describe the offset into the request header for
   929                                  ; different information.  For example STATUS is in byte 3 of the request
   930                                  ; header (starting count at zero).
   931                                  ;
   932                                  
   933                                  CMDLEN	equ	0			; length of this command
   934                                  UNIT	equ	1			; sub unit specifier
   935                                  CMD	equ	2			; command code
   936                                  STATUS	equ	3			; status
   937                                  MEDIA	equ	13			; media descriptor
   938                                  TRANS	equ	14			; transfer address
   939                                  COUNT	equ	18			; count of blocks or characters
   940                                  START	equ	20			; first block to transfer
   941                                  EXTRA	equ	22			; Usually pointer to Vol Id for error 15
   942                                  
   943                                  ;
   944                                  ; Strategy is the strategy entry point for all default bio device drivers.
   945                                  ; All that is done is to save the pointer to the request header in the
   946                                  ; variable PtrSav.
   947                                  ;
   948                                  
   949                                  STRATEGY:
   950 00000356 2E891E[6E00]            		mov	[CS:PTRSAV],BX
   951 0000035B 2E8C06[7000]            		mov	[CS:PTRSAV+2],ES
   952 00000360 CB                      		retf
   953                                  
   954                                  ;------------------------------------------------------------------------------
   955                                  ;
   956                                  ;			Device entry point
   957                                  ;
   958                                  ; The following ten pieces of code are the interrupt entry points for the
   959                                  ; default device drivers.  These small pieces of code have two jobs.
   960                                  ;
   961                                  ;	1) Make SI point to the beginning of the proper command jump  table.
   962                                  ;	   SI must first be pushed to preserve original contents.
   963                                  ;	2) If the call is an AUX or a printer save the number of the
   964                                  ;	   request in AL.  AL is moved to AUXNUM below.
   965                                  ;
   966                                  
   967                                  ;
   968                                  ; Con device:
   969                                  ;
   970                                  CON$IN:
   971 00000361 56                      		PUSH	SI
   972 00000362 BE[1800]                		MOV	SI,CONTBL
   973 00000365 EB30                    		JMP	SHORT ENTRY
   974                                  AUX0$IN:
   975 00000367 56                      		PUSH	SI
   976 00000368 50                      		PUSH	AX
   977 00000369 30C0                    		XOR	AL,AL
   978 0000036B EB06                    		JMP	SHORT AUXENT
   979                                  AUX1$IN:
   980 0000036D 56                      		PUSH	SI
   981 0000036E 50                      		PUSH	AX
   982 0000036F B001                    		MOV	AL,1
   983 00000371 EB00                    		JMP	short AUXENT
   984                                  
   985                                  AUXENT:
   986 00000373 BE[2C00]                		MOV	SI,AUXTBL
   987 00000376 EB20                    		JMP	SHORT ENTRY1
   988                                  
   989                                  PRN0$IN:
   990 00000378 56                      		PUSH	SI
   991 00000379 50                      		PUSH	AX
   992 0000037A 30C0                    		XOR	AL,AL
   993 0000037C EB0A                    		JMP	SHORT PRNENT
   994                                  PRN1$IN:
   995 0000037E 56                      		PUSH	SI
   996 0000037F 50                      		PUSH	AX
   997 00000380 B001                    		MOV	AL,1
   998 00000382 EB04                    		JMP	SHORT PRNENT
   999                                  PRN2$IN:
  1000 00000384 56                      		PUSH	SI
  1001 00000385 50                      		PUSH	AX
  1002 00000386 B002                    		MOV	AL,2
  1003                                  PRNENT:
  1004 00000388 BE[5600]                		MOV	SI,PRNTBL
  1005 0000038B EB0B                    		JMP	SHORT ENTRY1
  1006                                  
  1007                                  TIM$IN:
  1008 0000038D 56                      		PUSH	SI
  1009 0000038E BE[4200]                		MOV	SI,TIMTBL
  1010 00000391 EB04                    		JMP	SHORT ENTRY
  1011                                  
  1012                                  DSK$IN:
  1013 00000393 56                      		PUSH	SI
  1014 00000394 BE[0400]                		mov	SI,DSKTBL
  1015                                  
  1016                                  ;
  1017                                  ;  This section is the prolog to all default device drivers.  All registers
  1018                                  ; are saved, the registers are filled with information from the request header,
  1019                                  ; and the routine from the jump table is called. Error checking is done
  1020                                  ; to assure command code is valid. Before calling the routine in the
  1021                                  ; jump table the register are:
  1022                                  ;
  1023                                  ;	AH = Media Descriptor
  1024                                  ;	AL = Unit Code
  1025                                  ;	BX = offset to PTRSAV (request header is therefore at DS:BX)
  1026                                  ;	CX = count from request header
  1027                                  ;	DX = start sector
  1028                                  ;	ES:DI = transfer address
  1029                                  ;	SI = points to jump table
  1030                                  ;	DS = points to this segment
  1031                                  ;
  1032                                  ; Once the routine finishes its job it jumps back to one of the eight
  1033                                  ; pieces of code below labeled Exit Points.
  1034                                  ;
  1035                                  
  1036                                  ENTRY:
  1037 00000397 50                      		push	AX
  1038                                  ENTRY1:
  1039 00000398 51                      		push	CX			; save all registers
  1040 00000399 52                      		push	DX
  1041 0000039A 57                      		push	DI
  1042 0000039B 55                      		push	BP
  1043 0000039C 1E                      		push	DS
  1044 0000039D 06                      		push	ES
  1045 0000039E 53                      		push	BX
  1046                                  
  1047 0000039F 2EA2[7400]              		mov	[CS:AUXNUM],AL		; save choice of AUX/PRN device
  1048                                  
  1049 000003A3 2EC51E[6E00]            		lds	BX,[CS:PTRSAV]		; get pointer to I/O packet
  1050                                  	
  1051 000003A8 8A4701                  		mov	AL,[BX+UNIT]		;AL = UNIT CODE
  1052 000003AB 8A670D                  		mov	AH,[BX+MEDIA]		;AH = MEDIA DESCRIP
  1053 000003AE 8B4F12                  		mov	CX,[BX+COUNT]		;CX = COUNT
  1054 000003B1 8B5714                  		mov	DX,[BX+START]		;DX = START SECTOR
  1055                                  
  1056 000003B4 97                      		xchg	DI,AX
  1057 000003B5 8A4702                  		mov	AL,[BX+CMD]
  1058                                  		; 11/04/2018
  1059                                  		;cmp	AL,[CS:SI]		; is command code a valid number?
  1060                                  		;ja	SHORT CMDERR		; no, jump to handle error
  1061                                  
  1062                                  		;XOR	AH,AH
  1063                                  		;CBW				; note that AL <= 15 means OK
  1064                                  		;shl	AX,1
  1065                                  		;add	SI,AX			; get SI to point to address of routine
  1066                                  		
  1067                                  		; 10/04/2018
  1068 000003B8 3C0B                    		CMP	AL,11
  1069 000003BA 7713                    		JA	SHORT CMDERR
  1070 000003BC 30E4                    		XOR	AH,AH
  1071 000003BE 01C6                    		ADD	SI,AX
  1072 000003C0 01C6                    		ADD	SI,AX
  1073                                  
  1074 000003C2 97                      		xchg	AX,DI			; put proper value back into AX
  1075 000003C3 C47F0E                  		les	DI,[BX+TRANS]		; get ES:DI to point to transfer address
  1076 000003C6 0E                      		push	CS			; get DS equal to CS
  1077 000003C7 1F                      		pop	DS
  1078                                  
  1079 000003C8 FC                      		cld				; clear the direction flag
  1080 000003C9 FF24                    		jmp	WORD [SI]		; go to the command
  1081                                  
  1082                                  
  1083                                  ;=====================================================
  1084                                  ;=
  1085                                  ;=	SUBROUTINES SHARED BY MULTIPLE DEVICES
  1086                                  ;=
  1087                                  ;=====================================================
  1088                                  
  1089                                  ;----------------------------------------------------------
  1090                                  ;
  1091                                  ;		Exit  Points
  1092                                  ;
  1093                                  ; All device driver call return through one of these eight
  1094                                  ; pieces of code.  The code set error and status conditions
  1095                                  ; and then restores the registers.
  1096                                  ;
  1097                                  		
  1098                                  BUS$EXIT:			; device busy exit
  1099                                  
  1100 000003CB B403                    		mov	AH,00000011b		; set error code
  1101 000003CD EB18                    		jmp	SHORT ERR1
  1102                                  CMDERR:
  1103 000003CF B003                    		mov	AL,3			; unknown command error
  1104                                  ERR$CNT:
  1105                                  		;lds	BX,[CS:PTRSAV]
  1106 000003D1 C51E[6E00]              		lds	BX,[PTRSAV]	; 11/04/2018
  1107 000003D5 294F12                  		sub	[BX+COUNT],CX		;# of successful I/O's
  1108                                  ERR$EXIT:
  1109 000003D8 B481                    		mov	AH,10000001b		; mark error and return
  1110 000003DA EB0B                    		jmp	SHORT ERR1
  1111                                  
  1112                                  EXIT$ZER:
  1113                                  		;lds	BX,[CS:PTRSAV]
  1114 000003DC C51E[6E00]              		lds	BX,[PTRSAV]		; IBMDOS 3.3 (IBMBIO.COM)		
  1115 000003E0 31C0                    		xor	AX,AX
  1116 000003E2 894712                  		mov	[BX+COUNT],AX		; indicate no character read
  1117                                  
  1118                                  EXIT:
  1119 000003E5 B401                    		mov	AH,00000001b
  1120                                  ERR1:
  1121                                  		;lds	BX,[CS:PTRSAV]
  1122 000003E7 C51E[6E00]              		lds	BX,[PTRSAV]	; 11/04/2018
  1123 000003EB 894703                  		mov	[BX+STATUS],AX		; mark operation complete
  1124                                  
  1125 000003EE 5B                      		pop	BX			; restore register and return
  1126 000003EF 07                      		pop	ES
  1127 000003F0 1F                      		pop	DS
  1128 000003F1 5D                      		pop	BP
  1129 000003F2 5F                      		pop	DI
  1130 000003F3 5A                      		pop	DX
  1131 000003F4 59                      		pop	CX
  1132 000003F5 58                      		pop	AX
  1133 000003F6 5E                      		pop	SI
  1134 000003F7 CB                      		retf
  1135                                  
  1136                                  
  1137                                  ;-------------------------------------------------------------
  1138                                  ;
  1139                                  ; Chrout - write out character in AL using current attribute
  1140                                  ;
  1141                                  ;   called via int 29h
  1142                                  ;
  1143                                  
  1144                                  CHROUT	equ	29H
  1145                                  
  1146                                  OUTCHR:
  1147                                  		; 08/04/2018 (IBMDOS 2.1, IBMBIO.COM) ; *
  1148 000003F8 FB                      		sti ; *
  1149 000003F9 50                      		push	AX			; preserve affect registers
  1150                                  		;push	SI
  1151                                  		;push	DI
  1152                                  		;push	BP
  1153 000003FA 53                      		push	BX			;
  1154 000003FB B40E                    		mov	AH,0Eh 			; set command to write a character
  1155                                  		;mov	BH,0			;
  1156                                  		;mov	BL,7			; set foreground color
  1157 000003FD BB0700                  		mov	BX,7
  1158 00000400 CD10                    		int	10h			; call rom-bios
  1159 00000402 5B                      		pop	BX			;
  1160                                  		;pop	BP			; restore registers
  1161                                  		;pop	DI
  1162                                  		;pop	SI
  1163 00000403 58                      		pop	AX
  1164 00000404 CF                      		iret
  1165                                  
  1166                                  ;----------------------------------------------
  1167                                  ;
  1168                                  ; Fill DX register with value in AUXNUM
  1169                                  ;
  1170                                  
  1171                                  GETDX:
  1172                                  		; IBMDOS 2.1
  1173                                  		;mov	dl, [AUXNUM]
  1174                                  		;xor	dh,dh
  1175                                  
  1176                                  		; MSDOS 3.3
  1177 00000405 2E8B16[7400]            		mov	DX,[CS:AUXNUM]
  1178 0000040A C3                      		retn
  1179                                  
  1180                                  
  1181                                  ;-----------------------------------------------------------------------------
  1182                                  ; MSCON.ASM - MSDOS 3.3 - 24/07/1987
  1183                                  ;-----------------------------------------------------------------------------
  1184                                  ; 23/03/2018 - Retro DOS v2.0
  1185                                  
  1186                                  ;----------------------------------------------------------------
  1187                                  ;								:
  1188                                  ;	      C O N - CONSOLE DEVICE DRIVER			:
  1189                                  ;								:
  1190                                  ;								:
  1191                                  ;   This file contains the Console Device Driver.  The		:
  1192                                  ; console device driver sends characters to the moniter and	:
  1193                                  ; gets characters from the keyboard.				:
  1194                                  ;								:
  1195                                  ;----------------------------------------------------------------
  1196                                  
  1197                                  
  1198                                  ;----------------------------------------------------------------
  1199                                  ;								:
  1200                                  ;		    Console read routine			:
  1201                                  ;								:
  1202                                  ;----------------------------------------------------------------
  1203                                  ;
  1204                                  
  1205                                  CON$READ:					; if CX is zero, no characters
  1206 0000040B E306                    		jcxz	CON$EXIT		;   to be read -- just exit
  1207                                  CON$LOOP:
  1208 0000040D E80500                  		call	CHRIN			; get char in AL
  1209 00000410 AA                      		stosb				; store char at ES:DI, specified buffer
  1210 00000411 E2FA                    		loop	CON$LOOP		; if CX is non-zero more char to read
  1211                                  CON$EXIT:
  1212 00000413 EBD0                    		jmp	short EXIT		; all done, successful return
  1213                                  
  1214                                  
  1215                                  ;----------------------------------------------------------------
  1216                                  ;								:
  1217                                  ;	    Input single character into AL			:
  1218                                  ;								:
  1219                                  ;----------------------------------------------------------------
  1220                                  CHRIN:
  1221                                  						; set command to read character
  1222 00000415 31C0                    		xor	AX, AX			;  and clear AL
  1223 00000417 8606[4A03]              		xchg	AL,[ALTAH]		; get character & zero ALTAH
  1224 0000041B 08C0                    		or	AL, AL			; see if buffer has a character
  1225 0000041D 7515                    		jnz	short KEYRET		; if so - return this character
  1226                                  						; if not - read single character
  1227 0000041F CD16                    		int	16h			; call ROM-Bios keyboard routine
  1228                                  ALT10:
  1229 00000421 09C0                    		or	AX,AX			; Check for non-key after BREAK
  1230 00000423 74F0                    		jz	short CHRIN
  1231 00000425 3D0072                  		cmp	AX,7200h		; Check for CTRL-PRTSC
  1232 00000428 7502                    		jnz	short ALT15
  1233 0000042A B010                    		mov	AL,16			; indicate prtsc
  1234                                  ALT15:
  1235 0000042C 08C0                    		or	AL,AL			; special case?
  1236 0000042E 7504                    		jnz	short KEYRET		; no, return with character
  1237 00000430 8826[4A03]              		mov	[ALTAH], AH		; yes, store special key
  1238                                  KEYRET:
  1239 00000434 C3                      		RETN
  1240                                  
  1241                                  ;----------------------------------------------------------------
  1242                                  ;								:
  1243                                  ;	   Keyboard non destructive read, no wait		:
  1244                                  ;								:
  1245                                  ; If bit 10 is set by the DOS in the status word of the request :
  1246                                  ; packet, and there is no character in the input buffer, the	:
  1247                                  ; driver issues a system WAIT request to the ROM. On return	:
  1248                                  ; from the ROM, it returns a 'char-not-found' to the DOS.       :
  1249                                  ;								:
  1250                                  ;----------------------------------------------------------------
  1251                                  
  1252                                  ;CONBUSJ:
  1253                                  ;		JMP	CONBUS
  1254                                  
  1255                                  CON$RDND:
  1256 00000435 A0[4A03]                		mov	AL,[ALTAH]		; first see if there is a
  1257 00000438 08C0                    		or	AL,AL			; character in the buffer?
  1258                                  		;jz	short RD1		; with debugging code it is
  1259                                  		;jmp	short RDEXIT		; too far for conditional jump
  1260 0000043A 7515                    		jnz	short RDEXIT
  1261                                  
  1262                                  RD1:				     		; set command to 'see if
  1263 0000043C B401                    		mov	AH, 1	     		; character available'
  1264 0000043E CD16                    		int	16h	     		; call ROM-BIOS keyboard routine
  1265                                  		;jz	short nochr		; with debugging code it is
  1266                                  		;jz	short CONBUSJ
  1267                                  		;jz	short CONBUS
  1268 00000440 7489                    		jz	short BUS$EXIT	
  1269                                  		;jmp	short gotchr		; to far for conditional jump
  1270                                  ;nochr:
  1271                                  		;cmp	short [fHaveK09], 0
  1272                                  		;jz	short CONBUSJ
  1273                                  		;lds	bx,[PTRSAV]		; get pointer to request header
  1274                                  		;test	word [bx+STATUS],0400h	; System WAIT enabled?
  1275                                  		;jz	short CONBUSJ 		; no, get out
  1276                                  
  1277                                  		;mov	AX, 4100h     		; set command for Wait on External
  1278                                  				      		; event and condition type to
  1279                                  				      		; any external event
  1280                                  		;xor	BL,BL			; no timeout value
  1281                                  		;int	15h	      		; call rom-bios sleep function
  1282                                  		;jmp	short CONBUS		; after wait exit to con busy
  1283                                  
  1284                                  gotchr:
  1285 00000442 09C0                    		or	AX, AX			; check for null after break
  1286 00000444 7504                    		JNZ	short NOTBRK		; no, skip down
  1287                                  ; note: AH is already zero, no need to set command
  1288 00000446 CD16                    		int	16h ;SB 		; yes, read the null
  1289 00000448 EBEB                    		Jmp	short CON$RDND		; and get a real status
  1290                                  
  1291                                  NOTBRK:
  1292 0000044A 3D0072                  		cmp	AX, 7200H		; check for ctrl-prtsc
  1293 0000044D 7502                    		jnz	short RDEXIT		; no
  1294 0000044F B010                    		mov	AL, 16			; yes, indicate ctrl-prtsc
  1295                                  
  1296                                  RDEXIT:
  1297 00000451 C51E[6E00]              		lds	BX, [PTRSAV]		; get pointer to request header
  1298 00000455 88470D                  		mov	[BX+MEDIA], AL		; move character into req. header
  1299                                  EXVEC:
  1300 00000458 EB8B                    		jmp	short EXIT		; all done -- successful return
  1301                                  ;CONBUS:
  1302                                  ;		Jmp	short BUS$EXIT		; done -- con device is busy
  1303                                  
  1304                                  
  1305                                  ;----------------------------------------------------------------
  1306                                  ;								:
  1307                                  ;		Keyboard flush routine				:
  1308                                  ;								:
  1309                                  ;----------------------------------------------------------------
  1310                                  
  1311                                  CON$FLSH:
  1312 0000045A E80200                  		call	FLUSH
  1313 0000045D EB86                    		jmp	EXIT
  1314                                  
  1315                                  FLUSH:
  1316 0000045F C606[4A03]00            		mov	byte [ALTAH], 0	; clear out holding buffer
  1317                                  
  1318                                  FlLoop:
  1319                                  				 	; Is there a char there?
  1320 00000464 B401                    		mov	AH, 1	 	; command code for check status
  1321 00000466 CD16                    		int	16h	 	; call rom-bios keyboard routine
  1322                                  					; if z flag is set then no character
  1323 00000468 7406                    		jz	short FlDone	; is ready, buffer is empty -- get out
  1324 0000046A 30E4                    		xor	AH, AH	 	; if zf is nof set, get character
  1325 0000046C CD16                    		int	16h	 	; call rom-bios to get character
  1326 0000046E EBF4                    		jmp	short FlLoop	; repeat until buffer is empty
  1327                                  FlDone:
  1328 00000470 C3                      		retn
  1329                                  
  1330                                  
  1331                                  ;----------------------------------------------------------------
  1332                                  ;								:
  1333                                  ;	       Console Write Routine				:
  1334                                  ;								:
  1335                                  ;----------------------------------------------------------------
  1336                                  	
  1337                                  CON$WRIT:
  1338 00000471 E3E5                    		jcxz	EXVEC			; if CX is zero, get out
  1339                                  CON$LP:
  1340 00000473 268A05                  		mov	AL,[ES:DI]		; get character
  1341 00000476 47                      		inc	DI			; point to next character
  1342                                  		;push	cx
  1343                                  		;push	di
  1344 00000477 CD29                    		int	CHROUT			; Output character
  1345 00000479 E2F8                    		loop	CON$LP			; repeat until all through
  1346                                  		;pop	di
  1347                                  		;pop	cx
  1348 0000047B E967FF                  		jmp	EXIT
  1349                                  
  1350                                  
  1351                                  
  1352                                  ;-----------------------------------------------
  1353                                  ;
  1354                                  ;	BREAK KEY HANDLING
  1355                                  ;
  1356                                  
  1357                                  CBREAK:
  1358 0000047E 2EC606[4A03]03          		mov	byte [CS:ALTAH], 3	; indicate break key set
  1359                                  		;nop
  1360                                  INTRET:
  1361 00000484 CF                      		IRET
  1362                                  
  1363                                  ;-----------------------------------------------------------------------------
  1364                                  ; MSAUX.ASM - MSDOS 3.3 - 24/07/1987
  1365                                  ;-----------------------------------------------------------------------------
  1366                                  ; 23/03/2018 - Retro DOS v2.0
  1367                                  
  1368                                  ;----------------------------------------------------------------
  1369                                  ;								:
  1370                                  ;	     A U X - AUXILARY DEVICE DRIVER			:
  1371                                  ;								:
  1372                                  ;								:
  1373                                  ;   This file contains the Auxilary Device Driver.  The 	:
  1374                                  ; auxilary driver handles calls to and from the RS-232 port.	:
  1375                                  ; Three devices uses this code: AUX, COM1, and COM2.  AUX and	:
  1376                                  ; COM1 talk to the zero RS-232 card and COM2 talks to the	:
  1377                                  ; 'one' RS-232 card.  The beginning of the interrupt entry      :
  1378                                  ; point for these devices sets the variable AUXNUM in the	:
  1379                                  ; msbio.asm module.  If the value is 0 the routines in this	:
  1380                                  ; file will talk to the the 'zero' card.  If the value in       :
  1381                                  ; AUXNUM is 1 the routines will talk to the 'one' card.         :
  1382                                  ; The procedure GETDX is called to put the value 0 or 1 in	:
  1383                                  ; the DX register depending on the value in AUXBUF.		:
  1384                                  ;								:
  1385                                  ;   The routines in this files are:				:
  1386                                  ;								:
  1387                                  ;	routine 		function			:
  1388                                  ;	------- 		--------			:
  1389                                  ;	AUX$READ		Read characters from the	:
  1390                                  ;				  specified device.		:
  1391                                  ;	AUX$RDND		Non-desrucrtive read with	:
  1392                                  ;				  no waiting.			:
  1393                                  ;	AUX$FLSH		Flush specified device input	:
  1394                                  ;				  buffer.			:
  1395                                  ;	AUX$WRIT		Write characters to the 	:
  1396                                  ;				  specified device.		:
  1397                                  ;	AUX$WRST		Get status of specified 	:
  1398                                  ;				  device			:
  1399                                  ;								:
  1400                                  ;  These routines are not called directly.  Call are made via	:
  1401                                  ; the strategy and interrupt entry point (see Device Header).	:
  1402                                  ;								:
  1403                                  ;  Data structure:						:
  1404                                  ;    The Aux Device has a two byte buffer called AUXBUF.  The	:
  1405                                  ;  first byte is for the zero card, the second byte is for the	:
  1406                                  ;  one card.  A zero value in the byte indicates the buffer is	:
  1407                                  ;  empty.  The routines use GETBX to get the address of the	:
  1408                                  ;  buffer.							:
  1409                                  ;								:
  1410                                  ;----------------------------------------------------------------
  1411                                  
  1412                                  ;		VALUES IN AH, REQUESTING FUNCTION OF INT 14H IN ROM BIOS
  1413                                  AUXFUNC_SEND	 EQU	1	;TRANSMIT
  1414                                  AUXFUNC_RECEIVE  EQU	2	;READ
  1415                                  AUXFUNC_STATUS	 EQU	3	;REQUEST STATUS
  1416                                  
  1417                                  ;		ERROR FLAGS, REPORTED BY INT 14H
  1418                                  
  1419                                  ;	 THESE FLAGS REPORTED IN AH:
  1420                                  FLAG_DATA_READY  EQU	01H	;DATA READY
  1421                                  FLAG_OVERRUN	 EQU	02H	;OVERRUN ERROR
  1422                                  FLAG_PARITY	 EQU	04H	;PARITY ERROR
  1423                                  FLAG_FRAME	 EQU	08H	;FRAMING ERROR
  1424                                  FLAG_BREAK	 EQU	10H	;BREAK DETECT
  1425                                  FLAG_TRANHOL_EMP EQU	20H	;TRANSMIT HOLDING REGISTER EMPTY
  1426                                  FLAG_TRANSHF_EMP EQU	40H	;TRANSMIT SHIFT REGISTER EMPTY
  1427                                  FLAG_TIMEOUT	 EQU	80H	;TIMEOUT
  1428                                  
  1429                                  ;	THESE FLAGS REPORTED IN AL:
  1430                                  FLAG_DELTA_CTS	 EQU	01H	;DELTA CLEAR TO SEND
  1431                                  FLAG_DELTA_DSR	 EQU	02H	;DELTA DATA SET READY
  1432                                  FLAG_TRAIL_RING  EQU	04H	;TRAILING EDGE RING INDICATOR
  1433                                  FLAG_DELTA_SIG	 EQU	08H	;DELTA RECEIVE LINE SIGNAL DETECT
  1434                                  FLAG_CTS	 EQU	10H	;CLEAR TO SEND
  1435                                  FLAG_DSR	 EQU	20H	;DATA SET READY
  1436                                  FLAG_RING	 EQU	40H	;RING INDICATOR
  1437                                  FLAG_REC_SIG	 EQU	80H	;RECEIVE LINE SIGNAL DETECT
  1438                                  
  1439                                  
  1440                                  ;----------------------------------------------------------------
  1441                                  ;								  :
  1442                                  ;	Read zero or more characters from Auxilary Device	  :
  1443                                  ;								  :
  1444                                  ;	input:es:[di] points to area to receive aux data	  :
  1445                                  ;	      cx has number of bytes to be read 		  :
  1446                                  ;	      "auxnum" first byte has number of aux device (rel 0):
  1447                                  ;								  :
  1448                                  ;----------------------------------------------------------------
  1449                                  
  1450                                  AUX$READ:
  1451 00000485 E311                    		jcxz	EXVEC2		; if no characters, get out
  1452 00000487 E88000                  		call	GETBX		; put address of AUXBUF in BX
  1453 0000048A 31C0                    		xor	AX,AX		; clear AX register
  1454 0000048C 8607                    		xchg	AL,[BX] 	; Get character , if any, from
  1455                                  					;   buffer and clear buffer
  1456 0000048E 08C0                    		or	AL,AL		; if AL is nonzero there was a
  1457                                  					;   character in the buffer
  1458 00000490 7503                    		jnz	short AUX2	; if so skip AUXIN call
  1459                                  AUX1:					;
  1460 00000492 E80600                  		call	AUXIN		; get character from port
  1461                                  AUX2:					;
  1462 00000495 AA                      		stosb			; store character
  1463 00000496 E2FA                    		loop	AUX1		; if more character, go around again
  1464                                  EXVEC2: 				;
  1465 00000498 E94AFF                  		jmp	EXIT		; all done, successful exit
  1466                                  
  1467                                  ;
  1468                                  ; AUXIN: make a call on ROM BIOS to read character from
  1469                                  ;	 the auxilary device, then do some error checking.
  1470                                  ;	 If an error occurs then AUXIN jumps to ERR$CNT and
  1471                                  ;	 does NOT return to where it was called from.
  1472                                  ;
  1473                                  
  1474                                  AUXIN:
  1475 0000049B B402                    		mov	ah,AUXFUNC_RECEIVE
  1476 0000049D E84100                  		call	AUXOP
  1477                                  		 			;check for Frame, Parity, or Overrun errors
  1478                                  		 			;WARNING: these error bits are unpredictable 
  1479                                  		 			;         if timeout (bit 7) is set
  1480 000004A0 F6C40E                  		test	ah,FLAG_FRAME | FLAG_PARITY | FLAG_OVERRUN
  1481 000004A3 7408                    		jz	short AROK	;No error if all bits are clear
  1482                                  
  1483                                  		;Error getting character
  1484                                  		;add	sp,+2		;Remove rtn address (near call)
  1485 000004A5 58                      		pop	ax
  1486 000004A6 30C0                    		xor	al,al
  1487 000004A8 0CB0                    		or	al,FLAG_REC_SIG | FLAG_DSR | FLAG_CTS
  1488                                  
  1489 000004AA E924FF                  		jmp	ERR$CNT
  1490                                  AROK:
  1491 000004AD C3                      		RETN			;CHAR JUST READ IS IN AL, STATUS IS IN AH
  1492                                  
  1493                                  ;----------------------------------------------------------------
  1494                                  ;								:
  1495                                  ;	Aux non-destructive read with no waiting		:
  1496                                  ;								:
  1497                                  ;	input: es:[di] points to area to receive aux data	:
  1498                                  ;								:
  1499                                  ;----------------------------------------------------------------
  1500                                  ;
  1501                                  
  1502                                  AUX$RDND:
  1503 000004AE E85900                  		call	GETBX		; have BX point to AUXBUF
  1504 000004B1 8A07                    		mov	AL,[BX] 	; copy contents of buffer to AL
  1505 000004B3 08C0                    		or	AL,AL		; if AL is non-zero (char in buffer)
  1506 000004B5 7514                    		jnz	short AUXRDX	;   then return character
  1507 000004B7 E82500                  		call	AUXSTAT 	;   if not, get status of AUX device
  1508 000004BA F6C401                  		TEST	AH,FLAG_DATA_READY ;TEST DATA READY
  1509 000004BD 740E                    		jz	short AUXBUS	;   then device is busy (not ready)
  1510                                  
  1511 000004BF A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  1512 000004C1 740A                    		jz	short AUXBUS	;   then device is busy (not ready)
  1513 000004C3 E8D5FF                  		call	AUXIN		;   else aux is ready, get character
  1514 000004C6 E84100                  		call	GETBX		; have bx point to AUXBUF
  1515 000004C9 8807                    		mov	[BX],AL 	; save character in buffer
  1516                                  AUXRDX: 				;
  1517 000004CB EB84                    		jmp	short RDEXIT	; return character
  1518                                  
  1519                                  AUXBUS: 				;
  1520 000004CD E9FBFE                  		Jmp	BUS$EXIT	; jump to device busy exit
  1521                                  
  1522                                  ;----------------------------------------------------------------
  1523                                  ;								:
  1524                                  ;		Aux Output Status				:
  1525                                  ;								:
  1526                                  ;----------------------------------------------------------------
  1527                                  
  1528                                  AUX$WRST:
  1529 000004D0 E80C00                  		call	AUXSTAT 	; get status of AUX in AX
  1530                                  					; now test to see if device is busy
  1531                                  					; if this bit is not set,
  1532 000004D3 A820                    		TEST	AL,FLAG_DSR	;TEST DATA SET READY
  1533 000004D5 74F6                    		jz	short AUXBUS	;   then device is busy (not ready)
  1534 000004D7 F6C420                  		TEST	AH,FLAG_TRANHOL_EMP ;TEST TRANSMIT HOLD REG EMPTY
  1535 000004DA 74F1                    		jz	short AUXBUS	;   then device is busy (not ready)
  1536 000004DC E906FF                  		jmp	EXIT
  1537                                  
  1538                                  ;
  1539                                  ; AUXSTAT makes a call on the ROM-BIOS to determine the status
  1540                                  ;	  of the auxilary device
  1541                                  ;	  Outputs:
  1542                                  ;		AX is filled with status of port.
  1543                                  ;		DX is changes to specify which card - either 0, 1 (, 2, 3) ;ba
  1544                                  ;		NO other registers are modified
  1545                                  ;
  1546                                  
  1547                                  AUXSTAT:
  1548 000004DF B403                    		mov	ah,AUXFUNC_STATUS
  1549                                  		;call	AUXOP
  1550                                  		;retn
  1551                                  AUXOP:					;AH=FUNCTION CODE
  1552                                  					;0=INIT, 1=SEND, 2=RECEIVE, 3=STATUS
  1553 000004E1 E821FF                  		call	GETDX		; have DX point to proper card
  1554 000004E4 CD14                    		int	14h		; call rom-bios for status
  1555 000004E6 C3                      		retn
  1556                                  
  1557                                  ;----------------------------------------------------------------
  1558                                  ;								:
  1559                                  ;  Flush AUX Input buffer - set contents of AUXBUF to zero	:
  1560                                  ;								:
  1561                                  ;----------------------------------------------------------------
  1562                                  
  1563                                  AUX$FLSH:
  1564 000004E7 E82000                  		call	GETBX		; get BX to point to AUXBUF
  1565 000004EA C60700                  		mov	BYTE [BX],0	; zero out buffer
  1566 000004ED E9F5FE                  		jmp	EXIT		; all done, successful return
  1567                                  	
  1568                                  ;----------------------------------------------------------------
  1569                                  ;								:
  1570                                  ;		Write to Auxilary Device			:
  1571                                  ;								:
  1572                                  ;----------------------------------------------------------------
  1573                                  
  1574                                  AUX$WRIT:
  1575 000004F0 E3A6                    		jcxz	EXVEC2		; if CX is zero, no characters
  1576                                  				;   to be written, jump to exit
  1577                                  AUX$LOOP:
  1578 000004F2 268A05                  		mov	AL,[ES:DI]	; get character to be written
  1579 000004F5 47                      		inc	DI		; move DI pointer to next character
  1580 000004F6 B401                    		MOV	AH,AUXFUNC_SEND ;VALUE=1, INDICATES A WRITE
  1581 000004F8 E8E6FF                  		CALL	AUXOP		;SEND CHARACTER OVER AUX PORT
  1582                                  
  1583 000004FB F6C480                  		TEST	AH,FLAG_TIMEOUT ;CHECK FOR ERROR
  1584 000004FE 7405                    		jz	short AWOK	;   then no error
  1585 00000500 B00A                    		mov	AL,10		;   else indicate write fault
  1586 00000502 E9CCFE                  		jmp	ERR$CNT 	; call error routines
  1587                                  
  1588                                  					; if CX is non-zero, still more
  1589                                  AWOK:
  1590 00000505 E2EB                    		loop	AUX$LOOP	; more characrter to print
  1591 00000507 E9DBFE                  		jmp	EXIT		; all done, successful return
  1592                                  
  1593                                  
  1594                                  ;
  1595                                  ;  GETBX puts the address of AUXBUF (the Auxilary Device buffer)
  1596                                  ;	 in BX.  After calling GETBX, a routine can get to AUXBUF
  1597                                  ;	 with [BX].
  1598                                  ;
  1599                                  ;  NOTE: The getdx routine is in msbio1 and looks like:
  1600                                  ;	mov	dx,word ptr cs:[auxnum]
  1601                                  ;
  1602                                  
  1603                                  GETBX:
  1604 0000050A E8F8FE                  		call	GETDX
  1605 0000050D 89D3                    		mov	BX,DX
  1606 0000050F 81C3[7200]              		add	BX,AUXBUF
  1607 00000513 C3                      		retn
  1608                                  
  1609                                  ;-----------------------------------------------------------------------------
  1610                                  ; MSLPT.ASM - MSDOS 3.3 - 24/07/1987
  1611                                  ;-----------------------------------------------------------------------------
  1612                                  ; 23/03/2018 - Retro DOS v2.0
  1613                                  
  1614                                  ;----------------------------------------------------------------
  1615                                  ;								:
  1616                                  ;	P R N - PRINTER DEVICE					:
  1617                                  ;								:
  1618                                  ;								:
  1619                                  ;   This file contains the Printer Device Driver.  The		:
  1620                                  ; printer driver handles calls to the printers.  Four devices	:
  1621                                  ; use this code: PRN, LPT1, LPT2, and LPT3.  The beginning	:
  1622                                  ; of the interrupt entry point for these device sets the	:
  1623                                  ; variable AUXNUM in the msbio.asm module.  The number is	:
  1624                                  ; in AUXNUM dictates which device will to written to: 0 for	:
  1625                                  ; PRN and LPT1, 1 for LPT2, and 2 for LPT3.			:
  1626                                  ;								:
  1627                                  ;   The routines in this files are:				:
  1628                                  ;								:
  1629                                  ;	routine 		function			:
  1630                                  ;	------- 		--------			:
  1631                                  ;	PRN$WRIT		Write to printer device 	:
  1632                                  ;	PRN$STAT		Printer status routine		:
  1633                                  ;	PRN$TilBusy		Print spooler routine		:
  1634                                  ;	Prn$GenIOCTL		Generic IOCTL routine		:
  1635                                  ;								:
  1636                                  ;  These routines are not called directly.  Call are made via	:
  1637                                  ; the strategy and interrupt entry point (see Device Header).	:
  1638                                  ;								:
  1639                                  ;----------------------------------------------------------------
  1640                                  
  1641                                  ; IBM ROM STATUS BITS (I DON'T TRUST THEM, NEITHER SHOULD YOU)             
  1642                                  									   
  1643                                  NOTBUSYSTATUS	equ 10000000b		; NOT BUSY			   
  1644                                  ACKSTATUS	equ 01000000b		; ACKNOWLEDGE (FOR WHAT?)	   
  1645                                  NOPAPERSTATUS	equ 00100000b		; NO MORE PAPER 		   
  1646                                  SELECTEDSTATUS	equ 00010000b		; THE PRINTER SAID IT WAS SELECTED 
  1647                                  IOERRSTATUS	equ 00001000b		; SOME KINDA ERROR		   
  1648                                  RESERVED	equ 00000110b		; NOPS				   
  1649                                  TIMEOUTSTATUS	equ 00000001b		; TIME OUT.			   
  1650                                  									   
  1651                                  									   
  1652                                  ; WARNING!!!  THE IBM ROM DOES NOT RETURN JUST ONE BIT.  IT RETURNS A	   
  1653                                  ; WHOLE SLEW OF BITS, ONLY ONE OF WHICH IS CORRECT.			   
  1654                                  									   
  1655                                  ;----------------------------------------------------------------
  1656                                  ;								:
  1657                                  ;		WRITE TO PRINTER DEVICE 			:
  1658                                  ;								:
  1659                                  ;   CX has count of bytes to be printed 			:
  1660                                  ;   ES:DI point to source buffer contains characters		:
  1661                                  ;   AuxNum (in msbio.asm) has printer number			:
  1662                                  ;								:
  1663                                  ;----------------------------------------------------------------
  1664                                  						   
  1665                                  PRN$WRIT:
  1666 00000514 E310                    		jcxz	EXVEC3			; no chars to output, Get out
  1667                                  PRN$LOOP:
  1668 00000516 BB0200                  		mov	BX,2			; Initialize retry flag
  1669                                  PRN$out:
  1670 00000519 268A05                  		mov	AL,[ES:DI]		; Get a character into AL
  1671 0000051C 47                      		inc	DI			; Point to next character
  1672 0000051D 30E4                    		XOR	AH,AH			; AH=0 => OUTPUT CHAR IN DL	   
  1673 0000051F E82400                  		call	PRNOP			; print character
  1674 00000522 7505                    		jnz	short PrRetry 		; if error, try to print again
  1675 00000524 E2F0                    		loop	PRN$LOOP		; if more character, keep printing
  1676                                  EXVEC3:
  1677 00000526 E9BCFE                  		jmp	EXIT
  1678                                  
  1679                                  PrRetry:
  1680 00000529 4F                      		dec	DI			; undo the inc above...
  1681 0000052A 4B                      		dec	BX			; Decrement retry count
  1682 0000052B 75EC                    		jnz	short PRN$out 		; See if done with retrys
  1683                                  PMESSG:
  1684 0000052D E9A1FE                  		JMP	ERR$CNT 		; if so return with the error
  1685                                  
  1686                                  ;----------------------------------------------------------------
  1687                                  ;								:
  1688                                  ;		PRINTER STATUS ROUTINE				:
  1689                                  ;								:
  1690                                  ;----------------------------------------------------------------
  1691                                  ;
  1692                                  						   
  1693                                  PRN$STAT:
  1694 00000530 E81100                  		call	PRNSTAT 		; get the status
  1695 00000533 75F8                    		jnz	short PMESSG		; if error jump to error routine
  1696 00000535 B009                    		MOV	AL,9			; AGAIN, ASSUME OUT OF PAPER...    
  1697 00000537 F6C420                  		TEST	AH,NOPAPERSTATUS					   
  1698 0000053A 75F1                    		JNZ	short PMESSG							   
  1699 0000053C F6C480                  		TEST	AH,NOTBUSYSTATUS					   
  1700 0000053F 75E5                    		jnz	short EXVEC3		; if not busy return via EXVEC3
  1701 00000541 E987FE                  		JMP	BUS$EXIT		; else busy, return to busy exit   
  1702                                  
  1703                                  ;
  1704                                  ;   PRNSTAT	get printer status
  1705                                  ;   PRNOP	print a character
  1706                                  ;
  1707                                  ; PRNSTAT and PRNOP are two routines which call on the ROM-BIOS
  1708                                  ; printer routines.  The routines share code which calls on the bios and
  1709                                  ; then determines which, if any, error occured. PRNSTAT and PRNOP differ
  1710                                  ; only by the value put into AH before the ROM-BIOS call.
  1711                                  ;
  1712                                  ;   INPUT	if PRNOP then character in AL
  1713                                  ;
  1714                                  ;   OUTPUT	- AL holds error code
  1715                                  ;		- AH status byte from printer
  1716                                  ;		- flag NZ if error
  1717                                  
  1718                                  PRNSTAT:						   
  1719 00000544 B402                    		mov	AH,2			; set command for get status   *
  1720                                  PRNOP:
  1721 00000546 E8BCFE                  		call	GETDX			; determine which printer      *
  1722 00000549 CD17                    		int	17h			; call ROM-BIOS printer routine  *
  1723                                  
  1724 0000054B F6C408                  		TEST	AH,IOERRSTATUS		; I/O ERROR?			   
  1725 0000054E 740A                    		JZ	CHECKNOTREADY		; NO, TRY NOT READY		   
  1726                                  									   
  1727                                  ; AT THIS POINT, WE KNOW WE HAVE AN ERROR. THE CONVERSE IS NOT TRUE.	   
  1728                                  									   
  1729 00000550 B009                    		MOV	AL,9			; FIRST, ASSUME OUT OF PAPER	   
  1730 00000552 F6C420                  		TEST	AH,NOPAPERSTATUS	; OUT OF PAPER SET?		   
  1731 00000555 7502                    		JNZ	short RET1			; YES, ERROR IS SET		   
  1732 00000557 FEC0                    		INC	AL			; INDICATE I/O ERROR		   
  1733                                  RET1:									   
  1734                                  									   
  1735                                  ; WE HAVE TRIAGED NOW FOR OUT OF PAPER AND IO ERR (IGNORING TIME-OUT)	   
  1736                                  									   
  1737 00000559 C3                      		RETN				; RETURN WITH ERROR		   
  1738                                  									   
  1739                                  ; THE BITS SAID NO ERROR.  UNFORTUNATELY, THERE MAY BE OTHER THINGS AT WOR  K
  1740                                  ; HERE. 								   
  1741                                  									   
  1742                                  CHECKNOTREADY:								   
  1743 0000055A B002                    		MOV	AL,2			; ASSUME NOT-READY		   
  1744 0000055C F6C401                  		TEST	AH,TIMEOUTSTATUS	; IS TIME-OUT SET?		   
  1745                                  						; IF NZ THEN ERROR, ELSE OK???	   
  1746                                  PRNOP2: 								   
  1747 0000055F C3                      		RETN								   
  1748                                  
  1749                                  ;-----------------------------------------------------------------------------
  1750                                  ; MSCLOCK.ASM - MSDOS 3.3 - 24/07/1987
  1751                                  ;-----------------------------------------------------------------------------
  1752                                  ; 23/03/2018 - Retro DOS v2.0
  1753                                  
  1754                                  ;----------------------------------------				  
  1755                                  ;	CMOS EQUATES FOR THIS SYSTEM	:  ; 26/03/2018 - CMOSEQU.INC, 1987				  
  1756                                  ;-----------------------------------------------------------------------------
  1757                                  CMOS_PORT	EQU	070H		; I/O ADDRESS OF CMOS ADDRESS PORT	 
  1758                                  CMOS_DATA	EQU	071H		; I/O ADDRESS OF CMOS DATA PORT 	 
  1759                                  NMI		EQU	10000000B	; DISABLE NMI INTERRUPTS MASK - 	 
  1760                                  					;  HIGH BIT OF CMOS LOCATION ADDRESS
  1761                                  ;---------- CMOS TABLE LOCATION ADDRESS'S ## --------------------------------- 
  1762                                  CMOS_SECONDS	EQU	000H		; SECONDS				 
  1763                                  CMOS_SEC_ALARM	EQU	001H		; SECONDS ALARM  ## NOTE:  ALL LOCATIONS 
  1764                                  CMOS_MINUTES	EQU	002H		; MINUTES	      | IN THE CMOS AREA 
  1765                                  CMOS_MIN_ALARM	EQU	003H		; MINUTES ALARM       | ARE IBM USE ONLY 
  1766                                  CMOS_HOURS	EQU	004H		; HOURS 	      | AND  SUBJECT  TO 
  1767                                  CMOS_HR_ALARM	EQU	005H		; HOURS ALARM	      | CHANGE. ONLY THE 
  1768                                  CMOS_DAY_WEEK	EQU	006H		; DAY OF THE WEEK     | POST & BIOS CODE 
  1769                                  CMOS_DAY_MONTH	EQU	007H		; DAY OF THE MONTH    | SHOULD	DIRECTLY 
  1770                                  CMOS_MONTH	EQU	008H		; MONTH 	      | ACCESS LOCATIONS 
  1771                                  CMOS_YEAR	EQU	009H		; YEAR (TWO DIGITS)   | IN CMOS STORAGE. 
  1772                                  CMOS_REG_A	EQU	00AH		; STATUS REGISTER A   '----------------- 
  1773                                  CMOS_REG_B	EQU	00BH		; STATUS REGISTER B  ALARM		 
  1774                                  CMOS_REG_C	EQU	00CH		; STATUS REGISTER C  FLAGS		 
  1775                                  CMOS_REG_D	EQU	00DH		; STATUS REGISTER D  BATTERY		 
  1776                                  CMOS_DIAG	EQU	00EH		; POST DIAGNOSTIC STATUS RESULTS BYTE	 
  1777                                  CMOS_SHUT_DOWN	EQU	00FH		; SHUTDOWN STATUS COMMAND BYTE		 
  1778                                  CMOS_DISKETTE	EQU	010H		; DISKETTE DRIVE TYPE BYTE	      ;  
  1779                                  ;		EQU	011H		; - RESERVED			      ;C 
  1780                                  CMOS_DISK	EQU	012H		; FIXED DISK TYPE BYTE		      ;H 
  1781                                  ;		EQU	013H		; - RESERVED			      ;E 
  1782                                  CMOS_EQUIP	EQU	014H		; EQUIPMENT WORD LOW BYTE	      ;C 
  1783                                  CMOS_B_M_S_LO	EQU	015H		; BASE MEMORY SIZE - LOW BYTE (X1024) ;K 
  1784                                  CMOS_B_M_S_HI	EQU	016H		; BASE MEMORY SIZE - HIGH BYTE	      ;S 
  1785                                  CMOS_E_M_S_LO	EQU	017H		; EXPANSION MEMORY SIZE - LOW BYTE    ;U 
  1786                                  CMOS_E_M_S_HI	EQU	018H		; EXPANSION MEMORY SIZE - HIGH BYTE   ;M 
  1787                                  CMOS_DISK_1	EQU	019H		; FIXED DISK TYPE - DRIVE C EXTENSION ;E 
  1788                                  CMOS_DISK_2	EQU	01AH		; FIXED DISK TYPE - DRIVE D EXTENSION ;D 
  1789                                  ;		EQU	01BH		; - 1BH THROUGH 2DH - RESERVED	      ;  
  1790                                  CMOS_CKSUM_HI	EQU	02EH		; CMOS CHECKSUM - HIGH BYTE	      ;* 
  1791                                  CMOS_CKSUM_LO	EQU	02FH		; CMOS CHECKSUM - LOW BYTE	      ;* 
  1792                                  CMOS_U_M_S_LO	EQU	030H		; USABLE MEMORY ABOVE 1 MEG - LOW BYTE	 
  1793                                  CMOS_U_M_S_HI	EQU	031H		; USABLE MEMORY ABOVE 1 MEG - HIGH BYTE  
  1794                                  CMOS_CENTURY	EQU	032H		; DATE CENTURY BYTE (BCD)		 
  1795                                  CMOS_INFO128	EQU	033H		; 128KB INFORMATION STATUS FLAG BYTE	 
  1796                                  ;		EQU	034H		; - 34H THROUGH 3FH - RESERVED		 	
  1797                                  
  1798                                  ;----------------------------------------------------------------
  1799                                  ;								:
  1800                                  ;		    CLOCK DEVICE DRIVER 			:
  1801                                  ;								:
  1802                                  ;								:
  1803                                  ;   This file contains the Clock Device Driver. 		:
  1804                                  ;								:
  1805                                  ;   The routines in this files are:				:
  1806                                  ;								:
  1807                                  ;	routine 		function			:
  1808                                  ;	------- 		--------			:
  1809                                  ;	TIM$WRIT		Set the current time		:
  1810                                  ;	TIM$READ		Read the current time		:
  1811                                  ;	Time_To_Ticks		Convert time to corresponding	:
  1812                                  ;				  number of clock ticks 	:
  1813                                  ;								:
  1814                                  ; The clock ticks at the rate of:				:
  1815                                  ;								:
  1816                                  ;	1193180/65536 ticks/second (about 18.2 ticks per second):
  1817                                  ; See each routine for information on the use.			:
  1818                                  ;								:
  1819                                  ;----------------------------------------------------------------
  1820                                  
  1821                                  ;
  1822                                  ; DAYCNT is the number of days since 1-1-80.
  1823                                  ; Each time the clock is read it is necessary to check if another day has
  1824                                  ; passed.  The ROM only returns the day rollover once so if it is missed
  1825                                  ; the time will be off by a day.
  1826                                  ;
  1827                                  
  1828                                  ;; variables for real time clock setting
  1829                                  ;HaveCMOSClock:
  1830                                  ;		db	0	;set by MSINIT.
  1831                                  ;base_century:
  1832                                  ;		db	19
  1833                                  ;base_year:
  1834                                  ;		db	80
  1835                                  ;month_tab:
  1836                                  ;		db	31,28,31,30,31,30,31,31,30,31,30,31
  1837                                  
  1838                                  ; The following are indirect intra-segment call addresses. The
  1839                                  ;procedures are defined in MSINIT for relocation.  MSINIT will set these
  1840                                  ;address when the relocation is done.
  1841                                  	
  1842                                  ;BinToBCD:
  1843                                  ;		dw	0	;should point to Bin_To_BCD proc in MSINIT
  1844                                  ;
  1845                                  ;DaycntToDay:
  1846                                  ;		dw	0	;should point to Daycnt_to_day in MSINIT
  1847                                  
  1848                                  ;********************************************************************
  1849                                  ; Indirect call address of TIME_TO_TICKS procedure.
  1850                                  ;This will be used by the relocatable portable suspend/resume code.
  1851                                  
  1852                                  ;TimeToTicks:
  1853                                  ;		dw	TIME_TO_TICKS
  1854                                  
  1855                                  ;--------------------------------------------------------------------
  1856                                  ;
  1857                                  ; Settime sets the current time
  1858                                  ;
  1859                                  ; On entry ES:[DI] has the current time:
  1860                                  ;
  1861                                  ;	number of days since 1-1-80	(WORD)
  1862                                  ;	minutes (0-59)			(BYTE)
  1863                                  ;	hours (0-23)			(BYTE)
  1864                                  ;	hundredths of seconds (0-99)	(BYTE)
  1865                                  ;	seconds (0-59)			(BYTE)
  1866                                  ;
  1867                                  ; Each number has been checked for the correct range.
  1868                                  ;
  1869                                  
  1870                                  TIM$WRIT:
  1871 00000560 268B05                  		mov	AX,[ES:DI]
  1872 00000563 50                      		push	AX		;DAYCNT. We need to set this at the very
  1873                                  					;  end to avoid tick windows.
  1874                                  		;;;Rev 3.30 Modification
  1875                                  		;cmp	byte [HaveCMOSClock], 0
  1876                                  		;je	short No_CMOS_1
  1877                                  		;mov	al,[es:di+3]		;get binary hours
  1878                                  		;call	BinToBCD		;convert to BCD
  1879                                  		;mov	ch,al			;CH = BCD hours
  1880                                  		;mov	al,[es:di+2]		;get binary minutes
  1881                                  		;call	BinToBCD		;convert to BCD
  1882                                  		;mov	cl,al			;CL = BCD minutes
  1883                                  		;mov	al,[es:di+5]		;get binary seconds
  1884                                  		;call	BinToBCD		;convert to BCD
  1885                                  		;mov	dh,al			;DH = BCD seconds
  1886                                  		;mov	dl,0			;DL = 0 (ST) or 1 (DST)
  1887                                  		;cli				;turn off timer
  1888                                  		;mov	ah,03h			;set RTC time
  1889                                  		;int	1Ah			;call rom bios clock routine
  1890                                  		;sti
  1891                                  		;;;End of Modification
  1892                                  No_CMOS_1:
  1893 00000564 268B4D02                		mov	CX,[ES:DI+2]
  1894 00000568 268B5504                		mov	DX,[ES:DI+4]
  1895                                  		;;Rev 3.30 Modification
  1896 0000056C E80D00                  		call	TIME_TO_TICKS		; convert time to ticks
  1897                                  						;CX:DX now has time in ticks
  1898 0000056F FA                      		cli				; Turn off timer
  1899 00000570 B401                    		mov	AH, 1			; command is set time in clock
  1900 00000572 CD1A                    		int	1Ah			; call rom-bios clock routines
  1901 00000574 8F06[5403]              		pop	word [DAYCNT]
  1902 00000578 FB                      		sti
  1903                                  		;;CMOS clock -------------------------------------
  1904                                  		;cmp	byte [HaveCMOSClock], 0
  1905                                  		;je	short No_CMOS_2
  1906                                  		;call	DaycntToDay		; convert to BCD format
  1907                                  		;cli				; Turn off timer
  1908                                  		;mov	AH,05h			; set RTC date
  1909                                  		;int	1Ah			; call rom-bios clock routines
  1910                                  		;sti
  1911                                  		;------------------------------------------------
  1912                                  No_CMOS_2:
  1913 00000579 E969FE                  		jmp	EXIT
  1914                                  		;;End of Modification
  1915                                  
  1916                                  ;
  1917                                  ; convert time to ticks
  1918                                  ; input : time in CX and DX
  1919                                  ; ticks returned in CX:DX
  1920                                  ;
  1921                                  
  1922                                  TIME_TO_TICKS:
  1923                                  		; first convert from Hour,min,sec,hund. to
  1924                                  		; total number of 100th of seconds
  1925 0000057C B03C                    		mov	AL,60
  1926 0000057E F6E5                    		mul	CH		;Hours to minutes
  1927 00000580 B500                    		mov	CH,0
  1928 00000582 01C8                    		add	AX,CX		;Total minutes
  1929 00000584 B97017                  		mov	CX,6000 	;60*100
  1930 00000587 89D3                    		mov	BX,DX		;Get out of the way of the multiply
  1931 00000589 F7E1                    		mul	CX		;Convert to 1/100 sec
  1932 0000058B 89C1                    		mov	CX,AX
  1933 0000058D B064                    		mov	AL,100
  1934 0000058F F6E7                    		mul	BH		;Convert seconds to 1/100 sec
  1935 00000591 01C1                    		add	CX,AX		;Combine seconds with hours and min.
  1936 00000593 83D200                  		adc	DX,0		;Ripple carry
  1937 00000596 B700                    		mov	BH,0
  1938 00000598 01D9                    		add	CX,BX		;Combine 1/100 sec
  1939 0000059A 83D200                  		adc	DX,0
  1940                                  
  1941                                  		;;Rev 3.30 Modification
  1942                                  		;DX:CX IS TIME IN 1/100 SEC
  1943 0000059D 92                      		XCHG	AX,DX
  1944 0000059E 91                      		XCHG	AX,CX		;NOW TIME IS IN CX:AX
  1945 0000059F BB0BE9                  		MOV	BX,59659
  1946 000005A2 F7E3                    		MUL	BX		;MULTIPLY LOW HALF
  1947 000005A4 87D1                    		XCHG	DX,CX
  1948 000005A6 92                      		XCHG	AX,DX		;CX->AX, AX->DX, DX->CX
  1949 000005A7 F7E3                    		MUL	BX		;MULTIPLY HIGH HALF
  1950 000005A9 01C8                    		ADD	AX,CX		;COMBINE OVERLAPPING PRODUCTS
  1951 000005AB 83D200                  		ADC	DX,0
  1952 000005AE 92                      		XCHG	AX,DX		;AX:DX=TIME*59659
  1953 000005AF BB0500                  		MOV	BX,5
  1954 000005B2 F6F3                    		DIV	BL		;DIVIDE HIGH HALF BY 5
  1955 000005B4 88C1                    		MOV	CL,AL
  1956 000005B6 B500                    		MOV	CH,0
  1957 000005B8 88E0                    		MOV	AL,AH		;REMAINDER OF DIVIDE-BY-5
  1958 000005BA 98                      		CBW
  1959 000005BB 92                      		XCHG	AX,DX		;USE IT TO EXTEND LOW HALF
  1960 000005BC F7F3                    		DIV	BX		;DIVIDE LOW HALF BY 5
  1961 000005BE 89C2                    		MOV	DX,AX
  1962                                  			; CX:DX is now number of ticks in time
  1963 000005C0 C3                      		retn
  1964                                  
  1965                                  ;
  1966                                  ; Gettime reads date and time
  1967                                  ; and returns the following information:
  1968                                  ;
  1969                                  ;	ES:[DI]  =count of days since 1-1-80
  1970                                  ;	ES:[DI+2]=hours
  1971                                  ;	ES:[DI+3]=minutes
  1972                                  ;	ES:[DI+4]=seconds
  1973                                  ;	ES:[DI+5]=hundredths of seconds
  1974                                  ;
  1975                                  
  1976                                  TIM$READ:				; read the clock
  1977 000005C1 30E4                    		xor	AH, AH		; set command to read clock
  1978 000005C3 CD1A                    		int	1Ah		; call rom-bios to get time
  1979                                  
  1980 000005C5 08C0                    		or	al,al		; check for a new day
  1981 000005C7 7404                    		jz	short noroll1 	; if al=0 then don't reset day count
  1982 000005C9 FF06[5403]              		INC	word [DAYCNT]	; CATCH ROLLOVE
  1983                                  noroll1:
  1984 000005CD 8B36[5403]              		MOV	SI,[DAYCNT]
  1985                                  
  1986                                  ;
  1987                                  ; we now need to convert the time in tick to the time in 100th of
  1988                                  ; seconds.  The relation between tick and seconds is:
  1989                                  ;
  1990                                  ;		 65536 seconds
  1991                                  ;	       ----------------
  1992                                  ;		1,193,180 tick
  1993                                  ;
  1994                                  ; To get to 100th of second we need to multiply by 100. The equation is:
  1995                                  ;
  1996                                  ;	Ticks from clock  * 65536 * 100
  1997                                  ;      ---------------------------------  = time in 100th of seconds
  1998                                  ;		1,193,180
  1999                                  ;
  2000                                  ; Fortunately this formula simplifies to:
  2001                                  ;
  2002                                  ;	Ticks from clock * 5 * 65,536
  2003                                  ;      --------------------------------- = time in 100th of seconds
  2004                                  ;		59,659
  2005                                  ;
  2006                                  ; The calculation is done by first multipling tick by 5. Next we divide by
  2007                                  ; 59,659.  In this division we multiply by 65,536 by shifting the dividend
  2008                                  ; my 16 bits to the left.
  2009                                  ;
  2010                                  ; start with ticks in CX:DX
  2011                                  ; multiply by 5
  2012 000005D1 89C8                    		MOV	AX,CX
  2013 000005D3 89D3                    		MOV	BX,DX
  2014 000005D5 D1E2                    		SHL	DX,1
  2015 000005D7 D1D1                    		RCL	CX,1		;TIMES 2
  2016 000005D9 D1E2                    		SHL	DX,1
  2017 000005DB D1D1                    		RCL	CX,1		;TIMES 4
  2018 000005DD 01DA                    		ADD	DX,BX
  2019 000005DF 11C8                    		ADC	AX,CX		;TIMES 5
  2020 000005E1 92                      		XCHG	AX,DX		
  2021                                  	
  2022                                  
  2023                                  ; now have ticks * 5 in DX:AX
  2024                                  ; we now need to multiply by 65,536 and divide by 59659 d.
  2025                                  
  2026 000005E2 B90BE9                  		mov	CX,59659	; get divisor
  2027 000005E5 F7F1                    		div	CX
  2028                                  					; DX now has remainder
  2029                                  					; AX has high word of final quotient
  2030 000005E7 89C3                    		mov	BX,AX		; put high work if safe place
  2031 000005E9 31C0                    		xor	AX,AX		; this is the multiply by 65536
  2032 000005EB F7F1                    		div	CX		; BX:AX now has time in 100th of seconds
  2033                                  
  2034                                  ;
  2035                                  ;Rounding based on the remainder may be added here
  2036                                  ;The result in BX:AX is time in 1/100 second.
  2037 000005ED 89DA                    		mov	DX,BX
  2038 000005EF B9C800                  		mov	CX,200		;Extract 1/100's
  2039                                  ;Division by 200 is necessary to ensure no overflow--max result
  2040                                  ;is number of seconds in a day/2 = 43200.
  2041 000005F2 F7F1                    		div	CX
  2042 000005F4 80FA64                  		cmp	DL,100		;Remainder over 100?
  2043 000005F7 7203                    		jb	short NOADJ
  2044 000005F9 80EA64                  		sub	DL,100		;Keep 1/100's less than 100
  2045                                  NOADJ:
  2046 000005FC F5                      		cmc			;If we subtracted 100, carry is now set
  2047 000005FD 88D3                    		mov	BL,DL		;Save 1/100's
  2048                                  ;To compensate for dividing by 200 instead of 100, we now multiply
  2049                                  ;by two, shifting a one in if the remainder had exceeded 100.
  2050 000005FF D1D0                    		rcl	AX,1
  2051 00000601 B200                    		mov	DL,0
  2052 00000603 D1D2                    		rcl	DX,1
  2053 00000605 B93C00                  		mov	CX,60		;Divide out seconds
  2054 00000608 F7F1                    		div	CX
  2055 0000060A 88D7                    		mov	BH,DL		;Save the seconds
  2056 0000060C F6F1                    		div	CL		;Break into hours and minutes
  2057 0000060E 86C4                    		xchg	AL,AH
  2058                                  
  2059                                  ;Time is now in AX:BX (hours, minutes, seconds, 1/100 sec)
  2060                                  
  2061 00000610 50                      		push	AX
  2062 00000611 89F0                    		MOV	AX,SI		; DAYCNT
  2063 00000613 AB                      		stosw
  2064 00000614 58                      		pop	AX
  2065 00000615 AB                      		stosw
  2066 00000616 89D8                    		mov	AX,BX
  2067 00000618 AB                      		stosw
  2068 00000619 E9C9FD                  		jmp	EXIT
  2069                                  
  2070                                  ;-----------------------------------------------------------------------------
  2071                                  ; MSDISK.ASM (1) - MSDOS 3.3 - 02/02/1988
  2072                                  ;-----------------------------------------------------------------------------
  2073                                  ; 23/03/2018 - Retro DOS v2.0
  2074                                  
  2075                                  ;------------------------------------------------------------------------
  2076                                  ;									:
  2077                                  ;	       DISK INTERFACE ROUTINES					:
  2078                                  ;									:
  2079                                  ;									:
  2080                                  ;   This file contains the Disk Device Driver.				:
  2081                                  ;									:
  2082                                  ;   The routines in this files are:					:
  2083                                  ;									:
  2084                                  ;	routine 		function				:
  2085                                  ;	------- 		--------				:
  2086                                  ;									:
  2087                                  ;	MEDIA$CHK		Determine if media in drive has changed :
  2088                                  ;									:
  2089                                  ;	GET$BPB 		Build a valid BPB for drive		:
  2090                                  ;									:
  2091                                  ;	DSK$REM 		Determine if disk has removable media	:
  2092                                  ;									:
  2093                                  ;	DSK$WRTV		Disk write with verify			:
  2094                                  ;									:
  2095                                  ;	DSK$WRT 		Disk write				:
  2096                                  ;									:
  2097                                  ;	DSK$READ		Read disk				:
  2098                                  ;									:
  2099                                  ;									:
  2100                                  ;  These routines are not called directly.  Call are made via		:
  2101                                  ; the strategy and interrupt entry point (see Device Header).		:
  2102                                  ;									:
  2103                                  ;  Data structures:							:
  2104                                  ;	There are two main types of data structures associated with	:
  2105                                  ;  the disk drives.  The first is the BDS.  BDS is the Bios Data	:
  2106                                  ;  structure.  There is one BDS for each logical drive in the system.	:
  2107                                  ;  All the BDS's are linked together in a list with the pointer to the  :
  2108                                  ;  first BDS being found in START_BDS.	The BDS hold various values	:
  2109                                  ;  important to the disk drive.  For example there is a field for last	:
  2110                                  ;  time accesses.  As actions take place in the system the BDS are	:
  2111                                  ;  update to reflect the actions.  For example if there is a read to	:
  2112                                  ;  a disk the last access field for the BDS for that drive is updated	:
  2113                                  ;  to the current time. 						:
  2114                                  ;	 The second data structure associated with disk drives is the	:
  2115                                  ;  BPB.  A BPB is a Bios Parameter Block.  The BPB contains information :
  2116                                  ;  about the media inside a disk drive.  Some on the fields in the BPB	:
  2117                                  ;  are Sectors per track, number of FATs, and number of tracks.  This	:
  2118                                  ;  information is used to tell where sectors are on the disk.  For	:
  2119                                  ;  example,  if we need to read logical sector 52:			:
  2120                                  ;									:
  2121                                  ;	Diskette			Track	Sector	Side		:
  2122                                  ;    single density							:
  2123                                  ;    eight sectors per track		  6	   5	  0		:
  2124                                  ;									:
  2125                                  ;    double density							:
  2126                                  ;    nine sectors per track		  2	   7	  1		:
  2127                                  ;									:
  2128                                  ;  The BPB for the media in the drive is stored in the BDS for the	:
  2129                                  ;  drive.  If the user changes the floppy in the drive a call is	:
  2130                                  ;  made to GET$BPB to build a new BPB in the BDS.  See this routine	:
  2131                                  ;  for the algorithm.							:
  2132                                  ;									:
  2133                                  ;									:
  2134                                  ;------------------------------------------------------------------------
  2135                                  
  2136                                  ;
  2137                                  ; Maximum number of retries in case of error
  2138                                  ;
  2139                                  
  2140                                  MAXERR	EQU	5
  2141                                  LSTDRV	EQU	0504h
  2142                                  
  2143                                  ;
  2144                                  ; Some floppy drives do not have changeline support.  The result is a
  2145                                  ; large amount of inefficiency in the code.  A media-check always returns
  2146                                  ; "I don`t know".  This cause DOS to reread the FAT on every access and
  2147                                  ; always discard any cached data.
  2148                                  ;    We get around this inefficiency by implementing a "Logical Door Latch".
  2149                                  ; The following three items are used to do this.  The logical door latch is
  2150                                  ; based on the premise that it is not physically possible to change floppy
  2151                                  ; disks in a drive in under two seconds (most people take about 10).  The
  2152                                  ; logical door latch is implemented by saving the time of the last successful
  2153                                  ; disk operation (in the value TIM_DRV).  When a new request is made the
  2154                                  ; current time is compared to the saved time.  If less than two seconds have
  2155                                  ; passed then the value "No Change" is returned.  If more than two seconds
  2156                                  ; have passed the value "Don't Know" is returned.
  2157                                  ;    There is one complecation to this algorithm.  Some programs change the
  2158                                  ; value of the timer.  In this unfortunate case we have an invalid timer.
  2159                                  ; This possiblity is detected by counting the number of disk operations
  2160                                  ; which occur without any time passing.  If this count exceeds the value of
  2161                                  ; "AccessMax" we assume the counter is invalid and always return "Don't
  2162                                  ; Know".  The variable "AccessCount" is used to keep track of the number
  2163                                  ; of disk operation which occur without the time changing.
  2164                                  ;
  2165                                  
  2166                                  AccessMax	equ	5
  2167                                  
  2168                                  ;
  2169                                  ; Some of the older versions of the IBM rom-bios always assumed a seek would
  2170                                  ; have to be made to read the diskette.  Consequently a large head settle
  2171                                  ; time was always used in the I/O operations.  To get around this problem
  2172                                  ; we need to continually adjust the head settle time.  The following
  2173                                  ; algorithm is used:
  2174                                  ;
  2175                                  ;   Get the current head settle value.
  2176                                  ;   If it is 1, then
  2177                                  ;	set slow = 15
  2178                                  ;   else
  2179                                  ;	set slow = value
  2180                                  ;   ...
  2181                                  ;   if we are seeking and writing then
  2182                                  ;	use slow
  2183                                  ;   else
  2184                                  ;	use fast
  2185                                  ;   ...
  2186                                  ;   restore current head settle value
  2187                                  ;
  2188                                  ;
  2189                                  ; flags for size of FAT
  2190                                  ;
  2191                                  
  2192                                  ;fTOOBIG 	EQU	80h
  2193                                  ;fBIG		EQU	40h
  2194                                  
  2195                                  error_unknown_media	equ	7	; for use in BUILD BPB call
  2196                                  
  2197                                  struc BPB_TYPE
  2198 00000000 <res 00000002>          .SECSIZE:	resw 1
  2199 00000002 <res 00000001>          .SECALL:	resb 1
  2200 00000003 <res 00000002>          .RESNUM:	resw 1
  2201 00000005 <res 00000001>          .FATNUM:	resb 1
  2202 00000006 <res 00000002>          .DIRNUM:	resw 1
  2203 00000008 <res 00000002>          .SECNUM:	resw 1
  2204 0000000A <res 00000001>          .FATID:		resb 1
  2205 0000000B <res 00000002>          .FATSIZE:	resw 1
  2206 0000000D <res 00000002>          .SLIM:		resw 1
  2207 0000000F <res 00000002>          .HLIM:		resw 1
  2208 00000011 <res 00000002>          .HIDDEN:	resw 1
  2209                                  .size:
  2210                                  endstruc
  2211                                  
  2212                                  ;------------------------------------------------------------------------
  2213                                  ;									:
  2214                                  ; The next 100 or so lines of code do the Media Check.	Media Check	:
  2215                                  ; determines if the diskette (media) in the drive has been changed.	:
  2216                                  ;									:
  2217                                  ;	SI is used to hold media check code:				:
  2218                                  ;			-1	media changed				:
  2219                                  ;			 0	Don't know                              :
  2220                                  ;			 1	media has not been changed		:
  2221                                  ;									:
  2222                                  ; The algorithm used is a follows:					:
  2223                                  ;	if (hard disk)							:
  2224                                  ;	    if (changed by format)					:
  2225                                  ;		   return (not changed) 				:
  2226                                  ;	    if	not (changed by format) 				:
  2227                                  ;		   return (changed)					:
  2228                                  ;	else we have a floppy						:
  2229                                  ;	    if floppy has change line support go ask the floppy 	:
  2230                                  ;	    if floppy does not have change line do the following	:
  2231                                  ;		read the time						:
  2232                                  ;		if more than two second have passed return don't know   :
  2233                                  ;		if no time has passed then might be unreliable		:
  2234                                  ;		  counter (some program fool with the counter when	:
  2235                                  ;		  they should not).  See note below for procedure with	:
  2236                                  ;		  unreliable counter					:
  2237                                  ;		if sometime has passed but not two second return	:
  2238                                  ;		  media has not changed.  This is based on the		:
  2239                                  ;		  assumption that it is not physically possible to	:
  2240                                  ;		  change a disk in less the two seconds (most people	:
  2241                                  ;		  take about 10 seconds).				:
  2242                                  ;									:
  2243                                  ;------------------------------------------------------------------------
  2244                                  
  2245                                  MEDIA$CHK:
  2246                                  		; 08/04/2018
  2247                                  		; Retro DOS v2.0
  2248                                  		; (Media check code here is mix of MSDOS 2.0, MSDOS 3.3
  2249                                  		; and Retro DOS v2.0 special media -disk change- check code..)
  2250                                  		; (..it is not compatible with MSDOS 3.3 mediacheck)
  2251                                  		; (Excluded methods: Volume Serial Number Check,
  2252                                  		; "fChanged_By_Format" check -via int 13h hook-)
  2253                                  
  2254 0000061C 31F6                    		xor	si, si  ; Presume "I don't know"
  2255                                  
  2256                                  		;cmp	AL, 1	; Retro DOS v2.0 method
  2257                                  				; We will not check disk change status
  2258                                  				; if disk/unit number > 1.
  2259                                  				; (hard disk or diskette 3 ! or diskette 4 !)
  2260                                  		;ja	short Media$Done
  2261                                  
  2262 0000061E 3A06[D300]              		cmp	al, [HARDNUM]
  2263 00000622 7317                    		jnb	short Media$Done ; fixed/hard disk !
  2264                                  
  2265                                  ;
  2266                                  ; If this code is reached disk is a diskette drive
  2267                                  ;
  2268                                  
  2269                                  WeHaveAFloppy:
  2270                                  		;mov	[CS:MEDIACHK_DRV], al ; Retro DOS v2.0 method 
  2271                                  		; 13/04/2018
  2272                                  		;mov	[MEDIACHK_DRV], al ; 11/04/2018
  2273                                  
  2274                                  ;
  2275                                  ; If drive is a floppy with changeline support the rom is called to
  2276                                  ; determine if the media has changed. It is not necessary to do the 2
  2277                                  ; second check on these drives.
  2278                                  ;
  2279 00000624 E80B03                  		CALL	MediaCheck
  2280                                  
  2281                                  		; DL = drive number (0..3) ; 13/04/2018
  2282                                  
  2283 00000627 21F6                    		and	si, si
  2284 00000629 7510                    		jnz	short Media$Done
  2285                                  
  2286                                  		; SI = 0, "I don't know" (if media has been changed or not!?)		
  2287                                  
  2288                                  ;
  2289                                  ; If this code is reached the drive is a floppy with no changeline support
  2290                                  ;
  2291 0000062B BE0100                  		MOV	SI,1			; PRESUME NO CHANGE
  2292                                  		;mov	al,[CS:TIM_DRV] 	; last drive accessed
  2293                                  						;is drive of last access the same?
  2294 0000062E A0[3701]                		mov	al, [TIM_DRV]
  2295                                  		;CMP	AL,[CS:MEDIACHK_DRV]
  2296                                  		;cmp	al, [MEDIACHK_DRV] ; 11/04/2018
  2297 00000631 38D0                    		CMP	AL, DL ; 13/04/2018
  2298 00000633 7505                    		JNE	short Media$Unk		; no, then return don't know
  2299                                  ;
  2300                                  ; CHECK TO SEE IF THIS DRIVE HAS BEEN ACCESSED IN THE LAST 2 SECONDS.
  2301                                  ;
  2302 00000635 E81900                  		call	CHECK_TIME_OF_ACCESS
  2303 00000638 EB01                    		jmp	short Media$Done
  2304                                  
  2305                                  Media$Unk:
  2306 0000063A 4E                      		DEC	SI			; RETURN "I DON'T KNOW"
  2307                                  
  2308                                  ;
  2309                                  ; SI now contains the correct value for media change. Clean up the left overs
  2310                                  ;
  2311                                  Media$Done:
  2312                                  		;les	bx,[CS:PTRSAV]		; get original packet
  2313 0000063B C41E[6E00]              		les	bx,[PTRSAV] ; 11/04/2018
  2314 0000063F 2689770E                		mov	[ES:BX+TRANS],SI
  2315 00000643 09F6                    		or	SI,SI
  2316 00000645 0F899CFD                		jns	EXIT
  2317                                  
  2318                                  		; make sure we ask ROM for media check
  2319                                  		;mov	byte [CS:TIM_DRV],-1
  2320 00000649 C606[3701]FF            		mov	byte [TIM_DRV],-1 ; 11/04/2018
  2321 0000064E E994FD                  		jmp	EXIT
  2322                                  
  2323                                  ;
  2324                                  ; PERFORM A CHECK ON THE TIME PASSED SINCE THE LAST ACCESS FOR THIS
  2325                                  ; PHYSICAL DRIVE.
  2326                                  ; WE ARE ACCESSING THE SAME DRIVE.  IF THE TIME OF LAST SUCCESSFUL ACCESS
  2327                                  ; WAS LESS THAN 2 SECONDS AGO, THEN WE MAY PRESUME THAT THE DISK WAS NOT
  2328                                  ; CHANGED
  2329                                  ; RETURNS IN SI:
  2330                                  ;	0 - IF TIME OF LAST ACCESS WAS >= 2 SECONDS
  2331                                  ;	1 - IF TIME WAS < 2 SECONDS (I.E NO MEDIA CHANGE ASSUMED)
  2332                                  ; REGISTERS AFFECTED AX,CX,DX, FLAGS.
  2333                                  ;
  2334                                  
  2335                                  CHECK_TIME_OF_ACCESS:
  2336                                  
  2337 00000651 BE0100                  		mov	si,1			; Presume no change
  2338                                  		;;Rev 3.30 Modification
  2339 00000654 30E4                    		xor	AH, AH			; set command to read time
  2340 00000656 CD1A                    		int	1Ah			; call rom-bios clock routine
  2341                                  
  2342                                  ;
  2343                                  ; Once time is read, must make sure the date wrap is not lost.	The ROM will
  2344                                  ; return the value only once, it must check for day wrap on each call.
  2345                                  ;
  2346 00000658 D0E8                    		SHR	AL,1
  2347                                  		;ADC	word [CS:DAYCNT],0	; ADD IT TO OUR SAVED DAY COUNT
  2348 0000065A 8316[5403]00            		ADC	word [DAYCNT], 0 ; 11/04/2018
  2349                                  ;
  2350                                  ; Compute elapsed time1
  2351                                  ;
  2352                                  		; 08/04/2018
  2353                                  		; Retro DOS v2.0
  2354                                  		;MOV	AX,[CS:TIM_LO]		; GET STORED TIME
  2355                                  		; 11/04/2018
  2356 0000065F A1[C900]                		MOV	AX,[TIM_LO]
  2357 00000662 29C2                    		SUB	DX,AX
  2358                                  		;MOV	AX,[CS:TIM_HI]
  2359 00000664 A1[CB00]                		MOV	AX,[TIM_HI]
  2360 00000667 19C1                    		SBB	CX,AX
  2361                                  ;
  2362                                  ; CX:DX is the elapsed time
  2363                                  ;
  2364 00000669 7515                    		JNZ	short TimeCheck_Unk	; CX <> 0 => > 1 hour
  2365 0000066B 09D2                    		OR	DX,DX			; did some time pass?
  2366 0000066D 750C                    		JNZ	short TimePassed	; yes, examine max value
  2367                                  ;
  2368                                  ; No noticeable time has passed. There are two possibilities. First there
  2369                                  ; could be two driver calls with in one clock tick (55 milliseconds).  The
  2370                                  ; second possibility is the program has reprogramed the counter -- this is
  2371                                  ; the unreliable counter case. To distinguish between the case a count is
  2372                                  ; kept of the number of calls that happen without a clock tick (the variable
  2373                                  ; is AccessCount).  If this count exceeds a set limit (MaxAccess) it is
  2374                                  ; assumed the counter is unreliable and the value don't know is returned.
  2375                                  ; If AccessCount is less than MaxAccess we assume the time is valid and
  2376                                  ; therefore the media has not changed.
  2377                                  ;
  2378                                  		;inc	byte [cs:AccessCount]
  2379                                  		; 11/04/2018
  2380 0000066F FE06[3601]              		inc	byte [AccessCount]
  2381                                  						; Exceeded threshold for count?
  2382                                  		;cmp	byte [cs:AccessCount],AccessMax
  2383 00000673 720C                    		jb	short TimeCheck_Ret	; no, return media unchanged
  2384                                  		;dec	byte [cs:AccessCount]	; don't let the count wrap
  2385 00000675 FE0E[3601]              		dec	byte [AccessCount]
  2386 00000679 EB05                    		jmp	short TimeCheck_Unk	; "I don't know" if media changed
  2387                                  
  2388                                  ;
  2389                                  ; If this code is reached some time has passed.  Need to determine if
  2390                                  ; 2 seconds have passed.  Note: 18.2 ticks per second.
  2391                                  ;
  2392                                  TimePassed:
  2393 0000067B 83FA24                  		CMP	DX,18 * 2		; IF ( Time_passed <= 2secs )
  2394 0000067E 7601                    		JBE	short TimeCheck_Ret	;      presume no change
  2395                                  
  2396                                  
  2397                                  ; Everything indicates that we do not know what has happened.
  2398                                  ;
  2399                                  TimeCheck_Unk:
  2400 00000680 4E                      		DEC	SI			; Presume I don't know
  2401                                  TimeCheck_Ret:
  2402 00000681 C3                      		RETN
  2403                                  
  2404                                  ERR$EXITJ: 
  2405 00000682 E953FD                  		JMP 	ERR$EXIT
  2406                                  
  2407                                  
  2408                                  ;------------------------------------------------------------------------
  2409                                  ;									:
  2410                                  ;		Get Bios Parameter Block				:
  2411                                  ;									:
  2412                                  ; GET$BPB is called to build a valid BPB for the media in the disk	:
  2413                                  ; drive.  A BPB (Bios Parameter Block) contains information about	:
  2414                                  ; the media which is currently in the drive.  The values stored is	:
  2415                                  ; information like number of fat sectors, size of drive, 8 or 9 sectors,:
  2416                                  ; etc.									:
  2417                                  ;									:
  2418                                  ;	This routine is called by the device drive code.		:
  2419                                  ;									:
  2420                                  ;	On entry AL contains the logical drive number which needs	:
  2421                                  ;	  the BPB built.						:
  2422                                  ;	ES:[di] points to a buffer; the first byte of the buffer is a	:
  2423                                  ;	   media decriptor byte.					:
  2424                                  ;									:
  2425                                  ;------------------------------------------------------------------------
  2426                                  ;
  2427                                  ; Build a valid BPB for the disk in the drive.
  2428                                  ;
  2429                                  
  2430                                  GET$BPB:
  2431 00000685 268A25                  		mov	AH,[ES:DI]		; get FAT ID byte read by DOS
  2432 00000688 E81500                  		call	SETDRIVE		; get the correct BDS for the drv
  2433                                  		; 08/04/2018
  2434                                  		;;;Rev 3.30 Modification
  2435                                  		;TEST	word [DI+BDS.Flags],fNon_Removable
  2436                                  		;JNZ	short ALREADY_GOTBPB	; NO NEED TO BUILD FOR FIXED DISKS
  2437                                  		;;End of Modification
  2438                                  		;call	GETBP			; build a BPB if necessary.
  2439 0000068B 72F5                    		jc	short ERR$EXITJ		; if error exit
  2440                                  ;SET_PATCH:
  2441                                  ;		CALL	Set_Volume_ID
  2442                                  ;ALREADY_GOTBPB:
  2443                                  ;		add	di,BDS.BytePerSec	; return the BPB that is in the current BDS
  2444                                  
  2445                                  SetPTRSAV:					; return point for DSK$INIT
  2446                                  		;les	BX,[CS:PTRSAV]
  2447 0000068D C41E[6E00]              		les	BX,[PTRSAV] ; 11/04/2018
  2448 00000691 2688670D                		mov	[ES:BX+MEDIA],AH
  2449 00000695 26897F12                		mov	[ES:BX+COUNT],DI
  2450 00000699 268C5F14                		mov	[ES:BX+COUNT+2],DS
  2451 0000069D E945FD                  		jmp	EXIT
  2452                                  
  2453                                  ;
  2454                                  ; SetDrive scans through the data structure of BDSs and returns a
  2455                                  ; pointer to the BDS that belongs to the drive specified in AL.
  2456                                  ; Carry is set if no BDS has a logical drive number which matches the
  2457                                  ; value in AL.
  2458                                  ;	Input:
  2459                                  ;	  AL contains the logical drive number
  2460                                  ;	Output:
  2461                                  ;	  DS:DI points to correct BDS if Carry is clear.
  2462                                  ;
  2463                                  ;	 All register execpt DS and DI are preserved
  2464                                  ;
  2465                                  
  2466                                  SETDRIVE:
  2467                                  		; 08/04/2018
  2468                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  2469 000006A0 50                      		push	ax
  2470 000006A1 3A06[C800]              		cmp	al, [DRVMAX]
  2471 000006A5 7204                    		jb	short CHECKHARDDISK
  2472                                  		;
  2473 000006A7 B007                    		mov	al,error_unknown_media
  2474 000006A9 F9                      		stc
  2475 000006AA C3                      		retn
  2476                                  CHECKHARDDISK:
  2477 000006AB 80E4F8                  		and	ah, 0F8h
  2478 000006AE 80FCF8                  		cmp	ah, 0F8h
  2479 000006B1 740D                    		je	short SETHARDDISK
  2480                                  SETFLOPPYDISK:
  2481 000006B3 30E4                    		xor	ah, ah
  2482 000006B5 BF[BA08]                		mov	di, DSKDRVS
  2483 000006B8 D0E0                    		shl	al, 1
  2484 000006BA 01C7                    		add	di, ax
  2485 000006BC 8B3D                    		mov	di, [DI] 
  2486                                  SETDRIVE_OK:
  2487 000006BE 58                      		pop	ax
  2488 000006BF C3                      		retn
  2489                                  SETHARDDISK:
  2490 000006C0 BF[D609]                		mov	di, HD0_PARAMETERS
  2491 000006C3 3A06[D300]              		cmp	al, [HARDNUM]
  2492 000006C7 74F5                    		je	short SETDRIVE_OK
  2493 000006C9 72E8                    		jb	short SETFLOPPYDISK
  2494 000006CB BF[E909]                		mov	di, HD1_PARAMETERS
  2495 000006CE EBEE                    		jmp	short SETDRIVE_OK
  2496                                  
  2497                                  
  2498                                  
  2499                                  ;------------------------------------------------------------------------
  2500                                  ;									:
  2501                                  ;		DISK I/O ROUTINES					:
  2502                                  ;									:
  2503                                  ;  On entry the register contain the following values:			:
  2504                                  ;									:
  2505                                  ;	AH - Media Descriptor byte					:
  2506                                  ;	AL - logical drive number					:
  2507                                  ;	CX - count of sectors to be read or written			:
  2508                                  ;	DX - start sector						:
  2509                                  ;	DI - offset of destination buffer				:
  2510                                  ;									:
  2511                                  ;------------------------------------------------------------------------
  2512                                  
  2513                                  
  2514                                  ;------------------------------------------------------------------------
  2515                                  ;									:
  2516                                  ;		Disk Write with Verify					:
  2517                                  ;									:
  2518                                  ;  Input								:
  2519                                  ;	See about header for register contents on entry.		:
  2520                                  ;									:
  2521                                  ;------------------------------------------------------------------------
  2522                                  
  2523                                  
  2524                                  DSK$WRITV:
  2525 000006D0 2EC706[CD00]0301        		MOV	WORD [CS:WRTVERIFY],103H
  2526 000006D7 EB07                    		JMP	SHORT DSK$CL
  2527                                  
  2528                                  ;------------------------------------------------------------------------
  2529                                  ;									:
  2530                                  ;		       Disk Write					:
  2531                                  ;									:
  2532                                  ;  Input								:
  2533                                  ;	See about header for register contents on entry.		:
  2534                                  ;									:
  2535                                  ;------------------------------------------------------------------------
  2536                                  
  2537                                  DSK$WRIT:
  2538 000006D9 2EC706[CD00]0300        		MOV	WORD [CS:WRTVERIFY],ROMWrite
  2539                                  
  2540                                  DSK$CL:
  2541 000006E0 E83500                  		CALL	DISKIO
  2542                                  DSK$IO:
  2543 000006E3 7203                    		JC	short DSKBad
  2544 000006E5 E9FDFC                  		JMP	EXIT
  2545                                  DSKBad:
  2546 000006E8 E9E6FC                  		JMP	ERR$CNT
  2547                                  
  2548                                  ;------------------------------------------------------------------------
  2549                                  ;									:
  2550                                  ;			Disk Read					:
  2551                                  ;									:
  2552                                  ;  Input								:
  2553                                  ;	See about header for register contents on entry.		:
  2554                                  ;									:
  2555                                  ;------------------------------------------------------------------------
  2556                                  
  2557                                  DSK$READ:
  2558 000006EB E82500                  		CALL	DISKRD
  2559 000006EE EBF3                    		JMP	short DSK$IO
  2560                                  
  2561                                  ;
  2562                                  ; Miscellaneous odd jump routines.  Moved out of mainline for speed.
  2563                                  ;
  2564                                  
  2565                                  
  2566                                  ;
  2567                                  ; CheckSingle determines if the drive specified is a virtual drive (more
  2568                                  ; than one logical drive associated with one physical drive). If this
  2569                                  ; is the case we need to prompt the user to place the correct disk in
  2570                                  ; the drive.
  2571                                  ;
  2572                                  ;	Input:
  2573                                  ;	   DS:DI pints to the BDS for the drive being checked.
  2574                                  ;
  2575                                  ;	If there is a error the carry flag is set on return
  2576                                  ;
  2577                                  ;  All registers are preserved.
  2578                                  ;
  2579                                  
  2580                                  CHECKSINGLE:
  2581                                  		; 13/04/2018
  2582                                  		;push	ax
  2583                                  		;mov	[MEDIACHK_DRV], al
  2584                                  		;cmp	byte [cs:Single],1	; single drive system?
  2585 000006F0 803E[CF00]01            		cmp	byte [Single], 1
  2586 000006F5 7217                    		jb	short SingleRet		; no, jump down
  2587                                  		;mov	al,[CS:MEDIACHK_DRV]
  2588                                  		;mov	al,[MEDIACHK_DRV]
  2589 000006F7 50                      		push	ax
  2590 000006F8 1E                      		push	ds
  2591 000006F9 57                      		push	di
  2592 000006FA 31FF                    		xor	di,di	
  2593 000006FC 8EDF                    		mov	ds,di
  2594 000006FE 88C4                    		mov	ah, al
  2595 00000700 86260405                		xchg	ah,[LSTDRV] ; 10/04/2018
  2596 00000704 5F                      		pop	di
  2597 00000705 1F                      		pop	ds
  2598 00000706 38C4                    		cmp	ah,al
  2599                                  		;je	short SingleRet
  2600 00000708 7403                    		je	short SingleRet_pop ; 13/04/2018
  2601                                  
  2602 0000070A E8C301                  		call	SWPDSK			; ask user for correct disk
  2603                                  		;mov	al, [MEDIACHK_DRV] ; 13/04/2018
  2604                                  ;SingleRet:
  2605                                  SingleRet_pop:
  2606 0000070D 58                      		pop	ax
  2607                                  SingleRet:
  2608 0000070E C3                      		retn				; return
  2609                                  
  2610                                  ;
  2611                                  ; BadDrive is called when sector specified is greater than last
  2612                                  ; sector on disk.
  2613                                  ; or when BDS is not found for drive
  2614                                  ;
  2615                                  
  2616                                  BadDrive:
  2617 0000070F B008                    		mov	AL,8			; error code 'sector not found'
  2618 00000711 F9                      		stc				; indicate error
  2619                                  IORET:	
  2620 00000712 C3                      		retn				; return
  2621                                  
  2622                                  ;------------------------------------------------------------
  2623                                  ;
  2624                                  ;	DISK I/O HANDLER
  2625                                  ;
  2626                                  ;   On entry:
  2627                                  ;	AL = Drive Number (0-6)
  2628                                  ;	AH = Media Descriptor
  2629                                  ;	CX = sector count
  2630                                  ;	DX = first sector
  2631                                  ;	DS = CS
  2632                                  ;	ES:DI = transfer address
  2633                                  ;	[RFLAG] = operation (2 for read, 3 for write)
  2634                                  ;	[VERIFY] = 1 for verity after write
  2635                                  ;
  2636                                  ;   On exit:
  2637                                  ;	if successful carry flag = 0
  2638                                  ;	  else CF=1 and AL contains error code
  2639                                  ;
  2640                                  
  2641                                  DISKRD:
  2642                                  		;mov	byte [CS:RFLAG],ROMRead	; set command to read
  2643 00000713 C606[CD00]02            		mov	byte [RFLAG],ROMRead	 ; 11/04/2018
  2644                                  
  2645                                  DISKIO:
  2646                                  		; 13/04/2018
  2647                                  		; 08/04/2018
  2648                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  2649                                  
  2650 00000718 F8                      		clc
  2651 00000719 E3F7                    		jcxz	IORET
  2652                                  		
  2653                                  		;mov	[CS:SPSAV],SP		; save the sp value
  2654 0000071B 8926[D900]              		mov	[SPSAV],sp
  2655                                  
  2656 0000071F 89FB                    		mov	BX,DI			; ES:BX is transfer address
  2657 00000721 E87CFF                  		call	SETDRIVE		; map logical and physical
  2658 00000724 72E9                    		jc	short BadDrive		; carry means BDS not found
  2659                                  		;mov	al,[DI+BDS.Mediad]
  2660                                  		;mov	[CS:MedByt],al		; Preserve media byte for drive for use
  2661                                  						; in determining media change.
  2662                                  		; DX = Sector address (offset)
  2663                                  		; BX = Buffer address (offset)
  2664                                  		
  2665                                  ; Ensure that we are trying to access valid sectors on the drive
  2666                                  ;
  2667 00000726 89D6                    		mov	SI,DX			; start with first sector
  2668 00000728 01CE                    		add	SI,CX			; add in sector count
  2669 0000072A 035511                  		add	DX,[DI+17]		; add in the hidden sectors
  2670 0000072D 3B7508                  		cmp	SI,[DI+8]		; compare against max (volume size)
  2671 00000730 77DD                    		ja	short BadDrive		; if greater than max, error
  2672                                  		;mov	[CS:SECCNT],CX		; save sector count
  2673 00000732 890E[D100]              		mov	[SECCNT],CX
  2674                                  
  2675                                  ; For hard drives do not do media check or set DPT.
  2676                                  ;
  2677                                  		; 13/04/2018	
  2678                                  		;mov	[MEDIACHK_DRV],al
  2679                                  
  2680 00000736 3A06[D300]              		cmp	al, [HARDNUM]
  2681 0000073A 730E                    		jnb	short SKIP1
  2682                                  
  2683 0000073C E8B1FF                  		CALL	CHECKSINGLE
  2684                                  
  2685                                  		; AL = Drive number (0,1,2,3) 
  2686                                  
  2687                                  		; DX = Sector address (LBA/physical)
  2688                                  		; BX = Buffer address (offset)
  2689                                  
  2690 0000073F 803E[CF00]00            		cmp	byte [Single], 0
  2691 00000744 7606                    		jna	short SKIP2
  2692 00000746 30C0                    		xor	al, al ;  Logical B: -> Physical drive 0 (A:)
  2693 00000748 EB02                    		JMP	SHORT SKIP2
  2694                                  SKIP1:
  2695 0000074A 047E                    		ADD	AL, 7Eh
  2696                                  SKIP2:
  2697 0000074C A2[D400]                		mov	[DRVNUM], AL	
  2698                                  
  2699 0000074F 89D0                    		mov	AX,DX			; setup logical sector for divide
  2700 00000751 31D2                    		xor	DX,DX
  2701 00000753 F7750D                  		div	word [DI+13]		; divide by sectors per track
  2702 00000756 FEC2                    		inc	DL
  2703                                  		;mov	[CS:CURSEC],DL		; save current sector
  2704 00000758 8816[D600]              		mov	[CURSEC],DL
  2705 0000075C 8B4D0F                  		mov	CX,[DI+15]		; get number of heads
  2706 0000075F 31D2                    		xor	DX,DX			; divide tracks by heads per cylinder
  2707 00000761 F7F1                    		div	CX
  2708                                  		;mov	[CS:CURHD],DL		; save current head
  2709 00000763 8816[D500]              		mov	[CURHD],DL
  2710                                  		;mov	[CS:CURTRK],AX		; save current track
  2711 00000767 A3[D700]                		mov	[CURTRK],AX
  2712                                  
  2713                                  ;
  2714                                  ; We are now set up for the I/O. Normally, we consider the DMA boundary
  2715                                  ; violations here.  
  2716                                  
  2717                                  		;mov	AX,[CS:SECCNT]
  2718                                  
  2719                                  		; 08/04/2018
  2720                                  		; RetRo DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  2721                                  
  2722 0000076A A1[D100]                		mov	ax, [SECCNT]
  2723 0000076D 8CC6                    		mov	si, es
  2724 0000076F D1E6                    		shl	si, 1
  2725 00000771 D1E6                    		shl	si, 1
  2726 00000773 D1E6                    		shl	si, 1
  2727 00000775 D1E6                    		shl	si, 1
  2728 00000777 01DE                    		add	si, bx
  2729 00000779 81C6FF01                		add	si, 511
  2730 0000077D 721B                    		jc	short ACROSS_64K
  2731 0000077F 87DE                    		xchg	bx, si
  2732 00000781 D0EF                    		shr	bh, 1
  2733 00000783 B480                    		mov	ah, 128
  2734 00000785 28FC                    		sub	ah, bh
  2735 00000787 87DE                    		xchg	bx, si
  2736 00000789 38C4                    		cmp	ah, al
  2737 0000078B 7602                    		jbe	short SKIP3
  2738 0000078D 88C4                    		mov	ah, al
  2739                                  SKIP3:
  2740 0000078F 50                      		push	ax
  2741 00000790 88E0                    		mov	al, ah
  2742 00000792 E86400                  		call	RW_TRACKS
  2743 00000795 58                      		pop	ax
  2744 00000796 28E0                    		sub	al, ah
  2745 00000798 741A                    		jz	short SET_TIM
  2746                                  ACROSS_64K:
  2747 0000079A 50                      		push	ax
  2748 0000079B 06                      		push	es
  2749 0000079C 53                      		push	bx
  2750 0000079D E83400                  		call	MOVE_BUFFER_CONTENT
  2751 000007A0 80C702                  		add	bh, 2
  2752 000007A3 E87500                  		call	RW_ONE_SECTOR
  2753 000007A6 5B                      		pop	bx
  2754 000007A7 07                      		pop	es
  2755 000007A8 58                      		pop	ax
  2756 000007A9 E82800                  		call	MOVE_BUFFER_CONTENT
  2757 000007AC FEC8                    		dec	al
  2758 000007AE 80C702                  		add	bh, 2
  2759 000007B1 E84500                  		call	RW_TRACKS
  2760                                  SET_TIM:
  2761                                  		 ; 13/04/2018
  2762                                  		;MOV	AL,[MEDIACHK_DRV]
  2763                                  		;MOV	AL, [DRVNUM]
  2764                                  
  2765                                  		;cmp	al,[HARDNUM]
  2766 000007B4 3A16[D300]              		CMP	DL, [HARDNUM]
  2767 000007B8 7319                    		jnb	short SKIP4
  2768                                  
  2769                                  		;MOV	[CS:TIM_DRV],AL 	; SAVE DRIVE LETTER
  2770                                  		;MOV	[TIM_DRV],AL 		; save drive number
  2771 000007BA 8816[3701]              		MOV	[TIM_DRV],DL
  2772                                  
  2773 000007BE 30E4                    		xor	ah, ah
  2774 000007C0 CD1A                    		int	1Ah		; CLOCK	- GET TIME OF DAY
  2775                                  					; Return: CX:DX	= clock	count
  2776                                  					; AL = 00h if clock was	read or	written
  2777                                  					; (via AH=0,1) since the previous
  2778                                  					; midnight; Otherwise, AL > 0
  2779 000007C2 08C0                    		or	al, al
  2780 000007C4 7404                    		jz	short NOROLL3
  2781 000007C6 FF06[5403]              		inc	word [DAYCNT]
  2782                                  NOROLL3:
  2783 000007CA 8916[C900]              		mov	[TIM_LO], dx
  2784 000007CE 890E[CB00]              		mov	[TIM_HI], cx
  2785 000007D2 F8                      		clc
  2786                                  SKIP4:
  2787 000007D3 C3                      		retn
  2788                                  
  2789                                  ;----------------------------------------------------------------------------
  2790                                  
  2791                                  MOVE_BUFFER_CONTENT:
  2792                                  		; 08/04/2018 (IBMDOS 2.1, IBMBIO.COM)
  2793                                  		; Retro DOS v2.0
  2794                                  		; save/restore existing data before/after buffer offset change
  2795                                  		; (this is done for solving dma boundary error problem)
  2796                                  
  2797 000007D4 57                      		push	di
  2798 000007D5 53                      		push	bx
  2799 000007D6 50                      		push	ax
  2800 000007D7 89DF                    		mov	di, bx
  2801 000007D9 80C702                  		add	bh, 2
  2802 000007DC 89DE                    		mov	si, bx
  2803 000007DE FC                      		cld
  2804 000007DF B90001                  		mov	cx, 256
  2805                                  MOVEBUFFER_LOOP:
  2806 000007E2 268B1D                  		mov	bx, [es:di]
  2807 000007E5 268B04                  		mov	ax, [es:si]
  2808 000007E8 26891C                  		mov	[es:si], bx
  2809 000007EB AB                      		stosw
  2810 000007EC 46                      		inc	si
  2811 000007ED 46                      		inc	si
  2812 000007EE E2F2                    		loop	MOVEBUFFER_LOOP
  2813 000007F0 8036[D000]01            		xor	byte [CURSECBUF], 1
  2814 000007F5 58                      		pop	ax
  2815 000007F6 5B                      		pop	bx
  2816 000007F7 5F                      		pop	di
  2817                                  RET3:
  2818 000007F8 C3                      		retn
  2819                                  
  2820                                  ;----------------------------------------------------------------------------
  2821                                  
  2822                                  RW_TRACKS:
  2823 000007F9 08C0                    		or	al, al
  2824 000007FB 74FB                    		jz	short RET3
  2825 000007FD 8A650D                  		mov	ah, [di+0Dh]	; bsSecPerTrack
  2826 00000800 FEC4                    		inc	ah
  2827 00000802 2A26[D600]              		sub	ah, [CURSEC]	; sector number on track
  2828 00000806 38C4                    		cmp	ah, al
  2829 00000808 7602                    		jbe	short SKIP5	; sector count overs track limit
  2830 0000080A 88C4                    		mov	ah, al		; fit to sector count
  2831                                  SKIP5:
  2832 0000080C 50                      		push	ax
  2833 0000080D 88E0                    		mov	al, ah		; read (remain) sectors on track
  2834 0000080F E80B00                  		call	RW_SECTORS
  2835 00000812 58                      		pop	ax
  2836 00000813 28E0                    		sub	al, ah
  2837 00000815 D0E4                    		shl	ah, 1		; 256 --> 512 (bx)
  2838 00000817 00E7                    		add	bh, ah		; +1X sector = +2X*256 bytes
  2839 00000819 EBDE                    		jmp	short RW_TRACKS
  2840                                  
  2841                                  ;----------------------------------------------------------------------------
  2842                                  
  2843                                  RW_ONE_SECTOR:
  2844 0000081B B001                    		mov	al, 1
  2845                                  
  2846                                  RW_SECTORS:
  2847                                  		; 09/04/2018
  2848                                  		; Retro DOS v2.0
  2849                                  
  2850                                  		;mov	si, 5
  2851 0000081D BE0500                  		MOV	SI, MAXERR
  2852 00000820 8A26[CD00]              		mov	ah, [RFLAG]
  2853                                  RETRY:
  2854 00000824 50                      		push	ax
  2855 00000825 8B16[D700]              		mov	dx, [CURTRK]
  2856 00000829 B106                    		mov	cl, 6
  2857 0000082B D2E6                    		shl	dh, cl
  2858 0000082D 0A36[D600]              		or	dh, [CURSEC]
  2859 00000831 89D1                    		mov	cx, dx
  2860 00000833 86E9                    		xchg	ch, cl
  2861 00000835 8B16[D400]              		mov	dx, [DRVNUM]
  2862 00000839 CD13                    		int	13h
  2863 0000083B 7240                    		jc	short DSKERR
  2864 0000083D 58                      		pop	ax
  2865 0000083E 50                      		push	ax
  2866                                  NO_SET:
  2867 0000083F 813E[CD00]0301          		cmp	word [RFLAG], 103h
  2868 00000845 7506                    		jne	short NoVerify
  2869 00000847 B404                    		mov	ah, 4
  2870 00000849 CD13                    		int	13h
  2871 0000084B 7230                    		jc	short DSKERR
  2872                                  NoVerify:
  2873 0000084D 58                      		pop	ax
  2874 0000084E 80E13F                  		and	cl, 3Fh
  2875 00000851 30E4                    		xor	ah, ah
  2876 00000853 2906[D100]              		sub	[SECCNT], ax
  2877 00000857 00C1                    		add	cl, al
  2878 00000859 880E[D600]              		mov	[CURSEC], cl
  2879 0000085D 3A4D0D                  		cmp	cl, [di+0Dh]  ; bsSecPerTrack	
  2880 00000860 761A                    		jbe	short Disk_Ret
  2881 00000862 C606[D600]01            		mov	byte [CURSEC], 1
  2882 00000867 8A36[D500]              		mov	dh, [CURHD]
  2883 0000086B FEC6                    		inc	dh
  2884 0000086D 3A750F                  		cmp	dh, [di+0Fh]  ; bsHeads	
  2885 00000870 7206                    		jb	short NOXOR
  2886 00000872 30F6                    		xor	dh, dh
  2887 00000874 FF06[D700]              		inc	word [CURTRK]
  2888                                  NOXOR:
  2889 00000878 8836[D500]              		mov	[CURHD], dh
  2890                                  Disk_Ret:
  2891 0000087C C3                      		retn
  2892                                  
  2893                                  DSKERR:
  2894                                  		; 09/04/2018
  2895                                  		; Retro DOS v2.0
  2896                                  
  2897                                  		; reset the disk and decrement retry cnt
  2898 0000087D 50                      		push	ax
  2899 0000087E B400                    		mov	ah, 0
  2900 00000880 CD13                    		int	13h
  2901 00000882 58                      		pop	ax		; Restore sector count
  2902 00000883 4E                      		dec	si
  2903 00000884 7405                    		jz	short HARDERR
  2904 00000886 80FC80                  		cmp	ah, 80h		; timeout?
  2905                                  		;jz	short HARDERR 	; yes, jump to hard error
  2906                                  		;jmp	short RETRY	; and try again
  2907 00000889 7599                    		jne	short RETRY	
  2908                                  HARDERR:
  2909 0000088B 803E[D000]00            		cmp	byte [CURSECBUF], 0
  2910 00000890 7606                    		jna	short HARDERR1
  2911 00000892 5B                      		pop	bx 	; ax, disk sector address 
  2912 00000893 5B                      		pop	bx 	; bx
  2913 00000894 07                      		pop	es 	; es 	
  2914 00000895 E83CFF                  		call	MOVE_BUFFER_CONTENT
  2915                                  HARDERR1:		
  2916                                  ;		CALL	MAPERROR
  2917                                  ;HARDERR2:			; for routines that call MapError themselves
  2918                                  ;		;mov	byte [CS:TIM_DRV],-1 	;Force a media check through ROM
  2919                                  ;		mov	byte [TIM_DRV], -1
  2920                                  ;		;mov	CX,[CS:SECCNT]		;Get count of sectors to go
  2921                                  ;		mov	CX,[SECCNT]
  2922                                  ;		;mov	SP,[CS:SPSAV]		;Recover entry stack pointer
  2923                                  ;		mov	SP,[SPSAV]
  2924                                  ;		;stc
  2925                                  ;		retn			;and return
  2926                                  
  2927                                  
  2928                                  ;----------------------------------------------------------------------------
  2929                                  
  2930                                  ;
  2931                                  ; Map error returned by ROM into corresponding code to be returned to
  2932                                  ; DOS in AL.
  2933                                  ;
  2934                                  MAPERROR:
  2935                                  		;push	CX			; save cx
  2936 00000898 0E                      		push	CS
  2937 00000899 07                      		pop	ES			; make ES the local segment
  2938 0000089A 88E0                    		mov	AL,AH			; move error code into AL
  2939                                  		;mov	[CS:LSTERR],AL		; terminate list with error code
  2940 0000089C A2[4001]                		mov	[LSTERR],AL
  2941 0000089F B90800                  		mov	CX,NUMERR		; number of possible error conditions
  2942 000008A2 BF[3901]                		mov	DI,ERRIN	 	; point to error conditions
  2943 000008A5 F2AE                    		repne	SCASB
  2944                                  		;mov	AL,[CS:DI + NUMERR - 1]	; get translation
  2945 000008A7 8A4509                  		mov	AL,[DI+NUMERR+1]
  2946                                  		;pop	cx			; restore cx
  2947                                  ;		stc				; flag error condition
  2948                                  ;		retn
  2949                                  
  2950                                  HARDERR2:			; for routines that call MapError themselves
  2951                                  		;mov	byte [CS:TIM_DRV],-1 	;Force a media check through ROM
  2952 000008AA C606[3701]FF            		mov	byte [TIM_DRV], -1
  2953                                  		;mov	CX,[CS:SECCNT]		;Get count of sectors to go
  2954 000008AF 8B0E[D100]              		mov	CX,[SECCNT]
  2955                                  		;mov	SP,[CS:SPSAV]		;Recover entry stack pointer
  2956 000008B3 8B26[D900]              		mov	SP,[SPSAV]
  2957 000008B7 F9                      		stc
  2958 000008B8 C3                      		retn			;and return
  2959                                  
  2960                                  
  2961                                  ; include msioctl.inc
  2962                                  
  2963                                  ;-----------------------------------------------------------------------------
  2964                                  ; include msioctl.inc - MSDOS 3.3 - MSDISK.ASM - 02/02/1988
  2965                                  ;-----------------------------------------------------------------------------
  2966                                  ; 24/03/2018 - Retro DOS v2.0
  2967                                  
  2968                                  		; include ioctl.inc
  2969                                  
  2970                                  ; IOCTL.INC - MSDOS 6.0 - 1991
  2971                                  ; ............................................................................
  2972                                  
  2973                                  ;*** J.K.
  2974                                  ;General Guide -
  2975                                  ;Category Code:
  2976                                  ; 0... .... DOS Defined
  2977                                  ; 1... .... User defined
  2978                                  ; .xxx xxxx Code
  2979                                  
  2980                                  ;Function Code:
  2981                                  ; 0... .... Return error if unsupported
  2982                                  ; 1... .... Ignore if unsupported
  2983                                  ; .0.. .... Intercepted by DOS
  2984                                  ; .1.. .... Passed to driver
  2985                                  ; ..0. .... Sends data/commands to device
  2986                                  ; ..1. .... Quries data/info from device
  2987                                  ; ...x .... Subfunction
  2988                                  ;
  2989                                  ; Note that "Sends/queries" data bit is intended only to regularize the
  2990                                  ; function set.  It plays no critical role; some functions may contain both
  2991                                  ; command and query elements. The convention is that such commands are
  2992                                  ; defined as "sends data".
  2993                                  
  2994                                  ;*****************************;*
  2995                                  ; BLOCK DRIVERS 	      ;*
  2996                                  ;*****************************;*
  2997                                  
  2998                                  ; IOCTL SUB-FUNCTIONS
  2999                                  IOCTL_GET_DEVICE_INFO	EQU	0
  3000                                  IOCTL_SET_DEVICE_INFO	EQU	1
  3001                                  IOCTL_READ_HANDLE	EQU	2
  3002                                  IOCTL_WRITE_HANDLE	EQU	3
  3003                                  IOCTL_READ_DRIVE	EQU	4
  3004                                  IOCTL_WRITE_DRIVE	EQU	5
  3005                                  IOCTL_GET_INPUT_STATUS	EQU	6
  3006                                  IOCTL_GET_OUTPUT_STATUS EQU	7
  3007                                  IOCTL_CHANGEABLE?	EQU	8
  3008                                  IOCTL_DeviceLocOrRem?	EQU	9
  3009                                  IOCTL_HandleLocOrRem?	EQU	0Ah   ;10
  3010                                  IOCTL_SHARING_RETRY	EQU	0Bh   ;11
  3011                                  GENERIC_IOCTL_HANDLE	EQU	0Ch   ;12
  3012                                  GENERIC_IOCTL		EQU	0Dh   ;13
  3013                                  IOCTL_GET_DRIVE_MAP 	EQU	0Eh   ;14
  3014                                  IOCTL_SET_DRIVE_MAP	EQU	0Fh   ;15
  3015                                  IOCTL_QUERY_HANDLE	EQU	10h   ;16
  3016                                  IOCTL_QUERY_BLOCK	EQU	11h   ;17
  3017                                  
  3018                                  ; GENERIC IOCTL SUB-FUNCTIONS
  3019                                  RAWIO			EQU	8
  3020                                  
  3021                                  ; RAWIO SUB-FUNCTIONS
  3022                                  GET_DEVICE_PARAMETERS	EQU	60H
  3023                                  SET_DEVICE_PARAMETERS	EQU	40H
  3024                                  READ_TRACK		EQU	61H
  3025                                  WRITE_TRACK		EQU	41H
  3026                                  VERIFY_TRACK		EQU	62H
  3027                                  FORMAT_TRACK		EQU	42H
  3028                                  GET_MEDIA_ID		EQU	66h	;AN000;AN003;changed from 63h
  3029                                  SET_MEDIA_ID		EQU	46h	;AN000;AN003;changed from 43h
  3030                                  GET_ACCESS_FLAG 	EQU	67h	;AN002;AN003;Unpublished function.Changed from 64h
  3031                                  SET_ACCESS_FLAG 	EQU	47h	;AN002;AN003;Unpublished function.Changed from 44h
  3032                                  SENSE_MEDIA_TYPE	EQU	68H	;Added for 5.00
  3033                                  
  3034                                  
  3035                                  ; SPECIAL FUNCTION FOR GET DEVICE PARAMETERS
  3036                                  BUILD_DEVICE_BPB	EQU	000000001B
  3037                                  
  3038                                  ; SPECIAL FUNCTIONS FOR SET DEVICE PARAMETERS
  3039                                  INSTALL_FAKE_BPB	EQU	000000001B
  3040                                  ONLY_SET_TRACKLAYOUT	EQU	000000010B
  3041                                  TRACKLAYOUT_IS_GOOD	EQU	000000100B
  3042                                  
  3043                                  ; SPECIAL FUNCTION FOR FORMAT TRACK
  3044                                  STATUS_FOR_FORMAT	EQU	000000001B
  3045                                  DO_FAST_FORMAT			equ	000000010B	;AN001;
  3046                                  ; CODES RETURNED FROM FORMAT STATUS CALL
  3047                                  FORMAT_NO_ROM_SUPPORT		EQU	000000001B
  3048                                  FORMAT_COMB_NOT_SUPPORTED	EQU	000000010B
  3049                                  
  3050                                  ; DEVICETYPE VALUES
  3051                                  MAX_SECTORS_IN_TRACK	EQU	63	; MAXIMUM SECTORS ON A DISK.(Was 40 in DOS 3.2)
  3052                                  DEV_5INCH		EQU	0
  3053                                  DEV_5INCH96TPI		EQU	1
  3054                                  DEV_3INCH720KB		EQU	2
  3055                                  DEV_8INCHSS		EQU	3
  3056                                  DEV_8INCHDS		EQU	4
  3057                                  DEV_HARDDISK		EQU	5
  3058                                  DEV_OTHER		EQU	7
  3059                                  ;DEV_3INCH1440KB	EQU	7
  3060                                  DEV_3INCH2880KB		EQU	9
  3061                                  ; Retro DOS v2.0 - 26/03/2018
  3062                                  ;;DEV_TAPE		EQU	6
  3063                                  ;;DEV_ERIMO		EQU	8
  3064                                  ;DEV_3INCH2880KB	EQU	9
  3065                                  DEV_3INCH1440KB		EQU	10
  3066                                  
  3067                                  ;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
  3068                                  					; CURRENTLY SUPPORT.
  3069                                  MAX_DEV_TYPE		EQU	10
  3070                                  
  3071                                  struc A_SECTORTABLE
  3072 00000000 <res 00000002>          .ST_SECTORNUMBER:	resw	1
  3073 00000002 <res 00000002>          .ST_SECTORSIZE:		resw	1
  3074                                  .size:
  3075                                  endstruc
  3076                                  
  3077                                  ; MSDOS 6.0 - BPB.INC - 1991
  3078                                  ; ####
  3079                                  ;**	BIOS PARAMETER BLOCK DEFINITION
  3080                                  ;
  3081                                  ;	The BPB contains information about the disk structure. It dates
  3082                                  ;	back to the earliest FAT systems and so FAT information is
  3083                                  ;	intermingled with physical driver information.
  3084                                  ;
  3085                                  ;	A boot sector contains a BPB for its device; for other disks
  3086                                  ;	the driver creates a BPB. DOS keeps copies of some of this
  3087                                  ;	information in the DPB.
  3088                                  ;
  3089                                  ;	The BDS structure contains a BPB within it.
  3090                                  ;
  3091                                  
  3092                                  struc A_BPB
  3093 00000000 <res 00000002>          .BPB_BYTESPERSECTOR:	resw	1
  3094 00000002 <res 00000001>          .BPB_SECTORSPERCLUSTER:	resb	1
  3095 00000003 <res 00000002>          .BPB_RESERVEDSECTORS:	resw	1
  3096 00000005 <res 00000001>          .BPB_NUMBEROFFATS:	resb	1
  3097 00000006 <res 00000002>          .BPB_ROOTENTRIES: 	resw	1
  3098 00000008 <res 00000002>          .BPB_TOTALSECTORS:	resw	1
  3099 0000000A <res 00000001>          .BPB_MEDIADESCRIPTOR:	resb	1
  3100 0000000B <res 00000002>          .BPB_SECTORSPERFAT:	resw	1
  3101 0000000D <res 00000002>          .BPB_SECTORSPERTRACK:	resw	1
  3102 0000000F <res 00000002>          .BPB_HEADS:		resw	1
  3103 00000011 <res 00000002>          .BPB_HIDDENSECTORS:	resw	1
  3104 00000013 <res 00000002>          			resw	1
  3105 00000015 <res 00000002>          .BPB_BIGTOTALSECTORS:	resw	1
  3106 00000017 <res 00000002>          			resw	1
  3107 00000019 <res 00000006>          			resb	6	; NOTE:  many times these
  3108                                  ;					; 	 6 bytes are omitted
  3109                                  ;					;	 when BPB manipulations
  3110                                  ;					;	 are performed!
  3111                                  .size:
  3112                                  endstruc
  3113                                  ; ####
  3114                                  
  3115                                  struc A_DEVICEPARAMETERS
  3116 00000000 <res 00000001>          .DP_SPECIALFUNCTIONS:	resb	1
  3117 00000001 <res 00000001>          .DP_DEVICETYPE:		resb	1
  3118 00000002 <res 00000002>          .DP_DEVICEATTRIBUTES:	resw	1
  3119 00000004 <res 00000002>          .DP_CYLINDERS:		resw	1
  3120 00000006 <res 00000001>          .DP_MEDIATYPE:		resb	1
  3121 00000007 <res 0000001F>          .DP_BPB:		resb	A_BPB.size
  3122 00000026 <res 00000002>          .DP_TRACKTABLEENTRIES:	resw	1
  3123 00000028 <res 000000FC>          .DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
  3124                                  endstruc
  3125                                  
  3126                                  struc A_TRACKREADWRITEPACKET
  3127 00000000 <res 00000001>          .TRWP_SPECIALFUNCTIONS:	resb	1
  3128 00000001 <res 00000002>          .TRWP_HEAD:		resw	1
  3129 00000003 <res 00000002>          .TRWP_CYLINDER:		resw	1
  3130 00000005 <res 00000002>          .TRWP_FIRSTSECTOR:	resw	1
  3131 00000007 <res 00000002>          .TRWP_SECTORSTOREADWRITE: resw	1
  3132 00000009 <res 00000004>          .TRWP_TRANSFERADDRESS:	resd	1
  3133                                  endstruc
  3134                                  
  3135                                  ;AN001; - FP_TRACKCOUNT is only meaningful when FP_SPECIALFUNCTIONS bit 1 = 1.
  3136                                  struc A_FORMATPACKET
  3137 00000000 <res 00000001>          .FP_SPECIALFUNCTIONS:	resb	1  ; db ?
  3138 00000001 <res 00000002>          .FP_HEAD: 		resw	1  ; dw ? 
  3139 00000003 <res 00000002>          .FP_CYLINDER:		resw	1  ; dw ?
  3140 00000005 <res 00000002>          .FP_TRACKCOUNT:		resw	1  ; dw 1 ; !
  3141                                  endstruc
  3142                                  
  3143                                  struc A_VERIFYPACKET
  3144 00000000 <res 00000001>          .VP_SPECIALFUNCTIONS:	resb	1
  3145 00000001 <res 00000002>          .VP_HEAD: 		resw	1
  3146 00000003 <res 00000002>          .VP_CYLINDER:		resw	1
  3147                                  endstruc
  3148                                  
  3149                                  struc A_MEDIA_ID_INFO
  3150 00000000 <res 00000002>          .MI_LEVEL:		resw	1  ; dw 0 ; !		;J.K. 87 Info. level
  3151 00000002 <res 00000004>          .MI_SERIAL:		resd	1  ; dd ?		;J.K. 87 Serial #
  3152 00000006 <res 0000000B>          .MI_LABEL:		resb	11 ; db 11 DUP (' ') ;!	;J.K. 87 volume label
  3153 00000011 <res 00000008>          .MI_SYSTEM:		resb 	8  ; db 8 DUP (' ')  ;!	;J.K. 87 File system type
  3154                                  endstruc
  3155                                  
  3156                                  struc A_DISKACCESS_CONTROL	   ;AN002; Unpublished function. Only for Hard file.
  3157 00000000 <res 00000001>          .DAC_SPECIALFUNCTIONS:	resb 	1  ; db 0 ; ! ;AN002; Always 0
  3158 00000001 <res 00000001>          .DAC_ACCESS_FLAG: 	resb 	1  ; db 0 ; ! 
  3159                                  				   ; Non Zero - allow disk I/O to unformatted hard file
  3160                                  endstruc			   ; 0 - Disallow disk I/O to unformatted hard file
  3161                                  
  3162                                  
  3163                                  struc A_MEDIA_SENSE			; Media sense structure added 5.00
  3164 00000000 <res 00000001>          .MS_ISDEFAULT:		resb	1	; If 1 type returned is drv default
  3165 00000001 <res 00000001>          .MS_DEVICETYPE:		resb	1	; Drive type 
  3166 00000002 <res 00000001>          .MS_RESERVED1:		resb	1	; RESERVED
  3167 00000003 <res 00000001>          .MS_RESERVED2:		resb 	1	; RESERVED 
  3168                                  endstruc
  3169                                  
  3170                                  ;********************************;*
  3171                                  ; CHARACTER DEVICES (PRINTERS)	 ;*
  3172                                  ;********************************;*
  3173                                  
  3174                                  ;RAWIO SUB-FUNCTIONS
  3175                                  GET_RETRY_COUNT 	EQU	65H
  3176                                  SET_RETRY_COUNT 	EQU	45H
  3177                                  
  3178                                  struc A_RETRYCOUNT
  3179 00000000 <res 00000002>          .RC_COUNT:		resw 1
  3180                                  endstruc
  3181                                  
  3182                                  ;********************************;*		;J.K. 4/29/86
  3183                                  ; CHARACTER DEVICES (SCREEN)	 ;*
  3184                                  ;********************************;*		;J.K. 4/29/86
  3185                                  ;
  3186                                  ;SC_MODE_INFO	 struc
  3187                                  ;SC_INFO_LENGTH 	 DW	 9
  3188                                  ;SC_MODE		 DB	 0
  3189                                  ;SC_COLORS		 DW	 0
  3190                                  ;SC_WIDTH		 DW	 0
  3191                                  ;SC_LENGTH		 DW	 0
  3192                                  ;SC_MODE_INFO	 ends
  3193                                  ;
  3194                                  ;SC_INFO_PACKET_LENGTH	 EQU	 9		 ;LENGTH OF THE INFO PACKET.
  3195                                  
  3196                                  ;SUBFUNCTIONS FOR CON$GENIOCTL
  3197                                  ;GET_SC_MODE		 EQU	 60h
  3198                                  ;SET_SC_MODE		 EQU	 40h
  3199                                  ;The following subfunctions are reserved for installable CODE PAGE switch
  3200                                  ;console devices. - J.K. 4/29/86
  3201                                  ;Get_active_codepage	 equ	 6Ah
  3202                                  ;Invoke_active_codepage  equ	 4Ah
  3203                                  ;Start_designate_codepage equ	 4Ch
  3204                                  ;End_designate_codepage  equ	 4Dh
  3205                                  ;Get_list_of_designated_codepage equ 6Bh
  3206                                  ;J.K. 4/29/86 *** End of Con$genioctl equates & structures
  3207                                  
  3208                                  ; ............................................................................
  3209                                  
  3210                                  ;-----------------------------------------------------------------------------
  3211                                  ; MSDISK.ASM (2) - MSDOS 3.3 - 02/02/1988
  3212                                  ;-----------------------------------------------------------------------------
  3213                                  ; 24/03/2018 - Retro DOS v2.0 
  3214                                  
  3215                                  ;-----------------------------------------------------------------------------
  3216                                  ; MSBIO2.ASM - MSDOS 3.3 - 02/02/1988
  3217                                  ;-----------------------------------------------------------------------------
  3218                                  ; 25/03/2018 - Retro DOS v2.0 
  3219                                  
  3220                                  		;EVENB
  3221 000008B9 90                      align 2
  3222                                  
  3223                                  DSKDRVS:	; 07/04/2018
  3224 000008BA [7409]                  		DW	_360K_parameters
  3225 000008BC [7409]                  		DW	_360K_parameters
  3226 000008BE [7409]                  		DW	_360K_parameters
  3227 000008C0 [7409]                  		DW	_360K_parameters
  3228                                  HDSKTAB:
  3229 000008C2 [D609]                  		DW	HD0_PARAMETERS
  3230 000008C4 [E909]                  		DW	HD1_PARAMETERS
  3231                                  
  3232                                  
  3233                                  ;*****************************************************************************
  3234                                  
  3235                                  DSK$INIT:
  3236                                  		;PUSH	CS
  3237                                  		;POP	DS
  3238                                  
  3239 000008C6 8A26[C800]              		MOV	AH,[DRVMAX]
  3240 000008CA BF[BA08]                		MOV	DI,DSKDRVS
  3241 000008CD E9BDFD                  		JMP	SetPTRSAV
  3242                                  
  3243                                  ;-------------------------------------------------
  3244                                  ;
  3245                                  ;  Ask to swap the disk in drive A:
  3246                                  ; Using a different drive in a one drive system so
  3247                                  ; request the user to change disks
  3248                                  ;
  3249                                  
  3250                                  SWPDSK:
  3251                                  		; 13/04/2018
  3252                                  		; 09/04/2018
  3253                                  		; Retro DOS v2.0 (IBMDOS 2.1, IBMBIO.COM)
  3254                                  
  3255                                  		;push	ds
  3256 000008D0 56                      		push	si ; 13/04/2018
  3257                                  		;xor	si,si
  3258                                  		;mov	ds,si
  3259                                  		;mov	ah,al
  3260                                  		;xchg	ah, [LSTDRV]
  3261                                  		;pop	ds
  3262                                  		;cmp	ah,al
  3263                                  		;je	short SWPDSK_ret
  3264                                  
  3265 000008D1 0441                    		add	al,"A"
  3266                                  		;mov	[cs:DRVLET],AL
  3267 000008D3 A2[0D09]                		mov	[DRVLET],AL		
  3268                                  		;push	ds			; preserve segment register
  3269                                  		;push	cs
  3270                                  		;pop	ds
  3271 000008D6 BE[F108]                		mov	SI,SNGMSG		; ds:si -> message
  3272                                  		;push	BX
  3273 000008D9 E80900                  		call	WRMSG			;Print disk change message
  3274 000008DC E880FB                  		call	FLUSH
  3275                                  						; wait for a keyboard character
  3276 000008DF 30E4                    		xor	AH, AH			; set command to read character
  3277 000008E1 CD16                    		int	16h			; call rom-bios
  3278                                  		;POP	BX
  3279                                  		;pop	ds			; restore segment register
  3280                                  ;SWPDSK_ret:
  3281                                  		;xor	al, al
  3282 000008E3 5E                      		pop	si ; 13/04/2018
  3283                                  WRMRET:
  3284 000008E4 C3                      		retn
  3285                                  
  3286                                  ;----------------------------------------------
  3287                                  ;
  3288                                  ;  WrMsg writes out message pointed to by [SI]
  3289                                  ;
  3290                                  
  3291                                  WRMSG:
  3292 000008E5 AC                      		lodsb				; get the next character of the message
  3293 000008E6 08C0                    		or	AL,AL			; see if end of message
  3294 000008E8 74FA                    		jz	short WRMRET
  3295 000008EA 9C                      		pushf
  3296 000008EB 0E                      		push	CS
  3297 000008EC E809FB                  		call	OUTCHR
  3298 000008EF EBF4                    		jmp	SHORT WRMSG
  3299                                  
  3300                                  
  3301                                  ;	INCLUDE BIOMES.INC
  3302                                  
  3303                                  ; BIOMES.INC - 24/07/1987
  3304                                  ;----------------------------------------------------------------------------
  3305                                  ;
  3306                                  ; Single drive message for msbio.com. Nul terminated.	;;End of Modification
  3307                                  ;
  3308                                  
  3309 000008F1 0D0A496E7365727420-     SNGMSG:	DB	0Dh,0Ah,"Insert diskette for drive "
  3310 000008FA 6469736B6574746520-
  3311 00000903 666F72206472697665-
  3312 0000090C 20                 
  3313 0000090D 413A20616E64207374-     DRVLET:	DB	"A: and strike",0Dh,0Ah,"any key when ready",0Dh,0Ah,0Ah,0
  3314 00000916 72696B650D0A616E79-
  3315 0000091F 206B6579207768656E-
  3316 00000928 2072656164790D0A0A-
  3317 00000931 00                 
  3318                                  
  3319                                  ;
  3320                                  ; End of code for virtual floppy drives
  3321                                  ;
  3322                                  
  3323                                  EndSwap:
  3324                                  
  3325                                  ;HNUM:		
  3326                                  ;		DB	0		; number of hardfile (hard drives)
  3327                                  ;HARDDRV:
  3328                                  ;		DB	80h		;Physical drive number of first hardfile
  3329                                  
  3330                                  
  3331                                  ; include ms96tpi.inc
  3332                                  
  3333                                  ; MS96TPI.INC - 24/07/1987
  3334                                  ;----------------------------------------------------------------------------
  3335                                  ; 25/03/2018 - Retro DOS v2.0
  3336                                  
  3337                                  ;------------------------------------------------------------------------
  3338                                  ;									:
  3339                                  ; File: ms96tpi.asm							:
  3340                                  ;									:
  3341                                  ; This file contains code to support the 96 tpi drives.  The code	:
  3342                                  ; is included in the bio if the machine has at least one drive with	:
  3343                                  ; changeline support.  If the machine has no changeline drives then	:
  3344                                  ; the code is not kept in the bio at system initialization time.	:
  3345                                  ;									:
  3346                                  ;------------------------------------------------------------------------
  3347                                  
  3348                                  ;
  3349                                  ; At media check time, we need to really get down and check what the change is.
  3350                                  ; This is GUARANTEED to be expensive.
  3351                                  ;
  3352                                  ; On entry AL contains logical drive number
  3353                                  ;
  3354                                  
  3355                                  MediaCheck:
  3356                                  		; 13/04/2018
  3357                                  		; 08/04/2018
  3358                                  		; Retro DOS v2.0
  3359                                  
  3360                                  		; SI = 0
  3361 00000932 E8BBFD                  		call	CHECKSINGLE	; make sure correct disk is in place
  3362                                  		;xor	si,si
  3363                                  		; 10/04/2018
  3364                                  		;mov	DL, [CS:MEDIACHK_DRV]
  3365                                  		; 13/04/2018
  3366                                  		;mov	dl, [MEDIACHK_DRV]
  3367 00000935 88C2                    		mov	dl, al	
  3368 00000937 E81500                  		call	HasChange
  3369 0000093A 7412                    		jz	short MediaRet ; SI = 0 ("I don't know")
  3370                                  
  3371                                  					; see if changeline has been triggered
  3372                                  ;;Rev 3.30 Modification
  3373                                  		;mov	DL, [DI+BDS.DriveNum] ; set logical drive number	  
  3374                                  		;mov	DL, [CS:MEDIACHK_DRV] ; 08/04/2018 - Retro DOS v2.0
  3375 0000093C B416                    		mov	AH, 16h 	    ; get changeline status	  
  3376 0000093E CD13                    		int	13h		    ; call rom diskette routine
  3377                                  			; (Programmer's Guide To AMIBIOS - 1993)
  3378                                  			; AH = 00h No floppy disk (media) change
  3379                                  			;      01h Invalid floppy disk parameter
  3380                                  			;      06h Floppy disk was changed since last access
  3381                                  			;      80h Floppy disk drive not ready		
  3382                                  			;      = Any other value is an error code
  3383                                  
  3384 00000940 720C                    		jc	short MediaRet ; SI = 0 ; ("I don't know")
  3385                                  		
  3386 00000942 46                      		inc	si ; 1 = "MEDIA IS NOT CHANGED"
  3387 00000943 20E4                    		and	ah, ah
  3388 00000945 7407                    		jz	short MediaRet
  3389 00000947 4E                      		dec	si ; 0 = ("I don't know")
  3390 00000948 80FC06                  		cmp	ah, 6
  3391 0000094B 7501                    		jne	short MediaRet
  3392 0000094D 4E                      		dec	si ; -1 = "MEDIA HAS BEEN CHANGED"
  3393                                  MediaRet:
  3394                                  		; DL = drive number (0 to 3)
  3395 0000094E C3                      		retn				
  3396                                  		
  3397                                  ;
  3398                                  ; HasChange - see if drive can supply change line
  3399                                  ;
  3400                                  ;   Inputs:	DS:DI points to current BDS
  3401                                  ;   Outputs:	Zero set - no change line available
  3402                                  ;		Zero reset - change line available
  3403                                  ;   Registers modified: none
  3404                                  
  3405                                  HasChange:
  3406                                  		; 08/04/2018
  3407                                  		; Retro DOS v2.0 (Programmer's Guide To AMIBIOS, 1993)
  3408                                  	
  3409                                  		; DL = Drive number (0,1)
  3410 0000094F B415                    		mov	ah, 15h  ; Return Drive Type
  3411 00000951 CD13                    		Int	13h
  3412                                  			; AH = 00h No drive present
  3413                                  			;      01h Drive does not have change line support
  3414                                  			;      02h Drive dos have changle line support
  3415                                  			; CF = 0 No error
  3416                                  			;      1 Error
  3417 00000953 B000                    		mov	al, 0
  3418 00000955 7207                    		jc	short HasNotChange
  3419 00000957 80FC02                  		cmp	ah, 2
  3420 0000095A 7502                    		jne	short HasNotChange
  3421 0000095C FEC0                    		inc	al ; 1 = (Disk drive has change line)	
  3422                                  HasNotChange:			
  3423 0000095E 08C0                    		or	al, al
  3424 00000960 C3                      		retn
  3425                                  
  3426                                  
  3427                                  ;-----------------------------------------------------------------------------
  3428                                  ; MSINIT.ASM - MSDOS 3.3 - 02/02/1988
  3429                                  ;-----------------------------------------------------------------------------
  3430                                  ; 19/03/2018 - Retro DOS v2.0
  3431                                  
  3432                                  ;-----------------------------------------------------------------------------
  3433                                  ; BOOT DISK PARAMETERS
  3434                                  ;-----------------------------------------------------------------------------
  3435                                  ; 07/04/2018 - RETRO DOS V2.0
  3436                                  
  3437                                  BOOT_DRV_PARMS:
  3438                                  		; 1.44MB
  3439 00000961 0002                    		dw 512
  3440 00000963 01                                      db 1
  3441 00000964 0100                                    dw 1	
  3442 00000966 02                                      db 2
  3443 00000967 E000                                    dw 224
  3444 00000969 400B                    		dw 2880
  3445                                  		; Retro DOS v1.0 - 10/02/2018
  3446 0000096B F0                      		db 0F0h		; Media descriptor
  3447 0000096C 0900                    		dw 9		; FAT size in sectors
  3448 0000096E 1200                    		dw 18		; Sectors per track
  3449 00000970 0200                    		dw 2		; Number of heads
  3450 00000972 0000                    		dw 0 ; Hidden sectors
  3451                                  		
  3452                                  ; Note: These (fd&hd) parameters table sizes are 19 bytes for MSDOS 2.11
  3453                                  
  3454                                  ;-----------------------------------------------------------------------------
  3455                                  ; FLOPPY DISK PARAMETERS
  3456                                  ;-----------------------------------------------------------------------------
  3457                                  ; 07/04/2018 - RETRO DOS V2.0
  3458                                  
  3459                                  		; Retro DOS v2.0 - 19 bytes disk parameters (07/04/2018)
  3460                                  _FD_parameters:
  3461                                  		; Retro DOS v1.0 - 10/02/2018
  3462                                  		; 17 bytes of DOS disk parameters
  3463                                  _360K_parameters:
  3464                                  		; 360KB
  3465 00000974 0002                    		dw 512		; Sector size in bytes.
  3466 00000976 02                      		db 2		; Sector per allocation unit.
  3467 00000977 0100                    		dw 1		; Reserved sectors.
  3468 00000979 02                      		db 2		; Number of allocation tables.
  3469 0000097A 7000                    		dw 112		; Number of directory entrys.
  3470 0000097C D002                    		dw 720		; Number of sectors on the disk.
  3471                                  		; Retro Dos v1.0 - 10/02/2018
  3472 0000097E FD                      		db 0FDh		; Media descriptor
  3473 0000097F 0200                    		dw 2		; FAT size in sectors
  3474 00000981 0900                    		dw 9		; Sectors per track
  3475 00000983 0200                    		dw 2		; Number of heads
  3476 00000985 0000                    		dw 0	
  3477                                  _1200K_parameters:
  3478                                  		; 1.2MB
  3479 00000987 0002                    		dw 512
  3480 00000989 01                                      db 1
  3481 0000098A 0100                                    dw 1	
  3482 0000098C 02                                      db 2
  3483 0000098D E000                                    dw 224
  3484 0000098F 6009                    		dw 2400
  3485                                  		; Retro DOS v1.0 - 10/02/2018
  3486 00000991 F9                      		db 0F9h		; Media Descriptor
  3487 00000992 0700                    		dw 7		; FAT size in sectors
  3488 00000994 0F00                    		dw 15		; Sectors per track
  3489 00000996 0200                    		dw 2		; Number of heads
  3490 00000998 0000                    		dw 0
  3491                                  _720K_paramaters:
  3492                                  		; 720KB
  3493 0000099A 0002                    		dw 512		; Sector size in bytes.
  3494 0000099C 02                      		db 2		; Sector per allocation unit.
  3495 0000099D 0100                    		dw 1		; Reserved sectors.
  3496 0000099F 02                      		db 2		; Number of allocation tables.
  3497 000009A0 7000                    		dw 112		; Number of directory entrys.
  3498 000009A2 A005                    		dw 1440		; Number of sectors on the disk.
  3499                                  		; Retro DOS v1.0 - 10/02/2018
  3500 000009A4 F9                      		db 0F9h		; Media descriptor
  3501 000009A5 0300                    		dw 3		; FAT size in sectors
  3502 000009A7 0900                    		dw 9		; Sectors per track
  3503 000009A9 0200                    		dw 2		; Number of heads
  3504 000009AB 0000                    		dw 0
  3505                                  _1440K_parameters:
  3506                                  		; 1.44MB
  3507 000009AD 0002                    		dw 512
  3508 000009AF 01                                      db 1
  3509 000009B0 0100                                    dw 1	
  3510 000009B2 02                                      db 2
  3511 000009B3 E000                                    dw 224
  3512 000009B5 400B                    		dw 2880
  3513                                  		; Retro DOS v1.0 - 10/02/2018
  3514 000009B7 F0                      		db 0F0h		; Media descriptor
  3515 000009B8 0900                    		dw 9		; FAT size in sectors
  3516 000009BA 1200                    		dw 18		; Sectors per track
  3517 000009BC 0200                    		dw 2		; Number of heads
  3518 000009BE 0000                    		dw 0
  3519                                  _2880K_parameters:
  3520                                  		; 2.88MB
  3521 000009C0 0002                    		dw 512
  3522 000009C2 02                                      db 2
  3523 000009C3 0100                                    dw 1	
  3524 000009C5 02                                      db 2
  3525 000009C6 F000                                    dw 240
  3526 000009C8 8016                    		dw 5760
  3527                                  		; Retro DOS v1.0 - 10/02/2018
  3528 000009CA F0                      		db 0F0h		; Media descriptor
  3529 000009CB 0900                    		dw 9		; FAT size in sectors
  3530 000009CD 2400                    		dw 36		; Sectors per track
  3531 000009CF 0200                    		dw 2		; Number of heads
  3532 000009D1 0000                    		dw 0
  3533                                  
  3534                                  END_OF_FDP_TBLS:
  3535                                  
  3536                                  ;-----------------------------------------------------------------------------
  3537                                  ; HARD DISK PARAMETERS
  3538                                  ;-----------------------------------------------------------------------------
  3539                                  ; 07/04/2018 - RETRO DOS V2.0
  3540                                  
  3541 000009D3 90                      align 2
  3542                                  
  3543 000009D4 00                      HNUM:		db 0	
  3544                                  HD_PARAMETERS:	
  3545 000009D5 80                      		db 80h	
  3546                                  HD0_PARAMETERS:	
  3547 000009D6 0002                    		dw 200h		
  3548 000009D8 01                      		db 1
  3549 000009D9 0100                    		dw 1
  3550 000009DB 02                      		db 2
  3551 000009DC 1000                    		dw 10h
  3552 000009DE 0000                    		dw 0
  3553 000009E0 F8                      		db 0F8h
  3554 000009E1 0100                    		dw 1
  3555 000009E3 0000                    		dw 0
  3556 000009E5 0000                    		dw 0
  3557 000009E7 0000                    		dw 0
  3558                                  
  3559                                  END_OF_HD1P_TBL:
  3560                                  
  3561                                  HD1_PARAMETERS:
  3562 000009E9 0002                    		dw 200h	
  3563 000009EB 00                      		db 0
  3564 000009EC 0100                    		dw 1
  3565 000009EE 02                      		db 2
  3566 000009EF 0000                    		dw 0
  3567 000009F1 0000                    		dw 0
  3568 000009F3 F8                      		db 0F8h
  3569 000009F4 0000                    		dw 0
  3570 000009F6 0000                    		dw 0
  3571 000009F8 0000                    		dw 0
  3572 000009FA 0000                    		dw 0
  3573                                  
  3574                                  END_OF_HD2P_TBL:
  3575                                  
  3576                                  ;-----------------------------------------------------------------------------
  3577 000009FC 0000                    DRVFAT		dw 0
  3578 000009FE 0000                    BIOS$		dw 0
  3579 00000A00 0000                    DOSCNT		dw 0
  3580                                  
  3581                                  ; 28/03/2018
  3582                                  ; MSDOS 6.0 - MSINIT.ASM, 1991
  3583 00000A02 0000                    init_bootseg:	dw	0	; seg addr of buffer for reading boot record
  3584                                  
  3585                                  BootBias equ 200h ; 19/03/2018
  3586                                  
  3587                                  ;-----------------------------------------------------------------------------
  3588                                  
  3589                                  ;-----------------------------------------------------------------------------
  3590                                  
  3591 00000A04 90<rept>                align 16
  3592                                  
  3593                                  ;-----------------------------------------------------------------------------
  3594                                  ; entry point from boot sector
  3595                                  ;-----------------------------------------------------------------------------
  3596                                  
  3597                                  ; ----------------------------------------------------------------------------
  3598                                  ; SYSINIT PARAMETER ADDRESS EQUALITIES - 25/02/2018 (MSDOS 2.0 'SYSINIT.ASM')
  3599                                  ; ----------------------------------------------------------------------------
  3600                                  ; ('sysinit.s', 'SYSINIT.BIN')
  3601                                  
  3602                                  ; IN SYSINIT SEGMENT (SYSINITSEG):
  3603                                  
  3604                                  CURRENT_DOS_LOCATION EQU 6   ; dw (segment)
  3605                                  FINAL_DOS_LOCATION   EQU 10  ; dw (segment)
  3606                                  DEVICE_LIST	     EQU 12  ; dd (segment:offset)	
  3607                                  DOSSIZE		     EQU 16  ; dw ; Retro DOS 2.0 - 'MSDOS.BIN' size in words
  3608                                  MEMORY_SIZE	     EQU 18  ; dw (paragraphs)	
  3609                                  DEFAULT_DRIVE	     EQU 20  ; db
  3610                                  
  3611                                  ;-----------------------------------------------------------------------------
  3612                                  ; initialization - stage 1
  3613                                  ;-----------------------------------------------------------------------------
  3614                                  INIT:
  3615                                  		; 07/04/2018
  3616                                  		; Retro DOS v2.0 - registers from FD Boot Sector 
  3617                                                  ; DL = [bsDriveNumber]
  3618                                  		; DH = [bsMedia]
  3619                                  		; AX = [bsSectors] ; Total sectors
  3620                                  		; DS = 0, SS = 0
  3621                                  		; BP = 7C00h
  3622                                  
  3623                                  		; Move Retro DOS v2.0 boot sector parameters to 0060h:0
  3624 00000A10 BB6000                  		mov	bx, 60h
  3625 00000A13 8EC3                    		mov	es, bx
  3626 00000A15 89EE                    		mov	si, bp
  3627 00000A17 29FF                    		sub	di, di
  3628 00000A19 B92300                  		mov	cx, 35 ; 70 bytes, 35 words
  3629                                  		;mov	cl, 35
  3630 00000A1C F3A5                    		rep	movsw
  3631                                  
  3632 00000A1E 0E                      		push	cs
  3633 00000A1F 1F                      		pop	ds
  3634                                  
  3635                                  		; 27/03/2018
  3636 00000A20 B9E42C                  		mov	cx, KERNEL_SIZE	; words !
  3637                                  		; 07/04/2018
  3638                                  		;mov	bx, KERNEL_SEGMENT ; 0070h
  3639 00000A23 B370                    		mov	bl, KERNEL_SEGMENT
  3640 00000A25 8EC3                    		mov	es, bx
  3641 00000A27 31FF                    		xor	di, di
  3642 00000A29 89FE                    		mov	si, di
  3643                                  		
  3644                                  		; Move KERNEL file from 1000h:0 to 0070h:0
  3645                                  		; (Retro DOS v2 BS loads 'MSDOS.SYS' at 1000h:0000h)
  3646 00000A2B F3A5                    		rep	movsw 
  3647 00000A2D 8EDB                    		mov	ds, bx
  3648                                  INIT0:
  3649 00000A2F 06                      		push	es
  3650 00000A30 68[340A]                		push	INIT1 ; 07/04/2018
  3651 00000A33 CB                      		retf	; jump to 0070h:INIT1
  3652                                  
  3653                                  ;INIT:
  3654                                  INIT1:
  3655                                  		; 19/03/2018
  3656                                  		; Retro DOS v2.0 (24/02/2018)
  3657                                  		; [REF: MSDOS 3.3, MSBIO, "MSINIT.ASM"  (24/07/1987)]
  3658                                  
  3659                                  ;------------------------------------------------------------------------
  3660                                  ;									:
  3661                                  ;	System initialization						:
  3662                                  ;									:
  3663                                  ;	The entry conditions are established by the bootstrap		:
  3664                                  ;	loader and are considered unknown.  The following jobs		:
  3665                                  ;	will be performed by this module:				:
  3666                                  ;									:
  3667                                  ;	1.	All device initialization is performed			:
  3668                                  ;	2.	A local stack is set up and DS:SI are set		:
  3669                                  ;		to point to an initialization table. Then		:
  3670                                  ;		an inter-segment call is made to the first		:
  3671                                  ;		byte of the dos 					:
  3672                                  ;	3.	Once the dos returns from this call the ds		:
  3673                                  ;		register has been set up to point to the start		:
  3674                                  ;		of free memory. The initialization will then		:
  3675                                  ;		load the command program into this area 		:
  3676                                  ;		beginning at 100 hex and transfer control to		:
  3677                                  ;		this program.						:
  3678                                  ;									:
  3679                                  ;------------------------------------------------------------------------
  3680                                  
  3681                                  		; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
  3682                                  		EOI	EQU	20H
  3683                                  		AKPORT	EQU	20H
  3684                                  		INITSPOT EQU	534H	; IBM wants 4 zeros here
  3685                                  		BRKADR	EQU	1BH * 4	; 6CH, 1BH break vector address
  3686                                  		TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
  3687                                  		DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
  3688                                  		SEC9	EQU	522H	; address of disk parameters
  3689                                  		;CHROUT	EQU	29H
  3690                                  		;LSTDRV	EQU     504H
  3691                                  		;;SYSIZE	EQU 200H ;NUMBER OF PARAGRAPHS IN SYSINIT MODULE
  3692                                  		 ; 26/03/2018
  3693                                  		RSINIT	EQU	0A3H
  3694                                  		NORMSETTLE EQU  15
  3695                                  
  3696                                  		; Retro DOS v1.0 (10/02/2018)
  3697                                  		; (Register values from Retro DOS v1.0 Boot Sector)
  3698                                  		; CS = 60h  ; BIO_SEGMENT
  3699                                  		; DS = 0
  3700                                  		; ES = 0
  3701                                  		; SS = 0
  3702                                  		; SP = 0FFFEh
  3703                                   		; BP = 7C00h
  3704                                  		; DL = Physical drive number = 0
  3705                                  		;push	cs
  3706                                  		;pop	ds
  3707                                  
  3708                                  		; Retro DOS v1.0 boot sector (fd0) dos parameters
  3709                                  		; (17 bytes)
  3710                                  		bsBytesPerSec	equ 11
  3711                                  		bsSecPerClust	equ 13
  3712                                  		bsResSectors	equ 14	
  3713                                  		bsFATs		equ 16
  3714                                  		bsRootDirEnts	equ 17
  3715                                  		bsSectors	equ 19	
  3716                                  		bsMedia		equ 21
  3717                                  		bsFATsecs	equ 22
  3718                                  		bsSecPerTrack	equ 24
  3719                                  		bsHeads		equ 26
  3720                                  
  3721                                  		; Retro DOS 1.0 extensions (to boot sector parameters) 
  3722                                  		bsDataStart	equ 64
  3723                                  
  3724                                  		;push	ds
  3725                                  		;pop	es
  3726                                  
  3727                                  		; 14/02/2018
  3728                                  		; Set video mode to 3 (Clear screen)
  3729 00000A34 B80300                  		mov	ax, 3
  3730 00000A37 CD10                    		int	10h
  3731                                  
  3732                                  		; 06/04/2018 - Retro DOS v2.0
  3733                                  		; (IBMDOS 2.1, IBMBIO.COM, 20/10/1983)
  3734                                  		; (by IDA Pro Free Dissassembler)
  3735                                  		; 19/03/2018
  3736                                  		; (Source Code Ref: MSDOS 3.3, MSINIT.ASM, 1991)
  3737                                  		
  3738                                  		; "MSINIT.ASM"
  3739                                  		;---------------------------------------------------------------
  3740                                  		; At this point the registers contain these values:
  3741                                  		;   AX = 0-based drive we booted from
  3742                                  		;   BX = the logical number of the first data sector on the disk
  3743                                  		;   CX = number of floppies including logical one
  3744                                  
  3745                                  		;
  3746                                  		; set up local stack
  3747                                  		;
  3748                                  
  3749 00000A39 31DB                    		XOR	BX,BX
  3750 00000A3B FA                      		CLI		; turn interrupts off while manupulating stack
  3751 00000A3C 8ED3                    		MOV	SS,BX	; set stack segment register
  3752 00000A3E BC0007                  		MOV	SP,700h	; set stack pointer
  3753 00000A41 FB                      		STI		; turn interrupts on
  3754                                  
  3755                                  		; 07/04/2018
  3756                                  		; Retro DOS v2.0
  3757 00000A42 CD11                    		INT	11h		; rom-bios equipment determination
  3758                                  		; 10/04/2018
  3759 00000A44 A801                    		TEST	AL, 1
  3760 00000A46 7504                    		JNZ	SHORT CHECKSINGLEFD
  3761 00000A48 31C0                    		XOR	AX, AX
  3762 00000A4A EB0E                    		JMP	SHORT NOFD
  3763                                  CHECKSINGLEFD:
  3764 00000A4C B106                    		MOV	CL, 6
  3765 00000A4E D2E8                    		SHR	AL, CL
  3766 00000A50 7504                    		JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  3767 00000A52 FE06[CF00]              		INC	byte [Single]	;REMEMBER THIS
  3768                                  NOTSINGLE:
  3769 00000A56 30E4                    		XOR	AH, AH
  3770 00000A58 FEC0                    		INC	AL ; 10/04/2018
  3771                                  NOFD:	
  3772 00000A5A 50                      		PUSH	AX ; (***)	; save number of floppies (in AL)
  3773 00000A5B 52                      		PUSH	DX ; (**)	; DL = Boot drive number (0 = A, 2 = C) 
  3774                                  					; DH = Media ID
  3775                                  
  3776 00000A5C CD12                    		INT	12h		; call rom-bios for memory size
  3777 00000A5E D3E0                    		SHL	AX, CL		; change from K to 16 byte blocks
  3778 00000A60 50                      		PUSH	AX ; (*)	; save memory size		
  3779                                  
  3780                                  Turn_Timer_On:								
  3781 00000A61 B020                    		mov	AL,EOI
  3782 00000A63 E620                    		out	AKPORT,AL	; turn on the timer
  3783                                  
  3784 00000A65 BE[2401]                		mov	SI,COM2DEV
  3785 00000A68 E87D02                  		call	AUX_INIT		;INIT COM2
  3786 00000A6B BE[DC00]                		mov	SI,COM1DEV
  3787 00000A6E E87702                  		call	AUX_INIT		;INIT COM1
  3788                                  
  3789 00000A71 BE[1201]                		mov	SI,LPT3DEV
  3790 00000A74 E86902                  		call	PRINT_INIT		;INIT LPT3
  3791 00000A77 BE[0001]                		mov	SI,LPT2DEV
  3792 00000A7A E86302                  		call	PRINT_INIT		;INIT LPT2
  3793 00000A7D BE[EE00]                		mov	SI,LPT1DEV
  3794 00000A80 E85D02                  		call	PRINT_INIT		;INIT LPT1
  3795                                  
  3796 00000A83 31D2                    		xor	DX,DX
  3797 00000A85 8EDA                    		mov	DS,DX			;TO INITIALIZE PRINT SCREEN VECTOR
  3798 00000A87 8EC2                    		mov	ES,DX
  3799                                  
  3800 00000A89 8CC8                    		mov	AX,CS			;FETCH SEGMENT
  3801                                  
  3802 00000A8B C7066C00[7E04]          		mov	word [BRKADR],CBREAK	;BREAK ENTRY POINT
  3803 00000A91 A36E00                  		mov	[BRKADR+2],AX		;VECTOR FOR BREAK
  3804                                  
  3805 00000A94 C706A400[F803]          		mov	word [CHROUT*4],OUTCHR
  3806 00000A9A A3A600                  		mov	[CHROUT*4+2],AX
  3807                                  
  3808                                  		; IBMDOS 2.1
  3809                                  		;MOV	WORD [DSKADR], SEC9 ; 522h
  3810                                  		;MOV	[DSKADR+2], ES ; 0
  3811                                   
  3812                                  		; MSDOS 3.3
  3813 00000A9D 8B367800                		mov	SI,[DSKADR]
  3814 00000AA1 8E1E7A00                		mov	DS,[DSKADR+2]		; DS:SI -> current table
  3815                                  
  3816 00000AA5 BF2205                  		mov	DI,SEC9 		; ES:DI -> New Table
  3817 00000AA8 B90B00                  		mov	CX,DISK_PARMS.size ; 11
  3818 00000AAB F3A4                    		rep	MOVSB			; Copy Table
  3819 00000AAD 06                      		push	ES			;
  3820 00000AAE 1F                      		pop	DS			; DS = 0
  3821                                  
  3822 00000AAF BF0400                  		mov	DI,4
  3823 00000AB2 BB[8404]                		mov	BX,INTRET		;WILL INITIALIZE REST OF INTERRUPTS
  3824 00000AB5 93                      		xchg	AX,BX
  3825 00000AB6 AB                      		stosw				;Location 4
  3826 00000AB7 93                      		xchg	AX,BX
  3827 00000AB8 AB                      		stosw				;INT 1		;Location 6
  3828 00000AB9 83C704                  		add	DI,4
  3829 00000ABC 93                      		xchg	AX,BX
  3830 00000ABD AB                      		stosw				;Location 12
  3831 00000ABE 93                      		xchg	AX,BX
  3832 00000ABF AB                      		stosw				;INT 3		;Location 14
  3833 00000AC0 93                      		xchg	AX,BX
  3834 00000AC1 AB                      		stosw				;Location 16
  3835 00000AC2 93                      		xchg	AX,BX
  3836 00000AC3 AB                      		stosw				;INT 4		;Location 18
  3837                                  
  3838 00000AC4 83C728                  		ADD	DI,40			
  3839 00000AC7 93                      		xchg	AX,BX
  3840 00000AC8 AB                      		stosw				;Location 60
  3841 00000AC9 93                      		xchg	AX,BX
  3842 00000ACA AB                      		stosw				;INT 0Fh	;Location 62 
  3843                                  
  3844 00000ACB 89160005                		mov	[500h],DX		;SET PRINT SCREEN & BREAK = 0
  3845 00000ACF 89160405                		mov	[LSTDRV],DX		;clean out last drive spec
  3846                                  
  3847                                  		; IBMDOS 2.1 (180KB, 5 1/4" diskette parameters)
  3848                                  		;mov	DI,SEC9 ; 522h 		; ES:DI -> New Table
  3849                                  		;mov	ax, 2DFh
  3850                                  		;stosw
  3851                                  		;mov	ax, 225h
  3852                                  		;stosw
  3853                                  		;mov	ax, 2A09h
  3854                                  		;stosw
  3855                                  		;mov	ax, 50FFh
  3856                                  		;stosw
  3857                                  		;mov	ax, 0FF6h
  3858                                  		;stosw
  3859                                  		;mov	al, 2
  3860                                  		;stosb
  3861                                  			
  3862                                  NO_DIDDLE:
  3863                                  		; 24/02/2018 (Retro DOS 2.0) ; *
  3864 00000AD3 0E                      		push	cs
  3865 00000AD4 1F                      		pop	ds
  3866                                  
  3867                                  		; 07/04/2018
  3868                                  		;int	12h			; call rom-bios for memory size
  3869                                  		;mov	CL, 6			; get ready for shift
  3870                                  		;shl	AX, CL			; change from K to 16 byte blocks
  3871                                  		
  3872 00000AD5 58                      		POP	AX ; (*)		; Memory size in paragraphs			
  3873                                  
  3874                                  		; 19/03/2018
  3875 00000AD6 59                      		pop	CX ; (**)		; CL = boot drive, CH = media byte
  3876                                  		; 11/04/2018
  3877 00000AD7 80F980                  		cmp	cl, 80h
  3878 00000ADA 7203                    		jb	short NO_HDBOOT
  3879 00000ADC 80E97E                  		sub	cl, 7Eh ; 80h = 2, 81h = 3
  3880                                  NO_HDBOOT:
  3881                                  		; 30/03/2018
  3882 00000ADF 890E[FC09]              		mov	[DRVFAT], CX ; (**)
  3883                                  		
  3884                                  		; 06/04/2018
  3885 00000AE3 A3[120D]                		MOV	[SYSINIT_START+MEMORY_SIZE],AX ; Top of memory (in paragraphs)
  3886 00000AE6 FEC1                    		INC	CL
  3887 00000AE8 880E[140D]              		MOV	[SYSINIT_START+DEFAULT_DRIVE],CL ; SAVE DEFAULT DRIVE SPEC
  3888                                  		
  3889                                  		; 08/04/2018
  3890                                  		; 28/03/2018
  3891                                  		; MSDOS 6.0 - MSINIT.ASM, 1991
  3892 00000AEC 83E840                  		sub	ax,64		;room for boot record buffer segment (1 kb)
  3893 00000AEF A3[020A]                		mov	[init_bootseg],ax
  3894                                  		
  3895 00000AF2 B86601                  		mov	ax, MSDOS_BIN_SEGMENT  ; MSDOS_BIN_OFFSET >> 4
  3896 00000AF5 83C070                  		add	ax, KERNEL_SEGMENT ; 26/03/2018
  3897 00000AF8 A3[060D]                		MOV	[SYSINIT_START+CURRENT_DOS_LOCATION], AX
  3898                                  
  3899                                  		; 07/04/2018
  3900 00000AFB B8[FC09]                		MOV	AX,END_OF_HD2P_TBL
  3901                                  		; 06/04/2018
  3902                                  		;MOV	AX,INIT
  3903 00000AFE 83C00F                  		ADD	AX,15
  3904 00000B01 D1E8                    		SHR	AX,1
  3905 00000B03 D1E8                    		SHR	AX,1
  3906 00000B05 D1E8                    		SHR	AX,1
  3907 00000B07 D1E8                    		SHR	AX,1
  3908 00000B09 83C070                  		ADD	AX,KERNEL_SEGMENT
  3909 00000B0C A3[0A0D]                		MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
  3910                                  
  3911 00000B0F C706[0C0D][7600]        		MOV	word [SYSINIT_START+DEVICE_LIST],CONHeader
  3912 00000B15 8C0E[0E0D]              		MOV	[SYSINIT_START+DEVICE_LIST+2],CS
  3913                                  		;PUSH	CS
  3914                                  		;PUSH	CS
  3915                                  		;POP	DS
  3916                                  		;POP	ES
  3917                                  
  3918                                  		;XOR	SI,SI
  3919                                  		;MOV	word [SI],HD_PARAMETERS
  3920                                  
  3921                                  		; 07/04/2018
  3922                                  		; Retro  DOS v2.0 
  3923                                  		; DISK DRIVE PARAMETERS TABLE SETUP METHOD (by Erdogan Tan)
  3924                                  		
  3925                                  		;; 24/02/2018 (Retro DOS 2.0, MSDOS 3.3 "MSINIT.ASM")
  3926                                  		;int	11h		; rom-bios equipment determination
  3927                                  		;AND	AL, 0C0h
  3928                                  		;JNZ	short NOTSINGLE	;ZERO MEANS SINGLE DRIVE SYSTEM
  3929                                  		;INC	byte [Single]	;REMEMBER THIS
  3930                                  ;NOTSINGLE:
  3931 00000B19 58                      		POP	AX ; (***)	; Number of floppies
  3932 00000B1A A2[D300]                		MOV	[HARDNUM],AL 	; Remember which drive is hard disk
  3933 00000B1D A2[C800]                		MOV	[DRVMAX],AL	; And set initial number of drives
  3934                                  		;SHL	AX,1		; Two bytes per address
  3935                                  		;MOV	DI,DSKDRVS
  3936                                  		;ADD	DI,AX		;Point to hardfile location
  3937                                  		;MOV	SI,HDSKTAB
  3938                                  		;MOVSW			;Two addresses to move
  3939                                  		;MOVSW
  3940                                  
  3941 00000B20 20C0                    		AND	AL, AL
  3942 00000B22 743F                    		JZ	SHORT SET_BOOT_DRV_PARMS  ; No floppy disks !?
  3943                                  		
  3944 00000B24 BE[BA08]                		MOV	SI, DSKDRVS
  3945 00000B27 30D2                    		XOR	DL, DL
  3946                                  		; 09/04/2018
  3947 00000B29 56                      		push	si
  3948                                  SET_FD_PARMS:
  3949 00000B2A 52                      		PUSH	DX
  3950 00000B2B B408                    		mov	AH, 8	     	; set command to get drive parameterS
  3951 00000B2D CD13                    		int	13h	     	; call ROM-BIOS to get number of drives
  3952 00000B2F 5A                      		POP	DX
  3953 00000B30 7226                    		jc	short ENDFLOPPIES ; old, rom therefore no hard disks
  3954                                  
  3955                                  		; This is the IBM Personal Computer
  3956                                  	 	; disk format. (Retro DOS v1.0 & v2.0)
  3957                                  		; Default Floppy drive Type is 1
  3958                                  		;	INT 13h (INT 40h) Function 08h
  3959                                  		;	   BL =	1 - 360KB, 40 track, 5 1/4"
  3960                                  		;		2 - 1.2MB, 80 track, 5 1/4"
  3961                                  		;		3 - 720KB, 80 track, 3 1/2"
  3962                                  		;		4 - 1.44MB, 80 track, 3 1/2"
  3963                                  		;		5 - 2.88MB, 80 track, 3 1/2"	
  3964                                  		; ES:DI = ROM BIOS DPT address (for floppy drives)
  3965                                  		;		(AMIBIOS 1993)
  3966                                  
  3967                                  		; 10/04/2018
  3968 00000B32 08E4                    		OR	AH, AH
  3969 00000B34 7522                    		JNZ	SHORT ENDFLOPPIES
  3970                                  
  3971 00000B36 20DB                    		AND	BL, BL
  3972 00000B38 741E                    		JZ	SHORT ENDFLOPPIES  ; < 1 is invalid
  3973 00000B3A 80FB05                  		CMP	BL, 5
  3974 00000B3D 7719                    		JA	SHORT ENDFLOPPIES  ; > 5 is invalid	
  3975                                  
  3976 00000B3F FECB                    		DEC	BL ; 0 based type number for table offset calculation
  3977 00000B41 30FF                    		XOR	BH,BH
  3978                                  		; 09/04/2018
  3979                                  		;push	dx
  3980                                  		;MOV	AX,19		; each parameters table size = 19 bytes
  3981                                  		;MUL	BX
  3982                                  		;pop	dx
  3983                                  		; 10/04/2018
  3984 00000B43 B013                    		MOV	AL,19
  3985 00000B45 F6E3                    		MUL	BL
  3986 00000B47 BB[7409]                		MOV	BX,_FD_parameters ; FD PARAMETERS FOR DRIVE TYPE 1 TO 5
  3987 00000B4A 01C3                    		ADD	BX,AX		  ; add table offset for this type	
  3988 00000B4C 891C                    		MOV	[SI],BX
  3989 00000B4E 46                      		INC	SI
  3990 00000B4F 46                      		INC	SI
  3991 00000B50 FEC2                    		INC	DL
  3992 00000B52 3A16[C800]              		CMP	DL, [DRVMAX]
  3993 00000B56 72D2                    		JB	SHORT SET_FD_PARMS
  3994                                  ENDFLOPPIES:
  3995 00000B58 5E                      		pop	si
  3996 00000B59 803E[CF00]01            		CMP	byte [Single], 1
  3997 00000B5E 7503                    		jne	short SET_BOOT_DRV_PARMS
  3998                                  		;MOV	SI, DSKDRVS
  3999 00000B60 AD                      		LODSW
  4000 00000B61 8904                    		MOV	[SI], AX
  4001                                  
  4002                                  SET_BOOT_DRV_PARMS:
  4003                                  		; 09/04/2018
  4004 00000B63 0E                      		push	cs
  4005 00000B64 07                      		pop	es
  4006                                  
  4007 00000B65 8A1E[FC09]              		MOV	BL, [DRVFAT]	; Boot drive number (0 = A, 2 = C)
  4008 00000B69 30FF                    		XOR	BH, BH
  4009 00000B6B D0E3                    		SHL	BL, 1
  4010 00000B6D 81C3[BA08]              		ADD	BX, DSKDRVS
  4011 00000B71 BF[6109]                		MOV	DI, BOOT_DRV_PARMS ; Boot drv params from its boot sector!
  4012 00000B74 893F                    		MOV	[BX], DI ; Set drv par. tbl. to boot sector parameters.	
  4013 00000B76 1E                      		PUSH	DS
  4014 00000B77 BB6000                  		MOV	BX, 60h
  4015 00000B7A 8EDB                    		MOV	DS, BX
  4016                                  		;MOV	CX, 17
  4017 00000B7C B91300                  		MOV	CX, 19 ; 09/04/2018
  4018 00000B7F BE0B00                  		MOV	SI, 11
  4019 00000B82 F3A4                    		REP	MOVSB
  4020 00000B84 1F                      		POP	DS
  4021                                  
  4022                                  SET_HD_PARMS:
  4023                                  		; 09/04/2018
  4024                                  		;push	es
  4025                                  		; 07/04/2018
  4026 00000B85 B280                    		mov	DL, 80h      	; tell rom bios to look at hard drives
  4027 00000B87 B408                    		mov	AH, 08h	     	; set command to get drive parameter
  4028 00000B89 CD13                    		int	13h	     	; call ROM-BIOS to get number of drives
  4029                                  		; 09/04/2018
  4030                                  		;pop	es
  4031 00000B8B 7256                    		jc	short INIT2	; old, rom therefore no hard disks
  4032                                  		;mov	[HNUM], DL	; save number of hard drives in HNUM
  4033                                  
  4034                                  ;
  4035                                  ; Set up all the hard drives in the system
  4036                                  ;
  4037                                  		
  4038                                  DoHard:
  4039                                  		;CMP	byte [HNUM],0	; IF (No_Hard_files)
  4040                                  		;JLE	short INIT2	;    THEN EXIT TO CONFIGURE
  4041                                  
  4042                                  		; 09/04/2018
  4043 00000B8D 08D2                    		or	dl, dl
  4044 00000B8F 7452                    		jz	short INIT2
  4045                                  
  4046 00000B91 8816[D409]              		mov	[HNUM], DL	; save number of hard drives in HNUM
  4047                                  
  4048 00000B95 B280                    		MOV	DL,80h
  4049 00000B97 BF[D609]                		MOV	DI,HD0_PARAMETERS
  4050 00000B9A E8B400                  		call	SETHARD
  4051                                  
  4052 00000B9D FE06[C800]              		INC	byte [DRVMAX]
  4053                                  		
  4054 00000BA1 FE0E[D409]              		DEC	byte [HNUM]
  4055 00000BA5 7414                    		JZ	SHORT SET_DSKDRVS_TBL
  4056                                  
  4057                                  		;push	es
  4058 00000BA7 B281                    		mov	DL, 81h
  4059 00000BA9 B408                    		mov	AH, 08h
  4060 00000BAB CD13                    		int	13h
  4061                                  		;pop	es
  4062 00000BAD 720C                    		jc	short SET_DSKDRVS_TBL
  4063                                  
  4064 00000BAF B281                    		MOV	DL,81h
  4065 00000BB1 BF[E909]                		MOV	DI,HD1_PARAMETERS
  4066 00000BB4 E89A00                  		call	SETHARD
  4067                                  
  4068 00000BB7 FE06[C800]              		INC	byte [DRVMAX]
  4069                                  
  4070                                  
  4071                                  ; End of physical drive initialization.	
  4072                                  
  4073                                  SET_DSKDRVS_TBL:
  4074                                  		; 11/04/2018
  4075 00000BBB 0E                      		push	cs
  4076 00000BBC 07                      		pop	es
  4077                                  		; 07/04/2018
  4078 00000BBD BF[BA08]                		MOV	DI,DSKDRVS
  4079 00000BC0 BE[C208]                		MOV	SI,HDSKTAB
  4080                                  		
  4081 00000BC3 A0[D300]                		mov	al, [HARDNUM]  ; number of floppies or
  4082 00000BC6 3C02                    		cmp	al, 2	       ; drv number of 1st hard drive
  4083 00000BC8 7311                    		jnb	short NO_SET_DEF
  4084                                  
  4085                                  		;mov	ax, _360K_PARAMETERS ; Default for Retro DOS v2.0	
  4086                                  		;stosw
  4087                                  		;stosw		
  4088                                  
  4089                                  		; 10/04/2018
  4090 00000BCA 8A26[C800]              		mov	ah, [DRVMAX] ; number of disks
  4091 00000BCE 28C4                    		sub	ah, al	     ; = number of hard disks 	
  4092                                  		
  4093 00000BD0 B002                    		mov	al, 2
  4094 00000BD2 00C4                    		add	ah, al	      ; number of disks with B: diskette	
  4095                                  
  4096 00000BD4 A2[D300]                		mov	[HARDNUM], al
  4097 00000BD7 8826[C800]              		mov	[DRVMAX], ah ; 10/04/2018
  4098                                  
  4099                                  		;JMP	SHORT MOV_HD_TBL_ADDR
  4100                                  
  4101                                  NO_SET_DEF:
  4102 00000BDB 30E4                    		xor	ah, ah
  4103 00000BDD D0E0                    		shl	al, 1
  4104 00000BDF 01C7                    		add	di, ax
  4105                                  ;MOV_HD_TBL_ADDR:
  4106 00000BE1 A5                      		movsw
  4107 00000BE2 A5                      		movsw
  4108                                  
  4109                                  INIT2:
  4110 00000BE3 803E[C800]03            		CMP	BYTE [DRVMAX], 3
  4111 00000BE8 7207                    		JB	SHORT NO_HARDDISKS
  4112 00000BEA 7719                    		JA	SHORT GOSYSINIT
  4113                                  
  4114 00000BEC B8[E909]                		MOV	AX,END_OF_HD1P_TBL
  4115 00000BEF EB03                    		JMP	SHORT CHANGE_FINALDOS_ADDR
  4116                                  NO_HARDDISKS:
  4117 00000BF1 B8[D309]                		MOV	AX,END_OF_FDP_TBLS		
  4118                                  CHANGE_FINALDOS_ADDR:
  4119 00000BF4 83C00F                  		ADD	AX,15
  4120 00000BF7 D1E8                    		SHR	AX,1
  4121 00000BF9 D1E8                    		SHR	AX,1
  4122 00000BFB D1E8                    		SHR	AX,1
  4123 00000BFD D1E8                    		SHR	AX,1
  4124 00000BFF 83C070                  		ADD	AX,KERNEL_SEGMENT
  4125 00000C02 A3[0A0D]                		MOV	[SYSINIT_START+FINAL_DOS_LOCATION],AX
  4126                                  GOSYSINIT:
  4127                                  		; 19/03/2018
  4128 00000C05 B96943                  		mov	cx, msdos_bin_size+1
  4129 00000C08 D1E9                    		shr	cx, 1
  4130 00000C0A 890E[100D]              		mov	[SYSINIT_START+DOSSIZE], cx ; DOS size in words
  4131                                  
  4132                                  		; 07/04/2018
  4133                                  		; Retro DOS v2.0
  4134                                  
  4135                                  ; *** SYSINIT1.ASM ***
  4136                                  ; ----------------------------------------------------------------------------
  4137                                  ; START OF MSDOS 3.3 SYSINIT CODE - SYSINIT1.ASM - 24/07/1987
  4138                                  ; ----------------------------------------------------------------------------
  4139                                  ; 25/03/2018 - Retro DOS v2.0
  4140                                  
  4141                                  SYSINIT:
  4142                                  		;JMP	GOINIT
  4143                                  
  4144                                  ; ..SYSINIT DATA .............................................................
  4145                                  
  4146                                  GOINIT:
  4147                                  
  4148                                  Move_Myself:
  4149                                  		; 03/05/2018
  4150                                  		; 25/02/2018 - Retro DOS 2.0 - MSDOS 2.0 "SYSINIT.ASM"
  4151                                  		; (Modified for Retro DOS 2.0, for NASM 'incbin' method)
  4152                                  
  4153                                  		SYSINITSIZE	EQU  sysinit_code_end - sysinit_code_start
  4154                                  
  4155                                  		; 28/03/2018
  4156                                          	;CLD
  4157 00000C0E BE[000D]                        	MOV     SI,SYSINIT_START
  4158 00000C11 31FF                            	XOR     DI,DI
  4159                                  		; 19/03/2018
  4160 00000C13 8B0E[120D]              	       	mov	CX,[SYSINIT_START+MEMORY_SIZE]
  4161                                  
  4162 00000C17 B86909                  		MOV	AX,SYSINITSIZE + 15 ; 03/05/2018
  4163 00000C1A D1E8                    		SHR     AX,1                    ; Divide by 16 for paras
  4164 00000C1C D1E8                    		SHR     AX,1
  4165 00000C1E D1E8                    		SHR     AX,1
  4166 00000C20 D1E8                    		SHR     AX,1
  4167 00000C22 29C1                    		SUB     CX,AX
  4168 00000C24 8EC1                    		MOV     ES,CX ; SYSINITSEG = [MEMORY_SIZE] - (SYSIZE+15)/16
  4169 00000C26 B95B09                  		MOV     CX,SYSINITSIZE + 1
  4170 00000C29 D1E9                    		SHR     CX,1                    ; Divide by 2 to get words
  4171 00000C2B F3A5                    		REP     MOVSW                   ; RELOCATE SYSINIT
  4172                                  
  4173 00000C2D 06                      		PUSH    ES
  4174 00000C2E 31C0                    		XOR	AX,AX ; 0
  4175 00000C30 50                      		PUSH    AX
  4176                                  
  4177 00000C31 CB                      		RETF	; far jump to final location of SYSINIT code
  4178                                  
  4179                                  ; ----------------------------------------------------------------------------
  4180                                  ; MSINIT.ASM (MSDOS 3.3)
  4181                                  ; ----------------------------------------------------------------------------
  4182                                  ; 19/03/2018
  4183                                  
  4184                                  ;	READ A BOOT RECORD INTO 7C0h:BootBias
  4185                                  ;  GetBoot reads the boot record into 7C0h:BootBias
  4186                                  ;  On Entry:
  4187                                  ;	DL contains ROM drive number (80h or 81h)
  4188                                  ;  On Exit:
  4189                                  ;	if carry set error
  4190                                  ;	if carry clear:
  4191                                  ;	   ES:BX piont to boot sector
  4192                                  ;	AX and CX are not preserved
  4193                                  ;	BX and ES are used to return values
  4194                                  ;
  4195                                  GETBOOT:
  4196                                  		; 08/04/2018
  4197                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  4198                                  
  4199                                  		;mov	AX, 07C0h     ; prepare to load ES
  4200                                  		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991	
  4201                                  		;mov	ax, [cs:init_bootseg]
  4202 00000C32 A1[020A]                		mov	ax, [init_bootseg]
  4203 00000C35 8EC0                    		mov	ES, AX	      ; load ES segment register
  4204 00000C37 BB0002                  		mov	BX, BootBias  ; load BX,  ES:BX is where sector goes
  4205 00000C3A B80102                  		mov	AX, 0201h     ; command to read & num sec. to 1
  4206 00000C3D 30F6                    		xor	DH, DH	      ; head number zero
  4207 00000C3F B90100                  		mov	CX, 0001h     ; cylinder zero and sector one
  4208 00000C42 CD13                    		int	13h	      ; call rom bios
  4209 00000C44 720A                    		jc	short ERRET
  4210 00000C46 26813EFE0355AA          		cmp	WORD [ES:BootBias+1FEH],0AA55H	; DAVE LITTON MAGIC BYTE?
  4211 00000C4D 7401                    		je	short Norm_Ret
  4212 00000C4F F9                      		stc
  4213                                  ERRET:
  4214                                  Norm_Ret:
  4215 00000C50 C3                      		RETN
  4216                                  
  4217                                  ;
  4218                                  ;   SetHard - generate BPB for a variable sized hard file.  IBM has a
  4219                                  ;   partitioned hard file; we must read physical sector 0 to determine where
  4220                                  ;   our own logical sectors start.  We also read in our boot sector to
  4221                                  ;   determine version number
  4222                                  ;
  4223                                  ;   Inputs:	DL is ROM drive number (80 OR 81)
  4224                                  ;		DS:DI points to BDS
  4225                                  ;   Outputs:	Carry clear -> BPB is filled in
  4226                                  ;		Carry set   -> BPB is left uninitialized due to error
  4227                                  ;
  4228                                  
  4229                                  SETHARD:
  4230                                  		; 13/04/2018
  4231                                  		; 08/04/2018
  4232                                  		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
  4233                                  		
  4234                                  		;push	dx
  4235                                  		;mov	ah,8
  4236                                              	;int	13h	; GET CURRENT DRIVE PARAMETERS
  4237                                  				; Input:
  4238                                  				;   DL = drive number
  4239                                  				; Return:
  4240                                  				;   CF set on error
  4241                                  				;   AH = status code, BL = drive type
  4242                                  				;   DL = number of consecutive drives
  4243                                  				;   DH = maximum value for head number
  4244                                  				;   ES:DI -> drive parameters
  4245                                  		; 09/04/2018
  4246                                  		;push	cs
  4247                                  		;pop	es
  4248                                  		
  4249 00000C51 FEC6                    		inc	dh 		; Number of heads
  4250 00000C53 88750F                  		mov	[di+0Fh],dh 	; bsHeads
  4251                                  		;pop	dx
  4252                                  		;jc	short SETRET
  4253 00000C56 80E13F                  		and	cl, 3Fh		; Sectors per track
  4254 00000C59 884D0D                  		mov	[di+0Dh],cl 	; bsSecPerTrack
  4255 00000C5C E8D3FF                  		call	GETBOOT
  4256 00000C5F 7213                    		jc	short SETRET
  4257                                  		; 13/04/2018
  4258                                  		;mov	bx, 1C2h
  4259 00000C61 BBC203                  		mov	bx, BootBias+1C2h ; Partition Table offset
  4260                                  SET1:
  4261 00000C64 26803F01                		cmp	byte [ES:BX], 1 ; Primary DOS Partition, FAT12 file system
  4262 00000C68 740B                    		je	short OKDrive
  4263 00000C6A 83C310                  		add	bx, 16		; Next partition
  4264                                  		;cmp	bx, 202h	; End of masterboot sector / partition table	
  4265 00000C6D 81FB0204                		cmp	bx,  BootBias+202h ; 13/04/2018
  4266 00000C71 72F1                    		jb	short SET1		
  4267 00000C73 F9                      		stc
  4268                                  SETRET:
  4269 00000C74 C3                      		retn
  4270                                  
  4271                                  OKDrive:
  4272 00000C75 268B4704                		mov	ax, [ES:BX+4]	; Start sector (LBA)
  4273 00000C79 894511                  		mov	[di+11h], ax	; Hidden sectors	      ; bsHidden1
  4274 00000C7C 268B4708                		mov	ax, [ES:BX+8]	; Partition size in sectors
  4275 00000C80 83F840                  		cmp	ax, 64
  4276 00000C83 72EF                    		jb	short SETRET
  4277 00000C85 894508                  		mov	[di+8], ax	; Total sectors (Volume Size) ; bsSectors
  4278 00000C88 B90001                  		mov	cx, 256
  4279 00000C8B BA4000                  		mov	dx, 64
  4280 00000C8E 3D0002                  		cmp	ax, 512
  4281 00000C91 7629                    		jbe	short GotParm
  4282 00000C93 00ED                    		add	ch, ch			; 512
  4283 00000C95 FEC1                    		inc	cl 		     ; 1
  4284 00000C97 BA7000                  		mov	dx, 112		; 112
  4285 00000C9A 3D0008                  		cmp	ax, 2048
  4286 00000C9D 761D                    		jbe	short GotParm
  4287 00000C9F 00ED                    		add	ch, ch 			; 1024
  4288 00000CA1 FEC1                    		inc	cl		     ; 2
  4289 00000CA3 BA0001                  		mov	dx, 256		; 256
  4290 00000CA6 3D0020                  		cmp     ax, 8192  	; 19/05/2018
  4291 00000CA9 7611                    		jbe	short GotParm
  4292 00000CAB 00ED                    		add	ch, ch			; 2048
  4293 00000CAD FEC1                    		inc	cl 		     ; 3
  4294 00000CAF 01D2                    		add	dx, dx 		; 512
  4295 00000CB1 3DA87F                  		cmp	ax, 32680
  4296 00000CB4 7606                    		jbe	short GotParm	; 19/05/2018
  4297 00000CB6 00ED                    		add	ch, ch			; 4096
  4298 00000CB8 FEC1                    		inc	cl		     ; 4
  4299 00000CBA 01D2                    		add	dx, dx 		; 1024
  4300                                  	  
  4301                                  GotParm:
  4302 00000CBC 895506                  		mov     [di+6], dx  	; Root directory entries ; bsRootDirEnts 
  4303 00000CBF 886D02                  		mov     [di+2], ch	; Sectors per cluster
  4304                                  		;xor	bx, bx
  4305 00000CC2 30FF                    		xor	bh, bh
  4306 00000CC4 88EB                    		mov     bl, ch
  4307 00000CC6 4B                      		dec     bx		
  4308 00000CC7 01C3                    		add     bx, ax
  4309 00000CC9 D3EB                    		shr     bx, cl		; Cluster (Sector) shift value
  4310 00000CCB 43                      		inc     bx
  4311 00000CCC 80E3FE                  		and     bl, 0FEh
  4312 00000CCF 89DE                    		mov     si, bx
  4313 00000CD1 D1EB                    		shr     bx, 1
  4314 00000CD3 01F3                    		add     bx, si
  4315 00000CD5 81C3FF01                		add     bx, 511
  4316 00000CD9 D0EF                    		shr     bh, 1
  4317 00000CDB 887D0B                  		mov     [di+0Bh], bh	; FAT sectors
  4318 00000CDE F8                      		clc
  4319 00000CDF C3                      		retn
  4320                                  							
  4321                                  ; ----------------------------------------------------------------------------
  4322                                  
  4323                                  ; SI POINTS TO DEVICE HEADER
  4324                                  ;
  4325                                  ;  4/22/86 - print_init, aux_init is modified to eliminate the
  4326                                  ;  self-modifying code.
  4327                                  
  4328                                  PRINT_INIT:
  4329 00000CE0 E80F00                  		call	GET_DEVICE_NUMBER
  4330 00000CE3 B401                    		mov	ah,1		;initalize printer port
  4331 00000CE5 CD17                    		int	17h		;call ROM-Bios routine
  4332 00000CE7 C3                      		retn
  4333                                  
  4334                                  AUX_INIT:
  4335 00000CE8 E80700                  		call	GET_DEVICE_NUMBER
  4336 00000CEB B0A3                    		mov	al,RSINIT	;2400,N,1,8 (MSEQU.INC)
  4337 00000CED B400                    		mov	ah,0		;initalize AUX port
  4338 00000CEF CD14                    		int	14h		;call ROM-Bios routine
  4339 00000CF1 C3                      		retn
  4340                                  
  4341                                  GET_DEVICE_NUMBER:
  4342                                  ;SI -> device header
  4343                                  		;MOV	AL,[CS:SI+13]	;GET DEVICE NUMBER FROM THE NAME
  4344 00000CF2 8A440D                  		MOV	AL,[SI+13]
  4345 00000CF5 2C31                    		SUB	AL,'1'
  4346 00000CF7 98                      		CBW
  4347 00000CF8 89C2                    		MOV	DX,AX
  4348 00000CFA C3                      		RETN
  4349                                  
  4350 00000CFB 90<rept>                align 16
  4351                                  
  4352                                  ; ----------------------------------------------------------------------------
  4353                                  ; MSDOS 2.0 -IBMBIO.COM- SYSINIT CODE ('SYSINIT.ASM')  	-will be relocated-
  4354                                  ; ----------------------------------------------------------------------------
  4355                                  
  4356                                  SYSINIT_START equ $
  4357                                  
  4358                                  sysinit_code_start: ; 10/06/2018 (sysinit.s)
  4359 00000D00 <incbin>                		incbin	'SYSINIT.BIN' ; Retro DOS 2.0 - MSDOS 2.0 'SYSINIT'
  4360                                  sysinit_code_end:
  4361 0000165A 90                      		db 90h  ; 09/04/2018	
  4362                                  
  4363 0000165B 90<rept>                align 16 ; Paragraph alignment is necessary here for MSDOS kernel relocation
  4364                                  
  4365                                  ; ----------------------------------------------------------------------------
  4366                                  ; START OF MSDOS 2.0 -IBMDOS.COM- KERNEL CODE (MSDOS.SYS) -will be relocated-
  4367                                  ; ----------------------------------------------------------------------------
  4368                                  
  4369                                  MSDOS_BIN_OFFSET:  ; this offset must be paragraph aligned
  4370 00001660 <incbin>                incbin		'MSDOS2.BIN'  ; 18/07/2018
  4371                                  msdos_bin_size	equ $ - MSDOS_BIN_OFFSET
  4372                                  
  4373                                  align 2
  4374                                  END_OF_KERNEL equ $
