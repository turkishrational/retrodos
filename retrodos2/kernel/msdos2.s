; ****************************************************************************
; MSDOS2.BIN (MSDOS 2.0 Kernel) - RETRO DOS v2.0 by ERDOGAN TAN
; ----------------------------------------------------------------------------
; Last Update: 18/07/2018
; ----------------------------------------------------------------------------
; Beginning: 24/02/2018 
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.11  
; ----------------------------------------------------------------------------
;	    ((nasm msdos2.s -l msdos2.lst -o MSDOS2.BIN)) 	
; ----------------------------------------------------------------------------
; Derived from 'MSCODE.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
; by Microsoft, 25/08/1983 (DOSLINK - 'MSDOS.ASM')
; ****************************************************************************
; main file: 'retrodos2.s'
; incbin 'MSDOS2.BIN' ; (DOSGROUP CODE SEGMENT)

; MSDOS 2.0 Kernel source files:
; 	MSDOS.ASM (STDSW.ASM + MSHEAD.ASM + MSDATA.ASM)
;	MSCODE.ASM
;	DOSMES.ASM ... STDIO.ASM, TIME.ASM, XENIX.ASM, XENIX2.ASM

;============================================================================
; DOSLINK
;============================================================================
;msdos mscode dosmes misc getset dircall alloc dev dir +
;disk fat rom stdbuf stdcall stdctrlc stdfcb stdproc +
;stdio time xenix xenix2

;============================================================================
; This MSDOS source code is verified & modified by using IDA Pro Disassembler
; output in TASM syntax (16/04/2018..18/04/2018 -> NASM syntax)
;============================================================================
; MSDOS2.ASM - MSDOS 2.11 KERNEL SOURCE CODE - Erdogan Tan, 18/04/2018
; 						(Assembler: NASM 2.11)
;
; ###########################################################################
; #	This file is generated by The Interactive Disassembler (IDA)	    #
; #	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    #
; #			 Licensed to: Freeware version			    #
; ###########################################################################
;
; Input	MD5   :	1D55763C742AEA72C3B64A0E8564E585

; ---------------------------------------------------------------------------
; File Name   :	D:\Documents and Settings\Erdoðan Tan\Desktop\IBMDOS.COM
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 4318h Loaded length: 4318h
;============================================================================


;============================================================================
; MSDOS.ASM
;============================================================================

;TITLE   Standard MSDOS
;NAME    MSDOS_2

; Number of disk I/O buffers

;	INCLUDE STDSW.ASM
;       INCLUDE MSHEAD.ASM
;       INCLUDE MSDATA.ASM

;	END

;============================================================================
; STDSW.ASM
;============================================================================

TRUE    EQU     0FFFFH
FALSE   EQU     ~TRUE ; NOT TRUE

; Use the switches below to produce the standard Microsoft version or the IBM
; version of the operating system
;MSVER   EQU     false
;IBM     EQU     true
;WANG    EQU     FALSE
;ALTVECT EQU     FALSE

; Set this switch to cause DOS to move itself to the end of memory
;HIGHMEM EQU     FALSE

;	IF      IBM
ESCCH   EQU     0			; character to begin escape seq.
CANCEL  EQU     27
TOGLINS EQU     TRUE			;One key toggles insert mode
TOGLPRN EQU     TRUE			;One key toggles printer echo
ZEROEXT EQU     TRUE
;       ELSE
;       IF      WANG			;Are we assembling for WANG?
;ESCCH   EQU     1FH			;Yes. Use 1FH for escape character
;       ELSE
;ESCCH   EQU     1BH
;       ENDIF
;CANCEL  EQU     "X"-"@"		;Cancel with Ctrl-X
;TOGLINS EQU     WANG			;Separate keys for insert mode on
					;and off if not WANG
;TOGLPRN EQU     FALSE			;Separate keys for printer echo on
					;and off
;ZEROEXT EQU     TRUE
;        ENDIF

;============================================================================
; MSHEAD.ASM
;============================================================================

;--------------------------------------------------------------
; TITLE   MSHEAD.ASM -- MS-DOS DEFINITIONS
;--------------------------------------------------------------

; MS-DOS High-performance operating system for the 8086  version 1.28
;        by Microsoft MSDOS development group:
;           Tim Paterson (Ret.)
;           Aaron Reynolds
;           Nancy Panners (Parenting)
;           Mark Zbikowski
;           Chris Peters (BIOS) (ret.)

; ****************** Revision History *************************
;          >> EVERY change must noted below!! <<
;
; 0.34 12/29/80 General release, updating all past customers
; 0.42 02/25/81 32-byte directory entries added
; 0.56 03/23/81 Variable record and sector sizes
; 0.60 03/27/81 Ctrl-C exit changes, including register save on user stack
; 0.74 04/15/81 Recognize I/O devices with file names
; 0.75 04/17/81 Improve and correct buffer handling
; 0.76 04/23/81 Correct directory size when not 2^N entries
; 0.80 04/27/81 Add console input without echo, Functions 7 & 8
; 1.00 04/28/81 Renumber for general release
; 1.01 05/12/81 Fix bug in `STORE'
; 1.10 07/21/81 Fatal error trapping, NUL device, hidden files, date & time,
;               RENAME fix, general cleanup
; 1.11 09/03/81 Don't set CURRENT BLOCK to 0 on open; fix SET FILE SIZE
; 1.12 10/09/81 Zero high half of CURRENT BLOCK after all (CP/M programs don't)
; 1.13 10/29/81 Fix classic "no write-through" error in buffer handling
; 1.20 12/31/81 Add time to FCB; separate FAT from DPT; Kill SMALLDIR; Add
;               FLUSH and MAPDEV calls; allow disk mapping in DSKCHG; Lots
;               of smaller improvements
; 1.21 01/06/82 HIGHMEM switch to run DOS in high memory
; 1.22 01/12/82 Add VERIFY system call to enable/disable verify after write
; 1.23 02/11/82 Add defaulting to parser; use variable escape character Don't
;               zero extent field in IBM version (back to 1.01!)
; 1.24 03/01/82 Restore fcn. 27 to 1.0 level; add fcn. 28
; 1.25 03/03/82 Put marker (00) at end of directory to speed searches
; 1.26 03/03/82 Directory buffers searched as a circular queue, current buffer
;               is searched first when possible to minimize I/O
;      03/03/82 STORE routine optimized to tack on partial sector tail as
;               full sector write when file is growing
;      03/09/82 Multiple I/O buffers
;      03/29/82 Two bugs:  Delete all case resets search to start at beginning
;               of directory (infinite loop possible otherwise), DSKRESET
;               must invalidate all buffers (disk and directory).
; 1.27 03/31/82 Installable device drivers
;                 Function call 47 - Get pointer to device table list
;                 Function call 48 - Assign CON AUX LIST
;      04/01/82 Spooler interrupt (INT 28) added.
; 1.28 04/15/82 DOS retructured to use ASSUMEs and PROC labels around system
;               call entries.  Most CS relative references changed to SS
;               relative with an eye toward putting a portion of the DOS in
;               ROM.  DOS source also broken into header, data and code pieces
;      04/15/82 GETDMA and GETVECT calls added as 24 and 32.  These calls
;               return the current values.
;      04/15/82 INDOS flag implemented for interrupt processing along with
;               call to return flag location (call 29)
;      04/15/82 Volume ID attribute added
;      04/17/82 Changed ABORT return to user to a long ret from a long jump to
;               avoid a CS relative reference.
;      04/17/82 Put call to STATCHK in dispatcher to catch ^C more often
;      04/20/82 Added INT int_upooler into loop ^S wait
;      04/22/82 Dynamic disk I/O buffer allocation and call to manage them
;               call 49.
;      04/23/82 Added GETDSKPTDL as call 50, similar to GETFATPT(DL), returns
;               address of DPB
;      04/29/82 Mod to WRTDEV to look for ^C or ^S at console input when
;               writting to console device via file I/O.  Added a console
;               output attribute to devices.
;      04/30/82 Call to en/dis able ^C check in dispatcher Call 51
;      04/30/82 Code to allow assignment of func 1-12 to disk files as well
;               as devices....  pipes, redirection now possible
;      04/30/82 Expanded GETLIST call to 2.0 standard
;      05/04/82 Change to INT int_fatal_abort callout int HARDERR.  DOS SS
;               (data segment) stashed in ES, INT int_fatal_abort routines must
;               preserve ES.  This mod so HARDERR can be ROMed.
; 1.29 06/01/82 Installable block and character devices as per 2.0 spec
;      06/04/82 Fixed Bug in CLOSE regarding call to CHKFATWRT.  It got left
;               out back about 1.27 or so (oops).  ARR
; 1.30 06/07/82 Directory sector buffering added to main DOS buffer queue
; 1.40 06/15/82 Tree structured directories.  XENIX Path Parser MKDIR CHDIR
;               RMDIR Xenix calls
; 1.41 06/13/82 Made GETBUFFR call PLACEBUF
; 1.50 06/17/82 FATs cached in buffer pool, get FAT pointer calls disappear
;               Frees up lots of memory.
; 1.51 06/24/82 BREAKDOWN modified to do EXACT one sector read/write through
;               system buffers
; 1.52 06/30/82 OPEN, CLOSE, READ, WRITE, DUP, DUP2, LSEEK implemented
; 1.53 07/01/82 OPEN CLOSE mod for Xenix calls, saves and gets remote dir
; 1.54 07/11/82 Function calls 1-12 make use of new 2.0 PDB. Init code
;               changed to set file handle environment.
; 2.00 08/01/82 Number for IBM release
;      01/19/83 No environ bug in EXEC
;      01/19/83 MS-DOS OEM INT 21 extensions (SET_OEM_HANDLER)
;      01/19/83 Performance bug fix in cooked write to NUL
;      01/27/83 Growcnt fixed for 32-bits
;      01/27/83 Find-first problem after create
; 2.01 02/17/83 International DOS
; 2.11 08/12/83 Dos split into several more modules for assembly on
;               an IBM PC
;
; *************************************************************

; ----------------------------------------------------------------------------
; EQUATES

; Interrupt Entry Points:

; INTBASE:      ABORT
; INTBASE+4:    COMMAND
; INTBASE+8:    BASE EXIT ADDRESS
; INTBASE+C:    CONTROL-C ABORT
; INTBASE+10H:  FATAL ERROR ABORT
; INTBASE+14H:  BIOS DISK READ
; INTBASE+18H:  BIOS DISK WRITE
; INTBASE+1CH:  END BUT STAY RESIDENT (NOT SET BY DOS)
; INTBASE+20H:  SPOOLER INTERRUPT
; INTBASE+40H:  Long jump to CALL entry point

ENTRYPOINTSEG   EQU     0CH
MAXDIF          EQU     0FFFH
SAVEXIT         EQU     10

       ; INCLUDE DOSSYM.ASM
       ; INCLUDE DEVSYM.ASM

; SUBTTL ^C, terminate/abort/exit and Hard error actions
; PAGE
; There are three kinds of context resets that can occur during normal DOS
; functioning:  ^C trap, terminate/abort/exit, and Hard-disk error.  These must
; be handles in a clean fashion that allows nested executions along with the
; ability to trap one's own errors.
;
; ^C trap - A process may elect to catch his own ^Cs.  This is achieved by
;           using the $GET_INTERRUPT_VECTOR and $SET_INTERRUPT_VECTOR as
;           follows:
;
;           $GET_INTERRUPT_VECTOR for INT int_ctrl_c
;           Save it in static memory.
;           $SET_INTERRUPT_VECTOR for INT int_ctrl_c
;
;           The interrupt service routine must preserve all registers and
;           return carry set iff the operation is to be aborted (via abort
;           system call), otherwise, carry is reset and the operation is
;           restarted.  ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE
;           RESULTS.
;
;           To restore original ^C processing (done on terminate/abort/exit),
;           restore INT int_ctrl_c from the saved vector.
;
; Hard-disk error -- The interrupt service routine for INT int_fatal_abort must
;           also preserve registers and return one of three values in AL: 0 and
;           1 imply retry and ignore (???)  and 2 indicates an abort.  The user
;           himself is not to issue the abort, rather, the dos will do it for
;           him by simulating a normal abort/exit system call.  ANY DEVIATION
;           FROM THIS WILL LEAD TO UNRELIABLE RESULTS.
;
; terminate/abort/exit -- The user may not, under any circumstances trap an
;           abort call.  This is reserved for knowledgeable system programs.
;           ANY DEVIATION FROM THIS WILL LEAD TO UNRELIABLE RESULTS.

;SUBTTL SEGMENT DECLARATIONS

; The following are all of the segments used.  They are declared in the order
; that they should be placed in the executable

;
; segment ordering for MSDOS
;

;START           SEGMENT BYTE PUBLIC 'START'
;START           ENDS

;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
;CONSTANTS       ENDS

;DATA            SEGMENT WORD PUBLIC 'DATA'
;DATA            ENDS

;CODE            SEGMENT BYTE PUBLIC 'CODE'
;CODE            ENDS

;LAST            SEGMENT BYTE PUBLIC 'LAST'
;LAST            ENDS

;DOSGROUP    GROUP   CODE,CONSTANTS,DATA,LAST

; The following segment is defined such that the data/const classes appear
; before the code class for ROMification

;START		SEGMENT BYTE PUBLIC 'START'
;           	ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
;		JMP     DOSINIT
;START		ENDS

;============================================================================
; DOSSYM.ASM
;============================================================================

;<Control character definitions>

c_DEL       EQU     7Fh         ;    ASCII rubout or delete previous char
c_BS        EQU     08h         ; ^H ASCII backspace
c_CR        EQU     0Dh         ; ^M ASCII carriage return
c_LF        EQU     0Ah         ; ^J ASCII linefeed
c_ETB       EQU     17h         ; ^W ASCII end of transmission
c_NAK       EQU     15h         ; ^U ASCII negative acknowledge
c_ETX       EQU     03h         ; ^C ASCII end of text
c_HT        EQU     09h         ; ^I ASCII tab

;<BPB Definition>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
; Certain structures, constants and system  calls  below  are  private  to ;
; the DOS  and  are  extremely  version-dependent.  They may change at any ;
; time at  the  implementors'  whim.   As  a  result,  they  must  not  be ;
; documented to  the  general  public.   If  an  extreme case arises, they ;
; must be documented with this warning.                                    ;
;                                                                          ;
; Those structures and constants that are subject to  the  above  will  be ;
; marked and bracketed with the flag:                                      ;
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <Bios Parameter Block>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

; Bios Parameter Block definition
; This structure is used to build a full DPB

struc BPBLOCK
.SECSZ: resw 1		; Size in bytes of physical sector
.CLUS:  resb 1		; Sectors/Alloc unit
.RES:   resw 1		; Number of reserved sectors
.FTCNT: resb 1		; Number of FATs
.DRCNT: resw 1		; Number of directory entries
.SCCNT: resw 1		; Total number of sectors
.MEDIA: resb 1		; Media descriptor byte
.FTSEC:	resw 1		; Number of sectors taken up by one FAT
.size:
endstruc
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <Disk I/O Buffer Header>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

; Field definition for I/O buffer information

struc BUFFINFO
.NEXTBUF:	resd 1		; Pointer to next buffer in list
; The next two items are often refed as a word
.BUFDRV:	resb 1		; Logical drive # assoc with buffer FF = free
.BUFDIRTY:	resb 1		; Dirty flag
.BUFPRI:	resb 1		; Buffer selection priority (see EQUs below)
.VISIT:		resb 1		; Visit flag for buffer pool scans
.BUFSECNO:	resw 1		; Sector number of buffer
; The next two items are often refed as a word
.BUFWRTCNT:	resb 1		; For FAT sectors, # times sector written out
.BUFWRTINC:	resb 1		; "   "     "   , # sectors between each write
.BUFDRVDP:	resd 1		; Pointer to drive parameters
.size:
endstruc

BUFINSIZ        EQU     BUFFINFO.size

                                ; Size of structure in bytes
FREEPRI EQU     0
LBRPRI  EQU     2               ; Last byte of buffer read
LBWPRI  EQU     4               ; Last byte written
RPRI    EQU     6               ; Read but not last byte
WPRI    EQU     8               ; Written but not last byte
DIRPRI  EQU     15              ; Directory Sector
FATPRI  EQU     30              ; FAT sector
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <User stack inside of system call>
; Location of user registers relative user stack pointer

struc	user_env   ; user_environ
.user_AX: resw 1
.user_BX: resw 1
.user_CX: resw 1
.user_DX: resw 1
.user_SI: resw 1
.user_DI: resw 1
.user_BP: resw 1
.user_DS: resw 1
.user_ES: resw 1
.user_IP: resw 1
.user_CS: resw 1
.user_F:  resw 1
.size:
endstruc

; <interrupt definitions>

INTTAB          EQU     20H
INTBASE         EQU     4 * INTTAB
ENTRYPOINT      EQU     INTBASE+40H

;	IF      ALTVECT
;ALTTAB  EQU     0F0H
;ALTBASE EQU     4 * ALTTAB
;	ENDIF

;
; interrupt assignments
;
;	IF	NOT ALTVECT
int_abort           EQU     INTTAB          ; abort process
int_command         EQU     int_abort+1     ; call MSDOS
int_terminate       EQU     int_abort+2     ; int to terminate address
int_ctrl_c          EQU     int_abort+3     ; ^c trapper
int_fatal_abort     EQU     int_abort+4     ; hard disk error
int_disk_read       EQU     int_abort+5     ; logical sector disk read
int_disk_write      EQU     int_abort+6     ; logical sector disk write
int_keep_process    EQU     int_abort+7     ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
int_spooler         EQU     int_abort+8     ; spooler call
int_fastcon         EQU     int_abort+9     ; fast CON interrupt
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        ;ELSE
;int_abort          EQU     INTTAB          ; abort process
;int_command        EQU     int_abort+1     ; call MSDOS
;int_terminate      EQU     ALTTAB          ; int to terminate address
;int_ctrl_c         EQU     int_terminate+1 ; ^c trapper
;int_fatal_abort    EQU     int_terminate+2 ; hard disk error
;int_disk_read      EQU     int_abort+5     ; logical sector disk read
;int_disk_write     EQU     int_abort+6     ; logical sector disk write
;int_keep_process   EQU     int_abort+7     ; terminate program and stay resident
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;int_spooler        EQU     int_terminate+3 ; spooler call
;int_fastcon        EQU     int_abort+9     ; fast CON interrupt
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        ;ENDIF

addr_int_abort          EQU    4 * int_abort
addr_int_command        EQU    4 * int_command
addr_int_terminate      EQU    4 * int_terminate
addr_int_ctrl_c         EQU    4 * int_ctrl_c
addr_int_fatal_abort    EQU    4 * int_fatal_abort
addr_int_disk_read      EQU    4 * int_disk_read
addr_int_disk_write     EQU    4 * int_disk_write
addr_int_keep_process   EQU    4 * int_keep_process
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
addr_int_spooler        EQU    4 * int_spooler
addr_int_fastcon        EQU    4 * int_fastcon
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <Disk map>
;  MSDOS partitions the disk into 4 sections:
;
;  phys sector 0:   +-------------------+
;       |           | boot/reserved     |
;       |           +-------------------+
;       |           |  File allocation  |
;       v           |      table(s)     |
;                   |  (multiple copies |
;                   |     are kept)     |
;                   +-------------------+
;                   |     Directory     |
;                   +-------------------+
;                   |     File space    |
;                   +-------------------+
;                   |   Unaddressable   |
;                   |  (to end of disk) |
;                   +-------------------+
;
; All partition boundaries are sector boundaries.  The size of the FAT is
; adjusted to maximize the file space addressable.

; BREAK <Directory entry>

;
;       +---------------------------+
;       |  (12 BYTE) filename/ext   |       0       0
;       +---------------------------+
;       |     (BYTE) attributes     |       11      B
;       +---------------------------+
;       |    (10 BYTE) reserved     |       12      C
;       +---------------------------+
;       | (WORD) time of last write |       22      16
;       +---------------------------+
;       | (WORD) date of last write |       24      18
;       +---------------------------+
;       |   (WORD) First cluster    |       26      1A
;       +---------------------------+
;       |     (DWORD) file size     |       28      1C
;       +---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;                           = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;
struc dir_entry
.dir_name:	resb 11			; file name
.dir_attr:	resb 1			; attribute bits
.dir_pad:	resb 10			; reserved for expansion
.dir_time:	resw 1			; time of last write
.dir_date:	resw 1			; date of last write
.dir_first:	resw 1			; first allocation unit of file
.dir_size_l:	resw 1			; low 16 bits of file size
.dir_size_h:	resw 1			; high 16 bits of file size
.size:
endstruc

attr_read_only      EQU      1h
attr_hidden         EQU      2h
attr_system         EQU      4h
attr_volume_id      EQU      8h
attr_directory      EQU     10h
attr_archive        EQU     20h

attr_all            EQU     attr_hidden+attr_system+attr_directory
                                        ; OR of hard attributes for FINDENTRY

attr_ignore         EQU     attr_read_only+attr_archive
                                        ; ignore this(ese) attribute(s)
                                        ; during search first/next

attr_changeable     EQU     attr_read_only+attr_hidden+attr_system+attr_archive
                                        ; changeable via CHMOD

; <File allocation Table information>
;
; The File Allocation Table uses a 12-bit entry for each allocation unit on the
; disk.  These entries are packed, two for every three bytes.  The contents of
; entry number N is found by 1) multiplying N by 1.5; 2) adding the result to
; the base address of the Allocation Table; 3) fetching the 16-bit word at this
; address; 4) If N was odd (so that N*1.5 was not an integer), shift the word
; right four bits; 5) mask to 12 bits (AND with 0FFF hex).  Entry number zero
; is used as an end-of-file trap in the OS and is passed to the BIOS to help
; determine disk format.  Entry 1 is reserved for future use.  The first
; available allocation unit is assigned entry number two, and even though it is
; the first, is called cluster 2.  Entries greater than 0FF8H are end of file
; marks; entries of zero are unallocated.  Otherwise, the contents of a FAT
; entry is the number of the next cluster in the file.
;
; Clusters with bad sectors are tagged with FF7H.  Any non-zero number would do
; because these clusters show as allocated, but are not part of any allocation
; chain and thus will never be allocated to a file.  A particular number is
; selected so that disk checking programs know what to do (ie.  a cluster with
; entry FF7H which is not in a chain is not an error).

; BREAK <DPB structure>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

DIRSTRLEN       EQU     64	; Max length in bytes of directory strings

struc	DPB
.DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
.UNIT:		resb 1		; Driver unit number of DPB
.SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
.CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
.CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
.FIRST_FAT:	resw 1		; Starting record of FATs
.FAT_COUNT:	resb 1		; Number of FATs for this drive
.ROOT_ENTRIES:	resw 1		; Number of directory entries
.FIRST_SECTOR:	resw 1		; First sector of first cluster
.MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
.FAT_SIZE:	resb 1		; Number of records occupied by FAT
.DIR_SECTOR:	resw 1		; Starting record of directory
.DRIVER_ADDR:	resd 1		; Pointer to driver
.MEDIA:		resb 1		; Media byte
.FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
				; check the first time this DPB is used
.NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
.CURRENT_DIR:	resw 1		; Cluster number of start of current directory
				; 0 indicates root, -1 indicates invalid
				; (disk ? changed)
.DIR_TEXT:	resb DIRSTRLEN	; ASCIZ string of current directory
.size:
endstruc

DPBSIZ  EQU     DPB.size	; Size of the structure in bytes

DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; BREAK <File Control Block definition>
;
; Field definition for FCBs
; The FCB has the following structure:
;
;       +---------------------------+
;       |   Drive indicator(byte)   |
;       +---------------------------+
;       |    Filename (8 chars)     |
;       +---------------------------+
;       |    Extension (3 chars)    |
;       +---------------------------+
;       |   Current Extent(word)    |
;       +---------------------------+
;       |    Record size (word)     |
;       +---------------------------+
;       |    File Size (2 words)    |
;       +---------------------------+
;       |       Date of write       |
;       +---------------------------+
;       |       Time of write       |
;       +---------------------------+
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;       | Flags:                    |
;       |  bit 7=0 file/1 device    |
;       |  bit 6=0 if dirty         |
;       |  bits 0-5 deviceid        |
;       +---------------------------+
;       |   first cluster in file   |
;       +---------------------------+
;       | position of last cluster  |
;       +---------------------------+
;       |   last cluster accessed   |   12 bit-+--- packed in 3 bytes
;       +---------------------------+          |
;       |     parent directory      |   <------+
;       +---------------------------+
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;       |    next record number     |
;       +---------------------------+
;       |   random record number    |
;       +---------------------------+
;

struc	SYS_FCB
.drive:	resb 1
.name:	resb 8
.ext:	resb 3
.EXTENT: resw 1
.RECSIZ: resw 1	; Size of record (user settable)
.FILSIZ: resw 1	; Size of file in bytes; used with the following
                        ; word
.DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
.FDATE:	resw 1	; Date of last writing
.FTIME:	resw 1	; Time of last writing
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
.DEVID:	resb 1	; Device ID number, bits 0-5 if file.
                        ; bit 7=0 for file, bit 7=1 for I/O device
                        ; If file, bit 6=0 if dirty
                        ; If I/O device, bit 6=0 if EOF (input)
                        ;               Bit 5=1 if Raw mode
                        ;               Bit 0=1 if console input device
                        ;               Bit 1=1 if console output device
                        ;               Bit 2=1 if null device
                        ;               Bit 3=1 if clock device
.FIRCLUS: resw 1	; First cluster of file
.CLUSPOS: resw 1	; Position of last cluster accessed
.LSTCLUS: resw 1	; Last cluster accessed and directory
          resb 1	; pack 2 12 bit numbers into 24 bits...
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
.NR:	resb 1	; Next record
.RR:	resb 4	; Random record
.size:
endstruc

FILDIRENT       EQU SYS_FCB.FILSIZ	; Used only by SEARCH FIRST and
                                        ; SEARCH NEXT

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
devid_file_clean        EQU     40h     ; true if file and not written
devid_file_mask_drive   EQU     3Fh     ; mask for drive number

devid_device            EQU     80h     ; true if a device
devid_device_EOF        EQU     40h     ; true if end of file reached
devid_device_raw        EQU     20h     ; true if in raw mode
devid_device_special    EQU     10h     ; true if special device
devid_device_clock      EQU     08h     ; true if clock device
devid_device_null       EQU     04h     ; true if null device
devid_device_con_out    EQU     02h     ; true if console output
devid_device_con_in     EQU     01h     ; true if consle input

;
; structure of devid field as returned by IOCTL is:
;
;       BIT     7   6   5   4   3   2   1   0
;             |---|---|---|---|---|---|---|---|
;             | I | E | R | S | I | I | I | I |
;             | S | O | A | P | S | S | S | S |
;             | D | F | W | E | C | N | C | C |
;             | E |   |   | C | L | U | O | I |
;             | V |   |   | L | K | L | T | N |
;             |---|---|---|---|---|---|---|---|
;       ISDEV = 1 if this channel is a device
;             = 0 if this channel is a disk file
;
;       If ISDEV = 1
;
;             EOF = 0 if End Of File on input
;             RAW = 1 if this device is in Raw mode
;                 = 0 if this device is cooked
;             ISCLK = 1 if this device is the clock device
;             ISNUL = 1 if this device is the null device
;             ISCOT = 1 if this device is the console output
;             ISCIN = 1 if this device is the console input
;
;       If ISDEV = 0
;             EOF = 0 if channel has been written
;             Bits 0-5  are  the  block  device  number  for
;                 the channel (0 = A, 1 = B, ...)
;
devid_ISDEV     EQU     80h
devid_EOF       EQU     40h
devid_RAW       EQU     20h
devid_SPECIAL   EQU     10H
devid_ISCLK     EQU     08h
devid_ISNUL     EQU     04h
devid_ISCOT     EQU     02h
devid_ISCIN     EQU     01h

devid_block_dev EQU     1Fh             ; mask for block device number

;
; find first/next buffer
;
struc	find_buf
.sattr:	   resb 1	; attribute of search
.drive:	   resb 1	; drive of search
.name:	   resb 11	; formatted name
.LastEnt:  resw 1	; LastEnt
.ThisDPB:  resd 1	; This DPB
.DirStart: resw 1	; DirStart
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

.attr:	 resb 1		; attribute found
.time:   resb 1		; time
.date:   resb 1		; date
.size_l: resw 1		; low(size)
.size_h: resw 1		; high(size)
.pname:	 resb 13	; packed name
.size:
endstruc

; BREAK <Process data block>
;
; Process data block (otherwise known as program header)
;

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
.ENVIRON:	resw 1		; seg addr of environment
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
.USER_STACK:	resd 1		; stack of self during system calls
.PAD1:		resb 30 ; 1Eh
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
.CALL_SYSTEM:	resb 5		; portable method of system call
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
.PAD2:		resb 6
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
endstruc

; BREAK <EXEC and EXE file structures>
;
; EXEC arg block - load/go program
;

;
; The following get used as arguments to the EXEC system call.  They indicate
; whether or not the program is executed or whether or not a program header
; gets created.
;
exec_func_no_execute    EQU 1           ; no execute bit
exec_func_overlay       EQU 2           ; overlay bit

struc EXEC0
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.size:
endstruc

struc EXEC1
.ENVIRON:	resw 1		; seg addr of environment
.COM_LINE:	resd 1		; pointer to asciz command line
.5C_FCB:	resd 1		; default fcb at 5C
.6C_FCB:	resd 1		; default fcb at 6C
.SP:		resw 1		; stack pointer of program
.SS:		resw 1		; stack seg register of program
.IP:		resw 1		; entry point IP
.CS:		resw 1		; entry point CS
.size:
endstruc

struc EXEC3
.load_addr:	resw 1		; seg address of load point
.reloc_fac:	resw 1		; relocation factor
endstruc

;
; Exit codes in upper byte
;
Exit_Terminate      EQU     0
Exit_Abort          EQU     0
Exit_Ctrl_C         EQU     1
Exit_Hard_Error     EQU     2
Exit_Keep_Process   EQU     3

;
; EXE file header
;

struc EXE
.signature:   resw 1		; must contain 4D5A (yay zibo!)
.len_mod_512: resw 1		; low 9 bits of length
.pages:       resw 1		; number of 512b pages in file
.rle_count:   resw 1		; count of reloc entries
.par_dir:     resw 1		; number of paragraphs before image
.min_BSS:     resw 1		; minimum number of para of BSS
.max_BSS:     resw 1		; max number of para of BSS
.SS:          resw 1		; stack of image
.SP:          resw 1		; SP of image
.chksum:      resw 1		; checksum of file (ignored)
.IP:          resw 1		; IP of entry
.CS:          resw 1		; CS of entry
.rle_table:   resw 1		; byte offset of reloc table
.iov:         resw 1		; overlay number (0 for root)
.sym_tab:     resd 1		; offset of symbol table in file
.size:
endstruc

exe_valid_signature     EQU 5A4Dh
exe_valid_old_signature EQU 4D5Ah

struc symbol_entry
.value:	resd 1
.type:	resw 1
.len:	resb 1
.name:	resb 255
endstruc

; <Internal system file table format>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;
; system file table
;

struc	SFT
.SFT_LINK:	resd 1
.SFT_COUNT:	resw 1		; number of entries
.SFT_TABLE:	resw 1		; beginning of array of the following
.size:
endstruc

;
; system file table entry
;

struc	SF_ENTRY
.sf_ref_count:	resb 1		; number of processes sharing fcb
.sf_mode:	resb 1		; mode of access
.sf_attr:	resb 1		; attribute of file
.sf_fcb:	resb SYS_FCB.size  ; actual FCB
.size:
endstruc

sf_default_number   EQU     5h
; 19/04/2018
sf_entry_size equ SF_ENTRY.size ; 40

;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <Memory arena structure>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;
; arena item
;

struc ARENA
.SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
.OWNER:		resw 1		; owner of arena item
.SIZE:		resw 1		; size in paragraphs of item
endstruc

arena_owner_system  EQU 0               ; free block indication

arena_signature_normal  EQU 4Dh         ; valid signature, not end of arena
arena_signature_end     EQU 5Ah         ; valid signature, last block in arena
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

; <Machine instruction definitions>

mi_INT          EQU     0CDh
mi_Long_JMP     EQU     0EAh
mi_Long_CALL    EQU     09Ah
mi_Long_RET     EQU     0CBh

; <Standard I/O assignments>

stdin       EQU     0
stdout      EQU     1
stderr      EQU     2
stdaux      EQU     3
stdprn      EQU     4

; <Xenix subfunction assignments>

open_for_read   EQU 0
open_for_write  EQU 1
open_for_both   EQU 2

; <Xenix error codes>

;
; XENIX calls all return error codes through AX.  If an error occurred then the
; carry bit will be set and the error code is in AX.  If no error occurred then
; the carry bit is reset and AX contains returned info.
;

no_error_occurred		EQU     0

error_invalid_function          EQU     1
error_file_not_found            EQU     2
error_path_not_found            EQU     3
error_too_many_open_files       EQU     4
error_access_denied             EQU     5
error_invalid_handle            EQU     6
error_arena_trashed             EQU     7
error_not_enough_memory         EQU     8
error_invalid_block             EQU     9
error_bad_environment           EQU     10
error_bad_format                EQU     11
error_invalid_access            EQU     12
error_invalid_data              EQU     13
;**** unused                    EQU     14
error_invalid_drive             EQU     15
error_current_directory         EQU     16
error_not_same_device           EQU     17
error_no_more_files             EQU     18

country_not_found               EQU     error_file_not_found ; DOSSYM_V211.ASM
alloc_not_enough_memory         EQU     error_not_enough_memory
alloc_arena_trashed             EQU     error_arena_trashed

close_invalid_handle            EQU     error_invalid_handle
close_invalid_function          EQU     error_invalid_function

chdir_path_not_found            EQU     error_path_not_found

chmod_path_not_found            EQU     error_path_not_found
chmod_access_denied             EQU     error_access_denied
chmod_invalid_function          EQU     error_invalid_function

creat_access_denied             EQU     error_access_denied
creat_path_not_found            EQU     error_path_not_found
creat_too_many_open_files       EQU     error_too_many_open_files

curdir_invalid_drive            EQU     error_invalid_drive

dealloc_invalid_block           EQU     error_invalid_block
dealloc_arena_trashed           EQU     error_arena_trashed

dup_invalid_handle              EQU     error_invalid_handle
dup_too_many_open_files         EQU     error_too_many_open_files

dup2_invalid_handle             EQU     error_invalid_handle

exec_invalid_function           EQU     error_invalid_function
exec_bad_environment            EQU     error_bad_environment
exec_bad_format                 EQU     error_bad_format
exec_not_enough_memory          EQU     error_not_enough_memory
exec_file_not_found             EQU     error_file_not_found

filetimes_invalid_function      EQU     error_invalid_function
filetimes_invalid_handle        EQU     error_invalid_handle

findfirst_file_not_found        EQU     error_file_not_found
findfirst_no_more_files         EQU     error_no_more_files
findnext_no_more_files          EQU     error_no_more_files

international_invalid_function  EQU     error_invalid_function

ioctl_invalid_handle            EQU     error_invalid_handle
ioctl_invalid_function          EQU     error_invalid_function
ioctl_invalid_data              EQU     error_invalid_data

lseek_invalid_handle            EQU     error_invalid_handle
lseek_invalid_function          EQU     error_invalid_function

mkdir_path_not_found            EQU     error_path_not_found
mkdir_access_denied             EQU     error_access_denied

open_invalid_access             EQU     error_invalid_access
open_file_not_found             EQU     error_file_not_found
open_access_denied              EQU     error_access_denied
open_too_many_open_files        EQU     error_too_many_open_files

read_invalid_handle             EQU     error_invalid_handle
read_access_denied              EQU     error_access_denied

rename_file_not_found           EQU     error_file_not_found
rename_not_same_device          EQU     error_not_same_device
rename_access_denied            EQU     error_access_denied

rmdir_path_not_found            EQU     error_path_not_found
rmdir_access_denied             EQU     error_access_denied
rmdir_current_directory         EQU     error_current_directory

setblock_invalid_block          EQU     error_invalid_block
setblock_arena_trashed          EQU     error_arena_trashed
setblock_not_enough_memory      EQU     error_not_enough_memory
setblock_invalid_function       EQU     error_invalid_function

unlink_file_not_found           EQU     error_file_not_found
unlink_access_denied            EQU     error_access_denied

write_invalid_handle            EQU     error_invalid_handle
write_access_denied             EQU     error_access_denied

; <system call definitions>

ABORT                           EQU 0   ;  0      0
STD_CON_INPUT                   EQU 1   ;  1      1
STD_CON_OUTPUT                  EQU 2   ;  2      2
STD_AUX_INPUT                   EQU 3   ;  3      3
STD_AUX_OUTPUT                  EQU 4   ;  4      4
STD_PRINTER_OUTPUT              EQU 5   ;  5      5
RAW_CON_IO                      EQU 6   ;  6      6
RAW_CON_INPUT                   EQU 7   ;  7      7
STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
STD_CON_STRING_INPUT            EQU 10  ; 10      A
STD_CON_INPUT_STATUS            EQU 11  ; 11      B
STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
DISK_RESET                      EQU 13  ; 13      D
SET_DEFAULT_DRIVE               EQU 14  ; 14      E
FCB_OPEN                        EQU 15  ; 15      F
FCB_CLOSE                       EQU 16  ; 16     10
DIR_SEARCH_FIRST                EQU 17  ; 17     11
DIR_SEARCH_NEXT                 EQU 18  ; 18     12
FCB_DELETE                      EQU 19  ; 19     13
FCB_SEQ_READ                    EQU 20  ; 20     14
FCB_SEQ_WRITE                   EQU 21  ; 21     15
FCB_CREATE                      EQU 22  ; 22     16
FCB_RENAME                      EQU 23  ; 23     17
GET_DEFAULT_DRIVE               EQU 25  ; 25     19
SET_DMA                         EQU 26  ; 26     1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DEFAULT_DPB                 EQU 31  ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_RANDOM_READ                 EQU 33  ; 33     21
FCB_RANDOM_WRITE                EQU 34  ; 34     22
GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
GET_FCB_POSITION                EQU 36  ; 36     24
SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
GET_DATE                        EQU 42  ; 42     2A
SET_DATE                        EQU 43  ; 43     2B
GET_TIME                        EQU 44  ; 44     2C
SET_TIME                        EQU 45  ; 45     2D
SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
; Extended functionality group
GET_DMA                         EQU 47  ; 47     2F
GET_VERSION                     EQU 48  ; 48     30
KEEP_PROCESS                    EQU 49  ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
GET_DPB                         EQU 50  ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
GET_INDOS_FLAG                  EQU 52  ; 52     34
GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
GET_DRIVE_FREESPACE             EQU 54  ; 54     36
CHAR_OPER                       EQU 55  ; 55     37
INTERNATIONAL                   EQU 56  ; 56     38
; XENIX CALLS
;   Directory Group
MKDIR                           EQU 57  ; 57     39
RMDIR                           EQU 58  ; 58     3A
CHDIR                           EQU 59  ; 59     3B
;   File Group
CREAT                           EQU 60  ; 60     3C
OPEN                            EQU 61  ; 61     3D
CLOSE                           EQU 62  ; 62     3E
READ                            EQU 63  ; 63     3F
WRITE                           EQU 64  ; 64     40
UNLINK                          EQU 65  ; 65     41
LSEEK                           EQU 66  ; 66     42
CHMOD                           EQU 67  ; 67     43
IOCTL                           EQU 68  ; 68     44
XDUP                            EQU 69  ; 69     45
XDUP2                           EQU 70  ; 70     46
CURRENT_DIR                     EQU 71  ; 71     47
;    Memory Group
ALLOC                           EQU 72  ; 72     48
DEALLOC                         EQU 73  ; 73     49
SETBLOCK                        EQU 74  ; 74     4A
;    Process Group
EXEC                            EQU 75  ; 75     4B
EXIT                            EQU 76  ; 76     4C
_WAIT				EQU 77  ; 77     4D
FIND_FIRST                      EQU 78  ; 78     4E
;   Special Group
FIND_NEXT                       EQU 79  ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
SET_CURRENT_PDB                 EQU 80  ; 80     50
GET_CURRENT_PDB                 EQU 81  ; 81     51
GET_IN_VARS                     EQU 82  ; 82     52
SETDPB                          EQU 83  ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
DUP_PDB                         EQU 85  ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
RENAME                          EQU 86  ; 86     56
FILE_TIMES                      EQU 87  ; 87     57

SET_OEM_HANDLER			EQU 248 ; 248    F8
;OEM_C1				EQU 249 ; 249    F9
;OEM_C2				EQU 250 ; 250    FA
;OEM_C3				EQU 251 ; 251    FB
;OEM_C4				EQU 252 ; 252    FC
;OEM_C5				EQU 253 ; 253    FD
;OEM_C6				EQU 254 ; 254    FE
;OEM_C7				EQU 255 ; 255    FF

;============================================================================
; DOSSYM_V211.ASM
;============================================================================

DOS_MAJOR_VERSION   EQU      2
DOS_MINOR_VERSION   EQU     11

;
; Current structure of the data returned by the international call
;

struc	INTERNAT_BLOCK
.Date_tim_format:
		RESW 1		; 0-USA, 1-EUR, 2-JAP
.Currency_sym:
		RESB 5		; Currency Symbol 5 bytes
.Thous_sep:
		RESB 2		; Thousands separator 2 bytes
.Decimal_sep:
		RESB 2		; Decimal separator 2 bytes
.Date_sep:
		RESB 2		; Date separator 2 bytes
.Time_sep:
		RESB 2		; Time separator 2 bytes
.Bit_field:	
		RESB 1		; Bit values
                                   ;   Bit 0 = 0 if currency symbol first
                                   ;         = 1 if currency symbol last
                                   ;   Bit 1 = 0 if No space after currency symbol
                                   ;         = 1 if space after currency symbol
.Currency_cents:
		RESB 	1	; Number of places after currency dec point
.Time_24:
		RESB 	1	; 1 if 24 hour time, 0 if 12 hour time
.Map_call:
		RESW	1	; Address of case mapping call (DWORD)
                RESW	1       ; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
.Data_sep:
		RESB	2	; Data list separator character
.size:		
endstruc

;============================================================================
; DEVSYM.ASM
;============================================================================

;SUBTTL DEVICE TABLE AND SRH DEFINITION
;PAGE

; The device table list has the form:
struc	SYSDEV
.NEXT:		resd 1		;Pointer to next device header
.ATT:		resw 1		;Attributes of the device
.STRAT:		resw 1		;Strategy entry point
.INT:		resw 1		;Interrupt entry point
.NAME:		resb 8		;Name of device (only first byte used for block)
.size:
endstruc

;Attribute bit masks
DEVTYP  EQU     8000H           ;Bit 15 - 1  if Char, 0 if block
DEVIOCTL EQU    4000H           ;Bit 14 - CONTROL mode bit
ISFATBYDEV EQU  2000H           ;Bit 13 - Device uses FAT ID bytes, comp media.
ISCIN   EQU     0001H           ;Bit 0 - This device is the console input.
ISCOUT  EQU     0002H           ;Bit 1 - This device is the console output.
ISNULL  EQU     0004H           ;Bit 2 - This device is the null device.
ISCLOCK EQU     0008H           ;Bit 3 - This device is the clock device.
;ISIBM	EQU     0010H		;Bit 4 - This device is special
ISSPEC	EQU     0010H		;Bit 4 - This device is special ; 15/03/2018

;Static Reguest Header
struc	SRHEAD
.REQLEN:	resb 1		;Length in bytes of request block
.REQUNIT:	resb 1		;Device unit number
.REQFUNC:	resb 1		;Type of request
.REQSTAT:	resw 1		;Status Word
        	resb 8		;Reserved for queue links
.size:
endstruc

;Status word masks
STERR   EQU     8000H           ;Bit 15 - Error
STBUI   EQU     0200H           ;Bit 9 - Buisy
STDON   EQU     0100H           ;Bit 8 - Done
STECODE EQU     00FFH           ;Error code
WRECODE EQU     0

;Function codes
DEVINIT EQU     0               ;Initialization
DINITHL EQU     26              ;Size of init header
DEVMDCH EQU     1               ;Media check
DMEDHL  EQU     15              ;Size of media check header
DEVBPB  EQU     2               ;Get BPB
DEVRDIOCTL EQU  3               ;IOCTL read
DBPBHL  EQU     22              ;Size of Get BPB header
DEVRD   EQU     4               ;Read
DRDWRHL EQU     22              ;Size of RD/WR header
DEVRDND EQU     5               ;Non destructive read no wait (character devs)
DRDNDHL EQU     14              ;Size of non destructive read header
DEVIST  EQU     6               ;Input status
DSTATHL EQU     13              ;Size of status header
DEVIFL  EQU     7               ;Input flush
DFLSHL  EQU     15              ;Size of flush header
DEVWRT  EQU     8               ;Write
DEVWRTV EQU     9               ;Write with verify
DEVOST  EQU     10              ;Output status
DEVOFL  EQU     11              ;Output flush
DEVWRIOCTL EQU  12              ;IOCTL write

;============================================================================
; MSDATA.ASM
;============================================================================

; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
; SUBTTL Uninitialized data overlayed by initialization code
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
;PAGE
;DATA    SEGMENT WORD PUBLIC 'DATA'
; Init code overlaps with data area below

;        ORG     0
;        i_am    INBUF,128
;        I_AM    CONBUF,131              ; The rest of INBUF and console buffer
;        i_am    TIMEBUF,6
;        I_AM    DEVIOBUF,2              ; Buffer for I/O under file assignment
;        I_AM    EXITHOLD,DWORD

; Retro DOS 2.0 NASM modifications !!! (02/03/2018)
INBUF	 EQU	DATASEGMENT+0	; DATASEGMENT = DOSINIT addr (parag aligned)
CONBUF	 EQU	INBUF+128	; DATASEGMENT+128
TIMEBUF	 EQU	CONBUF+131	; DATASEGMENT+259
DEVIOBUF EQU	TIMEBUF+6	; DATASEGMENT+265
EXITHOLD EQU	DEVIOBUF+2	; DATASEGMENT+267

        ;PUBLIC  DevFCB
;DEVFCB	LABEL   BYTE	; Uses NAME1, NAME2, NAME3 combined
DEVFCB	EQU	EXITHOLD+4	; DATASEGMENT+271

; WARNING..  do not alter size or relative location of the following 4 items
; without first examining FCB_RENAME
        ;I_AM    NAME1,12                ; File name buffer
        ;I_AM    ATTRIB,BYTE
        ;I_AM    NAME2,13
        ;I_AM    NAME3,14

        ;I_AM    EXTFCB,BYTE
NAME1	EQU	EXITHOLD+4	; DATASEGMENT+271 ; File name buffer
ATTRIB	EQU	NAME1+12	; DATASEGMENT+283
NAME2	EQU	ATTRIB+1	; DATASEGMENT+284
NAME3	EQU	NAME2+13	; DATASEGMENT+297
EXTFCB  EQU	NAME3+14	; DATASEGMENT+311

; WARNING - the following two items are accessed as a word
        ;I_AM    CREATING,BYTE
        ;I_AM    DELALL,BYTE
CREATING EQU	EXTFCB+1	; DATASEGMENT+312 
DELALL	EQU	CREATING+1	; DATASEGMENT+313 	

        ;I_AM    FoundDel,BYTE
FOUNDDEL EQU	DELALL+1	; DATASEGMENT+314	

        ;I_AM    user_SP,WORD
        ;I_AM    user_SS,WORD
        ;I_AM    CONTSTK,WORD
        ;I_AM    SECCLUSPOS,BYTE	; Position of first sector 
				 	; within cluster
        ;I_AM    DSKERR,BYTE
        ;I_AM    TRANS,BYTE
        ;I_AM    READOP,BYTE
        ;I_AM    THISDRV,BYTE
        ;I_AM    THISDPB,DWORD
        ;I_AM    CLUSFAC,BYTE

user_SP	EQU	FOUNDDEL+1	; DATASEGMENT+315		
user_SS	EQU	user_SP+2	; DATASEGMENT+317 
CONTSTK	EQU	user_SS+2	; DATASEGMENT+319 
SECCLUSPOS EQU	CONTSTK+2	; DATASEGMENT+321 
DSKERR	EQU	SECCLUSPOS+1	; DATASEGMENT+322 
TRANS	EQU	DSKERR+1	; DATASEGMENT+323 
READOP	EQU	TRANS+1		; DATASEGMENT+324 
THISDRV	EQU	READOP+1	; DATASEGMENT+325 
THISDPB	EQU	THISDRV+1	; DATASEGMENT+326 
CLUSFAC	EQU	THISDPB+4	; DATASEGMENT+330 

; WARNING - the following two items are accessed as a word
        ;I_AM    DRIVESPEC,BYTE
        ;I_AM    ROOTSTART,BYTE
DRIVESPEC EQU	CLUSFAC+1	; DATASEGMENT+331	
ROOTSTART EQU	DRIVESPEC+1	; DATASEGMENT+332 

        ;I_AM    CLUSSPLIT,BYTE
        ;i_am    INSMODE,BYTE
        ;I_AM    CLUSSAVE,WORD
        ;I_AM    CLUSSEC,WORD
        ;I_AM    PREREAD,WORD		; 0 means preread; 1 means optional
        ;I_AM    FATBYT,WORD
        ;I_AM    DEVPT,DWORD
        ;I_AM    THISFCB,DWORD		; Address of user FCB

CLUSSPLIT EQU	ROOTSTART+1  	; DATASEGMENT+333 
INSMODE	EQU	CLUSSPLIT+1	; DATASEGMENT+334	
CLUSSAVE EQU	INSMODE+1	; DATASEGMENT+335	
CLUSSEC	EQU	CLUSSAVE+2	; DATASEGMENT+337	
PREREAD	EQU	CLUSSEC+2	; DATASEGMENT+339 ; 0 means preread; 1 means optional
FATBYT	EQU	PREREAD+2	; DATASEGMENT+341	
DEVPT	EQU	FATBYT+2	; DATASEGMENT+343 
THISFCB	EQU	DEVPT+4		; DATASEGMENT+347 ; Address of user FCB  

        ;I_AM    NEXTADD,WORD
        ;I_AM    RECPOS,4
        ;I_AM    RECCNT,WORD
        ;I_AM    LASTPOS,WORD
        ;I_AM    CLUSNUM,WORD
        ;I_AM    DIRSEC,WORD
        ;I_AM    DIRSTART,WORD
        ;I_AM    SECPOS,WORD		; Position of first sector accessed
        ;I_AM    VALSEC,WORD		; Number of valid (previously written)
	;				; sectors

NEXTADD	EQU 	THISFCB+4	; DATASEGMENT+351
RECPOS	EQU	NEXTADD+2	; DATASEGMENT+353
RECCNT	EQU	RECPOS+4	; DATASEGMENT+357 
LASTPOS	EQU	RECCNT+2	; DATASEGMENT+359 
CLUSNUM	EQU	LASTPOS+2	; DATASEGMENT+361	
DIRSEC	EQU	CLUSNUM+2	; DATASEGMENT+363	
DIRSTART EQU	DIRSEC+2	; DATASEGMENT+365 
SECPOS	EQU	DIRSTART+2 	; DATASEGMENT+367 ; Position of first sector accessed
VALSEC	EQU	SECPOS+2	; DATASEGMENT+369 ; SECPOS+2 ; Number of valid
						  	     ; (previously written)
	;						     ; sectors

        ;I_AM    BYTSECPOS,WORD		; Position of first byte within sector
        ;I_AM    BYTPOS,4		; Byte position in file of access
        ;I_AM    BYTCNT1,WORD		; No. of bytes in first sector
        ;I_AM    BYTCNT2,WORD		; No. of bytes in last sector
        ;I_AM    SECCNT,WORD		; No. of whole sectors
        ;I_AM    ENTFREE,WORD
        ;I_AM    ENTLAST,WORD
        ;I_AM    NXTCLUSNUM,WORD
        ;I_AM    GROWCNT,DWORD
        ;I_AM    CURBUF,DWORD
        ;I_AM    VOLID,BYTE
        ;I_AM    NULLDEVPT,DWORD
        ;I_AM    CINSAV,DWORD
        ;I_AM    CINDSAV,BYTE
        ;I_AM    COUTDSAV,BYTE
        ;I_AM    COUTSAV,DWORD

BYTSECPOS EQU	VALSEC+2 	; DATASEGMENT+371 ; Position of first byte within sector
BYTPOS	EQU	BYTSECPOS+2	; DATASEGMENT+373 ; Byte position in file of access
BYTCNT1	EQU	BYTPOS+4 	; DATASEGMENT+377 ; No. of bytes in first sector
BYTCNT2	EQU	BYTCNT1+2 	; DATASEGMENT+379 ; No. of bytes in last sector
SECCNT	EQU	BYTCNT2+2 	; DATASEGMENT+381 ; No. of whole sectors
ENTFREE	EQU	SECCNT+2	; DATASEGMENT+383	
ENTLAST	EQU	ENTFREE+2	; DATASEGMENT+385	
NXTCLUSNUM EQU	ENTLAST+2	; DATASEGMENT+387	
GROWCNT	EQU	NXTCLUSNUM+2	; DATASEGMENT+389	
CURBUF	EQU	GROWCNT+4	; DATASEGMENT+393	
VOLID	EQU	CURBUF+4	; DATASEGMENT+397	
NULLDEVPT EQU	VOLID+1		; DATASEGMENT+398	
CINSAV	EQU	NULLDEVPT+4	; DATASEGMENT+402	
CINDSAV EQU	CINSAV+4	; DATASEGMENT+406	
COUTDSAV EQU	CINDSAV+1	; DATASEGMENT+407	
COUTSAV EQU	COUTDSAV+1	; DATASEGMENT+408 
        
	;PUBLIC  SaveBX
SaveBX	EQU	COUTSAV+4 	; DATASEGMENT+412 ; DW ?
        ;PUBLIC  SaveDS
SaveDS  EQU	SaveBX+2  	; DATASEGMENT+414 ; DW ?
        ;I_AM    ConC_spsave,WORD
ConC_spsave EQU	SaveDS+2	; DATASEGMENT+416 

        ;I_AM    exit_code,WORD		; exit code of last proc.
        ;I_am    exit_type,BYTE		; type of exit...
exit_code EQU	ConC_spsave+2	; DATASEGMENT+418 
exit_type EQU	exit_code+2	; DATASEGMENT+420 

;       IF      IBM
;;For 2.00 this pads the DOS so that on a 2 disk IBM PC with no
;;CONFIG.SYS file the space taken up by BIOS, DOS, res COMMAND is
;;about 24K
;IBMPAD  DB      540h DUP(?)
;       ENDIF

; make those pushes fast!!!
;EVEN
        ;DB      0A0H DUP (?)
        ;I_am    AuxStack,0A0h
        ;I_AM    DSKSTACK,0A0h		; Stack space
AUXSTACK EQU	exit_type+2+160	; DATASEGMENT+422+160
DSKSTACK EQU	AUXSTACK+160	; DATASEGMENT+742

	;PUBLIC  IOSTACK
;IOSTACK LABEL   BYTE
IOSTACK EQU	DSKSTACK+160	; DATASEGMENT+902	

        ;PUBLIC  NSS
;NSS         DW      ?
;        PUBLIC  NSP
;NSP         DW      ?
NSS	EQU	IOSTACK+0	; DATASEGMENT+902
NSP	EQU	NSS+2		; DATASEGMENT+904


;============================================================================
; XENIX.ASM
;============================================================================
; 02/04/2018

;DATA        SEGMENT BYTE PUBLIC 'DATA'
;
;open_name   DW  ?
;            DW  ?
;open_access DB  ?
;open_jfn    DW  ?                       ; accessed as DD
;open_jfn_b  DW  ?                       ; accessed as DD with above
;open_sfn    DW  ?
;open_sfoff  DW  ?                       ; accessed as DD
;open_sfn_b  DW  ?                       ; accessed as DD with above
;open_devid  DB  ?
;Cr_read_only    DB  ?
;rename_source   DD  ?
;rename_dest     DD  ?
;
;DATA        ENDS

open_name    equ NSP+2		; DATASEGMENT+906
open_access  equ open_name+4	; DATASEGMENT+910
open_jfn     equ open_access+1	; DATASEGMENT+911
open_jfn_b   equ open_jfn+2	; DATASEGMENT+913
open_sfn     equ open_jfn_b+2	; DATASEGMENT+915
open_sfoff   equ open_sfn+2	; DATASEGMENT+917
open_sfn_b   equ open_sfoff+2	; DATASEGMENT+919
open_devid   equ open_sfn_b+2	; DATASEGMENT+921
Cr_read_only equ open_devid+1	; DATASEGMENT+922
rename_source equ Cr_read_only+1 ; DATASEGMENT+923
rename_dest  equ rename_source+4 ; DATASEGMENT+927
;		

;============================================================================
; XENIX2.ASM
;============================================================================
; 02/04/2018

;DATA        SEGMENT BYTE PUBLIC 'DATA'

;PushSave    DW      ?
;PushES      DW      ?
;PushBX      DW      ?
;xenix_count DW      ?

;DATA	ENDS

;align 2

; 15/04/2018

PushSave     equ rename_dest+4	; DATASEGMENT+932
PushES:      equ PushSave+2	; DATASEGMENT+934
PushBX:      equ PushES+2	; DATASEGMENT+936
xenix_count  equ PushBX+2	; DATASEGMENT+938

; 16/04/2018
;sf_default_number equ 5
;sf_entry_size equ SF_ENTRY.size ; 40
				

; *****	; Total uninitialized data (segment) size = 940 bytes ; *****
; !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

;============================================================================
; MSHEAD.ASM
;============================================================================

[BITS 16]
[ORG 0]

START:
        JMP     DOSINIT

;============================================================================
; MSDATA.ASM
;============================================================================

;SUBTTL Initialized data and data used at DOS initialization
;PAGE

; DATA AREA for MS-DOS

;IFNDEF  KANJI
;KANJI   EQU     0       ;FALSE
;ENDIF

;CONSTANTS       SEGMENT BYTE PUBLIC 'CONST'
;        EXTRN   international_table:BYTE
;        EXTRN   Current_Country:WORD

;	ORG     0

;CONSTRT EQU	$		; Start of constants segment

;       PUBLIC  DevStrLen
DEVSTRLEN:
	DB	3		; Size of below
;	PUBLIC  DevString
DEVSTRING:
	DB	"DEV"		; Dummy device directory

;
; Table of routines for assignable devices
;
; MSDOS allows assignment if the following standard devices:
;   stdin  (usually CON input)
;   stdout (usually CON output)
;   auxin  (usually AUX input)
;   auxout (usually AUX output)
;   stdlpt (usually PRN output)
;
; SPECIAL NOTE:
;   Status of a file is a strange idea.  We choose to handle it in this manner:
;   If we're not at end-of-file, then we always say that we have a character.
;   Otherwise, we return ^Z as the character and set the ZERO flag.  In this
;   manner we can support program written under the old DOS (they use ^Z as EOF
;   on devices) and programs written under the new DOS (they use the ZERO flag
;   as EOF).

; Default FCBs for boot up

;sf_entry_size equ SF_ENTRY.size

SFTABL:	   ; LABEL   DWORD		; file table
		DW -1
		DW -1
		DW  sf_default_number  ; Number of entries in table
		times (sf_default_number*sf_entry_size) db 0

NoSetDir:	db  0			; true -> do not set directory
DidCTRLC:	db  0			; true -> we did a ^C exit
SpaceFlag:	db  0			; true -> embedded spaces are allowed
                                        ; in FCB
; the next two variables relate to the position of the logical stdout/stdin
; cursor.  They are only meaningful when stdin/stdout are assigned to the
; console.

CARPOS:		db  0			; cursor position in stdin
STARTPOS:	db  0			; position of cursor at beginning
                                        ; of buffered input call
PFLAG:		db  0
VERFLG:		db  0			; Initialize with verify off
CONTPOS:	dw  0
        ; PUBLIC  CHARCO
CHARCO:		db 00000011b		; Allows statchks every 4 chars...

        ;I_AM    DMAADD,DWORD 
DMAADD:		dw  80H			; User's disk transfer address
                dw  0			; (disp/seg)
            ;ORG     $-CONSTRT-4
            ;DW      80H
            ;DW      ?

ENDMEM:		dw  0

            ;PUBLIC  switch_character
switch_character: 
		DB  '/'

            ;PUBLIC  device_availability
device_availability:
		DB  0FFH

            ;I_AM    FirstArena,WORD        
FirstArena:	dw 0			; first free block found
BestArena:	dw 0			; best free block found
LastArena:	dw 0			; last free block found
AllocMethod:	db 0		        ; how to alloc first(best)last
arena_head:	dw 0

; ****************************************************************************
; NOTE: INT 21H AH=52H !  (http://stanislavs.org/helppc/int_21-52.html)
; ****************************************************************************
; INT 21,52 - Get Pointer to DOS "INVARS" (Undocumented)
;
;	AH = 52h
;
;	on return:
;	ES:BX = pointer to DOS "invars", a table of pointers used by DOS.
;		Known "invars" fields follow (varies with DOS version):
;
;	Offset Size		 Description
;
;	 -12   word   sharing retry count (DOS 3.1-3.3)
;	 -10   word   sharing retry delay  (DOS 3.1-3.3)
;	  -8   dword  pointer to current disk buffer (DOS 3.x)
;	  -4   word   pointer in DOS code segment of unread CON input;
;		      0 indicates no unread input (DOS 3.x)
;	  -2   word   segment of first Memory Control Block (MCB)
;	  00   dword  pointer to first DRIVE PARAMETER TABLE (A:) in chain
;	  04   dword  pointer to DOS System File Table (SFT)
;	  08   dword  pointer to $CLOCK device driver
;	  0C   dword  pointer to CON device driver
;	  10   byte   number of logical drives in system
;	  11   word   maximum bytes/block of any block device
;	  13   dword  pointer to DOS cache buffer header
;	  17 18bytes  NUL device header, first 4 bytes of device header
;		      point to the next device in device chain
;
; ****************************************************************************

; The following block of data is used by SYSINIT.  Do not change the order or
; size of this block

            ;PUBLIC  SYSINITVAR

SYSINITVAR:	; LABEL   WORD
        ;I_AM	DPBHEAD,DWORD           
DPBHEAD:	dd	0		; Pointer to head of DPB-FAT list
        ;I_AM    sft_addr,DWORD      
SFT_ADDR:	dw	SFTABL		; Pointer to first FCB table
                dw	0  
	    ;ORG     $-CONSTRT-4
            ;short_addr  SFTABL
            ;DW      ?                   ; DOS segment set at INIT

; The following address points to the CLOCK device
BCLOCK:		dd	0
; The following address is used by DISKSTATCHK it is always points to the
; console input device header
BCON:		dd	0		; Console device entry points
NUMIO:		db	0		; Number of disk tables
MAXSEC:		dw 	0		; Maximum allowed sector size
BUFFHEAD:	dd	0		; Pointer to head of buffer queue
DEVHEAD:	; LABEL   DWORD	
NULDEV:		dd	0		; Set to list start passed by 
					; BIOS at DOS Init
		dw	DEVTYP | ISNULL	; DEVTYP OR ISNULL	
		dw	SNULDEV
        	dw	INULDEV
        	db	"NUL     "
; ---
        ;i_am    DAY,BYTE
DAY:		DB  0		
MONTH:		DB  0
YEAR:		DW  0
DAYCNT:		DW  -1
WEEKDAY:	DB  0
	;ORG     $-CONSTRT-7
        ;DB      0,0
        ;DW      0,-1
        ;DB      0

CURDRV:		DB  0			; Default to drive A
LASTENT:	DW  0
INDOS:		DB  0			; DOS status for interrupt processing
            ;ORG     $-CONSTRT-1
            ;DB      0
ERRORMODE:	DB  0			; Flag for INT 24 processing
        ;PUBLIC  WPErr
WPERR:		DB  -1			; Write protect error flag
CONSWAP:	DB  0
        ;PUBLIC  IDLEINT
IDLEINT:	DB  1
        ;PUBLIC  CNTCFLAG
CNTCFLAG:	DB  0			; ^C check in dispatch disabled

        ;PUBLIC  LastBuffer
LASTBUFFER:	;  LABEL   DWORD	; Buffer queue recency pointer
		DW	-1
		DW	-1

; Combination of all device call parameters

; 29/03/2018
        ;PUBLIC  DEVCALL
;DEVCALL SRHEAD  <>			; (Structure variable)
DEVCALL:
DEVCALL_REQLEN:	 db	0		;Length in bytes of request block	
DEVCALL_REQUNIT: db	0		;Device unit number
DEVCALL_REQFUNC: db	0		;Type of request
DEVCALL_REQSTAT: dw	0		;Status Word
		 times	8 db 0		;Reserved for queue links	

CALLUNIT:	; LABEL   BYTE
CALLFLSH:	; LABEL   WORD
	;I_AM    CALLMED,BYTE
CALLMED:	db	0
CALLBR:		; LABEL   DWORD
        ;PUBLIC  CALLXAD
;CALLXAD     LABEL   DWORD
CALLXAD:
        ;I_AM    CALLRBYT,BYTE
CALLRBYT:	db	0        
		times	3 db 0
        ;PUBLIC CallBPB
CALLBPB:	; LABEL   DWORD
        ;I_AM    CALLSCNT,WORD
CALLSCNT:	dw	0
CALLSSEC:	dw	0
        ;I_AM    CALLDEVAD,DWORD
CALLDEVAD:	dd	0		; stash for device entry point

; Same as above for I/O calls

; 29/03/2018
        ;PUBLIC  IOCall
;IOCALL  SRHEAD  <>			; (Structure variable)
IOCALL:
IOCALL_REQLEN:	db	0		;Length in bytes of request block	
IOCALL_REQUNIT:	db	0		;Device unit number
IOCALL_REQFUNC: db	0		;Type of request
IOCALL_REQSTAT: dw	0		;Status Word
		times	8 db 0		;Reserved for queue links
IOFLSH:		; LABEL   WORD
        ;PUBLIC  IORCHR
IORCHR:		; LABEL   BYTE
IOMED:		db	0
IOXAD:		dd	0
IOSCNT:		dw	0
IOSSEC:		dw	0

; Call struct for DSKSTATCHK
        ;PUBLIC  DSKSTCALL
DSKSTCALL:	DB	DRDNDHL
                DB	0
        ;PUBLIC  DSKSTCOM
DSKSTCOM:	DB	DEVRDND
DSKSTST:	DW	0
                TIMES	8 DB 0
DSKCHRET:	DB	0
	        DW	DEVIOBUF
                DW      0		; DOS segment set at Init
        ;PUBLIC  DSKSTCNT
DSKSTCNT:	DW      1
		DW      0

; ---
; Days in year
        ;i_am    YRTAB,8
	;ORG     $-CONSTRT-8

YRTAB:   
	DB	200,166			; Leap year
	DB	200,165
	DB	200,165
	DB	200,165


; Days of each month
        ;i_am    MONTAB,12
        ;ORG     $-CONSTRT-12
MONTAB:        
	DB      31                      ; January
february:
	DB	28 			; February--reset each 
					; time year changes
        DB      31                      ; March
        DB      30                      ; April
        DB      31                      ; May
        DB      30                      ; June
        DB      31                      ; July
        DB      31                      ; August
        DB      30                      ; September
        DB      31                      ; October
        DB      30                      ; November
        DB      31                      ; December

        ;IF      NOT IBM
        ;PUBLIC  OEM_HANDLER
OEM_HANDLER     DD  -1
        ;ENDIF

;WARNING For HIGHMEM version, these two vars must be at the end of the
; Constants segment to prevent them getting overwritten.
        ;I_AM    CurrentPDB,WORD
        ;i_am    CreatePDB,BYTE
CurrentPDB:	dw 0
CreatePDB:	db 0			; flag for creating a process

        ;PUBLIC  LEAVEADDR
align 2
LEAVEADDR:	; LABEL WORD
        ;short_addr    _LEAVE
	dw	_LEAVE

;CONSTANTS       ENDS

;============================================================================
; DOSMES.ASM
;============================================================================
; 02/04/2018

;CONSTANTS	SEGMENT BYTE PUBLIC 'CONST'

DIVMES:
	DB      13,10,"Divide overflow",13,10
DivMesLen:
	DB	$-DIVMES	; Length of the above message in bytes

;
; The next variable points to the country table for the current country
;       ( the table returned by the AL=0 INTERNATIONAL call).
;

Current_Country:
	DW	USTABLE
;
; The international table(s).
; This is simply a sequence of tables of the following form:
;
;               BYTE  Size of this table excluding this byte and the next
;               BYTE  Country code represented by this table
;	                A sequence of n bytes, where n is the number specified
;                       by the first byte above and is not > internat_block_max,
;                       in the correct order for being returned by the
;                       INTERNATIONAL call as follows:
;		WORD	Date format 0=mdy, 1=dmy, 2=ymd
;		5 BYTE	Currency symbol null terminated
;		2 BYTE	thousands separator null terminated
;		2 BYTE	Decimal point null terminated
;		2 BYTE	Date separator null terminated
;		2 BYTE	Time separator null terminated
;		1 BYTE	Bit field.  Currency format.
;			Bit 0.  =0 $ before #  =1 $ after #
;			Bit 1.	no. of spaces between # and $ (0 or 1)
;		1 BYTE	No. of significant decimal digits in currency
;		1 BYTE	Bit field.  Time format.
;			Bit 0.  =0 12 hour clock  =1 24 hour
;		WORD	Segment offset for address of case conversion routine
;		WORD	RESERVED.  Filled in by DOS.  Segment value for above routine
;		2 BYTE	Data list separator null terminated.
;                  NOTE: The segment part of the DWORD Map_call is set
;                       by the INTERNATIONAL call. Do not try to initialize
;                       it to anything meaningful.
;
; The list of tables is terminated by putting a byte of -1 after the last
;       table (a table with length -1).

international_table:
		
	db INTERNAT_BLOCK.size	; Size in bytes of this table
	db 1			; Country code
USTABLE:	; INTERNAT_BLOCK structure
	dW 0		; .Date_tim_format
	db '$',0,0,0,0	; .Currency_sym
	db ',',0	; .Thous_sep	
	db '.',0	; .Decimal_sep
	db '-',0	; .Date_sep
	db ':',0	; .Time_sep
	db 0		; .Bit_field
	db 2		; .Currency_cents
	db 0		; .Time_24
	dw MAP_DCASE,0	; .Map_call
	db ',',0	; .Data_sep

;	Tables for the IBM PC character set follow.  The values
;	associated with some of the currency symbols may change with
;	other character sets.  You may wish to add or delete country
;	entries.  NOTE: It is not a mistake that the JAPANESE entry
;	has different currency symbols for the KANJI and
;	non-KANJI versions.

	db INTERNAT_BLOCK.size	; Size in bytes of this table
	db 44			; Country code
UKTABLE:
	dW 1 ; Europe
	db 9Ch,0,0,0,0
	db ',',0
	db '.',0
	db '-',0
	db ':',0
	db 0
	db 2
	db 0
	dw MAP_DCASE,0
	db ',',0

	db INTERNAT_BLOCK.size	; Size in bytes of this table
	db 49			; Country code
GRMTABLE:
	dW 1
	db 'D','M',0,0,0
	db '.',0
	db ',',0
	db '.',0
	db '.',0
	db 3 ; bit 0 = 1 : Currency symbol last
	     ; bit 1 = 1 : space after currency symbol
	db 2
	db 1 ; 24 hour time		
	dW MAP_DCASE,0
	db ';',0

	db INTERNAT_BLOCK.size	; Size in bytes of this table
	db 33			; Country code
FRNTABLE:
	dW 1
	db 'F',0,0,0,0
	db ' ',0
	db ',',0
	db '/',0
	db ':',0
	db 3
	db 2
	db 1
	dw MAP_DCASE,0
	db ';',0

	db INTERNAT_BLOCK.size	; Size in bytes of this table
	db 81			; Country code
JAPTABLE:
	dW 2 ; Japan
	db 9DH,0,0,0,0
	db ',',0
	db '.',0
	db '-',0
	db ':',0
	db 0
	db 0
	db 1
	dw MAP_DCASE,0
	db ',',0

	DB  -1              ; End of tables

;CONSTANTS       ENDS

;04/05/2018
;============================================================================
; 	Retro DOS v2.0
;============================================================================
	db 	0
RETRODOSMSG:
	DB	13,10
	db	"Retro DOS v2.0 by Erdogan Tan [2018]"
	db	13,10,"$", 0 

;----------------------------------------------------------------------------

align 2

DATASEGMENT EQU $ ; 17/04/2018

;PAGE
;        INCLUDE MSINIT.ASM

; 31/03/2018

;============================================================================
; MSINIT.ASM
;============================================================================

; 15/04/2018 - Retro DOS v2.0 (DATA adaption for NASM)

; TITLE MSINIT.ASM -- MS-DOS INITIALIZATION CODE

;       ORG     0                       ; reset to beginning of data segment
; Init code below overlaps with data area

;INITBLOCK DB    110H DUP(0)     ; Allow for segment round up
INITBLOCK:	TIMES 272 DB 0

INITSP:		DW 0
INITSS:		DW 0
BUFFSTRT:	DW 0

;ASSUME  CS:DOSGROUP,DS:DOSGROUP,ES:DOSGROUP,SS:NOTHING
;
;        EXTRN   QUIT:NEAR,IRET:NEAR,ABSDRD:FAR,ABSDWRT:FAR
;        EXTRN   COMMAND:NEAR,CALL_ENTRY:NEAR
;        IF      NOT IBM
;        EXTRN   HEADER:BYTE
;        ENDIF

MOVDPB:
; This section of code is safe from being overwritten by block move
        ;MOV     SP,[CS:INITSP]
        ;MOV     SS,[CS:INITSS]
        ; 30/03/2018
	MOV     SP,[INITSP]
        MOV     SS,[INITSS]

	;REP	MOVS BYTE PTR [DI], [SI]
        REP     MOVSB
        CLD
        MOV     [ES:DMAADD+2],DX
        MOV     SI,[DPBHEAD]	; Address of first DPB
        MOV     [ES:DPBHEAD+2],ES
        MOV     [ES:SFT_ADDR+2],ES
        MOV     CL,[NUMIO]	; Number of DPBs
        XOR     CH,CH
SETFINDPB:
        MOV     [ES:SI+1AH],ES
        MOV     BYTE [ES:SI+17H],-1  ; Never accessed before
        ADD     SI,DPBSIZ       ; Point to next DPB
        LOOP    SETFINDPB
        SUB     SI,DPBSIZ
        MOV     WORD [ES:SI+1AH],-1
        MOV     DI,[BUFFSTRT]                   ; Set up one default buffer
        MOV     [ES:BUFFHEAD+2],ES
        MOV     [ES:BUFFHEAD],DI
        MOV     WORD [ES:DI+4],00FFH
        MOV     BYTE [ES:DI+6],FREEPRI
        MOV     WORD [ES:DI],-1
        MOV     WORD [ES:DI+2],-1
        PUSH    ES
        INC     DX			; Leave enough room for the ARENA
        MOV     BYTE [CreatePDB],0FFh	; create jfns and set CurrentPDB
        ;invoke $CREATE_PROCESS_DATA_BLOCK   ; Set up segment
	CALL	_$CREATE_PROCESS_DATA_BLOCK  ; 30/03/2018
        POP     ES
;
; set up memory arena
;SPECIAL NOTE FOR HIGHMEM VERSION
; At this point a process header has been built where the start of the 
; CONSTANTS segment as refed by CS is. From this point until the return 
; below be careful about references off of CS.
;
	; 13/04/2018 ; *
        ;PUSH	AX ; *
        ;MOV	AX,[CurrentPDB]
        MOV	AX,[CS:CurrentPDB] ; 15/03/2018
	MOV     [ES:CurrentPDB],AX	; Put it in the REAL location
        MOV     BYTE [ES:CreatePDB],0	; reset flag in REAL location
        DEC     AX
        MOV     [ES:arena_head],AX
        PUSH    DS
        MOV     DS,AX
        MOV     BYTE [ARENA.SIGNATURE],arena_signature_end
        MOV     WORD [ARENA.OWNER],arena_owner_system
        SUB     AX,[ES:ENDMEM]
        NEG     AX
        DEC     AX
        MOV     [ARENA.SIZE],AX
        POP     DS
        ;POP	AX ; *

        MOV     DI,SFTABL + SFT.SFT_TABLE   ; Point to sft 0
        MOV     AL,3
        STOSB           ; Adjust Refcount
	MOV     DI,SYSINITVAR  ; 16/03/2018
        RETF
	
	; 18/04/2018
FILL1	equ	$ - DATASEGMENT
; ---------------------------------------------------------------------------
	times (940-FILL1) db 0

;============================================================================
; MSCODE.ASM
;============================================================================

; Retro DOS v2.0 (NASM 2.11) source code modifications by Erdogan Tan
; 03/03/2018

;
; MSCODE.ASM -- MSDOS code
;

;INCLUDE DOSSEG.ASM
;INCLUDE STDSW.ASM

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;IFNDEF  KANJI
;KANJI   EQU     0       ; FALSE
;ENDIF

;IFNDEF  IBM
;IBM     EQU     0
;ENDIF

;IFNDEF  HIGHMEM
;HIGHMEM  EQU     0
;ENDIF

        ;i_need  USER_SP,WORD
        ;i_need  USER_SS,WORD
        ;i_need  SAVEDS,WORD
        ;i_need  SAVEBX,WORD
        ;i_need  INDOS,BYTE
        ;i_need  NSP,WORD
        ;i_need  NSS,WORD
        ;i_need  CURRENTPDB,WORD
        ;i_need  AUXSTACK,BYTE
        ;i_need  CONSWAP,BYTE
        ;i_need  IDLEINT,BYTE
        ;i_need  NOSETDIR,BYTE
        ;i_need  ERRORMODE,BYTE
        ;i_need  IOSTACK,BYTE
        ;i_need  WPERR,BYTE
        ;i_need  DSKSTACK,BYTE
        ;i_need  CNTCFLAG,BYTE
        ;i_need  LEAVEADDR,WORD
        ;i_need  NULLDEVPT,DWORD

        ;IF NOT IBM
        ;i_need  OEM_HANDLER,DWORD
        ;ENDIF

        ;EXTRN   DSKSTATCHK:NEAR,GETBP:NEAR,DSKREAD:NEAR,DSKWRITE:NEAR

; ----------------------------------------------------------------------------
; BREAK   <Copyright notice and version>
; ----------------------------------------------------------------------------

CODSTRT EQU     $

        ;IF      NOT IBM
        ;IF      NOT KANJI
        ;PUBLIC  HEADER
HEADER: DB      13,10,"Microsoft MS-DOS version "
        DB      DOS_MAJOR_VERSION + "0"
        DB      "."
        DB      (DOS_MINOR_VERSION / 10) + "0"
        ;DB	(DOS_MINOR_VERSION MOD 10) + "0"
        DB	(DOS_MINOR_VERSION % 10) + "0"
	;IF      HIGHMEM
        ;DB      "H"
        ;ENDIF
        ;ENDIF
;        IF      KANJI
;        PUBLIC  HEADER
;HEADER  DB      13,10,82h,"M"+1fh,82h,"i"+20h,82h,"c"+20h,82h,"r"+20h,82h,"o"+20h
;        DB      82h,"s"+20h,82h,"o"+20h,82h,"f"+20h,82h,"t"+20h
;        DB      81h,40h,82h,"M"+1fh,82h,"S"+1fh,81h,5dh+1fh
;        DB      82h,"D"+1fh,82h,"O"+1fh,82h,"S"+1fh,81h,40h
;        DB      82h,DOS_MAJOR_VERSION+"0"+1fh
;        DB      81h,25h+1fh
;        DB      82h,(DOS_MINOR_VERSION / 10)+"0"+1fh
;        DB      82h,(DOS_MINOR_VERSION MOD 10)+"0"+1fh
;        DB      94h,0c5h
;        ENDIF
        DB      13,10
        DB      "Copyright 1981,82,83 Microsoft Corp.",13,10,"$"
        ;ENDIF

; ----------------------------------------------------------------------------
; BREAK   <System call entry points and dispatcher>
; ----------------------------------------------------------------------------
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

        ;procedure   SYSTEM_CALL,NEAR
SYSTEM_CALL:
;entry	QUIT				; INT 20H entry point
QUIT:
        MOV     AH,0
        JMP     SHORT SAVREGS

COMMAND:				; CODE XREF: STATCHK:loc_2C53j
	;IF	NOT IBM
        CMP	AH,SET_OEM_HANDLER
        JB      SHORT NOTOEM
	; 18/07/2018
	je	_$SET_OEM_HANDLER	

	;
	; 20/04/2018
        ;JMP	_$SET_OEM_HANDLER

	; Retro DOS v2.0 - 20/04/2018
	CMP	AX, 0FFFFh
	;JNE	_$SET_OEM_HANDLER
	; 18/07/2018
	jne	DO_OEM_FUNC

	PUSHA
	MOV     SI,RETRODOSMSG
        ;CALL	OUTMES
wrdosmsg:
	mov	ah, 0Eh
	mov	bx, 7
wrdosmsg_nxt:
	cs	lodsb
	cmp	al, '$'
	je	short wrdosmsg_ok		
	int	10h
	jmp	short wrdosmsg_nxt
wrdosmsg_ok:
	POPA
	JMP	SHORT BADCALL 
	;

NOTOEM:
	;ENDIF

        CMP     AH,MAXCOM
        JBE     SHORT SAVREGS

BADCALL:
        MOV     AL,0
;entry	IRET
_IRET:
        IRET

; ---------------------------------------------------------------------------

;entry	CALL_ENTRY                      ; System call entry point and dispatcher
CALL_ENTRY:
        POP     AX                      ; IP from the long call at 5
        POP     AX                      ; Segment from the long call at 5
        ;POP	WORD [user_SP]		; IP from the CALL 5
        POP	WORD [CS:user_SP] ; 12/03/2018
	PUSHF                           ; Start re-ordering the stack
        CLI
        PUSH    AX                      ; Save segment
        ;PUSH	WORD [user_SP]		; Stack now ordered as if INT had been used
        PUSH	WORD [CS:user_SP] ; 12/03/2018
        CMP     CL,MAXCALL              ; This entry point doesn't get as many calls
        JA      SHORT BADCALL
        MOV     AH,CL
SAVREGS:
        CALL    save_world
        ;MOV	[SaveDS],DS
        ;MOV	[SaveBX],BX
        MOV	[CS:SaveDS],DS	; 12/03/2018
        MOV	[CS:SaveBX],BX	; 12/03/2018
        MOV     BX,CS
        MOV     DS,BX
;ASSUME  DS:DOSGROUP
        INC     BYTE [INDOS]		; Flag that we're in the DOS
        MOV     AX,[user_SP]
        MOV     [NSP],AX
        MOV     AX,[user_SS]
        MOV     [NSS],AX
        POP     AX
        PUSH    AX
        MOV     [user_SP],SP
        MOV     [user_SS],SS
;
; save user stack in his area for later returns (possibly from EXEC)
; Here comes multitasking!!!
;
        MOV     DS,[CurrentPDB]
        MOV     [PDB.USER_STACK],SP
        MOV     [PDB.USER_STACK+2],SS

        MOV     BX,CS                   ; no holes here.
        MOV     SS,BX
;ASSUME  SS:DOSGROUP

;entry	REDISP
REDISP:
        MOV     SP,AUXSTACK		; Enough stack for interrupts
        STI                             ; Stack OK now
        PUSH    CS
        POP     DS
        XOR     BH,BH
        MOV     [CONSWAP],BH
        MOV     BYTE [IDLEINT],1
        MOV     BYTE [NoSetDir],0	; set directories on search
        MOV     BL,AH
        SHL     BX,1
        CLD
        OR      AH,AH
        JZ      SHORT DSKROUT		; ABORT
        CMP     AH,12
        JBE     SHORT IOROUT		; Character I/O
        CMP     AH,GET_CURRENT_PDB      ; INT 24 needs GET,SET PDB
        JZ      SHORT IOROUT
        CMP     AH,SET_CURRENT_PDB
        JNZ     SHORT DSKROUT
IOROUT:
        CMP     BYTE [ERRORMODE],0
        JNZ     SHORT DISPCALL		; Stay on AUXSTACK if INT 24
        MOV     SP,IOSTACK
        JMP     SHORT DISPCALL

DSKROUT:
        MOV     BYTE [ERRORMODE],0	; Cannot make non 1-12 calls in
        MOV     BYTE [WPERR],-1		; error mode, so good place to
                                        ; make sure flags are reset
        MOV     SP,DSKSTACK
        TEST    BYTE [CNTCFLAG],-1
        JZ      SHORT DISPCALL
        PUSH    AX
        ;invoke	DSKSTATCHK
        CALL	DSKSTATCHK
	POP     AX
DISPCALL:
        PUSH    WORD [LEAVEADDR]
        PUSH	WORD [CS:BX+DISPATCH]
        ;PUSH	WORD [BX+DISPATCH]
        MOV     BX,[SaveBX]
        MOV     DS,[SaveDS]
;ASSUME	DS:NOTHING
        ;return
	RETN	

;entry LEAVE
_LEAVE:
;ASSUME	SS:NOTHING			; User routines may misbehave
        CLI
        ;DEC     BYTE [INDOS]
        ;MOV     SP,[user_SP]
        ;MOV     SS,[user_SS]
        ; 12/03/2018
	DEC     BYTE [CS:INDOS]
        MOV     SP,[CS:user_SP]
        MOV     SS,[CS:user_SS]
	MOV     BP,SP
	;MOV	[BP.user_AX],AL	
        ;MOV	[BP+user_env.user_AX],AL  ; user_env.user_AX = 0
        MOV     [BP],AL
	;MOV     AX,[NSP]
        ;MOV     [user_SP],AX
        ;MOV     AX,[NSS]
        ;MOV     [user_SS],AX
        ; 12/03/2018
	MOV     AX,[CS:NSP]
        MOV     [CS:user_SP],AX
        MOV     AX,[CS:NSS]
        MOV     [CS:user_SS],AX
	CALL    restore_world

        IRET

;SYSTEM_CALL ENDP

;
; restore_world restores all registers ('cept SS:SP, CS:IP, flags) from
; the stack prior to giving the user control
;
        ;ASSUME  DS:NOTHING,ES:NOTHING
;restore_tmp DW  ?
restore_tmp: 
	dw	0
        ;procedure restore_world,NEAR
restore_world:
        ;POP	WORD [restore_tmp] ; POP     restore_tmp
        POP	WORD [CS:restore_tmp] ; 12/03/2018
        POP     AX              ; PUSH    ES
        POP     BX              ; PUSH    DS
        POP     CX              ; PUSH    BP
        POP     DX              ; PUSH    DI
        POP     SI              ; PUSH    SI
        POP     DI              ; PUSH    DX
        POP     BP              ; PUSH    CX
        POP     DS              ; PUSH    BX
        POP     ES              ; PUSH    AX
world_ret:
        ;PUSH	WORD [restore_tmp] ; PUSH    restore_tmp
        PUSH	WORD [CS:restore_tmp] ; 12/03/2018
        ;return

	RETN

;restore_world   ENDP

;
; save_world saves complete registers on the stack
;
        ;procedure   save_world,NEAR
save_world:
        ;POP	WORD [restore_tmp] ; POP     restore_tmp
        POP	WORD [CS:restore_tmp] ; 12/03/2018
        PUSH    ES
        PUSH    DS
        PUSH    BP
        PUSH    DI
        PUSH    SI
        PUSH    DX
        PUSH    CX
        PUSH    BX
        PUSH    AX
        JMP     SHORT world_ret

;save_world      ENDP

;
; get_user_stack returns the user's stack (and hence registers) in DS:SI
;
        ;procedure   get_user_stack,NEAR
get_user_stack:
        ;LDS	SI,DWORD PTR [user_SP]
        ;LDS	SI, [user_SP]
        LDS	SI, [CS:user_SP] ; 12/03/2018
	;return
	RETN

;get_user_stack  ENDP

align 2

; ---------------------------------------------------------------------------
; Standard Functions
;DISPATCH    LABEL WORD
DISPATCH:
	%define short_addr dw  ; 03/03/2018 - Retro DOS v2.0
;.lall
        short_addr  _$ABORT			    ;  0      0
;.xall
        short_addr  _$STD_CON_INPUT		    ;  1      1
        short_addr  _$STD_CON_OUTPUT		    ;  2      2
        short_addr  _$STD_AUX_INPUT		    ;  3      3
        short_addr  _$STD_AUX_OUTPUT		    ;  4      4
        short_addr  _$STD_PRINTER_OUTPUT	    ;  5      5
        short_addr  _$RAW_CON_IO		    ;  6      6
        short_addr  _$RAW_CON_INPUT		    ;  7      7
        short_addr  _$STD_CON_INPUT_NO_ECHO	    ;  8      8
        short_addr  _$STD_CON_STRING_OUTPUT	    ;  9      9
        short_addr  _$STD_CON_STRING_INPUT	    ; 10      A
        short_addr  _$STD_CON_INPUT_STATUS	    ; 11      B
        short_addr  _$STD_CON_INPUT_FLUSH	    ; 12      C
        short_addr  _$DISK_RESET		    ; 13      D
        short_addr  _$SET_DEFAULT_DRIVE		    ; 14      E
        short_addr  _$FCB_OPEN			    ; 15      F
        short_addr  _$FCB_CLOSE			    ; 16     10
        short_addr  _$DIR_SEARCH_FIRST		    ; 17     11
        short_addr  _$DIR_SEARCH_NEXT		    ; 18     12
        short_addr  _$FCB_DELETE		    ; 19     13
        short_addr  _$FCB_SEQ_READ		    ; 20     14
        short_addr  _$FCB_SEQ_WRITE	            ; 21     15
        short_addr  _$FCB_CREATE		    ; 22     16
        short_addr  _$FCB_RENAME		    ; 23     17
        short_addr  _CPMFUNC			    ; 24     18
        short_addr  _$GET_DEFAULT_DRIVE		    ; 25     19
        short_addr  _$SET_DMA			    ; 26     1A

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SLEAZEFUNC		    ; 27     1B
        short_addr  _$SLEAZEFUNCDL		    ; 28     1C
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

        short_addr  _CPMFUNC			    ; 29     1D
        short_addr  _CPMFUNC			    ; 30     1E
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DEFAULT_DPB               ; 31     1F
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _CPMFUNC			    ; 32     20
        short_addr  _$FCB_RANDOM_READ               ; 33     21
        short_addr  _$FCB_RANDOM_WRITE              ; 34     22
        short_addr  _$GET_FCB_FILE_LENGTH	    ; 35     23
        short_addr  _$GET_FCB_POSITION		    ; 36     24
;MAXCALL = ($-DISPATCH)/2 - 1
MAXCALL EQU ($-DISPATCH)/2 - 1

; Extended Functions
        short_addr  _$SET_INTERRUPT_VECTOR	    ; 37     25
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$CREATE_PROCESS_DATA_BLOCK	    ; 38     26
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$FCB_RANDOM_READ_BLOCK	   ; 39     27
        short_addr  _$FCB_RANDOM_WRITE_BLOCK       ; 40     28
        short_addr  _$PARSE_FILE_DESCRIPTOR	   ; 41     29
        short_addr  _$GET_DATE                     ; 42     2A
        short_addr  _$SET_DATE                     ; 43     2B
        short_addr  _$GET_TIME                     ; 44     2C
        short_addr  _$SET_TIME                     ; 45     2D
        short_addr  _$SET_VERIFY_ON_WRITE          ; 46     2E

; Extended functionality group
        short_addr  _$GET_DMA                      ; 47     2F
        short_addr  _$GET_VERSION                  ; 48     30
        short_addr  _$KEEP_PROCESS		   ; 49     31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$GET_DPB			   ; 50     32
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$SET_CTRL_C_TRAPPING          ; 51     33
        short_addr  _$GET_INDOS_FLAG               ; 52     34
        short_addr  _$GET_INTERRUPT_VECTOR         ; 53     35
        short_addr  _$GET_DRIVE_FREESPACE          ; 54     36
        short_addr  _$CHAR_OPER                    ; 55     37
        short_addr  _$INTERNATIONAL                ; 56     38
; XENIX CALLS
;   Directory Group
        short_addr  _$MKDIR			   ; 57     39
        short_addr  _$RMDIR			   ; 58     3A
        short_addr  _$CHDIR			   ; 59     3B
;   File Group
        short_addr  _$CREAT			   ; 60     3C
        short_addr  _$OPEN			   ; 61     3D
        short_addr  _$CLOSE			   ; 62     3E
        short_addr  _$READ			   ; 63     3F
        short_addr  _$WRITE			   ; 64     40
        short_addr  _$UNLINK			   ; 65     41
        short_addr  _$LSEEK			   ; 66     42
        short_addr  _$CHMOD			   ; 67     43
        short_addr  _$IOCTL			   ; 68     44
        short_addr  _$DUP			   ; 69     45
        short_addr  _$DUP2			   ; 70     46
        short_addr  _$CURRENT_DIR		   ; 71     47
;    Memory Group
        short_addr  _$ALLOC			   ; 72     48
        short_addr  _$DEALLOC                      ; 73     49
        short_addr  _$SETBLOCK                     ; 74     4A
;    Process Group
        short_addr  _$EXEC			   ; 75     4B
        short_addr  _$EXIT			   ; 76     4C
        short_addr  _$WAIT			   ; 77     4D
        short_addr  _$FIND_FIRST		   ; 78     4E
;   Special Group
        short_addr  _$FIND_NEXT			   ; 79     4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$SET_CURRENT_PDB		   ; 80     50
        short_addr  _$GET_CURRENT_PDB              ; 81     51
        short_addr  _$GET_IN_VARS                  ; 82     52
        short_addr  _$SETDPB			   ; 83     53
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  $GET_VERIFY_ON_WRITE           ; 84     54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        short_addr  _$DUP_PDB                      ; 85     55
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
        short_addr  _$RENAME			   ; 86     56
        short_addr  _$FILE_TIMES                   ; 87     57
        short_addr  _$ALLOCOPER                    ; 88     58

;MAXCOM  = ($-DISPATCH)/2 - 1

MAXCOM  EQU ($-DISPATCH)/2 - 1

; ---------------------------------------------------------------------------

_CPMFUNC:
        XOR     AL,AL
        ;return
	RETN

; ---------------------------------------------------------------------------
_$SET_OEM_HANDLER:
	; 18/07/2018
;ASSUME  DS:NOTHING,ES:NOTHING
;
;; Inputs:
;;       User registers, User Stack, INTS disabled
;;       If CALL F8, DS:DX is new handler address
;; Function:
;;       Process OEM INT 21 extensions
;; Outputs:
;;       Jumps to OEM_HANDLER if appropriate
;
	;JNE     short DO_OEM_FUNC	; If above F8 try to jump to handler
	MOV     [CS:OEM_HANDLER],DX	; Set Handler
	MOV     [CS:OEM_HANDLER+2],DS
	IRET                            ; Quick return, Have altered no registers

DO_OEM_FUNC:
	CMP     WORD [CS:OEM_HANDLER],-1
	JNZ     short OEM_JMP
	JMP     BADCALL                 ; Handler not initialized

OEM_JMP:
	JMP     FAR [CS:OEM_HANDLER]

;       ENDIF
; ---------------------------------------------------------------------------
;ASSUME  SS:DOSGROUP
;
; $Set_current_PDB takes BX and sets it to be the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
       ;procedure   $SET_CURRENT_PDB,NEAR
_$SET_CURRENT_PDB:
        ;ASSUME  DS:NOTHING,SS:NOTHING
        ;MOV     [CurrentPDB],BX
        MOV     [CS:CurrentPDB],BX ; 12/03/2018
        ;return
	RETN
;$SET_CURRENT_PDB    ENDP
; ---------------------------------------------------------------------------
; $get_current_PDB returns in BX the current process
;   *** THIS FUNCTION CALL IS SUBJECT TO CHANGE!!! ***
;
        ;procedure $GET_CURRENT_PDB,NEAR
_$GET_CURRENT_PDB:
        ;ASSUME  DS:NOTHING,SS:NOTHING
        ;invoke  get_user_stack
	call	get_user_stack
        ;PUSH	 word [CurrentPDB]
        PUSH    word [CS:CurrentPDB] ; 12/03/2018
        ;POP	[SI.user_BX]
	pop	word [SI+2]
        ;return
	retn
;$GET_CURRENT_PDB    ENDP
;									   ;	
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;BREAK <NullDev -- Driver for null device>
        ;procedure   SNULDEV,FAR
SNULDEV:
;ASSUME DS:NOTHING,ES:NOTHING,SS:NOTHING
        ;MOV     [NULLDEVPT],BX
        ;MOV     [NULLDEVPT+2],ES
	; 12/03/2018
        MOV     [CS:NULLDEVPT],BX
        MOV     [CS:NULLDEVPT+2],ES
        ;return
	RETF	; ! FAR return !
;SNULDEV ENDP

; ---------------------------------------------------------------------------
        ;procedure   INULDEV,FAR
INULDEV:
        PUSH    ES
        PUSH    BX
        ;LES	BX,[NULLDEVPT]
        LES	BX, [CS:NULLDEVPT] ; 12/03/2018
	OR	WORD [ES:BX+3],STDON ; Set done bit
        POP     BX
        POP     ES
        ;return
	RETF	; ! FAR return !

;INULDEV ENDP

; ---------------------------------------------------------------------------

;BREAK <AbsDRD, AbsDWRT -- INT int_disk_read, int_disk_write handlers>>

        ;IF      IBM
;ERRIN:					; Codes returned by BIOS
        ;DB      2			; NO RESPONSE
        ;DB      6			; SEEK FAILURE
        ;DB      12			; GENERAL ERROR
        ;DB      4			; BAD CRC
        ;DB      8			; SECTOR NOT FOUND
        ;DB      0			; WRITE ATTEMPT ON WRITE-PROTECT DISK
;ERROUT:				; DISK ERRORS RETURNED FROM INT 25 and 26
        ;DB      80H			; NO RESPONSE
        ;DB      40H			; Seek failure
        ;DB      2			; Address Mark not found
        ;DB      8			; DMA OVERRUN
        ;DB      4			; SECTOR NOT FOUND
        ;DB      3			; WRITE ATTEMPT TO WRITE-PROTECT DISK

;NUMERR	EQU	$-ERROUT
        ;ENDIF

; ---------------------------------------------------------------------------
        ;procedure   ABSDRD,FAR
ABSDRD:
;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING
        CLI
        ;MOV     [user_SS],SS
        ;MOV     [user_SP],SP
	; 15/03/2018
        MOV	[CS:user_SS],SS
        MOV	[CS:user_SP],SP        
	PUSH    CS
        POP     SS
;ASSUME  SS:DOSGROUP
        MOV     SP,DSKSTACK
        ;INC     BYTE [INDOS]
        INC	BYTE [SS:INDOS]
	STI
        CLD
        PUSH    ES
        PUSH    DS
        PUSH    SS
        POP     DS
;ASSUME  DS:DOSGROUP
        ;invoke	GETBP
	CALL	GETBP
        POP     DS
;ASSUME  DS:NOTHING
        JC      SHORT ILEAVE
        ;invoke	DSKREAD
	CALL	DSKREAD
TLEAVE:
        JZ      SHORT ILEAVE

        ;IF	IBM
; Translate the error code to ancient 1.1 codes
        ;PUSH    ES
        ;PUSH    CS
        ;POP     ES
        ;XOR     AH,AH			; Nul error code
        ;MOV     CX,NUMERR		; Number of possible error conditions
        ;MOV     DI,ERRIN		; Point to error conditions
        ;REPNE   SCASB
        ;JNZ     SHORT LEAVECODE	; Not found
        ;MOV     AH,[ES:DI+NUMERR-1]	; Get translation
;LEAVECODE:
        ;POP     ES
        ;ENDIF

        STC
ILEAVE:
        POP     ES
        CLI
        ;DEC     BYTE [INDOS]
        ;15/03/2018
	DEC	BYTE [SS:INDOS]
	;MOV     SP,[user_SP]
        ;MOV     SS,[user_SS]
	MOV     SP,[SS:user_SP]
        MOV     SS,[SS:user_SS]
;ASSUME  SS:NOTHING
        STI
        ;return
	RETF   ; ! FAR return !

;ABSDRD	ENDP
; ---------------------------------------------------------------------------
        ;procedure   ABSDWRT,FAR
ABSDWRT:
;ASSUME	DS:NOTHING,ES:NOTHING,SS:NOTHING

        CLI
	; 15/03/2018
        ;MOV     [user_SS],SS
        ;MOV     [user_SP],SP
        MOV     [CS:user_SS],SS
        MOV     [CS:user_SP],SP
        PUSH    CS
        POP     SS
;ASSUME	SS:DOSGROUP
        ;MOV	SP,OFFSET DOSGROUP:DSKSTACK
        MOV	SP, DSKSTACK
	;INC	BYTE PTR [INDOS]
        INC	BYTE [SS:INDOS]
	STI
        CLD
        PUSH    ES
        PUSH    DS
        PUSH    SS
        POP     DS
;ASSUME  DS:DOSGROUP
        ;invoke	GETBP
        CALL	GETBP
	POP     DS
;ASSUME  DS:NOTHING
        JC      SHORT ILEAVE
        ;invoke DSKWRITE
        CALL	DSKWRITE
	JMP     SHORT TLEAVE

;ABSDWRT ENDP

; ---------------------------------------------------------------------------
        ;procedure   SYS_RETURN,NEAR
SYS_RETURN:        
	;ASSUME  DS:NOTHING,ES:NOTHING
        ;entry   SYS_RET_OK
SYS_RET_OK:        
	call    get_user_stack
        ;PUSH	[SI.user_F]
        PUSH	WORD [SI+16H]
	POPF
        CLC
        JMP     SHORT DO_RET

        ;entry   SYS_RET_ERR
SYS_RET_ERR:        
	XOR     AH,AH                   ; hack to allow for smaller error rets
        call    get_user_stack
        ;PUSH	[SI.user_F]
        PUSH	WORD [SI+16H]
        POPF
        STC
DO_RET:
        ;MOV	[SI.user_AX],AX         ; Really only sets AH
	;MOV	[SI+user_env.user_AX], AX ; user_env.user_AX = 0
	MOV	[SI], AX
        PUSHF
        ;POP	[SI.user_F]             ; dump on his flags
        POP	WORD [SI+16H]
	;return
	RETN

;SYS_RETURN  ENDP

;do_ext

;CODE    ENDS

;============================================================================
; DOSMES.ASM
;============================================================================
; Retro DOS v2.0 - 14/03/2018

;CODE	SEGMENT BYTE PUBLIC 'CODE'
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

;CASE MAPPER ROUTINE FOR 80H-FFH character range
;     ENTRY: AL = Character to map
;     EXIT:  AL = The converted character
; Alters no registers except AL and flags.
; The routine should do nothing to chars below 80H.
;
; Example:
MAP_DCASE:
	CMP     AL,80H
	JB	SHORT L_RET	;Map no chars below 80H ever
	CMP     AL,0A7H
	JA	SHORT L_RET	;This routine maps chars between 80H and A7H
	SUB	AL,80H		;Turn into index value
	PUSH	DS
	PUSH	BX
	PUSH	CS		;Move to DS
	POP	DS
	MOV	BX,_TABLE
	XLAT			;Get upper case character
	POP	BX
	POP	DS
L_RET:  
	RETF	; 02/04/2018

_TABLE:
	DB	80H,9AH,"E","A",8EH,"A",8FH,80H
	DB	"E","E","E","I","I","I",8EH,8FH
	DB	90H,92H,92H,"O",99H,"O","U","U"
	DB	"Y",99H,9AH,9BH,9CH,9DH,9EH,9FH
	DB	"A","I","O","U",0A5H,0A5H,0A6H,0A7H

;SUBTTL EDIT FUNCTION ASSIGNMENTS AND HEADERS

; The following two tables implement the current buffered input editing
; routines.  The tables are pairwise associated in reverse order for ease
; in indexing.  That is; The first entry in ESCTAB corresponds to the last
; entry in ESCFUNC, and the last entry in ESCTAB to the first entry in ESCFUNC.

ESCCHAR:
	DB	ESCCH		;Lead-in character for escape sequences
ESCTAB:
        DB      64		; Ctrl-Z - F6
        DB      77		; Copy one char - -->
        DB      59		; Copy one char - F1
        DB      83		; Skip one char - DEL
        DB      60		; Copy to char - F2
        DB      62		; Skip to char - F4
        DB      61		; Copy line - F3
        DB      61		; Kill line (no change to template ) - Not used
        DB      63		; Reedit line (new template) - F5
        DB      75		; Backspace - <--
        DB      82		; Enter insert mode - INS (toggle)
        DB      65		; Escape character - F7
        DB      65		; End of table
ESCEND:
ESCTABLEN EQU   ESCEND-ESCTAB

ESCFUNC:
	DW	GETCH               ; Ignore the escape sequence
	DW	TWOESC
	DW	ENTERINS
	DW	BACKSP
	DW	REEDIT
	DW	KILNEW
	DW	COPYLIN
	DW	SKIPSTR
	DW	COPYSTR
	DW	SKIPONE
	DW	COPYONE
	DW	COPYONE
	DW	CTRLZ

;
; OEMFunction key is expected to process a single function
;   key input from a device and dispatch to the proper
;   routines leaving all registers UNTOUCHED.
;
; Inputs:   CS, SS are DOSGROUP
; Outputs:  None. This function is expected to JMP to onw of
;           the following labels:
;
;           GetCh       - ignore the sequence
;           TwoEsc      - insert an ESCChar in the buffer
;           ExitIns     - toggle insert mode
;           EnterIns    - toggle insert mode
;           BackSp      - move backwards one space
;           ReEdit      - reedit the line with a new template
;           KilNew      - discard the current line and start from scratch
;           CopyLin     - copy the rest of the template into the line
;           SkipStr     - read the next character and skip to it in the template
;           CopyStr     - read next char and copy from template to line until char
;           SkipOne     - advance position in template one character
;           CopyOne     - copy next character in template into line
;           CtrlZ       - place a ^Z into the template
; Registers that are allowed to be modified by this function are:
;           AX, CX, BP

OEMFunctionKey:
	CALL	_$STD_CON_INPUT_NO_ECHO  ; Get the second byte of the sequence
	MOV     CL,ESCTABLEN ; 13	; length of table for scan
	PUSH    DI                      ; save DI (cannot change it!)
	MOV     DI,ESCTAB		; offset of second byte table
	REPNE   SCASB                   ; Look it up in the table
	POP     DI                      ; restore DI
	SHL     CX,1                    ; convert byte offset to word
	MOV     BP,CX                   ; move to indexable register
	;JMP	word [SS:BP+ESCFUNC]	; Go to the right routine
	jmp	word [BP+ESCFUNC] ; 16/04/2018

;CODE	ENDS
;
;	do_ext
;	END

;============================================================================
; MISC.ASM
;============================================================================
;TITLE MISC - Miscellanious routines for MS-DOS
;NAME  MISC
;
; Miscellaneous system calls most of which are CAVEAT
;
; $SLEAZEFUNC
; $SLEAZEFUNCDL
; $GET_INDOS_FLAG
; $GET_IN_VARS
; $GET_DEFAULT_DPB
; $GET_DPB
; $DISK_RESET
; $SETDPB
; $Dup_PDB
; $CREATE_PROCESS_DATA_BLOCK
; sti

;
;.xlist
;
; get the appropriate segment definitions
;
;INCLUDE DOSSEG.ASM
;
;CODE    SEGMENT BYTE PUBLIC  'CODE'
;        ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;ENTRYPOINTSEG	EQU	0CH
;MAXDIF		EQU	0FFFH
;SAVEXIT	EQU	10

; BREAK <SleazeFunc -- get a pointer to media byte>

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
        ;procedure   $SLEAZEFUNC,NEAR
;ASSUME  DS:NOTHING,ES:NOTHING
_$SLEAZEFUNC:

; Inputs:
;       None
; Function:
;       Return Stuff sort of like old get fat call
; Outputs:
;       DS:BX = Points to FAT ID byte (IBM only)
;               GOD help anyone who tries to do ANYTHING except
;               READ this ONE byte.
;       DX = Total Number of allocation units on disk
;       CX = Sector size
;       AL = Sectors per allocation unit
;          = -1 if bad drive specified

        MOV     DL,0
_$SLEAZEFUNCDL:
        PUSH    SS
        POP     DS
        MOV     AL,DL
        CALL	GETTHISDRV
        MOV     AL,-1
        JC      SHORT BADSLDRIVE
        CALL	FATREAD
        MOV     DX,[ES:BP+0DH]
        DEC     DX
        MOV     AL,[ES:BP+4]
        INC     AL
        MOV     CX,[ES:BP+2]
        ADD     BP,DPB.MEDIA
BADSLDRIVE:
        CALL	get_user_stack
        MOV     [SI+4],CX
        MOV     [SI+6],DX
        MOV     [SI+2],BP
        MOV     [SI+0EH],ES
	retn
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;BREAK <$ABORT -- Terminate a process>
        ;procedure   $ABORT,NEAR
_$ABORT:
;ASSUME  DS:NOTHING,ES:NOTHING

; Inputs:
;       CS:00 must point to valid program header block
; Function:
;       Restore terminate and Cntrl-C addresses, flush buffers
;       and transfer to the terminate address
; Returns:
;       TO THE TERMINATE ADDRESS

        XOR     AL,AL
        ;MOV     [exit_type],exit_abort
	MOV	BYTE [SS:exit_type],Exit_Abort  ; 12/03/2018
;
; abort_inner must have AL set as the exit code!
;
        ;entry   abort_inner
abort_inner:        
	;MOV     AH,[exit_type]
        MOV	AH,[SS:exit_type] ; 31/03/2018
	;MOV     [exit_code],AX
        MOV	[SS:exit_code],AX ; 12/03/2018
	;invoke Get_user_stack
        call	get_user_stack
	;MOV	DS,[SI.user_CS]		; set up old interrupts
        MOV	DS,[SI+14H]
	XOR     AX,AX
        MOV     ES,AX
        MOV     SI,SAVEXIT
        MOV     DI,addr_int_terminate
        MOVSW
        MOVSW
        MOVSW
        MOVSW
        MOVSW
        MOVSW
        ;transfer reset_environment
	jmp	reset_environment
;$ABORT   ENDP

; ---------------------------------------------------------------------------

;BREAK <$Dir_Search_First -- Start a directory search>

_$DIR_SEARCH_FIRST:

; Inputs:
;       DS:DX Points to unopenned FCB
; Function:
;       Directory is searched for first matching entry and the directory
;       entry is loaded at the disk transfer address
; Returns:
;       AL = -1 if no entries matched, otherwise 0

        CALL	GETFILE

SAVPLCE:
; Search-for-next enters here to save place and report
; findings.
        MOV     DL,0            ; Do not XOR!!!
        JC      SHORT KILLSRCH
        OR      AH,AH           ; Is it I/O device?
        JS      SHORT KILLIT	; If so, sign bit will end search
        MOV     AX,[LASTENT]
        INC     DL
KILLIT:
        MOV     [ES:DI+10H],AX
        MOV     AX,[THISDPB]
        MOV     [ES:DI+12H],AX
        MOV     AX,[THISDPB+2]
        MOV     [ES:DI+14H],AX
        MOV     AX,[DIRSTART]
        MOV     [ES:DI+16H],AX
; Information in directory entry must be copied into the first
; 33 bytes starting at the disk transfer address.
        MOV     SI,BX
        LES     DI,[DMAADD]
        MOV     AX,00FFH
        CMP     AL,[EXTFCB]
        JNZ     SHORT NORMFCB
        STOSW
        INC     AL
        STOSW
        STOSW
        MOV     AL,[ATTRIB]
        STOSB
NORMFCB:
        MOV     AL,[THISDRV]
        INC     AL
        STOSB   ; Set drive number
        OR      DL,DL
        JZ      SHORT DOSRELATIVE
        MOV     DS,[CURBUF+2]
DOSRELATIVE:
	MOV     CX,16

        REP     MOVSW   ; Copy 32 bytes of directory entry
        XOR     AL,AL
        RETN

KILLSRCH1:
        PUSH    DS
        POP     ES      ; Make ES:DI point to the FCB
KILLSRCH:
        MOV     AX,-1
        MOV     [ES:DI+10H],AX
        RETN

; ---------------------------------------------------------------------------

;BREAK <$Dir_Search_Next -- Find next matching directory entry>

_$DIR_SEARCH_NEXT:

; Inputs:
;       DS:DX points to unopenned FCB returned by $DIR_SEARCH_FIRST
; Function:
;       Directory is searched for the next matching entry and the directory
;       entry is loaded at the disk transfer address
; Returns:
;       AL = -1 if no entries matched, otherwise 0

        CALL	MOVNAMENOSET
        MOV     DI,DX
        JC      SHORT KILLSRCH1
        MOV     AX,[DI+10H]
        LES     BP,[DI+12H]
        OR      AX,AX
        JS      SHORT KILLSRCH1
        MOV     BX,[DI+16H]
        PUSH    DX
        PUSH    DS
        PUSH    AX
        ;MOV     [THISDPB],BP
        ;MOV     [THISDPB+2],ES
	MOV	[SS:THISDPB],BP		; 12/03/2018
        MOV	[SS:THISDPB+2],ES	; 12/03/2018
        CALL	SETDIRSRCH
        POP     AX
        MOV     WORD [ENTLAST],-1
        CALL	GETENT
        CALL	NEXTENT
        POP     ES
        POP     DI
        JMP     SAVPLCE

; ---------------------------------------------------------------------------

;BREAK <$Get_FCB_File_Length -- Return size of file in current records>

_$GET_FCB_FILE_LENGTH:

; Inputs:
;       DS:DX points to unopenned FCB
; Function:
;       Set random record field to size of file
; Returns:
;       AL = -1 if no entries matched, otherwise 0

        CALL	GETFILE
        MOV     AL,-1
        JC	SHORT RET14
        ADD     DI,SYS_FCB.RR	; Write size in RR field
        MOV     CX,[ES:DI-13H]
        OR      CX,CX
        JNZ     SHORT RECOK
        MOV     CX,128
RECOK:
        XOR     DX,DX           ; Intialize size to zero
        INC     SI
        INC     SI              ; Point to length field
        MOV     DS,[CURBUF+2]
        MOV     AX,[SI+2]       ; Get high word of size
        DIV     CX
        PUSH    AX              ; Save high part of result
        LODSW			; Get low word of size
        DIV     CX
        OR      DX,DX           ; Check for zero remainder
        POP     DX
        JZ	SHORT DEVSIZ
        INC     AX              ; Round up for partial record
        JNZ     SHORT DEVSIZ	; Propagate carry?
        INC     DX
DEVSIZ:
        STOSW
        MOV     AX,DX
        STOSB
        MOV     AL,0
        CMP     CX,64
        JAE     SHORT RET14	; Only 3-byte field if fcb_RECSIZ >= 64
        MOV     [ES:DI],AH
RET14:  
	RETN

; BREAK <$Get_Fcb_Position -- Set random record field to current position>
        ;procedure  $GET_FCB_POSITION,NEAR

; ---------------------------------------------------------------------------

_$GET_FCB_POSITION:

; Inputs:
;       DS:DX points to openned FCB
; Function:
;       Sets random record field to be same as current record fields
; Returns:
;       None

        CALL	GETREC
        MOV     [DI+21H],AX
        MOV     [DI+23H],DL
        CMP     WORD [DI+0EH],64
        JAE     SHORT RET16
        MOV     [DI+24H],DH	; Set 4th byte only if record size < 64
RET16:  
	RETN

; ---------------------------------------------------------------------------

;BREAK <$Disk_Reset -- Flush out all dirty buffers>
        ;procedure   $DISK_RESET,NEAR

_$DISK_RESET:

; Inputs:
;       None
; Function:
;       Flush and invalidate all buffers
; Returns:
;       Nothing

        PUSH    SS
        POP     DS
        MOV     AL,-1
        CALL	FLUSHBUF
        MOV     WORD [LASTBUFFER+2],-1
        MOV     WORD [LASTBUFFER],-1
        CALL	SETVISIT
NBFFR:					; Free ALL buffers
        MOV     BYTE [DI+7],1 ; Mark as visited
        CMP     BYTE [DI+4],-1
        JZ      SHORT SKPBF		; Save a call to PLACEBUF
        MOV     WORD [DI+4],00FFH
        CALL	SCANPLACE
SKPBF:
        CALL	SKIPVISIT
        JNZ     SHORT NBFFR
        RETN
; ---------------------------------------------------------------------------
        ;procedure   $RAW_CON_IO,NEAR   ; System call 6

_$RAW_CON_IO:

; Inputs:
;       DL = -1 if input
;       else DL is output character
; Function:
;       Input or output raw character from console, no echo
; Returns:
;       AL = character

        MOV     AL,DL
        CMP     AL,-1
        JNZ     SHORT RAWOUT
        ;LES     DI,[user_SP]	; Get pointer to register save area
        LES     DI,[SS:user_SP] ; 12/03/2018
	XOR     BX,BX
        CALL	GET_IO_FCB
        JC	SHORT RET17
        MOV     AH,1
        CALL	IOFUNC
        JNZ     SHORT RESFLG
        CALL	SPOOLINT
        OR      BYTE [ES:DI+16H],40H ; Set user's zero flag
        XOR     AL,AL
RET17:
        RETN

RESFLG:
        AND     BYTE [ES:DI+16H],0FFH-40H
					    ; Reset user's zero flag
RILP:
        CALL	SPOOLINT
    ;entry   $RAW_CON_INPUT        ; System call 7

_$RAW_CON_INPUT:

; Inputs:
;       None
; Function:
;       Input raw character from console, no echo
; Returns:
;       AL = character

        XOR     BX,BX
        CALL	GET_IO_FCB
        JC	SHORT RET17
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT RILP
        XOR     AH,AH
        CALL	IOFUNC
        RETN
;
;       Output the character in AL to stdout
;
;entry   RAWOUT
RAWOUT:
        PUSH    BX
        MOV     BX,1

        CALL	GET_IO_FCB
        JC      SHORT RAWRET1

        TEST    BYTE [SI+18H],080H	; output to file?
        JZ      SHORT RAWNORM			; if so, do normally
        PUSH    DS
        PUSH    SI
        LDS     SI,[SI+19H]   	; output to special?
        TEST    BYTE [SI+4],ISSPEC
        POP     SI
        POP     DS
        JZ      SHORT RAWNORM			; if not, do normally
        INT     int_fastcon                     ; quickly output the char
        JMP     SHORT RAWRET
RAWNORM:
        CALL    RAWOUT3
RAWRET: 
	CLC
RAWRET1:
        POP     BX
	RETN
;
;       Output the character in AL to handle in BX
;
;entry   RAWOUT2
RAWOUT2:
        CALL	GET_IO_FCB
        JC	SHORT RET18
RAWOUT3:
        PUSH    AX
        JMP     SHORT RAWOSTRT
ROLP:
        CALL	SPOOLINT
RAWOSTRT:
        MOV     AH,3
        CALL    IOFUNC
        JZ      SHORT ROLP
        POP     AX
        MOV     AH,2
        CALL    IOFUNC
        CLC                     ; Clear carry indicating successful
RET18:    
	RETN

; ---------------------------------------------------------------------------

; This routine is called at DOS init

        ;procedure   OUTMES,NEAR ; String output for internal messages
OUTMES:
        ;LODS	CS:BYTE PTR [SI]
        CS	LODSB
	CMP     AL,"$" ; 24h
        JZ	SHORT RET18
        CALL	OUTT
        JMP     SHORT OUTMES
        ;RETN

; ---------------------------------------------------------------------------

_$PARSE_FILE_DESCRIPTOR:

; Inputs:
;       DS:SI Points to a command line
;       ES:DI Points to an empty FCB
;       Bit 0 of AL = 1 At most one leading separator scanned off
;                   = 0 Parse stops if separator encountered
;       Bit 1 of AL = 1 If drive field blank in command line - leave FCB
;                   = 0  "    "    "     "         "      "  - put 0 in FCB
;       Bit 2 of AL = 1 If filename field blank - leave FCB
;                   = 0  "       "      "       - put blanks in FCB
;       Bit 3 of AL = 1 If extension field blank - leave FCB
;                   = 0  "       "      "        - put blanks in FCB
; Function:
;       Parse command line into FCB
; Returns:
;       AL = 1 if '*' or '?' in filename or extension, 0 otherwise
;       DS:SI points to first character after filename

        CALL	MAKEFCB
        PUSH    SI
        CALL	get_user_stack
        POP	WORD [SI+8]
        RETN

;BREAK <$Create_Process_Data_Block,SetMem -- Set up process data block>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
	;procedure   $Dup_PDB,NEAR
_$DUP_PDB:
        ;MOV     BYTE [CreatePDB],0FFH	; indicate a new process
	MOV     BYTE [SS:CreatePDB],0FFH ; 15/03/2018

        ;procedure   $CREATE_PROCESS_DATA_BLOCK,NEAR
;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING

_$CREATE_PROCESS_DATA_BLOCK:

; Inputs:
;       DX = Segment number of new base
; Function:
;       Set up program base and copy term and ^C from int area
; Returns:
;       None
; Called at DOS init

        MOV     ES,DX
        ;TEST    BYTE [CreatePDB],0FFh
        TEST	BYTE [CS:CreatePDB],0FFh ; 15/03/2018
	JZ      SHORT Create_PDB_old
        ;MOV     DS,[CurrentPDB]
        MOV     DS,[CS:CurrentPDB] ; 15/03/2018
        JMP     SHORT Create_copy

Create_PDB_old:
        CALL	get_user_stack
        MOV     DS,[SI+14H]

Create_copy:
        XOR     SI,SI                   ; copy all 80h bytes
        MOV     DI,SI
        MOV     CX,80H
        REP     MOVSW

        ;TEST    BYTE [CreatePDB],0FFh	; Shall we create a process?
        TEST    BYTE [CS:CreatePDB],0FFh
        JZ      SHORT Create_PDB_cont	; nope, old style call
;
; Here we set up for a new process...
;

        PUSH    CS
        POP     DS
        XOR     BX,BX                   ; dup all jfns
        MOV     CX,FILPERPROC

create_dup_jfn:
        PUSH    ES                      ; save new PDB
        CALL	get_jfn_pointer         ; ES:DI is jfn
        JC      SHORT create_skip	; not a valid jfn
        PUSH    ES                      ; save him
        PUSH    DI
        CALL	get_sf_from_jfn         ; get sf pointer
        JC      SHORT create_no_inc
        ;INC	BYTE [ES:DI+SF_ENTRY.sf_ref_count] ; new fh
        INC	BYTE [ES:DI]		; SF_ENTRY.sf_ref_count = 0

create_no_inc:
        POP     DI
        POP     ES			; get old jfn
        MOV     AL,[ES:DI]		; get sfn
        POP     ES
        PUSH    ES
        MOV     AL,[ES:BX]		; copy into new place!

create_skip:
        POP     ES
        INC     BX                      ; next jfn...
        LOOP    create_dup_jfn

        PUSH    word [CurrentPDB]	; get current process
        POP     BX
        PUSH    BX
        POP     word [ES:PDB.PARENT_PID] ; stash in child
        MOV     [CurrentPDB],ES
        MOV     DS,BX
;
; end of new process create
;
Create_PDB_cont:
        ;MOV     BYTE [CreatePDB],0h	; reset flag
        MOV	BYTE [CS:CreatePDB],0	; 15/03/2018
	MOV     AX,[2]			; set up size for fall through

;entry SETMEM
SETMEM:

; Inputs:
;       AX = Size of memory in paragraphs
;       DX = Segment
; Function:
;       Completely prepares a program base at the
;       specified segment.
; Called at DOS init
; Outputs:
;       DS = DX
;       ES = DX
;       [0] has INT int_abort
;       [2] = First unavailable segment ([ENDMEM])
;       [5] to [9] form a long call to the entry point
;       [10] to [13] have exit address (from int_terminate)
;       [14] to [17] have ctrl-C exit address (from int_ctrl_c)
;       [18] to [21] have fatal error address (from int_fatal_abort)
; DX,BP unchanged. All other registers destroyed.

        XOR     CX,CX
        MOV     DS,CX
        MOV     ES,DX
        MOV     SI,addr_int_terminate
        MOV     DI,SAVEXIT
        MOV     CX,6
        REP     MOVSW
        MOV     [ES:2],AX
        SUB     AX,DX
        CMP     AX,MAXDIF
        JBE     SHORT HAVDIF
        MOV     AX,MAXDIF
HAVDIF:
        MOV     BX,ENTRYPOINTSEG
        SUB     BX,AX
        MOV     CL,4
        SHL     AX,CL
        MOV     DS,DX
        MOV     WORD [PDB.CPM_CALL+1],AX
        MOV     WORD [PDB.CPM_CALL+3],BX
        MOV     WORD [PDB.EXIT_CALL],(int_abort*256) + mi_INT
        MOV     BYTE [PDB.CPM_CALL],mi_Long_CALL
        MOV     WORD [PDB.CALL_SYSTEM],(int_command*256) + mi_INT
        MOV     BYTE [PDB.CALL_SYSTEM+2],mi_Long_RET
        RETN

;$CREATE_PROCESS_DATA_BLOCK ENDP
;	do_ext

;CODE   ENDS
;       END

;============================================================================
; GETSET.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

;TITLE	GETSET - GETting and SETting MS-DOS system calls
;NAME	GETSET

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

USERNUM:
	DW	0			; 24 bit user number
        DB      0
;	IF      IBM
;OEMNUM: DB      0			; 8 bit OEM number
;	ELSE
OEMNUM:	DB      0FFH			; 8 bit OEM number
;	ENDIF

MSVERS:				; MS-DOS version in hex for $GET_VERSION
MSMAJOR: DB	DOS_MAJOR_VERSION
MSMINOR: DB	DOS_MINOR_VERSION


;BREAK <$Get_Version -- Return MSDOS version number>

_$GET_VERSION:

; Inputs:
;       None
; Function:
;       Return MS-DOS version number
; Outputs:
;       OEM number in BH
;       User number in BL:CX (24 bits)
;       Version number as AL.AH in binary
;       NOTE: On pre 1.28 DOSs AL will be zero

        PUSH    SS
        POP     DS
        MOV     BX,[USERNUM+2]
        MOV     CX,[USERNUM]
        MOV     AX,[MSVERS]
        call	get_user_stack
        MOV     [SI+2],BX
        MOV     [SI+4],CX
        ;MOV	[SI+user_env.user_AX],AX  ; Really only sets AH
        MOV	[SI],AX ; 31/03/2018
	RETN

;BREAK <$International - return country-dependent information>

;
; Inputs:
;       DS:DX point to a block
; Function:
;       give users an idea of what country the application is running
; Outputs:
;       AX = number of bytes transferred
;       DS:DX ->+---------------------------------+
;               | WORD Date/time format           |
;               +---------------------------------+
;               | BYTE ASCIZ currency symbol      |
;               +---------------------------------+
;               | BYTE ASCIZ thousands separator  |
;               +---------------------------------+
;               | BYTE ASCIZ decimal separator    |
;               +---------------------------------+

_$INTERNATIONAL:

        MOV     BL,AL
        PUSH    DS
        POP     ES
        PUSH    DX
        POP     DI
        PUSH    SS
        POP     DS
        CMP     DI,-1
        JZ	SHORT international_set
        OR      BL,BL
        JNZ	SHORT international_find
        MOV     SI,[Current_Country]
        MOV     AX,[SI-2]		; Get size in AL, country code in AH
        MOV     BL,AH			; Set country code
        JMP     SHORT international_copy

international_find:
        CALL    international_get
        JNC	SHORT international_copy
        ;error	country_not_found
	MOV	AL,country_not_found
	jmp	SYS_RET_ERR

international_get:
        MOV     SI,international_table
international_next:
        LODSW                           ; Get size in AL, country code in AH
        CMP     AL,-1
        JNZ     SHORT check_code
        STC
RET35:
        RETN

check_code:
        CMP     BL,AH
        JZ      SHORT RET35		; Carry clear
        XOR     AH,AH
        ADD     SI,AX
        JMP     SHORT international_next

international_copy:
        MOV     CL,AL
        XOR     CH,CH
        PUSH    DI
        REP     MOVSB
        POP     DI
        MOV     [ES:DI+14H],CS   
					; Set segment for case map call
international_ok:
        XOR     AX,AX
        MOV     AL,BL           ; Return country code in AX
	JMP	SYS_RET_OK

international_set:
        CALL    international_get
        JNC	SHORT international_store
        ;error	country_not_found
	MOV	AL,country_not_found
	jmp	SYS_RET_ERR

international_store:
        MOV     [Current_Country],SI
        JMP     SHORT international_ok

;BREAK <$Get_Verify_on_Write - return verify-after-write flag>

_$GET_VERIFY_ON_WRITE:

; Inputs:
;       none.
; Function:
;       returns flag
; Returns:
;       AL = value of VERIFY flag

        ;MOV	AL,[VERFLG]
	MOV	AL,[SS:VERFLG]	; Retro DOS v2.0 - 12/03/2018
        RETN

;BREAK <$Set_Verify_on_Write - Toggle verify-after-write flag>

_$SET_VERIFY_ON_WRITE:

; Inputs:
;       AL = desired value of VERIFY flag
; Function:
;       Sets flag
; Returns:
;       None

        AND     AL,1
        ;MOV	[VERFLG],AL
        MOV	[SS:VERFLG],AL ; Retro DOS v2.0 - 12/03/2018
	RETN

;BREAK <$Set_CTRL_C_Trapping -- En/Disable ^C check in dispatcher>

_$SET_CTRL_C_TRAPPING:

; Inputs:
;       AL = 0 read ^C status
;       AL = 1 Set ^C status, DL = 0/1 for ^C off/on
; Function:
;       Enable disable ^C checking in dispatcher
; Outputs:
;       If AL = 0 then DL = 0/1 for ^C off/on

        OR      AL,AL
        JNZ     SHORT CTRL_C_set
	CALL	get_user_stack
        ;MOV	AL,[CNTCFLAG]
	MOV	AL,[SS:CNTCFLAG]  ; 12/03/2018
        MOV     [SI+6],AL
        RETN
CTRL_C_set:
        DEC     AL
        JNZ     SHORT bad_val
        AND     DL,01h
        ;MOV	[CNTCFLAG],DL
	MOV	[SS:CNTCFLAG],DL  ; 12/03/2018	
        RETN
bad_val:
        MOV     AL,0FFH
        RETN

;BREAK <$Get_INDOS_Flag -- Return location of DOS critical-section flag>

_$GET_INDOS_FLAG:

; Inputs:
;       None
; Function:
;       Returns location of DOS status for interrupt routines
; Returns:
;       Flag location in ES:BX

        CALL	get_user_stack
        MOV     WORD [SI+2],INDOS
        MOV     [SI+10H],SS
	RETN 

;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;
                                                                          ;
_$GET_IN_VARS:

; Return a pointer to interesting DOS variables This call is version
; dependent and is subject to change without notice in future versions.
; Use at risk.

        CALL	get_user_stack
        MOV     WORD [SI+2],SYSINITVAR
        MOV     [SI+10H],SS
	RETN
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;BREAK <$Get_Drive_Freespace -- Return bytes of free disk space on a drive>

_$GET_DRIVE_FREESPACE:

; Inputs:
;       DL = Drive number
; Function:
;       Return number of free allocation units on drive
; Outputs:
;       BX = Number of free allocation units
;       DX = Total Number of allocation units on disk
;       CX = Sector size
;       AX = Sectors per allocation unit
;          = -1 if bad drive specified
; This call returns the same info in the same registers (except for FAT pointer)
;      as the old FAT pointer calls

        PUSH    SS
        POP     DS
        MOV     AL,DL
	CALL	GETTHISDRV
        MOV     AX,-1
        JC      SHORT BADFRDRIVE
	CALL	FATREAD
        XOR     DX,DX
        MOV     BX,2
        MOV     CX,[ES:BP+0DH]
        DEC     CX
        PUSH    CX              ; Save Total
SCANFREE:
	CALL	UNPACK
        JNZ     SHORT NOTFREECLUS
        INC     DX
NOTFREECLUS:
        INC     BX
        LOOP    SCANFREE
        POP     BX              ; Remember Total
        MOV     AL,[ES:BP+4]
        INC     AL
        XOR     AH,AH
        MOV     CX,[ES:BP+2]
BADFRDRIVE:
	CALL	get_user_stack
	;ASSUME  DS:NOTHING
        MOV     [SI+4],CX
        MOV     [SI+6],BX
        MOV     [SI+2],DX
        ;MOV	[SI+user_env.user_AX],AX
        MOV	[SI],AX ; 31/03/2018
	RETN

;BREAK <$Get_DMA, $Set_DMA -- Get/Set current DMA address>

_$GET_DMA:

; Inputs:
;       None
; Function:
;       Get DISK TRANSFER ADDRESS
; Returns:
;       ES:BX is current transfer address

        ;MOV     BX,[DMAADD]
        ;MOV     CX,[DMAADD+2]
	; 12/03/2018
        MOV     BX,[SS:DMAADD]
        MOV     CX,[SS:DMAADD+2]
        CALL	get_user_stack
        MOV     [SI+2],BX
        MOV     [SI+10H],CX
        RETN

_$SET_DMA:		; System call 26

; Inputs:
;       DS:DX is desired new disk transfer address
; Function:
;       Set DISK TRANSFER ADDRESS
; Returns:
;       None

        ;MOV     [DMAADD],DX
        ;MOV     [DMAADD+2],DS
	; 12/03/2018
        MOV     [SS:DMAADD],DX
        MOV     [SS:DMAADD+2],DS
        RETN

;BREAK <$Get_Default_DPB,$Get_DPB -- Return pointer to DPB>
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;

_$GET_DEFAULT_DPB:

; Inputs:
;       DL = Drive number (always default drive for call 31)
; Function:
;       Return pointer to drive parameter table for default drive
; Returns:
;       DS:BX points to the DPB
;       AL = 0 If OK, = -1 if bad drive (call 50 only)

        MOV     DL,0
_$GET_DPB:
        PUSH    SS
        POP     DS
        MOV     AL,DL
	CALL	GETTHISDRV
        JC      SHORT ISNODRV
	CALL	FATREAD
	CALL	get_user_stack
        MOV     [SI+2],BP
        MOV     [SI+0EH],ES
        XOR     AL,AL
        RETN
ISNODRV:
        MOV     AL,-1
        RETN
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;BREAK <$Get_Default_Drive, $Set_Default_Drive -- Set/Get default drive>

_$GET_DEFAULT_DRIVE:

; Inputs:
;       None
; Function:
;       Return current drive number
; Returns:
;       AL = drive number

        ;MOV     AL,[CURDRV]
        MOV	AL, [SS:CURDRV] ; 12/03/2018
	RETN

_$SET_DEFAULT_DRIVE:

; Inputs:
;       DL = Drive number for new default drive
; Function:
;       Set the default drive
; Returns:
;       AL = Number of drives, NO ERROR RETURN IF DRIVE NUMBER BAD

        ;MOV     AL,[NUMIO]
	MOV	AL, [SS:NUMIO] ; 12/03/2018
        CMP     DL,AL
        JNB	SHORT _RET17
        ;MOV     [CURDRV],DL
	MOV	[SS:CURDRV],DL ; 12/03/2018
_RET17:  
	RETN


;BREAK <$Get_Interrupt_Vector - Get/Set interrupt vectors>

_$GET_INTERRUPT_VECTOR:

; Inputs:
;       AL = interrupt number
; Function:
;       Get the interrupt vector
; Returns:
;       ES:BX is current interrupt vector

        CALL    RECSET
        LES     BX,[ES:BX]
	CALL	get_user_stack
        MOV     [SI+2],BX
        MOV     [SI+10H],ES
	RETN

_$SET_INTERRUPT_VECTOR:		; System call 37

; Inputs:
;       AL = interrupt number
;       DS:DX is desired new interrupt vector
; Function:
;       Set the interrupt vector
; Returns:
;       None

        CALL    RECSET
        MOV     [ES:BX],DX
        MOV     [ES:BX+2],DS
	RETN

        ;IF	ALTVECT
;VECIN:  ; INPUT VECTORS
;	DB	22H             ; Terminate
;	DB      23H             ; ^C
;	DB      24H             ; Hard error
;	DB	28H             ; Spooler
;LSTVEC:
;	DB	0		; ALL OTHER

;VECOUT: ; GET MAPPED VECTOR
;	DB	int_terminate
;	DB      int_ctrl_c
;	DB      int_fatal_abort
;	DB      int_spooler
;LSTVEC2:
	DB	0		; Map to itself

;NUMVEC	EQU	VECOUT-VECIN
;	ENDIF

RECSET:

        ;IF	ALTVECT
        ;PUSH	SS
        ;POP	ES
        ;MOV	[LSTVEC],AL     ; Terminate list with real vector
        ;MOV	[LSTVEC2],AL    ; Terminate list with real vector
        ;MOV	CX,NUMVEC       ; Number of possible translations
        ;MOV	DI,VECIN	; Point to vectors
        ;REPNE	SCASB
        ;MOV	AL,[ES:DI+NUMVEC-1] ; Get translation
        ;ENDIF

        XOR     BX,BX
        MOV     ES,BX
        MOV     BL,AL
        SHL     BX,1
        SHL     BX,1
	RETN

;BREAK <$Char_Oper - hack on paths, switches so that xenix can look like PCDOS>

; input:    AL = function:
;                   0 - read switch char
;                   1 - set switch char (char in DL)
;                   2 - read device availability
;                   3 - set device availability (0/FF in DL)
;                       DL = 0 means /DEV/ must preceed device names
;                       DL = Non 0 means /DEV/ need not preeceed
; output:   (get) DL - character/flag
;

_$CHAR_OPER:

        PUSH    SS
        POP     DS
        OR      AL,AL
        JNZ     SHORT char_oper_set_switch
        MOV     DL,[switch_character]
        JMP     SHORT char_oper_ret
char_oper_set_switch:
        DEC     AL
        JNZ	SHORT char_oper_read_avail
        MOV     [switch_character],DL
	RETN
char_oper_read_avail:
        DEC     AL
        JNZ	SHORT char_oper_set_avail
        MOV     DL,[device_availability]
        JMP     SHORT char_oper_ret
char_oper_set_avail:
        DEC     AL
        JNZ     SHORT char_oper_bad_ret
        MOV     [device_availability],DL
	RETN
char_oper_bad_ret:
        MOV     AL,0FFh
	RETN
char_oper_ret:
	CALL	get_user_stack
        MOV     [SI+6],DX
	RETN

;BREAK <$SetDPB - Create a valid DPB from a user-specified BPB>

_$SETDPB:

; Inputs:
;       ES:BP Points to DPB
;       DS:SI Points to BPB
; Function:
;       Build a correct DPB from the BPB
; Outputs:
; ES:BP and DS preserved all others destroyed

        MOV     DI,BP
        ADD     DI,2                    ; Skip over dpb_drive and dpb_UNIT
        LODSW
        STOSW                           ; dpb_sector_size
        MOV     DX,AX
        LODSB
        DEC     AL
        STOSB                           ; dpb_cluster_mask
        INC     AL
        XOR     AH,AH
LOG2LOOP:
        TEST    AL,1
        JNZ     SHORT SAVLOG
        INC     AH
        SHR     AL,1
        JMP     SHORT LOG2LOOP
SAVLOG:
        MOV     AL,AH
        STOSB                           ; dpb_cluster_shift
        MOV     BL,AL
        MOVSW                           ; dpb_first_FAT Start of FAT (# of reserved sectors)
        LODSB
        STOSB                           ; dpb_FAT_count Number of FATs
        MOV     BH,AL
        LODSW
        STOSW                           ; dpb_root_entries Number of directory entries
        MOV     CL,5
        SHR     DX,CL                   ; Directory entries per sector
        DEC     AX
        ADD     AX,DX                   ; Cause Round Up
        MOV     CX,DX
        XOR     DX,DX
        DIV     CX
        MOV     CX,AX                   ; Number of directory sectors
        INC     DI
        INC     DI                      ; Skip dpb_first_sector
        MOVSW                           ; Total number of sectors in DSKSIZ (temp as dpb_max_cluster)
        LODSB
        MOV     [ES:BP+16H],AL    	; Media byte
        LODSW                           ; Number of sectors in a FAT
        STOSB                           ; dpb_FAT_size
        MUL     BH                      ; Space occupied by all FATs
        ADD     AX,[ES:BP+6]
        STOSW                           ; dpb_dir_sector
        ADD     AX,CX                   ; Add number of directory sectors
        MOV     [ES:BP+0BH],AX
        SUB     AX,[ES:BP+0DH]
        NEG     AX                      ; Sectors in data area
        MOV     CL,BL                   ; dpb_cluster_shift
        SHR     AX,CL                   ; Div by sectors/cluster
        INC     AX
        MOV     [ES:BP+0DH],AX
        MOV     WORD [ES:BP+1CH],0 ; Current directory is root
	RETN
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;

;    do_ext

;CODE	ENDS
;    END

;============================================================================
; DIRCALL.ASM
;============================================================================
; Retro DOS v2.0 - 09/03/2018

;TITLE DIRCALL - Directory manipulation internal calls
;NAME  DIRCALL

; $MKDIR
; $CHDIR
; $RMDIR

;.xlist
;INCLUDE DOSSEG.ASM

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

; XENIX CALLS
;BREAK <$MkDir - Make a directory entry>

MKNERRJ: 
	JMP	MKNERR
NODEEXISTSJ: 
	JMP	NODEEXISTS

_$MKDIR:

; Inputs:
;       DS:DX Points to asciz name
; Function:
;       Make a new directory
; Returns:
;       STD XENIX Return
;       AX = mkdir_path_not_found if path bad
;       AX = mkdir_access_denied  If
;               Directory cannot be created
;               Node already exists
;               Device name given
;               Disk or directory(root) full

        CALL	validate_path
        JC      SHORT MKNERRJ
        MOV     SI,DX
        ; 15/03/2018
	;MOV     [THISFCB+2],SS
        ;MOV     WORD [THISFCB],AUXSTACK-40  ; Scratch space
	MOV     [CS:THISFCB+2],SS
        MOV     WORD [CS:THISFCB],AUXSTACK-40
        MOV     AL,attr_directory
        ;MOV     WORD [CREATING],0E500h
	MOV     WORD [CS:CREATING],0E500h
	CALL	MAKENODE
        MOV     AL,mkdir_path_not_found
        JC      SHORT MKNERRJ
        JNZ     SHORT NODEEXISTSJ
        LDS     DI,[CURBUF]
        SUB     SI,DI
        PUSH    SI              ; Pointer to fcb_FIRCLUS
        PUSH    WORD [DI+8] ; Sector of new node
        PUSH    SS
        POP     DS
        PUSH    WORD [DIRSTART]	; Parent for .. entry
        XOR     AX,AX
        MOV     [DIRSTART],AX   ; Null directory
        CALL	NEWDIR
        JC      SHORT NODEEXISTSPOPDEL	; No room
        CALL	GETENT          ; First entry
        LES     DI,[CURBUF]
        MOV     BYTE [ES:DI+5],1
        ADD     DI,BUFINSIZ     ; Point at buffer
        MOV     AX,202EH        ; ". "
        STOSW
        MOV     DX,[DIRSTART]   ; Point at itself
        CALL	SETDOTENT
        MOV     AX,2E2EH        ; ".."
        STOSW
        POP     DX              ; Parent
	CALL	SETDOTENT
        LES     BP,[THISDPB]
        POP     DX              ; Entry sector
        XOR     AL,AL           ; Pre read
	CALL	GETBUFFR
        MOV     DX,[DIRSTART]
        LDS     DI,[CURBUF]
ZAPENT:
        POP     SI              ; fcb_Firclus pointer
        ADD     SI,DI
        MOV     [SI],DX
        XOR     DX,DX
        MOV     [SI+2],DX
        MOV     [SI+4],DX
DIRUP:
        MOV     BYTE [DI+5],1
        PUSH    SS
        POP     DS
        MOV     AL,[ES:BP]
	CALL	FLUSHBUF
SYS_RET_OKJ:
        JMP     SYS_RET_OK

NODEEXISTSPOPDEL:
        POP     DX              ; Parent
        POP     DX              ; Entry sector
        LES     BP,[THISDPB]
        XOR     AL,AL           ; Pre read
	CALL	GETBUFFR
        LDS     DI,[CURBUF]
        POP     SI              ; dir_first pointer
        ADD     SI,DI
        SUB     SI,dir_entry.dir_first ; Point back to start of dir entry
        MOV     BYTE [SI],0E5H	; Free the entry
        CALL    DIRUP
NODEEXISTS:
        MOV     AL,mkdir_access_denied
MKNERR:
        JMP     SYS_RET_ERR

;BREAK <$ChDir -- Change current directory on a drive>

_$CHDIR:

; Inputs:
;       DS:DX Points to asciz name
; Function:
;       Change current directory
; Returns:
;       STD XENIX Return
;       AX = chdir_path_not_found if error

        CALL	validate_path
        JC      SHORT PATHTOOLONG

        PUSH    DS
        PUSH    DX
        MOV     SI,DX
	CALL	GETPATH
        JC      SHORT PATHNOGOOD
        JNZ     SHORT PATHNOGOOD
        MOV     AX,[DIRSTART]
        MOV     BX,AX
        XCHG    BX,[ES:BP+1CH]
        OR      AX,AX
        POP     SI
        POP     DS
        JZ      SHORT SYS_RET_OKJ
        MOV     DI,BP
        ADD     DI,DPB.DIR_TEXT
        MOV     DX,DI
	;CMP     BYTE [DRIVESPEC],0
        CMP     BYTE [CS:DRIVESPEC],0 ; 15/03/2018
	JZ      SHORT NODRIVESPEC
        INC     SI
        INC     SI
NODRIVESPEC:
        MOV     CX,SI
	;CMP     BYTE [ROOTSTART],0
	CMP     BYTE [CS:ROOTSTART],0 ; 15/03/2018
        JZ      SHORT NOTROOTPATH
        INC     SI
        INC     CX
        JMP     SHORT COPYTHESTRINGBXZ
NOTROOTPATH:
        OR      BX,BX           ; Previous path root?
        JZ	SHORT COPYTHESTRING   ; Yes
        XOR     BX,BX
ENDLOOP:
        CMP     BYTE [ES:DI],0
        JZ      SHORT PATHEND
        INC     DI
        INC     BX
        JMP     SHORT ENDLOOP
PATHEND:
        MOV     AL,'/'
        ;CMP     AL,[switch_character]
        CMP     AL,[CS:switch_character] ; 15/03/2018
	JNZ     SHORT SLASHOK
        MOV     AL,'\'		; Use the alternate character
SLASHOK:
        STOSB
        INC     BX
        JMP     SHORT CHECK_LEN

PATHNOGOOD:
        POP     AX
        POP     AX
PATHTOOLONG:
        ;error	error_path_not_found
	MOV	AL,error_path_not_found
	jmp	SYS_RET_ERR

INCBXCHK:
        INC     BX
BXCHK:
        CMP     BX,DIRSTRLEN
        RETN

COPYTHESTRINGBXZ:
        XOR     BX,BX
COPYTHESTRING:
        LODSB
        OR      AL,AL
        ;JNZ     SHORT FOOB
        ;JMP     CPSTDONE
	JZ	CPSTDONE ; 15/03/2018
FOOB:
        CMP     AL,'.'
        JZ      SHORT SEEDOT
        CALL    COPYELEM
CHECK_LEN:
        CMP     BX,DIRSTRLEN
        JB      SHORT COPYTHESTRING
        MOV     AL,[ES:DI-1]
	CALL	PATHCHRCMP
        JNZ	SHORT OK_DI
        DEC     DI
OK_DI:
        XOR     AL,AL
        STOSB                   ; Correctly terminate the path
        MOV     WORD [ES:BP+1CH],-1 ; Force re-validation
        JMP     SHORT PATHTOOLONG

SEEDOT:
        LODSB
        OR      AL,AL           ; Check for null
        JZ      SHORT CPSTDONEDEC
        CMP     AL,'.'
        JNZ     SHORT COPYTHESTRING ; eat ./
        CALL    DELELMES        ; have   ..
        LODSB                   ; eat the /
        OR      AL,AL           ; Check for null
        JZ      SHORT CPSTDONEDEC
        JMP     SHORT COPYTHESTRING

; Copy one element from DS:SI to ES:DI include trailing / not trailing null
; LODSB has already been done
COPYELEM:
        PUSH    DI                      ; Save in case too long
        PUSH    CX
        MOV     CX,800h                 ; length of filename
        MOV     AH,'.'                  ; char to stop on
        CALL    CopyPiece               ; go for it!
        CALL    BXCHK                   ; did we go over?
        JAE     SHORT POPCXDI		; yep, go home
        CMP     AH,AL                   ; did we stop on .?
        JZ      SHORT CopyExt		; yes, go copy ext
        OR      AL,AL                   ; did we end on nul?
        JZ      SHORT DECSIRET		; yes, bye
CopyPathEnd:
        STOSB                           ; save the path char
        CALL    INCBXCHK                ; was there room for it?
        JAE	SHORT POPCXDI		; Nope
        INC     SI                      ; guard against following dec
DECSIRET:
        DEC     SI                      ; point back at null
        POP     CX
        POP     AX                      ; toss away saved DI
        RETN
POPCXDI:
        POP     CX                      ; restore
        POP     DI                      ; point back...
	RETN
CopyExt:
        STOSB                           ; save the dot
        CALL    INCBXCHK                ; room?
        JAE     SHORT POPCXDI		; nope.
        LODSB                           ; get next char
        XOR     AH,AH                   ; NUL here
        MOV     CX,300h                 ; at most 3 chars
        CALL    CopyPiece               ; go copy it
        CALL    BXCHK                   ; did we go over
        JAE     SHORT POPCXDI		; yep
        OR      AL,AL                   ; sucessful end?
        JZ      SHORT DECSIRET		; yes
        JMP     SHORT CopyPathEnd	; go stash path char

DELELMES:
; Delete one path element from ES:DI
        DEC     DI                      ; the '/'
        DEC     BX

        ;IF      KANJI
        ;PUSH    AX
        ;PUSH    CX
        ;PUSH    DI
        ;PUSH    DX
        ;MOV     CX,DI
        ;MOV     DI,DX
;DELLOOP:
        ;CMP     DI,CX
        ;JZ      GOTDELE
        ;MOV     AL,ES:[DI]
        ;INC     DI
        ;invoke  TESTKANJ
        ;JZ      NOTKANJ11
        ;INC     DI
        ;JMP     DELLOOP

;NOTKANJ11:
        ;invoke  PATHCHRCMP
        ;JNZ     DELLOOP
        ;MOV     DX,DI                   ; Point to char after '/'
        ;JMP     DELLOOP

;GOTDELE:
        ;MOV     DI,DX
        ;POP     DX
        ;POP     AX                      ; Initial DI
        ;SUB     AX,DI                   ; Distance moved
        ;SUB     BX,AX                   ; Set correct BX
        ;POP     CX
        ;POP     AX
        ;return
        ;ELSE
DELLOOP:
        CMP     DI,DX
        ;retz
        JZ	SHORT CopyPieceRet
	PUSH    AX
        MOV     AL,[ES:DI-1]
        CALL	PATHCHRCMP
        POP     AX
        ;retz
        JZ	SHORT CopyPieceRet
        DEC     DI
        DEC     BX
        JMP     SHORT DELLOOP
        ;ENDIF

CPSTDONEDEC:
        DEC     DI                      ; Back up over trailing /
CPSTDONE:
        STOSB                           ; The NUL
        JMP     SYS_RET_OK

; copy a piece CH chars max until the char in AH (or path or NUL)
CopyPiece:
        STOSB                           ; store the character
        INC     CL                      ; moved a byte
        CALL    INCBXCHK                ; room enough?
        JAE     SHORT CopyPieceRet	; no, pop CX and DI
        OR      AL,AL                   ; end of string?
        JZ	SHORT CopyPieceRet	; yes, dec si and return

        ;IF KANJI
        ;CALL    TestKanj                ; was it kanji?
        ;JZ      NotKanj                 ; nope
        ;MOVSB                           ; move the next byte
        ;CALL    INCBXCHK                ; room for it?
        ;JAE     CopyPieceRet            ; nope
        ;INC     CL                      ; moved a byte
;NotKanj:
        ;ENDIF

        CMP     CL,CH                   ; move too many?
        JBE     SHORT CopyPieceNext	; nope

        ;IF KANJI
        ;CALL    TestKanj                ; was the last byte kanji
        ;JZ      NotKanj2                ; no only single byte backup
        ;DEC     DI                      ; back up a char
        ;DEC     BX
;NotKanj2:
        ;ENDIF

        DEC     DI                      ; back up a char
        DEC     BX
CopyPieceNext:
        LODSB                           ; get next character
        CALL	PATHCHRCMP              ; end of road?
        JZ      SHORT CopyPieceRet	; yep, return and don't dec SI
        CMP     AL,AH                   ; end of filename?
        JNZ     SHORT CopyPiece		; go do name
CopyPieceRet:
        RETN				; bye!

;BREAK <$RmDir -- Remove a directory>

NOPATHJ: 
	JMP    NOPATH

_$RMDIR:				; System call 47

; Inputs:
;       DS:DX Points to asciz name
; Function:
;       Delete directory if empty
; Returns:
;       STD XENIX Return
;       AX = rmdir_path_not_found If path bad
;       AX = rmdir_access_denied If
;               Directory not empty
;               Path not directory
;               Root directory specified
;               Directory malformed (. and .. not first two entries)
;       AX = rmdir_current_directory

	CALL	validate_path
        JC      SHORT NOPATHJ
        MOV     SI,DX
	CALL	GETPATH
        JC      SHORT NOPATHJ
        JNZ     SHORT NOTDIRPATH
        MOV     DI,[DIRSTART]
        OR      DI,DI
        JZ      SHORT NOTDIRPATH
        MOV     CX,[ES:BP+1CH]
        CMP     CX,-1
        JNZ     SHORT rmdir_current_dir_check
	CALL	GETCURRDIR
	CALL	get_user_stack
        MOV     DX,[SI+6]
        MOV     DS,[SI+0EH]
        JMP     SHORT _$RMDIR

NOTDIRPATHPOP:
        POP     AX
        POP     AX
NOTDIRPATH:
        ;error	error_access_denied
	MOV	AL,error_access_denied
	jmp	SYS_RET_ERR

rmdir_current_dir_check:
        CMP     DI,CX
        JNZ     SHORT rmdir_get_buf
        ;error	error_current_directory
	MOV	AL,error_current_directory
	jmp	SYS_RET_ERR 

rmdir_get_buf:
        LDS     DI,[CURBUF]
        SUB     BX,DI
        PUSH    BX                      ; Save entry pointer
        PUSH    WORD [DI+8]	; Save sector number
        PUSH    SS
        POP     DS
        PUSH    SS
        POP     ES
        MOV     DI,NAME1
        MOV     AL,'?'
        MOV     CX,11
        REP     STOSB
        XOR     AL,AL
        STOSB
        CALL	STARTSRCH
	CALL	GETENTRY
        MOV     DS,[CURBUF+2]
        MOV     SI,BX
        LODSW
        ;CMP	AX,(' ' SHL 8) OR '.'
        CMP	AX, 202Eh ; '. '
	JNZ     SHORT NOTDIRPATHPOP
        ADD     SI,32-2
        LODSW
        ;CMP	AX,('.' SHL 8) OR '.'
        CMP	AX, 2E2Eh ; '..'
	JNZ	SHORT NOTDIRPATHPOP
        PUSH    SS
        POP     DS
        MOV     WORD [LASTENT],2	; Skip . and ..
        CALL	GETENTRY
        MOV     BYTE [ATTRIB],attr_directory+attr_hidden+attr_system
        CALL	SRCH
        JNC     SHORT NOTDIRPATHPOP
        LES     BP,[THISDPB]
        MOV     BX,[DIRSTART]
        CALL	RELEASE
        POP     DX
        XOR     AL,AL
	CALL	GETBUFFR
        LDS     DI,[CURBUF]
        POP     BX
        ADD     BX,DI
        MOV     BYTE [BX],0E5H		; Free the entry
        JMP     DIRUP

NOPATH:
        ;error	error_path_not_found
	MOV	AL,error_path_not_found
	jmp	SYS_RET_ERR

;	do_ext
;
;CODE    ENDS
;        END

;============================================================================
; ALLOC.ASM
;============================================================================

; xenix memory calls for MSDOS
;
; CAUTION: The following routines rely on the fact that arena_signature and
; arena_owner_system are all equal to zero and are contained in DI.
;
;INCLUDE DOSSEG.ASM

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;TITLE ALLOC.ASM - memory arena manager
;NAME Alloc

;SUBTTL memory allocation utility routines
;PAGE
;
; arena data
;
;       i_need  arena_head,WORD         ; seg address of start of arena
;       i_need  CurrentPDB,WORD         ; current process data block addr
;       i_need  FirstArena,WORD         ; first free block found
;       i_need  BestArena,WORD          ; best free block found
;       i_need  LastArena,WORD          ; last free block found
;       i_need  AllocMethod,BYTE        ; how to alloc first(best)last
;
;
; arena_free_process
; input:    BX - PID of process
; output:   free all blocks allocated to that PID
;
        ;procedure   arena_free_process,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

arena_free_process:

        MOV     DI,ARENA.SIGNATURE ; 0	
        MOV     AX,[SS:arena_head] ; 15/04/2018  
        CALL    check_signature         ; ES <- AX, check for valid block

arena_free_process_loop:
        ;retc
        JC	SHORT AFP_RETN	; Retro DOS v.20 - 05/03/2018
	PUSH    ES
        POP     DS
        CMP     [ARENA.OWNER],BX	; is block owned by pid?
        JNZ     SHORT arena_free_next	; no, skip to next
        MOV     [ARENA.OWNER],DI	; yes... free him

arena_free_next:
        CMP     BYTE [DI],arena_signature_end
                                        ; end of road, Jack?
        ;retz				; never come back no more
	JZ	SHORT AFP_RETN
        CALL    arena_next              ; next item in ES/AX carry set if trash
        JMP     SHORT arena_free_process_loop

;AFP_RETN:
;	RETN

;arena_free_process  ENDP

;
; arena_next
; input:    DS - pointer to block head
; output:   AX,ES - pointers to next head
;           carry set if trashed arena
;
        ;procedure   arena_next,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

arena_next:

        MOV     AX,DS                   ; AX <- current block
        ADD     AX,[ARENA.SIZE]		; AX <- AX + current block length
        INC     AX                      ; remember that header!
;
;       fall into check_signature and return
;
;       CALL    check_signature         ; ES <- AX, carry set if error
;       RET

;arena_next  ENDP

;
; check_signature
; input:    AX - address of block header
; output:   ES=AX, carry set if signature is bad
;
        ;procedure   check_signature,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

check_signature:        

	MOV     ES,AX                   ; ES <- AX
        CMP     BYTE [ES:DI],arena_signature_normal
                                        ; IF next signature = not_end THEN
        JZ      SHORT check_signature_ok ;   GOTO ok
        CMP     BYTE [ES:DI],arena_signature_end
                                        ; IF next signature = end then
        JZ      SHORT check_signature_ok ;   GOTO ok
        STC                             ; set error
AFP_RETN:
 	;  Retro DOS v.20 - 05/03/2018
check_signature_ok:
        ;return
COALESCE_RETN:
	RETN

;check_signature_ok:
        ;CLC
        ;return

;Check_signature ENDP

;
; Coalesce - combine free blocks ahead with current block
; input:    DS - pointer to head of free block
; output:   updated head of block, AX is next block
;           carry set -> trashed arena
;
        ;procedure   Coalesce,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
        
Coalesce:
	
	CMP     BYTE [DI],arena_signature_end
                                        ; IF current signature = END THEN
        ;retz				;   GOTO ok
        jz	short COALESCE_RETN
	CALL    arena_next              ; ES, AX <- next block, Carry set if error
        ;retc				; IF no error THEN GOTO check
	jc	short COALESCE_RETN

coalesce_check:
        CMP     [ES:ARENA.OWNER],DI
        ;retnz				; IF next block isnt free THEN return
        JNZ	SHORT COALESCE_RETN
	MOV     CX,[ES:ARENA.SIZE]	; CX <- next block size
        INC     CX                      ; CX <- CX + 1 (for header size)
        ADD     [ARENA.SIZE],CX		; current size <- current size + CX
        MOV     CL,[ES:DI]              ; move up signature
        MOV     [DI],CL
        JMP     SHORT Coalesce		; try again

;Coalesce    ENDP

;SUBTTL $Alloc - allocate space in memory
;PAGE
;
;   Assembler usage:
;           MOV     BX,size
;           MOV     AH,Alloc
;           INT     21h
;         AX:0 is pointer to allocated memory
;         BX is max size if not enough memory
;
;   Description:
;           Alloc returns  a  pointer  to  a  free  block of
;       memory that has the requested  size  in  paragraphs.
;
;   Error return:
;           AX = error_not_enough_memory
;              = error_arena_trashed
;
        ;procedure   $ALLOC,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$ALLOC:

        XOR     AX,AX
        MOV     DI,AX
	
	; 15/03/2018
	;MOV     [FirstArena],AX         ; init the options
        ;MOV     [BestArena],AX
        ;MOV     [LastArena],AX
        MOV     [SS:FirstArena],AX         ; init the options
        MOV     [SS:BestArena],AX
        MOV     [SS:LastArena],AX
        PUSH    AX                      ; alloc_max <- 0
        ;MOV     AX,[arena_head]         ; AX <- beginning of arena
        MOV     AX,[SS:arena_head]
	CALL    check_signature         ; ES <- AX, carry set if error
        JC      SHORT alloc_err		; IF error THEN GOTO err

alloc_scan:
        PUSH    ES
        POP     DS                      ; DS <- ES
        CMP     [ARENA.OWNER],DI
        JZ      SHORT alloc_free	; IF current block is free THEN examine

alloc_next:
        CMP     BYTE [DI],arena_signature_end
                                        ; IF current block is last THEN
        JZ      SHORT alloc_end		;   GOTO end
        CALL    arena_next              ; AX, ES <- next block, Carry set if error
        JNC     SHORT alloc_scan	; IF no error THEN GOTO scan

alloc_err:
        POP     AX

alloc_trashed:
        ;error	error_arena_trashed
	MOV	AL,error_arena_trashed
	JMP	SYS_RET_ERR

alloc_end:
        ;CMP     WORD [FirstArena],0
        CMP	WORD [SS:FirstArena],0	; 15/03/2018
	JNZ     SHORT alloc_do_split

alloc_fail:
        ;invoke get_user_stack
        CALL	get_user_stack
	POP     BX
        ;MOV	[SI].user_BX,BX
        MOV	[SI+2],BX
	;error	error_not_enough_memory
	MOV	AL,error_not_enough_memory
	JMP	SYS_RET_ERR

alloc_free:
        CALL    Coalesce		; add following free block to current
        JC	SHORT alloc_err		; IF error THEN GOTO err
        MOV     CX,[ARENA.SIZE]
        POP     DX                      ; check for max found size
        CMP     CX,DX
        JNA     SHORT alloc_test
        MOV     DX,CX

alloc_test:
        PUSH    DX
        CMP     BX,CX                   ; IF BX > size of current block THEN
        JA      SHORT alloc_next	;   GOTO next

	; 15/03/2018
        ;CMP     WORD [FirstArena],0
        CMP     WORD [SS:FirstArena],0
	JNZ	SHORT alloc_best
        ;MOV     [FirstArena],DS	; save first one found
        MOV     [SS:FirstArena],DS	
alloc_best:
        ;CMP     WORD [BestArena],0
        CMP     WORD [SS:BestArena],0
        JZ      SHORT alloc_make_best	; initial best
        PUSH    ES
        ;MOV     ES,[BestArena]
        MOV     ES,[SS:BestArena]
        CMP     [ES:ARENA.SIZE],CX	; is size of best larger than found?
        POP     ES
        JBE     SHORT alloc_last
alloc_make_best:
        ;MOV     [BestArena],DS		; assign best
        MOV     [SS:BestArena],DS
alloc_last:
        ;MOV     [LastArena],DS		; assign last
        MOV     [SS:LastArena],DS 
        JMP     SHORT alloc_next

;
; split the block high
;
alloc_do_split_high:
        ;MOV     DS,[LastArena]
        MOV     DS, [SS:LastArena]
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX
        MOV     DX,DS
        JE      SHORT alloc_set_owner	; sizes are equal, no split
        ADD     DX,CX                   ; point to next block
        MOV     ES,DX                   ; no decrement!
        DEC     CX
        XCHG    BX,CX                   ; bx has size of lower block
        JMP     SHORT alloc_set_sizes	; cx has upper (requested) size
;
; we have scanned memory and have found all appropriate blocks
; check for the type of allocation desired; first and best are identical
; last must be split high
;
alloc_do_split:
	; 15/03/2018
        ;CMP     BYTE [AllocMethod], 1
        CMP     BYTE [SS:AllocMethod], 1
        JA      SHORT alloc_do_split_high
        ;MOV     DS,[FirstArena]
        MOV     DS,[SS:FirstArena]        
	JB      SHORT alloc_get_size
        ;MOV     DS,[BestArena]
	MOV     DS,[SS:BestArena]
alloc_get_size:
        MOV     CX,[ARENA.SIZE]
        SUB     CX,BX                   ; get room left over
        MOV     AX,DS
        MOV     DX,AX                   ; save for owner setting
        JE      SHORT alloc_set_owner	; IF BX = size THEN (don't split)
        ADD     AX,BX
        INC     AX                      ; remember the header
        MOV     ES,AX                   ; ES <- DS + BX (new header location)
        DEC     CX                      ; CX <- size of split block
alloc_set_sizes:
        MOV     [ARENA.SIZE],BX		; current size <- BX
        MOV     [ES:ARENA.SIZE],CX      ; split size <- CX
        MOV     BL,arena_signature_normal
        XCHG    BL,[DI]			; current signature <- 4D
        MOV     [ES:DI],BL		; new block sig <- old block sig
        MOV     [ES:ARENA.OWNER],DI

alloc_set_owner:
        MOV     DS,DX
        ;MOV     AX,[CurrentPDB]
        MOV     AX,[SS:CurrentPDB] ; 15/03/2018
        MOV     [ARENA.OWNER],AX
        MOV     AX,DS
        INC     AX
        POP     BX
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$alloc  ENDP

;SUBTTL $SETBLOCK - change size of an allocated block (if possible)
;PAGE
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     BX,newsize
;           MOV     AH,setblock
;           INT     21h
;         if setblock fails for growing, BX will have the maximum
;         size possible
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;              = error_not_enough_memory
;              = error_invalid_function
;
        ;procedure   $SETBLOCK,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$SETBLOCK:        

	MOV     DI,ARENA.SIGNATURE
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JNC     SHORT setblock_grab

setblock_bad:
        JMP     alloc_trashed

setblock_grab:
        MOV     DS,AX
        CALL    Coalesce
        JC      SHORT setblock_bad
        MOV     CX,[ARENA.SIZE]
        PUSH    CX
        CMP     BX,CX
        JBE     SHORT alloc_get_size
        JMP     alloc_fail

;$setblock   ENDP

;SUBTTL $DEALLOC - free previously allocated piece of memory
;PAGE
;
;   Assembler usage:
;           MOV     ES,block
;           MOV     AH,dealloc
;           INT     21h
;
;   Error return:
;           AX = error_invalid_block
;              = error_arena_trashed
;
        ;procedure   $DEALLOC,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$DEALLOC:        
	MOV     DI,ARENA.SIGNATURE ; = 0
        MOV     AX,ES
        DEC     AX
        CALL    check_signature
        JC      SHORT dealloc_err
        MOV     [ES:ARENA.OWNER],DI
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

dealloc_err:
        ;error	error_invalid_block
	MOV	AL,error_invalid_block
	JMP	SYS_RET_ERR

;$DEALLOC    ENDP

;SUBTTL $AllocOper - get/set allocation mechanism
;PAGE

;   Assembler usage:
;           MOV     AH,AllocOper
;           MOV     BX,method
;           MOV     AL,func
;           INT     21h
;
;   Error return:
;           AX = error_invalid_function
;
        ;procedure   $AllocOper,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$ALLOCOPER:        
	; 15/04/2018
	CMP     AL,1
        JB      SHORT AllocOperGet
        JZ      SHORT AllocOperSet
        ;error	error_invalid_function
	MOV	AL, error_invalid_function
	JMP	SYS_RET_ERR
AllocOperGet:
        MOV     AL,[SS:AllocMethod]
        XOR     AH,AH
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK
AllocOperSet:
        MOV     [SS:AllocMethod],BL
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$AllocOper  ENDP

;do_ext

;CODE	ENDS
;    END

;============================================================================
; DEV.ASM
;============================================================================
; Retro DOS v2.0 - 14/03/2018

; Device call routines for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE   DEV - Device call routines
;NAME    Dev

;SUBTTL IOFUNC -- DO FUNCTION 1-12 I/O

IOFUNC_RETRY:
	CALL	restore_world
IOFUNC:

; Inputs:
;       DS:SI Points to FCB
;       AH is function code
;               = 0 Input
;               = 1 Input Status
;               = 2 Output
;               = 3 Output Status
;               = 4 Flush
;       AL = character if output
; Function:
;       Perform indicated I/O to device or file
; Outputs:
;       AL is character if input
;       If a status call
;               zero set if not ready
;               zero reset if ready (character in AL for input status)
; For regular files:
;       Input Status
;               Gets character but restores fcb_RR field
;               Zero set on EOF
;       Input
;               Gets character advances fcb_RR field
;               Returns ^Z on EOF
;       Output Status
;               Always ready
; AX altered, all other registers preserved

        MOV     [SS:IOXAD+2],SS
        MOV     WORD [SS:IOXAD],DEVIOBUF
        MOV     WORD [SS:IOSCNT],1
        MOV     [SS:DEVIOBUF],AX

IOFUNC2:
        TEST    BYTE [SI+18H],080H
        ;JNZ     SHORT IOTODEV
        ;JMP     IOTOFILE
	JZ	IOTOFILE ; 15/03/2018
IOTODEV:
        CALL	save_world
        PUSH    DS
        PUSH    SS
        POP     ES
        PUSH    SS
        POP     DS
        XOR     BX,BX
        MOV     [IOCALL_REQSTAT],BX
        MOV     [IOMED],BL

        MOV     BX,IOCALL

        MOV     CX,(DEVRD*256) + DRDWRHL
        OR      AH,AH
        JZ      SHORT DCALLR
        MOV     CX,(DEVRDND*256) + DRDNDHL
        DEC     AH
        JZ      SHORT DCALLR
        MOV     CX,(DEVWRT*256) + DRDWRHL
        DEC     AH
        JZ      SHORT DCALLO
        MOV     CX,(DEVOST*256) + DSTATHL
        DEC     AH
        JZ      SHORT DCALLO
DFLUSH:
        MOV     CX,(DEVIFL*256) + DFLSHL
DCALLR:
        MOV     AH,86H
DCALL:
        MOV     [IOCALL_REQLEN],CL
        MOV     [IOCALL_REQFUNC],CH
        MOV     CL,AH
        POP     DS
        CALL    DEVIOCALL
        MOV     DI,[SS:IOCALL_REQSTAT]
        TEST    DI,STERR
        JZ      SHORT OKDEVIO
        MOV     AH,CL
        CALL	CHARHARD
        CMP     AL,1
        JZ      SHORT IOFUNC_RETRY
;Know user must have wanted ignore. Make sure device shows ready so
;that DOS doesn't get caught in a status loop when user simply wants
;to ignore the error.
        AND     BYTE [SS:IOCALL_REQSTAT+1], ~(STBUI >> 8)  ; 0FDh
OKDEVIO:
        PUSH    SS
        POP     DS
        CMP     CH,DEVRDND
        JNZ     SHORT DNODRD
        MOV     AL,[IORCHR]
        MOV     [DEVIOBUF],AL
DNODRD: 
	MOV     AH,[IOCALL_REQSTAT+1]
        NOT     AH                      ; Zero = busy, not zero = ready
        AND     AH,(STBUI >> 8) ; STBUI SHR 8 ; = 2
  	CALL	restore_world
        MOV     AX,[SS:DEVIOBUF]
        RETN

DCALLO:
        MOV     AH,87H
        JMP     SHORT DCALL

IOTOFILE:
        OR      AH,AH
        JZ      SHORT IOIN
        DEC     AH
        JZ      SHORT IOIST
        DEC     AH
        JZ      SHORT IOUT
        RETN			; NON ZERO FLAG FOR OUTPUT STATUS

IOIST:
        PUSH    WORD [SI+21H]        ; Save position
        PUSH    WORD [SI+23H]
        CALL    IOIN
        POP     WORD [SI+23H]      ; Restore position
        POP     WORD [SI+21H]
	RETN

IOUT:
        CALL    SETXADDR
        CALL	STORE
        CALL	FINNOSAV
        CALL    RESTXADDR       ; If you change this into a jmp don't come
IOUT_RETN:
        RETN			; crying to me when things don't work ARR

IOIN:
        CALL    SETXADDR
	CALL	LOAD
        PUSH    CX
	CALL	FINNOSAV
        POP     CX
        OR      CX,CX           ; Check EOF
        CALL    RESTXADDR
        MOV     AL,[SS:DEVIOBUF]   ; Get byte from trans addr
        JNZ	SHORT IOUT_RETN
        MOV     AL,1AH          ; ^Z if EOF
        RETN

SETXADDR:
        POP     WORD [SS:CALLSCNT]	; Return address
        CALL	save_world
        PUSH    WORD [SS:DMAADD]	; Save Disk trans addr
        PUSH    WORD [SS:DMAADD+2]
        PUSH    DS
        PUSH    SS
        POP     DS
        MOV     CX,[IOXAD+2]
        MOV     [DMAADD+2],CX
        MOV     CX,[IOXAD]
        MOV     [DMAADD],CX		; Set byte trans addr
        MOV     CX,[IOSCNT]             ; ioscnt specifies length of buffer
        POP     DS
        MOV     WORD [SI+0EH],1 ; One byte per record
        MOV     DX,SI                   ; FCB to DS:DX
	CALL	GETRRPOS
        JMP     SHORT RESTRET           ; RETURN ADDRESS

RESTXADDR:
        POP     WORD [SS:CALLSCNT]     ; Return address
        POP     WORD [SS:DMAADD+2]     ; Restore Disk trans addr
        POP     WORD [SS:DMAADD]
        CALL	restore_world
RESTRET:
	JMP     WORD [SS:CALLSCNT]	; Return address

;SUBTTL DEVIOCALL, DEVIOCALL2 - CALL A DEVICE

DEVIOCALL:

; Inputs:
;       DS:SI Points to device FCB
;       ES:BX Points to request data
; Function:
;       Call the device
; Outputs:
;       None
; DS:SI,AX destroyed, others preserved

        LDS     SI,[SI+19H]

DEVIOCALL2:
; As above only DS:SI points to device header on entry, and DS:SI is preserved
        MOV     AX,[SI+6]
        MOV     [SS:CALLDEVAD],AX
        MOV     [SS:CALLDEVAD+2],DS
        CALL    FAR [SS:CALLDEVAD]  ; 28/03/2018
        MOV     AX,[SI+8]
        MOV     [SS:CALLDEVAD],AX
        CALL    FAR [SS:CALLDEVAD]  ; 28/03/2018	
        RETN

;SUBTTL DEVNAME - LOOK FOR NAME OF DEVICE

DEVNAME:

; Inputs:
;       DS,ES:DOSGROUP
;       Filename in NAME1
; Function:
;       Determine if file is in list of I/O drivers
; Outputs:
;       Carry set if name not found
;       ELSE
;       Zero flag set
;       BH = Bit 7,6 = 1, bit 5 = 0 (cooked mode)
;            bits 0-4 set from low byte of attribute word
;       DEVPT = DWORD pointer to Device header of device
; Registers BX destroyed

        PUSH    SI
        PUSH    DI
        PUSH    CX

        TEST    BYTE [ATTRIB],attr_volume_id 
			; If looking for VOL id don't find devs
        JNZ	SHORT RET31
        MOV     SI,NULDEV
LOOKIO:
        TEST    WORD [SI+4],DEVTYP
        JZ      SHORT SKIPDEV		; Skip block devices
        PUSH    SI
        ADD     SI,SYSDEV.NAME
        MOV     DI,NAME1
        MOV     CX,4                    ; All devices are 8 letters
        REPE    CMPSW                   ; Check for name in list
        POP     SI
        JZ      SHORT IOCHK		; Found it?
SKIPDEV:
        LDS     SI,[SI]			; Get address of next device
        CMP     SI,-1                   ; At end of list?
        JNZ     SHORT LOOKIO
RET31:  
	STC				; Not found
RETNV:  
	PUSH    SS
        POP     DS
        POP     CX
        POP     DI
        POP     SI
        RETN

IOCHK:
        MOV     [SS:DEVPT+2],DS		; Save pointer to device
        MOV     BH,[SI+4]
        OR      BH,0C0H
        AND     BH,~20H ; 0DFh		;Clears Carry
        MOV     [SS:DEVPT],SI
        JMP     SHORT RETNV

GETBP:

; Inputs:
;       AL = Logical unit number (A = 0)
; Function:
;       Find Drive Parameter Block
; Outputs:
;       ES:BP points to DPB
;       [THISDPB] = ES:BP
;       Carry set if unit number bad
; No other registers altered

        LES     BP,[DPBHEAD]    ; Just in case drive isn't valid
        AND     AL,3FH          ; Mask out dirty and device bits
        CMP     AL,[NUMIO]
        CMC
        JC      SHORT GOTDPB	; Get drive A
FNDDPB:
        CMP     AL,[ES:BP]
        JZ      SHORT GOTDPB	; Carry is clear if jump executed
        LES     BP,[ES:BP+18H]
        JMP     SHORT FNDDPB
GOTDPB:
        MOV     [THISDPB],BP
        MOV     [THISDPB+2],ES
        RETN

;SUBTTL SETREAD, SETWRITE -- SET UP HEADER BLOCK

SETREAD:

; Inputs:
;       DS:BX = Transfer Address
;       CX = Record Count
;       DX = Starting Record
;       AH = Media Byte
;       AL = Unit Code
; Function:
;       Set up the device call header at DEVCALL
; Output:
;       ES:BX Points to DEVCALL
; No other registers effected

        PUSH    DI
        PUSH    CX
        PUSH    AX
        MOV     CL,DEVRD
SETCALLHEAD:
        MOV     AL,DRDWRHL
        PUSH    SS
        POP     ES
        MOV     DI,DEVCALL
        STOSB                   ; length
        POP     AX
        STOSB                   ; Unit
        PUSH    AX
        MOV     AL,CL
        STOSB                   ; Command code
        XOR     AX,AX
        STOSW                   ; Status
        ADD     DI,8            ; Skip link fields
        POP     AX
        XCHG    AH,AL
        STOSB                   ; Media byte
        XCHG    AL,AH
        PUSH    AX
        MOV     AX,BX
        STOSW
        MOV     AX,DS
        STOSW                   ; Transfer addr
        POP     CX              ; Real AX
        POP     AX              ; Real CX
        STOSW                   ; Count
        XCHG    AX,DX           ; AX=Real DX, DX=real CX, CX=real AX
        STOSW                   ; Start
        XCHG    AX,CX
        XCHG    DX,CX
        POP     DI
        MOV     BX,DEVCALL
        RETN

SETWRITE:

; Inputs:
;       DS:BX = Transfer Address
;       CX = Record Count
;       DX = Starting Record
;       AH = Media Byte
;       AL = Unit Code
; Function:
;       Set up the device call header at DEVCALL
; Output:
;       ES:BX Points to DEVCALL
; No other registers effected

        PUSH    DI
        PUSH    CX
        PUSH    AX
        MOV     CL,DEVWRT
        ADD     CL,[SS:VERFLG]
        JMP     SHORT SETCALLHEAD

;CODE	ENDS
;    END

;============================================================================
; DIR.ASM
;============================================================================
; Retro DOS v2 - 09/03/2018

; Directory routines for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE	DIR - Directory and path cracking
;NAME	Dir

;SUBTTL BUILDDIR,NEWDIR -- ALLOCATE DIRECTORIES
;PAGE

BUILDDIR:

; Inputs:
;       ES:BP Points to DPB
;       [THISFCB] Set if using NEWDIR entry point
;       [LASTENT] current last valid entry number in directory if no free
;               entries
; Function:
;       Grow directory if no free entries and not root
; Outputs:
;       CARRY SET IF FAILURE
;       ELSE
;          AX entry number of new entry
;          If a new dir [DIRSTART],[CLUSFAC],[CLUSNUM],[DIRSEC] set
;               AX = first entry of new dir
;       GETENT should be called to set [LASTENT]

        MOV     AX,[ENTFREE]
        CMP     AX,-1
        JNZ     SHORT GOTRET
        CMP     WORD [DIRSTART],0
        JNZ     SHORT NEWDIR
        STC
        RETN			; Can't grow root

NEWDIR:
        MOV     BX,[DIRSTART]
        OR      BX,BX
        JZ      SHORT NULLDIR
        CALL	GETEOF
NULLDIR:
        MOV     CX,1
        CALL	ALLOCATE
        JC	SHORT BUILDDIR_RETN
        MOV     DX,[DIRSTART]
        OR      DX,DX
        JNZ     SHORT ADDINGDIR
        CALL	SETDIRSRCH
        MOV     WORD [LASTENT],-1
        JMP     SHORT GOTDIRREC
ADDINGDIR:
        CMP     WORD [CLUSNUM],0FF8H
        JB      SHORT NOTFIRSTGROW
        MOV     [CLUSNUM],BX
NOTFIRSTGROW:
        MOV     DX,BX
        XOR     BL,BL
	CALL	FIGREC
GOTDIRREC:
        MOV     CL,[ES:BP+4]
        INC     CL
        XOR     CH,CH
ZERODIR:
        PUSH    CX
        MOV     AL,0FFH
	CALL	GETBUFFR
        MOV     CX,[ES:BP+2]
        PUSH    ES
        LES     DI,[CURBUF]
        PUSH    DI
        ADD     DI,BUFINSIZ
        XOR     AX,AX
        SHR     CX,1
        REP     STOSW
        JNC     SHORT EVENZ
        STOSB
EVENZ:
        POP     DI
        INC     AL
        MOV     [ES:DI+5],AL
        POP     ES
        POP     CX
        INC     DX
        LOOP    ZERODIR
        MOV     AX,[LASTENT]
        INC     AX
GOTRET:
        CLC
BUILDDIR_RETN:
        RETN

;
; set up a . and .. directory entry for a directory
;

SETDOTENT:
        MOV     CX,4
        MOV     AX,2020H
        REP     STOSW
        STOSB
        MOV     SI,[THISFCB]
        MOV     AL,attr_directory
        STOSB
        ADD     DI,10
        MOV     AX,[SI+16H]
        STOSW
        MOV     AX,[SI+14H]
        STOSW
        MOV     AX,DX
        STOSW
        XOR     AX,AX
        STOSW
        STOSW
        RETN

;SUBTTL GETFILE, GETNAME, FINDNAME -- LOOK FOR A FILE

; Start of procedure SEARCH

GETFILE:
; Same as GETNAME except ES:DI points to FCB on successful return
        CALL	MOVNAME
        JC	SHORT GETFILE_RETN
        PUSH    DX
        PUSH    DS
        CALL    FINDNAME
        POP     ES
        POP     DI
GETFILE_RETN:
        RETN

GETNAME:

; Inputs:
;       DS,DX point to FCB
; Function:
;       Find file name in disk directory. First byte is
;       drive number (0=current disk). "?" matches any
;       character.
; Outputs:
;       Carry set if file not found
;       ELSE
;       Zero set if attributes match (always except when creating)
;       AH = Device ID (bit 7 set if not disk)
;       [THISDPB] = Base of drive parameters
;       DS = DOSGROUP
;       ES = DOSGROUP
;       [CURBUF+2]:BX = Pointer into directory buffer
;       [CURBUF+2]:SI = Pointer to First Cluster field in directory entry
;       [CURBUF] has directory record with match
;       [NAME1] has file name
; All other registers destroyed.

        CALL	MOVNAME
	JC	SHORT GETNAME_RETN	; Bad file name?

FINDNAME:
        PUSH    SS
        POP     DS
	CALL	DEVNAME
        JC	SHORT FINDENTRY
        CALL	BUILDFCB
FINDNAME_RETN:
GETNAME_RETN:
        RETN

; NOTE THE FALL THROUGH

;SUBTTL FINDENTRY -- LOOK FOR AN ENTRY

FINDENTRY:

; Inputs:
;       [THISDPB] set
;       [SECCLUSPOS] = 0
;       [DIRSEC] = Starting directory sector number
;       [CLUSNUM] = Next cluster of directory
;       [CLUSFAC] = Sectors/Cluster
;       [NAME1] = Name to look for
; Function:
;       Find file name in disk directory.
;       "?" matches any character.
; Outputs:
;       Carry set if name not found
;       ELSE
;       Zero set if attributes match (always except when creating)
;       AH = Device ID (bit 7 set if not disk)
;       [THISDPB] = Base of drive parameters
;       DS = DOSGROUP
;       ES = DOSGROUP
;       [CURBUF+2]:BX = Pointer into directory buffer
;       [CURBUF+2]:SI = Pointer to First Cluster field in directory entry
;       [CURBUF] has directory record with match
;       [NAME1] has file name
;       [LASTENT] is entry number of the entry
; All other registers destroyed.

        CALL    STARTSRCH
        CMP     BYTE [ATTRIB],attr_volume_id
					; Looking for vol ID only ?
        JNZ     SHORT NOTVOLSRCH 	; No
        CALL    SETROOTSRCH		; Yes force search of root
NOTVOLSRCH:
        CALL    GETENTRY
SRCH:
        PUSH    DS
        MOV     DS,[CURBUF+2]
        MOV     AH,[BX]
        OR      AH,AH                   ; End of directory?
        JZ      SHORT FREE
        ;CMP     AH,[DELALL]		; Free entry?
        CMP	AH,[SS:DELALL] ; 15/03/2018
	JZ      SHORT FREE
        TEST    BYTE [BX+11],attr_volume_id
					; Volume ID file?
        JZ      SHORT CHKFNAM		; NO
        ;INC     BYTE [VOLID]
	INC	BYTE [SS:VOLID] ; 15/03/2018
CHKFNAM:
        MOV     SI,BX
        PUSH    SS
        POP     ES
        MOV     DI,NAME1
        MOV     CX,11
WILDCRD:
        REPE    CMPSB
        JZ      SHORT FOUND
        CMP     BYTE [ES:DI-1],"?"
        JZ      SHORT WILDCRD
        POP     DS
NEXTENT:
        LES     BP,[THISDPB]
        CALL    NEXTENTRY
        JNC     SHORT SRCH
        JMP     SHORT SETESRET

FREE:
        POP     DS
        MOV     CX,[LASTENT]
        CMP     CX,[ENTFREE]
        JAE     SHORT TSTALL
        MOV     [ENTFREE],CX
TSTALL:
        CMP     AH,[DELALL]		; At end of directory?
        JZ      SHORT NEXTENT		; No - continue search
        MOV     [ENTLAST],CX
        STC
        JMP     SHORT SETESRET

FOUND:
;
; We have a file with a matching name.  We must now consider
; the attributes:
; ATTRIB        Action
; ------        ------
; Volume_ID     Is Volume_ID in test?
; Otherwise     If no create then Is ATTRIB+extra superset of test?
;               If create then Is ATTRIB equal to test?
;
        MOV     CH,[SI]                 ; Attributes of file
        POP     DS
        MOV     AH,[ATTRIB]		; Attributes of search
        TEST    CH,attr_volume_id       ; Volume ID file?
        JZ      SHORT check_one_volume_id ; Nope check other attributes
        TEST    AH,attr_volume_id       ; Can we find Volume ID?
        JZ      SHORT NEXTENT		; Nope, (not even $FCB_CREATE)
        XOR     AH,AH                   ; Set zero flag for $FCB_CREATE
        JMP     SHORT _RETF		; Found Volume ID
check_one_volume_id:
        CMP     AH,attr_volume_id       ; Looking only for Volume ID?
        JZ      SHORT NEXTENT		; Yes, continue search
        ADD     SI,15
        CALL    MatchAttributes
        JZ      SHORT _RETF
        TEST    BYTE [CREATING],-1	; Pass back mismatch if creating
        JZ      SHORT NEXTENT		; Otherwise continue searching
_RETF:
        LES     BP,[THISDPB]
        MOV     AH,[ES:BP]
SETESRET:
        PUSH    SS
        POP     ES
        RETN

;SUBTTL GETENTRY, NEXTENTRY, GETENT -- STEP THROUGH DIRECTORY

GETENTRY:

; Inputs:
;       [LASTENT] has directory entry
;       ES:BP points to drive parameters
; Function:
;       Locates directory entry in preparation for search
;       GETENT provides entry for passing desired entry in AX
;       A valid search environment MUST exist
;               ENDENT,ENTLAST,ENTFREE
; Outputs:
;       [CURBUF+2]:BX = Pointer to next directory entry in CURBUF
;       [CURBUF+2]:DX = Pointer to first byte after end of CURBUF
;       [LASTENT] = New directory entry number

        MOV     AX,[LASTENT]
GETENT:
        MOV     [LASTENT],AX
        MOV     CL,4
        SHL     AX,CL
        XOR     DX,DX
        SHL     AX,1
        RCL     DX,1                    ; Account for overflow in last shift
        MOV     BX,[ES:BP+2]
        AND     BL,255-31               ; Must be multiple of 32
        DIV     BX
        MOV     BX,DX                   ; Position within sector
        PUSH    BX
	CALL	DIRREAD
        POP     BX
SETENTRY:
        MOV     DX,[CURBUF]
        ADD     DX,BUFINSIZ
        ADD     BX,DX
        ADD     DX,[ES:BP+2] ; Always clears carry
        RETN

NEXTENTRY:

; Inputs:
;       Same as outputs of GETENTRY, above
; Function:
;       Update BX, and [LASTENT] for next directory entry.
;       Carry set if no more.

        MOV     AX,[LASTENT]
        CMP     AX,[ENTLAST]
        JZ      SHORT NONE
        INC     AX
        ADD     BX,32
        CMP     BX,DX
        JB      SHORT HAVIT
        MOV     BL,[SECCLUSPOS]
        INC     BL
        CMP     BL,[CLUSFAC]
        JB      SHORT SAMECLUS
        MOV     BX,[NXTCLUSNUM]
        CMP     BX,0FF8H
        JAE     SHORT NONE
        CMP     BX,2
        JB      SHORT NONE
        JMP     SHORT GETENT
NONE:
        STC
        RETN
HAVIT:
        MOV     [LASTENT],AX
        CLC
        RETN

SAMECLUS:
        MOV     [SECCLUSPOS],BL
        MOV     [LASTENT],AX
        PUSH    DS
        LDS     DI,[CURBUF]
        MOV     DX,[DI+8]
        INC     DX
        POP     DS
	CALL	FIRSTCLUSTER
        XOR     BX,BX
        JMP     SHORT SETENTRY

; end of procedure SEARCH

;SUBTTL GETCURRDIR -- GET CURRENT DIRECTORY

; Start of procedure DIR_SEARCH

GETCURRDIR:

; Inputs:
;       ES:BP Points to DPB
;       FATREAD should be called before this routine
; Function:
;       Find current directory for drive
;       If path is bad set current directory to the root
; Outputs:
;       DS = DOSGROUP
;       [SECCLUSPOS] = 0
;       [DIRSTART] = Cluster # of first cluster of directory ( 0 if root)
;       [DIRSEC] Set to phys sec # of first sector first cluster of directory
;       [CLUSNUM] Set to next cluster
;       [CLUSFAC] Sectors/cluster
; Destroys all registers

        MOV     BX,[ES:BP+1CH]
        OR      BX,BX
        JZ      SHORT SETROOTSRCH
        CMP     BX,0FF8H
        JB      SHORT SETDIRSRCH
        PUSH    ES
        POP     DS
        LEA     SI,[BP+1EH]
        CALL    ROOTPATH
        JNC     SHORT SETCURR
        MOV     WORD [ES:BP+1CH],0

SETROOTSRCH:
        PUSH    SS
        POP     DS
        XOR     AX,AX
        MOV     [DIRSTART],AX
        MOV     [SECCLUSPOS],AL
        DEC     AX
        MOV     [CLUSNUM],AX
        MOV     AX,[ES:BP+0BH]
        MOV     DX,[ES:BP+10H]
        SUB     AX,DX
        MOV     [CLUSFAC],AL
        MOV     [DIRSEC],DX
        RETN

SETCURR:
        MOV     AX,[DIRSTART]
        MOV     [ES:BP+1CH],AX
        RETN

SETDIRSRCH:

; Inputs:
;       BX cluster number of start of directory
;       ES:BP Points to DPB
; Function:
;       Set up a directory search
; Outputs:
;       DS = DOSGROUP
;       [DIRSTART] = BX
;       [CLUSFAC],[CLUSNUM],[SECCLUSPOS],[DIRSEC] set
; destroys AX,DX

        OR      BX,BX
        JZ      SHORT SETROOTSRCH
        PUSH    SS
        POP     DS
        MOV     [DIRSTART],BX
        MOV     AL,[ES:BP+4]
        INC     AL
        MOV     [CLUSFAC],AL
        CALL	UNPACK
        MOV     [CLUSNUM],DI
        MOV     DX,BX
        XOR     BL,BL
        MOV     [SECCLUSPOS],BL
        CALL	FIGREC
        MOV     [DIRSEC],DX
        RETN

; End of procedure DIR_SEARCH

;SUBTTL MAKENODE -- CREATE A NEW NODE

MAKENODE:

; Inputs:
;       AL - attribute to create
;       DS:SI Points to asciz path
;       [THISFCB] Points to an empty FCB
; Function:
;       Make a new node
; Outputs:
;       DS=DOSGROUP
;       ES:BP Points to DPB
;       AX = 0 Success
;       AX = 1 A node by this name exists and is a directory
;       AX = 2 A new node could not be created                error
;       AX = 3 A node by this name exists and is a file       error
;       AX = 4 Bad Path                                       error
;       AX = 5 Attribute mismatch                             error
;       CARRY SET IF ERROR
;       ELSE
;          [DIRSTART],[DIRSEC],[CLUSFAC],[CLUSNUM] set to directory
;               containing new node.
;          [CURBUF+2]:BX Points to entry
;          [CURBUF+2]:SI Points to entry.fcb_firclus
;          [ThisFCB] is filled in
;          If this is a new entry zero is set and
;               Attribute byte in entry is directory
;          else a file existed by this name and:
;               [NAME1] has name
;               entry is not changed in any way
; Destroys all registers

        PUSH    AX
        CALL    GETPATH
        MOV     DL,CL           ; Save CL info
        POP     CX
        ;MOV     [ATTRIB],CL
        MOV	[SS:ATTRIB],CL ; 15/03/2018
	MOV     CX,AX
        JNC     SHORT make_exists ; File existed
        JNZ     SHORT make_err_4 ; Path bad
        OR      DL,DL           ; Check "CL" return from GETPATH
        JNZ     SHORT make_type	; Name simply not found
make_err_4:
        MOV     AL,4            ; case 1 bad path
make_err_ret:
        STC
        RETN

make_type:
        XOR     AL,AL           ; nothing exists... assume 0
        STC
        JMP     SHORT make_save
make_exists:
        JZ      SHORT make_exists_dir
        MOV     AL,3            ; file exists type 3
 	; 15/03/2018
        ;TEST    BYTE [ATTRIB],(attr_volume_id+attr_directory)
	TEST    BYTE [SS:ATTRIB],(attr_volume_id+attr_directory)
        JNZ     SHORT make_err_ret_5 ; but we wanted a volid or dir
        OR      CH,CH
        JS      SHORT make_dev	; No furthur checks if device
        PUSH    CX
        ;MOV     DS,[CURBUF+2]
        MOV     DS,[SS:CURBUF+2]
        MOV     CH,[BX+0BH] ; Get file attributes
        TEST    CH,attr_read_only
        JNZ     SHORT make_err_ret_5P ; Cannot create on read only files
        CALL    MatchAttributes
make_err_ret_5P:
        POP     CX
        JZ	SHORT make_dev	; Attributes ok
make_err_ret_5:
        MOV     AL,5            ; Attribute mismatch
        JMP     SHORT make_err_ret

make_dev:
        XOR     AL,AL           ; Make sure zero set(atts match), carry clear(exists)
        MOV     AL,3            ; Restore correct value
        JMP     SHORT make_save
make_exists_dir:
        MOV     AL,1            ; directory exists
        ;TEST    BYTE [ATTRIB],attr_directory
        TEST    BYTE [SS:ATTRIB],attr_directory
        JZ	SHORT make_err_ret ; we didn't want a directory
        CLC
        RETN			; just return

make_save:
        PUSH    AX
;
; set up for call to NewEntry - it is in the middle of FCB_CREATE
; so we must also pre-push two registers.  They will be popped off
; by FCB_CREATE
;
        PUSH    SS
        POP     DS
        PUSHF				;Save state of flags
        CMP     BYTE [NAME1],'.'	;Detect attempt to make '.' or '..'
        JNZ	SHORT NOTLDOT		; Needed because no '.' or '..' in root
        POPF
        MOV     AL,1                    ;Force type 2 error
        JMP     SHORT SET2ERR

NOTLDOT:
        POPF
        PUSH    ES
        LES     DI,[THISFCB]
        PUSH    DS
        PUSH    DI
        PUSH    ES
        MOV     AX,CX
        CALL	NEWENTRY
        POP     DS
        POP     ES
SET2ERR:
        OR      AL,AL
        POP     AX
        JZ      SHORT make_set_fcb
        MOV     AL,2                ; create failed case 2
        STC
	RETN

make_set_fcb:
        PUSH    ES
        LES     DI,[THISFCB]
        INC     DI
        PUSH    DS
        PUSH    SI
        MOV     DS,[CURBUF+2]
        MOV     SI,BX
        MOV     CX,11
        REP     MOVSB
        POP     SI
        POP     DS
        POP     ES
        CMP     AL,1
        JA      SHORT make_errors
        OR      AL,AL
        CLC
        RETN
make_errors:
        STC
        RETN

;SUBTTL GETPATH -- PARSE AN asciz PATH

GETPATH:

; Inputs:
;       DS:SI Points to asciz path
; Function:
;       Crack the path
; Outputs:
;       [DRIVESPEC] is non zero if a drive was specified
;       [ROOTSTART] is non zero if a / started the path
;       [ATTRIB] set to attr_directory+attr_hidden+attr_system
;       Same as FINDPATH except if path specifies a device in which case
;       bit 7 of AH will be set and SI and BX will point DOSGROUP relative
; Destroys all registers

        XOR     AX,AX
        ; 15/03/2018
	;MOV     [DRIVESPEC],AX
        ;MOV     BYTE [ATTRIB],attr_directory+attr_system+attr_hidden
	MOV     [SS:DRIVESPEC],AX
        MOV     BYTE [SS:ATTRIB],attr_directory+attr_system+attr_hidden
        LODSB
	CALL	PATHCHRCMP
        JZ	SHORT DEFAULTROOT
        MOV     AH,AL
        LODSB
        CMP     AL,':'
        JZ	SHORT DRVSPEC
        DEC     SI
        DEC     SI
        PUSH    DS
        PUSH    SI
        PUSH    SS
        POP     ES
        ;CMP     BYTE [device_availability],0
        CMP     BYTE [SS:device_availability],0
	JZ      SHORT NOWDEV
        CALL    GOTPRESTRING2
        JNC	SHORT BUILDFCBJ	; If no carry then we have a device
NOWDEV:
        CALL    DEFPATH
GOFIND:
        ;MOV     AL,[NoSetDir]
        MOV     AL,[SS:NoSetDir]
        PUSH    AX
        ;MOV     BYTE [NoSetDir],0
        MOV     BYTE [SS:NoSetDir],0
        CALL    GETCURRDIR
        POP     AX
        ;MOV     [NoSetDir],AL
        MOV     [SS:NoSetDir],AL
	POP     SI
        POP     DS
        JMP	FINDPATH

DEFPATH:
        XOR     AL,AL
DRVPATH:
        CALL	GETTHISDRV
        JC	SHORT GETPATH_RETN	; Bad drive
        PUSH    SS
        POP     DS
        CALL	FATREAD
        CLC
;GETPATH_RETN:
        RETN

DEFAULTROOT:
        PUSH    DS
        PUSH    SI
        CALL    DEFPATH
        POP     SI
        POP     DS
ROOTSRCH:
	; 15/03/2018
        ;INC     BYTE [ROOTSTART]
        INC     BYTE [SS:ROOTSTART]
        CMP     BYTE [SI],0
        JZ      SHORT PATHISNULL

        PUSH    DS
        PUSH    SI
        PUSH    ES              ; Save pointer to DPB
        CALL    CHKDEV
        POP     ES
        JNC	SHORT BUILDFCBJ
        POP     SI
        POP     DS
        JMP     ROOTPATH

BUILDFCBJ:
        POP     AX
        POP     AX
        ;context es
        PUSH	SS
	POP	ES
	;invoke BUILDFCB	; Clears carry sets zero
	CALL	BUILDFCB
        INC     AL		; reset zero
        ;return
GETPATH_RETN:
	RETN

DRVSPEC:
        ;INC     BYTE [DRIVESPEC]
        INC     BYTE [SS:DRIVESPEC]
        MOV     AL,AH
        OR      AL,20H          ; Convert to lower case
        SUB     AL,60H          ; Make A=1
        PUSH    DS
        PUSH    SI
        PUSH    AX
        ;context es
        PUSH	SS
	POP	ES
	CALL    GOTPRESTRING2
        POP     AX
        JNC     SHORT BUILDFCBJ
        CALL    DRVPATH
        POP     SI
        POP     DS
        ;retc			; Bad drive
	JC 	SHORT GETPATH_RETN
        LODSB
        CALL	PATHCHRCMP
        JZ      SHORT ROOTSRCH
        DEC     SI
        PUSH    DS
        PUSH    SI
        JMP	SHORT GOFIND

PATHISNULL:
        CALL    SETROOTSRCH
        XOR     AL,AL           ; Set zero (directory) clear carry
        RETN

CHKDEV:
        PUSH    SS
        POP     ES
        MOV     DI,DEVSTRING
        XOR     CX,CX
        MOV     CL,[SS:DEVSTRLEN] ; 15/03/2018
CHKPRESTRING:
        REPE    CMPSB
        JZ      SHORT GOTPRESTRING
        DEC     SI
        CALL	GETLET          ; Try convert to upper case
        CMP     AL,[ES:DI-1]
        JZ      SHORT CHKPRESTRING
NOPRESTRING:
        STC
	RETN

GOTPRESTRING:
        LODSB
        CALL	PATHCHRCMP
        JNZ     SHORT NOPRESTRING
GOTPRESTRING2:
        MOV     DI,NAME1
        MOV     CX,9
TESTLOOP:
        CALL	GETLET
        CMP     AL,'.'
        JZ      SHORT TESTDEVICE
        CALL	PATHCHRCMP
        JZ      SHORT NOTDEV
        OR      AL,AL
        JZ      SHORT TESTDEVICE
        STOSB
        LOOP    TESTLOOP
NOTDEV:
        STC
        RETN

TESTDEVICE:
        ADD     CX,2
        MOV     AL,' '
        REP     STOSB
        PUSH    SS
        POP     DS
        CALL	DEVNAME
	RETN

;SUBTTL ROOTPATH, FINDPATH -- PARSE A PATH

ROOTPATH:

; Inputs:
;       ES:BP Points to DPB
;       FATREAD should be called before this routine
;       DS:SI Points to asciz string of path which is assumed to start at
;               the root (no leading '/').
; Function:
;       Search from root for path
; Outputs:
;       Same as FINDPATH
; Destroys all registers

        PUSH    DS
        CALL    SETROOTSRCH
        POP     DS

; NOTE FALL THROUGH

FINDPATH:

; Inputs:
;       ES:BP Points to DPB
;       DS:SI Points to asciz string of path (no leading '/').
;       [SECCLUSPOS] = 0
;       [DIRSEC] = Phys sec # of first sector of directory
;       [CLUSNUM] = Cluster # of next cluster
;       [CLUSFAC] = Sectors per cluster
;   Validate_path should be called before this routine is used,
;       unless it is KNOWN the path is good.
; Function:
;       Parse path name
; Outputs:
;       ES:BP Points to DPB
;       Carry set if bad path
;          DS:SI Points to path element causing failure
;          Zero set
;             [DIRSTART],[DIRSEC],[CLUSNUM], and [CLUSFAC] are set up to
;             start a search on the last directory
;             CL is zero if there is a bad name in the path
;             CL is non-zero if the name was simply not found
;                [ENTFREE] may have free spot in directory
;                [NAME1] is the name.
;                CL = 81H if '*'s or '?' in name 1, 80H otherwise
;          Zero reset
;             File in middle of path or bad name in path
;               or path too long or malformed path
;       ELSE
;          DS = DOSGROUP
;          AH = device ID
;          [CURBUF] contains directory record with match
;          [CURBUF+2]:BX Points into [CURBUF] to start of entry
;          [CURBUF+2]:SI Points to fcb_FIRCLUS field for entry
;          [NAME1] Has entry name
;          If last element is a directory zero is set and:
;             [DIRSTART],[SECCLUSPOS],[DIRSEC],[CLUSNUM], and [CLUSFAC]
;             are set up to start a search on it.
;          If last element is a file zero is reset
; Destroys all registers

        PUSH    ES
        PUSH    SI
        CALL	NAMETRANS
        MOV     CL,AL
        OR      CL,80H
        POP     DI
        POP     ES
        CMP     SI,DI
        ;JNZ     SHORT check_device
        ;JMP     BADPATH
	JZ	BADPATH ; 15/03/2018
check_device:
        PUSH    DS
        PUSH    SI
        MOV     AL,[SI]

;
; can we see all devices
;
        PUSH	SS
	POP	DS
        CMP     BYTE [device_availability],0
        JZ      SHORT FindFile
;
; check name1 to see if we have a device...
;
        PUSH    ES
        ;context ES
        PUSH	SS
	POP	ES
	CALL	DEVNAME		; blast BX
        POP     ES
        JC      SHORT FindFile
        OR      AL,AL
        JNZ     SHORT FILEINPATH
        POP     SI
        POP     SI
        PUSH	SS
	POP	ES
	CALL	BUILDFCB
        INC     AL
	RETN

FindFile:
        PUSH    DI              ; Start of this element
        PUSH    ES
        PUSH    CX
        CALL    FINDENTRY
        POP     CX
        POP     ES
        POP     DI
        JC      SHORT BADPATHPOP
        LDS     DI,[CURBUF]
        TEST    BYTE [BX+0BH],attr_directory
        JZ      SHORT FILEINPATH

;
; if we are not setting the directory, then
; check for end of string
;
        ;CMP     BYTE [NoSetDir],0
        CMP     BYTE [SS:NoSetDir],0 ; 15/03/2018
	JZ      SHORT SetDir
        MOV     DX,DI
        MOV     AX,DS
        POP     DI
        POP     DS
        CMP     BYTE [DI],0
        JZ      SHORT SETRET
        PUSH    DS
        PUSH    DI
        MOV     DI,DX
        MOV     DS,AX

SetDir:
        MOV     DX,[SI]
        SUB     BX,DI
        SUB     SI,DI
        PUSH    BX
        PUSH    AX
        PUSH    SI
        PUSH    CX
        PUSH    WORD [DI+8]
        MOV     BX,DX
        CALL    SETDIRSRCH
        POP     DX
        XOR     AL,AL
	CALL	GETBUFFR
        POP     CX
        POP     SI
        POP     AX
        POP     BX
        MOV     DI,[CURBUF]
        ADD     SI,DI
        ADD     BX,DI
        POP     DI
        POP     DS
        MOV     AL,[DI]
        OR      AL,AL
        JZ      SHORT SETRET
        INC     DI
        MOV     SI,DI
	CALL	PATHCHRCMP
        JNZ     SHORT find_bad_name
        JMP     FINDPATH

find_bad_name:
        DEC     SI
BADPATH:
        XOR     CL,CL   ; Set zero
        STC
        RETN

FILEINPATH:
        POP     DI
        POP     DS
        MOV     AL,[DI]
        OR      AL,AL
        JZ      SHORT INCRET
        MOV     SI,DI   ; Path too long
        STC
        RETN

INCRET:
        INC     AL      ; Reset zero
SETRET:
        PUSH    SS
        POP     DS
        RETN

BADPATHPOP:
        POP     SI
        POP     DS
        MOV     AL,[SI]
        MOV     SI,DI   ; Start of bad element
        OR      AL,AL   ; zero if bad element is last, non-zero if path too long
        STC
	RETN

;SUBTTL STARTSRCH -- INITIATE DIRECTORY SEARCH

STARTSRCH:

; Inputs:
;       [THISDPB] Set
; Function:
;       Set up a search for GETENTRY and NEXTENTRY
; Outputs:
;       ES:BP = Drive parameters
;       Sets up LASTENT, ENDENT, ENTFREE=ENTLAST=-1, VOLID=0
; Destroys all registers (via FATREAD)

        LES     BP,[THISDPB]
        XOR     AX,AX
        MOV     [LASTENT],AX
        MOV     [VOLID],AL	; No volume ID found
        DEC     AX
        MOV     [ENTFREE],AX
        MOV     [ENTLAST],AX
	RETN

;BREAK <MatchAttributes - the final check for attribute matching>

;
; Input:    [Attrib] = attribute to search for
;           CH = found attribute
; Output:   JZ <match>
;           JNZ <nomatch>
;

MatchAttributes:
        PUSH    AX
        ;MOV     AL,[Attrib]         ; AL <- SearchSet
        MOV	AL,[SS:ATTRIB] ; 14/03/2018
	NOT     AL                  ; AL <- SearchSet'
        AND     AL,CH               ; AL <- SearchSet' and FoundSet
        AND     AL,attr_all         ; AL <- SearchSet' and FoundSet and Important
;
; the result is non-zero if an attribute is not in the search set
; and in the found set and in the important set. This means that we do not
; have a match.  Do a JNZ <nomatch> or JZ <match>
;
        POP     AX
	RETN

;do_ext

;CODE    ENDS
;    END

;============================================================================
; DISK.ASM
;============================================================================

; Disk routines for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE	DISK - Disk utility routines
;NAME	Disk

;SUBTTL LOAD -- MAIN READ ROUTINE AND DEVICE IN ROUTINES
;PAGE

; * * * * Drivers for file input from devices * * * *

SWAPBACK:
        PUSH    ES
        PUSH    DI
        PUSH    SI
        PUSH    BX
        MOV     BX,1
        CALL	get_sf_from_jfn
        ADD     DI,SF_ENTRY.sf_fcb
        MOV     BL,[COUTDSAV]
        LDS     SI,[COUTSAV]
        MOV     [ES:DI+19H],SI
        MOV     [ES:DI+1BH],DS
        MOV     [ES:DI+18H],BL
        PUSH    SS
        POP     DS
        XOR     BX,BX
        CALL	get_sf_from_jfn
        ADD     DI,SF_ENTRY.sf_fcb
        MOV     BL,[CINDSAV]
        LDS     SI,[CINSAV]
        MOV     [ES:DI+19H],SI
        MOV     [ES:DI+1BH],DS
        MOV     [ES:DI+18H],BL
        PUSH    SS
        POP     DS
        MOV     BYTE [CONSWAP],0
        MOV     BYTE [IDLEINT],1
SWAPRET:
        POP     BX
        POP     SI
        POP     DI
        POP     ES
        RETN

SWAPCON:
        PUSH    ES
        PUSH    DI
        PUSH    SI
        PUSH    BX
        MOV     BYTE [CONSWAP],1
        MOV     BYTE [IDLEINT],0
        XOR     BX,BX
        CALL	get_sf_from_jfn
        ADD     DI,SF_ENTRY.sf_fcb
        MOV     BL,[ES:DI+18H]
        MOV     [CINDSAV],BL
        LDS     SI,[ES:DI+19H]
	; 15/03/2018
        ;MOV     [CINSAV],SI
        ;MOV     [CINSAV+2],DS
        ;LDS     SI,[THISFCB]
        MOV     [SS:CINSAV],SI
        MOV     [SS:CINSAV+2],DS
        LDS     SI,[SS:THISFCB]
        MOV     BL,[SI+18H]
        LDS     SI,[SI+19H]
        MOV     [ES:DI+18H],BL
        MOV     [ES:DI+19H],SI
        MOV     [ES:DI+1BH],DS
        PUSH    SS
        POP     DS
        MOV     BX,1
        CALL	get_sf_from_jfn
        ADD     DI,SF_ENTRY.sf_fcb
        MOV     BL,[ES:DI+18H]
        MOV     [COUTDSAV],BL
        LDS     SI,[ES:DI+19H]
        ;MOV     [COUTSAV],SI
        ;MOV     [COUTSAV+2],DS
        ;LDS     SI,[THISFCB]
        MOV     [SS:COUTSAV],SI
        MOV     [SS:COUTSAV+2],DS
        LDS     SI,[SS:THISFCB]
        MOV     BL,[SI+18H]
        LDS     SI,[SI+19H]
        MOV     [ES:DI+18H],BL
        MOV     [ES:DI+19H],SI
        MOV     [ES:DI+1BH],DS
        PUSH    SS
        POP     DS
        JMP     SWAPRET

LOAD:

; Inputs:
;       DS:DI point to FCB
;       DX:AX = Position in file to read
;       CX = No. of records to read
; Outputs:
;       DX:AX = Position of last record read
;       CX = No. of bytes read
;       ES:DI point to FCB
;       fcb_LSTCLUS, fcb_CLUSPOS fields in FCB set

        call    SETUP
        OR      BL,BL           ; Check for named device I/O
        JS      SHORT READDEV
        CALL	DISKREAD
        RETN

READDEV:
        LES     DI,[DMAADD]
        TEST    BL,40H                  ; End of file?
        JZ      SHORT ENDRDDEVJ3
        TEST    BL,ISNULL               ; NUL device?
        JZ      SHORT TESTRAW		; NO
        XOR     AL,AL                   ; Indicate EOF
ENDRDDEVJ3: 
	JMP	ENDRDDEVJ2

DVRDRAW:
        PUSH    ES
        POP     DS
DVRDRAWR:
        MOV     BX,DI                   ; DS:BX transfer addr
        XOR     DX,DX                   ; Start at 0
        XOR     AX,AX                   ; Media Byte, unit = 0
        CALL	SETREAD
	; 15/03/2018
        ;LDS     SI,[THISFCB]
        LDS     SI,[SS:THISFCB]
	CALL	DEVIOCALL
        MOV     DX,DI                   ; DX is preserved by INT 24
        MOV     AH,86H                  ; Read error
        ;MOV     DI,[DEVCALL_REQSTAT]
        MOV     DI,[SS:DEVCALL_REQSTAT]
	TEST    DI,STERR
        JZ      SHORT CRDROK		; No errors
        CALL	CHARHARD
        MOV     DI,DX
        CMP     AL,1
        JZ      SHORT DVRDRAWR		; Retry
CRDROK:
        MOV     DI,DX
        ;ADD     DI,[CALLSCNT]		; Amount transferred
        ADD     DI,[SS:CALLSCNT]
	JMP     SHORT ENDRDDEVJ2

TESTRAW:
        TEST    BL,020H                 ; Raw mode?
        JNZ     SHORT DVRDRAW
        TEST    BL,ISCIN                ; Is it console device?
        ;JZ      SHORT NOTRDCON
        ;JMP     READCON
	JNZ	READCON ; 15/03/2018
NOTRDCON:
        MOV     AX,ES
        MOV     DS,AX
        MOV     BX,DI
        XOR     DX,DX
        MOV     AX,DX
        PUSH    CX
        MOV     CX,1
        CALL	SETREAD
        POP     CX
        ;LDS     SI,[THISFCB]
        LDS     SI,[SS:THISFCB]
        LDS     SI,[SI+19H]
DVRDLP:
        CALL	DSKSTATCHK
        CALL	DEVIOCALL2
        PUSH    DI
        MOV     AH,86H
        ;MOV     DI,[DEVCALL_REQSTAT]
        MOV     DI,[SS:DEVCALL_REQSTAT]
        TEST    DI,STERR
        JZ      SHORT CRDOK
        CALL	CHARHARD
        POP     DI
        ;MOV     WORD [CALLSCNT],1
        MOV     WORD [SS:CALLSCNT],1
	CMP     AL,1
        JZ      SHORT DVRDLP		;Retry
        XOR     AL,AL                   ;Pick some random character
        JMP     SHORT DVRDIGN
CRDOK:
        POP     DI
        ;CMP     WORD [CALLSCNT],1
	CMP     WORD [SS:CALLSCNT],1
        JNZ     SHORT ENDRDDEVJ2
        PUSH    DS
        ;MOV     DS,[CALLXAD+2]
        MOV     DS,[SS:CALLXAD+2]
        MOV     AL,[DI]
        POP     DS
DVRDIGN:
        ;INC     WORD [CALLXAD]
        ;MOV     WORD [DEVCALL_REQSTAT],0
        INC     WORD [SS:CALLXAD]
        MOV     WORD [SS:DEVCALL_REQSTAT],0
        INC     DI
        CMP     AL,1AH                  ; ^Z?
        JZ      SHORT ENDRDDEVJ
        CMP     AL,c_CR                 ; CR?
        LOOPNZ  DVRDLP
ENDRDDEVJ:
        DEC     DI
ENDRDDEVJ2:
        JMP     SHORT ENDRDDEV

TRANBUF:
        LODSB
        STOSB
        CMP     AL,c_CR         ; Check for carriage return
        JNZ     SHORT NORMCH
        MOV     BYTE [SI],c_LF
NORMCH:
        CMP     AL,c_LF
        LOOPNZ  TRANBUF
        JNZ     SHORT ENDRDCON
        XOR     SI,SI           ; Cause a new buffer to be read
        CALL	OUTT		; Transmit linefeed
        OR      AL,1            ; Clear zero flag--not end of file
ENDRDCON:
        PUSH    SS
        POP     DS
        CALL    SWAPBACK
        MOV     [CONTPOS],SI
ENDRDDEV:
        PUSH    SS
        POP     DS
        MOV     [NEXTADD],DI
        JNZ     SHORT SETFCBC	; Zero set if Ctrl-Z found in input
        LES     DI,[THISFCB]
        AND     BYTE [ES:DI+18H],0FFH-40H 
				; Mark as no more data available
SETFCBC:
       	CALL	SETFCB
       	RETN

READCON:
        CALL    SWAPCON
        MOV     SI,[CONTPOS]
        OR      SI,SI
        JNZ     SHORT TRANBUF
        CMP     BYTE [CONBUF],128
        JZ      SHORT GETBUF
        MOV     WORD [CONBUF],0FF80H	; Set up 128-byte buffer with no template
GETBUF:
        PUSH    CX
        PUSH    ES
        PUSH    DI
        MOV     DX,CONBUF
        CALL	_$STD_CON_STRING_INPUT	; Get input buffer
        POP     DI
        POP     ES
        POP     CX
        MOV     SI,CONBUF+2
        CMP     BYTE [SI],1AH		; Check for Ctrl-Z in first character
        JNZ     SHORT TRANBUF
        MOV     AL,1AH
        STOSB
        DEC     DI
        MOV     AL,10
        CALL	OUTT			; Send linefeed
        XOR     SI,SI
        JMP     SHORT ENDRDCON

;SUBTTL STORE -- MAIN WRITE ROUTINE AND DEVICE OUT ROUTINES

; Inputs:
;       DS:DI point to FCB
;       DX:AX = Position in file of disk transfer
;       CX = Record count
; Outputs:
;       DX:AX = Position of last record written
;       CX = No. of records written
;       ES:DI point to FCB
;       fcb_LSTCLUS, fcb_CLUSPOS fields in FCB set

STORE:
        CALL	SETUP
        OR      BL,BL
        JS      SHORT WRTDEV
        CALL	DATE16
        MOV     [ES:DI+14H],AX
        MOV     [ES:DI+16H],DX
        call    DISKWRITE
        RETN

WRITECON:
        PUSH    DS
        PUSH    SS
        POP     DS
        CALL    SWAPCON
        POP     DS
        MOV     SI,BX
        PUSH    CX
WRCONLP:
        LODSB
        CMP     AL,1AH          ; ^Z?
        JZ      SHORT CONEOF
        CALL	OUTT
        LOOP    WRCONLP
CONEOF:
        POP     AX                      ; Count
        SUB     AX,CX                   ; Amount actually written
        POP     DS
        CALL    SWAPBACK
        JMP     SHORT ENDWRDEV

DVWRTRAW:
        XOR     AX,AX                   ; Media Byte, unit = 0
        CALL	SETWRITE
        ;LDS     SI,[THISFCB]
        LDS     SI,[SS:THISFCB] ; 14/03/2018        
	CALL	DEVIOCALL
        MOV     DX,DI
        MOV     AH,87H
        ;MOV     DI,[DEVCALL_REQSTAT]
        MOV     DI,[SS:DEVCALL_REQSTAT] ; 14/03/2018        
	TEST    DI,STERR
        JZ      SHORT CWRTROK
        CALL	CHARHARD
        MOV     BX,DX                   ; Recall transfer addr
        CMP     AL,1
        JZ      SHORT DVWRTRAW		; Try again
CWRTROK:
        POP     DS
        MOV     AX,[CALLSCNT]           ; Get actual number of bytes transferred
ENDWRDEV:
        LES     DI,[THISFCB]
        XOR     DX,DX
        DIV     WORD [ES:DI+0EH]
        MOV     CX,AX                   ; Partial record is ignored
        call    ADDREC
	RETN

WRTDEV:
        OR      BL,40H          ; Reset EOF for input
        XOR     AX,AX
        JCXZ    ENDWRDEV        ; problem of creating on a device.
        PUSH    DS
        MOV     AL,BL
        LDS     BX,[DMAADD]
        MOV     DI,BX
        XOR     DX,DX                   ; Set starting point
        TEST    AL,020H                 ; Raw?
        JNZ     SHORT DVWRTRAW
        TEST    AL,ISCOUT               ; Console output device?
        JNZ     WRITECON
        TEST    AL,ISNULL
        JNZ     SHORT WRTNUL
        MOV     AX,DX
        CMP     BYTE [BX],1AH		; ^Z?
        JZ      SHORT WRTCOOKDONE	; Yes, transfer nothing
        PUSH    CX
        MOV     CX,1
        CALL	SETWRITE
        POP     CX
        ;LDS     SI,[THISFCB]
        LDS     SI,[SS:THISFCB] ; 14/03/2018
	LDS     SI,[SI+19H]
DVWRTLP:
        CALL	DSKSTATCHK
        CALL	DEVIOCALL2
        PUSH    DI
        MOV     AH,87H
        ;MOV     DI,[DEVCALL_REQSTAT]
        MOV     DI,[SS:DEVCALL_REQSTAT] ; 14/03/2018
        TEST    DI,STERR
        JZ      SHORT CWROK
        CALL	CHARHARD
        POP     DI
        ;MOV     WORD [CALLSCNT],1
        MOV     WORD [SS:CALLSCNT],1 ; 14/03/2018
        CMP     AL,1
        JZ      SHORT DVWRTLP
        JMP     SHORT DVWRTIGN
CWROK:
        POP     DI
        ;CMP     WORD [CALLSCNT],0
        CMP	WORD [SS:CALLSCNT],0 ; 14/03/2018
	JZ      SHORT WRTCOOKDONE
DVWRTIGN:
        INC     DX
	; 14/03/2018
        ;INC     WORD [CALLXAD]
        INC     WORD [SS:CALLXAD]
        INC     DI
        PUSH    DS
        ;MOV     DS,[CALLXAD+2]
        MOV     DS,[SS:CALLXAD+2]
        CMP     BYTE [DI],1AH       ; ^Z?
        POP     DS
        JZ      SHORT WRTCOOKDONE
        ;MOV     WORD [DEVCALL_REQSTAT],0
        MOV     WORD [SS:DEVCALL_REQSTAT],0
        LOOP    DVWRTLP
WRTCOOKDONE:
        MOV     AX,DX
        POP     DS
        JMP     ENDWRDEV

WRTNUL:
        MOV     DX,CX                   ;Entire transfer done
        JMP     SHORT WRTCOOKDONE

GET_IO_FCB:
; Convert JFN number in BX to FCB in DS:SI
        PUSH    SS
        POP     DS
        PUSH    ES
        PUSH    DI
        CALL	get_sf_from_jfn
        JC      SHORT RET44P
        MOV     SI,DI
        ADD     SI,SF_ENTRY.sf_fcb
        PUSH    ES
        POP     DS
RET44P:
        POP     DI
        POP     ES
        RETN

;SUBTTL GETTHISDRV -- FIND CURRENT DRIVE

GETTHISDRV:

; Input:    AL has drive identifier (1=A, 0=default)
; Output:   AL has physical drive (0=A)
; Carry set if invalid drive (and AL is garbage anyway)

	; 15/03/2018
        ;CMP     [NUMIO],AL
        CMP     [SS:NUMIO],AL
        JC	SHORT GETTHISDRIVE_RETN
        DEC     AL
        JNS     SHORT PHYDRV
        ;MOV     AL,[CURDRV]
        MOV     AL,[SS:CURDRV]
PHYDRV:
        ;MOV     [THISDRV],AL
        MOV     [SS:THISDRV],AL
GETTHISDRIVE_RETN:
        RETN

;SUBTTL DIRREAD -- READ A DIRECTORY SECTOR

DIRREAD:

; Inputs:
;       AX = Directory block number (relative to first block of directory)
;       ES:BP = Base of drive parameters
;       [DIRSEC] = First sector of first cluster of directory
;       [CLUSNUM] = Next cluster
;       [CLUSFAC] = Sectors/Cluster
; Function:
;       Read the directory block into [CURBUF].
; Outputs:
;       [NXTCLUSNUM] = Next cluster (after the one skipped to)
;       [SECCLUSPOS] Set
;       ES:BP unchanged [CURBUF] Points to Buffer with dir sector
; All other registers destroyed.

        MOV     CL,[CLUSFAC]
        DIV     CL              ; AL # clusters to skip, AH position in cluster
        MOV     [SECCLUSPOS],AH
        MOV     CL,AL
        XOR     CH,CH
        MOV     DX,[DIRSEC]
        ADD     DL,AH
        ADC     DH,0
        MOV     BX,[CLUSNUM]
        MOV     [NXTCLUSNUM],BX
        JCXZ    FIRSTCLUSTER
SKPCLLP:
        CALL	UNPACK
        XCHG    BX,DI
        CMP     BX,0FF8H
        JAE     SHORT HAVESKIPPED
        LOOP    SKPCLLP
HAVESKIPPED:
        MOV     [NXTCLUSNUM],BX
        MOV     DX,DI
        MOV     BL,AH
        CALL	FIGREC
FIRSTCLUSTER:
        XOR     AL,AL           ; Indicate pre-read
        MOV     AH,DIRPRI
        CALL	GETBUFFR
        RETN

;SUBTTL FATSECRD -- READ A FAT SECTOR

FATSECRD:

; Inputs:
;       Same as DREAD
;       DS:BX = Transfer address
;       CX = Number of sectors
;       DX = Absolute record number
;       ES:BP = Base of drive parameters
; Function:
;       Calls BIOS to perform FAT read.
; Outputs:
;       Same as DREAD

        MOV     DI,CX
        MOV     CL,[ES:BP+8]
        MOV     AL,[ES:BP+0FH]
        XOR     AH,AH
        MOV     CH,AH
        PUSH    DX
NXTFAT:
        PUSH    CX
        PUSH    AX
        MOV     CX,DI
        CALL    DSKREAD
        POP     AX
        POP     CX
        JZ      SHORT RET41P
        ADD     DX,AX
        LOOP    NXTFAT
        POP     DX
        MOV     CX,DI

; NOTE FALL THROUGH

;SUBTTL DREAD -- DO A DISK READ

DREAD:

; Inputs:
;       DS:BX = Transfer address
;       CX = Number of sectors
;       DX = Absolute record number
;       ES:BP = Base of drive parameters
; Function:
;       Calls BIOS to perform disk read. If BIOS reports
;       errors, will call HARDERR for further action.
; DS,ES:BP preserved. All other registers destroyed.

        CALL    DSKREAD
        JZ	SHORT DREAD_RETN
        ;MOV     BYTE [READOP],0
        MOV     BYTE [SS:READOP],0 ; 15/03/2018
        CALL	HARDERR
        CMP     AL,1            ; Check for retry
        JZ      SHORT DREAD
        RETN			; Ignore otherwise

RET41P: 
	POP     DX
DREAD_RETN:
        RETN

;SUBTTL DSKREAD -- PHYSICAL DISK READ

DSKREAD: 

; Inputs:
;       DS:BX = Transfer addr
;       CX = Number of sectors
;       DX = Absolute record number
;       ES:BP = Base of drive parameters
; Function:
;       Call BIOS to perform disk read
; Outputs:
;       DI = CX on entry
;       CX = Number of sectors unsuccessfully transfered
;       AX = Status word as returned by BIOS (error code in AL if error)
;       Zero set if OK (from BIOS)
;       Zero clear if error
; SI Destroyed, others preserved

        PUSH    CX
        MOV     AH,[ES:BP+16H]
        MOV     AL,[ES:BP+1]
        PUSH    BX
        PUSH    ES
        CALL	SETREAD
        JMP     SHORT DODSKOP

;SUBTTL DWRITE -- SEE ABOUT WRITING

DWRITE:

; Inputs:
;       DS:BX = Transfer address
;       CX = Number of sectors
;       DX = Absolute record number
;       ES:BP = Base of drive parameters
; Function:
;       Calls BIOS to perform disk write. If BIOS reports
;       errors, will call HARDERR for further action.
; BP preserved. All other registers destroyed.

        CALL    DSKWRITE
        JZ	SHORT DWRITE_RETN
        ;MOV     BYTE [READOP],1
        MOV	BYTE [SS:READOP],1 ; 14/03/22018
	CALL	HARDERR
        CMP     AL,1            ; Check for retry
        JZ      SHORT DWRITE
DWRITE_RETN:
        RETN

;SUBTTL DSKWRITE -- PHYSICAL DISK WRITE

DSKWRITE:

; Inputs:
;       DS:BX = Transfer addr
;       CX = Number of sectors
;       DX = Absolute record number
;       ES:BP = Base of drive parameters
; Function:
;       Call BIOS to perform disk read
; Outputs:
;       DI = CX on entry
;       CX = Number of sectors unsuccessfully transfered
;       AX = Status word as returned by BIOS (error code in AL if error)
;       Zero set if OK (from BIOS)
;       Zero clear if error
; SI Destroyed, others preserved

        PUSH    CX
        MOV     AH,[ES:BP+16H]
        MOV     AL,[ES:BP+1]
        PUSH    BX
        PUSH    ES
        CALL	SETWRITE
DODSKOP:
        MOV     CX,DS           ; Save DS
        POP     DS              ; DS:BP points to DPB
        PUSH    DS
        LDS     SI,[DS:BP+12H]
        CALL	DEVIOCALL2
        MOV     DS,CX           ; Restore DS
        POP     ES              ; Restore ES
        POP     BX
        ;MOV     CX,[CALLSCNT]   ; Number of sectors transferred
        MOV     CX,[SS:CALLSCNT] ; 14/03/2018	
        POP     DI
        SUB     CX,DI
        NEG     CX              ; Number of sectors not transferred
        ;MOV     AX,[DEVCALL_REQSTAT]
        MOV     AX,[SS:DEVCALL_REQSTAT] ; 14/03/2018
        TEST    AX,STERR
        RETN

SETUP:

; Inputs:
;       DS:DI point to FCB
;       DX:AX = Record position in file of disk transfer
;       CX = Record count
; Outputs:
;       DS = DOSGROUP
;       BL = fcb_DEVID from FCB
;       CX = No. of bytes to transfer  (0 = 64K)
;       [THISDPB] = Base of drive parameters
;       [RECCNT] = Record count
;       [RECPOS] = Record position in file
;       ES:DI Points to FCB
;       [THISFCB] = ES:DI
;       [NEXTADD] = Displacement of disk transfer within segment
;       [SECPOS] = Position of first sector
;       [BYTPOS] = Byte position in file
;       [BYTSECPOS] = Byte position in first sector
;       [CLUSNUM] = First cluster
;       [SECCLUSPOS] = Sector within first cluster
;       [DSKERR] = 0 (no errors yet)
;       [TRANS] = 0 (No transfers yet)
;       [THISDRV] = Physical drive unit number

        PUSH    AX
        MOV     AL,[DI]
        DEC     AL
	; 15/03/2018
        ;MOV     [THISDRV],AL
        MOV     [SS:THISDRV],AL
        MOV     AL,[DI+18H]
        MOV     SI,[DI+0EH]
        OR      SI,SI
        JNZ     SHORT HAVRECSIZ
        MOV     SI,128
        MOV     [DI+0EH],SI
HAVRECSIZ:
        ;MOV     [THISFCB+2],DS
        MOV     [SS:THISFCB+2],DS
        PUSH    SS
        POP     DS              ; Set DS to DOSGROUP
        MOV     [THISFCB],DI
        OR      AL,AL           ; Is it a device?
        JNS     SHORT NOTDEVICE
        XOR     AL,AL           ; Fake in drive 0 so we can get BP
NOTDEVICE:
        CALL	GETBP
        POP     AX
        JNC     SHORT CheckRecLen
        XOR     CX,CX
        MOV     BYTE [DSKERR],4
        POP     BX
        RETN

CheckRecLen:
        CMP     SI,64           ; Check if highest byte of RECPOS is significant
        JB      SHORT SMALREC
        XOR     DH,DH           ; Ignore MSB if record >= 64 bytes
SMALREC:
        MOV     [RECCNT],CX
        MOV     [RECPOS],AX
        MOV     [RECPOS+2],DX
        MOV     BX,[DMAADD]
        MOV     [NEXTADD],BX
        MOV     BYTE [DSKERR],0
        MOV     BYTE [TRANS],0
        MOV     BX,DX
        MUL     SI
        MOV     [BYTPOS],AX
        PUSH    DX
        MOV     AX,BX
        MUL     SI
        POP     BX
        ADD     AX,BX
        ADC     DX,0            ; Ripple carry
        JNZ     SHORT EOFERR
        MOV     [BYTPOS+2],AX
        MOV     DX,AX
        MOV     AX,[BYTPOS]
        MOV     BX,[ES:BP+2]
        CMP     DX,BX           ; See if divide will overflow
        JNC     SHORT EOFERR
        DIV     BX
        MOV     [SECPOS],AX
        MOV     [BYTSECPOS],DX
        MOV     DX,AX
        AND     AL,[ES:BP+4]
        MOV     [SECCLUSPOS],AL
        MOV     AX,CX           ; Record count
        MOV     CL,[ES:BP+5]
        SHR     DX,CL
        MOV     [CLUSNUM],DX
        MUL     SI              ; Multiply by bytes per record
        MOV     CX,AX
        ADD     AX,[DMAADD]     ; See if it will fit in one segment
        ADC     DX,0
        JZ      SHORT OK	; Must be less than 64K
        MOV     AX,[DMAADD]
        NEG     AX              ; Amount of room left in segment
        JNZ     SHORT PARTSEG
        DEC     AX
PARTSEG:
        XOR     DX,DX
        DIV     SI              ; How many records will fit?
        MOV     [RECCNT],AX
        MUL     SI              ; Translate that back into bytes
        MOV     BYTE [DSKERR],2	; Flag that trimming took place
        MOV     CX,AX
        JCXZ    NOROOM
OK:
        LES     DI,[THISFCB]
        MOV     BL,[ES:DI+18H]
        RETN

EOFERR:
        MOV     BYTE [DSKERR],1
        XOR     CX,CX
NOROOM:
        LES     DI,[THISFCB]
        POP     BX              ; Kill return address
        RETN

;SUBTTL BREAKDOWN -- CUT A USER READ OR WRITE INTO PIECES

BREAKDOWN:

; Inputs:
;       CX = Length of disk transfer in bytes
;       ES:BP = Base of drive parameters
;       [BYTSECPOS] = Byte position within first sector
; Outputs:
;       [BYTCNT1] = Bytes to transfer in first sector
;       [SECCNT] = No. of whole sectors to transfer
;       [BYTCNT2] = Bytes to transfer in last sector
; AX, BX, DX destroyed. No other registers affected.

        MOV     AX,[BYTSECPOS]
        MOV     BX,CX
        OR      AX,AX
        JZ      SHORT SAVFIR	; Partial first sector?
        SUB     AX,[ES:BP+2]
        NEG     AX              ; Max number of bytes left in first sector
        SUB     BX,AX           ; Subtract from total length
        JAE     SHORT SAVFIR
        ADD     AX,BX           ; Don't use all of the rest of the sector
        XOR     BX,BX           ; And no bytes are left
SAVFIR:
        MOV     [BYTCNT1],AX
        MOV     AX,BX
        XOR     DX,DX
        DIV     WORD [ES:BP+2]  ; How many whole sectors?
        MOV     [SECCNT],AX
        MOV     [BYTCNT2],DX    ; Bytes remaining for last sector
        OR      DX,[BYTCNT1]
        JNZ	SHORT BREAKDOWN_RETN ; NOT (BYTCNT1 = BYTCNT2 = 0)
        CMP     AX,1
        JNZ	SHORT BREAKDOWN_RETN
        MOV     AX,[ES:BP+2] ; Buffer EXACT one sector I/O
        MOV     [BYTCNT2],AX
        MOV     [SECCNT],DX	; DX = 0
BREAKDOWN_RETN:
	RETN

;SUBTTL DISKREAD -- PERFORM USER DISK READ

DISKREAD:

; Inputs:
;       Outputs of SETUP
; Function:
;       Perform disk read
; Outputs:
;       DX:AX = Position of last record read
;       CX = No. of records read
;       ES:DI point to FCB
;       fcb_LSTCLUS, fcb_CLUSPOS fields in FCB set

        MOV     AX,[ES:DI+10H]
        MOV     BX,[ES:DI+12H]
        SUB     AX,[BYTPOS]
        SBB     BX,[BYTPOS+2]
        JB      SHORT RDERR
        JNZ     SHORT ENUF
        OR      AX,AX
        JZ      SHORT RDERR
        CMP     AX,CX
        JAE     SHORT ENUF
        MOV     CX,AX
ENUF:
        LES     BP,[THISDPB]
        CALL    BREAKDOWN
        MOV     CX,[CLUSNUM]
        CALL	FNDCLUS
        OR      CX,CX
        JZ      SHORT SKIPERR
RDERR:
        JMP     WRTERR
RDLASTJ:
	JMP	RDLAST
SETFCBJ2:
	JMP	SETFCB

SKIPERR:

        MOV     [LASTPOS],DX
        MOV     [CLUSNUM],BX
        CMP     WORD [BYTCNT1],0
        JZ      SHORT RDMID
        CALL	BUFRD
RDMID:
        CMP     WORD [SECCNT],0
        JZ      SHORT RDLASTJ
        CALL	NEXTSEC
        JC      SHORT SETFCBJ2
        MOV     BYTE [TRANS],1      ; A transfer is taking place
ONSEC:
        MOV     DL,[SECCLUSPOS]
        MOV     CX,[SECCNT]
        MOV     BX,[CLUSNUM]
RDLP:
        CALL	OPTIMIZE
        PUSH    DI
        PUSH    AX
        PUSH    BX
        MOV     DS,[DMAADD+2]
        PUSH    DX
        PUSH    CX
        CALL    DREAD
        POP     BX
        POP     DX
        ADD     BX,DX           ; Upper bound of read
        MOV     AL,[ES:BP+0]
        CALL	SETVISIT
NXTBUF:                         ; Must see if one of these sectors is buffered
        MOV     BYTE [DI+7],1  ; Mark as visited
        CMP     AL,[DI+4]
        JNZ     SHORT DONXTBUF	; Not for this drive
        CMP     [DI+8],DX
        JC      SHORT DONXTBUF	; Below first sector
        CMP     [DI+8],BX
        JNC     SHORT DONXTBUF	; Above last sector
        CMP     BYTE [DI+5],0
        JZ      SHORT CLBUFF	; Buffer is clean, so OK
; A sector has been read in when a dirty copy of it is in a buffer
; The buffered sector must now be read into the right place
        POP     AX              ; Recall transfer address
        PUSH    AX
        PUSH    DI              ; Save search environment
        PUSH    DX
        SUB     DX,[DI+8] ; How far into transfer?
        NEG     DX
        MOV     SI,DI
        MOV     DI,AX
        MOV     AX,DX
        MOV     CX,[ES:BP+2]
        MUL     CX
        ADD     DI,AX           ; Put the buffer here
        ADD     SI,BUFINSIZ
        SHR     CX,1
        PUSH    ES
        ;MOV     ES,[DMAADD+2]
        MOV     ES,[SS:DMAADD+2] ; 15/03/2018
        REP     MOVSW
        JNC     SHORT EVENMOV
        MOVSB
EVENMOV:
        POP     ES
        POP     DX
        POP     DI
        MOV     AL,[ES:BP+0]
CLBUFF:
        CALL	SCANPLACE
DONXTBUF:
        CALL	SKIPVISIT
        JNZ     SHORT NXTBUF
        PUSH    SS
        POP     DS
        POP     CX
        POP     CX
        POP     BX
        JCXZ    RDLAST
        CMP     BX,0FF8H
        JAE     SHORT SETFCB
        MOV     DL,0
        INC     WORD [LASTPOS]	; We'll be using next cluster
        JMP     SHORT RDLP

RDLAST:
        MOV     AX,[BYTCNT2]
        OR      AX,AX
        JZ      SHORT SETFCB
        MOV     [BYTCNT1],AX
        CALL	NEXTSEC
        JC      SHORT SETFCB
        MOV     WORD [BYTSECPOS],0
        CALL	BUFRD

SETFCB:
        LES     SI,[THISFCB]
        MOV     AX,[NEXTADD]
        MOV     DI,AX
        SUB     AX,[DMAADD]     ; Number of bytes transfered
        XOR     DX,DX
        MOV     CX,[ES:SI+0EH]
        DIV     CX              ; Number of records
        CMP     AX,[RECCNT]     ; Check if all records transferred
        JZ	SHORT FULLREC
        MOV     BYTE [DSKERR],1
        OR      DX,DX
        JZ      SHORT FULLREC	; If remainder 0, then full record transfered
        MOV     BYTE [DSKERR],3	; Flag partial last record
        SUB     CX,DX           ; Bytes left in last record
        PUSH    ES
        MOV     ES,[DMAADD+2]
        XCHG    AX,BX           ; Save the record count temporarily
        XOR     AX,AX           ; Fill with zeros
        SHR     CX,1
        JNC     SHORT EVENFIL
        STOSB
EVENFIL:
        REP     STOSW
        XCHG    AX,BX           ; Restore record count to AX
        POP     ES
        INC     AX              ; Add last (partial) record to total
FULLREC:
        MOV     CX,AX
        MOV     DI,SI           ; ES:DI point to FCB
SETCLUS:
        TEST    BYTE [ES:DI+18H],-1
        JS      SHORT ADDREC	; don't set clisters if device
        MOV     AX,[CLUSNUM]
        AND     WORD [ES:DI+1DH],0F000h 
				; fcb_lstclus is packed with dir clus
        OR      [ES:DI+1DH],AX ; drop in the correct part of fcb_lstclus
        MOV     AX,[LASTPOS]
        MOV     [ES:DI+1BH],AX
ADDREC:
        MOV     AX,[RECPOS]
        MOV     DX,[RECPOS+2]
        JCXZ    RET28           ; If no records read, don't change position
        DEC     CX
        ADD     AX,CX           ; Update current record position
        ADC     DX,0
        INC     CX
RET28:  
	RETN

;SUBTTL DISKWRITE -- PERFORM USER DISK WRITE

DISKWRITE:

; Inputs:
;       Outputs of SETUP
; Function:
;       Perform disk write
; Outputs:
;       DX:AX = Position of last record written
;       CX = No. of records written
;       ES:DI point to FCB
;       fcb_LSTCLUS, fcb_CLUSPOS fields in FCB set

        AND     BL,3FH          ; Mark file as dirty
        MOV     [ES:DI+18H],BL
        LES     BP,[THISDPB]
        CALL    BREAKDOWN
        MOV     AX,[BYTPOS]
        MOV     DX,[BYTPOS+2]
        JCXZ    WRTEOFJ
        ADD     AX,CX
        ADC     DX,0            ; AX:DX=last byte accessed
        DIV     WORD [ES:BP+2] ; AX=last sector accessed
        MOV     BX,AX           ; Save last full sector
        OR      DX,DX
        JNZ     SHORT CALCLUS
        DEC     AX              ; AX must be zero base indexed
CALCLUS:
        MOV     CL,[ES:BP+5]
        SHR     AX,CL           ; Last cluster to be accessed
        PUSH    AX
        PUSH    DX              ; Save the size of the "tail"
        PUSH    ES
        LES     DI,[THISFCB]
        MOV     AX,[ES:DI+10H]
        MOV     DX,[ES:DI+12H]
        POP     ES
        DIV     WORD [ES:BP+2]
        MOV     CX,AX           ; Save last full sector of current file
        OR      DX,DX
        JZ      SHORT NORNDUP
        INC     AX              ; Round up if any remainder
NORNDUP:
        MOV     [VALSEC],AX     ; Number of sectors that have been written
        XOR     AX,AX
        MOV     [GROWCNT],AX
        MOV     [GROWCNT+2],AX
        POP     AX
        SUB     BX,CX           ; Number of full sectors
        JB      SHORT NOGROW
        JZ      SHORT TESTTAIL
        MOV     CX,DX
        XCHG    AX,BX
        MUL     WORD [ES:BP+2] ; Bytes of full sector growth
        SUB     AX,CX           ; Take off current "tail"
        SBB     DX,0            ; 32-bit extension
        ADD     AX,BX           ; Add on new "tail"
        ADC     DX,0            ; ripple tim's head off
        JMP     SHORT SETGRW

HAVSTART:
        MOV     CX,AX
        CALL	SKPCLP
        ;JCXZ    DOWRTJ
        JCXZ	DOWRT ; 15/03/2018
	CALL	ALLOCATE
        ;JNC     SHORT DOWRTJ
	JNC	SHORT DOWRT ; 15/03/2018
WRTERR:
        XOR     CX,CX
        MOV     BYTE [DSKERR],1
        MOV     AX,[RECPOS]
        MOV     DX,[RECPOS+2]
        LES     DI,[THISFCB]
        RETN

;DOWRTJ: 
;	JMP	SHORT DOWRT

WRTEOFJ:
        JMP	WRTEOF

TESTTAIL:
        SUB     AX,DX
        JBE     SHORT NOGROW
        XOR     DX,DX
SETGRW:
        MOV     [GROWCNT],AX
        MOV     [GROWCNT+2],DX
NOGROW:
        POP     AX
        MOV     CX,[CLUSNUM]    ; First cluster accessed
        CALL	FNDCLUS
        MOV     [CLUSNUM],BX
        MOV     [LASTPOS],DX
        SUB     AX,DX           ; Last cluster minus current cluster
        JZ      SHORT DOWRT	; If we have last clus, we must have first
        JCXZ    HAVSTART        ; See if no more data
        PUSH    CX              ; No. of clusters short of first
        MOV     CX,AX
        CALL	ALLOCATE
        POP     AX
        JC      SHORT WRTERR
        MOV     CX,AX
        MOV     DX,[LASTPOS]
        INC     DX
        DEC     CX
        JZ      SHORT NOSKIP
        CALL	SKPCLP
NOSKIP:
        MOV     [CLUSNUM],BX
        MOV     [LASTPOS],DX
DOWRT:
        CMP     WORD [BYTCNT1],0
        JZ      SHORT WRTMID
        MOV     BX,[CLUSNUM]
        CALL	BUFWRT
WRTMID:
        MOV     AX,[SECCNT]
        OR      AX,AX
        JZ      SHORT WRTLAST
        ADD     [SECPOS],AX
        CALL	NEXTSEC
        MOV     BYTE [TRANS],1	; A transfer is taking place
        MOV     DL,[SECCLUSPOS]
        MOV     BX,[CLUSNUM]
        MOV     CX,[SECCNT]
WRTLP:
        CALL	OPTIMIZE
        PUSH    DI
        PUSH    AX
        PUSH    DX
        PUSH    BX
        MOV     AL,[ES:BP+0]
        MOV     BX,CX
        ADD     BX,DX           ; Upper bound of write
        CALL	SETVISIT
NEXTBUFF:                       ; Search for buffers
        MOV     BYTE [DI+7],1 ; Mark as visited
        CMP     AL,[DI+4]
        JNZ     SHORT DONEXTBUFF  ; Not for this drive
        CMP     [DI+8],DX
        JC      SHORT DONEXTBUFF  ; Buffer is not in range of write
        CMP     [DI+8],BX
        JNC     SHORT DONEXTBUFF  ; Buffer is not in range of write
        MOV     WORD [DI+4],00FFH
				; Free the buffer, it is being over written
        CALL	SCANPLACE
DONEXTBUFF:
        CALL	SKIPVISIT
        JNZ     SHORT NEXTBUFF
        POP     BX
        POP     DX
        ;MOV     DS,[DMAADD+2]
        MOV     DS,[SS:DMAADD+2] ; 15/03/2018
        CALL    DWRITE
        POP     CX
        POP     BX
        PUSH    SS
        POP     DS
        JCXZ    WRTLAST
        MOV     DL,0
        INC     WORD [LASTPOS]	; We'll be using next cluster
        JMP     SHORT WRTLP

WRTERRJ: 
	JMP     WRTERR

WRTLAST:
        MOV     AX,[BYTCNT2]
        OR      AX,AX
        JZ      SHORT FINWRT
        MOV     [BYTCNT1],AX
        CALL	NEXTSEC
        MOV     WORD [BYTSECPOS],0
        CALL	BUFWRT
FINWRT:
        LES     DI,[THISFCB]
        MOV     AX,[GROWCNT]
        MOV     CX,[GROWCNT+2]
        OR      AX,AX
        JNZ     SHORT UPDATE_size
        OR      CX,CX
        JZ      SHORT SAMSIZ
UPDATE_size:
        ADD     [ES:DI+10H],AX
        ADC     [ES:DI+12H],CX
SAMSIZ:
        MOV     CX,[RECCNT]
        JMP     SETCLUS

WRTEOF:
        MOV     CX,AX
        OR      CX,DX
        JZ      SHORT KILLFIL
        SUB     AX,1
        SBB     DX,0
        DIV     WORD [ES:BP+2]
        MOV     CL,[ES:BP+5]
        SHR     AX,CL
        MOV     CX,AX
        CALL	FNDCLUS
        JCXZ    RELFILE
        CALL	ALLOCATE
        JC      SHORT WRTERRJ
UPDATE:
        LES     DI,[THISFCB]
        MOV     AX,[BYTPOS]
        MOV     [ES:DI+10H],AX
        MOV     AX,[BYTPOS+2]
        MOV     [ES:DI+12H],AX
        XOR     CX,CX
        JMP     ADDREC

RELFILE:
        MOV     DX,0FFFH
        CALL	RELBLKS
        JMP     SHORT UPDATE

KILLFIL:
        XOR     BX,BX
        PUSH    ES
        LES     DI,[THISFCB]
        MOV     [ES:DI+1BH],BX
        XCHG    BX,[ES:DI+19H]
        AND     WORD [ES:DI+1DH],0F000H
        POP     ES
        OR      BX,BX
        JZ      SHORT UPDATE
        CALL	RELEASE
        JMP     SHORT UPDATE

;CODE    ENDS
;    END

;============================================================================
; FAT.ASM
;============================================================================
; Retro	DOS v2.0 - 13/03/2018

;
; FAT operations for MSDOS
;

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;        ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE	FAT - FAT maintenance routines
;NAME	FAT

;SUBTTL UNPACK -- UNPACK FAT ENTRIES

UNPACK:

; Inputs:
;       BX = Cluster number
;       ES:BP = Base of drive parameters
; Outputs:
;       DI = Contents of FAT for given cluster
;       Zero set means DI=0 (free cluster)
; SI Destroyed, No other registers affected. Fatal error if cluster too big.

        CMP     BX,[ES:BP+0DH]
        JA      SHORT HURTFAT
        CALL    MAPCLUSTER
        MOV     DI,[DI]
        JNC     SHORT HAVCLUS
        PUSH    CX
        MOV     CL,4
        SHR     DI,CL
        POP     CX
        STC
HAVCLUS:
        AND     DI,0FFFH
        PUSH    SS
        POP     DS
        RETN

HURTFAT:
        PUSH    AX
        MOV     AH,80H          ; Signal Bad FAT to INT int_fatal_abort handler
        MOV     DI,0FFFH        ; In case INT int_fatal_abort returns (it shouldn't)
        CALL	FATAL
        POP     AX              ; Try to ignore bad FAT
;UNPACK_RETN:
        RETN

;SUBTTL PACK -- PACK FAT ENTRIES

PACK:

; Inputs:
;       BX = Cluster number
;       DX = Data
;       ES:BP = Pointer to drive DPB
; Outputs:
;       The data is stored in the FAT at the given cluster.
;       SI,DX,DI all destroyed
;       No other registers affected

        CALL    MAPCLUSTER
        MOV     SI,[DI]
        JNC     SHORT ALIGNED
        PUSH    CX
        MOV     CL,4
        SHL     DX,CL
        POP     CX
        AND     SI,0FH
        JMP     SHORT PACKIN
ALIGNED:
        AND     SI,0F000H
PACKIN:
        OR      SI,DX
        MOV     [DI],SI
        ;LDS     SI,[CURBUF]
        LDS	SI, [SS:CURBUF]
	MOV     BYTE [SI+5],1
        ;CMP     BYTE [CLUSSPLIT],0
	CMP     BYTE [SS:CLUSSPLIT],0
        PUSH    SS
        POP     DS
	;retz
	;JZ	SORT UNPACK_RETN
	JZ	SHORT PACK_RETN
        PUSH    AX
        PUSH    BX
        PUSH    CX
        MOV     AX,[CLUSSAVE]
        MOV     DS,[CURBUF+2]
        ADD     SI,BUFINSIZ
        MOV     [SI],AH
        PUSH    SS
        POP     DS
        PUSH    AX
        MOV     DX,[CLUSSEC]
        MOV     SI,1
        XOR     AL,AL
        ;invoke  GETBUFFRB
        CALL	GETBUFFRB
	LDS     DI,[CURBUF]
        MOV     BYTE [DI+5],1
        ADD     DI,BUFINSIZ
        DEC     DI
        ADD     DI,[ES:BP+2]
        POP     AX
        MOV     [DI],AL
        PUSH    SS
        POP     DS
        POP     CX
        POP     BX
        POP     AX
PACK_RETN:
        RETN

;SUBTTL MAPCLUSTER - BUFFER A FAT SECTOR

MAPCLUSTER:

; Inputs:
;       ES:BP Points to DPB
;       BX Is cluster number
; Function:
;       Get a pointer to the cluster
; Outputs:
;       DS:DI Points to contents of FAT for given cluster
;       DS:SI Points to start of buffer
;       Carry set if cluster data is in high 12 bits of word
; No other registers effected

        MOV     BYTE [CLUSSPLIT],0
        PUSH    AX
        PUSH    BX
        PUSH    CX
        PUSH    DX
        MOV     AX,BX
        SHR     AX,1
        ADD     AX,BX
        XOR     DX,DX
        MOV     CX,[ES:BP+2]
        DIV     CX	; AX is FAT sector # DX is sector index
        ADD     AX,[ES:BP+6]
        DEC     CX
        PUSH    AX
        PUSH    DX
        PUSH    CX
        MOV     DX,AX
        XOR     AL,AL
        MOV     SI,1
        CALL	GETBUFFRB
        LDS     SI,[CURBUF]
        LEA     DI,[SI+10H]
        POP     CX
        POP     AX
        POP     DX
        ADD     DI,AX
        CMP     AX,CX
        JNZ     SHORT MAPRET
        MOV     AL,[DI]
        PUSH    SS
        POP     DS
        INC     BYTE [CLUSSPLIT]
        MOV     [CLUSSAVE],AL
        MOV     [CLUSSEC],DX
        INC     DX
        XOR     AL,AL
        MOV     SI,1
	CALL	GETBUFFRB
        LDS     SI,[CURBUF]
        LEA     DI,[SI+10H]
        MOV     AL,[DI]
        PUSH    SS
        POP     DS
        MOV     [CLUSSAVE+1],AL
        MOV     DI,CLUSSAVE
MAPRET:
        POP     DX
        POP     CX
        POP     BX
        MOV     AX,BX
        SHR     AX,1
        POP     AX
	RETN

;SUBTTL FATREAD -- CHECK DRIVE GET FAT

FAT_operation:

FATERR:
        AND     DI,STECODE      ; Put error code in DI
        MOV     AH,2            ; While trying to read FAT
        MOV     AL,[THISDRV]    ; Tell which drive
	CALL	FATAL1

FATREAD:

; Function:
;       If disk may have been changed, FAT is read in and buffers are
;       flagged invalid. If not, no action is taken.
; Outputs:
;       ES:BP = Base of drive parameters
; All other registers destroyed

        MOV     AL,[THISDRV]
	CALL	GETBP
        MOV     AL,DMEDHL
        MOV     AH,[ES:BP+1]
        MOV     [DEVCALL],AX
        MOV     BYTE [DEVCALL_REQFUNC],DEVMDCH
        MOV     WORD [DEVCALL_REQSTAT],0
        MOV     AL,[ES:BP+16H]
        MOV     [CALLMED],AL
        PUSH    ES
        PUSH    DS
        MOV     BX,DEVCALL
        LDS     SI,[ES:BP+12H] ; DS:SI Points to device header
        POP     ES                      ; ES:BX Points to call header
	CALL	DEVIOCALL2
        PUSH    SS
        POP     DS
        POP     ES                      ; Restore ES:BP

        MOV     DI,[DEVCALL_REQSTAT]
        TEST    DI,STERR
        JNZ     SHORT FATERR

        XOR     AH,AH
        XCHG    AH,[ES:BP+17H] ; Reset dpb_first_access
        MOV     AL,[THISDRV]	; Use physical unit number
        OR      AH,[CALLRBYT]
        JS      SHORT NEWDSK	; new disk or first access?
        JZ      SHORT CHKBUFFDIRT
FATREAD_RETN1:
        RETN			; If Media not changed
CHKBUFFDIRT:
        INC     AH              ; Here if ?Media..Check buffers
        LDS     DI,[BUFFHEAD]
NBUFFER:                        ; Look for dirty buffers
        CMP     AX,[DI+4]
        ;retz			; There is a dirty buffer, assume Media OK
        JZ	SHORT FATREAD_RETN1
	LDS     DI,[DI]
        CMP     DI,-1
        JNZ     SHORT NBUFFER
; If no dirty buffers, assume Media changed
NEWDSK:
        CALL	SETVISIT
NXBUFFER:
        MOV     BYTE [DI+7],1
        CMP     AL,[DI+4]	; For this drive?
        JNZ     SHORT SKPBUFF
        MOV     WORD [DI+4],00FFH  ; Free up buffer
	CALL	SCANPLACE
SKPBUFF:
        CALL	SKIPVISIT
        JNZ     SHORT NXBUFFER
        LDS     DI,[ES:BP+12H]
        TEST    WORD [DI+4],ISFATBYDEV
        JNZ     SHORT GETFREEBUF
        ;context DS
        PUSH	SS
	POP	DS
	MOV     BX,2
        CALL    UNPACK                  ; Read the first FAT sector into  CURBUF
        LDS     DI,[CURBUF]
        JMP     SHORT GOTGETBUF
GETFREEBUF:
        PUSH    ES                      ; Get a free buffer for BIOS to use
        PUSH    BP
        ;LDS     DI,[BUFFHEAD]
        LDS	DI,[SS:BUFFHEAD]
	CALL	BUFWRITE
        POP     BP
        POP     ES
GOTGETBUF:
        ADD     DI,BUFINSIZ
        ;MOV     [CALLXAD+2],DS
        MOV     [SS:CALLXAD+2],DS
        PUSH    SS
        POP     DS
        MOV     [CALLXAD],DI
        MOV     AL,DBPBHL
        MOV     AH,[ES:BP+1]
        MOV     [DEVCALL],AX
        MOV     BYTE [DEVCALL_REQFUNC],DEVBPB
        MOV     WORD [DEVCALL_REQSTAT],0
        MOV     AL,[ES:BP+16H]
        MOV     [CALLMED],AL
        PUSH    ES
        PUSH    DS
        PUSH    WORD [ES:BP+14H]
        PUSH    WORD [ES:BP+12H]
        MOV     BX,DEVCALL
        POP     SI
        POP     DS                      ; DS:SI Points to device header
        POP     ES                      ; ES:BX Points to call header
	CALL	DEVIOCALL2
        POP     ES                      ; Restore ES:BP
        PUSH    SS
        POP     DS
        MOV     DI,[DEVCALL_REQSTAT]
        TEST    DI,STERR
        JNZ     SHORT FATERRJ
        MOV     AL,[ES:BP+16H]
        LDS     SI,[CALLBPB]
        CMP     AL,[SI+0AH]
        JZ      SHORT DPBOK
	CALL	_$SETDPB
        ;LDS     DI,[CALLXAD]            ; Get back buffer pointer
        LDS     DI,[SS:CALLXAD] ; 15/03/2018
	MOV     AL,[ES:BP+8]
        MOV     AH,[ES:BP+0FH]
        MOV     [DI-6],AX 		;Correct buffer info
DPBOK:
        ;context ds
        PUSH	SS
	POP	DS
	MOV     AX,-1
        TEST    [ES:BP+1CH],AX
        ;retz				; If root, leave as root
	JZ	SHORT FATREAD_RETN2
        MOV     [ES:BP+1CH],AX ; Path may be bad, mark invalid
FATREAD_RETN2:
	RETN

FATERRJ: 
	JMP	FATERR

;CODE	ENDS
;   END

;============================================================================
; ROM.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

; Disk utilities of MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE   ROM - miscellaneous routines
;NAME    ROM

GET_random_record:
GETRRPOS1:
        MOV     CX,1
GETRRPOS:
        MOV     DI,DX
        CMP     BYTE [DI],-1
        JNZ     short NORMFCB1
        ADD     DI,7
NORMFCB1:
        MOV     AX,[DI+21H]
        MOV     DX,[DI+23H]
	RETN

;SUBTTL FNDCLUS -- Skip over allocation units
;PAGE

FNDCLUS:

; Inputs:
;       CX = No. of clusters to skip
;       ES:BP = Base of drive parameters
;       [THISFCB] point to FCB
; Outputs:
;       BX = Last cluster skipped to
;       CX = No. of clusters remaining (0 unless EOF)
;       DX = Position of last cluster
; DI destroyed. No other registers affected.

        PUSH    ES
        LES     DI,[THISFCB]
        MOV     BX,[ES:DI+1DH]  
				; fcb_lstclus is packed with dir clus
        AND     BX,0FFFh	; get rid of dir nibble
        MOV     DX,[ES:DI+1BH]
        OR      BX,BX
        JZ      SHORT NOCLUS
        SUB     CX,DX
        JNB     SHORT FINDIT
        ADD     CX,DX
        XOR     DX,DX
        MOV     BX,[ES:DI+19H]
FINDIT:
        POP     ES
        JCXZ    RET10
SKPCLP:
	CALL	UNPACK
        CMP     DI,0FF8H
        JAE     SHORT RET10
        XCHG    BX,DI
        INC     DX
        LOOP    SKPCLP
RET10:  
	RETN

NOCLUS:
        POP     ES
        INC     CX
        DEC     DX
	RETN

;SUBTTL BUFSEC -- BUFFER A SECTOR AND SET UP A TRANSFER
;PAGE

BUFSEC:

; Inputs:
;       AH = priority of buffer
;       AL = 0 if buffer must be read, 1 if no pre-read needed
;       ES:BP = Base of drive parameters
;       [CLUSNUM] = Physical cluster number
;       [SECCLUSPOS] = Sector position of transfer within cluster
;       [BYTCNT1] = Size of transfer
; Function:
;       Insure specified sector is in buffer, flushing buffer before
;       read if necessary.
; Outputs:
;       ES:DI = Pointer to buffer
;       SI = Pointer to transfer address
;       CX = Number of bytes
;       [NEXTADD] updated
;       [TRANS] set to indicate a transfer will occur

        MOV     DX,[CLUSNUM]
        MOV     BL,[SECCLUSPOS]
        CALL    FIGREC
	CALL	GETBUFFR
        MOV     BYTE [TRANS],1		; A transfer is taking place
        MOV     SI,[NEXTADD]
        MOV     DI,SI
        MOV     CX,[BYTCNT1]
        ADD     DI,CX
        MOV     [NEXTADD],DI
        LES     DI,[CURBUF]
        ADD     DI,BUFINSIZ             ; Point to buffer
        ADD     DI,[BYTSECPOS]
	RETN

;SUBTTL BUFRD, BUFWRT -- PERFORM BUFFERED READ AND WRITE
;PAGE

BUFRD:

; Do a partial sector read via one of the system buffers
; ES:BP Points to DPB

        PUSH    ES
	;MOV	AX,LBRPRI SHL 8		; Assume last byte read
	MOV	AX,LBRPRI*256
        CALL    BUFSEC
        MOV     BX,ES
        MOV     ES,[DMAADD+2]
        MOV     DS,BX
        XCHG    DI,SI
        SHR     CX,1
        JNC     SHORT EVENRD
        MOVSB
EVENRD:
        REP     MOVSW
        POP     ES
        ;LDS     DI,[CURBUF]
        LDS     DI,[SS:CURBUF] ; 15/03/2018
        LEA     BX,[DI+10H]
        SUB     SI,BX                   ; Position in buffer
        CALL	PLACEBUF
        CMP     SI,[ES:BP+2]
        JB      SHORT RBUFPLACED
        CALL	PLACEHEAD
RBUFPLACED:
        PUSH    SS
        POP     DS
	RETN

BUFWRT:

; Do a partial sector write via one of the system buffers
; ES:BP Points to DPB

        MOV     AX,[SECPOS]
        INC     AX              ; Set for next sector
        MOV     [SECPOS],AX
        CMP     AX,[VALSEC]     ; Has sector been written before?
        MOV     AL,1
        JA      SHORT NOREAD	; Skip preread if SECPOS>VALSEC
        XOR     AL,AL
NOREAD:
        PUSH    ES
        CALL    BUFSEC
        MOV     DS,[DMAADD+2]
        SHR     CX,1
        JNC     SHORT EVENWRT
        MOVSB
EVENWRT:
        REP     MOVSW
        POP     ES
        ;LDS     BX,[CURBUF]
        LDS     BX,[SS:CURBUF] ; 15/03/2018
	MOV     BYTE [BX+5],1
        LEA     SI,[BX+10H]
        SUB     DI,SI                   ; Position in buffer
        MOV     SI,DI
        MOV     DI,BX
        CALL	PLACEBUF
        CMP     SI,[ES:BP+2]
        JB      SHORT WBUFPLACED
        CALL	PLACEHEAD
WBUFPLACED:
        PUSH    SS
        POP     DS
	RETN

;SUBTTL NEXTSEC -- Compute next sector to read or write
;PAGE

NEXTSEC:

; Compute the next sector to read or write
; ES:BP Points to DPB

        TEST    BYTE [TRANS],-1
        JZ      SHORT CLRET
        MOV     AL,[SECCLUSPOS]
        INC     AL
        CMP     AL,[ES:BP+4]
        JBE     SHORT SAVPOS
        MOV     BX,[CLUSNUM]
        CMP     BX,0FF8H
        JAE	SHORT NONEXT
	CALL	UNPACK
        MOV     [CLUSNUM],DI
        INC     WORD [LASTPOS]
        MOV     AL,0
SAVPOS:
        MOV     [SECCLUSPOS],AL
CLRET:
        CLC
        RETN
NONEXT:
        STC
        RETN

;SUBTTL OPTIMIZE -- DO A USER DISK REQUEST WELL
;PAGE

OPTIMIZE:

; Inputs:
;       BX = Physical cluster
;       CX = No. of records
;       DL = sector within cluster
;       ES:BP = Base of drives parameters
;       [NEXTADD] = transfer address
; Outputs:
;       AX = No. of records remaining
;       BX = Transfer address
;       CX = No. or records to be transferred
;       DX = Physical sector address
;       DI = Next cluster
;       [CLUSNUM] = Last cluster accessed
;       [NEXTADD] updated
; ES:BP unchanged. Note that segment of transfer not set.

        PUSH    DX
        PUSH    BX
        MOV     AL,[ES:BP+4]
        INC     AL              ; Number of sectors per cluster
        MOV     AH,AL
        SUB     AL,DL           ; AL = Number of sectors left in first cluster
        MOV     DX,CX
        MOV     CX,0

OPTCLUS:
; AL has number of sectors available in current cluster
; AH has number of sectors available in next cluster
; BX has current physical cluster
; CX has number of sequential sectors found so far
; DX has number of sectors left to transfer
; ES:BP Points to DPB
; ES:SI has FAT pointer

	CALL	UNPACK
        ADD     CL,AL
        ADC     CH,0
        CMP     CX,DX
        JAE     SHORT BLKDON
        MOV     AL,AH
        INC     BX
        CMP     DI,BX
        JZ      SHORT OPTCLUS
        DEC     BX
FINCLUS:
        MOV     [CLUSNUM],BX    ; Last cluster accessed
        SUB     DX,CX           ; Number of sectors still needed
        PUSH    DX
        MOV     AX,CX
        MUL     WORD [ES:BP+2]  
				; Number of sectors times sector size
        MOV     SI,[NEXTADD]
        ADD     AX,SI           ; Adjust by size of transfer
        MOV     [NEXTADD],AX
        POP     AX              ; Number of sectors still needed
        POP     DX              ; Starting cluster
        SUB     BX,DX           ; Number of new clusters accessed
        ADD     [LASTPOS],BX
        POP     BX              ; BL = sector postion within cluster
	CALL	FIGREC
        MOV     BX,SI
	RETN
BLKDON:
        SUB     CX,DX           ; Number of sectors in cluster we don't want
        SUB     AH,CL           ; Number of sectors in cluster we accepted
        DEC     AH              ; Adjust to mean position within cluster
        MOV     [SECCLUSPOS],AH
        MOV     CX,DX           ; Anyway, make the total equal to the request
        JMP     SHORT FINCLUS

;SUBTTL FIGREC -- Figure sector in allocation unit
;PAGE

FIGREC:

; Inputs:
;       DX = Physical cluster number
;       BL = Sector position within cluster
;       ES:BP = Base of drive parameters
; Outputs:
;       DX = physical sector number
; No other registers affected.

        PUSH    CX
        MOV     CL,[ES:BP+5]
        DEC     DX
        DEC     DX
        SHL     DX,CL
        OR      DL,BL
        ADD     DX,[ES:BP+0BH]
        POP     CX
	RETN

;SUBTTL GETREC -- Figure record in file from fcb
;PAGE

GETREC:

; Inputs:
;       DS:DX point to FCB
; Outputs:
;       CX = 1
;       DX:AX = Record number determined by fcb_EXTENT and fcb_NR fields
;       DS:DI point to FCB
; No other registers affected.

        MOV     DI,DX
        CMP     BYTE [DI],-1		; Check for extended FCB
        JNZ     SHORT NORMFCB2
        ADD     DI,7
NORMFCB2:
        MOV     CX,1
        MOV     AL,[DI+20H]
        MOV     DX,[DI+0CH]
        SHL     AL,1
        SHR     DX,1
        RCR     AL,1
        MOV     AH,DL
        MOV     DL,DH
        MOV     DH,0
	RETN

;SUBTTL ALLOCATE -- Assign disk space
;PAGE

ALLOCATE:

; Inputs:
;       BX = Last cluster of file (0 if null file)
;       CX = No. of clusters to allocate
;       DX = Position of cluster BX
;       ES:BP = Base of drive parameters
;       [THISFCB] = Points to FCB
; Outputs:
;       IF insufficient space
;         THEN
;       Carry set
;       CX = max. no. of records that could be added to file
;         ELSE
;       Carry clear
;       BX = First cluster allocated
;       FAT is fully updated including dirty bit
;       fcb_FIRCLUS field of FCB set if file was null
; SI,BP unchanged. All other registers destroyed.

        PUSH    BX                      ; save the fat byte
        XOR     BX,BX
	CALL	UNPACK
        MOV     [FATBYT],DI
        POP     BX

        PUSH    DX
        PUSH    CX
        PUSH    BX
        MOV     AX,BX
CLUSALLOC:
        MOV     DX,BX
FINDFRE:
        INC     BX
        CMP     BX,[ES:BP+0DH]
        JLE     SHORT TRYOUT
        CMP     AX,1
        JG      SHORT TRYIN
        POP     BX
        MOV     DX,0FFFH
	CALL	RELBLKS
        POP     AX              ; No. of clusters requested
        SUB     AX,CX           ; AX=No. of clusters allocated
        POP     DX
	CALL	RESTFATBYT
        INC     DX              ; Position of first cluster allocated
        ADD     AX,DX           ; AX=max no. of cluster in file
        MOV     DL,[ES:BP+4]
        MOV     DH,0
        INC     DX              ; DX=records/cluster
        MUL     DX              ; AX=max no. of records in file
        MOV     CX,AX
        SUB     CX,[RECPOS]	; CX=max no. of records that could be written
        JA      SHORT MAXREC
        XOR     CX,CX           ; If CX was negative, zero it
MAXREC:
        STC
        RETN

TRYOUT:
        CALL	UNPACK
        JZ      SHORT HAVFRE
TRYIN:
        DEC     AX
        JLE     SHORT FINDFRE
        XCHG    AX,BX
	CALL	UNPACK
        JZ      SHORT HAVFRE
        XCHG    AX,BX
        JMP     SHORT FINDFRE
HAVFRE:
        XCHG    BX,DX
        MOV     AX,DX
	CALL	PACK
        MOV     BX,AX
        LOOP    CLUSALLOC
        MOV     DX,0FFFH
	CALL	PACK
        POP     BX
        POP     CX              ; Don't need this stuff since we're successful
        POP     DX
	CALL	UNPACK
	CALL	RESTFATBYT
        XCHG    BX,DI
        OR      DI,DI
        ;retnz
	JNZ	SHORT ALLOCATE_RETN
        PUSH    ES
        LES     DI,[THISFCB]
        AND     BX,0FFFh
        MOV     [ES:DI+19H],BX
        AND     WORD [ES:DI+1DH],0F000h  ; clear out old lstclus
        OR      [ES:DI+1DH],BX      ; or the new guy in...
        POP     ES
ALLOCATE_RETN:
        RETN

RESTFATBYT:

        PUSH    BX
        PUSH    DX
        PUSH    DI
        XOR     BX,BX
        MOV     DX,[FATBYT]
        CALL	PACK
        POP     DI
        POP     DX
        POP     BX
	RETN

;SUBTTL RELEASE -- DEASSIGN DISK SPACE
;PAGE

RELEASE:

; Inputs:
;       BX = Cluster in file
;       ES:BP = Base of drive parameters
; Function:
;       Frees cluster chain starting with [BX]
; AX,BX,DX,DI all destroyed. Other registers unchanged.

        XOR     DX,DX
RELBLKS:
; Enter here with DX=0FFFH to put an end-of-file mark
; in the first cluster and free the rest in the chain.
        
	CALL	UNPACK
        ;retz
        JZ	SHORT RET12
	MOV     AX,DI
        CALL	PACK
        CMP     AX,0FF8H
        MOV     BX,AX
        JB      SHORT RELEASE
RET12:  
	RETN

;SUBTTL GETEOF -- Find the end of a file
;PAGE

GETEOF:

; Inputs:
;       ES:BP Points to DPB
;       BX = Cluster in a file
;       DS = CS
; Outputs:
;       BX = Last cluster in the file
; DI destroyed. No other registers affected.

        CALL	UNPACK
        CMP     DI,0FF8H
        JAE	SHORT RET12
        MOV     BX,DI
        JMP     SHORT GETEOF

;CODE	ENDS
;    END

;============================================================================
; STDBUF.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

;
; Standard buffer management for MSDOS
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;.cref
;.list

;TITLE	STDBUF - MSDOS buffer management
;NAME	STDBUF

;INCLUDE BUF.ASM

;============================================================================
; BUF.ASM
;============================================================================
; Retro DOS v2.0 - 12/03/2018

;
; buffer management for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;SUBTTL SETVISIT,SKIPVISIT -- MANAGE BUFFER SCANS

SETVISIT:

; Inputs:
;       None
; Function:
;       Set up a scan of I/O buffers
; Outputs:
;       All visit flags = 0
;               NOTE: This pre-scan is needed because a hard disk error
;                     may cause a scan to stop in the middle leaving some
;                     visit flags set, and some not set.
;       DS:DI Points to [BUFFHEAD]
; No other registers altered

        ;LDS     DI,[BUFFHEAD]
        LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
	PUSH    AX
        XOR     AX,AX
SETLOOP:
        MOV     [DI+7],AL
        LDS     DI,[DI]
        CMP     DI,-1
        JNZ     SHORT SETLOOP
        ;LDS     DI,[BUFFHEAD]
	LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
        POP     AX
SVISIT_RETN:
        RETN

SKIPVISIT:

; Inputs:
;       DS:DI Points to a buffer
; Function:
;       Skip visited buffers
; Outputs:
;       DS:DI Points to next unvisited buffer
;       Zero is set if skip to LAST buffer
; No other registers altered

        CMP     DI,-1
        ;retz
        JZ	SHORT SVISIT_RETN
	CMP     BYTE [DI+7],1
        ;retnz
        JNZ	SHORT SVISIT_RETN
	LDS     DI,[DI]
        JMP     SHORT SKIPVISIT
	;RETN

;SUBTTL SCANPLACE, PLACEBUF -- PUT A BUFFER BACK IN THE POOL

SCANPLACE:

; Inputs:
;       Same as PLACEBUF
; Function:
;       Save scan location and call PLACEBUF
; Outputs:
;       DS:DI Points to saved scan location
; SI destroyed, other registers unchanged

        PUSH    ES
        LES     SI,[DI] ; Save scan location
        CALL    PLACEBUF
        PUSH    ES
        POP     DS                      ; Restore scan location
        MOV     DI,SI
        POP     ES
        RETN

NRETJ:  
	JMP     SHORT NRET

PLACEBUF:

; Input:
;       DS:DI points to buffer
; Function:
;       Remove buffer from queue and re-insert it in proper place.
;       If buffer doesn't go at end, and isn't free, decrement
;       priorities.
; NO registers altered
;
; DS:SI -- Curbuf, current buffer in list
; ES:DI -- Buf, buffer passed as argument
; BP:CX -- Pointsave, saved Buf.nextbuf
; DX:BX -- Lastbuf, previous buffer in list
; AL    -- Inserted, Buf has been inserted
; AH    -- Removed, Buf has been removed

        CALL	save_world
        LES     CX,[DI]
        CMP     CX,-1           ; Buf is LAST?
        JZ      SHORT NRET	; Buffer already last
        MOV     BP,ES           ; Pointsave = Buf.nextbuf
        PUSH    DS
        POP     ES              ; Buf is ES:DI
	; 15/03/2018
        ;LDS     SI,[BUFFHEAD]  ; Curbuf = HEAD
        LDS     SI,[SS:BUFFHEAD]
        CALL    POINTCOMP       ; Buf == HEAD?
        JNZ     SHORT BUFLOOP
        ;MOV     [BUFFHEAD],CX
        ;MOV     [BUFFHEAD+2],BP ; HEAD = Pointsave
        MOV     [SS:BUFFHEAD],CX
        MOV     [SS:BUFFHEAD+2],BP
        JMP     SHORT LOOKEND

BUFLOOP:
        PUSH    DS
        PUSH    SI
        LDS     SI,[SI]
        CALL    POINTCOMP
        JZ	SHORT GOTTHEBUF
        POP     AX
        POP     AX
        JMP     SHORT BUFLOOP

GOTTHEBUF:
        POP     SI
        POP     DS
        MOV     [SI],CX   ; If Curbuf.nextbuf == buf
        MOV     [SI+2],BP ; Curbuf.nextbuf = Pointsave
LOOKEND:
        PUSH    DS
        PUSH    SI
        LDS     SI,[SI]
        CMP     SI,-1
        JZ      SHORT GOTHEEND
        POP     AX
        POP     AX
        JMP     SHORT LOOKEND

GOTHEEND:
        POP     SI
        POP     DS
        MOV     [SI],DI
        MOV     [SI+2],ES ; Curbuf.nextbuf = Buf
        MOV     WORD [ES:DI],-1
        MOV     WORD [ES:DI+2],-1 ; Buf is LAST
NRET:
        CALL	restore_world
        RETN

PLACEHEAD:

; SAME AS PLACEBUF except places buffer at head

        CALL	save_world
        PUSH    DS
        POP     ES
	; 15/03/2018
        ;LDS     SI,[BUFFHEAD]
        ;MOV     [BUFFHEAD],DI
        ;MOV     [BUFFHEAD+2],ES
        LDS     SI,[SS:BUFFHEAD]
        MOV     [SS:BUFFHEAD],DI
        MOV     [SS:BUFFHEAD+2],ES
        MOV     [ES:DI],SI
        MOV     [ES:DI+2],DS
LOOKEND2:
        PUSH    DS
        PUSH    SI
        LDS     SI,[SI]
        CALL    POINTCOMP
        JZ      SHORT GOTHEEND2
        POP     AX
        POP     AX
        JMP     SHORT LOOKEND2

GOTHEEND2:
        POP     SI
        POP     DS
        MOV     WORD [SI],-1
        MOV     WORD [SI+2],-1	; Buf is LAST
        JMP     SHORT NRET

;SUBTTL POINTCOMP -- 20 BIT POINTER COMPARE

POINTCOMP:

; Compare DS:SI to ES:DI (or DS:DI to ES:SI) for equality
; DO NOT USE FOR < or >
; No Registers altered

        CMP     SI,DI
        ;retnz
        JNZ	SHORT POINTCOMP_RETN
	PUSH    CX
        PUSH    DX
        MOV     CX,DS
        MOV     DX,ES
        CMP     CX,DX
        POP     DX
        POP     CX
POINTCOMP_RETN:
        RETN

;SUBTTL GETBUFFR -- GET A SECTOR INTO A BUFFER

GETBUFFR:

; Input:
;       AH = Priority buffer is to have
;       AL = 0 means sector must be pre-read
;          ELSE no pre-read
;       DX = Desired physical sector number
;       ES:BP = Pointer to drive parameters
; Function:
;       Get the specified sector into one of the I/O buffers
;       And shuffle the queue
; Output:
;       [CURBUF] Points to the Buffer for the sector
; DX,ES:BP unchanged, all other registers destroyed

        XOR     SI,SI
GETBUFFRB:
        MOV     [PREREAD],AX
        MOV     AL,[ES:BP]
        LDS     DI,[LASTBUFFER]
        CMP     DI,-1			; Recency pointer valid?
        JZ      SHORT SKBUF		; No
        CMP     DX,[DI+8]
        JNZ     SHORT SKBUF		; Wrong sector
        CMP     AL,[DI+4]
        JNZ     SHORT SKBUF		; Wrong Drive
        JMP     SHORT JUSTBUF		; Just asked for same buffer
SKBUF:
        ;LDS     DI,[BUFFHEAD]
        LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
NXTBFF:
        CMP     DX,[DI+8]
        JNZ     SHORT BUMP
        CMP     AL,[DI+4]
        JNZ     SHORT BUMP
        JMP     SHORT SETINF
BUMP:
        LDS     DI,[DI]
        CMP     DI,-1
        JNZ     SHORT NXTBFF
        ;LDS     DI,[BUFFHEAD]
        LDS     DI,[SS:BUFFHEAD] ; 15/03/2018
        PUSH    SI
        PUSH    DX
        PUSH    BP
        PUSH    ES
        CALL    BUFWRITE		; Write out the dirty buffer
        POP     ES
        POP     BP
        POP     DX
        POP     SI
RDSEC:					; Read in the new sector
        ;TEST    BYTE [PREREAD],-1
        TEST    BYTE [SS:PREREAD],-1 ; 15/03/2018
	JNZ     SHORT SETBUF
        LEA     BX,[DI+10H]	; Point at buffer
        MOV     CX,1
        PUSH    SI
        PUSH    DI
        PUSH    DX
        OR      SI,SI
        JZ      SHORT NORMSEC
	CALL	FATSECRD
        JMP     SHORT GOTTHESEC	; Buffer is marked free if read barfs
NORMSEC:
	CALL	DREAD		; Buffer is marked free if read barfs
GOTTHESEC:
        POP     DX
        POP     DI
        POP     SI
SETBUF:
        MOV     [DI+8],DX
        MOV     [DI+0CH],BP
        MOV     [DI+0EH],ES
        XOR     AH,AH
        MOV     AL,[ES:BP]
        MOV     [DI+4],AX
SETINF:
        MOV     AX,1			; Default to not a FAT sector
        OR      SI,SI
        JZ      SHORT SETSTUFFOK
        MOV     AL,[ES:BP+8]
        MOV     AH,[ES:BP+0FH]
SETSTUFFOK:
        MOV     [DI+0AH],AX
        CALL    PLACEBUF
JUSTBUF:
	; 15/03/2018
        ;MOV     [CURBUF+2],DS
        ;MOV     [LASTBUFFER+2],DS
        MOV     [SS:CURBUF+2],DS
        MOV     [SS:LASTBUFFER+2],DS
        PUSH    SS
        POP     DS
        MOV     [CURBUF],DI
        MOV     [LASTBUFFER],DI
	RETN

;SUBTTL FLUSHBUF -- WRITE OUT DIRTY BUFFERS

FLUSHBUF:

; Input:
;       DS = DOSGROUP
;       AL = Physical unit number
;          = -1 for all units
; Function:
;       Write out all dirty buffers for unit, and flag them as clean
; DS Preserved, all others destroyed (ES too)

        LDS     DI,[BUFFHEAD]
        MOV     AH,-1
NXTBUFF:
        CMP     [DI+4],AH
        JZ      SHORT SKIPBFF		; Skip free buffers
        CMP     AH,AL
        JZ	SHORT DOBUFFER		; Do all dirty buffers
        CMP     AL,[DI+4]
        JNZ     SHORT SKIPBFF		; Buffer not for this unit
DOBUFFER:
        CMP     BYTE [DI+5],0
        JZ	SHORT SKIPBFF		; Buffer not dirty
        PUSH    AX
        PUSH    WORD [DI+4]
        CALL    BUFWRITE
        POP     AX
        XOR     AH,AH                   ; Buffer is clean
        ;CMP     AL,[WPERR]
        CMP     AL,[SS:WPERR] ; 15/03/2018
	JNZ	SHORT NOZAP
        MOV     AL,0FFH                 ; Invalidate buffer, it is inconsistent
NOZAP:
        MOV     [DI+4],AX
        POP     AX                      ; Search info
SKIPBFF:
        LDS     DI,[DI]
        CMP     DI,-1
        JNZ     SHORT NXTBUFF
        PUSH    SS
        POP     DS
        RETN

;SUBTTL BUFWRITE -- WRITE OUT A BUFFER IF DIRTY

BUFWRITE:

; Input:
;       DS:DI Points to the buffer
; Function:
;       Write out all the buffer if dirty.
; Output:
;       Buffer marked free
; DS:DI Preserved, ALL others destroyed (ES too)

        MOV     AX,00FFH
        XCHG    AX,[DI+BUFFINFO.BUFDRV] ; Free, in case write barfs
        CMP     AL,0FFH
        ;retz				; Buffer is free.
	JZ	SHORT BUFWRITE_RETN ; 15/04/2018
        OR      AH,AH
        ;retz				; Buffer is clean.
	JZ	SHORT BUFWRITE_RETN
        ;CMP     AL,[WPERR]
        CMP     AL,[SS:WPERR] ; 15/03/2018
	;retz				; If in WP error zap buffer
	JZ	SHORT BUFWRITE_RETN
        LES     BP,[DI+0CH]
        LEA     BX,[DI+10H]		; Point at buffer
        MOV     DX,[DI+8]
        MOV     CX,[DI+0AH]
        MOV     AL,CH                   ; [DI.BUFWRTINC]
        XOR     CH,CH
        MOV     AH,CH
        PUSH    DI
WRTAGAIN:
        PUSH    CX
        PUSH    AX
        MOV     CX,1
        PUSH    BX
        PUSH    DX
	CALL	DWRITE          ; Write out the dirty buffer
        POP     DX
        POP     BX
        POP     AX
        POP     CX
        ADD     DX,AX
        LOOP    WRTAGAIN
        POP     DI
BUFWRITE_RETN:
        RETN

;CODE	ENDS
;    END

;============================================================================
; SYSCALL.ASM
;============================================================================
; Retro DOS v2.0 - 13/03/2018

;
; system call entry points MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;SUBTTL DATE AND TIME - SYSTEM CALLS 42,43,44,45; S/G DATE,TIME

_$GET_DATE:			;System call 42

; Inputs:
;       None
; Function:
;       Return current date
; Returns:
;       Date in CX:DX

        PUSH    SS
        POP     DS
        CALL	READTIME        ;Check for rollover to next day
        MOV     AX,[YEAR]
        MOV     BX,[DAY]
	CALL	get_user_stack	;Get pointer to user registers
        MOV     [SI+6],BX  ;DH=month, DL=day
        ADD     AX,1980         ;Put bias back
        MOV     [SI+4],AX  ;CX=year
        ;MOV     AL,[WEEKDAY]
        MOV	AL,[SS:WEEKDAY]
	RETN

_$SET_DATE:			;System call 43

; Inputs:
;       CX:DX valid date
; Function:
;       Set current date
; Returns:
;       AL = -1 date bad, = 0 OK

        MOV     AL,-1           ;Be ready to flag error
        SUB     CX,1980         ;Fix bias in year
        JC      SHORT RET24	;Error if not big enough
        CMP     CX,119          ;Year must be less than 2100
        JA      SHORT RET24
        OR      DH,DH
        JZ      SHORT RET24
        OR      DL,DL
        JZ      SHORT RET24	;Error if either month or day is 0
        CMP     DH,12           ;Check against max. month
        JA      SHORT RET24
        PUSH    SS
        POP     DS
	CALL	DODATE
RET24:  
	RETN

_$GET_TIME:			;System call 44

; Inputs:
;       None
; Function:
;       Get current time
; Returns:
;       Time in CX:DX

        PUSH    SS
        POP     DS
	CALL	READTIME
	CALL	get_user_stack           ;Get pointer to user registers
        MOV     [SI+6],DX
        MOV     [SI+4],CX
        XOR     AL,AL
RET26:  
	RETN

_$SET_TIME:			;System call 45
;Time is in CX:DX in hours, minutes, seconds, 1/100 sec.

; Inputs:
;       CX:DX = Time
; Function:
;       Set time
; Returns:
;       AL = -1 time bad, = 0 OK

        MOV     AL,-1           ;Flag in case of error
        CMP     CH,24           ;Check hours
        JAE     SHORT RET26
        CMP     CL,60           ;Check minutes
        JAE     SHORT RET26
        CMP     DH,60           ;Check seconds
        JAE     SHORT RET26
        CMP     DL,100          ;Check 1/100's
        JAE     SHORT RET26
        PUSH    CX
        PUSH    DX
        PUSH    SS
        POP     DS
        MOV     BX,TIMEBUF
        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
        PUSH    BX
	CALL	SETREAD
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Get correct day count
        POP     DS
        POP     BX
	CALL	SETWRITE
        POP     WORD [TIMEBUF+4]
        POP     WORD [TIMEBUF+2]
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Set the time
        XOR     AL,AL
        RETN

;SUBTTL DISK R/W ROUTINES

_$FCB_SEQ_READ:			; System call 20

; Inputs:
;       DS:DX Points to openned FCB
; Function:
;       Read next record from file to disk transfer address
; Returns:
;       AL = 1 EOF record is empty
;       AL = 3 EOF record is partial zero filled
;       AL = 2 No room at disk transfer address
;       AL = 0 All OK

        CALL	GETREC
        CALL	LOAD
        JMP     SHORT FINSEQ

_$FCB_SEQ_WRITE:		; System call 21

; Inputs:
;       DS:DX Points to openned FCB
; Function:
;       Write next record to file from disk transfer address
; Returns:
;       AL = 1 Disk full
;       AL = 2 No room in disk transfer segment
;       AL = 0 All OK

        CALL	GETREC
	CALL	STORE
FINSEQ:
        JCXZ    SETNREX
        ADD     AX,1
        ADC     DX,0
        JMP     SHORT SETNREX

_$FCB_RANDOM_READ:		; System call 33

; Inputs:
;       DS:DX Points to openned FCB
; Function:
;       Read record addressed by random record field from file to
;         disk transfer address
; Returns:
;       AL = 1 EOF record is empty
;       AL = 3 EOF record is partial zero filled
;       AL = 2 No room at disk transfer address
;       AL = 0 All OK

        CALL	GETRRPOS1
	CALL	LOAD
        JMP     SHORT FINRND

_$FCB_RANDOM_WRITE:		; System call 34

; Inputs:
;       DS:DX Points to openned FCB
; Function:
;       Write record addressed by random record field to file from
;         disk transfer address
; Returns:
;       AL = 1 Disk full
;       AL = 2 No room in disk transfer segment
;       AL = 0 All OK

	CALL	GETRRPOS1
	CALL	STORE
        JMP     SHORT FINRND

_$FCB_RANDOM_READ_BLOCK:	; System call 39

; Inputs:
;       DS:DX Points to openned FCB
;       CX = Record count
; Function:
;       Read CX records starting at random record field from file
;         to disk transfer address
; Returns:
;       AL = 1 EOF record is empty
;       AL = 3 EOF record is partial zero filled
;       AL = 2 No room at disk transfer address
;       AL = 0 All OK
;       CX = Actual number of records read

	CALL	GETRRPOS
	CALL	LOAD
        JMP     SHORT FINBLK

_$FCB_RANDOM_WRITE_BLOCK:	; System call 40

; Inputs:
;       DS:DX Points to openned FCB
;       CX = Record count
; Function:
;       Write CX records starting at random record field to file
;         from disk transfer address
;       If CX = 0 File is set to length determined from random record field
; Returns:
;       AL = 1 Disk full
;       AL = 2 No room in disk transfer segment
;       AL = 0 All OK
;       CX = Actual number of records written

        CALL	GETRRPOS
	CALL	STORE
FINBLK:
	CALL	get_user_stack
        MOV     [SI+4],CX
FINNOSAV:
        JCXZ    FINRND
        ADD     AX,1
        ADC     DX,0
FINRND:
        MOV     [ES:DI+21H],AX
        MOV     [ES:DI+23H],DL
        OR      DH,DH
        JZ      SHORT SETNREX
        MOV     [ES:DI+24H],DH 
			; Save 4 byte of RECPOS only if significant
SETNREX:
        MOV     CX,AX
        AND     AL,7FH
        MOV     [ES:DI+20H],AL
        AND     CL,80H
        SHL     CX,1
        RCL     DX,1
        MOV     AL,CH
        MOV     AH,DL
        MOV     [ES:DI+0CH],AX
        ;MOV     AL,[DSKERR]
        MOV     AL,[SS:DSKERR]
RET4:
        RETN

;SUBTTL $FCB_DELETE -- SYSTEM CALL 19

_$FCB_DELETE:		; System call 19

; Inputs:
;       DS:DX point to unopened FCB
; Function:
;       Delete all matching entries
; Returns:
;       AL = -1 if no entries matched, otherwise 0

	CALL	MOVNAME
        MOV     AL,-1
        ;MOV     [FOUNDDEL],AL
        MOV	[SS:FOUNDDEL],AL
	JC      SHORT RET4
        ;MOV     AL,[ATTRIB]
        MOV	AL,[SS:ATTRIB]
	AND     AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
                                        ; Look only at hidden bits
        CMP     AL,attr_hidden+attr_system+attr_directory+attr_volume_id+attr_read_only
                                        ; All must be set
        JNZ	SHORT NOTALL
        MOV     CX,11
        MOV     AL,"?"
        MOV     DI,NAME1
        REPE    SCASB                   ; See if name is *.*
        JNZ     SHORT NOTALL
	;MOV	BYTE [DELALL],0		; DEL *.* - flag deleting all
	MOV	BYTE [SS:DELALL],0		; DEL *.* - flag deleting all
NOTALL:
	CALL	FINDNAME
        MOV     AL,-1
        JC      SHORT RET4
        OR      AH,AH			; Check if device name
        JS      SHORT RET4		; Can't delete I/O devices
DELFILE:
        LES     BP,[THISDPB]
        MOV     AH,[DELALL]
        PUSH    DS
        LDS     DI,[CURBUF]
        ;TEST    [Attrib],attr_read_only ; are we deleting RO files too?
        TEST	BYTE [SS:ATTRIB],attr_read_only
	JNZ     SHORT DoDelete		; yes
        TEST    BYTE [BX+0BH],attr_read_only
        JZ      SHORT DoDelete		; not read only
        POP     DS
        JMP     SHORT DELNXT
DoDelete:
        ;MOV     BYTE PTR [FoundDel],0
        MOV	BYTE [SS:FOUNDDEL], 0
	MOV     BYTE [DI+5],1
        MOV     [BX],AH
        MOV     BX,[SI]
        POP     DS
        OR      BX,BX
        JZ      SHORT DELNXT
        CMP     BX,[ES:BP+0DH]
        JA      SHORT DELNXT
	CALL	RELEASE
DELNXT:
	CALL	GETENTRY                        ; Registers need to be reset
	CALL	NEXTENT
        JNC     SHORT DELFILE
        CALL    FLUSHRET1
        MOV     AL,[FOUNDDEL]
        RETN


;SUBTTL $FCB_RENAME -- SYSTEM CALL 23	; RENAME FILES

ERRETJ: 
	JMP	ERRET

_$FCB_RENAME:			; System call 23

; Inputs:
;       DS:DX point to a modified FCB (DS:DX+11H points to destination
;        name)
; Function:
;       Rename all matching entries to indicated name
; Returns:
;       AL = -1 if no entries matched, otherwise 0

	CALL	MOVNAME
        JC      SHORT ERRETJ
        ADD     SI,5
        MOV     DI,NAME2
	CALL	LODNAME
        JC      SHORT ERRETJ	; Report error if second name invalid
	CALL	FINDNAME
        JC      SHORT ERRETJ
        OR      AH,AH           ; Check if I/O device name
        JS      SHORT ERRETJ	; If so, can't rename it
        MOV     SI,NAME1
        MOV     DI,NAME3
        MOV     CX,13
        REP     MOVSB           ; Copy name to search for --include attribute byte
RENFIL:
        MOV     DI,NAME1
        MOV     SI,NAME2
        MOV     CX,11
NEWNAM:
        LODSB
        CMP     AL,"?"
        JNZ     SHORT NOCHG
        PUSH    DS
        MOV     DS,[CURBUF+2]
        MOV     AL,[BX]
        POP     DS
NOCHG:
        STOSB
        INC     BX
        LOOP    NEWNAM
        INC     DI
        MOV     BYTE [DI],attr_all  ;Sets ATTRIB
                                ; Stop duplicates with any attributes
	CALL	DEVNAME         ; Check if giving it a device name
        JNC	short RENERR
        XOR     AX,AX
        PUSH    WORD [LASTENT]
	CALL	FINDENTRY       ; See if new name already exists
        POP     AX
        JNC	short RENERR	; Error if found
        LES     BP,[THISDPB]
        CALL	GETENT                  ; Re-read matching entry
        MOV     DI,BX           ; Leave BX,DX until call to NEXTENT
        MOV     ES,[CURBUF+2]
        MOV     SI,NAME1
        MOV     CX,11
        REP     MOVSB                   ; Replace old name with new one
        MOV     DI,[CURBUF]
        MOV     BYTE [ES:DI+5],1 ; Directory changed
        PUSH    SS
        POP     ES
        MOV     SI,NAME3
        MOV     DI,NAME1
        MOV     CX,13                   ; Include attribute byte
        REP     MOVSB                   ; Copy name back into search buffer
	CALL	NEXTENT
        JNC     SHORT RENFIL
        JMP     FLUSHRET1

RENERR:
        CALL    FLUSHRET1
ERRET:
        MOV     AL,-1
        RETN

;SUBTTL $FCB_OPEN -- SYSTEM CALL 15	; OPEN A FILE

_$FCB_OPEN:			; System call 15

; Inputs:
;       DS:DX point to an unopened FCB
; Function:
;       Open indicated file and fill in FCB
; Returns:
;       AL = -1 if no entries matched, otherwise 0
; FOR INTERNAL USE
;       [CURBUF+2]:SI and [CURBUF+2]:BX Preserved

	CALL	GETFILE

DOOPEN:

; Enter here to perform $FCB_OPEN on file already found
; in directory. AH=device ID number, DS=CS, BX points to directory
; entry in [CURBUF], SI points to First Cluster field, and
; ES:DI point to the FCB to be opened. This entry point
; is used by $FCB_CREATE.
        JC      SHORT ERRET
        PUSH    SI
        PUSH    AX              ; Save I/O driver number
        XOR     AL,AL
        OR      AH,AH
        JS      SHORT OPENDEV
        MOV     AL,[THISDRV]
        MOV     DS,[CURBUF+2]
        INC     AX
OPENDEV:
        STOSB
        XOR     AX,AX
;IF ZEROEXT
        ADD     DI,11
        STOSW                   ; Zero low byte of extent field if ZERPEXT only
;ELSE
;	ADD     DI,12           ; Point to high half of CURRENT BLOCK field
;	STOSB                   ; Set it to zero (CP/M programs set low byte)
;ENDIF
        MOV     AL,128          ; Default record size
        STOSW                   ; Set record size
        LODSW                   ; Get starting cluster
        MOV     DX,AX           ; Save it for the moment
        MOVSW                   ; Transfer size to FCB
        MOVSW
        MOV     AX,[SI-8]       ; Get date
        STOSW                   ; Save date in FCB
        MOV     AX,[SI-10]      ; Get time
        STOSW                   ; Save it in FCB
        POP     AX              ; Restore I/O driver number
        POP     SI
        MOV     AL,AH
        OR      AL,40H          ; Not dirty
        STOSB
        JS      SHORT SAVDEVPT	; If device, go save pointer to it
        MOV     AX,DX           ; Restore starting cluster
        STOSW                   ; first cluster
        PUSH    AX                      ; save cluster
        XOR     AX,AX
        STOSW                           ; clus pos
        POP     AX                      ; last cluster
        STOSB
        MOV     AL,AH
        ;MOV     AH,BYTE PTR [DIRSTART]
        MOV     AH,[SS:DIRSTART]
	PUSH    CX
        MOV     CL,4
        SHL     AH,CL
        OR      AL,AH
        STOSB
        ;MOV     AX,[DIRSTART]
        MOV     AX,[SS:DIRSTART]
        MOV     CL,4
        SHL     AX,CL
        POP     CX
        MOV     AL,AH
        STOSB
OPEN_RET:
        XOR     AX,AX
        RETN

SAVDEVPT:
        LDS     AX,[DEVPT]
        STOSW
        MOV     [ES:DI],DS
        JMP     SHORT OPEN_RET

;SUBTTL $FCB_CLOSE -- SYSTEM CALL 16; CLOSE FILE

_$FCB_CLOSE:		; System call 16

; Inputs:
;       DS:DX point to an opened FCB
; Function:
;       Close the indicated file
; Returns:
;       AL = -1 if disk has been changed, otherwise 0

        MOV     DI,DX
        CMP     BYTE [DI],-1		; Check for extended FCB
        JNZ     SHORT NORMFCB3
        ADD     DI,7
NORMFCB3:
        TEST    BYTE [DI+18H],devid_file_clean+devid_device
                                        ; Allow only dirty files
        JNZ     SHORT OKRET1		; can't close I/O device or not written
	CALL	MOVNAMENOSET
        JC      SHORT BADCLOSE		; Bad file name
FCB_CLOSE_INNER:
        PUSH    DX
        PUSH    DS
        MOV     SI,DX
        MOV     BX,[SI+1EH]
        MOV     CL,4
        SHR     BX,CL
        PUSH    BX
        PUSH    SS
        POP     DS
	CALL	FATREAD
        POP     BX
	CALL	SETDIRSRCH
	CALL	FINDENTRY
        POP     ES
        POP     DI
        JC      SHORT BADCLOSE
        LDS     BX,[CURBUF]

        ; note that SI points to dir_first...

        OR      BYTE [SI-0FH],attr_archive
        MOV     CX,[ES:DI+19H]
        MOV     [SI],CX
        MOV     DX,[ES:DI+10H]
        MOV     [SI+2],DX
        MOV     DX,[ES:DI+12H]
        MOV     [SI+4],DX
        MOV     DX,[ES:DI+14H]
        MOV     [SI-2],DX
        MOV     DX,[ES:DI+16H]
        MOV     [SI-4],DX
        MOV     BYTE [BX+5],1
        PUSH    SS
        POP     DS
FLUSHRET1:
        LES     BP,[THISDPB]
        MOV     AL,[ES:BP+0]
	CALL	FLUSHBUF
OKRET1:
        XOR     AL,AL
        RETN

BADCLOSE:
        MOV     AL,-1
        RETN

;SUBTTL $FCB_CREATE -- SYSTEM CALL 22	; MAKE AND OPEN A NEW FILE

_$FCB_CREATE:		; System call 22

; Inputs:
;       DS:DX point to an unopened FCB
; Function:
;       If file does not exist, create it and open it
;       If file exists, free up its contents and open the file
; Returns:
;       AL = -1 if file cannot be created, otherwise 0

	CALL	MOVNAME
        JC      SHORT ERRET3
        MOV     DI,NAME1
        MOV     CX,11
        MOV     AL,"?"
        REPNE   SCASB
        JZ      SHORT ERRET3
        ;MOV     BYTE [CREATING],-1
        MOV     BYTE [SS:CREATING],-1 ; 15/03/2018
        PUSH    DX
        PUSH    DS
        CALL	FINDNAME
NWENTY:
        LES     BP,[THISDPB]
        JNC	SHORT EXISTENT
	CALL	BUILDDIR
        JC      SHORT ERRPOP
	CALL	GETENT		; Point at that free entry
        JMP     SHORT FREESPOT
ERRPOP:
        POP     DS
        POP     DX
ERRET3:
        JMP     SHORT BADCLOSE

NEWENTRY:
        POP     DX      ; Return address
        POP     ES      ; ES
        POP     CX      ; DI
        PUSH    DX
        PUSH    CX
        PUSH    ES
        JMP	SHORT NWENTY

EXISTENT:
        JNZ     SHORT ERRPOP	; Error if attributes don't match
        OR      AH,AH           ; Check if file is I/O device
        JS      SHORT OPENJMP	; If so, no action
        PUSH    DS
        LDS     DI,[CURBUF]
        MOV     CX,[SI]         ; Get pointer to clusters
        MOV     SI,[DI+8]
        POP     DS
        JCXZ    FREESPOT
        CMP     CX,[ES:BP+0DH]
        JA      SHORT FREESPOT
        SUB     BX,DI
        PUSH    BX
        PUSH    SI              ; Save sector number
        MOV     BX,CX
	CALL	RELEASE         ; Free any data already allocated
        POP     DX
        XOR     AL,AL
	CALL	GETBUFFR
        POP     BX
        ADD     BX,[CURBUF]
FREESPOT:
        TEST    BYTE [ATTRIB],attr_volume_id
        JZ      SHORT NOTVOLID
        CMP     BYTE [VOLID],0
        JNZ     SHORT ERRPOP	; Can't create a second volume ID
NOTVOLID:
        MOV     ES,[CURBUF+2]
        MOV     DI,BX
        MOV     SI,NAME1
        MOV     CX,5
        MOVSB
        REP     MOVSW
        MOV     AL,[ATTRIB]
        STOSB
        MOV     CL,5
        XOR     AX,AX
        REP     STOSW
	CALL	DATE16
        XCHG    AX,DX
        STOSW
        XCHG    AX,DX
        STOSW
        XOR     AX,AX
        PUSH    DI
        STOSW
        STOSW
        STOSW
        MOV     SI,[CURBUF]
        MOV     BYTE [ES:SI+5],1
        LES     BP,[THISDPB]
        MOV     AL,[ES:BP+0]
        PUSH    AX
        PUSH    BX
	CALL	FLUSHBUF
        POP     BX
        POP     AX
        POP     SI
        MOV     AH,AL             ; Get I/O driver number back
OPENJMP:
        CLC                     ; Clear carry so OPEN won't fail
        POP     ES
        POP     DI
        JMP     DOOPEN

;do_ext
;
;CODE	ENDS
;    END

;============================================================================
; CTRLC.ASM
;============================================================================

;
; ^C status routines for MSDOS
;

;INCLUDE DOSSEG.ASM

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;        ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;SUBTTL Checks for ^C in CON I/O
;PAGE
        ;procedure   DSKSTATCHK,NEAR ; Check for ^C if only one level in

DSKSTATCHK:        
	;CMP     BYTE [INDOS],1
        CMP     BYTE [SS:INDOS],1 ; 15/03/2018
	;retnz			; Do NOTHING
	JNZ	SHORT _RET37 ; Retro DOS v2.0 - 04/03/2018         

	PUSH    CX
        PUSH    ES
        PUSH    BX
        PUSH    DS
        PUSH    SI
        PUSH    CS
        POP     ES
        PUSH    CS
        POP     DS
        XOR     CX,CX
        MOV     BYTE [DSKSTCOM],DEVRDND
        MOV     BYTE [DSKSTCALL],DRDNDHL
        MOV     [DSKSTST],CX
        MOV     BX,DSKSTCALL
        LDS     SI,[BCON]
        CALL	DEVIOCALL2
 	; 15/03/2018
        ;TEST    WORD [DSKSTST],STBUI
        TEST    WORD [SS:DSKSTST],STBUI
	JNZ     SHORT ZRET		; No characters available
        ;MOV     AL,[DSKCHRET]
        MOV     AL,[SS:DSKCHRET]
DSK1:
        CMP     AL,"C"-"@"
        JNZ     SHORT RET36
        ;MOV     BYTE [DSKSTCOM],DEVRD
        ;MOV     BYTE [DSKSTCALL],DRDWRHL
        ;MOV     [DSKCHRET],CL
        ;MOV     [DSKSTST],CX
        MOV     BYTE [SS:DSKSTCOM],DEVRD
        MOV     BYTE [SS:DSKSTCALL],DRDWRHL
        MOV     [SS:DSKCHRET],CL
        MOV     [SS:DSKSTST],CX
        INC     CX
        ;MOV     [DSKSTCNT],CX
	MOV     [SS:DSKSTCNT],CX    
	CALL	DEVIOCALL2              ; Eat the ^C
        POP     SI
        POP     DS
        POP     BX                      ; Clean stack
        POP     ES
        POP     CX
        JMP     SHORT CNTCHAND

ZRET:
        XOR     AL,AL                   ; Set zero
RET36:
        POP     SI
        POP     DS
        POP     BX
        POP     ES
        POP     CX
_RET37:
        RETN

NOSTOP:
        CMP     AL,"P"-"@"
        JZ      SHORT INCHK

	; 15/04/2018
        ;IF	NOT TOGLPRN
        CMP	AL,"N"-"@"
        JZ	SHORT INCHK
        ;ENDIF

        CMP     AL,"C"-"@"
        JZ      SHORT INCHK
	RETN

        ;procedure SPOOLINT,NEAR

SPOOLINT:
        PUSHF
	; 15/03/2018
        ;CMP     BYTE [IDLEINT],0
        CMP     BYTE [SS:IDLEINT],0
        JZ      SHORT POPFRET
        ;CMP     BYTE [ERRORMODE],0
        CMP     BYTE [SS:ERRORMODE],0
        JNZ     SHORT POPFRET		;No spool ints in error mode
        INT     int_spooler
POPFRET:
        POPF
_RET18:  
	RETN

        ;procedure   STATCHK,NEAR

STATCHK:
        CALL	DSKSTATCHK              ; Allows ^C to be detected under
                                        ; input redirection
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_FCB
        POP     BX
        JC      SHORT _RET18
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT SPOOLINT
        CMP     AL,'S'-'@'
        JNZ     SHORT NOSTOP
        XOR     AH,AH
        CALL	IOFUNC                  ; Eat Cntrl-S
        JMP     SHORT PAUSOSTRT
PRINTOFF:
PRINTON:
        ;NOT     BYTE [PFLAG]
	NOT	BYTE [SS:PFLAG] ; 14/03/2018
STATCHK_RETN:
        RETN

PAUSOLP:
        CALL    SPOOLINT
PAUSOSTRT:
        MOV     AH,1
        CALL	IOFUNC
        JZ      SHORT PAUSOLP
INCHK:
        PUSH    BX
        XOR     BX,BX
        CALL	GET_IO_FCB
        POP     BX
        JC      SHORT _RET18
        XOR     AH,AH
        CALL	IOFUNC
        CMP     AL,'P'-'@'
        JZ      SHORT PRINTON
	; 15/04/2018
        ;IF	NOT TOGLPRN
        CMP	AL,'N'-'@'
        JZ	SHORT PRINTOFF
        ;ENDIF
        CMP     AL,'C'-'@'
        ;retnz
	JNZ	SHORT STATCHK_RETN	

        ;procedure   CNTCHAND,NEAR

CNTCHAND:
; Ctrl-C handler.
; "^C" and CR/LF is printed. Then the user registers are restored and
; the user CTRL-C handler is executed.  At this point the top of the stack
; has 1) the interrupt return address should the user CTRL-C handler wish
; to allow processing to continue; 2) the original interrupt return address
; to the code that performed the function call in the first place. If
; the user CTRL-C handler wishes to continue, it must leave all registers
; unchanged and RET (not IRET) with carry CLEAR. If carry is SET then
; an terminate system call is simulated.
        MOV     AL,3                ; Display "^C"
        CALL	BUFOUT
        CALL	CRLF
        PUSH    SS
        POP     DS
        CMP     BYTE [CONSWAP],0
        JZ      SHORT NOSWAP
        CALL	SWAPBACK
NOSWAP:
        CLI                         ; Prepare to play with stack
        MOV     SP,[user_SP]
        MOV     SS,[user_SS]	    ; User stack now restored
        CALL	restore_world       ; User registers now restored
        ;MOV     BYTE [INDOS],0	    ; Go to known state
        ;MOV     BYTE [ERRORMODE],0
        ;MOV     [ConC_spsave],SP    ; save his SP
        ; 14/03/2018
	MOV     BYTE [CS:INDOS],0
        MOV     BYTE [CS:ERRORMODE],0
        MOV     [CS:ConC_spsave],SP
        INT     int_ctrl_c ; 23h    ; Execute user Ctrl-C handler
        ;MOV     [user_SS],AX	    ; save the AX
        MOV     [CS:user_SS],AX
        PUSHF                       ; and the flags (maybe new call)
        POP     AX
        ;CMP     SP,[ConC_spsave]
        CMP	SP,[CS:ConC_spsave]
	JNZ     SHORT ctrlc_try_new ; new syscall maybe?
ctrlc_repeat:
        ;MOV     AX,[user_SS]        ; no...
        MOV     AX,[CS:user_SS]
	;transfer COMMAND           ; Repeat command otherwise
COMMANDJ:
	JMP	COMMAND

ctrlc_try_new:
        ;SUB     WORD [ConC_spsave],2 ; Are there flags on the stack?
        ;CMP     SP,[ConC_spsave]
        SUB     WORD [CS:ConC_spsave],2 ; Are there flags on the stack?
        CMP     SP,[CS:ConC_spsave]
        JZ      SHORT ctrlc_new	    ; yes, new system call

ctrlc_abort:
        ;MOV	AX,(EXIT SHL 8) + 0
        MOV	AX, (EXIT*256) + 0  ; 4C00h
	;MOV     BYTE [DidCTRLC],0FFh
	mov	byte [CS:DidCTRLC],0FFh ; 14/03/2018
        ;transfer COMMAND	    ; give up by faking $EXIT
	;JMP	SHORT COMMANDJ
	JMP	COMMAND

ctrlc_new:
        PUSH    AX
        POPF
        ;POP	WORD [user_SS]
        pop	word [CS:user_SS] ; 14/03/2018
	JNC     SHORT ctrlc_repeat  ; repeat operation
        JMP     SHORT ctrlc_abort   ; indicate ^ced

;CNTCHAND ENDP

;SUBTTL DIVISION OVERFLOW INTERRUPT

; Default handler for division overflow trap
        ;procedure   DIVOV,NEAR
;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING

DIVOV: ; MSDOS 2.11 DIVOV (in CTRLC.ASM, 19/08/1983)
        MOV     SI,DIVMES
        CALL    RealDivOv
        JMP     SHORT ctrlc_abort  ; Use Ctrl-C abort on divide overflow

	; DIVOV at IBMDOS.COM offset 3143h (MSDOS 2.0)
	;push    si
	;push    ax
	;mov     si, offset DIVMES
	;call    OUTMES
	;pop     ax
	;pop     si
	;int     23h             ; DOS - CONTROL "C" EXIT ADDRESS
	;iret

;DIVOV   ENDP

;
; RealDivOv: perform actual divide overflow stuff.
; Inputs:   none
; Outputs:  message to BCON
;
	;procedure RealDivOv,NEAR   ; Do divide overflow and clock process

RealDivOv:
        PUSH    CS                  ; get ES addressability
        POP     ES
        PUSH    CS                  ; get DS addressability
        POP     DS
        MOV     BYTE [DSKSTCOM],DEVWRT
        MOV     BYTE [DSKSTCALL],DRDWRHL
        MOV     WORD [DSKSTST],0
        MOV     BL,[DivMesLen]
        XOR     BH,BH
        MOV     [DSKSTCNT],BX
        MOV     BX,DSKSTCALL
        MOV     [DSKCHRET+1],SI    ; transfer address (need an EQU)
        LDS     SI,[BCON]
        CALL	DEVIOCALL2
        ;MOV     WORD [DSKCHRET+1],DEVIOBUF
        ;MOV     WORD [DSKSTCNT],1
	; 14/03/2018
        MOV     WORD [CS:DSKCHRET+1],DEVIOBUF
        MOV     WORD [CS:DSKSTCNT],1
	;return
        RETN

;RealDivOv   ENDP

;SUBTTL CHARHRD,HARDERR,ERROR -- HANDLE DISK ERRORS AND RETURN TO USER
;PAGE
       ; procedure CHARHARD,NEAR
;ASSUME  DS:NOTHING,ES:NOTHING,SS:DOSGROUP

CHARHARD:

; Character device error handler
; Same function as HARDERR

	; 15/03/2018
        ;MOV     WORD [EXITHOLD+2],ES
        ;MOV     WORD [EXITHOLD],BP
        MOV     WORD [SS:EXITHOLD+2],ES
        MOV     WORD [SS:EXITHOLD],BP
        PUSH    SI
        AND     DI,STECODE
        MOV     BP,DS                   ;Device pointer is BP:SI
        CALL    FATALC
        POP     SI
	;return
        RETN

;CHARHARD ENDP

        ;procedure HardErr,NEAR
;ASSUME  DS:NOTHING,ES:NOTHING

HARDERR:

; Hard disk error handler. Entry conditions:
;       DS:BX = Original disk transfer address
;       DX = Original logical sector number
;       CX = Number of sectors to go (first one gave the error)
;       AX = Hardware error code
;       DI = Original sector transfer count
;       ES:BP = Base of drive parameters
;       [READOP] = 0 for read, 1 for write
                                        ;
        XCHG    AX,DI                   ; Error code in DI, count in AX
        AND     DI,STECODE              ; And off status bits
        CMP     DI,WRECODE              ; Write Protect Error?
        JNZ     short NOSETWRPERR
        PUSH    AX
        MOV     AL,[ES:BP+0]
        ;MOV     [WPERR],AL		; Flag drive with WP error
        MOV     [SS:WPERR],AL ; 15/03/2018
        POP     AX
NOSETWRPERR:
        SUB     AX,CX                   ; Number of sectors successfully transferred
        ADD     DX,AX                   ; First sector number to retry
        PUSH    DX
        MUL     word [ES:BP+2] 		; Number of bytes transferred
        POP     DX
        ADD     BX,AX                   ; First address for retry
        XOR     AH,AH                   ; Flag disk section in error
        CMP     DX,[ES:BP+6] 		; In reserved area?
        JB      SHORT ERRINT
        INC     AH                      ; Flag for FAT
        CMP     DX,[ES:BP+10H] ; In FAT?
        JB      SHORT ERRINT
        INC     AH
        CMP     DX,[ES:BP+0BH] ; In directory?
        JB      SHORT ERRINT
        INC     AH                      ; Must be in data area
ERRINT:
        SHL     AH,1                    ; Make room for read/write bit
        ;OR      AH,[READOP]
        OR      AH,[SS:READOP] ; 15/03/2018
        ;entry   FATAL
FATAL:
        MOV     AL,[ES:BP+0]	; Get drive number
        ;entry   FATAL1
FATAL1:  
	; 15/03/2018      
	;MOV     [EXITHOLD+2],ES
        ;MOV     [EXITHOLD],BP		; The only things we preserve
	MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BP
        LES     SI,[ES:BP+12H]
        MOV     BP,ES                   ; BP:SI points to the device involved

FATALC:
        ;CMP     BYTE [ERRORMODE],0
	CMP     BYTE [SS:ERRORMODE],0
        JNZ     SHORT SETIGN		; No INT 24s if already INT 24
        ;MOV     [CONTSTK],SP
        MOV     [SS:CONTSTK],SP
        PUSH    SS
        POP     ES
        CLI                             ; Prepare to play with stack
        ;INC     BYTE [ERRORMODE]	; Flag INT 24 in progress
        ;DEC     BYTE [INDOS]		; INT 24 handler might not return
        ;MOV     SS,[user_SS]
        INC     BYTE [SS:ERRORMODE]	; Flag INT 24 in progress
        DEC     BYTE [SS:INDOS]		; INT 24 handler might not return
        MOV     SS,[SS:user_SS]
        MOV     SP,[ES:user_SP]         ; User stack pointer restored
        INT     int_fatal_abort         ; Fatal error interrupt vector, must preserve ES
        MOV     [ES:user_SP],SP         ; restore our stack
        MOV     [ES:user_SS],SS
        MOV     SP,ES
        MOV     SS,SP
        ;MOV     SP,[CONTSTK]
        ;INC     BYTE [INDOS]		; Back in the DOS
        ;MOV     BYTE [ERRORMODE],0	; Back from INT 24
        MOV     SP,[SS:CONTSTK]
        INC     BYTE [SS:INDOS]		; Back in the DOS
        MOV     BYTE [SS:ERRORMODE],0	; Back from INT 24
        STI
IGNRET:
        ;LES     BP,[EXITHOLD]
        LES     BP,[SS:EXITHOLD]
        CMP     AL,2
        JZ      SHORT error_abort
        ;MOV     BYTE [WPERR],-1	;Forget about WP error
        MOV     BYTE [SS:WPERR],-1
        RETN

SETIGN:
        XOR     AL,AL                   ;Flag ignore
        JMP     SHORT IGNRET

error_abort:
        PUSH    SS
        POP     DS
        CMP     BYTE [CONSWAP],0
        JZ      SHORT NOSWAP2
        CALL	SWAPBACK
NOSWAP2:
        MOV     BYTE [exit_type],Exit_Hard_Error
        MOV     DS,[CurrentPDB]
;
; reset_environment checks the DS value against the CurrentPDB. If they
; are different, then an old-style return is performed. If they are
; the same, then we release jfns and restore to parent. We still use
; the PDB at DS:0 as the source of the terminate addresses.
;
; output:   none.
;
        ;entry   reset_environment
reset_environment:
        PUSH    DS                      ; save PDB of process

        MOV     AL,int_terminate
        call	_$GET_INTERRUPT_VECTOR	; and who to go to
	; 15/03/2018
        ;MOV     [EXITHOLD+2],ES	; save return address
        ;MOV     [EXITHOLD],BX
        ;MOV     BX,[CurrentPDB]	; get current process
        MOV     [SS:EXITHOLD+2],ES
        MOV     [SS:EXITHOLD],BX
        MOV     BX,[SS:CurrentPDB]
        MOV     DS,BX                   ;
        MOV     AX,[PDB.PARENT_PID]	; get parent to return to
        POP     CX
;
; AX = parentPDB, BX = CurrentPDB, CX = ThisPDB
; Only free handles if AX <> BX and BX = CX and [exit_code].upper is not
; Exit_keep_process
;
        CMP     AX,BX
        JZ      short reset_return	; parentPDB = CurrentPDB
        CMP     BX,CX
        JNZ     short reset_return	; CurrentPDB <> ThisPDB
        PUSH    AX                      ; save parent
        ;CMP     BYTE [exit_type],Exit_Keep_Process
	CMP     BYTE [SS:exit_type],Exit_Keep_Process
        JZ      short reset_to_parent	; keeping this process

        call	arena_free_process

        ; reset environment at [CurrentPDB]; close those handles
        MOV     CX,FILPERPROC

reset_free_jfn:
        MOV     BX,CX
        PUSH    CX
        DEC     BX                      ; get jfn
        call	_$CLOSE			; close it, ignore return
        POP     CX
        LOOP    reset_free_jfn          ; and do 'em all

reset_to_parent:
        ;POP     WORD [CurrentPDB]	; set up process as parent
        POP     WORD [SS:CurrentPDB]
reset_return:                           ; come here for normal return
        PUSH    CS
        POP     DS
        MOV     AL,-1
        CALL	FLUSHBUF                ; make sure that everything is clean

        CLI
        MOV     BYTE [INDOS],0		;Go to known state
        MOV     BYTE [WPERR],-1		;Forget about WP error
;
; Snake into multitasking... Get stack from CurrentPDB person
;
        MOV     DS,[CurrentPDB]
        MOV     SS,[PDB.USER_STACK+2]
        MOV     SP,[PDB.USER_STACK]

        CALL	restore_world
        POP     AX                      ; suck off CS:IP of interrupt...
        POP     AX
        POP     AX
        MOV     AX,0F202h               ; STI
        PUSH    AX
        ;15/03/2018
	;PUSH    WORD [EXITHOLD+2]
        ;PUSH    WORD [EXITHOLD]
	PUSH    WORD [CS:EXITHOLD+2]
        PUSH    WORD [CS:EXITHOLD]
        STI
        IRET			; Long return back to user terminate address

;HardErr ENDP

	;ASSUME  SS:DOSGROUP
;do_ext

;CODE    ENDS
;    END

;============================================================================
; STDFCB.ASM
;============================================================================
; Retro DOS v2.0 - 13/03/2018

;
; Standard FCB calls for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;.cref
;.list

;TITLE   STDFCB - FCB calls for MSDOS
;NAME    STDFCB

;INCLUDE FCB.ASM

;============================================================================
; FCB.ASM
;============================================================================
; Retro DOS v2.0 - 13/03/2018

;
; FCB management routines for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

MAKEFCB:

DRVBIT  EQU     2
NAMBIT  EQU     4
EXTBIT  EQU     8

        ;MOV     BYTE [SpaceFlag],0
        MOV     BYTE [SS:SpaceFlag],0

	XOR     DL,DL           ; Flag--not ambiguous file name
        TEST    AL,DRVBIT       ; Use current drive field if default?
        JNZ     SHORT DEFDRV
        MOV     BYTE [ES:DI],0      ; No - use default drive
DEFDRV:
        INC     DI
        MOV     CX,8
        TEST    AL,NAMBIT       ; Use current name fields as defualt?
        XCHG    AX,BX           ; Save bits in BX
        MOV     AL," "
        JZ      SHORT FILLB	; If not, go fill with blanks
        ADD     DI,CX
        XOR     CX,CX           ; Don't fill any
FILLB:
        REP     STOSB
        MOV     CL,3
        TEST    BL,EXTBIT       ; Use current extension as default
        JZ      SHORT FILLB2
        ADD     DI,CX
        XOR     CX,CX
FILLB2:
        REP     STOSB
        XCHG    AX,CX           ; Put zero in AX
        STOSW
        STOSW                   ; Initialize two words after to zero
        SUB     DI,16           ; Point back at start
        TEST    BL,1            ; Scan off separators if not zero
        JZ      SHORT SKPSPC
        CALL    SCANB           ; Peel off blanks and tabs
        CALL    DELIM           ; Is it a one-time-only delimiter?
        JNZ     SHORT _NOSCAN
        INC     SI              ; Skip over the delimiter
SKPSPC:
        CALL    SCANB           ; Always kill preceding blanks and tabs
_NOSCAN:
        CALL    GETLET
        JBE     SHORT NODRV 	; Quit if termination character
        CMP     BYTE [SI],":"        ; Check for potential drive specifier
        JNZ     NODRV
        INC     SI              ; Skip over colon
        SUB     AL,"@"          ; Convert drive letter to binary drive number
        JBE     SHORT BADDRV	; Valid drive numbers are <= NUMIO
        ;CMP     AL,[NUMIO]
        CMP	AL,[SS:NUMIO] ; 15/03/2018
	JBE     SHORT HAVDRV
BADDRV:
        MOV     DL,-1
HAVDRV:
        STOSB           ; Put drive specifier in first byte
        INC     SI
        DEC     DI      ; Counteract next two instructions
NODRV:
        DEC     SI      ; Back up
        INC     DI      ; Skip drive byte
NORMSCAN:
        MOV     CX,8
        CALL    GETWORD         ; Get 8-letter file name
        CMP     BYTE [SI],"."
        JNZ     SHORT NODOT
        INC     SI              ; Skip over dot if present
        MOV     CX,3            ; Get 3-letter extension
        CALL    MUSTGETWORD
NODOT:
        MOV     AL,DL
        RETN

NONAM:
        ADD     DI,CX
        DEC     SI
        RETN

GETWORD:
        CALL    GETLET
        JBE     SHORT NONAM	; Exit if invalid character
        DEC     SI
;
; UGH!!! Horrible bug here that should be fixed at some point:
; If the name we are scanning is longer than CX, we keep on reading!
;
MUSTGETWORD:
        CALL    GETLET
;
; If spaceFlag is set then we allow spaces in a pathname
;
        JB      SHORT FILLNAM
        JNZ     SHORT MustCheckCX
        ;TEST    BYTE [SpaceFlag],0FFh
        TEST    BYTE [SS:SpaceFlag],0FFh
        JZ      SHORT FILLNAM
        CMP     AL," "
        JNZ     SHORT FILLNAM

MustCheckCX:
        JCXZ    MUSTGETWORD
        DEC     CX
        CMP     AL,"*"                  ; Check for ambiguous file specifier
        JNZ     SHORT NOSTAR
        MOV     AL,"?"
        REP     STOSB
NOSTAR:
        STOSB

        ;IF      KANJI
        ;CALL    TESTKANJ
        ;JZ      NOTDUAL3
        ;JCXZ    BNDERR                  ; Attempt to straddle boundry
        ;MOVSB                           ; Transfer second byte
        ;DEC     CX
        ;JMP     SHORT NOTDUAL3
;BNDERR:
        ;MOV     BYTE PTR ES:[DI-1]," "  ; patch up that space
        ;JMP     MustGetWord             ; go back and scan until delim
;NOTDUAL3:
        ;ENDIF

        CMP     AL,"?"
        JNZ     SHORT MUSTGETWORD
        OR      DL,1                    ; Flag ambiguous file name
        JMP     SHORT MUSTGETWORD
FILLNAM:
        MOV     AL," "
        REP     STOSB
        DEC     SI
        RETN

SCANB:
        LODSB
        CALL    SPCHK
        JZ      SCANB
        DEC     SI
        RETN

;
; NameTrans is used by FindPath to scan off an element
; of a path.  We must allow spaces in pathnames
; Inputs:   SS - DOSGROUP
;           DS:SI name
; Outputs:  DS:SI advanced over spot
;           ES:DI point to after Name1
; registers modified: AX, BX, CX, DX

NAMETRANS:
        ;MOV     BYTE PTR [SpaceFlag],1
        MOV     BYTE [SS:SpaceFlag],1
        PUSH    SS
        POP     ES
        MOV     DI,NAME1
        PUSH    DI
        MOV     AL,' '
        MOV     CX,11
        REP     STOSB
        XOR     AL,AL
        MOV     DL,AL
        STOSB
        POP     DI
        CMP     BYTE [SI],'.'
      
	;IF      KANJI
        ;JZ      FOOBAR
        ;CALL    NORMSCAN
        ;CMP     [NAME1],0E5H
        ;retnz
        ;MOV     [NAME1],5
        ;return
;FOOBAR:
        ;ELSE
        JNZ	SHORT NORMSCAN
        ;ENDIF

        MOVSB
        LODSB
        CALL    PATHCHRCMP
        JZ      SHORT GOTDOTNAME
        OR      AL,AL
        JZ      SHORT GOTDOTNAME
        CMP     AL,'.'
        JNZ     SHORT BADDOTS
        STOSB
        LODSB
        CALL    PATHCHRCMP
        JZ      SHORT GOTDOTNAME
        OR      AL,AL
        JZ      SHORT GOTDOTNAME
        DEC     SI
BADDOTS:
        DEC     SI
GOTDOTNAME:
        DEC     SI
        XOR     AL,AL
        RETN

;SUBTTL BUILDFCB -- MAKE A BLANK FCB FOR A DEVICE

BUILDFCB:

; Function:
;       Build a blank FCB for I/O to a device
; Outputs:
;       Same as GETNAME

        MOV     AX,"  "
        MOV     DI,DEVFCB+8     ; Point to extent field
        STOSW
        STOSB                   ; Blank out extent field
        XOR     AX,AX
        MOV     CX,10
        REP     STOSW           ; Fill FCB with zeros
        STOSB
        CALL	DATE16
        MOV     DI,DEVFCB+22
        XCHG    AX,DX
        STOSW
        XCHG    AX,DX
        STOSW
        XCHG    AX,BX           ; But device number in AH
        MOV     BX,DEVFCB
        MOV     SI,DI
        XOR     AL,AL           ; Set zero, clear carry
BUILDFCB_RETN:
	RETN

;SUBTTL MOVENAME, LODNAME -- EXAMINE FCB AND SETUP

FCB_move:
MOVNAMENOSET:
        MOV     DI,1
        JMP     SHORT MOVSTART

MOVNAME:

; Inputs:
;       DS, DX point to FCB or extended FCB
; Outputs:
;       DS:DX point to normal FCB
;       DS:SI point after end of NAME/EXT in FCB
;       ES = DOSGROUP
;       If file name OK:
;       [NAME1] has name in upper case
; All registers destroyed
; Carry set if bad file name or drive

        XOR     DI,DI
MOVSTART:
        ;MOV     WORD PTR [CREATING],0E500H ; Not creating, not DEL *.*
        MOV     WORD [SS:CREATING],0E500H
	MOV     SI,DX
        LODSB
        ;MOV     [EXTFCB],AL	; Set flag if extended FCB in use
        MOV     [SS:EXTFCB],AL	; Set flag if extended FCB in use
        XOR     AH,AH           ; Set default attributes
        CMP     AL,-1           ; Is it an extended FCB?
        JNZ     SHORT HAVATTRB
        ADD     DX,7            ; Adjust to point to normal FCB
        ADD     SI,6
        MOV     AH,[SI-1]       ; Attribute byte
        LODSB                   ; Get drive select byte
HAVATTRB:
        CALL	GETTHISDRV
        ;retc
        JC	SHORT BUILDFCB_RETN
	PUSH    DS
        PUSH    DX
        PUSH    SI
        PUSH    AX
;
; DS:DX is pointer to good FCB
; DS:SI is same
;
; Move the file into Name1 and UCASE it
;
        PUSH    DI
        ;context ES
        PUSH	SS
	POP	ES
	MOV     DI,NAME1
        CALL    LODNAME
        POP     DI
        JC      SHORT DrvNoSet
;
; are we setting current dir info?
;
        OR      DI,DI
        JNZ     SHORT DrvNoSet	; do not set dir info

;
; check for device name first, eliminating drive hits on devices
;
        ;context DS
        PUSH	SS
	POP	DS
	CALL	DEVNAME
        JNC     SHORT DrvNoSet	; we have a device
;
; make sure that everything is current
;
	CALL	FATREAD
        ;MOV     BYTE PTR [ATTRIB],attr_directory+attr_hidden+attr_system
        MOV     BYTE [SS:ATTRIB],attr_directory+attr_hidden+attr_system
 	CALL	GETCURRDIR
DrvNoSet:
        POP     AX
        ;MOV     BYTE PTR [ATTRIB],AH
	MOV     [SS:ATTRIB],AH

        POP     SI
        POP     DX
        POP     DS
        ;context ES
        PUSH	SS
	POP	ES
	MOV     DI,NAME1

LODNAME:

; Inputs:   DS:SI point to an FCB
;           ES:DI point to an FCB
; Outputs:  DS:SI point to after FCB
;           ES:DI point to after FCB
;                 FCB from DS:SI copied and ucased to ES:DI
; Carry set if there was an error.
; Destroys AX,CX
        CMP     BYTE [SI]," "	; Don't allow blank as first letter
        STC                     ; In case of error
        ;retz
	JZ	SHORT BUILDFCB_RETN

        ;IF      KANJI
        ;MOV     CX,8
        ;CMP     BYTE PTR [SI],0E5H
        ;JNZ     MOVCHK
        ;INC     SI
        ;MOV     AL,5
        ;STOSB
        ;MOVSB
        ;MOV     CX,6
;MOVCHK:
        ;CALL    GETLET
        ;JB      RET6
        ;JNZ     STOLET          ; Is it a delimiter?
        ;CMP     AL," "          ; This is the only delimiter allowed
        ;STC                     ; In case of error
        ;JNZ     RET6
;STOLET:
        ;STOSB
        ;CALL    TESTKANJ
        ;JZ      MOVLP           ;No
        ;LODSB                   ;Get second byte
        ;DEC     CX
        ;JZ      BOUNDERR        ;Attempt to cross boundry
        ;STOSB
;MOVLP:
        ;LOOP    MOVCHK
        ;MOV     CX,3
;MOVCHK2:
        ;CALL    GETLET
        ;JB      RET6
        ;JNZ     STOLET2         ; Is it a delimiter?
        ;CMP     AL," "          ; This is the only delimiter allowed
        ;STC                     ; In case of error
        ;retnz
;STOLET2:
        ;STOSB
        ;CALL    TESTKANJ
        ;JZ      MOVLP2          ;No
        ;LODSB                   ;Get second byte
        ;DEC     CX
        ;JNZ     DOSTORE
;BOUNDERR:                       ;Attempt to cross boundry
        ;STC
        ;return

;DOSTORE:
        ;STOSB
;MOVLP2:
        ;LOOP    MOVCHK2
        ;ELSE
        MOV     CX,11
MOVCHK:
        CALL    GETLET
        JB      SHORT RET6
        JNZ     SHORT STOLET	; Is it a delimiter?
        CMP     AL," "          ; This is the only delimiter allowed
        STC                     ; In case of error
        ;retnz
	;JNZ	SHORT BUILDFCB_RETN
	JNZ	SHORT RET6
STOLET:
        STOSB
        LOOP    MOVCHK
        ;ENDIF

        CLC                     ; Got through whole name - no error
RET6:   
	RETN

;SUBTTL GETLET, DELIM -- CHECK CHARACTERS AND CONVERT

GETLET:

; Get a byte from [SI], convert it to upper case, and compare for delimiter.
; ZF set if a delimiter, CY set if a control character (other than TAB).
        
	LODSB

        CMP     AL,"a"
        JB      SHORT CHK1
        CMP     AL,"z"
        JA      SHORT CHK1
        SUB     AL,20H          ; Convert to upper case
CHK1:
        PUSH    SI
        ;MOV     SI,[Current_Country]
        MOV	SI, [CS:Current_Country] ; Retro DOS v2.0 - 13/03/2018
	ADD     SI,INTERNAT_BLOCK.Map_call
        PUSH    CS              ; CS for long return
        CALL    WORD [CS:SI]
        POP     SI
CHK:
        CMP     AL,"."
        ;retz
        JZ	SHORT RET6
	CMP     AL,'"'
        ;retz
        JZ	SHORT RET6 
        CALL    PATHCHRCMP
        ;retz
        JZ	SHORT RET6
        CMP     AL,"["
        ;retz
        JZ	SHORT RET6
        CMP     AL,"]"
        ;retz
        JZ	SHORT RET6

DELIM:
        CMP     AL,":"          ; Allow ":" as separator in IBM version
        ;retz
        JZ	SHORT RET6

        CMP     AL,"<"
        ;retz
        JZ	SHORT RET6
        CMP     AL,"|"
        ;retz
        JZ	SHORT RET6
        CMP     AL,">"
        ;retz
        JZ	SHORT RET6

        CMP     AL,"+"
        ;retz
        JZ	SHORT RET6
        CMP     AL,"="
        ;retz
        JZ	SHORT RET6
        CMP     AL,";"
        ;retz
        JZ	SHORT RET6
        CMP     AL,","
        ;retz
        JZ	SHORT RET6
SPCHK:
        CMP     AL,9            ; Filter out tabs too
        ;retz
        JZ	SHORT RET6

; WARNING! " " MUST be the last compare

        CMP     AL," "
GETLET_RETN:
        RETN

PATHCHRCMP:

        CMP     AL,'/'
        ;retz
        JZ	SHORT GETLET_RETN
	CMP     AL,'\'
        RETN

        ;IF      KANJI
;procedure   TESTKANJ,NEAR
        ;CMP     AL,81H
        ;JB      NOTLEAD
        ;CMP     AL,9FH
        ;JBE     ISLEAD
        ;CMP     AL,0E0H
        ;JB      NOTLEAD
        ;CMP     AL,0FCH
        ;JBE     ISLEAD
;NOTLEAD:
        ;PUSH    AX
        ;XOR     AX,AX           ;Set zero
        ;POP     AX
        ;return
;ISLEAD:
        ;PUSH    AX
        ;XOR     AX,AX           ;Set zero
        ;INC     AX              ;Reset zero
        ;POP     AX
        ;return
;TESTKANJ  ENDP
        ;ENDIF
;do_ext
;
;CODE	ENDS
;    END

;============================================================================
; PROC.ASM (1)
;============================================================================

; process control system calls for MSDOS
;

;INCLUDE DOSSEG.ASM

;CODE    SEGMENT BYTE PUBLIC  'CODE'
;        ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;SUBTTL $WAIT - return previous process error code
;PAGE
;
; process control data
;
       ; i_need  exit_code,WORD          ; code of exit

;
;   Assembler usage:
;           MOV     AH, Wait
;           INT     int_command
;         AX has the exit code

        ;procedure   $WAIT,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
_$WAIT:
	; 15/03/2018
        ;MOV     AX,[exit_code]
        MOV     AX,[SS:exit_code]
	XOR     DX,DX
        ;MOV     [exit_code],DX
        MOV     [SS:exit_code],DX
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$WAIT   ENDP

; ---------------------------------------------------------------------------

;;IF IBM
;        ;procedure $EXEC,NEAR
;_$EXEC:
;        ;error   error_invalid_function  ; error macro
;	MOV	AL,error_invalid_function
;	jmp	SYS_RET_ERR
;
;$EXEC   ENDP
;ENDIF

;IF NOT IBM
;INCLUDE EXEC.ASM
;ENDIF

; 15/04/2018
;----------------------------------------------------------------------------
; EXEC.ASM (MSDOS 2.0)
;----------------------------------------------------------------------------

;SUBTTL $exec - load/go a program
;PAGE
;
; Assembler usage:
;           LDS     DX, name
;           LES     BX, blk
;           MOV     AH, Exec
;           MOV     AL, func
;           INT     int_command
;
;       AL  Function
;       --  --------
;        0  Load and execute the program.
;        1  Load, create the program header but do not
;           begin execution.
;        3  Load overlay. No header created.
;
;           AL = 0 -> load/execute program
;
;           +---------------------------+
;           | WORD segment address of   |
;           | environment.              |
;           +---------------------------+
;           | DWORD pointer to ASCIZ    |
;           | command line at 80h       |
;           +---------------------------+
;           | DWORD pointer to default  |
;           | FCB to be passed at 5Ch   |
;           +---------------------------+
;           | DWORD pointer to default  |
;           | FCB to be passed at 6Ch   |
;           +---------------------------+
;
;           AL = 1 -> load program
;
;           +---------------------------+
;           | WORD segment address of   |
;           | environment.              |
;           +---------------------------+
;           | DWORD pointer to ASCIZ    |
;           | command line at 80h       |
;           +---------------------------+
;           | DWORD pointer to default  |
;           | FCB to be passed at 5Ch   |
;           +---------------------------+
;           | DWORD pointer to default  |
;           | FCB to be passed at 6Ch   |
;           +---------------------------+
;           | DWORD returned value of   |
;           | CS:IP                     |
;           +---------------------------+
;           | DWORD returned value of   |
;           | SS:IP                     |
;           +---------------------------+
;
;           AL = 3 -> load overlay
;
;           +---------------------------+
;           | WORD segment address where|
;           | file will be loaded.      |
;           +---------------------------+
;           | WORD relocation factor to |
;           | be applied to the image.  |
;           +---------------------------+
;
; Returns:
;           AX = exec_invalid_function
;              = exec_bad_format
;              = exec_bad_environment
;              = exec_not_enough_memory
;              = exec_file_not_found
;

exec_blk:            DD  0
exec_func:           DB  0
exec_fh:             DW  0
exec_rel_fac:        DW  0
exec_res_len_para:   DW  0
exec_init_IP:        DW  0
exec_init_CS:        DW  0
exec_init_SP:        DW  0
exec_init_SS:        DW  0
exec_environ:        DW  0
exec_size:           DW  0
exec_load_block:     DW  0

exec_load_high:      DB  0

exec_internal_buffer EQU $
exec_signature:      DW  0		; must contain 4D5A  (yay zibo!)
exec_len_mod_512:    DW  0		; low 9 bits of length
exec_pages:          DW  0		; number of 512b pages in file
exec_rle_count:      DW  0		; count of reloc entries
exec_par_dir:        DW  0		; number of paragraphs before image
exec_min_BSS:        DW  0		; minimum number of para of BSS
exec_max_BSS:        DW  0		; max number of para of BSS
exec_SS:             DW  0		; stack of image
exec_SP:             DW  0		; SP of image
exec_chksum:         DW  0		; checksum  of file (ignored)
exec_IP:             DW  0		; IP of entry
exec_CS:             DW  0		; CS of entry
exec_rle_table:      DW  0		; byte offset of reloc table
exec_iov:            DW  0		; overlay number (0 for root)
exec_dma:            DW  0
exec_internal_buffer_size EQU $-exec_internal_buffer

;IF NOT IBM
;	procedure   $Exec,NEAR
;	ASSUME  DS:NOTHING, ES:NOTHING
;ENDIF

_$EXEC:
	; 15/04/2018
;
; validate function
;
	CMP     AL,3                    ; only 0, 1 or 3 are allowed
        JNA     short exec_check_2
exec_bad_fun:
        mov	al, error_invalid_function
exec_ret_err:
        jmp	SYS_RET_ERR

exec_check_2:
        CMP     AL,2
        JZ      short exec_bad_fun

        MOV     WORD [SS:exec_blk],BX  ; stash args
        MOV     WORD [SS:exec_blk+2],ES
        MOV     BYTE [SS:exec_func],AL
        MOV     BYTE [SS:exec_load_high],0

        XOR     AL,AL                   ; open for reading
        call	_$OPEN			; is the file there?
        JC      short exec_ret_err

        MOV     [SS:exec_fh],AX
        MOV     BX,AX

        XOR     AL,AL
        call	_$IOCTL

        TEST    DL,devid_ISDEV
        JZ	short exec_check_environ
        MOV     AL,exec_file_not_found
        JC      short exec_ret_err

exec_check_environ:
        MOV     WORD [SS:exec_load_block],0

        TEST    BYTE [SS:exec_func],exec_func_overlay ; overlays.. no environment
        JNZ     short exec_read_header
        LDS     SI,[SS:exec_blk] 	; get block
        MOV     AX,[SI]   		; address of environ
        OR      AX,AX
        JNZ     short exec_scan_env
        MOV     DS,[SS:CurrentPDB]
        MOV     AX,[PDB.ENVIRON]
        MOV     [SS:exec_environ],AX
        OR      AX,AX
        JZ      short exec_read_header

exec_scan_env:
        CLD
        MOV     ES,AX
        XOR     DI,DI
        MOV     CX,07FFFh               ; at most 32k of environment
        XOR     AL,AL

exec_get_environ_len:
        REPNZ   SCASB                   ; find that nul byte
        JZ      short exec_check	; CX is out... bad environment
        MOV     AL,exec_bad_environment
        JMP     exec_bomb

exec_check:
        SCASB                           ; is there another nul byte?
        JNZ	short exec_get_environ_len ; no, scan some more
        PUSH    DI
        MOV     BX,DI                   ; AX <- length of environment
        ADD     BX,0Fh
        MOV     CL,4
        SHR     BX,CL                   ; number of paragraphs needed
        PUSH    ES
	call	_$ALLOC			; can we get the space?
        POP     DS
        POP     CX
        ;JNC	short exec_save_environ
        ;JMP	short exec_no_mem	; nope... cry and sob
	jc	short exec_no_mem

exec_save_environ:
        MOV     ES,AX
        MOV     [SS:exec_environ],AX	; save him for a rainy day

        XOR     SI,SI
        XOR     DI,DI
        REP     MOVSB                   ; copy the environment

exec_read_header:
;
; We read in the program header into the above data area and determine
; where in this memory the image will be located.
;
        PUSH    SS
        POP     DS                      ; and put it in DS:DX
	;ASSUME  DS:DOSGROUP

        MOV     CX,exec_internal_buffer_size; header size
        MOV     BX,[exec_fh]            ; from the handle
        MOV     DX,exec_signature

        PUSH    ES
        PUSH    DS
        CALL    exec_dealloc
	call	_$READ
        CALL    exec_alloc
        POP     DS
        POP     ES
        JC	short exec_bad_file
        CMP     AX,exec_internal_buffer_size; did we read the right number?
        JNZ     short exec_com_filej	; yep... continue
        CMP	word [exec_max_BSS],0
        JNZ     short exec_check_sig
        MOV     byte [exec_load_high],-1
exec_check_sig:
        MOV     AX,[exec_signature]
        CMP     AX,exe_valid_signature  ; zibo arises!
        JZ      short exec_save_start	; assume com file if no signature
        CMP     AX,exe_valid_old_signature  ; zibo arises!
        JZ      short exec_save_start	; assume com file if no signature

exec_com_filej:
        JMP	exec_com_file

;
; We have the program header... determine memory requirements
;
exec_save_start:
        MOV     AX,[exec_pages]         ; get 512-byte pages
        MOV     CL,5                    ; convert to paragraphs
        SHL     AX,CL
        SUB     AX,[exec_par_dir]       ; AX = size in paragraphs
        MOV     [exec_res_len_para],AX

;
; Do we need to allocate memory?  Yes if function is not load-overlay
;
        TEST    BYTE [exec_func],exec_func_overlay
        JZ      short exec_allocate	; allocation of space
;
; get load address from block
;
        LES     DI,[exec_blk]
        MOV     AX,[ES:DI]
        MOV     [exec_dma],AX
        MOV     AX,[ES:DI+2]
        MOV     [exec_rel_fac],AX
        JMP     short exec_find_res

exec_no_mem:
        MOV     AL,exec_not_enough_memory
        JMP     SHORT exec_bomb             ; AX should be set by $ALLOC

exec_bad_file:
        MOV     AL,exec_bad_format

exec_bomb:
        ;ASSUME  DS:NOTHING,ES:NOTHING
        PUSH    AX
        MOV     BX,[SS:exec_fh]
        CALL    exec_dealloc
	call	_$CLOSE
        POP     AX
	jmp	SYS_RET_ERR

exec_allocate:
	;ASSUME  DS:DOSGROUP
        PUSH    AX
        MOV     BX,0FFFFh               ; see how much room in arena
        PUSH    DS
	call	_$ALLOC			; should have carry set and BX has max
        POP     DS
        POP     AX
        ADD     AX,10h                  ; room for header
        CMP     BX,11h                  ; enough room for a header
        JB	short exec_no_mem
        CMP     AX,BX                   ; is there enough for bare image?
        JA	short exec_no_mem
        CMP     byte [exec_load_high],0	; if load high, use max
        JNZ     short exec_BX_max	; use max
        ADD     AX,[exec_min_BSS]       ; go for min allocation
        JC	short exec_no_mem             ; oops! carry
        CMP     AX,BX                   ; enough space?
        JA	short exec_no_mem	; nope...
        SUB     AX,[exec_min_BSS]
        ADD     AX,[exec_max_BSS]       ; go for the MAX
        JC      exec_BX_max
        CMP     AX,BX
        JBE	short exec_got_block

exec_BX_max:
        MOV     AX,BX

exec_got_block:
        PUSH    DS
        MOV     BX,AX
        MOV     [exec_size],BX
	call	_$ALLOC                  ; get the space
        POP     DS
        JC	short exec_no_mem
        MOV     [exec_load_block],AX
        ADD     AX,10h
        CMP     byte [exec_load_high],0
        JZ      short exec_use_ax	; use ax for load info
        ADD     AX,[exec_size]          ; go to end
        SUB     AX,[exec_res_len_para]  ; drop off header
        SUB     AX,10h                  ; drop off pdb
exec_use_ax:
        MOV     [exec_rel_fac],AX       ; new segment
        MOV     [exec_dma],AX           ; beginning of dma

;
; Determine the location in the file of the beginning of the resident
;
exec_find_res:
        MOV     DX,[exec_par_dir]
        PUSH    DX
        MOV     CL,4
        SHL     DX,CL                   ; low word of location
        POP     AX
        MOV     CL,12
        SHR     AX,CL                   ; high word of location
        MOV     CX,AX                   ; CX <- high

;
; Read in the resident image (first, seek to it)
;
        MOV     BX,[exec_fh]
        PUSH    DS
        XOR     AL,AL
	call	_$LSEEK			; seek to resident
        POP     DS

exec_big_read:                          ; Read resident into memory
        MOV     BX,[exec_res_len_para]
        CMP     BX,1000h                ; too many bytes to read?
        JB      exec_read_ok
        MOV     BX,0FE0h                ; max in one chunk FE00 bytes

exec_read_ok:
        SUB     [exec_res_len_para],BX  ; we read (soon) this many
        PUSH    BX
        MOV     CL,4
        SHL     BX,CL                   ; get count in bytes from paras
        MOV     CX,BX                   ; count in correct register
        MOV     BX,[exec_fh]            ; handle in correct register
        PUSH    DS
        MOV     DS,[exec_dma]           ; Set up read buffer
        ;ASSUME  DS:NOTHING
        XOR     DX,DX
        PUSH    CX                      ; save our count
        CALL    exec_dealloc
	call	_$READ			; WOMP!
        CALL    exec_alloc
        POP     CX                      ; get old count to verify
        POP     DS
	;ASSUME  DS:DOSGROUP
        CMP     CX,AX                   ; did we read enough?
        POP     BX                      ; get paragraph count back
        JNZ	short exec_do_reloc	; and do reloc if no more to read
;
; We've read in CX bytes... bump DTA location
;

        ADD     [exec_dma],BX           ; bump dma address
        CMP     WORD [exec_res_len_para],0
        JNZ     short exec_big_read

;
; The image has now been read in.  We must perform relocation to
; the current location.
;

exec_do_reloc:
        MOV     CX,[exec_rel_fac]
        MOV     AX,[exec_SS]            ; get initial SS
        ADD     AX,CX                   ; and relocate him
        MOV     [exec_init_SS],AX

        MOV     AX,[exec_SP]            ; initial SP
        MOV     [exec_init_SP],AX

        LES     AX,[exec_IP]
        MOV     [exec_init_IP],AX
        MOV     AX,ES
        ADD     AX,CX                   ; relocated...
        MOV     [exec_init_CS],AX

        XOR     CX,CX
        MOV     DX,[exec_rle_table]
        MOV     BX,[exec_fh]
        PUSH    DS
        XOR     AX,AX
	call	_$LSEEK
        POP     DS
        JNC     short exec_get_entries
exec_bad_filej:
        JMP     exec_bad_file

exec_get_entries:
        MOV     DX,[exec_rle_count]     ; Number of entries left

exec_read_reloc:
        ;ASSUME  DS:NOTHING
        PUSH    DX
        MOV     DX,exec_signature
        MOV     CX,((exec_internal_buffer_size)/4)*4
        MOV     BX,[SS:exec_fh]
        PUSH    DS
        CALL    exec_dealloc
	call	_$READ
        CALL    exec_alloc
        POP     ES
        POP     DX
        JC      short exec_bad_filej
        MOV     CX,(exec_internal_buffer_size)/4
        MOV     DI,exec_signature	; Pointer to byte location in header
;
; Relocate a single address
;
        MOV     SI,[SS:exec_rel_fac]

exec_reloc_one:
        CMP     DX,0                    ; Any more entries?
        ;JNE	short exec_get_addr
        ;JMP	exec_set_PDB
	je	exec_set_PDB

exec_get_addr:
        LDS     BX,[ES:DI]		; Get ra/sa of entry
        MOV     AX,DS                   ; Relocate address of item
        ADD     AX,SI
        MOV     DS,AX
        MOV     AX,[BX]			; Relocate item
        ADD     AX,SI
        MOV     [BX],AX
        ADD     DI,4
        DEC     DX
        LOOP    exec_reloc_one		; End of internal buffer?
;
; We've exhausted a single buffer's worth.  Read in the next piece
; of the relocation table.
;
        PUSH    ES
        POP     DS
        JMP     short exec_read_reloc

exec_no_memj:
        JMP     exec_no_mem
;
; we have a .COM file.  First, determine if we are merely loading an overlay.
;
exec_com_file:
        TEST    byte [SS:exec_func],exec_func_overlay
        JZ      short exec_alloc_com_file
        LDS     SI,[SS:exec_blk]	; get arg block
        LODSW                           ; get load address
        MOV     [SS:exec_dma],AX
        JMP     SHORT exec_64K		; read it all!

; We must allocate the max possible size block (ick!) and set up
; CS=DS=ES=SS=PDB pointer, IP=100, SP=max size of block.
;
exec_alloc_com_file:
        MOV     BX,0FFFFh
	call	_$ALLOC			; largest piece available as error
        OR      BX,BX
        JZ	short exec_no_memj
        MOV     [SS:exec_size],BX	; save size of allocation block

        PUSH    BX
	call	_$ALLOC			; largest piece available as error
        POP     BX                      ; get size of block...

        MOV     [SS:exec_load_block],AX
        ADD     AX,10h                  ; increment for header
        MOV     [SS:exec_dma],AX
        SUB     BX,10h                  ; remember header

        CMP     BX,1000h                ; 64k or more?
        JAE     short exec_64K		; yes, read only 64k
        MOV     AX,BX                   ; convert size to bytes
        MOV     CL,4
        SHL     AX,CL
        JMP     SHORT exec_read_com

exec_64K:
        MOV     AX,0FFFFh               ; 64k-1 bytes

exec_read_com:
        PUSH    AX                      ; save number to read
        MOV     BX,[SS:exec_fh]		; of com file
        XOR     CX,CX                   ; but seek to 0:0
        MOV     DX,CX

	XOR     AX,AX                   ; seek relative to beginning
        call	_$LSEEK                  ; back to beginning of file

        MOV     BX,[SS:exec_fh]
        POP     CX                      ; number to read
        MOV     DS,[SS:exec_dma]
        XOR     DX,DX
        PUSH    CX
        CALL    exec_dealloc

	call	_$READ			; read in com file

        CALL    exec_alloc
        POP     SI                      ; get number of bytes to read
        CMP     AX,SI                   ; did we read them all?
        JZ      short exec_no_memj	; exactly the wrong number... no memory

        TEST    BYTE [SS:exec_func],exec_func_overlay
        JNZ     short exec_set_PDB	; no starto, chumo!
        MOV     AX,[SS:exec_dma]
        SUB     AX,10h
        MOV     [SS:exec_init_CS],AX
        MOV     WORD [SS:exec_init_IP],100h ; initial IP is 100h
        ; SI is at most FFFFh
        DEC     SI                      ; make room for stack
        ; SI is at most FFFEh, room for a 0!
        MOV     [SS:exec_init_SP],SI	; max value for read is also SP!
        MOV     [SS:exec_init_SS],AX
        MOV     DS,AX
        MOV     WORD [SI],0		; 0 for return

exec_set_PDB:
        MOV     BX,[SS:exec_fh]		; we are finished with the file.
        CALL    exec_dealloc
	
	call	_$CLOSE                  ; release the jfn

        CALL    exec_alloc
        TEST    BYTE [SS:exec_func],exec_func_overlay
        JZ	short exec_build_header
	jmp	SYS_RET_OK		; overlay load -> done

exec_build_header:
        MOV     DX,[SS:exec_load_block]
;
; assign the space to the process
;

        MOV     SI,ARENA.OWNER		; pointer to owner field

        MOV     AX,[SS:exec_environ]	; get environ pointer
        OR      AX,AX
        JZ	short NO_OWNER		; no environment
        DEC     AX                      ; point to header
        MOV     DS,AX
        MOV     [SI],DX			; assign ownership
NO_OWNER:
        MOV     AX,[SS:exec_load_block]	; get load block pointer
        DEC     AX
        MOV     DS,AX                   ; point to header
        MOV     [SI],DX			; assign ownership

        PUSH    DX
	MOV     BYTE [SS:CreatePDB], 0FFH ; indicate a new process
	call	_$DUP_PDB		; ES is now PDB
        POP     DX
        PUSH    word [SS:exec_environ]
        POP     word [ES:PDB.ENVIRON]
        MOV     SI,[SS:exec_size]
        ADD     SI,DX
        MOV	[ES:PDB.BLOCK_LEN],SI
;
; set up proper command line stuff
;
        LDS     SI,[SS:exec_blk]	; get the block
        PUSH    DS                      ; save its location
        PUSH    SI
        LDS     SI,[SI+6]		; get the 5c fcb
        MOV     CX,12                   ; copy drive, name and ext
        PUSH    CX
        MOV     DI,5Ch
        MOV     BL,[SI]
        REP     MOVSB
        XOR     AX,AX                   ; zero extent, etc for CPM
        STOSW
        STOSW
        POP     CX
        POP     SI                      ; get block
        POP     DS
        PUSH    DS                      ; save (again)
        PUSH    SI
        LDS     SI,[SI+0AH]		; get 6C FCB
        MOV     DI,6Ch                  ; do same as above
        MOV     BH,[SI]
        REP     MOVSB
        STOSW
        STOSW
        POP     SI                      ; get block (last time)
        POP     DS
        LDS     SI,[SI+2]		; command line
        MOV     CX,80h
        MOV     DI,CX
        REP     MOVSB                   ; Wham!

;
; Process BX into default AX (validity of drive specs on args)
;
        DEC     CL                      ; get 0FFh in CX
        CMP     BH,[SS:NUMIO]
        JBE     SHORT exec_BH_good
        MOV     BH,CL
        JMP     SHORT exec_BL
exec_BH_good:
        XOR     BH,BH
exec_BL:
        CMP     BL,[SS:NUMIO]
        JBE	SHORT exec_BL_good
        MOV     BL,CL
        JMP     SHORT exec_set_return
exec_BL_good:
        XOR     BL,BL
exec_set_return:
	CALL	get_user_stack          ; get his return address
        PUSH    WORD [SI+14H] 		; suck out the CS and IP
        PUSH    WORD [SI+12H] 
        PUSH    WORD [SI+14H] 		; suck out the CS and IP
        PUSH    WORD [SI+12H]
        POP     WORD [ES:PDB.EXIT]
        POP     WORD [ES:PDB.EXIT+2]
        XOR     AX,AX
        MOV     DS,AX
        POP     WORD [addr_int_terminate] ; save them where we can get them later
        POP     WORD [addr_int_terminate+2] ; when the child exits.

        MOV     WORD [SS:DMAADD],80h
        MOV     DS,[SS:CurrentPDB]
        MOV     [SS:DMAADD+2],DS

        TEST    BYTE [SS:exec_func],exec_func_no_execute
        JZ      SHORT exec_go

        LDS     SI,[SS:exec_init_SP]	; get stack
        LES     DI,[SS:exec_blk]	; and block for return
        MOV     [ES:DI+10H],DS     ; return SS

        DEC     SI                      ; 'push' default AX
        DEC     SI
        MOV     [SI],BX			; save default AX reg
        MOV	[ES:DI+0EH],SI	; return 'SP'

        LDS     AX,[SS:exec_init_IP]
        MOV     [ES:DI+14H],DS     ; initial entry stuff

        MOV     [ES:DI+12H],AX
	JMP	SYS_RET_OK

exec_go:
        LDS     SI,[SS:exec_init_IP]	; get entry point
        CLI
        MOV     BYTE [SS:INDOS],0

        MOV     SS,[SS:exec_init_SS]	; set up user's stack
	;ASSUME	SS:NOTHING
        MOV     SP,[SS:exec_init_SP]	; and SP
        STI
        PUSH    DS                      ; fake long call to entry
        PUSH    SI
        MOV     ES,DX                   ; set up proper seg registers
        MOV     DS,DX
        MOV     AX,BX                   ; set up proper AX
	
	RETF

exec_dealloc:
        PUSH	BX
        MOV	BX,arena_owner_system	; 0
        CALL	exec_do_change_owner
        POP	BX
        retn

exec_alloc:
        PUSH	BX
        MOV	BX,[CS:CurrentPDB]
        CALL	exec_do_change_owner
        POP	BX
        retn

exec_do_change_owner:
        PUSH    DS
        PUSH    AX
        MOV     AX,[CS:exec_environ]
        OR      AX,AX
        JZ      SHORT exec_alloc_try_load
        DEC     AX
        MOV     DS,AX
        MOV     [ARENA.OWNER],BX
exec_alloc_try_load:
        MOV     AX,[CS:exec_load_block]
        OR      AX,AX
        JZ      SHORT exec_alloc_done
        DEC     AX
        MOV     DS,AX
        MOV     [ARENA.OWNER],BX
exec_alloc_done:
        POP     AX
        POP     DS
        RETN

;============================================================================
; PROC.ASM (2)
;============================================================================

;SUBTTL Terminate and stay resident handler
;PAGE
;
; Input:    DX is  an  offset  from  CurrentPDB  at which to
;           truncate the current block.
;
; output:   The current block is truncated (expanded) to be [DX+15]/16
;           paragraphs long.  An exit is simulated via resetting CurrentPDB
;           and restoring the vectors.
;
        ;procedure   $Keep_process,NEAR
        ;ASSUME DS:NOTHING,ES:NOTHING,SS:DOSGROUP

_$KEEP_PROCESS:

        PUSH    AX                      ; keep exit code around
	; 15/03/2018
        ;MOV     BYTE [exit_type],Exit_Keep_Process
 	;MOV     ES,[CurrentPDB]
        MOV     BYTE [SS:exit_type],Exit_Keep_Process
 	MOV     ES,[SS:CurrentPDB]
        CMP     DX,6h                   ; keep enough space around for system
        JAE     short keep_shrink	; info
        MOV     DX,6h
keep_shrink:
        MOV     BX,DX
        PUSH    BX
        PUSH    ES
        call	$SETBLOCK               ; ignore return codes.
        POP     DS
        POP     BX
        JC      short keep_done		; failed on modification
        MOV     AX,DS
        ADD     AX,BX
        MOV     [PDB.BLOCK_LEN],AX

keep_done:
        POP     AX
        JMP     SHORT exit_inner        ; and let abort take care of the rest

;$Keep_process   ENDP

        ;procedure   Stay_resident,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING,SS:NOTHING

Stay_resident:        
	;MOV	AX,(Keep_process SHL 8) + 0 ; Lower part is return code
	MOV	AX,(KEEP_PROCESS*256) + 0 ; Lower part is return code
        ADD     DX,15
        MOV     CL,4
        SHR     DX,CL
        ;transfer COMMAND
	JMP	COMMAND

;Stay_resident   ENDP

;SUBTTL $EXIT - return to parent process
;PAGE
;
;   Assembler usage:
;           MOV     AL, code
;           MOV     AH, Exit
;           INT     int_command
;   Error return:
;           None.
;
        ;procedure $EXIT,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING,SS:DOSGROUP
_$EXIT:
        XOR     AH,AH
	; 15/03/2018
        ;XCHG    AH,[DidCTRLC]
	XCHG    AH,[SS:DidCTRLC]
        OR      AH,AH
        ;MOV     BYTE [exit_type],Exit_Terminate
        MOV     BYTE [SS:exit_type],Exit_Terminate
        JZ      SHORT exit_inner
        ;MOV     BYTE [exit_type],Exit_Ctrl_C
        MOV     BYTE [SS:exit_type],Exit_Ctrl_C
exit_inner:
        CALL	get_user_stack
        ;PUSH    WORD [CurrentPDB]
        PUSH    WORD [SS:CurrentPDB]
	POP     WORD [SI+14H]
        ;transfer abort_inner
	JMP	abort_inner

;$EXIT   ENDP

;do_ext

;CODE    ENDS
;    END

;============================================================================
; STDIO.ASM - (MSDOS 2.0)
;============================================================================

;
; Standard device IO for MSDOS (first 12 function calls)
;

;.xlist
;.xcref
;INCLUDE STDSW.ASM
;INCLUDE DOSSEG.ASM
;.cref
;.list

;TITLE   STDIO - device IO for MSDOS
;NAME    STDIO

;INCLUDE IO.ASM

; ---------------------------------------------------------------------------
;
; NOTE for Retro DOS v2.0 :  (ERDOGAN TAN - 13/03/2018)
;	  I0.ASM is missing in MSDOS 2.0 kernel source code files !!!
;	  INSTEAD of IO.ASM, I have disassembled IBMDOS.COM (MSDOS 2.0)
;			    and I have used CPMIO.ASM (MSDOS 6.0 source code)
;			    to restore MSDOS 2.0 device IO source code 
;
;		(STRIN.ASM has '$STD_CON_STRING_INPUT' code.)		
;
;============================================================================
; IO.ASM (MSDOS 2.0) (IBMDOS.COM 2.0) - STRIN.ASM (MSDOS 2.0, 19/08/1983)
;============================================================================
; Retro DOS v2.0 by Erdogan Tan, 13/03/2018 - 14/03/2018

; (Disassembled code of IBMDOS.COM, 08/03/1983) - Dissassembler: IDA Pro Free
; (Comments are from CPMIO.ASM - 1991, MSDOS 6.0) 

;**	Standard device IO for MSDOS (first 12 function calls)
;
;	TITLE	IBMCPMIO - device IO for MSDOS
;	NAME	IBMCPMIO

;	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input_No_Echo
;	$Std_Con_String_Output
;	$Std_Con_String_Input
;	$RawConIO
;	$RawConInput
;	RAWOUT
;	RAWOUT2
;

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

; ---------------------------------------------------------------------------

;	TITLE	CPMIO2 - device IO for MSDOS
;	NAME	CPMIO2

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;**	Old style CP/M 1-12 system calls to talk to reserved devices
;
;	$Std_Con_Input
;	$Std_Con_Output
;	OUTT
;	TAB
;	BUFOUT
;	$Std_Aux_Input
;	$Std_Aux_Output
;	$Std_Printer_Output
;	$Std_Con_Input_Status
;	$Std_Con_Input_Flush
;
;	Revision History:
;
;	  AN000	 version 4.00 - Jan. 1988

; The following routines form the console I/O group (funcs 1,2,6,7,8,9,10,11).
; They assume ES and DS NOTHING, while not strictly correct, this forces data
; references to be SS or CS relative which is desired.

;DOSCODE SEGMENT
;	ASSUME	SS:DOSDATA,CS:DOSCODE


;hkn; 	All the variables use SS override or DS. Therefore there is
;hkn;	no need to specifically set up any seg regs unless SS assumption is
;hkn;	not valid. 

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT - System Call 1
;
;	Input character from console, echo
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT:	;System call 1
	
	CALL	_$STD_CON_INPUT_NO_ECHO
	PUSH	AX
	CALL	OUTT
	POP	AX
CON_INPUT_RETN:	
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_OUTPUT - System Call 2
;
;	Output character to console
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_OUTPUT:	;System call 2

	MOV	AL,DL

OUTT:
	CMP	AL,20H ; " "
	JB	SHORT CTRLOUT
	CMP	AL,c_DEL ; 7Fh
	JZ	SHORT OUTCH
OUTCHA:	
	;INC	BYTE PTR [CARPOS]
	INC	BYTE [SS:CARPOS]
OUTCH:
	PUSH	DS
	PUSH	SI
	;INC	BYTE PTR [CHARCO]		;invoke  statchk...
	;AND	BYTE PTR [CHARCO],00111111B	;AN000; every 64th char
	INC	BYTE [SS:CHARCO]	
	;AND	BYTE [SS:CHARCO],00111111B
	; 14/03/2018
	and	byte [SS:CHARCO], 3  ; IBMDOS.COM, MSDOS 2.0
	JNZ	SHORT OUTSKIP
	PUSH	AX
	CALL	STATCHK
	POP	AX
OUTSKIP:
	CALL	RAWOUT				;output the character
	POP	SI
	POP	DS

	;TEST	BYTE PTR [PFLAG],-1
	;retz
	TEST	BYTE [SS:PFLAG],-1
	JZ	SHORT CON_INPUT_RETN

	PUSH	BX
	PUSH	DS
	PUSH	SI
	MOV	BX,1
	; MSDOS 6.0 (CPMIO2.ASM)
	;CALL	GET_IO_SFT		;hkn; GET_IO_SFT will set up DS:SI 
	;				;hkn; to sft entry
	;JC	SHORT TRIPOPJ
	;MOV	BX,[SI].SF_FLAGS
	;TEST	BX,sf_isnet	; 8000H		; output to NET?
	;JNZ	TRIPOPJ 			; if so, no echo
	;TEST	BX,devid_device ; 80H		; output to file?
	;JZ	SHORT TRIPOPJ 			; if so, no echo
	; 14/03/2018
	call	GET_IO_FCB	 ; IBMDOS.COM, MSDOS 2.0
	jc	short TRIPOPJ
	test	byte [SI+18H], 80h 		; [SI+18h]
	jz	short TRIPOPJ
	;MOV	BX,4
	;CALL	GET_IO_SFT
	;JC	SHORT TRIPOPJ
	;TEST	[SI].SF_FLAGS,sf_net_spool ; 800H ; StdPrn redirected?
	;JZ	SHORT LISSTRT2J			; No, OK to echo
	;MOV	BYTE [PFLAG],0			; If a spool, NEVER echo
	;MOV	BYTE [SS:PFLAG],0
	mov	bx, 4
	jmp	short LISSTRT2
	
TRIPOPJ:
	JMP	SHORT TRIPOP

;LISSTRT2J:
;	JMP	SHORT LISSTRT2

CTRLOUT:
	CMP	AL,c_CR ; 0Dh
	JZ	SHORT ZERPOS
	CMP	AL,c_BS ; 8
	JZ	SHORT BACKPOS
	CMP	AL,c_HT ; 9
	JNZ	SHORT OUTCH
	;MOV	AL,[CARPOS]
	MOV	AL,[SS:CARPOS]
	OR	AL,0F8H
	NEG	AL

TAB:
	PUSH	CX
	MOV	CL,AL
	MOV	CH,0
	JCXZ	POPTAB
TABLP:
	MOV	AL," "
	CALL	OUTT
	LOOP	TABLP
POPTAB:
	POP	CX
	RETN

ZERPOS:
	;MOV	BYTE PTR [CARPOS],0
	MOV	BYTE [SS:CARPOS],0
	JMP	SHORT OUTCH
OUTJ:	
	JMP	SHORT OUTT

BACKPOS:
	;DEC	BYTE PTR [CARPOS]
	DEC	BYTE [SS:CARPOS]
	JMP	SHORT OUTCH

BUFOUT:
	CMP	AL," "
	JAE	SHORT OUTJ		;Normal char
	CMP	AL,9
	JZ	SHORT OUTJ		;OUT knows how to expand tabs
	PUSH	AX
	MOV	AL,"^"
	CALL	OUTT		;Print '^' before control chars
	POP	AX
	OR	AL,40H		;Turn it into Upper case mate
	CALL	OUTT
BUFOUT_RETN:
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_INPUT - System Call 3
;
;	$STD_AUX_INPUT returns a character from Aux Input
;
;	ENTRY	none
;	EXIT	(al) = character
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_AUX_INPUT:	;System call 3

	CALL	STATCHK
	MOV	BX,3
	;CALL	GET_IO_SFT
	CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.0 (IBMDOS.COM)
	;retc
	JC	SHORT BUFOUT_RETN
	JMP	SHORT TAISTRT
AUXILP:
	CALL	SPOOLINT
TAISTRT:
	MOV	AH,1
	CALL	IOFUNC
	JZ	SHORT AUXILP
	XOR	AH,AH
	CALL	IOFUNC
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_AUX_OUTPUT - Output character to AUX
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_AUX_OUTPUT:	;System call 4

	PUSH	BX
	MOV	BX,3
	JMP	SHORT SENDOUT

;
;----------------------------------------------------------------------------
;
;**	$STD_PRINTER_OUTPUT - Output character to printer
;
;	ENTRY	(dl) = character
;	EXIT	none
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_PRINTER_OUTPUT:	;System call 5

	PUSH	BX
	MOV	BX,4

SENDOUT:
	MOV	AL,DL
	PUSH	AX
	CALL	STATCHK
	POP	AX
	PUSH	DS
	PUSH	SI
LISSTRT2:
	CALL	RAWOUT2
TRIPOP:
	POP	SI
	POP	DS
	POP	BX
	RETN

;----------------------------------------------------------------------------
;
; Procedure : $Std_Con_Input_No_Echo
;
;----------------------------------------------------------------------------

_$STD_CON_INPUT_NO_ECHO:   ;System call 8

; Inputs:
;	None
; Function:
;	Input character from console, no echo
; Returns:
;	AL = character

	push	ds
	push	si

INTEST:
	call	STATCHK
	jz	short INTEST
	xor	ah, ah
	call	IOFUNC
	pop	si
	pop	ds

NOSCAN:
	retn

;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_OUTPUT - Console String Output
;
;
;	ENTRY	(DS:DX) Point to output string '$' terminated
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------
;

_$STD_CON_STRING_OUTPUT:	;System call 9

	mov	si, dx
STRING_OUT1:	
	lodsb
	cmp	al, '$'
	jz	short NOSCAN
NEXT_STR1:
	call	OUTT
	jmp	short STRING_OUT1

;----------------------------------------------------------------------------
;
;**	$STD_CON_STRING_INPUT - Input Line from Console
;
;	$STD_CON_STRING_INPUT Fills a buffer from console input until CR
;
;	ENTRY	(ds:dx) = input buffer
;	EXIT	none
;	USES	ALL
;
;----------------------------------------------------------------------------

_$STD_CON_STRING_INPUT:		;System call 10

	mov	ax, ss
	mov	es, ax
	mov	si, dx
	xor	ch, ch
	lodsw

;	(AL) = the buffer length
;	(AH) = the template length

        or	al, al
        jz	short NOSCAN	;Buffer is 0 length!!?
	mov	bl, ah		;Init template counter
        mov	bh, ch		;Init template counter

;	(BL) = the number of bytes in the template

        cmp	al, bl
        jbe	short NOEDIT	;If length of buffer inconsistent with contents
        cmp	byte [bx+si], 0Dh ; c_CR
        jz	short EDITON	;If CR correctly placed EDIT is OK

; The number of chars in the template is >= the number of chars in buffer or
; there is no CR at the end of the template.  This is an inconsistant state
; of affairs.  Pretend that the template was empty:
;

NOEDIT:	
	mov	bl, ch		;Reset buffer
EDITON: 
	mov	dl, al
	dec	dx		;DL is # of bytes we can put in the buffer

;	Top level.  We begin to read a line in.

NEWLIN: 
	mov	al, [SS:CARPOS]
	mov	[SS:STARTPOS], al ;Remember position in raw buffer

	push	si
	mov	di, INBUF ;Build the new line here
	mov	byte [SS:INSMODE], ch ;Insert mode off
	mov	bh, ch		;No chars from template yet
	mov	dh, ch		;No chars to new line yet
	call	_$STD_CON_INPUT_NO_ECHO ;Get first char
	cmp	al, 0Ah	;c_LF	;Linefeed 
	jnz	short GOTCH

;	This is the main loop of reading in a character and processing it.
;
;	(BH) = the index of the next byte in the template
;	(BL) = the length of the template
;	(DH) = the number of bytes in the buffer
;	(DL) = the length of the buffer

GETCH:
	call	_$STD_CON_INPUT_NO_ECHO
GOTCH:
;
; Brain-damaged Tim Patterson ignored ^F in case his BIOS did not flush the
; input queue.
;
        cmp	al, "F"-"@"  ; CMP AL, 6  ; Ignore ^F
	jz	short GETCH

;	If the leading char is the function-key lead byte

        cmp	al, [SS:ESCCHAR]
        jz	short ESCAPE	;change reserved keyword DBM 5-7-87

;	Rubout and ^H are both destructive backspaces.

        cmp	al, c_DEL ; 7FH
        jz	short BACKSPJ
        cmp	al, c_BS  ; 8
        jz	short BACKSPJ

;	CR terminates the line.

        cmp	al, c_CR ; 0Dh
        jz	short ENDLIN

;	LF goes to a new line and keeps on reading.

        cmp	al, c_LF ; 0Ah
	jz	short PHYCRLF

;	^X (or ESC) deletes the line and starts over

	cmp	al, CANCEL ; 1Bh
	jz	short KILNEW

; Otherwise, we save the input character.

SAVCH:	
	cmp	dh, dl
	jnb	short BUFFUL		; buffer is full.
        stosb
	inc	dh                      ; increment count in buffer.
	call	BUFOUT			;Print control chars nicely

        cmp	byte [SS:INSMODE], 0
	jnz	short GETCH		; insertmode => don't advance template
        cmp	bh, bl
        jnb	short GETCH		; no more characters in template
        inc	si                      ; Skip to next char in template
        inc	bh                      ; remember position in template
        jmp	short GETCH

BACKSPJ: 
	jmp	short BACKSP

BUFFUL: 
	mov	al, 7			; Bell to signal full buffer
	call	OUTT
	jmp	short GETCH

ESCAPE: 
	;transfer OEMFunctionKey
	JMP	OEMFunctionKey

ENDLIN:
        stosb				; Put the CR in the buffer
	call	OUTT                    ; Echo it
        pop	di                      ; Get start of user buffer
        mov	[di-1], dh		; Tell user how many bytes
        inc	dh			; DH is length including CR

COPYNEW:
	; (IBMDOS.COM, MSDOS 2.0, STRIN.ASM)
	mov	bp, es
	mov	bx, ds
	mov	es, bx
	mov	ds, bp
	mov	si, INBUF
	mov	cl, dh
	rep	movsb
	retn

	; CPMIO.ASM (MSDOS 6.0)
	;;SAVE	<DS,ES>
	;PUSH	DS
	;PUSH	ES
	;;RESTORE <DS,ES>		; XCHG ES,DS
	;POP	DS
	;POP	ES

;;hkn; INBUF is in DOSDATA
        ;MOV     SI,INBUF
        ;MOV     CL,DH                   ; set up count
        ;REP     MOVSB                   ; Copy final line to user buffer
;OLDBAK_RETN:
        ;RETN

;Output a CRLF
CRLF:
	mov	al, c_CR ; 0Dh 
	call	OUTT
	mov	al, c_LF ; 0Ah
	jmp	OUTT

;	Output a CRLF to the user screen and do NOT store it into the buffer

PHYCRLF:
	CALL	CRLF
        JMP     GETCH

; The user wants to throw away what he's typed in and wants to start over.  We
; print the backslash and then go to the next line and tab to the correct spot
; to begin the buffered input.

KILNEW:
        mov	al, '\'
        call	OUTT            ;Print the CANCEL indicator
        pop	si		;Remember start of edit buffer
PUTNEW:
	call	CRLF            ;Go to next line on screen
	mov	al, [SS:STARTPOS]
	call	TAB             ;Tab over
        JMP     NEWLIN		;Start over again

;	Destructively back up one character position

BACKSP:
	or	dh, dh
	jz	short OLDBAK	;No chars in line, do nothing to line
	call	BACKUP          ;Do the backup
	mov	al, [es:di]	;Get the deleted char
        cmp	al, 20h	; ' '
	jnb	short OLDBAK	;Was a normal char
        cmp	al, c_HT ; 9
	jz	short BAKTAB	;Was a tab, fix up users display
        call	BACKMES         ;Was a control char, zap the '^'
OLDBAK:
        cmp	byte [SS:INSMODE], 0 ;In insert mode, get more chars
        jnz	short GETCH1
	or	bh, bh
        jz	short GETCH1	;Not advanced in template, stay where we are
        dec	bh		;Go back in template
        dec	si
GETCH1:
        jmp	GETCH

BAKTAB:
        push	di
        dec	di		;Back up one char
        std			;Go backward
        mov	cl, dh		;Number of chars currently in line
        mov	al, 20h	; ' '
        push	bx
        mov	bl, 7		;Max
        jcxz	FIGTAB		;At start, do nothing
FNDPOS:
        scasb			;Look back
	jbe	short CHKCNT
	cmp	byte [es:di+1], 9
	jz	short HAVTAB	;Found a tab
	dec	bl		;Back one char if non tab control char
CHKCNT:
        loop	FNDPOS
FIGTAB:		
	sub	bl, [SS:STARTPOS]
HAVTAB:
	sub	bl, dh
	add	cl, bl
	and	cl, 7		;CX has correct number to erase
	cld			;Back to normal
	pop	bx
	pop	di
	jz	short OLDBAK	;Nothing to erase
TABBAK:
	call	BACKMES
	loop	TABBAK		;Erase correct number of chars
	jmp	short OLDBAK

BACKUP:
        dec	dh             ;Back up in line
        dec	di
BACKMES:
        mov	al, c_BS ; 8	;Backspace
        call	OUTT
        mov	al, 20h ; ' '	;Erase
        call	OUTT
        mov	al, c_BS ; 8	;Backspace
	jmp	OUTT		;Done

;User really wants an ESC character in his line
TWOESC:	
	mov	al, [SS:ESCCHAR]
	jmp	SAVCH

;Copy the rest of the template
COPYLIN:
        mov	cl, bl		;Total size of template
	sub	cl, bh		;Minus position in template, is number to move
        jmp	short COPYEACH

COPYSTR:
	call	FINDOLD         ;Find the char
	jmp	short COPYEACH  ;Copy up to it

;Copy one char from template to line
COPYONE:
        mov	cl, 1
;Copy CX chars from template to line
COPYEACH:
        mov	byte [SS:INSMODE], 0	;All copies turn off insert mode
	cmp	dh, dl
        jz	short GETCH2		;At end of line, can't do anything
        cmp	bh, bl
        jz	short GETCH2		;At end of template, can't do anything
        lodsb
        stosb
	call	BUFOUT
        inc	bh			;Ahead in template
        inc	dh			;Ahead in line
        loop	COPYEACH
GETCH2:
        jmp	GETCH

;Skip one char in template
SKIPONE:
	cmp	bh, bl
	jz	short GETCH2		;At end of template
	inc	bh			;Ahead in templat
	inc	si
	jmp	GETCH

SKIPSTR:
	call	FINDOLD                 ;Find out how far to go
        add	si, cx			;Go there
        add	bh, cl
        jmp	GETCH

;Get the next user char, and look ahead in template for a match
;CX indicates how many chars to skip to get there on output
;NOTE: WARNING: If the operation cannot be done, the return
;       address is popped off and a jump to GETCH is taken.
;       Make sure nothing extra on stack when this routine
;       is called!!! (no PUSHes before calling it).
FINDOLD:
        call	_$STD_CON_INPUT_NO_ECHO
	; STRIN.ASM (MSDOS 2.11, 19/08/2018) 
	CMP     AL,[SS:ESCCHAR]            ; did he type a function key?
        CMP	AL,[SS:ESCCHAR]
	JNZ     SHORT FINDSETUP		; no, set up for scan
        CALL	_$STD_CON_INPUT_NO_ECHO	; eat next char
        JMP     SHORT NOTFND		; go try again
FINDSETUP:
	mov	cl, bl
        sub	cl, bh		;CX is number of chars to end of template
	jz	short NOTFND	;At end of template
        dec	cx		;Cannot point past end, limit search
        jz	short NOTFND	 ;If only one char in template, forget it
	push	es
	push	ds
	pop	es
	push	di
	mov	di, si		;Template to ES:DI
	inc	di
	repne	scasb		;Look
	pop	di
	pop	es
	jnz	short NOTFND	;Didn't find the char
        not	cl		;Turn how far to go into how far we went
        add	cl, bl		;Add size of template
        sub	cl, bh		;Subtract current pos, result distance to skip
FINDOLD_RETN:
	retn

NOTFND:
        pop	bp              ;Chuck return address
        jmp	GETCH

REEDIT:
	mov	al, '@'		;Output re-edit character
	call	OUTT
	pop	di
	push	di
	push	es
	push	ds
	call	COPYNEW		;Copy current line into template
	pop	ds
	pop	es
	pop	si
	mov	bl, dh		;Size of line is new size template
	jmp	PUTNEW		;Start over again

EXITINS:
ENTERINS:
	not	byte [SS:INSMODE]
	jmp	GETCH

;Put a real live ^Z in the buffer (embedded)
CTRLZ:
	mov	al, "Z"-"@" ; 1Ah
        jmp	SAVCH

;DOSCODE ENDS
;	END

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_STATUS - System Call 11
;
;	Check console input status
;
;	ENTRY	none
;	EXIT	AL = -1 character available, = 0 no character
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_STATUS:		 ;System call 11

	CALL	STATCHK
	MOV	AL,0			; no xor!!
	;retz
	JZ	SHORT SCIS_RETN ; 15/04/2018
	OR	AL,-1
SCIS_RETN:
	RETN

;
;----------------------------------------------------------------------------
;
;**	$STD_CON_INPUT_FLUSH - System Call 12
;
;	Flush console input buffer and perform call in AL
;
;	ENTRY	(AL) = DOS function to be called after flush (1,6,7,8,10)
;	EXIT	(al) = 0 iff (al) was not one of the supported fcns
;		return arguments for the fcn supplied in (AL)
;	USES	all
;
;----------------------------------------------------------------------------
;

_$STD_CON_INPUT_FLUSH:		;System call 12

	PUSH	AX
	PUSH	DX
	XOR	BX,BX
	;CALL	GET_IO_SFT
	CALL	GET_IO_FCB	; 14/03/2018 - MSDOS 2.0 (IBMDOS.COM)
	JC	SHORT BADJFNCON
	MOV	AH,4
	CALL	IOFUNC

BADJFNCON:
	POP	DX
	POP	AX
	MOV	AH,AL
	CMP	AL,1
	JZ	SHORT REDISPJ
	CMP	AL,6
	JZ	SHORT REDISPJ
	CMP	AL,7
	JZ	SHORT REDISPJ
	CMP	AL,8
	JZ	SHORT REDISPJ
	CMP	AL,10
	JZ	SHORT REDISPJ
	MOV	AL,0
	RETN

REDISPJ:
	CLI
	;transfer REDISP
	JMP	REDISP

;DOSCODE ENDS
;	END

;============================================================================
; TIME.ASM
;============================================================================
; Retro DOS v2.0 - 14/03/2018

; Time and date functions for MSDOS
;

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

;TITLE   TIME - time and date functions
;NAME    TIME

FOURYEARS EQU 3*365 + 366

;SUBTTL DATE16, READTIME, DODATE -- GUTS OF TIME AND DATE

;
; Date16 returns the current date in AX, current time in DX
;   AX - YYYYYYYMMMMDDDDD  years months days
;   DX - HHHHHMMMMMMSSSSS  hours minutes seconds/2
;

DATE16:
        PUSH    CX
        PUSH    ES
        CALL    READTIME
        POP     ES
        SHL     CL,1            ;Minutes to left part of byte
        SHL     CL,1
        SHL     CX,1            ;Push hours and minutes to left end
        SHL     CX,1
        SHL     CX,1
        SHR     DH,1            ;Count every two seconds
        OR      CL,DH           ;Combine seconds with hours and minutes
        MOV     DX,CX
        MOV     AX,[MONTH]	;Fetch month and year
        MOV     CL,4
        SHL     AL,CL		;Push month to left to make room for day
        SHL     AX,1
        POP     CX
        OR      AL,[DAY]
        RETN

READTIME:
;Gets time in CX:DX. Figures new date if it has changed.
;Uses AX, CX, DX.

        PUSH    SI
        PUSH    BX
        MOV     BX,TIMEBUF
        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
	CALL	SETREAD
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Get correct date and time
        POP     DS
        POP     BX
        POP     SI
        MOV     AX,[TIMEBUF]
        MOV     CX,[TIMEBUF+2]
        MOV     DX,[TIMEBUF+4]
        CMP     AX,[DAYCNT]     ;See if day count is the same
        JZ      SHORT RET22
        CMP     AX,FOURYEARS*30 ;Number of days in 120 years
        JAE     SHORT RET22	;Ignore if too large
        MOV     [DAYCNT],AX
        PUSH    SI
        PUSH    CX
        PUSH    DX              ;Save time
        XOR     DX,DX
        MOV     CX,FOURYEARS    ;Number of days in 4 years
        DIV     CX              ;Compute number of 4-year units
        SHL     AX,1
        SHL     AX,1
        SHL     AX,1            ;Multiply by 8 (no. of half-years)
        MOV     CX,AX           ;<240 implies AH=0
        MOV     SI,YRTAB        ;Table of days in each year
        CALL    DSLIDE          ;Find out which of four years we're in
        SHR     CX,1            ;Convert half-years to whole years
        JNC     SHORT SK	;Extra half-year?
        ADD     DX,200
SK:
        CALL    SETYEAR
        MOV     CL,1            ;At least at first month in year
        MOV     SI,MONTAB       ;Table of days in each month
        CALL    DSLIDE          ;Find out which month we're in
        MOV     [MONTH],CL
        INC     DX              ;Remainder is day of month (start with one)
        MOV     [DAY],DL
        CALL    WKDAY           ;Set day of week
        POP     DX
        POP     CX
        POP     SI
RET22:  
	RETN

DSLIDE:
        MOV     AH,0
DSLIDE1:
        LODSB			;Get count of days
        CMP     DX,AX           ;See if it will fit
        JB      SHORT RET23	;If not, done
        SUB     DX,AX
        INC     CX              ;Count one more month/year
        JMP     SHORT DSLIDE1

SETYEAR:
;Set year with value in CX. Adjust length of February for this year.
        MOV     [YEAR],CL
CHKYR:
        TEST    CL,3            ;Check for leap year
        MOV     AL,28
        JNZ     SHORT SAVFEB	;28 days if no leap year
        INC     AL              ;Add leap day
SAVFEB:
        MOV     [MONTAB+1],AL   ;Store for February
RET23:  
	RETN

DODATE:
        CALL    CHKYR           ;Set Feb. up for new year
        MOV     AL,DH
        MOV     BX,MONTAB-1
        XLAT                    ;Look up days in month
        CMP     AL,DL
        MOV     AL,-1           ;Restore error flag, just in case
        JB      SHORT RET25	;Error if too many days
        CALL    SETYEAR
        MOV     [DAY],DX	;Set both day and month
        SHR     CX,1
        SHR     CX,1
        MOV     AX,FOURYEARS
        MOV     BX,DX
        MUL     CX
        MOV     CL,[YEAR]
        AND     CL,3
        MOV     SI,YRTAB
        MOV     DX,AX
        SHL     CX,1            ;Two entries per year, so double count
        CALL    DSUM            ;Add up the days in each year
        MOV     CL,BH           ;Month of year
        MOV     SI,MONTAB
        DEC     CX              ;Account for months starting with one
        CALL    DSUM            ;Add up days in each month
        MOV     CL,BL           ;Day of month
        DEC     CX              ;Account for days starting with one
        ADD     DX,CX           ;Add in to day total
        XCHG    AX,DX           ;Get day count in AX
        MOV     [DAYCNT],AX
        PUSH    SI
        PUSH    BX
        PUSH    AX
        MOV     BX,TIMEBUF
        MOV     CX,6
        XOR     DX,DX
        MOV     AX,DX
        PUSH    BX
	CALL	SETREAD
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2	;Get correct date and time
        POP     DS
        POP     BX
	CALL	SETWRITE
        POP     WORD [TIMEBUF]
        PUSH    DS
        LDS     SI,[BCLOCK]
	CALL	DEVIOCALL2      ;Set the date
        POP     DS
        POP     BX
        POP     SI
WKDAY:
        MOV     AX,[DAYCNT]
        XOR     DX,DX
        MOV     CX,7
        INC     AX
        INC     AX              ;First day was Tuesday
        DIV     CX              ;Compute day of week
        MOV     [WEEKDAY],DL
        XOR     AL,AL           ;Flag OK
RET25:
	RETN

DSUM:
        MOV     AH,0
        JCXZ    RET25
DSUM1:
        LODSB
        ADD     DX,AX
        LOOP    DSUM1
        RETN

;CODE	ENDS
;    END

;============================================================================
; XENIX.ASM
;============================================================================

; xenix file calls for MSDOS
;

;INCLUDE DOSSEG.ASM

;IFNDEF  KANJI
;KANJI   EQU     0       ;FALSE
;ENDIF

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;	ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;TITLE   XENIX - IO system to mimic UNIX
;NAME    XENIX

        ;i_need  NoSetDir,BYTE
        ;i_need  CURDRV,BYTE
        ;i_need  IOCALL,BYTE
        ;i_need  IOMED,BYTE
        ;i_need  IOSCNT,WORD
        ;i_need  IOXAD,DWORD
        ;i_need  DIRSTART,WORD
        ;i_need  ATTRIB,BYTE
        ;i_need  THISFCB,DWORD
        ;i_need  AuxStack,BYTE
        ;i_need  Creating,BYTE
        ;i_need  ThisDRV,BYTE
        ;i_need  NAME1,BYTE
        ;i_need  LastEnt,WORD
        ;i_need  ThisDPB,DWORD
        ;i_need  EntLast,WORD
        ;i_need  CurrentPDB,WORD
        ;i_need  sft_addr,DWORD		; pointer to head of table
        ;i_need  CURBUF,DWORD		; pointer to current buffer
        ;i_need  DMAADD,DWORD		; pointer to current dma address

;BREAK <Local data>

;CODE   ENDS

;;DATA	SEGMENT BYTE PUBLIC 'DATA'
;
;open_name:   DW 0
;             DW 0
;open_access: DB 0
;open_jfn:    DW 0			; accessed as DD
;open_jfn_b:  DW 0			; accessed as DD with above
;open_sfn:    DW 0
;open_sfoff:  DW 0			; accessed as DD
;open_sfn_b:  DW 0			; accessed as DD with above
;open_devid:  DB 0
;Cr_read_only: DB 0
;rename_source: DD 0
;rename_dest: DD 0
;
;;DATA	ENDS

;CODE	SEGMENT BYTE PUBLIC 'CODE'

;BREAK <Validate_path - check to see if there are meta characters in path>

;
; Input: DS:DX is an ASCIZ path
; Output: Carry set if meta-characters present or path malformed and
;           Zero is set if the only problem is that meta-characters
;               are present in the last element of the path
;procedure Validate_path,near
        ;ASSUME  DS:NOTHING,ES:NOTHING

validate_path:
        
	PUSH    AX
        PUSH    CX
        PUSH    SI
        MOV     SI,DX
        MOV     CX,0FFH			; No path seps yet
        MOV     AX,[SI]			; Get first two bytes
        OR      AL,AL
        JZ      SHORT validate_malformed	; NUL path
        CMP     AH,':'
        JNZ     SHORT validate_loop		; OK so far
        CMP     BYTE [SI+2],0
        JZ      SHORT validate_malformed	; NUL path (just d:)
validate_loop:
        LODSB
validate_loop1:

        ;IF      KANJI
        ;invoke  TESTKANJ
        ;JZ      NOTKANJ6
        ;INC     SI
        ;JMP     validate_loop
;
;NOTKANJ6:
;        ENDIF

        OR      AL,AL
        JZ      SHORT validate_end
        CMP     AL,"?"
        JZ      SHORT validate_error
        CMP     AL,"*"
        JZ      SHORT validate_error
        ;invoke PathChrCmp
        CALL	PATHCHRCMP
	JNZ     SHORT validate_loop
        JCXZ    validate_malformed	;If path sep, cannot have meta yet
        LODSB				;Look ahead one char
        OR      AL,AL
        JZ      SHORT validate_checktslsh ;Trailing path sep
        ;invoke	PathChrCmp
        CALL	PATHCHRCMP
        JNZ     SHORT validate_loop1	;Double path sep?
validate_malformed:
        INC     CX
        OR      CX,CX                   ;Reset zero
        JMP     SHORT validate_set_carry

validate_error:
        XOR     CX,CX                   ;Flag metas found
        JMP     SHORT validate_loop

validate_checktslsh:
;A bizarre case, "/" is OK, "d:/" is OK, anything else is an error
        SUB     SI,DX
        CMP     SI,2
        JZ      SHORT validate_end	;Two chars, the '/' and the NUL
        CMP     SI,4
        JNZ     SHORT validate_malformed ;Four chars, "D:/<NUL>"
        MOV     SI,DX
        CMP     BYTE [SI+1],':'
        JNZ     SHORT validate_malformed ;Second char must be a ':'

validate_end:
        OR      CX,CX                   ;Clears carry
        JNZ     SHORT validate_ok	;No metas found, leave carry clear
validate_set_carry:
        STC
validate_ok:
        POP     SI
        POP     CX
        POP     AX
        RETN

;validate_path   ENDP

;BREAK <Access_path - determine if file found>

;
; Input: DS:DX point to a path
; Output: Carry reset - outputs of GetPath
;         carry set - AL has error code
;
        ;procedure   Access_path,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

access_path:
        CALL	validate_path
        JC      SHORT access_no_path
        MOV     SI,DX
	;invoke	GetPath
        CALL	GETPATH
        ;retnc
        jnc	short ACCESS_RET
	MOV     AL,error_file_not_found
        OR      CL,CL
        JNZ     short access_STC_ret
access_no_path:
        MOV     AL,error_path_not_found
access_STC_ret:
        STC
ACCESS_RET:
        ;return
	RETN

;access_path ENDP

;BREAK <Find_free_jfn - return a free jfn in users PDB>
;
; system file table data
;

; The system file table is two linear tables.  The first table is the
; DOS initialization table containing a default number of FCBs.  The
; first word in the table is a link to the second table, which
; SYSINIT sets up, the second word is the number of FCBs in the table.

;
; find_free_jfn
; input:    none
; output:   JNC <found>
;               ES:DI is pointer to free JFN
;           JC  <no free jfns>
;               ES,DI indeterminate
;
        ;procedure   Find_free_jfn,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

Find_free_jfn:
        
	PUSH    AX
        PUSH    CX
        MOV     AL,0FFh
        ;MOV	ES,[CurrentPDB]
	MOV     ES,[SS:CurrentPDB] ; 15/03/2018
        MOV     DI,PDB.JFN_TABLE
        MOV     CX,FILPERPROC
        REPNE   SCASB
        STC
        JNZ     SHORT Find_jfn_ret
        DEC     DI
        CLC
Find_jfn_ret:
        POP     CX
        POP     AX
        RETN

;Find_free_jfn   ENDP

;BREAK <find_free_sfn - return a free sfn and sf pointer>

; find_free_sfn
; input:    none
; output:   JNC <found>
;               ES:DI is free sf entry
;               SI is sfn
;           JC  <not found>
;               ES,DI,SI indeterminate
;
; sft_addr -->  (link) count (fcbs)
; links = -1 means end of list
;
        ;procedure   Find_free_sfn,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

Find_free_sfn:

        PUSH    BX
        PUSH    CX
        ;LES     BX,[SFT_ADDR]		; head of chain of tables
        LES     BX,[SS:SFT_ADDR] ; 15/03/2018
	XOR     SI,SI                   ; count of sfn

        ; ES:BX points to table... search through table
Find_sfn_in_table:
        CMP     BX,-1                   ; end of chain
        JZ      SHORT Find_no_free_sfns
        MOV     DI,SFT.SFT_TABLE	; offset to sf entry
        MOV     CX,[ES:BX+4] 		; count of fcbs in table

Find_sfn:
        ;CMP	BYTE [ES:BX+DI+SF_ENTRY.sf_ref_count],0h
        CMP	BYTE [ES:BX+DI],0 ; SF_ENTRY.sf_ref_count = 0
        JZ      SHORT Find_got_sfn	; ref count is 0 -> free entry
        ADD     DI,SF_ENTRY.size	; look to next entry
        INC     SI                      ; bump sfn
        LOOP    Find_sfn
        LES     BX,[ES:BX]		; link to next
        JMP     SHORT Find_sfn_in_table ; look for more

Find_no_free_sfns:
        STC
        JMP     SHORT Find_ret
Find_got_sfn:
        ADD     DI,BX
        CLC
Find_ret:
        POP     CX
        POP     BX
        RETN

;Find_free_sfn   ENDP

;BREAK <$Open - open a file handle>

;   Assembler usage:
;           LDS     DX, Name
;           MOV     AH, Open
;           MOV     AL, access
;           INT     int_command
;
;       ACCESS          Function
;       ------          --------
;       open_for_read   file is opened for reading
;       open_for_write  file is opened for writing
;       open_for_both   file is opened for both reading and writing.
;
;   Error returns:
;           AX = error_invalid_access
;              = error_file_not_found
;              = error_access_denied
;              = error_too_many_open_files
;

        ;procedure   $Open,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
_$OPEN:       
	;MOV     BYTE [Cr_read_only],0
	MOV     BYTE [SS:Cr_read_only],0 ; 14/03/2018
open_create:
        CMP     AL,open_for_both        ; validate access
        JBE     SHORT open_get_jfn
        ;error  error_invalid_access	; error macro (in DOSMAC.ASM)
	MOV	AL,error_invalid_access
	JMP	SYS_RET_ERR

open_get_jfn:
        ;MOV     [open_name+2],DS
        MOV	[SS:open_name+2],DS ; 14/03/2018
	;context DS			; context macro (in DOSMAC.ASM)
        PUSH	SS
	POP	DS
		;ASSUME  DS:DOSGROUP
	MOV     [open_name],DX
        MOV     [open_access],AL

        ;invoke	Find_free_jfn		; scan through user's area
	CALL	Find_free_jfn	
        ; ES:DI is the jfn entry
        JNC     SHORT open_get_sfn
open_too_many:
        ;error	error_too_many_open_files
	MOV	AL,error_too_many_open_files
	JMP	SYS_RET_ERR

open_get_sfn:
        MOV     [open_jfn_b],ES
        MOV     [open_jfn],DI

        ;invoke	Find_free_sfn           ; get a free sft entry
	CALL	Find_free_sfn
        ; ES:DI is the SFT entry that's free, SI is the sfn
        JC      SHORT open_too_many

open_file:
        MOV     [open_sfn],SI
        MOV     [open_sfoff],DI
        MOV     [open_sfn_b],ES
;
; open the file
;
        PUSH    DS
        LDS     DX,[open_name]
        ;ASSUME  DS:NOTHING
        CALL    access_path
        POP     DS
        ;ASSUME  DS:DOSGROUP
        JNC	SHORT open_check_access	; carry set -> error

        ;transfer SYS_RET_ERR
	JMP	SYS_RET_ERR

open_check_access:
        MOV     ES,[CURBUF+2]		; get buffer location
        MOV     [open_devid],AH
        TEST    AH,80h
        JNZ     SHORT open_set_fcb_dev	; is a device
        MOV     AL,[ES:BX+0BH]
        TEST    AL,attr_directory       ; can't open directories
        JZ      short open_try_volid

open_bad_access:
        ;error	error_access_denied
	MOV	AL,error_access_denied
	JMP	SYS_RET_ERR

open_try_volid:
        TEST    AL,attr_volume_id       ; can't open volume ids
        JNZ     SHORT open_bad_access
        TEST    AL,attr_read_only       ; check write on read only
        JZ      SHORT open_set_fcb
        CMP     BYTE [Cr_read_only],0
        JNZ     SHORT open_set_fcb	; ok if creating read only file
        CMP     BYTE [open_access], open_for_read
        JNZ     SHORT open_bad_access	; writing on a read only file
        JMP     SHORT open_set_fcb

open_set_fcb_dev:
        PUSH    SS
        POP     ES                      ;Device opens are DOSGROUP relative

open_set_fcb:
        MOV     CX,11                   ; copy name into FCB...
        PUSH    SI                      ; ES:BX is source, must change
        MOV     SI,BX                   ; ES:SI is source
        MOV     DI,[open_sfoff]		; ??:DI is dest
        PUSH    DS
        PUSH    ES
        MOV     ES,[open_sfn_b]		; ES:DI is dest
        POP     DS                      ; DS:SI is source
        ;ASSUME  DS:NOTHING
;
; need to save attribute for the close operation
;
        MOV     AH,[BX+0BH] 		; save attribute for close
        MOV     [ES:DI+2],AH

        ADD     DI,SF_ENTRY.sf_fcb+1	; point to name

        ;IF      KANJI
        ;MOVSB
        ;CMP     BYTE PTR ES:[DI-1],5
        ;JNZ     NOTKTRAN
        ;MOV     BYTE PTR ES:[DI-1],0E5H
;NOTKTRAN:
        ;DEC     CX
        ;ENDIF

        REP     MOVSB                   ; move in parsed name
        POP     DS
        ;ASSUME	DS:DOSGROUP
        POP     SI
        LES     DI,[open_sfoff]
        ADD     DI,SF_ENTRY.sf_fcb	; offset on fcb in sf entry
        MOV     AH,[open_devid]
        ;invoke	DOOPEN                  ; let open code fill in blanks
        CALL	DOOPEN
	;context DS
        PUSH	SS
	POP	DS
		;ASSUME	DS:DOSGROUP
	LES     DI,[open_sfoff]
        ;INC	BYTE [ES:DI+SF_ENTRY.sf_ref_count] ; reference this FCB
        INC	BYTE [ES:DI]	; SF_ENTRY.sf_ref_count = 0
	MOV     AL,[open_access]	; stash the access
        MOV     [ES:DI+1],AL
        XOR     AX,AX
        MOV     [ES:DI+24H],AX ; beginning of file
        MOV     [ES:DI+26H],AX
        INC     AX
        MOV     [ES:DI+11H],AX ; byte io only
        LES     DI,[open_jfn]
        MOV     AX,[open_sfn]
        MOV     [ES:DI],AL		; stash sfn in PDB
        SUB     DI,PDB.JFN_TABLE	; get jfn for user
        MOV     AX,DI
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$Open   ENDP

;BREAK <$UNLINK - delete a file entry>

;
;   Assembler usage:
;           LDS     DX, name
;           MOV     AH, Unlink
;           INT     21h
;
;   Error returns:
;           AX = error_file_not_found
;              = error_access_denied
;
        ;procedure   $UNLINK,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$UNLINK:
	CALL    access_path
        JNC     SHORT unlink_check_attr
        ;transfer SYS_RET_ERR
	JMP	SYS_RET_ERR

unlink_check_attr:
        JZ      SHORT unlink_dir
        ;LDS     DI,[CURBUF]	; get directory entry
        LDS     DI,[SS:CURBUF] ; 14/03/2018
	TEST    BYTE [BX+0BH],attr_read_only
        JZ      SHORT unlink_doit

unlink_dir:
        ;error	error_access_denied
	MOV	AL, error_access_denied
	JMP	SYS_RET_ERR
	
unlink_doit:
        MOV     BYTE [BX+18H],0E5h ; delete dir entry
        MOV     BYTE [DI+5],1	; dirty the buffer
        LODSW
        MOV     BX,AX
        AND     BX,0FFFh
        ;context DS
        PUSH	SS
	POP	DS
	JZ      SHORT unlink_flush
        ;invoke	RELEASE
	CALL	RELEASE
unlink_flush:
        MOV     AL,[ES:BP]
        ;invoke FLUSHBUF
        CALL	FLUSHBUF
	;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$UNLINK ENDP

;BREAK <$CREAT - creat a new file and open him for input>

;   Assembler usage:
;           LDS     DX, name
;           MOV     AH, Creat
;           MOV     CX, access
;           INT     21h
;       ; AX now has the handle
;
;   Error returns:
;           AX = error_access_denied
;              = error_path_not_found
;              = error_too_many_open_files
;
        ;procedure $CREAT,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$CREAT:        
	CALL    validate_path
        JNC     SHORT unlink_do_make
        ;error	error_path_not_found
	MOV	AL,error_path_not_found
	JMP	SYS_RET_ERR

unlink_do_make:
        PUSH    DX
        PUSH    DS
        ;context DS
        PUSH	SS
	POP	DS
		; ASSUME DS:DOSGROUP
	MOV     WORD [CREATING],0E5FFh
        ;MOV	WORD PTR [THISFCB+2],SS
	MOV     [THISFCB+2],SS
        ;MOV    WORD PTR [THISFCB],OFFSET DOSGROUP:AUXSTACK-40
        MOV     WORD [THISFCB],AUXSTACK-40
        MOV     SI,DX
        MOV     AL,CL
        AND     CL,attr_read_only
        MOV     [Cr_read_only],CL
        POP     DS
        PUSH    DS
;ASSUME  DS:NOTHING
        ;invoke MakeNode
        CALL	MAKENODE
	POP     DS
        POP     DX
        OR      AL,AL
        JZ      SHORT creat_open
        CMP     AL,3
        JZ      SHORT creat_open
creat_no_access:
        ;error	error_access_denied
	MOV	AL,error_access_denied
	JMP	SYS_RET_ERR
creat_open:
        MOV     AL,open_for_both
        ;JMP	open_create
	JMP	open_get_jfn	; Retro DOS v2.0 - 04/03/2018	

;$CREAT ENDP

;BREAK <$DUP - duplicate a jfn>

;   Assembler usage:
;           MOV     BX, fh
;           MOV     AH, Dup
;           INT     int_command
;         AX has the returned handle
;   Errors:
;           AX = dup_invalid_handle
;              = dup_too_many_open_files
        ;procedure   $DUP,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
_$DUP:        
	;context DS
        PUSH	SS
	POP	DS
	;invoke Find_free_jfn
        CALL	Find_free_jfn
	JC      SHORT dup_no_free_handles

dup_force:
        PUSH    ES
        PUSH    DI
        ;invoke	Get_sf_from_jfn
	CALL	get_sf_from_jfn
        POP     SI
        POP     DS
        JC      SHORT dup_bad_handle
        ; ES:DI is pointer to sf entry
        ; DS:DI is pointer to jfn
        ;INC	BYTE [ES:DI+SF_ENTRY.sf_ref_count] 
				; another jfn reference...
        INC	BYTE [ES:DI]	; SF_ENTRY.sf_ref_count = 0
        MOV     AL,[BX+0BH]	; get old sfn
        MOV     [SI],AL                 ; store in new place
        SUB     SI,PDB.JFN_TABLE	; get jfn
        MOV     AX,SI
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

dup_no_free_handles:
        ;error	error_too_many_open_files
	MOV	AL,error_too_many_open_files
	JMP	SYS_RET_ERR

dup_bad_handle:
        ;error	error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

;$DUP    ENDP

;BREAK <$DUP2 - force a dup on a particular jfn>

;
;   Assembler usage:
;           MOV     BX, fh
;           MOV     CX, newfh
;           MOV     AH, Dup2
;           INT     int_command
;   Error returns:
;           AX = error_invalid_handle
;
        ;procedure   $DUP2,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
_$DUP2:     
	XCHG    BX,CX                   ; BX < destination jfn
        PUSH    BX
        PUSH    CX
        ;invoke	$CLOSE                  ; close BX
        CALL	_$CLOSE
	;context DS
        PUSH	SS
	POP	DS
	POP     CX
        POP     BX
        ;invoke Get_jfn_pointer
        CALL	get_jfn_pointer
	XCHG    BX,CX
        JNC     SHORT dup_force
lseek_bad_handle:
        ;error	error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

;$DUP2   ENDP

;BREAK <$CHMOD - change file attributes>

;   Assembler usage:
;           LDS     DX, name
;           MOV     CX, attributes
;           INT     21h
;   Error returns:
;           AX = error_path_not_found
;           AX = error_access_denied
;
        ;procedure $CHMOD,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
_$CHMOD:        
	CMP     AL,1
        JBE     SHORT chmod_save
        ;error	error_invalid_function
	MOV	AL,error_invalid_function
	JMP	SYS_RET_ERR
chmod_save:
        JB      SHORT chmod_try_file
        MOV     BX,CX
        AND     BX,~attr_changeable  ; NOT attr_changeable
        JZ      SHORT chmod_try_file

chmod_bad:
        ;error	error_access_denied
	MOV	AL,error_access_denied
chmod_bye:			; Retro DOS v2.0 - 04/03/2018
	JMP	SYS_RET_ERR

;chmod_bye:
        ;transfer SYS_RET_ERR
	;JMP	SYS_RET_ERR

chmod_try_file:
        PUSH    CX
        PUSH    AX
        CALL    access_path
        POP     DX
        POP     CX
        JC	SHORT chmod_bye
        ;LES     DI,[CURBUF]
        LES     DI,[SS:CURBUF] ; 15/03/2018
	;context DS
        PUSH	SS
	POP	DS
	OR      DL,DL
        JZ      SHORT chmod_fetch
        AND     BYTE [ES:BX+0BH],~attr_changeable
        OR      BYTE [ES:BX+0BH],CL
        MOV     BYTE [ES:DI+5],1
        MOV     AL,-1
	;invoke	FlushBuf
        CALL	FLUSHBUF
	;transfer SYS_RET_OK
	JMP	SYS_RET_OK
chmod_fetch:
        XOR     CX,CX
        MOV     CL,[ES:BX+0BH]
        ;invoke Get_user_stack
        CALL	get_user_stack
	;MOV	[SI.user_CX],CX
	MOV     [SI+4],CX
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$chmod  ENDP

;BREAK <$CURRENT_DIR - dump the current directory into user space>

;   Assembler usage:
;               LDS     SI,area
;               MOV     DL,drive
;               INT     21h
;           ; DS:SI is a pointer to 64 byte area that contains drive
;           ; current directory.
;   Error returns:
;           AX = error_invalid_drive

;procedure   $CURRENT_DIR,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$CURRENT_DIR:

        PUSH    DS
        PUSH    BX
        PUSH    SI
        ;invoke $get_DPB
	CALL	_$GET_DPB
;
; ES:BP points to DPB.  DS:SI points to user stack, unless error
;
        CMP     AL,0FFh
        JNZ     SHORT current_copy
        POP     AX              ; Clean Stack
        POP     AX
        POP     AX
        ;error	error_invalid_drive
	MOV	AL,error_invalid_drive
	JMP	SYS_RET_ERR

current_copy:
        POP     DI              ; where to move to
        ;POP	[SI.user_BX]    ; restore old BX
        POP	WORD [SI+2]
	POP     BX
        ;MOV	[SI.user_DS],BX ; and restore old DS
	MOV	[SI+0EH],BX
;
; ES:BP is pointer to DPB. BX:DI is pointer to destination
;
        CMP     WORD [ES:BP+1CH],-1
        JNZ     SHORT current_ok
        PUSH    BX
        PUSH    DI
        ;MOV     BYTE [ATTRIB],attr_all
        MOV	BYTE [SS:ATTRIB],attr_all ; 12/03/2018
	;invoke GETCURRDIR
	CALL	GETCURRDIR
        POP     DI
        POP     BX
current_ok:
        MOV     SI,BP           ; ES:SI is source
        PUSH    ES
        POP     DS              ; DS:SI is source
        MOV     ES,BX           ; ES:DI is destination
        ;CMP	[SI.dpb_current_dir],0
        CMP	WORD [SI+1CH],0
	JNZ     SHORT current_move
        ;MOV	BYTE PTR [SI.dpb_dir_text],0
        MOV     BYTE [SI+1EH],0

current_move:
        ADD     SI,DPB.DIR_TEXT
        MOV     CX,DIRSTRLEN
current_loop:
        LODSB
        STOSB
        OR      AL,AL
        LOOPNZ  current_loop
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$CURRENT_DIR    ENDP

;BREAK <$RENAME - move directory entries around>

;   Assembler usage:
;           LDS     DX, source
;           LES     DI, dest
;           MOV     AH, Rename
;           INT     21h
;
;   Error returns:
;           AX = error_file_not_found
;              = error_not_same_device
;              = error_access_denied

;procedure   $RENAME,near

_$RENAME:
	; 12/03/2018
        ;MOV     [rename_source],DX
        ;MOV     [rename_source+2],DS
        ;MOV     [rename_dest],DI
        ;MOV     [rename_dest+2],ES
	MOV     [SS:rename_source],DX
        MOV     [SS:rename_source+2],DS
        MOV     [SS:rename_dest],DI
        MOV     [SS:rename_dest+2],ES
        CALL    access_path
        JNC     SHORT rename_check_dir
        ;transfer SYS_RET_ERR
	JMP	SYS_RET_ERR

rename_check_dir:
        JZ      SHORT rename_no_access
        ;MOV     DS,[CurBuf+2]
	MOV     DS,[SS:CURBUF+2] ; 12/03/2018
        PUSH    WORD [BX+18H]
        PUSH    WORD [BX+1AH]
        PUSH    WORD [BX+1EH]
        PUSH    WORD [BX+1CH]
        PUSH    WORD [BX+16H]
        PUSH    WORD [BX+0BH]
	; 12/03/2018
        ;PUSH    WORD [ThisDrv]
        ;LDS     SI,[rename_dest]
        PUSH    WORD [SS:THISDRV]
        LDS     SI,[SS:rename_dest]
        ;invoke GetPath
        call	GETPATH
	POP     AX
        JC      SHORT rename_check_drives
rename_bad_access:
        ADD     SP,12
rename_no_access:
        ;error	error_access_denied
	MOV	AL,error_access_denied
	JMP	SYS_RET_ERR

rename_check_drives:
        ;CMP     AL,[ThisDrv]
        CMP	AL, [SS:THISDRV] 	; 12/03/2018
	JZ      SHORT rename_create
        ADD     SP,12
        ;error	error_not_same_device
	MOV	AL,error_not_same_device
	JMP	SYS_RET_ERR

rename_create:
	; 12/03/2018
        ;LDS     SI,[rename_dest]
        LDS     SI,[SS:rename_dest]
        POP     AX
        PUSH    AX
	;MOV     WORD [Creating],0E5FFh
        ;MOV     [THISFCB+2],SS
        ;MOV     WORD [THISFCB],AUXSTACK-40
	MOV     WORD [SS:CREATING],0E5FFh
        MOV     [SS:THISFCB+2],SS
        MOV     WORD [SS:THISFCB],AUXSTACK-40
        ;invoke	MakeNode
	CALL	MAKENODE
        JC      SHORT rename_bad_access
        ;LDS     SI,[CURBUF]
        LDS	SI,[SS:CURBUF]
	POP     AX
        MOV     [BX+0BH],AL
        POP     WORD [BX+16H]
        POP     WORD [BX+1CH]
        POP     WORD [BX+1EH]
        POP     WORD [BX+1AH]
        POP     WORD [BX+18H]
        MOV     BYTE [SI+5],1
        ;LDS     SI,[rename_source]
	LDS	SI,[SS:rename_source]
        ;invoke	GetPath
        CALL	GETPATH
	;LDS     SI,[CURBUF]
	LDS     SI,[SS:CURBUF]
        MOV     BYTE [BX],0E5h
        MOV     BYTE [SI+5],1
        ;context DS
        PUSH	SS
	POP	DS
	MOV     AL,0FFh
        ;invoke FlushBuf
	CALL	FLUSHBUF
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$RENAME ENDP

;BREAK <$FIND_FIRST - find first matching xenix filename>

;   Assembler usage:
;           MOV AH, FindFirst
;           LDS DX, name
;           MOV CX, attr
;           INT 21h
;       ; DMA address has datablock
;
;   Error Returns:
;           AX = error_file_not_found
;              = error_no_more_files

;procedure  $FIND_FIRST,near
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$FIND_FIRST:        
	CALL	validate_path
        JNC     SHORT find_get
        JZ      SHORT find_get
        ;error	error_file_not_found
	MOV	AL,error_file_not_found
	JMP	SYS_RET_ERR
find_get:
        MOV     SI,DX
        PUSH    CX
	; 12/03/2018
        ;INC     BYTE [NoSetDir] ; if we find a dir, don't change to it
        INC     BYTE [SS:NoSetDir]
        ;MOV     WORD [Creating],0E500h
        MOV     WORD [SS:CREATING],0E500h
	CALL    GETPATH
        POP     CX
        ;MOV     [Attrib],CL
	mov	[SS:ATTRIB],CL
find_check:
        JNC     SHORT find_check_attr
find_no_more:
        ;error	error_no_more_files
	MOV	AL,error_no_more_files
	JMP	SYS_RET_ERR
find_check_attr:
        ;MOV     DS,[CURBUF+2]
        MOV     DS,[SS:CURBUF+2]
	MOV     CH,[BX+0BH]
        ;invoke MatchAttributes
        CALL	MatchAttributes
	JZ      SHORT found_it
        ;PUSH    WORD [LastEnt]
	PUSH    WORD [SS:LASTENT]
        ;MOV     BX,[DirStart]
	MOV     BX,[SS:DIRSTART]
        JMP     find_it_next
found_it:
        ;LES     DI,[DMAADD]
        ;MOV     AL,[Attrib]
        LES     DI,[SS:DMAADD]
        MOV     AL,[SS:ATTRIB]
        STOSB                           ; find_buf 0 = attribute in search
        ;MOV     AL,[ThisDrv]
        MOV     AL,[SS:THISDRV]
        STOSB                           ; find_buf 1 = drive
        MOV     CX,11
        PUSH    BX
        MOV     SI,NAME1		; find_buf 2 = formatted name
        PUSH    DS
        PUSH    SS
        POP     DS

        ;IF      KANJI
        ;MOVSB
        ;CMP     BYTE PTR ES:[DI-1],5
        ;JNZ     NOTKANJB
        ;MOV     BYTE PTR ES:[DI-1],0E5H
;NOTKANJB:
        ;DEC     CX
        ;ENDIF

        REP     MOVSB
        POP     DS
        ;MOV     AX,[LastEnt]
        MOV     AX,[SS:LASTENT]
        STOSW                           ; find_buf 13 = LastEnt
        ;MOV     AX,[ThisDPB]
        MOV     AX,[SS:THISDPB]
        STOSW                           ; find_buf 15 = ThisDPB
        ;MOV     AX,[ThisDPB+2]
        MOV     AX,[SS:THISDPB+2]
        STOSW
        ;MOV     AX,[DirStart]
        MOV     AX,[SS:DIRSTART]
        STOSW                           ; find_buf 19 = DirStart
        MOV     AL,[BX+0BH]
        STOSB                           ; find_buf 21 = attribute found
        MOV     AX,[BX+16H]
        STOSW                           ; find_buf 22 = time
        MOV     AX,[BX+18H]
        STOSW                           ; find_buf 24 = date
        MOV     AX,[BX+1CH]
        STOSW                           ; find_buf 26 = low(size)
        MOV     AX,[BX+1EH]
        STOSW                           ; find_buf 28 = high(size)
        POP     SI
        MOV     CX,8                    ; find_buf 30 = packed name
find_loop_name:
        LODSB
        STOSB
        CMP     AL," "
        LOOPNZ  find_loop_name
        JNZ	SHORT find_check_dot
        DEC     DI
find_check_dot:
        ADD     SI,CX
        CMP     BYTE [SI]," "
        JZ      SHORT find_done
        MOV     AL,"."
        STOSB
        MOV     CX,3
find_loop_ext:
        LODSB
        STOSB
        CMP     AL," "
        LOOPNZ  find_loop_ext
        JNZ     SHORT find_done
        DEC     DI
find_done:
        XOR     AL,AL
        STOSB
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$FIND_FIRST ENDP

;BREAK <$FIND_NEXT - scan for match in directory>

;   Assembler usage:
;       ; dma points at area returned by find_first
;           MOV AH, findnext
;           INT 21h
;       ; next entry is at dma
;
;   Error Returns:
;           AX = error_no_more_files

;procedure   $FIND_NEXT,near
        ;ASSUME  DS:NOTHING,ES:NOTHING
        
_$FIND_NEXT:
	;LDS     SI,[DMAADD]
        LDS	SI, [SS:DMAADD] ; 12/03/2018
	MOV     DX,SI
        INC     DX
        PUSH    SI
        ;invoke	MOVNAMENOSET
        CALL	MOVNAMENOSET
	POP     SI
        JNC     SHORT find_load

findnext_no_more:
        ;error	error_no_more_files
	MOV	AL,error_no_more_files
	JMP	SYS_RET_ERR

find_load:
        MOV     AX,[SI+0DH]
        LES     BP,[SI+0FH]
        OR      AX,AX
        JS      SHORT findnext_no_more
        ;MOV    BX,[SI.find_buf_DirStart]
        MOV     BX,[SI+13H]
	MOV     DL,[SI]
	; 12/03/2018
        ;MOV     [Attrib],DL
        MOV	[SS:ATTRIB],DL
	PUSH    AX
        ;MOV     [ThisDPB],BP
        ;MOV     [ThisDPB+2],ES
        MOV     [SS:THISDPB],BP
        MOV     [SS:THISDPB+2],ES
find_it_next:
        ;invoke SetDirSrch
        CALL	SETDIRSRCH
	;ASSUME DS:DOSGROUP
        POP     AX
        MOV     WORD [ENTLAST],-1
        ;invoke GetEnt
        CALL	GETENT
        ;invoke NextEnt
        CALL	NEXTENT
        JMP     find_check

;$find_next  ENDP

;do_ext

;CODE    ENDS
;    END

;============================================================================
; XENIX2.ASM
;============================================================================

;
; xenix file calls for MSDOS
;

;INCLUDE DOSSEG.ASM

;IFNDEF  KANJI
;KANJI   EQU     0       ;FALSE
;ENDIF

;CODE	SEGMENT BYTE PUBLIC  'CODE'
;       ASSUME  SS:DOSGROUP,CS:DOSGROUP

;.xlist
;.xcref
;INCLUDE DOSSYM.ASM
;INCLUDE DEVSYM.ASM
;.cref
;.list

;TITLE   XENIX - IO system to mimic UNIX
;NAME    XENIX

        ;i_need  NoSetDir,BYTE
        ;i_need  CURDRV,BYTE
        ;i_need  IOCALL,BYTE
        ;i_need  IOMED,BYTE
        ;i_need  IOSCNT,WORD
        ;i_need  IOXAD,DWORD
        ;i_need  DIRSTART,WORD
        ;i_need  ATTRIB,BYTE
        ;i_need  THISFCB,DWORD
        ;i_need  AuxStack,BYTE
        ;i_need  Creating,BYTE
        ;i_need  ThisDRV,BYTE
        ;i_need  NAME1,BYTE
        ;i_need  LastEnt,WORD
        ;i_need  ThisDPB,DWORD
        ;i_need  EntLast,WORD
        ;i_need  CurrentPDB,WORD
        ;i_need  sft_addr,DWORD              ; pointer to head of table
        ;i_need  CURBUF,DWORD                ; pointer to current buffer
        ;i_need  DMAADD,DWORD                ; pointer to current dma address

;BREAK <Local data>

;CODE        ENDS

;;DATA        SEGMENT BYTE PUBLIC 'DATA'
;
;;PushSave    DW      ?
;;PushES      DW      ?
;;PushBX      DW      ?
;;xenix_count DW      ?
;
;; 02/04/2018
;
;PushSave:    DW 0
;PushES:      DW 0
;PushBX:      DW 0
;xenix_count: DW 0
;
;;DATA	ENDS

;CODE	SEGMENT BYTE PUBLIC 'CODE'

;BREAK <get_sf_from_sfn - translate a sfn into sf pointer>
;
; get_sf_from_sfn
; input:    AX has sfn (0 based)
;           DS is DOSGROUP
; output:   JNC <found>
;               ES:DI is sf entry
;           JC  <error>
;               ES,DI indeterminate
;
        ;procedure get_sf_from_sfn,NEAR
        ;ASSUME  DS:DOSGROUP,ES:NOTHING
 
get_sf_from_sfn:
       
	PUSH    AX                      ; we trash AX in process
        LES     DI,[SFT_ADDR]

get_sfn_loop:
        CMP     DI,-1                   ; end of chain of tables?
        JZ      SHORT get_sf_invalid	; I guess so...
        SUB     AX,[ES:DI+4] 		; chop number of entries in this table
        JL      SHORT get_sf_gotten	; sfn is in this table
        LES     DI,[ES:DI]		; step to next table
        JMP     SHORT get_sfn_loop

get_sf_gotten:
        ;ADD	AX,ES:[DI].sft_count    ; reset to index in this table
        ADD	AX,[ES:DI+4]
	PUSH    BX
        ;MOV	BX,SIZE sf_entry
        MOV	BX, SF_ENTRY.size
	MUL     BL                      ; number of bytes offset into table
        POP     BX
        ;ADD	AX,sft_table            ; offset into sf table structure
        ADD	AX,SFT.SFT_TABLE
	ADD     DI,AX                   ; offset into memory
        CLC
        JMP     SHORT get_sf_ret

get_sf_jfn_invalid:
get_sf_invalid:
        STC

get_sf_jfn_ret:
get_sf_ret:
        POP     AX                      ; remember him?
        RETN

;get_sf_from_sfn ENDP

;BREAK <get_sf_from_jfn - translate a jfn into sf pointer>

; get_sf_from_jfn
; input:    BX is jfn 0 based
;           DS is DOSGROUP
; output:   JNC <found>
;               ES:DI is sf entry
;           JC  <error>
;               ES,DI is indeterminate
;
        ;procedure   get_sf_from_jfn,NEAR
        ;ASSUME  DS:DOSGROUP,ES:NOTHING

get_sf_from_jfn:
        
	PUSH    AX                      ; save him
        ;invoke get_jfn_pointer
        CALL	get_jfn_pointer
	JC      SHORT get_sf_jfn_invalid
        MOV     AL,[ES:DI]              ; get sfn
        CMP     AL,0FFh                 ; is it free?
        JZ      SHORT get_sf_jfn_invalid ; yep... error
        XOR     AH,AH
        ;invoke get_sf_from_sfn         ; check this sfn out...
        CALL	get_sf_from_sfn         
	JMP     SHORT get_sf_jfn_ret    ; condition codes are properly set

;get_sf_from_jfn ENDP

;BREAK <get_jfn_pointer - map a jfn into a pointer to jfn>

; get_jfn_pointer
; input:    BX is jfn
;           DS is DOSGROUP
; output:   JNC <found>
;               ES:DI is pointer to jfn
;           JC  <bad jfn>
;
        ;procedure Get_jfn_pointer,NEAR
        ;ASSUME  DS:DOSGROUP,ES:NOTHING
        
get_jfn_pointer:

	CMP     BX,FILPERPROC
        JAE     SHORT get_jfn_bad
        MOV     ES,[CurrentPDB]
        MOV     DI,BX
        ;ADD    DI,PDB_JFN_Table
        ADD	DI,PDB.JFN_TABLE
	CLC
        RETN

get_jfn_bad:
        STC
        RETN

;get_jfn_pointer ENDP


;BREAK <$Close - release a handle>

;   Assembler usage:
;           MOV     BX, handle
;           MOV     AH, Close
;           INT     int_command
;
;   Error return:
;           AX = error_invalid_handle
;
        ;procedure   $Close,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$CLOSE:
        ;context DS
	PUSH	SS
	POP	DS
	;invoke get_jfn_pointer         ; get jfn loc
        CALL	get_jfn_pointer
	JNC     short close_jfn

close_bad_handle:
        ;error	error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

close_jfn:
        MOV     AL,[ES:DI]
        CMP     AL,0FFh
        JE      SHORT close_bad_handle
        MOV     BYTE [ES:DI],0FFh
        XOR     AH,AH
        ;invoke	get_sf_from_sfn
        CALL	get_sf_from_sfn
	JC      SHORT close_bad_handle
        PUSH    ES
        POP     DS
        ;ASSUME  DS:NOTHING
        ;DEC	[DI].sf_ref_count       ; no more reference
        DEC	BYTE [DI]
	;LEA    DX,[DI.sf_fcb]
	LEA     DX,[DI+3]

;
; need to restuff Attrib if we are closing a protected file
;
        ;TEST	[DI.sf_fcb.fcb_DevID],devid_file_clean+devid_device
	TEST	BYTE [DI+1BH],devid_file_clean+devid_device
        JNZ     SHORT close_ok
        ;PUSH	WORD PTR [DI].sf_attr
        PUSH	WORD [DI+2]
	;invoke MOVNAMENOSET
        CALL	MOVNAMENOSET
	POP     BX
        ;MOV     [ATTRIB],BL
        MOV	[SS:ATTRIB],BL ; 14/03/2018
	;invoke FCB_CLOSE_INNER
        CALL	FCB_CLOSE_INNER
	CMP     AL,0FFh                 ; file not found error?
        JNZ     SHORT close_ok
        ;error	error_file_not_found
	MOV	AL,error_file_not_found
	JMP	SYS_RET_ERR

close_ok:
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$Close  ENDP

;BREAK <PushDMA, PopDMA, ptr_normalize - set up local dma and save old>
; PushDMA
; input:    DS:DX is DMA
; output:   DS:DX is normalized , ES:BX destroyed
;           [DMAADD] is now set up to DS:DX
;           old DMA is pushed

        ;procedure   PushDMA,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
PushDMA:
	; 15/03/2018
        ;MOV     [PushES],ES
        ;MOV     [PushBX],BX
        ;POP     WORD [PushSave]
        ;LES     BX,[DMAADD]		; get old dma
        MOV     [SS:PushES],ES
        MOV     [SS:PushBX],BX
        POP     WORD [SS:PushSave]
        LES     BX,[SS:DMAADD]
	PUSH    ES
        PUSH    BX
        ;PUSH    WORD [PushSave]
        PUSH    WORD [SS:PushSave]
        CALL	ptr_normalize           ; get new dma
        ;MOV     [DMAADD],DX		; save IT!
        ;MOV     [DMAADD+2],DS
        ;MOV     ES,[PushES]
        ;MOV     BX,[PushBX]
        MOV     [SS:DMAADD],DX
        MOV     [SS:DMAADD+2],DS
        MOV     ES,[SS:PushES]
        MOV     BX,[SS:PushBX]
        RETN

;PushDMA ENDP

; PopDMA
; input:    old DMA under ret address on stack
; output:   [DMAADD] set to old version and stack popped
        ;procedure   PopDMA,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING
PopDMA:
        ;POP     WORD [PushSave]
        ;POP     WORD [DMAADD]
        ;POP     WORD [DMAADD+2]
        ;PUSH    WORD [PushSave]
        POP     WORD [SS:PushSave]
        POP     WORD [SS:DMAADD]
        POP     WORD [SS:DMAADD+2]
        PUSH    WORD [SS:PushSave]
        RETN

;PopDMA  ENDP

; ptr_normalize
; input:    DS:DX is a pointer
; output:   DS:DX is normalized (DX < 10h)
        ;procedure ptr_normalize,NEAR
        
ptr_normalize:
	PUSH    CX                      ; T1 = CX
        PUSH    DX                      ; T2 = DX
        MOV     CL,4
        SHR     DX,CL                   ; DX = (DX >> 4)    (using CX)
        MOV     CX,DS
        ADD     CX,DX
        MOV     DS,CX                   ; DS = DS + DX      (using CX)
        POP     DX
        AND     DX,0Fh                  ; DX = T2 & 0Fh
        POP     CX                      ; CX = T1

;       PUSH    AX
;       PUSH    DX
;       MOV     AX,DS
;       PUSH    CX
;       MOV     CL,4
;       SHR     DX,CL                   ; get upper part of dx
;       POP     CX
;       ADD     AX,DX                   ; add into seg address
;       MOV     DS,AX
;       POP     DX
;       AND     DX,0Fh                  ; save low part
;       POP     AX

        RETN

;ptr_normalize   ENDP

;BREAK <$Read - Do file/device I/O>

;   Assembler usage:
;           LDS     DX, buf
;           MOV     CX, count
;           MOV     BX, handle
;           MOV     AH, Read
;           INT     int_command
;         AX has number of bytes read
;   Errors:
;           AX = read_invalid_handle
;              = read_access_denied
;
        ;procedure   $Read,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$READ:
        ;invoke	PushDMA
	CALL	PushDMA
        CALL    IO_setup
        JC      SHORT IO_err
        CMP     BYTE [ES:DI+1],open_for_write
        JNE     SHORT read_setup
IO_bad_mode:
        MOV     AL,read_access_denied
IO_err:
        ;invoke PopDMA
        CALL	PopDMA
	;transfer SYS_RET_ERR
	JMP	SYS_RET_ERR

read_setup:
        ;invoke	$FCB_RANDOM_READ_BLOCK  ; do read
	CALL	_$FCB_RANDOM_READ_BLOCK
IO_done:
        ;invoke	get_user_stack          ; get old frame
	CALL	get_user_stack
        ;MOV	AX,[SI].user_CX         ; get returned CX
        MOV	AX,[SI+4]
	;MOV     CX,[xenix_count]
	MOV     CX,[SS:xenix_count] ; 15/03/2018
        ;MOV	[SI].user_CX,CX         ; stash our CX
        MOV	[SI+4],CX
	;invoke PopDMA                  ; get old DMA
        CALL	PopDMA
	;transfer SYS_RET_OK
	JMP	SYS_RET_OK

;$Read   ENDP

;BREAK <$Write - Do file/device I/O>

;   Assembler usage:
;           LDS     DX, buf
;           MOV     CX, count
;           MOV     BX, handle
;           MOV     AH, Write
;           INT     int_command
;         AX has number of bytes written
;   Errors:
;           AX = write_invalid_handle
;              = write_access_denied
;

        ;procedure   $Write,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$WRITE:
        ;invoke	PushDMA
        CALL	PushDMA
	CALL    IO_setup
        JC      SHORT IO_err
        ;CMP	ES:[DI].sf_mode,open_for_read
        CMP	BYTE [ES:DI+1],open_for_read
        JE      SHORT IO_bad_mode
        ;invoke $FCB_RANDOM_WRITE_BLOCK ; do write
        CALL	_$FCB_RANDOM_WRITE_BLOCK
        JMP     SHORT IO_done

;$write  ENDP

IO_setup:
        ;ASSUME  DS:NOTHING,ES:NOTHING
        ;context DS
        PUSH	SS
	POP	DS
	MOV     [xenix_count],CX
        ;invoke Get_sf_from_jfn
	CALL	get_sf_from_jfn
        ; ES:DI is sf pointer
        MOV     AL,read_invalid_handle          ;Assume an error
        MOV     CX,[xenix_count]
        ;LEA	DX,[DI].sf_fcb
	LEA	DX,[DI+3]
        PUSH    ES
        POP     DS
        ;ASSUME  DS:NOTHING
        RETN

;BREAK <$LSEEK - set random record field>

;   Assembler usage:
;           MOV     DX, offsetlow
;           MOV     CX, offsethigh
;           MOV     BX, handle
;           MOV     AL, method
;           MOV     AH, LSeek
;           INT     int_command
;         DX:AX has the new location of the pointer
;   Error returns:
;           AX = error_invalid_handle
;              = error_invalid_function

        ;procedure   $LSEEK,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$LSEEK:
        CMP     AL,3
        JB      SHORT lseek_get_sf
        ;error	error_invalid_function
	MOV	AL,error_invalid_function
	JMP	SYS_RET_ERR

lseek_get_sf:
        ;context DS
        PUSH	SS
	POP	DS
	;invoke get_sf_from_jfn
	CALL	get_sf_from_jfn
        PUSH    ES
        POP     DS
        ;ASSUME  DS:NOTHING
        JC      SHORT lseek_bad
;
; don't seek device
;
        ;TEST	[DI.sf_fcb+fcb_devid],devid_device
        TEST	BYTE [DI+1BH],devid_device
        JZ      SHORT lseek_dispatch
        XOR     AX,AX
        XOR     DX,DX
        JMP     SHORT lseek_ret
lseek_dispatch:
        DEC     AL
        JL      SHORT lseek_beginning
        DEC     AL
        JL      SHORT lseek_current
; move from end of file
; first, get end of file
        XCHG    AX,DX               ; AX <- low
        XCHG    DX,CX               ; DX <- high
        ;ASSUME DS:NOTHING
        ;ADD    AX,[DI+sf_fcb+fcb_FILSIZ]
        ;ADC    DX,[DI+sf_fcb+fcb_FILSIZ+2]
	ADD	AX,[DI+13H]
	ADC	DX,[DI+15H]
        JMP     SHORT lseek_ret

lseek_beginning:
        XCHG    AX,DX               ; AX <- low
        XCHG    DX,CX               ; DX <- high

lseek_ret:
        ;MOV	WORD PTR [DI+sf_fcb+fcb_RR],AX
        ;MOV	WORD PTR [DI+sf_fcb+fcb_RR+2],DX
        MOV	[DI+24H],AX
        MOV	[DI+26H],DX
        ;invoke	get_user_stack
        CALL	get_user_stack
	;MOV	[SI.user_DX],DX
        ;MOV	[SI.user_AX],AX
	MOV	[SI+6],DX
        ;MOV	[SI+user_env.user_AX],AX
        MOV	[SI],AX ; 31/03/2018
	;transfer SYS_RET_OK
	JMP	SYS_RET_OK

lseek_current:
; ES:DI is pointer to sf... need to invoke  set random record for place
        XCHG    AX,DX               ; AX <- low
        XCHG    DX,CX               ; DX <- high
        ;ADD	AX,WORD PTR [DI+sf_fcb+fcb_RR]
        ;ADC	DX,WORD PTR [DI+sf_fcb+fcb_RR+2]
        ADD	AX,[DI+24H]
        ADC	DX,[DI+26H]
        JMP     SHORT lseek_ret

lseek_bad:
        ;error	error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

;$lseek  ENDP

;BREAK <$IOCTL - return/set device dependent stuff>

;   Assembler usage:
;           MOV     BX, Handle
;           MOV     DX, Data
;
;       (or LDS     DX,BUF
;           MOV     CX,COUNT)
;
;           MOV     AH, Ioctl
;           MOV     AL, Request
;           INT     21h
;
;   Error returns:
;           AX = error_invalid_handle
;              = error_invalid_function
;              = error_invalid_data

        ;procedure   $IOCTL,NEAR
        ;ASSUME  DS:NOTHING,ES:NOTHING

_$IOCTL:        
	MOV     SI,DS                   ;Stash DS for calls 2,3,4 and 5
        ;context DS
        PUSH	SS
	POP	DS
	CMP     AL,3
        JA      SHORT ioctl_check_block	;Block device
        PUSH    DX
        ;invoke get_sf_from_jfn
        CALL	get_sf_from_jfn
	POP     DX                      ;Restore DATA
        JNC     SHORT ioctl_check_permissions ; have valid handle
        ;error   error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

ioctl_check_permissions:
        CMP     AL,2
        JAE     SHORT ioctl_control_string
        CMP     AL,0
        MOV     AL,[DI+1BH]
        JZ      SHORT ioctl_read	; read the byte
        OR      DH,DH
        JZ      SHORT ioctl_check_device ; can I set with this data?
        ;error	error_invalid_data      ; no DH <> 0
	MOV	AL,error_invalid_data
	JMP	SYS_RET_ERR

ioctl_check_device:
        TEST    AL,devid_ISDEV          ; can I set this handle?
        JZ      SHORT ioctl_bad_fun	; no, it is a file.
        MOV     [ES:DI+1BH],DL
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

ioctl_read:
        XOR     AH,AH
        TEST    AL,devid_ISDEV          ; Should I set high byte
        JZ      SHORT ioctl_no_high	; no
        LES     DI,[ES:DI+1CH] ;Get device pointer
        MOV     AH,[DI+5]   ;Get high byte

ioctl_no_high:
        CALL	get_user_stack
        MOV     DX,AX
        MOV     [SI+6],DX
        ;transfer SYS_RET_OK
	JMP	SYS_RET_OK

ioctl_control_string:
        TEST    BYTE [ES:DI+1BH],devid_ISDEV 
					; can I?
        JZ      SHORT ioctl_bad_fun	; no, it is a file.
        LES     DI,[ES:DI+1CH]
					;Get device pointer
        XOR     BL,BL           ; Unit number of char dev = 0
        JMP     SHORT ioctl_do_string

ioctl_check_block:
        DEC     AL
        DEC     AL                      ;4=2,5=3,6=4,7=5
        CMP     AL,3
        JBE     SHORT ioctl_get_dev

        MOV     AH,1
        SUB     AL,4                    ;6=0,7=1
        JZ      SHORT ioctl_get_status
        MOV     AH,3
        DEC     AL
        JNZ     SHORT ioctl_bad_fun

ioctl_get_status:
        PUSH    AX
        CALL	GET_IO_FCB
        POP     AX
        JC      SHORT ioctl_acc_err
        ;invoke IOFUNC
        CALL	IOFUNC
	MOV     AH,AL
        MOV     AL,0FFH
        JNZ     SHORT ioctl_status_ret
        INC     AL
ioctl_status_ret:
        ;transfer SYS_RET_OK
        JMP	SYS_RET_OK

ioctl_bad_fun:
        ;error	error_invalid_function
	MOV	AL,error_invalid_function
	JMP	SYS_RET_ERR

ioctl_acc_err:
        ;error	error_access_denied
	MOV	AL,error_access_denied
	JMP	SYS_RET_ERR

ioctl_get_dev:
        PUSH    CX
        PUSH    DX
        PUSH    AX
        PUSH    SI              ;DS in disguise
        MOV     AL,BL           ;Drive
        CALL	GETTHISDRV
        JC      SHORT ioctl_bad_drv
        CALL	FATREAD         ;"get" the drive
        MOV     BL,[ES:BP+1] ; Unit number
        LES     DI,[ES:BP+12H]
        CLC                     ;Make sure error jump not taken
ioctl_bad_drv:
        POP     SI
        POP     AX
        POP     DX
        POP     CX
        JC      SHORT ioctl_acc_err
ioctl_do_string:
        TEST    WORD [ES:DI+4],DEVIOCTL ;See if device accepts control
        JZ      SHORT ioctl_bad_fun		;NO
        DEC     AL
        DEC     AL
        JZ      SHORT ioctl_control_read
        MOV     BYTE [IOCALL_REQFUNC],DEVWRIOCTL
        JMP     SHORT ioctl_control_call
ioctl_control_read:
        MOV     BYTE [IOCALL_REQFUNC],DEVRDIOCTL
ioctl_control_call:
        MOV     AL,DRDWRHL
        MOV     AH,BL			;Unit number
        MOV     [IOCALL_REQLEN],AX
        XOR     AX,AX
        MOV     [IOCALL_REQSTAT],AX
        MOV     [IOMED],AL
        MOV     [IOSCNT],CX
        MOV     [IOXAD],DX
        MOV     [IOXAD+2],SI
        PUSH    ES
        POP     DS
        MOV     SI,DI                   ;DS:SI -> driver
        PUSH    SS
        POP     ES
        MOV     BX,IOCALL		;ES:BX -> Call header
        ;invoke	DEVIOCALL2
        CALL	DEVIOCALL2
        ;MOV     AX,[IOSCNT]		;Get actual bytes transferred
	MOV     AX,[SS:IOSCNT] ; 12/03/2018
        ;transfer SYS_RET_OK
        JMP	SYS_RET_OK

;$IOCTL  ENDP

;BREAK <File_Times - modify write times on a handle>

;   Assembler usage:
;           MOV AH, FileTimes
;           MOV AL, func
;           MOV BX, handle
;       ; if AL = 1 then then next two are mandatory
;           MOV CX, time
;           MOV DX, date
;           INT 21h
;       ; if AL = 0 then CX/DX has the last write time/date
;       ; for the handle.
;
;   Error returns:
;           AX = error_invalid_function
;              = error_invalid_handle

;procedure   $File_times,near

_$FILE_TIMES:        

	CMP     AL,2
        JB      SHORT filetimes_ok
        ;error	error_invalid_function
	MOV	AL,error_invalid_function
	JMP	SYS_RET_ERR

filetimes_ok:
        PUSH    SS
        POP     DS
        CALL    get_sf_from_jfn
        JNC     short filetimes_disp
        ;error	error_invalid_handle
	MOV	AL,error_invalid_handle
	JMP	SYS_RET_ERR

filetimes_disp:
        OR      AL,AL
        JNZ     SHORT filetimes_set
        MOV     CX,[ES:DI+19H]
        MOV     DX,[ES:DI+17H]
        CALL	get_user_stack
        MOV     [SI+4],CX
        MOV     [SI+6],DX
        ;transfer SYS_RET_OK
        JMP	SYS_RET_OK

filetimes_set:
        MOV     [ES:DI+19H],CX
        MOV     [ES:DI+17H],DX
        AND     BYTE [ES:DI+1BH],~devid_file_clean
        ;transfer SYS_RET_OK
        JMP	SYS_RET_OK

;$file_times ENDP

;do_ext

;CODE	ENDS
;    END

;============================================================================
; MSINIT.ASM
;============================================================================

; the next segment defines a new class that MUST appear last in the link map.
; This defines several important locations for the initialization process that
; must be the first available locations of free memory.

;LAST    SEGMENT BYTE PUBLIC 'LAST'
        ;PUBLIC  SYSBUF
        ;PUBLIC  MEMSTRT

;SYSBUF  LABEL   WORD
SYSBUF:
;ASSUME  CS:DOSGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

	; Retro DOS v2.0 - 03/03/2018
DOSINIT:
	; Far call from SYSINIT
	; DX = Memory size in paragraphs
	; DS:SI = [DEVICE_LIST] (SYSINIT.S) 
	;	   (Retro DOS v2.0, 16/03/2018)
        CLI
        CLD
	; 12/03/2018
        ;MOV     [ENDMEM],DX
        ;MOV     [INITSP],SP
        ;MOV     [INITSS],SS
        MOV     [CS:ENDMEM],DX
        MOV     [CS:INITSP],SP
        MOV     [CS:INITSS],SS
        MOV     AX,CS
        MOV     SP,INITSTACK
        MOV     SS,AX
        ;MOV     [DEVHEAD+2],DS
        ;MOV     [DEVHEAD],SI	; DS:SI Points to CONSOLE Device
	MOV     [SS:DEVHEAD+2],DS
        MOV     [SS:DEVHEAD],SI	; DS:SI Points to CONSOLE Device

        CALL    CHARINIT

        PUSH    SI
        ;ADD	SI,SDEVNAME	; Point to name
        ADD	SI,SYSDEV.NAME
	PUSH    CS
        POP     ES
        MOV     DI,SFTABL+SFT.SFT_TABLE	; Point to sft 0
        MOV     AL,3
        STOSB           ; Refcount
        DEC     AL
        STOSB           ; Access rd/wr
        XOR     AL,AL
        STOSB           ; Drive byte
        STOSB           ; attribute
        MOV     CX,4
        REP     MOVSW   ; Name
        MOV     CL,3
        MOV     AL," "
        REP     STOSB   ; Extension
        ADD     DI,12   ; Skip
	; 14/04/2018
        MOV     AL,0C0h|ISCIN|ISCOUT ; 0C0H OR ISCIN OR ISCOUT
        STOSB
        POP     SI
        MOV     AX,SI
        STOSW                   ; Device pointer in FIRCLUS
        MOV     AX,DS
        STOSW
        ;OR     BYTE PTR [SI.SDEVATT],ISCIN OR ISCOUT
        OR	BYTE [SI+4], ISCIN|ISCOUT
	; 12/03/2018
	;MOV     [BCON],SI
        ;MOV     [BCON+2],DS
	MOV     [SS:BCON],SI
        MOV     [SS:BCON+2],DS
CHAR_INIT_LOOP:
        LDS     SI,[SI]				; AUX device
        CALL    CHARINIT
        TEST    BYTE [SI+4],ISCLOCK
        JZ      SHORT CHAR_INIT_LOOP
	; 12/03/2018
        ;MOV     [BCLOCK],SI
        ;MOV     [BCLOCK+2],DS
        MOV     [SS:BCLOCK],SI
        MOV     [SS:BCLOCK+2],DS
        MOV     BP,MEMSTRT			; ES:BP points to DPB
PERDRV:
        LDS     SI,[SI]				; Next device
        CMP     SI,-1
	JZ      SHORT CONTINIT

        CALL    CHARINIT

	; Retro DOS v2.0 - 16/03/2018 (NOTE for 'CHARINIT' return):
	; [CALLUNIT] = Number of drives for (Disk) Block Dev Driver ([DRVMAX])
	;           (..When the command is 'DSK$INIT', as in 'CHARINIT')
	; [CALLBPB] = [DEVCALL.COUNT] = Address of the BPB (DEVCALL offset 18) 
	; (REF: MSDOS 3.3 MSBIO2.ASM, MSDATA.INC, MSDISK.ASM, MSBIO1.ASM)
	; (.. !DSK$IN' in MSBIO1.ASM)
	; DEVCALL.MEDIA = CALLUNIT (DEVCALL offset 13)

        TEST    WORD [SI+4],DEVTYP
        JNZ     SHORT PERDRV			; Skip any other character devs

        ;MOV     CL,[CALLUNIT]
        MOV	CL, [SS:CALLUNIT] ; 12/03/2018
	XOR     CH,CH
        MOV     [SI+0AH],CL		; Number of units in name field
        ;MOV     DL,[NUMIO]
        MOV     DL,[SS:NUMIO] ; 15/03/2018
        XOR     DH,DH
        ;ADD     [NUMIO],CL
        ADD	[SS:NUMIO],CL 	; 12/03/2018
	PUSH    DS
        PUSH    SI
        ;LDS     BX,[CALLBPB]
	LDS	BX, [SS:CALLBPB] ; 12/03/2018
PERUNIT:
        MOV     SI,[BX]                 ; DS:SI Points to BPB
        INC     BX
        INC     BX                      ; On to next BPB
        MOV     [ES:BP],DL
        MOV     [ES:BP+1],DH
        PUSH    BX
        PUSH    CX
        PUSH    DX

        ;invoke	$SETDPB
        CALL	_$SETDPB

	MOV     AX,[ES:BP+2]
        ; 12/03/2018
	;CMP     AX,[MAXSEC]
	CMP	AX,[SS:MAXSEC]
	JBE     SHORT NOTMAX
        ;MOV     [MAXSEC],AX
	MOV	[SS:MAXSEC],AX
NOTMAX:
        POP     DX
        POP     CX
        POP     BX
        MOV     AX,DS                   ; Save DS
        POP     SI
        POP     DS
        MOV     [ES:BP+12H],SI
        MOV     [ES:BP+12H+2],DS
        PUSH    DS
        PUSH    SI
        INC     DH
        INC     DL
        MOV     DS,AX
        ADD     BP,DPBSIZ
	LOOP    PERUNIT
        POP     SI
        POP     DS
	JMP	SHORT PERDRV

CONTINIT:
        PUSH    CS
        POP     DS
; Calculate true address of buffers, FATs, free space
        MOV     DI,BP           ; First byte after current DPBs
        MOV     BP,[MAXSEC]
        MOV     AX,SYSBUF
        MOV     [BUFFSTRT],AX
        ADD     AX,BP           ; One I/O buffer
        ADD     AX,BUFINSIZ
        MOV     [DPBHEAD],AX	; True start of DPBs
        MOV     DX,AX
        SUB     DX,SYSBUF
        MOV     BP,DX
        ADD     BP,DI           ; Allocate buffer space
        SUB     BP,ADJFAC       ; True address of free memory
        PUSH    BP ; ###		
        MOV     DI,MEMSTRT	; Current start of DPBs
        ADD     DI,DPB.NEXT_DPB	; Point at dpb.next_dpb field
        MOV     CL,[NUMIO]
        XOR     CH,CH
TRUEDPBAD:
        ADD     AX,DPBSIZ       ; Compute address of next DPB
        STOSW                   ; Set the link to next DPB
        ADD     DI,DPBSIZ-2     ; Point at next address
        LOOP    TRUEDPBAD
        SUB     DI,DPBSIZ       ; Point at last dpb.next_dpb field
        MOV     AX,-1
        STOSW                   ; End of list
        ADD     BP,15           ; True start of free space (round up to segment)
        MOV     CL,4
        SHR     BP,CL           ; Number of segments for DOS resources
        MOV     DX,CS
        ADD     DX,BP           ; First free segment
	;MOV	BX,0FH
	;MOV	CX,[ENDMEM]

        ;IF	HIGHMEM
        ;SUB	CX,BP
        ;MOV	BP,CX		; Segment of DOS
        ;MOV	DX,CS		; Program segment
        ;ENDIF

        ;IF	NOT HIGHMEM
        MOV     BP,CS
        ;ENDIF

; BP has segment of DOS (whether to load high or run in place)
; DX has program segment (whether after DOS or overlaying DOS)
; CX has size of memory in paragraphs (reduced by DOS size if HIGHMEM)
        ;MOV	[ENDMEM],CX
        MOV     ES,BP

        ;IF     HIGHMEM
        ;XOR    SI,SI
        ;MOV    DI,SI
        ;MOV    CX,SYSBUF	;# bytes to move
        ;SHR    CX,1		;# words to move (carry set if odd)
        ;REP	MOVSW		; Move DOS to high memory
        ;JNC	SHORT NOTODD
        ;MOVSB
;NOTODD:
        ;ENDIF

        MOV     [ES:DSKCHRET+3],ES
        XOR     AX,AX
        MOV     DS,AX
        MOV     ES,AX
        MOV     DI,INTBASE+2
        MOV     AX,BP
        MOV     BYTE [ENTRYPOINT],mi_Long_JMP
        MOV     WORD [ENTRYPOINT+1],CALL_ENTRY
        MOV     WORD [ENTRYPOINT+3],AX
        ;EXTRN	DIVOV:near
        MOV     WORD [0],DIVOV	; Set default divide 
				; trap address
        MOV     [2],AX
        MOV     CX,17
        REP	STOSW		; Set 9 segments (skip 2 between each)

        ;IF      ALTVECT
        ;MOV     DI,ALTBASE+2
        ;MOV     CX,15
        ;REP     STOSW		; Set 8 segments (skip 2 between each)
        ;ENDIF

        MOV     WORD [addr_int_abort],QUIT
        MOV     WORD [addr_int_command],COMMAND
        MOV     WORD [addr_int_terminate],100H
        MOV     WORD [addr_int_terminate+2],DX
        MOV     WORD [addr_int_ctrl_c],_IRET   
							; Ctrl-C exit
        MOV     WORD [addr_int_fatal_abort],_IRET
							; Fatal error exit
        MOV     WORD [addr_int_disk_read],ABSDRD
							; INT 25
        MOV     WORD [addr_int_disk_write],ABSDWRT
							; INT 26
        ;EXTRN	Stay_resident:NEAR
        MOV     WORD [addr_int_keep_process],Stay_resident
        MOV     WORD [addr_int_spooler],_IRET  ; Spooler

        ;IF	NOT ALTVECT
        MOV     CX,12
        XOR     AX,AX
        MOV     DI,2AH*4
        REP     STOSW           ;Zero interrupt locs for ints 2AH-2FH
        ;ENDIF

        PUSH    CS
        POP     DS
        PUSH    CS
        POP     ES
        MOV     AX,INITBLOCK
        ADD	AX,0Fh		; round to a paragraph
        MOV     CL,4
        SHR     AX,CL
        MOV     DI,DS
        ADD     DI,AX
        INC     DI
        MOV     [CurrentPDB],DI
        PUSH    BP ; ##
        PUSH    DX ; #		; Save COMMAND address
        MOV     AX,[ENDMEM]
        MOV     DX,DI

        ;invoke	SETMEM          ; Basic Header
	CALL	SETMEM
        PUSH    CS
        POP     DS
        MOV     DI,PDB.JFN_TABLE
        XOR     AX,AX
        STOSW
        STOSB                   ; 0,1 and 2 are CON device
        MOV     AL,0FFH
        MOV     CX,FILPERPROC - 3
        REP     STOSB           ; Rest are unused
        PUSH    CS
        POP     ES
        MOV     [SFT_ADDR+2],DS	; Must be set to print messages

; After this points the char device functions for CON will work for
; printing messages

        ;IF	NOT IBM
        ;IF	NOT ALTVECT
        MOV     SI,HEADER
        ;invoke	OUTMES
        CALL	OUTMES
	;PUSH	CS		; Outmes stomps on segments
        ;POP	DS
        ;PUSH	CS
        ;POP	ES
        ;ENDIF
        ;ENDIF

; Move the FATs into position
        POP     DX ; #			; Restore COMMAND address
        POP     BP ; ##
        POP     CX ; ###		; True address of free memory
        MOV     SI,MEMSTRT		; Place to move DPBs from
        MOV     DI,[DPBHEAD]		; Place to move DPBs to
        SUB     CX,DI                   ; Total length of DPBs
        CMP     DI,SI
        JBE     SHORT MOVJMP		; Are we moving to higher or 
					; lower memory?
        DEC     CX                      ; Move backwards to higher memory
        ADD     DI,CX
        ADD     SI,CX
        INC     CX
        STD
MOVJMP:
        MOV     ES,BP
        JMP     MOVDPB

CHARINIT:
;ASSUME  DS:NOTHING,ES:NOTHING
; DS:SI Points to device header
	; 15/03/2018
        ;MOV     BYTE [DEVCALL_REQLEN],DINITHL
        ;MOV     BYTE [DEVCALL_REQUNIT],0
        ;MOV     BYTE [DEVCALL_REQFUNC],DEVINIT
        ;MOV     WORD [DEVCALL_REQSTAT],0
        MOV     BYTE [SS:DEVCALL_REQLEN],DINITHL
        MOV     BYTE [SS:DEVCALL_REQUNIT],0
        MOV     BYTE [SS:DEVCALL_REQFUNC],DEVINIT
        MOV     WORD [SS:DEVCALL_REQSTAT],0
        PUSH    ES
        PUSH    BX
        PUSH    AX
        MOV     BX,DEVCALL
        PUSH    CS
        POP     ES
        ;invoke	DEVIOCALL2
        CALL	DEVIOCALL2	
	POP     AX
        POP     BX
        POP     ES
        RETN

align 2

        ;DB	80H DUP(?)
	TIMES	64 Dw 0

INITSTACK:	; INITSTACK LABEL BYTE
        DW	0 ; DW ?

;MEMSTRT LABEL	WORD
MEMSTRT	EQU	$
ADJFAC  EQU     MEMSTRT-SYSBUF

        ;do_ext
;LAST	ENDS