; ****************************************************************************
; IOSYS6.S (MSDOS 6.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
; ----------------------------------------------------------------------------
; Last Update: 25/06/2023 - Retro DOS v4.2 (Prev: 28/12/2022, Retro DOS v4.1)
; ----------------------------------------------------------------------------
; Beginning: 26/12/2018 (Retro DOS 4.0)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15 (2.11)
; ----------------------------------------------------------------------------
;	   ((nasm iosys6.s -l iosys6.lst -o IOSYS6.BIN -Z error.txt)) 	
; ----------------------------------------------------------------------------

; 30/12/2022 - Retro DOS v4.2 Kernel -dosbios- ('iosys6.s')
; Modified from 'iosys5.s' (28/12/2022, Retro DOS v4.1 Kernel's IO.SYS) file
; as below:
;    1) SYSINIT code has been changed from MSDOS 5.0 to MSDOS 6.21 IO.SYS
;      (except DOUBLESPACE feature! Retro DOS does not use the DOUBLESPACE.)	
;    2) 'iosys6.s' is same with 'iosys5.s' except sysinit code.
;	(Also, MSDOS 5.0 & MSDOS 6.21 IO.SYS are almost same except
;	SYSINIT and 'Starting MS-DOS' msg part of MSDOS 6.21 IO.SYS.) 

; ----------------------------------------------------------------------------

; 09/12/2022 - Multisection binary file format (BIOSDATA & BIOSCODE sections)
; 01/10/2022 - Erdogan Tan (Istanbul)

;Note: This code is a part of Retro DOS 4.0 kernel source code
;     (as included binary, 'IOSYS5.BIN') 
;     Equivalent of MSDOS 5.0 IO.SYS, BIOSCODE and BIOSDATA and SYSINIT
;						        (except MSLOAD code)  
      
;---- Retro DOS v2 (v3) boot sector loads RETRODOS.SYS (MSDOS.SYS)
;     at 1000h:0000h and loader (initialization) part of RETRODOS kernel
;     moves IO.SYS (DOSBIOSCODE & DOSBIOSDATA, 'IOSYS5.BIN') to 70h:0000h.
;     Then SYSINIT code to the next segment (46Dh for original MSDOS 5.0)..
;     SYSINIT code relocates itself and DOSBIOSCODE and MSDOS.SYS
;     (MSDOS5.BIN) according to request/setting in 'config.sys' file.

; ----------------------------------------------------------------------------

;bpbx		struc ;	(sizeof=0x19)	
;
;bytespersec	dw ?			; base 10
;secperclust	db ?			; base 10
;rsvdsecs	dw ?			; base 10
;numfats	db ?			; base 10
;rootdirents	dw ?			; base 10
;totalsize16	dw ?			; base 10
;mediaid	db ?
;fatsecs	dw ?			; base 10
;secpertrack	dw ?			; base 10
;heads		dw ?			; base 10
;hiddensecs_lw	dw ?			; base 10
;hiddensecs_hw	dw ?			; base 10
;totalsecs_lw	dw ?			; base 10
;totalsecs_hw	dw ?			; base 10
;
;bpbx		ends

;-----------------------------------------------------------------------------
;
; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

;-----------------------------------------------------------------------------

;		.386
;		.model flat

; ============================================================================

; 24/12/2022
; 22/12/2022
; 20/12/2022
; 18/12/2022
; 10/12/2022
; 09/12/2022
; 19/10/2022, 21/10/2022
; 17/10/2022, 18/10/2022
; 15/10/2022, 16/10/2022
; 03/10/2022
; 02/10/2022
; 01/10/2022 - Erdogan Tan

; [[ Most of comments here are from the original MSDOS 6.0 source code ]]

;-----------------------------------------------------------------------------
; Start of (MSDOS 5.0) IO.SYS (IBMBIO.COM)
;-----------------------------------------------------------------------------

		[ORG 0]			; segment 0x0070h

; ----------------------------------------------------------------------------
; %include msload5.s	; 09/12/2022
; ----------------------------------------------------------------------------

;=============================================================================
; (IO.SYS) LOADER SECTION 
;=============================================================================
; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
;non-contiguous io.sys loader (msload) ((MSDOS 6.0 source: MSLOAD.ASM, 1991))

section .MSLOAD ; vstart=0 

; ****************************************************************************
; MSLOADS5.S (MSDOS 5.0 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 01/10/2022
; ----------------------------------------------------------------------------
; Last Update: 25/12/2022 (Modified IO.SYS loader)  ((Previous: 22/12/2022))
; ----------------------------------------------------------------------------
; Beginning: 21/10/2022 (Retro DOS 4.0)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15 
; ----------------------------------------------------------------------------
;	   ((nasm msload5.s -l msload5.lst -o MSLOAD5.BIN -Z error.txt)) 
; ----------------------------------------------------------------------------
; Converted to NASM source code from disassembled MSDOS 5.0 (IO.SYS) MSLOAD
; code by Erdogan Tan (disassembly: 18/09/2022, Converted source: 21/10/2022) 
; ----------------------------------------------------------------------------

; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h

;		.386
;		.model flat

; ===========================================================================

; 09/12/2022
; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output

; ===========================================================================
;	NOTE: The boot loader should be verifying that the first
;	  block of io.sys is, in fact, at cluster 2. This would be saving
;	  a whole lot of time during system debugging.
;
;============================================================================
;
;     for dos 4.00, msload program has been changed to allow:
;	  1. 32 bit calculation,
;	  2. reading a fat sector when needed, instead of reading the whole
;	     fat sectors at once. this will make the boot time faster,
;	     and eliminate the memory size limitation problem,
;	  3. solving the limitation of the file size (29 kb) of io.sys0,
;	  4. adding the boot error message. show the same boot error message
;	     and do the same behavior when the read operation of io.sys
;	     fails as the msboot program, since msload program is the
;	     extention of msboot program.
;
; ===========================================================================

;
;----------------------------------------------------------------------------
;
; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
;		SYSINIT & transient portion of COMMAND.COM
;
;----------------------------------------------------------------------------
		
		[ORG 0]			; segment 0x0070h

START$:
		jmp	SaveInputValuess

%if 0
; 20/12/2022
; 09/12/2022
; ---------------------------------------------------------------------------
SysVersion:	dw 5			; expected_version	
;MyStacks:	db 256 dup(0)		; local stack
; 22/12/2022
; 20/12/2022
;MyStacks:	dw 102 dup(0)		; local stack
NumHeads:	dw 0			; ...
ClusterSize:	db 2 dup(0)		; ...
StartSecL:	dw 0			; ...
StartSecH:	dw 0			; ...
TempH:		dw 0			; for 32 bit calculation
TempCluster:	db 2 dup(0)		; temporary place for cluster number
LastFatSector:	db 2 dup(0FFh)		; fat sec # start from 1st FAT entry
SectorCount:	dw 0			; ...
SecPerFat:	dw 0			; ...
HiddenSectorsL:	dw 0			; ...
HiddenSectorsH:	dw 0			; ...
BytesPerSec:	dw 0			; ...
ReservSectors:	db 2 dup(0)		; ...
CurrentCluster:	db 2 dup(0)		; ...
NextBioLocation: db 2 dup(0)		; ...
FirstSectorL:	dw 0			; ...
FirstSectorH:	dw 0			; ...
TotalSectorsL:	dw 0			; max. number of sectors
TotalSectorsH:	dw 0			; ...
SecPerTrack:	db 2 dup(0)		; ...
BootDrive:	db 0			; ...
Fatsize:	db 0			; ...
MediaByte:	db 0			; ...
EndOfFile:	db 0			; ...
OrgDasdPtr:	db 4 dup(0)		; ...
FatSegment:	db 2 dup(0)		; ...
SecPerCluster:	db 0			; ...
; ---------------------------------------------------------------------------
%endif

; 24/12/2022
; 23/12/2022
; 20/12/2022
; 09/12/2022
; ---------------------------------------------------------------------------
SysVersion:	dw 5			; expected_version	
ClusterSize:	dw 0
StartSecL:	dw 0
StartSecH:	dw 0
TempH:		dw 0			; for 32 bit calculation
;TempCluster:	dw 0
;HiddenSectorsL: dw 0
;HiddenSectorsH: dw 0
;ReservSectors:	dw 0
LastFatSector:	dw 0FFFFh		; fat sec # start from 1st FAT entry
SectorCount:	dw 0
CurrentCluster:	dw 0	; *!*
BytesPerSec:	dw 0
SecPerCluster:	dw 0
;RootDirEntries: dw 0
SecPerFat:	dw 0
SecPerTrack:	dw 0
NumHeads:	dw 0
TotalSectorsL:	dw 0			; max. number of sectors
TotalSectorsH:	dw 0
FirstSectorL:	dw 0
FirstSectorH:	dw 0
BootDrive:	db 0
Fatsize:	db 0
MediaByte:	db 0
EndOfFile:	db 0
OrgDasdPtr:	dd 0
FatStartSecL:	dw 0
FatStartSecH:	dw 0
FatSegment:	dw 0

; SaveInputValuess
; ---------------------------------------------------------------------------
; INPUT:     none
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector (low) on disk (0-based)
;   ds:si = original rom bios diskette parameter table.
;
; if an extended boot record, then ax will be the first data sector
; high word. save ax and set FirstSectorH according to ax if it is an
; extended boot record.
;
;   ax = first data sector (high) on disk ;
; OUTPUT:
;
;   bx = first data sector on disk
;
;   MediaByte = input ch
;   BootDrive = input dl
;   FirstSectorL = input bx
;   FirstSectorH = input AX, if an extended boot record.;j.k.
;   TotalSectorsL = maximum sector number in this media ;j.k.
;   TotalSectorsH = high word of the above
;   HiddenSectorsL = hidden secotrs
;   HiddenSectorsH
;   ReservSectors = reserved sectors
;   SecPerTrack = sectors/track
;   NumHeads = heads/cylinder
;
;   ds = 0
;   AX,DX,SI destroyed
;
; calls:     none
; ---------------------------------------------------------------------------
;FUNCTION:
; save input information and bpb informations from the boot record.
; ---------------------------------------------------------------------------

Sec9 equ 522h
; 20/12/2022	
DskAddr	equ 1Eh*4 ; 7Eh
; 22/12/2022
;StackPtr equ MyStacks+(NumHeads-MyStacks)

; ---------------------------------------------------------------------------

		; 24/12/2022
		; (registers from MSDOS 5.0 boot sector)
		; ss = 0
		; sp = 7C00h
		; ds = 0
		; es = 0
		; ax:bx = absolute disk address for cluster 2 (data start)
		; dl = [BootDrv] = [7C24h]
		; ch = [MediaByte] = [7C15h]
		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
		; 0:500h = root dir buffer (1st sector of the root dir)

SaveInputValuess:
		; 24/12/2022
		push	ds
		push	cs
		pop	ds 
		;mov	[cs:FirstSectorL], bx ; first data sector (low word)
		;mov	[cs:MediaByte], ch
		;mov	[cs:BootDrive], dl
		;mov	[cs:OrgDasdPtr], si
		;push	ds
		;pop	word [cs:OrgDasdPtr+2]
		mov	[FirstSectorL], bx
		mov	[StartSecL], bx ; **!**
		mov	[MediaByte], ch
		mov	[BootDrive], dl
		mov	[OrgDasdPtr], si
		pop	word [OrgDasdPtr+2]

		xor	cx, cx		; segment 0 (obviously)
		mov	ds, cx		; ZERO
		; 23/12/2022
		; es = 0 (just before jumping to start of IO.SYS) 
		;push	es ; !
		;mov	es, cx
		; es = 0
		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
		;mov	ds, [DskAddr+2]	; DS:SI -> current table
		; 20/12/2022
		mov	si, Sec9
		mov	di, si
		xchg	si, [DskAddr]
		xchg	cx, [DskAddr+2]
		mov	ds, cx
		;mov	di, Sec9	; 522h  ; ES:DI -> new table
		mov	cx, 11			; taken from ibmboot.asm
		cld
		rep movsb		; copy table
		;push	es
		;pop	ds		; ds = 0
		; 20/12/2022
		mov	ds, cx ; 0
		;mov	word [DskAddr], Sec9 ; 522h
		;mov	[DskAddr+2], ds	; point disk parm vector to new table
		; 23/12/2022
		;pop	es ; !
		; es = 0
		; ds = 0
		; ss = 0
; 24/12/2022
%if 0
		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
		mov	[cs:BytesPerSec], cx
		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
		mov	[cs:SecPerCluster], cl
		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
		mov	[cs:SecPerTrack], cx
		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
		mov	[cs:NumHeads], cx
		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
		mov	[cs:SecPerFat], cx
		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
		mov	[cs:ReservSectors], cx
		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
		mov	[cs:HiddenSectorsL], cx
		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
		mov	[cs:TotalSectorsL], cx

		; First of all, check if it the boot record is an extended one.
		; This is just a safe guard in case some user just "copy" the
		; 4.00 iosys.com to a media with a conventional boot record.

		; 22/12/2022
		cmp	byte [7C26h], 29h ; ext_boot_signature
		jne	short relocate
		mov	[cs:FirstSectorH], ax ; first data sector (high word)
		mov	ax, [7C1Eh]
		mov	[cs:HiddenSectorsH], ax
		; 10/12/2022
		or	cx, cx
		;cmp	cx, 0		; cx set already before (=totalsectors)
		; 22/12/2022
		jnz	short relocate
		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
		mov	[cs:TotalSectorsL], ax
		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
		mov	[cs:TotalSectorsH], ax
%endif
		; 24/12/2022
		push	ax  ; * ; first data sector (high word)
		
		push	cs
		pop	es

		;mov	ax, [BioSStart]
		mov	ax, [51Ah]	; IO.SYS First Cluster
		dec	ax		; Root dir buffer at 500h (segment=0)
					; IO.SYS first cluster ptr at 51Ah
		dec	ax		; AX = word [51Ah] - 2
		mov	di, CurrentCluster		
		stosw			;  Initialize to this cluster

		mov	si, 07C0Bh	; boot sector's bpb, BytesPerSector
		;mov	di, BytesPerSec
		movsw	; BytesPerSec
		movsb	; SecPerCluster
		inc	di ; skip high byte of SecPerCluster word (it is 0)
		lodsw	; ReservSectors
		mov	bx, ax ; save ReservSectors in bx
		lodsb	; skip NumFats
		;movsw	; RootDirEntries ; !
		lodsw	; skip NUmDirEntries ; !
		lodsw	; TotalSectorsL
		mov	cx, ax ; save TotalSectorsL in cx
		lodsb	; skip MediaByte
		movsw	; SecPerFat
		movsw 	; SecPerTrack
		movsw	; NumHeads
		lodsw	; HiddenSectorsL
		push 	ax ; **	; HiddenSectorsL
		lodsw	; HiddenSectorsH
		mov	dx, ax	; save HiddenSectorsH in dx
		lodsw	
		push	ax ; *** ; BigTotalSecs lw
		lodsw
		push	ax ; **** ; BigTotalSecs hw
		lodsw	; skip BootDrv and CurrentHead

		mov	ax, cx ; TotalSectorsL

		mov	bp, si		
 
		pop	cx ; **** ; BigTotalSecs hw

		pop	si ; *** ; BigTotalSecs lw

		push	cs
		pop	ds
		
		; ss = 0
		; bp = 7C26h
		
		cmp	byte [bp], 29h  ; ext_boot_signature
		je	short ext_boot_sec_1

		stosw	; TotalSectorsL

		;pop	ax ; *** ; discard BigTotalSecs lw
		pop	ax ; ** ; HiddenSectorsL
		pop	dx ; * ; discard 1st data sector hw
		xor	dx, dx ; 0
		jmp	short set_fat_start
ext_boot_sec_1:
		; 24/12/2022
		;pop	si ; *** ; BigTotalSecs lw
		or	ax, ax  ; TotalSectorsL (16 bit total sectors)
		jnz	short ext_boot_sec_2 ; (*)

		; (32 bit total sectors)
		mov	ax, si ; BigTotalSecs lw 
		stosw	; TotalSectorsL	
		mov	ax, cx ; BigTotalSecs hw
ext_boot_sec_2:
		stosw	; TotalSectorsH or TotalSectorsL (*)
		pop	ax ; ** ; HiddenSectorsL
		;pop	word [FirstSectorH] ; * ; 1st data sector hw
		pop	cx ; * ; [FirstSectorH] ; 1st data sector hw
		mov	[FirstSectorH], cx
		mov	[StartSecH], cx ; **!**	

		; here, DI points to FatStartSecL
set_fat_start:
		; 24/12/2022
		; dx:ax = HiddenSectors
		; bx = ReservSectors

		add 	ax, bx
		adc	dx, 0

		;mov	[FatStartSecL], ax
		;mov	[FatStartSecH], dx		

		mov	di, FatStartSecL
		stosw
		mov	ax, dx
		stosw		
	
; Relocate
; -------------------------------------------------------------------------
;
; NOTES:
;
;   Relocates the loader code to top-of-memory.
;
; INPUT:     none
;
; OUTPUT:    code and data relocated.
;	     AX,CX,SI,DI destroyed
;
; calls:     none
; -------------------------------------------------------------------------
;
; Determine the number of paragraphs (16 byte blocks) of memory.
; this involves invoking the memory size determination interrupt,
; which returns the number of 1k blocks of memory, and then
; converting this to the number of paragraphs.
; Find out whether RPL code is present at top of memory and modify the
; available amount of memory in AX
; leave the number of paragraphs of memory in ax.
;
; -------------------------------------------------------------------------
; copy code from start to top of memory.
;
; the length to copy is EndOfLoader
;
; jump to relocated code
; -------------------------------------------------------------------------

relocate:
		; 24/12/2022
		;cld

		xor	si, si
		mov	di, si
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; Memory size in paragraphs

;------ Check if an RPL program is present at TOM and do not tromp over it

		; 10/12/2022
		; ds = 0
		; 24/12/2022
		; ds = cs
		xor	bx, bx
		mov	ds, bx		; ZERO
		
		;mov	bx, [DskAddr+44h] ; 2Fh*4 (Int 2Fh)
		;mov	ds, [DskAddr+46h] ; 2Fh*4+2
		; 10/12/2022
		mov	bx, [2Fh*4]	; (Int 2Fh)
		mov	ds, [2Fh*4+2]		

		;cmp	word ptr [bx+3], 'PR'
		; 09/12/2022
		cmp	word [bx+3], 'RP' ; 'RPL'
		jnz	short Skip_RPL
		cmp	byte [bx+5], 'L'
		jnz	short Skip_RPL
		mov	dx, ax		; get TOM into DX
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		mov	ax, dx
Skip_RPL:
		; 24/12/2022
		push	cs
		pop	ds	; 25/12/2022

		mov	cl, 4
		mov	dx, [BytesPerSec] ; 24/12/2022
		;mov	dx, [cs:BytesPerSec]
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	[FatSegment], ax ; 24/12/2022
		;mov	[cs:FatSegment], ax ; This will be used for fat sector
		; 22/12/2022
		;mov	dx, EndOfLoader
		mov	dx, EndOfLoader+256
				; loader size + temporary/local stack space (*)
		shr	dx, cl
		inc	dx
		sub	ax, dx
		mov	es, ax	; ES:DI -> place be relocated.
		; 22/12/2022
		dec	dx
		shl	dx, cl	; convert paragraphs to bytes (*)	
				; (stack pointer will be set to this offset)
		; 24/12/2022
		;push	cs
		;pop	ds		; DS:SI -> source

		mov	cx, EndOfLoader
		rep movsb

		push	es
		mov	ax, SetupStack
		push	ax		; Massage stack for destin of CS:IP
		retf
; ---------------------------------------------------------------------------

; Start of relocated code
;----------------------------------------------------------------------------
;
; Move the stack to just under the boot record and relocation area (0:7c00h)
;

SetupStack:	
		; 22/12/202		; ...
		;mov	ax, cs		; Start	of relocated code
		;mov	ss, ax
		;;mov	sp, NumHeads	; StackPtr offset
		; 20/12/2022
		;mov	sp, StackPtr	; StackPtr offset
		
; 22/12/2022
; (set a temporary stack just above the relocated loader code)
; ((instead of using/reserving 256 bytes of stack space in 'IO.SYS' file))

		; 22/12/2022
		; cs = loader segment (relocated)
		; dx = loader size + stack space (*) -paragraph aligned-

		;cli
		mov	ax, cs
		mov	ds, ax	; 24/12/2022
		cli 
		mov	ss, ax
		mov	sp, dx	; (*)
		sti

; FindClusterSize
; ---------------------------------------------------------------------------
;
; INPUT:     bpb information in loaded boot record at 0:7c00h
;
; OUTPUT:
;
;	ds = 0
;	ax = bytes/cluster
;	bx = sectors/cluster
;	si destroyed
; calls:     none
;----------------------------------------------------------------------------
;
; get bytes/sector from bpb
;
; get sectors/cluster from bpb
;
; bytes/cluster = bytes/sector * sector/cluster
; ---------------------------------------------------------------------------

FindClusterSize:

;for the time being just ASSUME the boot record is valid and the bpb is there.

		; 24/12/2022
		; ds = cs
		;xor	ax, ax
		;mov	ds, ax
		;mov	ax, [7C0Bh]	; get bpb bytes/sector
		; 24/12/2022
		mov	ax, [BytesPerSec]
		;xor	bx, bx
		;mov	bl, [7C0Dh]	; get sectors/cluster
		;mul	bx
		mul	word [SecPerCluster]
		;mov	[cs:ClusterSize], ax
		; 24/12/2022
		mov	[ClusterSize], ax

; CalcFatSize
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
;   to find out what system id byte is.
;
; INPUT:
;
; OUTPUT:
;
;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
;   all other registers destroyed
;
; ---------------------------------------------------------------------------

CalcFatSize:
		; 24/12/2022
		; ds = cs
		mov	byte [Fatsize], 1
		;mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
		;mov	dx, [cs:TotalSectorsH]
		;mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
		mov	dx, [TotalSectorsH]
		mov	ax, [TotalSectorsL] ; DX:AX = total disk sectors
		;;;		
; 24/12/2202
%if 0
		sub	ax, [ReservSectors]
		;sub	ax, [cs:ReservSectors]
		sbb	dx, 0		; DX:AX	= Total	avail sectors
		;mov	bx, [cs:SecPerFat]
		mov	bx, [SecPerFat]
		shl	bx, 1		; (Assume 2 FATs)
		sub	ax, bx
		sbb	dx, 0
		;mov	bx, [7C11h]	; Root directory entry count
		mov	bx, [RootDirEntries]
		mov	cl, 4
		shr	bx, cl		; BX = Total directory sectors
		sub	ax, bx
		sbb	dx, 0		; DX:AX	= Sectors in data area
%endif
		; 24/12/2022
		sub	ax, [FirstSectorL] ; total sectors - start of data
		sbb	dx, [FirstSectorH]
				; DX:AX	= Sectors in data area
		;;;
		;xor	cx, cx
		;mov	cl, [7C0Dh]	; Sectors per cluster
		mov	cx, [SecPerCluster] ; *#*
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx  ; *#*
		; 24/12/2022
		;;mov	[cs:TempH], ax	; AX = Total number of clusters
		;mov	[TempH], ax
		pop	ax
		div	cx  ; *#*
		cmp	ax, 4086	; 4096-10
		jb	short ReadInFirstClusters ; 12 bit FAT
		;mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
		mov	byte [Fatsize], 4 ; FAT_16_BIT

; ReadInFirstClusters
; ---------------------------------------------------------------------------
;
; NOTES: read the start of the clusters that covers at least IbmLoadSize
;	 fully.  for example, if sector/cluster = 2, and IbmLoadSize=3
;	 then we are going to re-read the second cluster to fully cover
;	 msload program in the cluster boundary.
;
; INPUT:
;   IbmLoadSize - make sure this value is the same as the one in
;		  msboot program when you build the new version!!!!!
;
;   SecPerCluster
;   ClusterSize
;   FirstSectorL
;   FirstSectorH
;
; OUTPUT: msload program is fully covered in a cluster boundary.
;	  ax = # of clusters we read in so far.
;
; calls:     ReadSectors
; logic:
;	ax; dx = IbmLoadSize / # of sector in a cluster.
;	if dx = 0 then ok. (msload is in a cluster boundary.)
;      else		   (has to read (ax+1)th cluster to cover msload)
;	read (ax+1)th cluster into the address after the clusters we
;	read in so far.
; ---------------------------------------------------------------------------

; 09/12/2022
; BiosStart equ 51Ah ; AX = IO.SYS starting cluster
; IbmLoadSize equ 3  ; AX = Number sectors in MSLOAD
; BiosOffset equ 700h ; Address where loader was read in
	
ReadInFirstClusters:
		; 24/12/2022
		;;mov	ax, [BioSStart]
		;mov	ax, [51Ah]	; IO.SYS First Cluster
		;dec	ax		; Root dir buffer at 500h (segment=0)
		;			; IO.SYS first cluster ptr at 51Ah
		;dec	ax		; AX = word [51Ah] - 2
		;;mov	[cs:CurrentCluster], ax ;  Initialize to this cluster
		; 24/12/2022
		; ds = cs
		;mov	[CurrentCluster], ax
		; 24/12/2022
		; [CurrentCluster] = word [51Ah] - 2

		;mov	ax, IbmLoadSize
		mov	ax, 3		; Load the 3rd and other IO.SYS	sectors
		div	cl ; *#*
		;div	byte [SecPerCluster]
		;;div	byte [cs:SecPerCluster]
					; AL = total cluster read in
					; AH = remaining sectors in last cluster
		; 10/12/2022
		and	ah, ah
		;cmp	ah, 0
		jz	short SetNextClusterNum	; next cluster

		xor	ah, ah
		push	ax		; AX = total clusters in the loader
					; already read in
; 24/12/2022
%if 0		
		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
		mov	cx, [cs:FirstSectorH]
		mov	[cs:StartSecH], cx
		mul	byte [cs:SecPerCluster]
		add	[cs:StartSecL], ax ; Add number of sectors already loaded
		adc	word [cs:StartSecH], 0 ; to start sector
		;mov	ax, [BiosStart]
		mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
		dec	ax
		dec	ax
		xor	bx, bx
		mov	bl, [cs:SecPerCluster]
		mul	bx		; DX:AX = logical start sector
		add	[cs:StartSecL], ax
		adc	[cs:StartSecH], dx
					; abs start sector for next read of
					; the rest of the last loader cluster
		pop	ax
		push	ax
		mul	word [cs:ClusterSize]
		;mov	di, BiosOffset
		mov	di, 700h	; IO.SYS offset	(segment = 0)
		add	di, ax
		xor	ax, ax
		mov	es, ax		; ES = segment 0
		mov	al, [cs:SecPerCluster]
					; Read in the entire last cluster
		mov	[cs:SectorCount], ax
		call	ReadSectors
		pop	ax		; AX = total clust read	by boot	loader
		inc	ax		; AX = total clust read	in now
SetNextClusterNum:			; ...
		inc	ax		; AX = total clusters read in based 2
		add	[cs:CurrentCluster], ax
		dec	ax		; CurrentCluster = Last	cluster	read
					; AX = number of clusters loaded
%endif
		; 24/12/2022
		; ds =cs
		;mov	cx, [FirstSectorL] ; Put starting sector of disk data
		;mov	[StartSecL], cx    ; area in StartSecH:StartSecL
		;mov	cx, [cs:FirstSectorH]
		;mov	[StartSecH], cx
		; [StartSecL] = [FirstSectorL] ; **!**
		; [StartSecH] = [FirstSectorH] ; **!**
		
		; 24/12/2022
		; cx = [SecPerCluster]  ; *#*

		;mul	byte [SecPerCluster]
		mul	cl ; *#*
		add	[StartSecL], ax ; Add number of sectors already loaded
		adc	word [StartSecH], 0 ; to start sector

		;mov	ax, [51Ah] ; AX = [51Ah] = IO.SYS 1st clust
		;dec	ax
		;dec	ax
		mov	ax, [CurrentCluster]
		; ax = word [51Ah] - 2
		
		;;xor	bx, bx
		;;mov	bl, [SecPerCluster]
		;mov	bx, [SecPerCluster]
		;mul	bx		; DX:AX = logical start sector
		mul	cx  ; [SecPerCluster]  ; *#*

		add	[StartSecL], ax
		adc	[StartSecH], dx
					; abs start sector for next read of
					; the rest of the last loader cluster
		pop	ax
		push	ax
		mul	word [ClusterSize]
		;mov	di, BiosOffset
		mov	di, 700h	; IO.SYS offset	(segment = 0)
		add	di, ax
		xor	ax, ax
		mov	es, ax		; ES = segment 0
		; 24/12/2022
		;mov	al, [SecPerCluster]
		;			; Read in the entire last cluster
		;mov	[SectorCount], ax
		mov	[SectorCount], cx ; [SecPerCluster]  ; *#*
		
		call	ReadSectors
		pop	ax		; AX = total clust read	by boot	loader
		inc	ax		; AX = total clust read	in now
SetNextClusterNum:			; ...
		inc	ax		; AX = total clusters read in based 2
		add	[CurrentCluster], ax
		dec	ax		; CurrentCluster = Last	cluster	read
					; AX = number of clusters loaded
		
; SaveLoadedBios
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   Determine how much of iosys was loaded in when the loader was loaded
;   by the boot record (only the portion that is guaranteed to be contiguous)
;
; INPUT:
;   AX:Total cluster already read in (loader & bios)
;   CS:CurrentCluster = number of clusters used for loader+2
;
; OUTPUT:
;	ES = 70h
;	DI = next offset to load iosys code
;	AX,BX,CX,DX,SI destroyed
;
;	CS:NextBioLocation = di on output
;	CS:last_cluster = last cluster loaded
;
; calls:     none
;
; ---------------------------------------------------------------------------
;
; Multiply cluster * cluster size in bytes to get total loaded for msload
;
; Subtract total_loaded - (EndOfLoader) to get loaded io.sys in last cluster
;
; Relocate this piece of iosys down to 70:0
;
; ---------------------------------------------------------------------------

SaveLoadedBios:
		push	ds
		; 24/12/2022
		; ds = cs
		; ax = number of loaded clusters
		mul	word [ClusterSize]
		;mul	word [cs:ClusterSize]
					; Get total bytes loaded by
					; this is always < 64k, so
					; lower 16 bits ok

		sub	ax, EndOfLoader ; (OFFSET EndOfLoader)-(OFFSET Start)
		mov	cx, ax
		mov	ax, 70h		; Segment at 70h
		mov	ds, ax
		mov	es, ax
		mov	si, EndOfLoader ; EndOfLoader
		xor	di, di
		rep movsb		; Relocate this code to 0070h:0000h
		;mov	[NextBioLocation], di
		;;mov	[cs:NextBioLocation], di

		; es:di = (the next) buffer address for next read

		pop	ds		; Save where location for next read

; GetContigClusters
; ---------------------------------------------------------------------------
;
; NOTES: go find clusters as long as they are contiguous
;
;
; INPUT:
;   CS:NextBioLocation
;   CS:
;
; OUTPUT:
;
; calls: GetNextFatEntry
; ---------------------------------------------------------------------------
;
;Set CS:SectorCount to sectors per cluster
;
;Call GetNextFatEntry to get next cluster in file
;
;Call check_for_eof
;
;if (nc returned)
;
;   {call GetNextFatEntry
;
;    if (new cluster is contig to old cluster)
;	{add sectors per cluster to CS:SectorCount
;
;	 call check_for_eof
;
;	 if (nc returned)
;
; ---------------------------------------------------------------------------

; 09/12/2022
; END_OF_FILE equ 0FFh
; DosLoadSeg equ 70h

GetContigClusters:

; 24/12/2022
%if 0	
		xor	ah, ah
		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
		push	word [cs:SectorCount]
		call	GetNextFatEntry		; Returns next cluster to read in AX	
		pop	word [cs:SectorCount]
		mov	word [cs:CurrentCluster], ax ; Update the last one found
		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
		jz	short GoToBioInit
		xor	dx, dx
		;sub	ax, 2			; Zero base the cluster
		; 10/12/2022
		dec	ax
		dec	ax
		xor	ch, ch
		mov	cl, [cs:SecPerCluster]
		mul	cx			; How many sectors (before next cluster) 
		add	ax, [cs:FirstSectorL]	; See where the data sector starts
		adc	dx, [cs:FirstSectorH]
		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
		mov	[cs:StartSecH], dx
		mov	di, [cs:NextBioLocation] ; Get where to put code
		push	word [cs:SectorCount]	; Save how many sectors
		;mov	ax, DosLoadSeg
		mov	ax, 70h
		mov	es, ax
		call	ReadSectors
		pop	ax			; Get back total sectors read in
		mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
		add	[cs:NextBioLocation], ax ; Point to where to load next	
		jmp	short GetContigClusters

%endif
		; 24/12/2022
		; ds = cs

		mov	ax, [SecPerCluster]	; Assume we will get one cluster
		mov	[SectorCount], ax	; Sector count = sectors in 1 cluster
		;push	word [SectorCount]
		push	ax
		call	GetNextFatEntry		; Returns next cluster to read in AX	
		pop	word [SectorCount]
		mov	[CurrentCluster], ax	; Update the last one found

		cmp	byte [EndOfFile], 0FFh	; END_OF_FILE
		je	short GoToBioInit ; 23/12/2022
		; 22/12/2022
		;xor	dx, dx ; * (not required)
		; 10/12/2022
		;sub	ax, 2			; Zero base the cluster
		dec	ax
		dec	ax
		; 24/12/2022
		; ax = cluster index
		;mov	cx, [SecPerCluster]
		;mul	cx ; *			; How many sectors (before next cluster) 
		mul	word [SecPerCluster]
		add	ax, [FirstSectorL]	; See where the data sector starts
		adc	dx, [FirstSectorH]
		mov	[StartSecL], ax		; Save it (used by ReadSectors)
		mov	[StartSecH], dx

		; es:di = (current) buffer address for (current) read
	
		call	ReadSectors
				; ES:DI = (the next) buffer address for next read
		
		jmp	short GetContigClusters

; ---------------------------------------------------------------------------

; GoToBiosInit
; ---------------------------------------------------------------------------
;
; NOTES:
;
;  Set up required registers for iosys, then jump to it (70:0)
;
; INPUT:     none
;
;   CS:MediaByte = media byte
;   CS:BootDrive = int 13 drive number we booted from
;   CS:FirstSectorL = first data sector on disk (low) (0-based)
;   CS:FirstSectorH = first data sector on disk (high)
;
; OUTPUT:
;
;   required by msinit
;   DL = int 13 drive number we booted from
;   CH = media byte
;   BX = first data sector on disk (0-based)
;   AX = first data sector on disk (high)
;   DI = sectors/fat for the boot media.
;
; calls:     none
; ---------------------------------------------------------------------------
;
; set up registers for msinit then do far jmp
;
; ---------------------------------------------------------------------------

GoToBioInit:	
		; 24/12/2022
		; ds = cs	
		;mov	ch, [cs:MediaByte]
		;mov	dl, [cs:BootDrive]
		;mov	bx, [cs:FirstSectorL]
		;mov	ax, [cs:FirstSectorH]

		mov	ch, [MediaByte] ; Restore regs required for msint
		mov	dl, [BootDrive] ; Physical drv number we booted from.
		mov	bx, [FirstSectorL] ; AX:BX = first data sector of disk
		mov	ax, [FirstSectorH]

		jmp	70h:0	; Far jump to IoSysAddr	(DOSBIOS)

; =============== S U B	R O U T	I N E =======================================

; ReadSectors
; ---------------------------------------------------------------------------
; notES:
;
;  read in the CS:SectorCount number of sectors at ES:di
;
;
; INPUT:
;
;   DI = OFFSET of start of read
;   ES = segment of read
;   CS:SectorCount = number of sectors to read
;   CS:StartSecL = starting sector (low)
;   CS:StartSecH = starting sector (high)
;   following is bpb info that must be setup prior to call
;   CS:NumHeads
;   CS:number_of_sectors
;   CS:BootDrive
;   CS:SecPerTrack
;
; OUTPUT:
;
;   AX,BX,CX,DX,SI,DI destroyed
; ---------------------------------------------------------------------------
; divide start sector by sectors per track
; the remainder is the actual sector number, 0 based
;
; increment actual sector number to get 1 based
;
; the quotient is the number of tracks - divide by heads to get the cyl
;
; the remainder is actual head, the quotient is cylinder
;
; figure the number of sectors in that track, set al to this
;
; do the read
;
; if error, do reset, then redo the int 13h
;
; if successful read, subtract # sectors read from SectorCount, add to logical
; sector, add #sectors read * BytesPerSec to bx;
;
; if SectorCount <> 0 do next read
; ---------------------------------------------------------------------------

ReadSectors:
		; 24/12/2022
		; 22/12/2022
ReadSectors:
		mov	cx, 5			; 5 retries

		; Convert a logical sector into track/sector/head. AX has the
		; logical sector number
TryRead:
		; 24/12/2022
		; ds = cs
		push	cx
		;mov	ax, [cs:StartSecL]	; Get starting sector
		;mov	dx, [cs:StartSecH]
		mov	ax, [StartSecL]		; Get starting sector
		mov	dx, [StartSecH]
		push	ax
		mov	ax, dx
		xor	dx, dx
		;;div	word [cs:SecPerTrack]
		;div	word [SecPerTrack]	
		; 24/12/2022
		mov	bx, [SecPerTrack]
		div	bx
		mov	[TempH], ax
		;mov	[cs:TempH], ax
		pop	ax
		div	bx
		;div	word [SecPerTrack]
		;;div	word [cs:SecPerTrack]	; [TempH]:ax = track,
						; dx = sector number

		;mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
						; read in this track
		sub	bx, dx
		;mov	si, bx
		mov	si, [SectorCount]

		cmp	si, bx
		jna	short GotLength
		;cmp	[SectorCount], si
		;;cmp	[cs:SectorCount], si	; Is possible sectors in track more
		;jnb	short GotLength		; than what we need to read?
		mov	si, bx
		;mov	si, [SectorCount]
		;;mov	si, [cs:SectorCount]	; Yes, only read what we need to
;GotLength:

		; 24/12/2022
		; IO.SYS < 40KB (segment override is not possible)
		; 700h+0F8FFh < 64KB address 
		;	(there is not an override risk up to 63743 bytes)
; 24/12/2022
%if 0
		; 24/12/2022
		; dma boundary check for >64KB reads
		; Also, Segment Override risk !
		or	di, di
		jz	short dma_boundary_ok ; no problem for the 1st read
		;cmp	byte [BootDrive], 80h
		;;cmp	byte [cs:BootDrive], 80h
		;jnb	short dma_boundary_ok ; no problem for hard disks
dma_boundary_chk:
		cmp	si, 1
		jna	short dma_boundary_ok 
				; 1 sector read will not cause a boundary error			
		push	dx
		push	ax
		mov	ax, si
		sub	dx, dx
		mul	word [BytesPerSec]
		mov	bx, es
		mov	cl, 4
		shl	bx, cl	; convert paragraphs to bytes
		; bx = segment start position (for 64K memory sections)
		add	bx, ax	; byte count to read
		pop	ax
		pop	dx
		add	bx, di	; add current buffer offset to byte count
		jnc	short dma_boundary_ok
		
		; Sector count must be decreased to prevent
		; DMA boundary error or segment override risk!
		dec	si
		jmp	short dma_boundary_chk
dma_boundary_ok:
%endif
		; 24/12/2022
GotLength:
		;inc	dl			; Sector numbers are 1-based
		; 18/12/2022
		inc	dx
		mov	bl, dl			; Start sector in BL
		; 24/12/2022
		mov	dx, [TempH]		; DX:AX = Track
		;mov	dx, [cs:TempH]		; DX:AX = Track
		push	ax
		mov	ax, dx
		xor	dx, dx
		; 24/12/2022
		div	word [NumHeads]
		;div	word [cs:NumHeads]	; Start cyl in AX, head in dl
		;mov	[TempH], ax
		;;mov	[cs:TempH], ax
		pop	ax
		div	word [NumHeads]
		;div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head

			; At this moment, we assume that TempH = 0,
			; ax <= 1024, dx <= 255

		mov	dh, dl
		
		mov	cl, 6
		shl	ah, cl			; Shift cyl high bits up
		or	ah, bl			; Mix in with sector bits
		mov	ch, al			; Setup cyl low
		mov	cl, ah			; Setup cyl/high - sector
		mov	bx, di			; Get back OFFSET
		; 24/12/2022
		mov	dl, [BootDrive]		; Get drive
		;mov	dl, [cs:BootDrive]	; Get drive
		mov	ax, si			; Get number of sectors to read (al)
		mov	ah, 2			; Read sectors
		; 23/12/2022
		;push	ax
		;push	di

			; Issue one read request. ES:BX have the transfer address,
			; AL is the number of sectors.	

		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		; 23/12/2022
		;pop	di
		;pop	ax

		; 23/12/2022
		mov	ah, 0
		
		pop	cx		; Get retry count back
		jnc	short ReadOk	; 23/12/2022
		
		; 23/12/2022
		;mov	bx, di		; Get offset
		; ah = 0
		;xor	ah, ah
		; 23/12/2022
		;push	cx
		; 24/12/2022
		;mov	dl, [BootDrive]
		;;mov	dl, [cs:BootDrive]
		; 23/12/2022
		;push	di
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		; 23/12/2022
		;pop	di
		;pop	cx
		dec	cx
		jz	short ReadError
		jmp	TryRead
; ---------------------------------------------------------------------------

ReadError:				
		jmp	ErrorOut
; ---------------------------------------------------------------------------

ReadOk:
		; 23/12/2022			
		; ah = 0
		; 22/12/2022
		;xor	ah, ah		; Mask out read command, just get # read
		; ch = 0
		mov	cl, al

		; 22/12/2022
		; cx = ax = read (sector) count	
		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
		;mul	bx			; Get total bytes read	
		; 24/12/2022
		; ds = cs
		mul	word [BytesPerSec]
		;mul	word [cs:BytesPerSec]
		add	di, ax			; Add it to OFFSET

		; 24/12/2022
		; IO.SYS < 40KB (segment override is not possible)
		; 700h+0F8FFh < 64KB address 
		;	(there is not an override risk up to 63743 bytes)
		;add	di, ax
		;jnc	short read_next_sector
		;mov	bx, es
		;;add	bx, 1000h
		;add	bh, 10h
		;mov	es, bx
;read_next_sector:

		; 24/12/2022
		; ds = cs
		; 22/12/2022
		sub	[SectorCount], cx
		;sub	[cs:SectorCount], cx
		;;sub	[cs:SectorCount], ax	; Bump number down
		jz	short EndRead
		add	[StartSecL], cx
		;add	[cs:StartSecL], cx
		;;add	[cs:StartSecL], ax	; Where to start next time
		adc	word [StartSecH], 0
		;adc	word [cs:StartSecH], 0
		jmp	ReadSectors
; ---------------------------------------------------------------------------
		
		; 24/12/2022
;EndRead:				
		;retn

; =============== S U B	R O U T	I N E =======================================

; GetNextFatEntry
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   given the last cluster found, this will return the next cluster of
;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
;   of iosys has been loaded, and control is passed to goto_iosys
;   msload can handle maximum fat area size of 128 kb.
;
; INPUT:
;
;    CS:CurrentCluster
;    CS:FatSize
;
; OUTPUT:
;
;   CS:CurrentCluster (updated)
;
; calls:  GetFatSector
; ---------------------------------------------------------------------------
; get CurrentCluster
;
; if (16 bit fat)
;    {if (CurrentCluster = fff8 - ffff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by multiply cluster by 2}
;
; else
;    {if (CurrentCluster = ff8 - fff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by	- multiply cluster by 3
;
;	 rotate right to divide by 2
;
;	 if (cy set - means odd number)
;	    {shr 4 times to keep high twelve bits}
;
;	 else
;	    {and with 0fffh to keep low 12 bits}
;	}
;    }
;
; ---------------------------------------------------------------------------

; 09/12/2022
; FAT_12_BIT equ 1
; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh

GetNextFatEntry:
		push	es
		; 24/12/2022
		; ds = cs
		;mov	ax, [cs:FatSegment]
		mov	ax, [FatSegment]
		mov	es, ax		; ES-> FAT area segment
		; 09/12/2022
		;;mov	byte [cs:EndOfFile], END_OF_FILE
		;mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
		;mov	ax, [cs:CurrentCluster] ; Get last cluster
		; 24/12/2022
		; ds = cs
		mov	byte [EndOfFile], 0FFh ; Assume last cluster
		mov	ax, [CurrentCluster] ; Get last cluster
		cmp	byte [Fatsize], 1
		;;cmp	byte [cs:FatSize], FAT_12_BIT
		;cmp	byte [cs:Fatsize], 1
		jne	short Got16Bit	; 23/12/2022
		mov	si, ax
		shr	ax, 1
		add	si, ax		; SI = AX * 1.5 = AX + AX/2
		; 23/12/2022
		;push	dx
		;xor	dx, dx
		sub	dx, dx ; 23/12/2022
		call	GetFatSector
		; 23/12/2022
		;pop	dx
		jnz	short ClusterOk
		mov	al, [es:bx]
		; 22/12/2022
		;mov	[cs:TempCluster], al
		;push	ax ; (*)
		inc	si
		; 23/12/2022
		;push	dx
		xor	dx, dx
		call	GetFatSector	; Read next fat sector
		; 23/12/2022
		;pop	dx
		; 22/12/2022
		;mov	al, [es:0]
		;mov	[cs:TempCluster+1], al
		;mov	ax, [cs:TempCluster]
		; 22/12/2022
		;pop	ax ; (*) 
		mov	ah, [es:0]
		jmp	short EvenOdd
; ---------------------------------------------------------------------------

ClusterOk:				
		mov	ax, [es:bx]
EvenOdd:	
		; 24/12/2022
		; ds = cs
		test	byte [CurrentCluster], 1
		; 10/12/2022		
		;test	byte [cs:CurrentCluster], 1 ; 09/12/2022
		;;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
		jnz	short OddResult		; If not zero it was odd
		and	ax, 0FFFh		; Keep low 12 bits
		jmp	short TestEOF
; ---------------------------------------------------------------------------

OddResult:				
		mov	cl, 4			; Keep high 12 bits for odd
		shr	ax, cl
TestEOF:				
		cmp	ax, 0FF8h		; Is it last cluster?
		jnb	short GotClusterDone	; Yep, all done here
		jmp	short NotLastCluster
; ---------------------------------------------------------------------------

Got16Bit:
		; 23/12/2022				
		;push	dx
		;xor	dx, dx
		sub	dx, dx ; 23/12/2022
		shl	ax, 1			; Multiply cluster by 2
		adc	dx, 0
		mov	si, ax			; Get the final buffer OFFSET
		call	GetFatSector
		; 23/12/2022
		;pop	dx
		mov	ax, [es:bx]
		cmp	ax, 0FFF8h
		jnb	short GotClusterDone
NotLastCluster:	
		; 24/12/2022
		; ds = cs			
		;;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
		;mov	byte [cs:EndOfFile], 0	; Assume not last cluster
		mov	byte [EndOfFile], 0	; Assume not last cluster
GotClusterDone:				
		pop	es
		; 24/12/2022
EndRead:
		retn

; =============== S U B	R O U T	I N E =======================================

; GetFatSector
; ---------------------------------------------------------------------------
;function: find and read the corresponding fat sector into ES:0
;
;in). SI = offset value (starting from fat entry 0) of fat entry to find.
;     ES = fat sector segment
;     CS:BytesPerSec
;
;out). corresponding fat sector read in.
;      BX = offset value of the corresponding fat entry in the fat sector.
;      CX destroyed.
;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
;      starts at the last byte of the fat sector. in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value. (this will only happen with the 12 bit fat).
;
; ---------------------------------------------------------------------------

		; 24/12/2022
		; 22/12/2022
GetFatSector:
		push	ax
		push	si
		push	di
		mov	ax, si
		; 24/12/2022
		; ds = cs
		;mov	cx, [cs:BytesPerSec]
		;div	cx			; AX = Sector number, DX = Offset
		div	word [BytesPerSec]
		cmp	ax, [LastFatSector]
		;cmp	ax, [cs:LastFatSector]	; The same fat sector?
		je	short SplitChk		; Don't need to read it again.
		mov	[LastFatSector], ax
		;mov	[cs:LastFatSector], ax
		push	dx
		; 24/12/2022
		xor	dx, dx
		;add	ax, [cs:HiddenSectorsL]
		;adc	dx, [cs:HiddenSectorsH]
		;add	ax, [cs:ReservSectors]
		;adc	dx, 0
		; 24/12/2022
		; ds = cs
		add	ax, [FatStartSecL]
		adc	dx, [FatStartSecH]
		mov	[StartSecL], ax
		mov	[StartSecH], dx		; Set up for ReadSectors
		;mov	[cs:StartSecL], ax
		;mov	[cs:StartSecH], dx	; Set up for ReadSectors
		
		mov	word [SectorCount], 1 ; 1 sector			
		;mov	word [cs:SectorCount], 1 ; 1 sector
		xor	di, di ; 0
		; es:di = FATSEGMENT:0000h
		call	ReadSectors
		pop	dx
		; 24/12/2022
		;mov	cx, [cs:BytesPerSec]
SplitChk:
		; 24/12/2022
		mov	cx, [BytesPerSec]				
		dec	cx			; CX = SECTOR SIZE - 1
		cmp	dx, cx			; If last byte of sector, splitted entry.
		mov	bx, dx			; set bx to dx
		pop	di
		pop	si
		pop	ax
EndWrite:		; 10/12/2022
		retn

; ---------------------------------------------------------------------------

ErrorOut:
		; 24/12/2022
		; ds = cs
		;push	cs
		;pop	ds
		
		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
		call	WriteTTY

		; Wait for a keypress on the keyboard.
		; Use the bios keyboard interrupt.

		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character

		; We have to restore the address of the original rom disk
		; parameter table to the location at [0:DskAddr]. The address
		; of this original table has been saved previously in
		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
		; has been restored we can reboot by invoking the bootstrap
		; loader bios interrupt.

		; 23/12/2022
		;xor	bx, bx
		;mov	ds, bx
		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
					 ; (Erdogan Tan, 23/12/2022)
		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
		
		; 23/12/2022
		push	ss ; 0
		pop	ds
		; ds = 0		

		mov	si, DskAddr	; (Int 1Eh)
		mov	[si], bx	; restore offset		
		mov	[si+2], es	; restore segment
		int	19h		; reboot


; =============== S U B	R O U T	I N E =======================================

; WriteTTY
; ---------------------------------------------------------------------------
; in) DS:si -> asciiz string.
;
; WriteTTY the character in al to the screen.
; use video service 'write teletype to active page' (ROM_TTY)
; use normal character attribute
; ---------------------------------------------------------------------------

WriteTTY:
		lodsb
		or	al, al
		jz	short EndWrite
		;mov	AH, ROM_TTY	; 09/12/2022
		mov	ah, 0Eh
		mov	bl, 7		; "normal" attribute
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short WriteTTY
; ---------------------------------------------------------------------------

; 10/12/2022	
;EndWrite:
;		retn

; ---------------------------------------------------------------------------

; 09/12/2022
;include msbio.cl1

		; 22/12/2022
		; 20/12/2022
		; 18/12/2022
		;db 0	; (word alignment)
NonSystemDiskMsg:
		db 0Dh,0Ah		; ...
		db 'Non-System disk or disk error',0Dh,0Ah
		db 'Replace and press any key when ready',0Dh,0Ah,0
; 25/12/2022
align 16

EndOfLoader:
		;dw 01A1h	; 10/12/2022

; ---------------------------------------------------------------------------

;=============================================================================
; DOS BIOS (IO.SYS) DATA SEGMENT 
;=============================================================================
; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)	

section .BIOSDATA vstart=0

;--- DOSBIOS data segment ----------------------------------------------------
;-----------------------------------------------------------------------------

;Bios_Data segment

BData_start:				
hdrv_pat:	jmp	init		; MSBIO1.ASM, MSSBDATA.INC
; ----------------------------------------------------------------------------

DosDataSg:	dw 0

; DOS's int 2f handler will exit via a jump through here.
; This is how the BIOS hooks int2f
			
bios_i2f:	db 0EAh			; far jump to int_2f (segment may not be at 70h)
off_706:	dw int_2f
word_708:	dw 70h			; KERNEL_SEGMENT

romstartaddr:	dw 0			; The start address for the romfind routines
					; This is to maintain binary compatibility
					; with DISK based DOS 5.0

; This is a byte used for special key handling in the resident
; console device driver. It must be here so that it can be included
; in the WIN386 instance table (in INC\LMSTUB.ASM).

altah:		db 0			; special key handling
			
inHMA:		db 0			; flag indicates we're running from HMA
xms:		dd 0			; entry point to xms if above is true

; PTRSAV - pointer save
;
; This variable holds the pointer to the Request Header passed by a program
; wishing to use a device driver. When the strategy routine is called it 
; puts the address of the Request header in this variable and returns.
		
ptrsav:		dd 0			
auxbuf:		;db 4 dup(0)		; set of 1 byte buffers for com 1,2,3, and 4
		db 0, 0, 0, 0 ; 19/10/2022
zeroseg:	dw 0			; easy way to load segment registers with zero			
i13_ds:		dw 0			; ds register for int13 call through	
prevoper:	dw 0			; holds int 13 request (i.e. register ax).			
number_of_sec:	db 0			; holds number of secs. to read on an ecc error
auxnum:		dw 0			; which aux device was requested			

;-----------------------------------------------------------------------------

res_dev_list:

; Device Header for the CON Device Driver

CONHeader:				; HEADER FOR DEVICE "CON"
		dw auxdev2
		dw 70h	
word_727:	dw 8013h
		dw strategy
		dw con_entry
aCon:		db 'CON     '           
auxdev2:	dw prndev2		; HEADER FOR DEVICE "AUX"	
		dw 70h
		dw 8000h
		dw strategy
		dw aux0_entry
aAux:		db 'AUX     '
prndev2:	dw timdev		; HEADER FOR DEVICE "PRN"
		dw 70h
word_74B:	dw 0A0C0h
		dw strategy
		dw prn0_entry
aPrn:		db 'PRN     '		; HEADER FOR DEVICE "CLOCK$"
timdev:		dw dskdev	
		dw 70h
		dw 8008h
		dw strategy
		dw tim_entry
aClock:		db 'CLOCK$  '
dskdev:		dw com1dev		; HEADER FOR DISK DEVICES
		dw 70h
		dw 8C2h
		;dw offset strategy
		;dw offset dsk_entry
		; 19/10/2022
		dw strategy
		dw dsk_entry

; maximum number of drives

drvmax:		db 4			
step_drv:	db 0FEh	 ; -2		; last drive accessed		
fhave96:	db 0			; flag to indicate presence of
					; 96tpi support		
single:		db 0			; used to detect single drive systems		
fhavek09:	db 0			; indicates if this is a k09 or not
					; used by console driver.			
fsetowner:	db 0			; = 1 if we are setting the owner of a
					; drive. (examined by checksingle).
		
com1dev:	dw lpt1dev		; Device Header for device "COM1"	
		dw 70h
		dw 8000h
		dw strategy
		dw aux0_entry
aCom1:		db 'COM1    '
lpt1dev:	dw lpt2dev		; Device Header for device LPT1	
		dw 70h
		dw 0A0C0h
		dw strategy
		dw prn1_entry
aLpt1:		db 'LPT1    '
lpt2dev:	dw lpt3dev		; Device Header for device LPT2	
		dw 70h
		dw 0A0C0h
		dw strategy
		dw prn2_entry
aLpt2:		db 'LPT2    ',0,0,0

;M058; Start of changes
; Orig13 needs to be at offset 0B4h for the CMS floppy driver to work.
;These guys patch Orig13 with their own int 13h hook and so this offset
;cannot change for them to work. Even ProComm does this.

Orig13:		dd 0			; to make Orig13 offset 0B4h		

lpt3dev:	dw com2dev		; Device Header for device LPT3	
		dw 70h
		dw 0A0C0h
		dw strategy
		dw prn3_entry
aLpt3:		db 'LPT3    '
com2dev:	dw com3dev		; Device Header for device "COM2"
		dw 70h
		dw 8000h
		dw strategy
		dw aux1_entry
		; 19/10/2022
aCom2:		db 'COM2    '
com3dev:	;dw offset com4dev	; Device Header for device "COM3"
		dw com4dev
		dw 70h
		dw 8000h
		;dw offset strategy
		;dw offset aux2_entry
		dw strategy
		dw aux2_entry	
aCom3:		db 'COM3    '
com4dev:	dw 0FFFFh		; Device Header for device "COM4"	
		dw 70h
		dw 8000h
		dw strategy
		dw aux3_entry
		db 'COM4    '

;-----------------------------------------------------------------------------

RomVectors:	db 10h			
Old10:		dd 0
		db 13h
Old13:		dd 0			
		db 15h
Old15:		dd 0			
		db 19h
Old19:		dd 0
		db 1Bh
Old1B:		dd 0

;EndRomVectors	equ $

;NUMROMVECTORS	equ ((EndRomVectors - RomVectors)/5)

;-----------------------------------------------------------------------------

start_bds:	dw bds1			; Start	of linked list of BDS's
		dw 70h			; KERNEL_SEGMENT

; (MSDOS 3.3) NOTE:
; Some floppy drives do not have changeline support. The result is a
; large amount of inefficiency in the code. A media-check always returns
; "I don`t know". This cause DOS to reread the FAT on every access and
; always discard any cached data.
;    We get around this inefficiency by implementing a "Logical Door Latch".
; The following three items are used to do this. The logical door latch is
; based on the premise that it is not physically possible to change floppy
; disks in a drive in under two seconds (most people take about 10). The
; logical door latch is implemented by saving the time of the last successful
; disk operation (in the value TIM_DRV). When a new request is made the
; current time is compared to the saved time. If less than two seconds have
; passed then the value "No Change" is returned. If more than two seconds
; have passed the value "Don't Know" is returned.
;    There is one complecation to this algorithm. Some programs change the
; value of the timer. In this unfortunate case we have an invalid timer.
; This possibility is detected by counting the number of disk operations
; which occur without any time passing. If this count exceeds the value of
; "AccessMax" we assume the counter is invalid and always return "Don't
; Know". The variable "AccessCount" is used to keep track of the number
; of disk operation which occur without the time changing.

accesscount:	db 0			
tim_drv:	db 0FFh			
medbyt:		db 0
wrtverify:	; 15/10/2022			
rflag:		db 2			; 2 for	read, 3	for write
verify:		db 0			; 1 if verify after write
seccnt:		dw 0			
		db 0			; -- pad where hardnum was
dsktnum:	db 1			; number of diskette drives			

; (MSDOS 3.3) NOTE:
; Some of the older versions of the IBM rom-bios always assumed a seek would
; have to be made to read the diskette. Consequently a large head settle
; time was always used in the I/O operations. To get around this problem
; we need to continually adjust the head settle time. The following
; algorithm is used:
;
;   Get the current head settle value.
;   If it is 1, then
;	set slow = 15
;   else
;	set slow = value
;   ...
;   if we are seeking and writing then
;	use slow
;   else
;	use fast
;   ...
;   restore current head settle value

motorstartup:	db 0			; value from table
settlecurrent:	db 0			; value	from table
settleslow:	db 0			; slow settle value
nextspeed:	db 0			; value	of speed to be used
save_head_sttl:	db 0			; used by read_sector routine
save_eot:	db 0			; saved	eot from the default DPT
eot:		db 9			
dpt:		dd 0			; pointer to Disk Parameter Table			
cursec:		db 0			; current sector
curhd:		db 0			; current head
curtrk:		dw 0			; current track
spsav:		dw 0			; save the stack pointer
formt_eot:	db 8			; eot used for format
hdnum:		db 0			; head number
trknum:		dw 0			; track	being manipulated
gap_patch:	db 50h			; format gap patched into dpt

;-----------------------------------------------------------------------------

; disk errors returned from the IBM rom

errin:		db 0CCh			; write	fault error
		db 80h			; no response
		db 40h			; seek failure
		db 10h			; bad crc
		db 8			; dma overrun
		db 6			; media	change
		db 4			; sector not found
		db 3			; write	attempt	to write-protect disk
lsterr:		db 0			; all other errors

; returned error codes corresponding to above

errout:		db 10			; write	fault error
		db 2			; no response
		db 6			; seek failure
		db 4			; bad crc
		db 4			; dma overrun
		db 15			; invalid media	change
		db 8			; sector not found
		db 0			; write	attempt	to write-protect disk
		db 12			; general error

;-----------------------------------------------------------------------------

; 30/12/2018 - Retro DOS v4.0

; read in boot sector here, read done in readboot.
; also read sector for dma check for hard disk.
;
; This buffer is word aligned because certain AMI BIOSs have a bug
; in them which causes the byte after the buffer to be trashed
; on floppy reads to odd-byte boundaries. Although no general effort 
; is made to enforce this in the bigger picture, this one small sacrifice
; makes that system more-or-less work.

; 30/12/2022
; (MSDOS 6.21 IO.SYS, BIOSDATA:014Eh)

disksector:	;db 512 dup(0)		; read in boot sector here
		; 19/10/2022
		times 512 db 0

;-----------------------------------------------------------------------------

; 30/12/2018 - Retro DOS v4.0
;-----------------------------------------------------------------------------
; 25/05/2018 (04/04/2018)
;*****************************************************************************
;	"bds" contains information for each drive in the system.
;	various values are patched whenever actions are performed.
;	sectors/alloc. unit in bpb initially set to -1 to signify that
;	the bpb has not been filled. link also set to -1 to signify end
;	of list. # of cylinders in maxparms initialized to -1 to indicate
;	that the parameters have not been set.

; 30/12/2022
; (MSDOS 6.21 IO.SYS, BIOSDATA:034Eh)

bds1:		;dw offset bds2
		dw bds2	; 19/10/2022
		dw 70h			; dword	link to	next structure
		db 0			; int 13h drive	number
		db 0			; logical drive	letter
fdrive1:	dw 512			
					; physical sector size in bytes
		db 0FFh			; sectors/allocation unit
		dw 1			; reserved sectors for dos
		db 2			; no of	file allocation	tables
		dw 64			; number of root directory entries
		dw 360			; number sectors (at 512 bytes each)
		db 0			; media	descriptor, initially 0
		dw 2			; number of fat	sectors
		dw 9			; sector limit (sectors	per track)
		dw 1			; head limit (number of	heads -	1)
		dw 0			; hidden sector	count (low word)
		dw 0			; hidden sector	(high)
		dw 0			; number sectors (low)
		dw 0			; number sectors (high)
		db 0			; true => large	fats
		dw 0			; open ref. count
		db 3			; form factor
		dw 20h			; various flags
		dw 40			; number of cylinders
recommended_bps: dw 512			; recommended bps for this drive
		db 1
		dw 1
		db 2
		dw 224			; number of root directory entries
		dw 360
		db 0F0h			; media	descriptor, initially 0F0h
		dw 2
		dw 9
		dw 2
		dw 0
		dw 0
		dw 0
		dw 0
		;db 6 dup(0)
		times 6 db 0		; 19/10/2022
		db 0FFh			; last track accessed on this drive
word_A95:	dw 0FFFFh		; keep these two contiguous (?)
		dw 0FFFFh
		db 'NO NAME    ',0      ; volume id for this disk
		dd 0			; current volume serial	from boot record
		db 'FAT12   ',0         ; current file system id from boot record
; ----

bds2:		dw bds3		
		dw 70h
		db 0
		db 0
fdrive2:	dw 512			
byte_ABA:	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
; ----

bds3:		dw bds4		
		dw 70h
		db 0
		db 0
fdrive3:	dw 512			
		db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0
; ----

bds4:		dw 0FFFFh		
		dw 70h
		db 0
		db 0
fdrive4:	dw 512			
byte_B82:	db 0FFh, 1, 0, 2, 40h, 0, 68h, 1, 0, 2,	0, 9, 0, 1, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 3, 20h, 0, 28h, 0
		db 0, 2, 1, 1, 0, 2, 0E0h, 0, 68h, 1, 0F0h, 2, 0, 9, 0
		db 2, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0FFh
		db 0FFh, 0FFh, 0FFh, 0FFh, 4Eh,	4Fh, 20h, 4Eh, 41h, 4Dh
		db 45h,	20h, 20h, 20h, 20h, 0, 0, 0, 0,	0, 46h,	41h, 54h
		db 31h,	32h, 20h, 20h, 20h, 0

;-----------------------------------------------------------------------------

sm92:		db 3			; .spf			
		db 9			; .spt
		db 112	; 70h		; .cdire
		dw 1440	; 2*9*80	; .csec
		db 2			; .spau
		db 2			; .chead

keyrd_func:	db 0			
keysts_func:	db 1			
printdev:	db 0			; printer device index

wait_count:	;dw 4 dup(50h)		; retry	counts for printers
		times 4 dw 50h		; 19/10/2022

daycnt:		dw 0			
t_switch:	db 0			; flag for updating daycnt
havecmosclock:	db 0			
base_century:	db 19			
base_year:	db 80			
month_tab:	db 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 
bintobcd:	dw bin_to_bcd		; points to bin_to_bcd proc in msinit
		dw 70h ; 17/10/2022	
daycnttoday:	dw daycnt_to_day	; points to daycnt_to_day in msinit
		dw 70h ; 17/10/2022
set_id_flag:	db 0			; flag for getbp routine
fat_12_id:	db 'FAT12   ',0         
fat_16_id:	db 'FAT16   ',0         
vol_no_name:	db 'NO NAME    ',0      

temp_h:		dw 0			; temporary for	32 bit calculation
start_sec_h:	dw 0			; starting sector number high word
saved_word:	dw 0			; tempory saving place for a word
multrk_flag:	dw 0			
ec35flag:	db 0			; flags	for 3.5	inch disk drives
vretry_cnt:	dw 0			
soft_ecc_cnt:	dw 0			
multitrk_format_flag: db 0		; multi	track format request flag
xfer_seg:	dw 0			; temp for transfer segment

; variables for msdioctl.asm module

; tracktable contains a 4-tuples (c,h,r,n) for each sector in a track
; c = cylinder number,h = head number,r = sector id,n = bytes per sector
;	n	bytes per sector
;      ---	----------------
;	0	      128
;	1	      256
;	2	      512
;	3	     1024

;max_sectors_curr_sup equ 63		; current maximum sec/trk that
;					; we support (was 40 in dos 3.2)

sectorspertrack: dw 36			
tracktable:	db 0, 0, 1, 2		
		db 0, 0, 2, 2
		db 0, 0, 3, 2
		db 0, 0, 4, 2
		db 0, 0, 5, 2
		db 0, 0, 6, 2
		db 0, 0, 7, 2
		db 0, 0, 8, 2
		db 0, 0, 9, 2
		db 0, 0, 10, 2
		db 0, 0, 11, 2
		db 0, 0, 12, 2
		db 0, 0, 13, 2
		db 0, 0, 14, 2
		db 0, 0, 15, 2
		db 0, 0, 16, 2
		db 0, 0, 17, 2
		db 0, 0, 18, 2
		db 0, 0, 19, 2
		db 0, 0, 20, 2
		db 0, 0, 21, 2
		db 0, 0, 22, 2
		db 0, 0, 23, 2
		db 0, 0, 24, 2
		db 0, 0, 25, 2
		db 0, 0, 26, 2
		db 0, 0, 27, 2
		db 0, 0, 28, 2
		db 0, 0, 29, 2
		db 0, 0, 30, 2
		db 0, 0, 31, 2
		db 0, 0, 32, 2
		db 0, 0, 33, 2
		db 0, 0, 34, 2
		db 0, 0, 35, 2
		db 0, 0, 36, 2
		times 108 db 0		; 19/10/2022
		;db 108 dup(0)		; 4*max_sectors_curr_sup - ($ -	tracktable) dup	(0)
					; times	((4*63)	- 144) db 0

;-----------------------------------------------------------------------------

; this is a real ugly place to put this
; it should really go in the bds

mediatype:	db 0			
media_set_for_format: db 0		; 1 if we have done an int 13 set media
					; type for format call
had_format_error: db 0			; 1 if the previous format operation
					; failed.

; temp disk base table. it holds the the current dpt which is then replaced by
; the one passed by "new roms" before we perform a format operation. the old
; dpt is restored in restoreolddpt. the first entry (disk_specify_1) is -1 if
; this table does not contain the previously saved dpt.
		
tempdpt:	dd 0FFFFFFFFh ; -1	; temp disk base table
model_byte:	db 0FFh			; model	byte set at init time
secondary_model_byte: db 0
		
int19sem:	db 0			; indicate that all int 19
					; initialization is complete
		
;; we assume the following remain contiguous and their order doesn't change
;i19_lst:
;	irp	aa,<02,08,09,0a,0b,0c,0d,0e,70,72,73,74,76,77>
;	public	int19old&aa
;		db	aa&h	; store the number as a byte
;int19old&aa	dd	-1	; original hardware int. vectors for int 19h.
;	endm

; 21/10/2022

i19_lst:	db 2			
					; Int19old&aa
int19old02:	dd 0FFFFFFFFh ; -1
		db 8
int19old08:	dd 0FFFFFFFFh		; original hardware int. vectors for int 19h
		db 9
int19old09:	dd 0FFFFFFFFh
		db 0Ah
int19old0A:	dd 0FFFFFFFFh
		db 0Bh
int19old0B:	dd 0FFFFFFFFh
		db 0Ch
int19old0C:	dd 0FFFFFFFFh
		db 0Dh
int19old0D:	dd 0FFFFFFFFh
		db 0Eh
int19old0E:	dd 0FFFFFFFFh
		db 70h
int19old70:	dd 0FFFFFFFFh
		db 72h
int19old72:	dd 0FFFFFFFFh
		db 73h
int19old73:	dd 0FFFFFFFFh
		db 74h
int19old74:	dd 0FFFFFFFFh
		db 76h
int19old76:	dd 0FFFFFFFFh
		db 77h
int19old77:	dd 0FFFFFFFFh

;num_i19	equ ($ - i19_lst)/5  ; 18/03/2019

;-----------------------------------------------------------------------------

dskdrvs:	dw fdrive1	
		dw fdrive2
		dw fdrive3
		dw fdrive4

;M011 -- made all hard drive stuff variable
		;dw 22 dup(0)		; up to	26 drives for mini disks
		times 22 dw 0	; 19/10/2022

;-----------------------------------------------------------------------------

; 01/10/2022 - Retro DOS v4.0 (MSDOS v5.0 -actual-)
; 30/12/2018 - Retro DOS v4.0 (MSDOS v6.21 -draft-)
; 01/06/2018 - Retro DOS v3.0 (MSDOS v3.3)

;variables for dynamic relocatable modules
;these should be stay resident.

int6c_ret_addr:	dd 0			; return address from int 6Ch
					; for p12 machine

; data structures for real-time date and time
			
bin_date_time:	db 0, 0, 0, 0		; century, year, month,	day

month_table:	dw 0			; january
		dw 31			; february
		dw 59
		dw 90
		dw 120
		dw 151
		dw 181
		dw 212
		dw 243
		dw 273
		dw 304
		dw 334			; december

daycnt2:	dw 0			
feb29:		db 0			; february 29 in a leap	year flag

;-----------------------------------------------------------------------------
;
; 01/10/2022 - (New/Actual) Retro DOS v4.0 (will run as MSDOS 5.0)	
; by Erdogan Tan (Istanbul) ! free source code !
; 31/12/2018 - (old/draft) Retro DOS v4.0 (will/would run as MSDOS 6.21)

; ----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	Entry points into Bios_Code routines. The segment values	*
;*	  are plugged in by seg_reinit.					*
;*									*
;************************************************************************

; 01/10/2022 - Retro DOS v4.0 - IO.SYS (MSDOS v5.0)
; BIOSCODE_SEGMENT equ 2C7h
; BIOSDATA_SEGMENT equ 70h ; KERNEL_SEGMENT equ 70h

; 01/10/2022 - Erdogan Tan
; (disassembled MSDOS 5.0 IO.SYS code here with fixed function/routine
;  addresses, they will be changed to table labels later)

; 09/12/2022
%if 0
cdev:		dw 43h,	2C7h		; chardev_entry
					; at 2C7h:43h =	70h:25B3h
ttticks:	dw 396h, 2C7h		; time_to_ticks
					; at 2C7h:396h = 70h:2906h
bcode_i2f:	dw 1302h, 2C7h		; i2f_handler
					; at 2C7h:1302h	= 70h:3872h
i13x:		dw 154Bh, 2C7h		; i13z
					; at 2C7h:154Bh	= 70h:3ABBh
%endif

; 30/12/2022
; (IOSYSCODESEG is 2CCh for MSDOS 6.21 IO.SYS)

; 09/12/2022
cdev:		dw chardev_entry, IOSYSCODESEG
ttticks:	dw time_to_ticks, IOSYSCODESEG
bcode_i2f:	dw i2f_handler, IOSYSCODESEG
i13x:		dw i13z, IOSYSCODESEG

end_BC_entries:	; 15/10/2022

;************************************************************************
;*									*
;*	cbreak - break key handling - simply set altah=3 and iret	*
;*									*
;************************************************************************

cbreak:					
		mov	byte [cs:altah], 3 ; break key handling
					; indicate break key set
intret:					
		iret

; =============== S U B	R O U T	I N E ========================================


;************************************************************************
;*									*
;*	strategy - store es:bx (device driver request packet)		*
;*		     away at [ptrsav] for next driver function call	*
;*									*
;************************************************************************

strategy:	; proc far		
		mov	[cs:ptrsav], bx ; store es:bx (device driver request packet)
					; away at [ptrsav] for next driver function call
		mov	[cs:ptrsav+2], es
		retf

; ----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	device driver entry points. these are the initial		*
;*	  'interrupt' hooks out of the device driver chain.		*
;*	  in the case of our resident drivers, they'll just		*
;*	  stick a fake return address on the stack which		*
;*	  points to dispatch tables and possibly some unit		*
;*	  numbers, and then call through a common entry point		*
;*	  which can take care of a20 switching				*
;*									*
;************************************************************************

; 01/10/2022 - Erdogan Tan
; (disassembled MSDOS 5.0 IO.SYS code here with fixed table
;  addresses, they will be changed to table labels later)

; 09/12/2022

con_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 0E4h		; con_table
		dw con_table	
					; 2C7h:0E4h = 70h:2654h
; ----------------------------------------------------------------------------

prn0_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 0FBh		; prn_table
		dw prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 0, 0
; ----------------------------------------------------------------------------

prn1_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 0FBh		; prn_table
		dw prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 0, 1
; ----------------------------------------------------------------------------

prn2_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 0FBh		; prn_table
		dw prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 1, 2
; ----------------------------------------------------------------------------

prn3_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 0FBh		; prn_table
		dw prn_table
					; 2C7h:0FBh = 70h:266Bh
		db 2, 3
; ----------------------------------------------------------------------------

aux0_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 130h		; aux_table
		dw aux_table
					; 2C7h:130h = 70h:26A0h
		db 0
; ----------------------------------------------------------------------------

aux1_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 130h		; aux_table
		dw aux_table
					; 2C7h:130h = 70h:26A0h
		db 1
; ----------------------------------------------------------------------------

aux2_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 130h		; aux_table
		dw aux_table
					; 2C7h:130h = 70h:26A0h
		db 2
; ----------------------------------------------------------------------------

aux3_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 130h		; aux_table
		dw aux_table
					; 2C7h:130h = 70h:26A0h
		db 3
; ----------------------------------------------------------------------------

tim_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 147h		; tim_table
		dw tim_table
					; 2C7h:147h = 70h:26B7h
; ----------------------------------------------------------------------------

; 15/10/2022
;DSKTBL	equ dsktbl - DOSBIOSEG_2C7h	; dsktbl - 2C70h
; 09/12/2022
DSKTBL equ dsktbl

dsk_entry:				
		call	cdev_entry
; ----------------------------------------------------------------------------
		;dw 4A2h		; dsktbl
		dw DSKTBL		; 09/12/2022
					; 2C7h:4A2h = 70h:2A12h

; =============== S U B	R O U T	I N E ========================================

;************************************************************************
;*									*
;*	Ensure A20 is enabled before jumping into code in HMA.		*
;*	This code assumes that if Segment of Device request packet is	*
;*	DOS DATA segment then the Device request came from DOS & that	*
;*	A20 is already on.						*
;*									*
;************************************************************************

cdev_entry:	; proc near		
		cmp	byte [cs:inHMA], 0
		jz	short ce_enter_codeseg
				; optimized for DOS in HMA
		push	ax
		mov	ax, [cs:DosDataSg]
		cmp	[cs:ptrsav+2], ax
		pop	ax
		jnz	short not_from_dos
				; jump is coded this way to fall thru
				; in 99.99% of the cases
ce_enter_codeseg:
		jmp	far [cs:cdev]			
		;jmp	dword ptr cs:cdev
;-----------------------------------------------------------------------------

not_from_dos:				
		call	EnsureA20On
		jmp	short ce_enter_codeseg

;************************************************************************
;*									*
;*	outchr - this is our int 29h handler. it writes the		*
;*	   character in al on the display using int 10h ttywrite	*
;*									*
;************************************************************************

; 30/12/2022
; (MSDOS 6.21 IO.SYS, BIOSDATA:0762h)

outchr:					
		push	ax		; int 29h handler
		push	si
		push	di
		push	bp
		push	bx
		mov	ah, 0Eh
		mov	bx, 7
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		pop	bx
		pop	bp
		pop	di
		pop	si
		pop	ax
		iret
;-----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	block13 - our int13 hooker					*
;*									*
;************************************************************************

block13:				
		cmp	byte [cs:inHMA], 0
		jz	short skipa20
		call	IsA20Off	; A20 Off?
		jnz	short skipa20
		call	EnableA20	; assure a20 enabled

skipa20:				
		mov	[cs:i13_ds], ds	; save caller's ds for call-through
		pushf			; fake interrupt
		call	far [cs:i13x]
		;call	dword ptr cs:i13x
					; call through Bios_Code entry table
		mov	ds, [cs:i13_ds]
		retf	2

; =============== S U B	R O U T	I N E =======================================

; the int13 hook calls back here to call-through to the ROM
; this is necessary because some people have extended their
; ROM BIOSs to use ds as a parameter/result register and
; our int13 hook relies heavily on ds to access Bios_Data

call_orig13:	; proc far		
		mov	ds, [i13_ds]	; get caller's ds register
		pushf			; simulate an int13
		call	far [cs:Orig13]
		;call	cs:Orig13
		mov	[cs:i13_ds], ds
		push	cs
		pop	ds		; restore ds ->	Bios_Data before return

		pushf
		; 10/12/2022
		; ds = cs
		cmp	byte [inHMA], 0	; 16/10/2022
		;cmp	byte [cs:inHMA], 0
		jz	short corig13_popf_retf
		call	IsA20Off
		jnz	short corig13_popf_retf
		call	EnableA20
corig13_popf_retf:			
		popf
		retf

;-----------------------------------------------------------------------------

; BIOSDATA:07BBh (MSDOS 6.21, IO.SYS)
; BIOSDATA:07BBh (MSDOS 5.0, IO.SYS) ; 16/10/2022

HiMem:		dd 0FFFF0090h		
LoMem:		dd 80h

; ----------------------------------------------------------------------------			

; =============== S U B	R O U T	I N E ========================================


;************************************************************************
;*									*
;*	EnsureA20On - ensure that a20 is enabled if we're running	*
;*	  in the HMA before interrupt entry points into Bios_Code	*
;*									*
;************************************************************************

EnsureA20On:	; proc near		
		call	IsA20Off
		;jz	short EnableA20
		;retn
		; 18/12/2022
		jnz	short A20On_retn	

; =============== S U B	R O U T	I N E ========================================


EnableA20:	; proc near		
		push	ax
		push	bx
		mov	ah, 5	 ; local enable a20
		;call	cs:xms
		call	far [cs:xms] ; 16/10/2022
		pop	bx
		pop	ax
A20On_retn:	; 18/12/2022	
		retn

; =============== S U B	R O U T	I N E ========================================


IsA20Off:	; proc near		
		push	ds
		push	es
		push	cx
		push	si
		push	di
		lds	si, [cs:HiMem]
		les	di, [cs:LoMem]
		mov	cx, 8
		repe cmpsw
		pop	di
		pop	si
		pop	cx
		pop	es
		pop	ds
		retn

; ----------------------------------------------------------------------------

DisableA20:
		push	ax
		push	bx
		mov	ah, 6		; local disable A20
		call	far [cs:xms]
		;call	cs:xms
		pop	bx
		pop	ax
		retn

; ----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	int19 - bootstrap interrupt -- we must restore a bunch of the	*
;*	  interrupt vectors before resuming the original int19 code	*
;*									*
;************************************************************************

int19:					
		push	cs
		pop	ds
		mov	es, [zeroseg]	; 16/10/2022
		mov	cx, 5		; NUMROMVECTORS
		;mov	si, offset RomVectors
		mov	si, RomVectors	; 19/10/2022
next_int:				
		lodsb			; get int number
		cbw			; assume < 128
		shl	ax, 1
		shl	ax, 1		; int *	4
		mov	di, ax
		lodsw
		stosw
		lodsw
		stosw			; install the saved vector
		loop	next_int
		cmp	byte [int19sem], 0 ; 19/10/2022
		jz	short doint19
		mov	si, i19_lst	; stacks code has changed these hardware interrupt vectors
					; stkinit in sysinit1 will initialize int19oldxx values
		mov	cx, 14		; num_i19

i19_restore_loop:			
		lodsb			; get interrupt	number
		cbw			; assume < 128
		mov	di, ax
		lodsw			; get original vector offset
		mov	bx, ax		; save it
		lodsw
		cmp	bx, 0FFFFh	; check	for 0ffffh (unlikely segment)
		jz	short i19_restor_1 ; opt no need to check selector too
		cmp	ax, 0FFFFh	; opt 0ffffh is	unlikely offset
		jz	short i19_restor_1
		add	di, di
		add	di, di
		xchg	ax, bx
		stosw
		xchg	ax, bx
		stosw			; put the vector back

i19_restor_1:				
		loop	i19_restore_loop

doint19:				
		cmp	byte [inHMA], 0	; ; Is dos running from	HMA
		jz	short SkipVDisk
		call	EraseVDiskHead	; Then erase our VDISK header at 1MB boundary
					; Some m/c's (AST 386 & HP QS/16 do not clear
					; the memory above 1MB during a	warm boot.
SkipVDisk:				
		int	19h		; DISK BOOT
					; causes reboot	of disk	system

; =============== S U B	R O U T	I N E ========================================

;-----------------------------------------------------------------------------
;
; procedure : int15
;
;		Int15 handler for recognizing ctrl-alt-del seq
;		If it recognizes ctrl-alt-del and if DOS was
;		is running high, it Erases the VDISK header
;		present at 1MB boundary
;
;-----------------------------------------------------------------------------

; 16/10/2022
;DELKEY		equ	53h
;ROMDATASEG	equ	40h
KBFLAG		equ	17h
;CTRLSTATE	equ	04h
;ALTSTATE	equ	08h

Int15:		; proc near		
		;cmp	ax, 4F00h+DELKEY
		cmp	ax, 4F53h	; del keystroke ?
		jz	short int15_1
		jmp	far [cs:Old15]	; 16/10/2022
		;jmp	cs:Old15
; ----------------------------------------------------------------------------

int15_1:				
		push	ds
		push	ax
		mov	ax, 40h		; ROMDATASEG
		mov	ds, ax
		;mov	al, ds:17h	; [KBFLAG]
		; 16/10/2022
		mov	al, [KBFLAG]
		and	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		cmp	al, 0Ch		; (CTRLSTATE | ALTSTATE)
		jnz	short int15_2
		push	cs
		pop	ds
		cmp	byte [inHMA], 0	; is DOS running from HMA
		jz	short int15_2
		call	EraseVDiskHead
int15_2:				
		pop	ax
		pop	ds
		stc
		jmp	far [cs:Old15]	; 16/10/2022
		;jmp	cs:Old15

; =============== S U B	R O U T	I N E ========================================

;-----------------------------------------------------------------------------
;
; procedure : EraseVDiskHead
;
;		Erases the VDisk Header present in the 1MB boundary
;
;-----------------------------------------------------------------------------

EraseVDiskHead:	; proc near		
		push	ax
		push	cx
		push	di
		push	es
		call	EnsureA20On
		mov	ax, 0FFFFh	; HMA seg
		mov	es, ax
		mov	di, 10h		; point	to VDISK header
		mov	cx, 10h		; size of vdisk	header
		xor	ax, ax
		rep stosw		; clear	it
		pop	es
		pop	di
		pop	cx
		pop	ax
		retn

; ----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	the int2f handler chains up to Bios_Code through here.		*
;*	  it returns through one of the three functions that follow.	*
;*	  notice that we'll assume we're being entered from DOS, so	*
;*	  that we're guaranteed to be A20 enabled if needed		*
;*									*
;************************************************************************

int_2f:		
		jmp	far [cs:bcode_i2f] ; 16/10/2022			
		;jmp	dword ptr cs:bcode_i2f ; far [cs:bcode_i2f]

; ----------------------------------------------------------------------------

; re-enter here to transition out of hma mode and jmp to dsk_entry
; note:  is it really necessary to transiton out and then back in?
;	 It's not as if this is a really speed critical function.
;	 might as well do whatever's most compact.

i2f_dskentry:				
		jmp	dsk_entry

; ----------------------------------------------------------------------------

;************************************************************************
;*									*
;*	re_init - called back by sysinit after a bunch of stuff		*
;*		is done. presently does nothing. affects no		*
;*		registers!						*
;*									*
;************************************************************************

; 09/12/2022
; re_init_:
re_init:				; called back by sysinit after
		retf			; a bunch of stuff is done.
					; presently does nothing

; ----------------------------------------------------------------------------

;SR; WIN386 support

; WIN386 instance data structure
;
; Here is a Win386 startup info structure which we set up and to which
; we return a pointer when Win386 initializes.

Win386_SI:	db 3, 0			; SI_Version
					; Startup Info for Win386
SI_Next:	dd 0			; pointer to next info structure
		dd 0			; a field we don't need
		dd 0			; another field	we don't need
SI_Instance:	dw Instance_Table
		dw 70h	; Bios_Data	; far pointer to instance table

; This table gives Win386 the instance data in the BIOS and ROM-BIOS data
; areas. Note that the address and size of the hardware stacks must
; be calculated and inserted at boot time.

Instance_Table:	dw 0, 50h		; print	screen status...
		dw 2			; ... 2	bytes
		dw 0Eh,	50h		; ROM Basic data...
		dw 14h			; ... 14H bytes
		dw altah		; a con	device buffer...
		dw 70h			; Bios_Data segment
		dw 1			; ... 1 byte

NextStack:

; NOTE:  If stacks are disabled by STACKS=0,0, the following
;	instance items WILL NOT be filled in by SYSINIT.
;	That's just fine as long as these are the last items
;	in the instance list since the first item is initialized
;	to 0000 at load time.

		dw 0, 0			; pointer to next stack	to be used...
		dw 2			; ... 2 bytes
IT_StackLoc:	dd 0			; location of hardware stacks
IT_StackSize:	dw 0			; size of hardware stacks
		dd 0			; terminate the	instance table

					;SR;
IsWin386:	db 0			; Flag to indicate whether
					; Win386 is running or not
;-----------------------------------------------------------------------------

;This routine was originally in BIOS_CODE but this causes a lot of problems
;when we call it including checking of A20. The code being only about 
;30 bytes, we might as well put it in BIOS_DATA

V86_Crit_SetFocus:			
		push	di
		push	es
		push	bx
		push	ax
		xor	di, di
		mov	es, di
		mov	bx, 15h		; Device ID of DOSMGR device
		mov	ax, 1684h	; Get API entry	point
		int	2Fh		; - Multiplex -	MS WINDOWS - GET DEVICE	API ENTRY POINT
					; BX = virtual device (VxD) ID,	ES:DI =	0000h:0000h
					; Return: ES:DI	-> VxD API entry point,	or 0:0 if the VxD does not support an API
		mov	ax, es
		or	ax, di
		jz	short Skip	; Here,	es:di is address of API	routine.
					; Set up stack frame to	simulate a call.
		push	cs
		;mov	ax, offset Skip
		mov	ax, Skip
		push	ax
		push	es
		push	di		; API far call address
		mov	ax, 1		; SetFocus function number
		retf			; do the call
;-----------------------------------------------------------------------------

Skip:					
		pop	ax
		pop	bx
		pop	es
		pop	di
		retf

;End WIN386 support

; ----------------------------------------------------------------------------

; 17/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

; 09/12/2022
;SYSINITSEG	equ 46Dh  ; SYSINIT segment
;DOSLOADSEG	equ 83Fh  ; MSDOS.SYS (kernel) loading segment		
; (followings are in sysinit segment)
;FTryToMovDOSHi	equ 0A84h ; (procedure in SYSINIT segment)
FTRYTOMOVDOSHI	equ FTryToMovDOSHi ; SYSINIT section
;DEVICELIST	equ 273h
DEVICELIST	equ DEVICE_LIST	; SYSINIT section 	
;MEMORYSIZE	equ 292h	
MEMORYSIZE	equ MEMORY_SIZE	; SYSINIT section
;DEFAULTDRIVE	equ 296h
DEFAULTDRIVE	equ DEFAULT_DRIVE ; SYSINIT section
;;currentdoslocation equ 271h
;CURRENTDOSLOCATION equ 271h
CURRENTDOSLOCATION equ CURRENT_DOS_LOCATION  ; SYSINIT section
;SYSINITSTART	equ 267h
SYSINITSTART	equ SYSINIT  ; SYSINIT section
; 18/10/2022
;toomanydrivesflag equ 3FFh 
TOOMANYDRIVESFLAG equ toomanydrivesflag ; SYSINIT section	

; ----------------------------------------------------------------------------

FreeHMAPtr:	dw 0FFFFh		
;MoveDOSIntoHMA: dd 46D0A84h 		; FTryToMovDOSHi
					; (procedure in	SYSINIT	segment)
; 17/10/2022
MoveDOSIntoHMA:	dw FTRYTOMOVDOSHI	; 09/12/2022
		dw SYSINITSEG	

;SR;
; A communication block has been setup between the DOS and the BIOS. All
;the data starting from SysinitPresent will be part of the data block. 
;Right now, this is the only data being communicated. It can be expanded 
;later to add more stuff

SysinitPresent:	db 0			
endfloppy:	db 0, 0

; ----------------------------------------------------------------------------			

; Bios_Data ends
	
; Possibly disposable BIOS data
; This data follows the	regular	BIOS data,
; and is part of the same group.

nul_vid:	db 'NO NAME    ',0      
					; null volume id
tmp_vid:	db 'NO NAME    ',0      
					; vid scratch buffer
harddrv:	db 80h			

end96tpi:

;;*********************************************************************
;;memory allocation for bdss
;;*********************************************************************
;
;;max_mini_dsk_num equ 23	; max # of mini disk ibmbio can support
;
;;bdss	BDS_STRUC (2+max_mini_dsk_num) dup (<>)	; currently max. 25
;
;bdss:	times BDS.size*(2+max_mini_dsk_num) db 0

bdss:		dw 0FFFFh		
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		dw 0FFFFh
		db 0, 0, 50h, 3, 0, 2, 1, 1, 0,	2, 10h,	0, 0, 0, 0F8h
		db 1, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 3
		db 20h,	0, 28h,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0
		db 0, 0, 0, 0, 0, 0, 0,	0, 0, 0, 0, 0, 0, 0, 0,	0, 0, 0
		db 0, 0FFh, 1, 0, 0, 0,	4Eh, 4Fh, 20h, 4Eh, 41h, 4Dh, 45h
		db 20h,	20h, 20h, 20h, 0, 0, 0,	0, 0, 46h, 41h,	54h, 31h
		db 32h,	20h, 20h, 20h, 0
		db 0

;---------------------------------------------------------------------------
; Possibly disposable data, goes at end of data group
;***************************************************************************

; Possibly disposable data, goes at end of data group

;***	ibm_disk_io - main routine, fixes at rom bug
;
;	entry:	(ah) = function, 02 or 0a for read.
;		(dl) = drive number (80h or 81h).
;		(dh) = head number.
;		(ch) = cylinder number.
;		(cl) = sector number (high 2 bits has cylinder number).
;		(al) = number of sectors.
;		(es:bx) = address of read buffer.
;		for more on register contents see rom bios listing.
;		stack set up for return by an iret.
;
;	exit:	(ah) = status of current operation.
;		(cy) = 1 if failed, 0 if successful.
;		for other register contents see rom bios listing.
;
;	uses:	
;
;
;	warning: uses old13 vector for non-read calls.
;		does direct calls to the at rom.
;		does segment arithmatic.
;
;	effects: performs disk i/o operation.

; 16/10/2022
; 28/05/2019
cmd_block equ 42h ; ROMBIOS DATA segment (40h) offset 42h ; 13/12/2022

;* offsets into cmd_block for registers

pre_comp equ 0	;write pre-compensation
sec_cnt	 equ 1	;sector count
sec_num	 equ 2	;sector number
cyl_low	 equ 3	;cylinder number, low part
cyl_high equ 4	;cylinder number, high part
drv_head equ 5	;drive/head (bit 7 = ecc mode, bit 5 = 512 byte sectors, 
		;            bit 4 = drive number, bits 3-0 have head number)
cmd_reg  equ 6	;command register

; 01/10/2022
disk_status1	equ 74h
hf_num		equ 75h
control_byte	equ 76h

; 30/12/2022
; (MSDOS 6.21 IO.SYS, BIOSDATA:12DEh)

ibm_disk_io:				
		cmp	dl, 80h		; main routine,	fixes at rom bug
		jb	short atd1	; pass through floppy disk calls. 
		cmp	ah, 2
		jz	short atd2	; intercept call 02 (read sectors).
		cmp	ah, 0Ah
		jz	short atd2	; and call 0Ah (read long).
atd1:
		jmp	far [cs:Old13]					
		;jmp	cs:Old13	; use rom int 13h handler
;-----------------------------------------------------------------------------

atd2:					
		push	bx
		push	cx
		push	dx
		push	di
		push	ds
		push	es
		push	ax
		mov	ax, 40h		; bioseg (rombios data segment)
					; establish bios segment addressing
		mov	ds, ax
		; 16/10/2022
		mov	byte [disk_status1], 0
		;mov	byte ptr ds:74h, 0 ; [disk_status1]
					; initially no error code.
		and	dl, 7Fh		; mask to hard disk number
		cmp	dl, [hf_num]
		;cmp	dl, ds:75h	; [hf_num] ; 40h:75h
		jb	short atd3	; disk number in range
		;mov	byte ptr ds:74h, 1 ; bad_disk
		mov	byte [disk_status1], 1
		jmp	short atd4	; disk number out of range error,
					; return
; ----------------------------------------------------------------------------

atd3:					
		push	bx
		mov	ax, es
		shr	bx, 4		; make es:bx to seg:000x form.
		add	ax, bx
		mov	es, ax
		pop	bx
		and	bx, 0Fh
		push	cs
		call	check_dma
		jb	short atd4	; abort if dma across segment boundary
		pop	ax
		push	ax
		call	setcmd		; set up command block for disk op
		mov	dx, 3F6h	; hf_reg_port 
		out	dx, al		; write out command modifier
		call	docmd		; carry out command
; ----------------------------------------------------------------------------

atd4:	

;  new code - let logical or clear carry and then set carry if ah!=0
;	      and save a couple bytes while were at it.
				
		pop	ax
		;mov	ah, ds:74h	; [disk_status1]
		mov	ah, [disk_status1]
		or	ah, ah
		jz	short atd5
		stc
atd5:					
		pop	es
		pop	ds
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retf	2		; far return, dropping flags

; =============== S U B	R O U T	I N E ========================================

;***	setcmd - set up cmd_block for the disk operation
;
;	entry:	(ds) = bios data segment.
;		(es:bx) in seg:000x form.
;		other registers as in int 13h call
;	
;	exit:	cmd_block set up for disk read call.
;		control_byte set up for disk operation.
;		(al) = control byte modifier
;
;	sets the fields of cmd_block using the register contents
;	and the contents of the disk parameter block for the given drive.
;
;	warning: (ax) destroyed.
;		does direct calls to the at rom.

setcmd:		; proc near		
		;mov	ds:43h,	al	; [cmd_block+sec_cnt]
		; 16/10/2022
		mov	[cmd_block+sec_cnt], al
		;mov	byte ptr ds:48h, 20h ; [cmd_block+cmd_reg]
		mov	byte [cmd_block+cmd_reg], 20h ; assume function 02h (read)
		cmp	ah, 2
		jz	short setc1	; cmd_reg = 20h	if function 02h	(read)
		mov	byte [cmd_block+cmd_reg], 22h
		;mov	byte ptr ds:48h, 22h ; [cmd_block+cmd_reg]
					; cmd_reg = 22h	if function 0Ah	(read long)
setc1:					
		mov	al, cl
		and	al, 3Fh		; mask sector number
		;mov	ds:44h,	al	; [cmd_block+sec_num]
		;mov	ds:45h,	ch	; [cmd_block+cyl_low]
		mov	[cmd_block+sec_num], al ; mov [44h],al
		mov	[cmd_block+cyl_low], ch ; mov [45h],ch
		mov	al, cl
		shr	al, 6		; get two high bits of cylinder	number
		;mov	ds:46h,	al	; [cmd_block+cyl_high]
		mov	[cmd_block+cyl_high], al ; mov [46h],al
		mov	ax, dx
		shl	al, 4		; drive	number
		and	ah, 0Fh
		or	al, ah		; head number
		or	al, 0A0h	; set ecc and 512 bytes	per sector
		;mov	ds:47h,	al	; [cmd_block+drv_head]
		mov	[cmd_block+drv_head], al  ; mov [47h],al 
		push	es
		push	bx
		push	cs
		call	get_vec
		mov	ax, [es:bx+5]	; [es:bx+fdp_precomp]
			 		; write pre-comp from disk parameters
		shr	ax, 2
		;mov	ds:42h,	al	; [cmd_block+pre_comp]
		mov	[cmd_block+pre_comp], al ; mov [42h],al
					; only use low part
		mov	al, [es:bx+8]	; [es:bx+fdp_control]
					; control byte modifier
		pop	bx
		pop	es
		;mov	ah, ds:76h	; [control_byte]
		mov	ah, [control_byte] ; mov ah,[76h]
		and	ah, 0C0h	; keep disable retry bits	
		or	ah, al
		;mov	ds:76h,	ah
		mov	[control_byte], ah ; mov [76h],al
		retn

; =============== S U B	R O U T	I N E ========================================

;***	docmd - carry out read operation to at hard disk
;
;	entry:	(es:bx) = address for read in data.
;		cmd_block set up for disk read.
;
;	exit:	buffer at (es:bx) contains data read.
;		disk_status1 set to error code (0 if success).
;
;	
;
;	warning: (ax), (bl), (cx), (dx), (di) destroyed.
;		no check is made for dma boundary overrun.
;
;	effects: programs disk controller.
;		performs disk input.

docmd:		; proc near		
		mov	di, bx
		push	cs
		call	command
		jnz	short doc3
doc1:					
		push	cs
		call	waitt		; wait for controller to complete read
		jnz	short doc3
		mov	cx, 256		; 256 words per sector
		mov	dx, 1F0h	; hf_port
		cld			; string op goes up
		cli			; disable interrupts
					; (bug was forgetting this)

;	M062 -- some of these old machines have intermittent failures
;		when the read is done at full speed. Instead of using
;		a string rep instruction, we'll use a loop. There is
;		a slight performance hit, but it only affects these
;		very old machines with an exact date code match, and
;		it makes said machines more reliable
;
;M062	repz	insw		;read in sector

rsct_loop:				
		insw
		loop	rsct_loop
		sti
		; 16/10/2022
		test	byte [cmd_block+cmd_reg], 02h
		;test	byte ptr ds:48h, 2 ; [cmd_block+cmd_reg]
					; (ds =	40h)
		jz	short doc2	; no ecc bytes to read.
		push	cs
		call	wait_drq	; wait for controller to complete read
		jb	short doc3
		mov	cx, 4		; 4 bytes of ecc
		mov	dx, 1F0h	; hf_port
		cli
		rep insb		; read in ecc
		sti
doc2:					
		push	cs
		call	check_status
		jnz	short doc3	; operation failed
		;dec	byte ptr ds:43h	; [cmd_block+sec_cnt]
		dec	byte [cmd_block+sec_cnt]
		jnz	short doc1	; loop while more sectors to read
doc3:					
		retn

; =============== S U B	R O U T	I N E ========================================

;***	define where the rom routines are actually located
;	   in the buggy old AT BIOS that we might need to
;	   install a special level of int13 handler for

; 16/10/2022

romsegment 	equ 0F000h  ; segment
romcommand 	equ 2E1Eh   ; offset in romsegment
romwait		equ 2E7Fh   ; offset in romsegment
romwait_drq 	equ 2EE2h   ; offset in romsegment
romcheck_status equ 2EF8h   ; offset in romsegment
romcheck_dma 	equ 2F69h   ; offset in romsegment	
romget_vec	equ 2F8Eh   ; offset in romsegment
romfret		equ 0FF65h  ; far return in rom	

;***	get_vec - get pointer to hard disk parameters.
;
;	entry:	(dl) = low bit has hard disk number (0 or 1).
;
;	exit:	(es:bx) = address of disk parameters table.
;
;	uses:	ax for segment computation.
;
;	loads es:bx from interrupt table in low memory, vector 46h (disk 0)
;	or 70h (disk 1).
;	
;	warning: (ax) destroyed.
;		this does a direct call to the at rom.

get_vec:	; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2F8Eh
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romget_vec

; =============== S U B	R O U T	I N E ========================================

;***	command - send contents of cmd_block to disk controller.
;
;	entry:	control_byte 
;		cmd_block - set up with values for hard disk controller.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr for no error.
;
;
;	warning: (ax), (cx), (dx) destroyed.
;		does a direct call to the at rom.
;
;	effects: programs disk controller.

command:	; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2E1Eh
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romcommand

; =============== S U B	R O U T	I N E ========================================

;***	waitt - wait for disk interrupt
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr if no error.
;
;
;	warning: (ax), (bl), (cx) destroyed.
;		does a direct call to the at rom.
;		
;	effects: calls int 15h, function 9000h.

waitt:		; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2E7Fh
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romwait

; =============== S U B	R O U T	I N E ========================================

;***	wait_drq - wait for data request.
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		cy if error, nc if no error.
;
;	warning: (al), (cx), (dx) destroyed.
;		does a direct call to the at rom.

wait_drq:	; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2EE2h
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romwait_drq

; =============== S U B	R O U T	I N E ========================================

;***	check_status - check hard disk status.
;
;	entry:	nothing.
;
;	exit:	disk_status1 = error code.
;		nz if error, zr if no error.
;
;	warning: (ax), (cx), (dx) destroyed.
;		does a direct call to the at rom.

check_status:	; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2EF8h
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romcheck_status

; =============== S U B	R O U T	I N E ========================================

;***	check_dma - check for dma overrun 64k segment.
;
;	entry:	(es:bx) = addr. of memory buffer in seg:000x form.
;		cmd_block set up for operation.
;
;	exit:	disk_status1 - error code.
;		cy if error, nc if no error.
;
;	warning: does a direct call to the at rom.

check_dma:	; proc near		
		;push	0FF65h		; romfret ; far	return in rom
		;jmp	far ptr	0F000h:2F69h
		; 16/10/2022
		push	romfret		; far return in rom
		jmp	romsegment:romcheck_dma

;-----------------------------------------------------------------------------

endatrom:

; ----------------------------------------------------------------------------

;; M015 -- begin changes
;;
;; Certain old COMPAQ '286 machines have a bug in their ROM BIOS.
;; When Int13 is done with AH > 15h and DL >= 80h, they trash
;; the byte at DS:74h, assuming that DS points to ROM_DATA.
;; If our init code detects this error, it will install this
;; special Int13 hook through the same mechanism that was set
;; up for the IBM patch above. This code is also dynamically
;; relocated by MSINIT.

compaq_disk_io:
		cmp	ah, 15h		; compaq_disk_io proc far
					;
					; the following	label defines the end of the at	rom patch.
					; this is used at configuration	time.
					;
					; warning!!!
					; this code will be dynamically	relocated by msinit
		ja	short mebbe_hookit ; only deal with functions > 15h
no_hookit:				
		;jmp	cs:Old13
		; 16/10/2022
		jmp	far [cs:Old13]

; ----------------------------------------------------------------------------

mebbe_hookit:				
		cmp	dl, 80h
		jb	short no_hookit
		push	ds
		push	ax
		mov	ax, 40h
		mov	ds, ax
		pop	ax
		pushf
		;call	cs:Old13
		; 16/10/2022
		call	far [cs:Old13]
		pop	ds
		retf	2

; ----------------------------------------------------------------------------

end_compaq_i13hook: db 0			

; =============== S U B	R O U T	I N E ========================================

; CMOS Clock setting support routines used by MSCLOCK.		
; Warning!!! This code will be dynamically relocated by MSINIT.

daycnt_to_day:	; proc far

; entry: [daycnt] = number of days since 1-1-80
;
; return: ch - century in bcd
;	  cl - year in bcd
;	  dh - month in bcd
;	  dl - day in bcd

		; 16/10/2022		
		push	word [cs:daycnt] ; save daycnt
		cmp	word [cs:daycnt], 7305	; (365*20+(20/4))
					; # days from 1-1-1980 to 1-1-2000
		jnb	short century20
		mov	byte [cs:base_century], 19
		mov	byte [cs:base_year], 80
		jmp	short years
; ----------------------------------------------------------------------------
		
century20:				
		mov	byte [cs:base_century], 20
		mov	byte [cs:base_year], 0
		sub	word [cs:daycnt], 7305	; (365*20+(20/4))
					; adjust daycnt
years:					
		xor	dx, dx
		mov	ax, [cs:daycnt]
		mov	bx, 1461	; (366+365*3)
					; # of days in a Leap year block
		div	bx		; AX = # of leap block,	DX = daycnt
		mov	[cs:daycnt], dx	; save daycnt left
		mov	bl, 4
		mul	bl		; AX = # of years. Less	than 100
		add	[cs:base_year], al ; So, ah = 0. Adjust year
		inc	word [cs:daycnt]	; set daycnt to	1 base
		cmp	word [cs:daycnt], 366	; daycnt=remainder of leap year	bk
		jbe	short leapyear	; within 366+355+355+355 days.
		inc	byte [cs:base_year]	; if daycnt <= 366, then leap year
		sub	word [cs:daycnt], 366	; else daycnt--, base_year++ ;
		mov	cx, 3		; And next three years are normal
regularyear:				
		cmp	word [cs:daycnt], 365	; for(i=1; i>3 or daycnt <=365;	i++)
		jbe	short yeardone	; {if (daycnt >	365)
		inc	byte [cs:base_year]	;   { daycnt -=	365
		sub	word [cs:daycnt], 365	;   }
		loop	regularyear	; }
					;
					; should never fall through loop
leapyear:				
		mov	byte [cs:month_tab+1], 29 ; leap year.
					; change month table.
yeardone:				
		xor	bx, bx
		xor	dx, dx
		mov	ax, [cs:daycnt]
		;mov	si, offset month_tab
		mov	si, month_tab	; 19/10/2022
		mov	cx, 12
months:					
		inc	bl

		; !!! -- 16/10/2022 -- (if DS=CS, what for CS: prefixes are used !?)
		;mov	dl, [cs:si]
		; !!! -- 16/10/2022 -- (may be to keep code addrs as unchanged/fix!?)
		; ds = cs !? ((ofcourse ds must be same with cs here))
		;mov	dl, [si] ; 20/03/2019 (MSDOS 6.21 IO.SYS, BIOSDATA:14C0h)
		;mov	dl, [si] ; 16/10/2022 (MSDOS 5.0 IO.SYS, BIOSDATA:14C0h)
		
		mov	dl, [si] ; ?	; mov dl, [cs:si]
		cmp	ax, dx		; cmp daycnt for each month till fit
					; dh=0
		jbe	short month_done
		inc	si		; next month
		sub	ax, dx		; adjust daycnt
		loop	months		;
					; should never fall through loop
month_done:				
		mov	byte [cs:month_tab+1], 28
					; restore month table value
		mov	dl, bl
		mov	dh, [cs:base_year]
		mov	cl, [cs:base_century] ; al=day,dl=month,dh=year,cl=cntry
		call	far [cs:bintobcd]
		;call	cs:bintobcd	; convert "day"	to bcd
					; dl = bcd day,	al = month
		xchg	dl, al
		call	far [cs:bintobcd]
		;call	cs:bintobcd	; dh = bcd month, al = year
		xchg	dh, al
		call	far [cs:bintobcd]
		;call	cs:bintobcd	; cl = bcd year, al = century
		xchg	cl, al
		call	far [cs:bintobcd]
		;call	cs:bintobcd	; ch = bcd century
		mov	ch, al
		pop	word [cs:daycnt] ; restore original value
		retf

enddaycnttoday:	

; =============== S U B	R O U T	I N E ========================================

bin_to_bcd:	; proc far		; real time clock support

;convert a binary input in al (less than 63h or 99 decimal)
;into a bcd value in al. ah destroyed.	
		
		push	cx		
		aam			; al=high digit	bcd, ah=low digit bc
		mov	cl, 4
		shl	ah, cl		; mov the high digit to	high nibble
		or	al, ah
		pop	cx
		retf

; ----------------------------------------------------------------------------

; the k09 requires the routines for reading the clock because of the suspend/
; resume facility. the system clock needs to be reset after resume.

; the following routine is executed at resume time when the system
; powered on after suspension. it reads the real time clock and
; resets the system time and date, and then irets.

; warning!!! this code will be dynamically relocated by msinit.

int6c:					
		push	cs
		pop	ds
		pop	word [int6c_ret_addr]	; pop off return address
		pop	word [int6c_ret_addr+2]
		popf
		call	read_real_date	; get the date from the clock
		cli
		mov	[daycnt], si	; update dos copy of date
		sti
		call	read_real_time	; get the time from the	rtc
		cli
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		sti
		;jmp	int6c_ret_addr	; long jump
		; 16/10/2022
		jmp	far [int6c_ret_addr] ; long jump

; =============== S U B	R O U T	I N E ========================================

;   read_real_date reads real-time clock for date and returns the number
;   of days elapsed since 1-1-80 in si

read_real_date:	; proc near		
		push	ax
		push	cx
		push	dx
		xor	ah, ah		; throw	away clock roll	over
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		pop	dx
		pop	cx
		pop	ax
		push	ax
		push	bx
		push	cx
		push	dx
		mov	word [cs:daycnt2], 1
					; REAL TIME CLOCK ERROR	FLAG (+1 DAY)
		mov	ah, 4
		int	1Ah		; CLOCK	- READ DATE FROM REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: DL = day in BCD
					; DH = month in	BCD
					; CL = year in BCD
					; CH = century (19h or 20h)
		jnb	short read_ok
		jmp	r_d_ret
;-----------------------------------------------------------------------------

read_ok:				
		mov	[bin_date_time], ch
		mov	[bin_date_time+1], cl
		mov	[bin_date_time+2], dh
		mov	[bin_date_time+3], dl
		mov	word [cs:daycnt2], 2 ; READ OF R-T CLOCK SUCCESSFUL
		call	bcd_verify	; verify bcd values in range
		jb	short r_d_ret	;  some	value out of range
		mov	word [cs:daycnt2], 3
		call	date_verify
		jb	short r_d_ret
		mov	word [cs:daycnt2], 0
		call	in_bin
		mov	al, [bin_date_time+1]
		cbw
		cmp	byte [bin_date_time], 20 ; 20th century?
		jnz	short century_19 ; no
		add	ax, 100		; add in a century

century_19:				
		sub	ax, 80		; subtract off 1-1-80
		mov	cl, 4		; leap year every 4
		div	cl		; al= #	leap year blocks, ah= remainder
		mov	bl, ah		; save odd years
		cbw			; zero ah
		mov	cx, 1461	; 366+(3*365)
					; # of days in leap year blocks
		mul	cx
		mov	[cs:daycnt2], ax ; SAVE COUNT OF DAYS
		mov	al, bl		; get odd years	count
		cbw
		or	ax, ax
		jz	short leap_year
		mov	cx, 365		; days in year
		mul	cx
		add	[cs:daycnt2], ax ; ADD ON DAYS IN ODD YEARS
		jmp	short leap_adjustment ;	account	for leap year
					; possibly account for a leap day
;-----------------------------------------------------------------------------

leap_year:				
		cmp	byte [bin_date_time+2], 2 ; is	month february?
		jbe	short no_leap_adjustment ; jan or feb. no leap day yet.
leap_adjustment:			
		inc	word [cs:daycnt2] ; account for leap day
no_leap_adjustment:			
		mov	cl, [bin_date_time+3] ; get days of month
		xor	ch, ch
		dec	cx		; because of offset from day 1,	not day	0
		add	[cs:daycnt2], cx ; GET DAYS IN MONTHS PRECEEDING
		mov	cl, [bin_date_time+2] ; get month
		xor	ch, ch
		dec	cx		; january starts at offset 0
		shl	cx, 1		; word offset
		mov	si, month_table
		add	si, cx
		; 16/10/2022
		; ds must be same with cs here, if so..
		; what for cs: prefixes are used !?)
		; mov	ax, [cs:si]
		; mov	ax, [si] ; 16/10/2022 (MSDOS 5.0 IO.SYS - BIOSDATA:15D5h)
		mov	ax, [si]	; mov ax, [cs:si]
					; get #	days in	previous months
		add	[cs:daycnt2], ax
r_d_ret:				
		mov	si, [cs:daycnt2]
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn

;-----------------------------------------------------------------------------

r_t_retj:				
		xor	cx, cx
		xor	dx, dx
		jmp	short r_t_ret

; =============== S U B	R O U T	I N E ========================================

; read_real_time reads the time from the rtc. on exit, it has the number of
; ticks (at 18.2 ticks per sec.) in cx:dx.

read_real_time:	; proc near		
		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		jb	short r_t_retj
		mov	[bin_date_time], ch ; hours
		mov	[bin_date_time+1], cl ; minutes
		mov	[bin_date_time+2], dh ; seconds
		mov	byte [bin_date_time+3], 0 ; unused for time
		call	bcd_verify
		jb	short r_t_retj
		call	time_verify
		jb	short r_t_retj
		call	in_bin		; from bcd to bin
		mov	ch, [bin_date_time]
		mov	cl, [bin_date_time+1]
		mov	dh, [bin_date_time+2]
		mov	dl, [bin_date_time+3]
		; 16/10/2022
		; 17/09/2022
		; 31/05/2019
		call	far [ttticks] 
		;call	dword ptr ttticks ; note: indirect far call
					; cx:dx	= number of ticks
					; (at 18.2 ticks per sec.)
r_t_ret:				
		retn

; =============== S U B	R O U T	I N E =======================================

;   in_bin converts bin_date_time values from bcd to bin

in_bin:		; proc near		
		mov	al, [bin_date_time] ; century or hours
		call	bcd_to_bin
		mov	[bin_date_time], al
		mov	al, [bin_date_time+1] ; years or minutes
		call	bcd_to_bin
		mov	[bin_date_time+1], al
		mov	al, [bin_date_time+2] ; months or seconds
		call	bcd_to_bin
		mov	[bin_date_time+2], al
		mov	al, [bin_date_time+3] ; days (not used for time)
		call	bcd_to_bin
		mov	[bin_date_time+3], al
		retn

; =============== S U B	R O U T	I N E =======================================

;   bcd_to_bin converts two bcd nibbles in al (value <= 99.) to
;   a binary representation in al
;   ah is destroyed

bcd_to_bin:	; proc near		
		mov	ah, al
		and	al, 0Fh
		mov	cl, 4
		shr	ah, cl
		aad
		retn

; =============== S U B	R O U T	I N E ========================================

;   date_verify loosely checks bcd date values to be in range
;   in bin_date_time

date_verify:	; proc near		
		cmp	byte [bin_date_time], 20h ; century check
		ja	short date_error
		jz	short century_20 ; jmp in 21th century
		cmp	byte [bin_date_time], 19h ; century check
		;jb	short date_error
		; 12/12/2022
		jb	short date_err2
		cmp	byte [bin_date_time+1], 80h ; year check
		;jb	short date_error
		; 12/12/2022
		jb	short date_err2
century_20:				
		cmp	byte [bin_date_time+1], 99h ; year check
		ja	short date_error
		cmp	byte [bin_date_time+2], 12h ; month check
		ja	short date_error
		cmp	byte [bin_date_time+2], 0
		;jbe	short date_error
		jna	short date_error
		cmp	byte [bin_date_time+3], 31h ; day check
		ja	short date_error
		;cmp	byte [bin_date_time+3], 0 ; day check
		;;jbe	short date_error
		;jna	short date_error
		; 12/12/2022
		; cf=0
		;clc
		; 12/12/2022
		cmp	byte [bin_date_time+3], 1 ; day check
		retn
;-----------------------------------------------------------------------------

date_error:				
		stc
date_err2:
		retn

; =============== S U B	R O U T	I N E ========================================

; time_verify very loosely checks bcd date values to be in range
; in bin_date_time

time_verify:	; proc near		
		cmp	byte [bin_date_time], 24h ; hour check
		ja	short time_error
		cmp	byte [bin_date_time+1], 59h ; minute check
		ja	short time_error
		; 12/12/2022h
		;cmp	byte [bin_date_time+2], 59h ; second check
		;ja	short time_error
		;clc
		;retn
		; 12/12/2022
		cmp	byte  [bin_date_time+2], 5Ah	
time_error:
bv_error:	
		cmc	; cf=0 -> cf=1, cf=1 -> cf=0
		retn

; ----------------------------------------------------------------------------

;time_error:				
		;stc
		;retn

; =============== S U B	R O U T	I N E ========================================

;   bcd_verify checks values in bin_date_time to be valid
;   bcd numerals.  carry set if any nibble out of range

bcd_verify:	; proc near		
		mov	cx, 4		; 4 bytes to check
		mov	bx, bin_date_time
bv_loop:				
		mov	al, [bx]	; get a	bcd number (0..99)
		mov	ah, al
		and	ax, 0F00Fh	; 10's place in high ah, 1's in al
					; is 1's place in range?
		cmp	al, 10
		ja	short bv_error	; jmp out of range
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		shr	ah, 1
		and	ah, 0Fh		; get rid of any erroneous bits
		cmp	ah, 10		; is 10's place in range
		ja	short bv_error	; jmp out of range
		inc	bx		; next byte
		dec	cx
		jnz	short bv_loop
		clc			; set success flag
		retn
; ----------------------------------------------------------------------------

		; 12/12/2022
;bv_error:				
		;stc			; set error flag
		;retn

; ----------------------------------------------------------------------------

endk09:

; ----------------------------------------------------------------------------

;------------------------------------------------------------------------
;									:
;	System initialization						:
;									:
;	The entry conditions are established by the bootstrap		:
;	loader and are considered unknown. The following jobs		:
;	will be performed by this module:				:
;									:
;	1.	All device initialization is performed			:
;	2.	A local stack is set up and DS:SI are set		:
;		to point to an initialization table. Then		:
;		an inter-segment call is made to the first		:
;		byte of the dos 					:
;	3.	Once the dos returns from this call the ds		:
;		register has been set up to point to the start		:
;		of free memory. The initialization will then		:
;		load the command program into this area 		:
;		beginning at 100 hex and transfer control to		:
;		this program.						:
;									:
;------------------------------------------------------------------------

; 01/10/2022
; 08/01/2018 - Retro DOS v4.0

; drvfat must be the first location of freeable space!

; 22/12/2022
align 2
		;db 90h

; 30/12/2022
; (MSDOS 6.21 IO.SYS, BIOSDATA:16D6h)

drvfat:		dw 0			; drive	and fat	id of dos
bios_l:		dw 0			; first	sector of data (low word)
bios_h:		dw 0			; first	sector of data (high word)
doscnt:		dw 0			; how many sectors to read
fbigfat:	db 0			; flags	for drive
fatloc:		dw 0			; seg addr of fat sector
init_bootseg:	dw 0			; seg addr of buffer for reading boot record
rom_drv_num:	db 80h			; rom drive number
md_sectorsize:	dw 200h			; used by get_fat_sector proc.
temp_cluster:	dw 0			; used by get_fat_sector proc.
last_fat_sec_num: dw 0FFFFh		; used by get_fat_sector proc.

; the following two bytes are used to save the info returned by int 13, ah = 8
; call to determine drive parameters.

num_heads:	db 2			; number of heads returned by rom
sec_trk:	db 9			; sec/trk returned by rom
num_cyln:	db 40			; number of cylinders returned by rom
fakefloppydrv:	db 0			; if 1,	then no	diskette drives	in the system.

; ----------------------------------------------------------------------------

disktable:	dw 512,	256, 64, 0	; warning !!! old values
		dw 2048, 513, 112, 0
		dw 8192, 1026, 256, 0
		dw 32680, 2051,	512, 0	; warning !!! old values
		dw 65535, 4100,	1024, 0	; default disktable under
					; the assumption of total fat size <= 128 kb,
					; and the maximum size of fat entry = 16 bit.

disktable2:	dw 0, 32680, 2051, 512,	0 
					; for compatibility.
		dw 4, 0, 402h, 200h, 40h ; covers upto 134 mb media.
					; fbig = 40h
		dw 8, 0, 803h, 200h, 40h ; upto	268 mb
		dw 10h,	0, 1004h, 200h,	40h ; upto 536 mb
		dw 20h,	0, 2005h, 200h,	40h ; upto 1072	mb
		dw 40h,	0, 4006h, 200h,	40h ; upto 2144	mb
		dw 80h,	0, 8007h, 200h,	40h ; upto 4288	mb...
					
; ----------------------------------------------------------------------------

;******************************************************
;variables for mini disk initialization
;******************************************************

; 01/10/2022
; [ Note: Minidisk == logical dos drive (in extended dos partition) ] 

rom_minidisk_num: db 0			; temp variable	for phys unit
hnum:		db 0			; real number of hardfiles
last_dskdrv_table: dw dskdrvs		; index	into dskdrv table
end_of_bdss:	dw bdss			; offset value of the ending address
					; of bds table. needed to figure out
					; the dosdatasg address.
mini_hdlim:	dw 0			
mini_seclim:	dw 0

;end of mini disk init variables **********************

; ----------------------------------------------------------------------------
			
bios_date:	db '01/10/84',0 	; used for checking at rom bios	date.

; 13/12/2022
%if 0

;align 2
		db  90h	

; the following are the recommended bpbs for the media that we know of so far.

;struc bpbx
;   resw 1 ; 512
;   resb 1
;   resw 1 ; 1
;   resb 1 ; 2
;   resw 1
;   resw 1
;   resb 1
;   resw 1
;   resw 1
;   resw 1 ; 2
;   resw 1
;   resw 1 ; hidden sector high
;   resd 1 ; extended total sectors
;.size:
;endstruc

; 08/01/2019 - Retro DOS v4.0

; 20/04/2019

; 01/10/2022 - Retro DOS v4.0 (MSDOS 5.0) IO.SYS

; 09/12/2022
BPB48T:
;bpb48t:	; bpbx <512, 2, 1, 2, 112, 720, 0FDh, 2, 9, 2, 0, 0, 0, 0> 
		; 48 tpi diskettes	;
		dw	512		; physical sector size in bytes
		db	2		; sectors/allocation unit
		dw	1		; reserved sectors for dos
		db	2		; number of allocation tables
		dw	112		; number of directory entries
		dw	720 ; 2*9*40	; number of sectors (at 512 bytes each)
		db	0FDh		; media descriptor
		dw	2		; number of fat sectors
		dw	9		; sectors per track
		dw	2		; heads
		dw	0		; hidden sector count (low word)
		dw	0		; hidden sector (high)
		dw	0		; number of sectors (low)
		dw	0		; number of sectors (high)					

		db 90h
;align 2
BPB96T:
;bpb96t:	; bpbx <512, 1, 1, 2, 224, 2400, 0F9h, 7, 15, 2, 0, 0, 0, 0> 
		; 96 tpi diskettes	;
		dw	512		; physical sector size in bytes
		db	1		; sectors/allocation unit
		dw	1		; reserved sectors for dos
		db	2		; number of allocation tables
		dw	224		; number of directory entries
		dw	2400 ; 2*15*80	; number of sectors (at 512 bytes each)
		db	0F9h		; media descriptor
		dw	7		; number of fat sectors
		dw	15		; sectors per track
		dw	2		; heads
		dw	0		; hidden sector count (low word)
		dw	0		; hidden sector (high)
		dw	0		; number of sectors (low)
		dw	0		; number of sectors (high)

		db 90h
;align 2
BPB35:
;bpb35:		; bpbx <512, 2, 1, 2, 112, 1440, 0F9h, 3, 9, 2, 0, 0, 0, 0> 
		; 3.5" diskettes - 720 KB ;		
		dw	512		; physical sector size in bytes
		db	2		; sectors/allocation unit
		dw	1		; reserved sectors for dos
		db	2		; number of allocation tables
		dw	112		; number of directory entries
		dw	1440 ; 2*9*80	; number of sectors (at 512 bytes each)
		db	0F9h		; media descriptor
		dw	3		; number of fat sectors
		dw	9		; sectors per track
		dw	2		; heads
		dw	0		; hidden sector count (low word)
		dw	0		; hidden sector (high)
		dw	0		; number of sectors (low)
		dw	0		; number of sectors (high)

		db 90h
;align 2

;align 2
;BPB144:
;bpb144:	; Retro DOS v4.0 feature only !	; 1.44MB diskettes
;
;		dw	512		; physical sector size in bytes
;		db	1		; sectors/allocation unit
;		dw	1		; reserved sectors for dos
;		db	2		; number of allocation tables
;		dw	224		; number of directory entries
;		dw	2880 ; 2*18*80	; number of sectors (at 512 bytes each)
;		db	0F0h		; media descriptor
;		dw	9		; number of fat sectors
;		dw	18		; sectors per track
;		dw	2		; heads
;		dw	0		; hidden sector count (low word)
;		dw	0		; hidden sector (high)
;		dw	0		; number of sectors (low)
;		dw	0		; number of sectors (high)
;
;		db 90h
;align 2

BPB288:
;bpb288:	; bpbx <512, 2, 1, 2, 240, 5760, 0F0h, 9, 36, 2, 0, 0, 0, 0>
		; 3.5" diskettes - 2.88 MB ;	 
		dw	512		; physical sector size in bytes
		db	2		; sectors/allocation unit
		dw	1		; reserved sectors for dos
		db	2		; number of allocation tables
		dw	240		; number of directory entries
		dw	5760 ; 2*36*80	; number of sectors (at 512 bytes each)
		db	0F0h		; media descriptor
		dw	3		; number of fat sectors
		dw	9		; sectors per track
		dw	2		; heads
		dw	0		; hidden sector count (low word)
		dw	0		; hidden sector (high)
		dw	0		; number of sectors (low)
		dw	0		; number of sectors (high)

		db 90h			;
;align 2

%endif

; ----------------------------------------------------------------------------
					; align	2
; 09/12/2022
%if 0
bpbtable:	dw bpb48t		; 48tpi	drives
		dw bpb96t		; 96tpi	drives
		dw bpb35		; 3.5" drives
		dw bpb35		; unused 8" diskette
		dw bpb35		; unused 8" diskette
		dw bpb35		; used for hard	disk
		dw bpb35		; used for tape	drive
		dw bpb35		; FFOTHER
		dw bpb35		; ERIMO
		dw bpb288		; 2.88MB drive
		;
		;dw bpb144		; 1.44MB drive - Retro DOS v4.0 feature !
%endif

; 13/12/2022
%if 0
BPBTABLE:	dw BPB48T		; 48tpi	drives
		dw BPB96T		; 96tpi	drives
		dw BPB35		; 3.5" drives
		dw BPB35		; unused 8" diskette
		dw BPB35		; unused 8" diskette
		dw BPB35		; used for hard	disk
		dw BPB35		; used for tape	drive
		dw BPB35		; FFOTHER
		dw BPB35		; ERIMO
		dw BPB288		; 2.88MB drive
		;
		;dw BPB144		; 1.44MB drive - Retro DOS v4.0 feature !

%endif

; ----------------------------------------------------------------------------

;	entry point to call utility functions in Bios_Code. At this time,
;	  we aren't doing any A20 switching. During MSINIT time Bios_Code
;	  will not yet be moved to its final resting place, so we know
;	  it'll be low.
;
;	to use this function, do a "push cs" and load bp with the offset of
;	  the function you want to call in Bios_Code. This routine will
;	  push the address of a retf in Bios_Code onto the stack which
;	  will get executed when the utility function finishes. It will
;	  then transfer control to Bios_Code:bp using a couple of pushes
;	  and a retf

; 16/10/2022
;BC_RETF equ bc_retf - DOSBIOSEG_2C7h
; 09/12/2022
BC_RETF equ bc_retf

addr_of_bcretf:	;dw 0C8h		; dw bc_retf
					; 2C7h:0C8h = 70h:2638h
		dw BC_RETF

; ----------------------------------------------------------------------------

call_bios_code:	; proc far			
		push	word [cs:addr_of_bcretf] 
					; set up near return to far return
		push	word [cs:cdev+2] ; push Bios_Code segment
		push	bp		; save offset of utility function
		retf			; far jump to (DOS)BIOS code

; ----------------------------------------------------------------------------

flp_drvs	db 0			

; ----------------------------------------------------------------------------

; 01/10/2022 - Retro DOS v4.0 (MSDOS 5.0)

;-----------------------------------------------------------------------------
; entry point from boot sector
;-----------------------------------------------------------------------------

init:		; 27/12/2018
		; MSDOS 6.0 (MSINIT.ASM)
		;=============================================================
		;
		; entry from boot sector. the register contents are:
		;
		;   dl = int 13 drive number we booted from
		;   ch = media byte
		;   bx = first data sector on disk.
		;   ax = first data sector (high)
		;   di = sectors/fat for the boot media.

		; 07/04/2018
		;=============================================================
		; Retro DOS v2.0 - registers from FD Boot Sector 
                ; DL = [bsDriveNumber]
		; DH = [bsMedia]
		; AX = [bsSectors] ; Total sectors
		; DS = 0, SS = 0
		; BP = 7C00h
		
		cli

		; 21/12/2022
		; ds = 0 (?)
		;push	ax
		;xor	ax, ax
		;mov	ds, ax
		;pop	ax
	
; 02/10/2022
; ------------------------------------------------------------------------------
; Note: Retro DOS v4.0 Kernel does not use/contain MSLOAD part of IO.SYS (5.0)
; 	Because, Retro DOS v2 boot sector loads complete/entire MSDOS.SYS
;	(RETRODOS.SYS) Kernel file (IO.SYS & MSDOS.SYS together).
;	As result of boot sector ve init differences, Retro DOS init code (here)
;	moves kernel to segment 070h at first, then sets diskette parameters
;	at segment 50h (while MSDOS 5.0 boot sector sets this).
; ------------------------------------------------------------------------------

; msload will check the extended boot record and set ax, bx accordingly.

;	msload passes a 32 bit sector number hi word in ax and low in bx
;	save this in cs:bios_h and cs:bios_l. this is for the start of
;	data sector of the bios.

		mov	[cs:bios_h], ax	; (start of) dos bios (IO.SYS) data sector
		mov	[cs:bios_l], bx

; with the following information from msload, we don't need the
;     boot sector any more.-> this will solve the problem of 29 kb size
;     limitation of msbio.com file.

		push	cs		; Save a peck of interrupt vectors...
		pop	es
		push	cx
		push	di

		; 21/12/2022
		; ds = 0 (?)
		; 24/12/2022
		; ds = cs
		xor	cx, cx
		mov	ds, cx
		; ds = 0

		mov	cl, 5
		;mov	cx, 5		; NUMROMVECTORS
					; no. of rom vectors to	be saved
		;mov	si, offset RomVectors ; point to list of int vectors
		mov	si, RomVectors
next_int_:		
		cs	; 16/10/2022
		lodsb		
		;lods	byte ptr cs:[si] ; cs lodsb
		cbw			; ax = interrupt number
		shl	ax, 1
		shl	ax, 1		; int no * 4
		mov	di, ax		; interrupt vector address
		xchg	si, di		; rombios interrupt vector address in si
					; saving address in di
		lodsw			; movsw
		stosw
		lodsw			; movsw
		stosw			; save the vector
		xchg	si, di
		loop	next_int_
		pop	di
		pop	cx

; we need to save int13 in two places in case we are running on an at.
; on ats we install the ibm supplied rom_bios patch which hooks
; int13 ahead of orig13. since int19 must unhook int13 to point to the
; rom int13 routine, we must have that rom address also stored away.

		; 21/12/2022
		;mov	ax, [cs:Old13]	; save old13 in orig13 also
		;mov	[cs:Orig13], ax
		;mov	ax, [cs:Old13+2]
		;mov	[cs:Orig13+2], ax

		; 16/10/2022
		mov	word [13h*4], block13
		;mov	word ptr ds:4Ch, offset	block13	; 13h*4
					; set up int 13	for new	action
		mov	[13h*4+2], cs
		;mov	word ptr ds:4Eh, cs ; 13h*4+2
		mov	word [15h*4], Int15
		;mov	word ptr ds:54h, offset	Int15 ;	15h*4
					; set up int 15	for new	action
		mov	[15h*4+2], cs
		;mov	word ptr ds:56h, cs ; 15h*4+2
		mov	word [19h*4], int19
		;mov	word ptr ds:64h, offset	int19 ;	19h*4
					; set up int 19	for new	action
		mov	[19h*4+2], cs
		;mov	word ptr ds:66h, cs ; 19h*4+2

		; 21/12/2022
		push	cs
		pop	ds
		
		mov	ax, [Old13]	; save old13 in orig13 also
		mov	[Orig13], ax
		mov	ax, [Old13+2]
		mov	[Orig13+2], ax
					; ;
		sti
		int	11h		; EQUIPMENT DETERMINATION
					; Return: AX = equipment flag bits

; we have to support a system that does not have any diskette
; drives but only hardfiles. this system will ipl from the hardfile.
; if the equipment flag bit 0 is 1, then the system has diskette drive(s).
; otherwise, the system has only hardfiles.
;
; important thing is that still, for compatibility reason, the drive letter
; for the hardfiles start from "c".  so, we still need to allocate dummy bds
; drive a and drive b. at sysinit time, we are going to set cds table entry
; of dpb pointer for these drives to 0, so any user attempt to access this
; drives will get "invalid drive letter ..." message. we are going to
; establish "fakefloppydrv" flag. ***sysinit module should call int 11h to
; determine whether there are any diskette drivers in the system or not.!!!***

; check the register returned by the equipment determination interrupt
; we have to handle the case of no diskettes in the system by faking
; two dummy drives.
;
; if the register indicates that we do have floppy drives we don't need
; to do anything special.
;
; if the register indicates that we don't have any floppy drives then
; what we need to do is set the fakefloppydrv variable, change the
; register to say that we do have floppy drives and then go to execute
; the code which starts at notsingle. this is because we can skip the
; code given below which tries to find if there are one or two drives
; since we already know about this.

		; 12/12/2022
		test	al, 1
		;test	ax, 1		; floppy drives	present	?
		jnz	short normalfloppydrv ;	yes.

; Some ROM BIOSs lie that there are no floppy drives. Lets find out
; whether it is an old ROM BIOS or a new one
;
; WARNING !!!
;
; This sequence of code is present in SYSINIT1.ASM also. Any modification
; here will require an equivalent modification in SYSINIT1.ASM also

		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	es
		mov	ah, 8
		mov	dl, 0
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jb	short _gdskp_error
		;mov	[cs:flp_drvs], dl
		; 21/12/2022
		; ds = cs
		mov	[flp_drvs], dl
_gdskp_error:				
		pop	es
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short normalfloppydrv
					; if error it is an old ROM BIOS
					; so, lets assume that ROM BIOS lied

		; 21/12/2022
		;cmp	byte [cs:flp_drvs], 0 ; number of drvs == 0?
		;jz	short _set_fake_flpdrv
		;mov	al, [cs:flp_drvs]
		mov	al, [flp_drvs]
		or	al, al		; number of drvs == 0?
		jz	short _set_fake_flpdrv

		;dec	al		; make it zero based
		; 18/12/2022
		dec	ax
		jmp	short got_num_flp_drvs
; ----------------------------------------------------------------------------

_set_fake_flpdrv:
		; 21/12/2022
		mov	ax, 1			
		mov	[fakefloppydrv], al ; 1
		;mov	byte [cs:fakefloppydrv], 1
		;			; we don't have any floppy drives.
		;mov	ax, 1
		jmp	short settwodrive ; well then set it for two drives!
; ----------------------------------------------------------------------------

normalfloppydrv:			; yes, bit 0 is 1.			
		rol	al, 1		; there	exist floppy drives.
		rol	al, 1		; put bits 6 & 7 into bits 0 & 1
got_num_flp_drvs:			
		;and	ax, 3		; only look at bits 0 &	1
		; 18/12/2022
		and	al, 3
		jnz	short notsingle	; zero means single drive system
		inc	ax		; pretend it's a two drive system
settwodrive:				; set this to two fakedrives
		; 21/12/2022
		; ds = cs
		inc	byte [single]
		;inc	byte [cs:single] ; remember this
notsingle:				
		inc	ax		; ax has number	of drives, 2-4
					; is also 0 indexed boot drive if we
					; booted off hard file
		mov	cl, al		; ch is	fat id,	cl # floppies

; 16/10/2022
; MSDOS 3.3 - "MSEQU.INC" (24/07/1987)
INITSPOT EQU	534h	; IBM wants 4 zeros here
BRKADR	 EQU	1BH * 4	; 6CH, 1BH break vector address
TIMADR	EQU	1CH * 4	; 70H, 1CH timer interrupt
DSKADR	EQU	1EH * 4	; address of ptr to disk parameters
SEC9	EQU	522h	; address of disk parameters
CHROUT	EQU	29h
LSTDRV	EQU     504h

; determine whether we booted from floppy or hard disk...

		test	dl, 80h		; boot from floppy ?
		jnz	short gothrd	; no.
		xor	ax, ax		; indicate boot	from drive a
gothrd:					
		xor	dx, dx		; ax = 0-based drive we	booted from
					; bios_l, bios_h set.
					; cl = number of floppies including fake one
					; ch = media byte
		cli
		mov	ss, dx		; set stack segment and stack pointer
		mov	sp, 700h
		sti
		push	cx ; *		; save number of floppies and media byte
		mov	ah, ch		; FAT ID to AH
		push	ax ; **		; save boot drive number and media byte
		
; let model_byte, secondary_model_byte be set here!!!

		mov	ah, 0C0h
		int	15h		; SYSTEM - GET CONFIGURATION (XT after 1/10/86,AT mdl 3x9,CONV,XT286,PS)
		jb	short no_rom_system_conf ; just	use Model_Byte
		cmp	ah, 0
		jnz	short no_rom_system_conf

		; 21/12/2022
		; ds = cs
		mov	al, [es:bx+2]	; [es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
		mov	[model_byte], al
		;mov	[cs:model_byte], al
					; get/save model byte
		mov	al, [es:bx+3]	; [es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
		mov	[secondary_model_byte], al
		;mov	[cs:secondary_model_byte], al
					; get/save secondary model byte
		jmp	short turn_timer_on
;-----------------------------------------------------------------------------

no_rom_system_conf:			
		mov	si, 0FFFFh
		mov	es, si
		; 21/12/2022
		mov	al, [es:0Eh]	; get model byte (from 0FFFFh:0Eh)
		mov	[model_byte], al
		;mov	[cs:model_byte], al ; save model byte
turn_timer_on:				
		mov	al, 20h	; ' '   ; turn on the timer
		out	20h, al		; Interrupt controller,	8259A.
					; AKPORT

; some olivetti m24 machines have an 8530 serial communications
; chip installed at io address 50h and 52h. if we're running
; on one of those, we must inhibit the normal aux port initialization

		; 21/12/2022
		; ds = cs
		cmp	byte [model_byte], 0
		;cmp	byte [cs:model_byte], 0 ; next to last	byte in	rom bios
		jnz	short not_olivetti_m24 ; skip for all other machines
					; (except olivetti m24)
		in	al, 66h		; is 8530 installed?
		test	al, 20h
		jz	short not_olivetti_m24 ; we're done if not
		mov	al, 0Fh		; double check
		out	50h, al
		in	al, 50h
		test	al, 1		; this test was	copied from olivetti
		jz	short skip_aux_port_init ; take	this branch if 8530 installed

not_olivetti_m24:			
		mov	al, 3		; init com4
		call	aux_init
		mov	al, 2		; init com3
		call	aux_init
		mov	al, 1		; init com2
		call	aux_init
		xor	al, al		; init com1
		call	aux_init

skip_aux_port_init:			
		mov	al, 2		; init lpt3
		call	print_init
		mov	al, 1		; init lpt2
		call	print_init
		xor	al, al		; init lpt1
		call	print_init
		
		xor	dx, dx ; 0
		mov	ds, dx		; to initialize	print screen vector
		mov	es, dx
		xor	ax, ax
		; 16/10/2022
		mov	di, INITSPOT	; 0534h
		;mov	di, 534h	; INITSPOT (0000h:0534h)
					; IBM wants 4 zeros here
		stosw
		stosw
		mov	ax, cs		; fetch	segment
		mov	word [BRKADR], cbreak
		;mov	word ptr ds:6Ch, offset	cbreak ; [BRKADR]
					; break	entry point
		mov	[BRKADR+2], ax		
		;mov	ds:6Eh,	ax	; vector for break
		mov	word [CHROUT*4], outchr
		;mov	word ptr ds:0A4h, offset outchr	; [CHROUT*4]
		mov	[CHROUT*4+2], ax
		;mov	ds:0A6h, ax	; [CHROUT*4+2]
		mov	di, 4
		mov	bx, intret ; 19/10/2022
		;mov	bx, offset intret ; intret (cs:intret)
					; will initialize rest of interrupts
		xchg	ax, bx
		stosw			; location 4
		xchg	ax, bx		; cs:
		stosw			; int 1	; location 6
		add	di, 4
		xchg	ax, bx
		stosw			; location 12
		xchg	ax, bx		; cs:
		stosw			; int 3	; location 14
		xchg	ax, bx
		stosw			; location 16
		xchg	ax, bx		; cs:
		stosw			; int 4	; location 18
		mov	[0500h], dx
		;mov	ds:500h, dx	; set print screen & break = 0
		mov	[LSTDRV], dx	; [0504h]
		;mov	ds:504h, dx	; clean	out last drive spec

; we need to initalize the cs:motorstartup variable from the disk
; parameter table at sec9. the offsets in this table are defined in
; the disk_parms struc in msdskprm.inc. 2 locs

		mov	al, [SEC9+0Ah]	; 16/10/2022 
		;mov	al, ds:52Ch	; [SEC9+DISK_PARMS.DISK_MOTOR_STRT]
					; [522h+0Ah]
		; 21/12/2022
		; ds = 0

		mov	[cs:motorstartup], al
		cmp	byte [cs:model_byte], 0FDh ; is this an old rom?
		jb	short no_diddle	; no
		mov	word [SEC9+09h], 20Fh
		;mov	word ptr ds:52Bh, 20Fh ; [SEC9+DISK_PARMS.DISK_HEAD_STTL], 0200h+NORMSETTLE
					; set head settle and motor start on pc-1 pc-2 pc-xt hal0
		mov	byte [SEC9+0], 0DFh
		;mov	byte ptr ds:522h, 0DFh ; [SEC9+DISK_PARMS.DISK_SPECIFY_1]
					;  set 1st specify byte	on pc-1	pc-2 pc-xt hal0
no_diddle:				
		int	12h		; MEMORY SIZE -
					; Return: AX = number of contiguous 1K blocks of memory
		mov	cl, 6
		shl	ax, cl		; convert memory size to 16-byte blocks	(segment no.)
		
		; 21/12/2022
		;pop	cx
		;mov	[cs:drvfat], cx ; save drive to load dos, and fat id
		
		push	ax ; ***	; save real top	of memory

;M068 - BEGIN
;------ Check if an RPL program is present at TOM and do not tromp over it

		; 21/12/2022
		; ds = 0
		;push	ds
		;push	bx		; pushes not required but since this
		;			; happens to be a last minute change
		;			; & since it is only init code.
		;xor	bx, bx
		;mov	ds, bx

		;mov	bx, ds:0BCh	; [2Fh*4]
		mov	bx, [2Fh*4]
		;mov	ds, word ptr ds:0BEh ; [2Fh*4+2]
		mov	ds, [2Fh*4+2]
		cmp	word [bx+3], 'RP' ; 'RPL'
		;cmp	word ptr [bx+3], 'PR' ; 'RPL'
		jnz	short SkipRPL
		cmp	byte [bx+5], 'L'
		;cmp	byte ptr [bx+5], 'L'
		jnz	short SkipRPL
		mov	dx, ax		; get TOM into DX
		mov	ax, 4A06h	; (multMULT shl	8) + multMULTRPLTOM
		int	2Fh		; Get new TOM from any RPL
		mov	ax, dx
SkipRPL:
		; 21/12/2022				
		;pop	bx
		;pop	ds
;M068 - END
		; 21/12/2022
		push	cs
		pop	ds

		sub	ax, 64		; room for fatloc segment. (1 kb buffer)
		; 21/12/2022
		mov	[fatloc], ax
		;mov	[cs:fatloc], ax	; location to read fat
		
		sub	ax, 64
		mov	[init_bootseg], ax ; 21/12/2022
		;mov	[cs:init_bootseg], ax
		pop	ax ; ***	; get back real top of memory for

		; 21/12/2022
		pop	cx ; **
		mov	[drvfat], cx	; save drive to load dos, and fat id

		;mov	dx, 46Dh	; SYSINIT segment
		mov	dx, SYSINITSEG	; 17/10/2022
		mov	ds, dx

; set pointer to resident device driver chain

		; 17/10/2022
		mov	word [DEVICELIST], res_dev_list
		;mov	word [273h], res_dev_list
		;;mov	word ptr ds:273h, offset res_dev_list
					; [SYSINIT+DEVICE_LIST]
		mov	[DEVICELIST+2], cs		
		;mov	[275h], cs
		;;mov	word ptr ds:275h, cs ; [SYSINIT+DEVICE_LIST+2]

		mov	[MEMORYSIZE], ax
		;mov	[292h], ax
		;;mov	ds:292h, ax	; [SYSINIT+MEMORY_SIZE]

		inc	cl
		mov	[DEFAULTDRIVE], cl
		;mov	[296h], cl
		;;mov	ds:296h, cl	; [SYSINIT+DEFAULT_DRIVE]

		mov	word [CURRENTDOSLOCATION], DOSLOADSEG
		;mov	word [271h], 83Fh ; (MSDOS.SYS segment)
		;;mov	word ptr ds:271h, 83Fh ; [SYSINIT+CURRENT_DOS_LOCATION]
					; dos_load_seg

; important: some old ibm hardware generates spurious int 0F's due to bogus
; printer cards. we initialize this value to point to an iret only if
;
; 1) the original segment points to storage inside valid ram.
;
; 2) the original segment is 0F000:xxxx

		;;mov	ax, 46Dh	; SYSINIT segment
		;mov	ax, SYSINITSEG	; 17/10/2022
		;mov	es, ax
		; 21/12/2022
		mov	es, dx ; SYSINITSEG
		xor	cx, cx ; 0
		mov	ds, cx		; segment 0
		;mov	ax, ds:3Eh	; [0Fh*4+2]
		mov	ax, [0Fh*4+2]	; segment for INT 0Fh
		; 18/10/2022
		cmp	ax, [es:MEMORYSIZE] ; es:292h
		;cmp	ax, es:292h	; [ES:SYSINIT+MEMORY_SIZE]  ; (condition 1)
		jbe	short resetintf
		cmp	ax, 0F000h	; (condition 2)
		jnz	short keepintf
resetintf:	
		mov	word [0Fh*4], intret			
		;mov	word ptr ds:3Ch, offset	intret ; [0Fh*4]
		mov	word [0Fh*4+2], cs
		;mov	word ptr ds:3Eh, cs ; [0Fh*4+2]
keepintf:				
; end important

; 17/10/2022
; 28/12/2018 - Retro DOS v4.0

; (MSDOS 6.0, MSINIT.ASM, 1991)
;
; we will check if the system has ibm extended keyboard by
; looking at a byte at 40:96. if bit 4 is set, then extended keyboard
; is installed, and we are going to set keyrd_func to 10h, keysts_func to 11h
; for the extended keyboard function. use cx as the temporary register.

		; 21/12/2022
		; ds = 0, cx = 0
		;xor	cx, cx
		;mov	ds, cx
		
		mov	cl, [496h]	; get keyboard flag

		; 21/12/2022
		push	cs
		pop	ds

		test	cl, 10h		; extended keyboard ?
		jz	short org_key	; no, original keyboard

		; 21/12/2022
		; ds = cs
		mov	byte [keyrd_func], 10h ; extended keyboard
		mov	byte [keysts_func], 11h
		;mov	byte [cs:keyrd_func], 10h ; extended keyboard
		;mov	byte [cs:keysts_func], 11h
					; change for extended keyboard functions
org_key:

; 02/06/2018 - Retro DOS v3.0

;**************************************************************
;	will initialize the number of drives
;	after the equipment call (int 11h) bits 6&7 will tell
;	the indications are as follows:
;
;	bits	7	6	drives
;		0	0	1
;		0	1	2
;		1	0	3
;		1	1	4
;**************************************************************
				
		; 21/12/2022
		; ds = cs
		;push	cs
		;pop	ds
		;push	cs
		;pop	es
		
		call	cmos_clock_read	; If cmos clock	exists,
					; then set the system time according to	that.
					; also,	reset the cmos clock rate.
		; 18/10/2022
		;mov	word ptr BData_start, offset harddrv ;
					; set up pointer to hdrive
		; 02/10/2022
		mov	word [hdrv_pat], harddrv 
					
		pop	ax ; *		; number of floppies and FAT ID
		xor	ah, ah		; chuck	fat id byte
		mov	[drvmax], al	; remember which drive is hard disk
		mov	[dsktnum], al	; and set initial number of drives
		shl	ax, 1
		add	[last_dskdrv_table], ax

		mov	dl, 80h
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jc	short enddrv
		mov	[hnum], dl
enddrv:
		; 21/12/2022
		push	cs
		pop	es

; scan the list of drives to determine their type. we have three flavors of
; diskette drives:
;
;   48tpi drives    we do nothing special for them
;   96tpi drives    mark the fact that they have changeline support.
;   3.5"  drives    mark changeline support and small.
;
; the following code uses registers for certain values:
;
;   dl - physical drive
;   ds:di - points to current bds
;   cx - flag bits for bds
;   dh - form factor for the drive (1 - 48tpi, 2 - 96tpi, 3 - 3.5" medium)
					
		xor	dl, dl

		; 21/12/2022
		; ds = cs
		;push	cs
		;pop	ds

		mov	byte [eot], 9
		mov	di, start_bds 	; if we	are faking floppy drives we need
					; to set aside two bdss	for the	two fake floppy	drives

; 02/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS)
; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.0, MSINIT.ASM)

; check to see if we are faking floppy drives. if not we don't
; do anything special. if we are faking floppy drives we need
; to set aside two bdss for the two fake floppy drives. we
; don't need to initalise any fields though. so starting at start_bds
; use the link field in the bds structure to go to the second bds
; in the list and initalise it's link field to -1 to set the end of
; the list. then jump to the routine at dohard to allocate/initialise
; the bds for harddrives.

		cmp	byte [fakefloppydrv], 1
		jnz	short loop_drive
		mov	di, [di]	; [di+BDS.link]
					; di <-	first bds link
		mov	di, [di]	; [di+BDS.link]
					; di <-	second bds link
		mov	word [di], 0FFFFh ; set end of link
		jmp	dohard		; allocate/initialise bds for harddrives
;-----------------------------------------------------------------------------

loop_drive:				
		cmp	dl, [drvmax]
		jb	short got_more
		jmp	done_drives
;-----------------------------------------------------------------------------

got_more:				
		xor	cx, cx		; zero all flags
		mov	di, [di]	; [di+BDS.link]
					; get next bds
		mov	dh, 0		; ff48tpi
					; set form factor to 48	tpi
		mov	byte [num_cyln], 40 ; 40 tracks per	side
		
		; 21/12/2022
		;push	ds
		push	di
		push	dx
		push	cx
		push	es ; es=cs=ds ; 21/12/2022
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		jc	short noparmsfromrom

; if cmos is bad, it gives es,ax,bx,cx,dh,di=0. cy=0.
; in this case, we are going to put bogus informations to bds table.
; we are going to set ch=39,cl=9,dh=1 to avoid divide overflow when
; they are calculated at the later time. this is just for the diagnostic
; diskette which need msbio,msdos to boot up before it sets cmos.
; this should only happen with drive b.

		cmp	ch, 0		; if ch=0, then	cl,dh=0	too.
		jnz	short pfr_ok
		;mov	ch, 39		; rom gave wrong info.
		;mov	cl, 9		; let's default to 360k.
		; 21/12/2022
		mov	cx, 2709h
		mov	dh, 1
pfr_ok:					
		inc	dh		; make number of heads 1-based
		inc	ch		; make number of cylinders 1-based
		mov	[num_heads], dh	; save parms returned by rom
		and	cl, 3Fh
		mov	[sec_trk], cl
		mov	[num_cyln], ch	; assume less than 256 cylinders!!

; make sure that eot contains the max number of sec/trk in system of floppies

		cmp	cl, [eot]	; may set carry
		;jbe	short eot_ok
		; 09/12/2022
		jne	short eotok
		mov	[eot], cl
;eot_ok:					
eotok:
		pop	es ; es=cs=ds ; 21/12/2022
		pop	cx
		pop	dx
		pop	di
		; 21/12/2022
		;pop	ds

; Check	for presence of	changeline

		mov	ah, 15h
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jc	short changeline_done
		cmp	ah, 2		; check	for presence of	changeline
		jnz	short changeline_done

; we have a drive with change line support.

		or	cl, 2		; fchangeline
					; signal type
		mov	byte [fhave96], 1 ; remember that we have 96tpi disks

; we now try to set up the form factor for the types of media that we know
; and can recognise. for the rest, we set the form factor as "other".

changeline_done:			
		cmp	byte [num_cyln], 40
		jnz	short try_80
		cmp	byte [sec_trk], 9
		jbe	short nextdrive
gotother:				
		mov	dh, 7		; ffOther
					; we have a "strange" medium
		jmp	short nextdrive
;-----------------------------------------------------------------------------

; 80 cylinders and 9 sectors/track => 720 kb device
; 80 cylinders and 15 sec/trk => 96 tpi medium

try_80:					
		cmp	byte [num_cyln], 80
		jnz	short gotother
		mov	dh, 9		; ff288
					; assume 2.88 MB drive
		cmp	byte [sec_trk], 36 ; is it	?
		jz	short nextdrive	; yeah,	go update

		; 12/05/2019 (ff144 type will not be used -compatibility problem-)
		; 08/01/2018 - Retro DOS v4.0 feature only ! for 1.44MB diskettes
		;mov	dh, ff144
		;cmp	byte [sec_trk], 18
		;je	short nextdrive

		cmp	byte [sec_trk], 15
		jz	short got96
		
		cmp	byte [sec_trk], 9
		jnz	short gotother
		
		mov	dh, 2		; ffSmall
		jmp	short nextdrive
; ----------------------------------------------------------------------------

got96:					
		mov	dh, 1		; ff96tpi
		jmp	short nextdrive
; ----------------------------------------------------------------------------

; we have an old rom, so we either have a 48tpi or 96tpi drive. if the drive
; has changeline, we assume it is a 96tpi, otherwise we treat it as a 48tpi.

noparmsfromrom:				
		pop	es ; es=cs=ds ; 21/12/2022
		pop	cx
		pop	dx
		pop	di
		; 21/12/2022
		;pop	ds

		mov	ah, 15h
		int	13h		; DISK - DISK -	GET TYPE (AT,XT2,XT286,CONV,PS)
					; DL = drive ID
					; Return: CF set on error, AH =	disk type (3 = hard drive)
					; CX:DX	= number of sectors on the media
		jc	short nextdrive

		cmp	ah, 2		; is there changeline?
		jnz	short nextdrive

		or	cl, 2
		mov	byte [fhave96], 1 ; fchangeline
		mov	byte [num_cyln], 80
		mov	dh, 1
		mov	al, 15
		cmp	al, [eot]
		jbe	short nextdrive
		mov	[eot], al
; ----------------------------------------------------------------------------

nextdrive:				
		or	cl, 20h		; fi_own_physical
					; set this true	for all	drives
		mov	bh, dl		; save int13 drive number

; we need to do special things if we have a single drive system and are setting
; up a logical drive. it needs to have the same int13 drive number as its
; counterpart, but the next drive letter. also reset ownership flag.
; we detect the presence of this situation by examining the flag single for the
; value 2.
		cmp	byte [single], 2
		jnz	short not_special
		dec	bh		; int13	drive number same for logical drive
		xor	cl, 20h		; reset	ownership flag for logical drive
not_special:

; the values that we put in for BDS_RBPB.BPB_HEADS and
; BDS_RBPB.BPB_SECTORSPERTRACK will only remain if the
; form factor is of type "ffother".
				
		xor	ax, ax		; fill BDS for drive
		mov	al, [num_heads]
		mov	[di+36h], ax	; [di+BDS.rheads]
		mov	al, [sec_trk]
		mov	[di+34h], ax	; [di+BDS.rsecpertrack]
		mov	[di+23h], cx	; [di+BDS.flags]
		mov	[di+22h], dh	; [di+BDS.formfactor]
		mov	[di+5],	dl	; [di+BDS.drivelet]
		mov	[di+4],	bh	; [di+BDS.drivenum]
		mov	bl, [num_cyln]
		mov	[di+25h], bl	; [di+BDS.cylinders]
		cmp	byte [single], 1 ; Special case for single drive system
		jnz	short no_single
		mov	byte [single], 2 ; Don't forget we have
					; single drive system
		; 18/12/2022
		or	cl, 10h
		;or	cx, 10h		; fi_am_mult
					; set that this	is one of several drives
		or	[di+23h], cx	; [di+BDS.flags]
					; save flags
		mov	di, [di]	; [di+BDS.link]
					; move to next BDS in list
		inc	dl		; add a	number
		jmp	short nextdrive	; Use same info	for BDS	as previous
; ----------------------------------------------------------------------------

no_single:				
		;inc	dl
		; 18/12/2022
		inc	dx
		jmp	loop_drive
; ----------------------------------------------------------------------------

done_drives:	
		;mov	word [di+BDS.link], -1			
		mov	word [di], -1	; set link to null

; set up all the hard drives in	the system

dohard:					
		mov	dh, [hnum]
		or	dh, dh		; done if no hardfiles
		jz	short static_configure
		mov	dl, 80h
dohard1:				
		push	dx
		mov	di, [end_of_bdss]
		mov	bl, [drvmax]
		mov	bh, 0		; first	primary	partition (or active)
		call	sethard
		jb	short hardfile_err
		call	dmax_check	; error	if already 26 drives
		jnb	short hardfile_err
		call	xinstall_bds	; insert new bds into linked list
hardfile_err:				
		pop	dx
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohard1

; end of physical drive	initialization

; *** do not change the position of the following statement.
; *** domini routine will use [drvmax] value for the start of the logical
; *** drive number of mini disk(s).
					
		call	domini		; for setting up mini disks, if found

; -- begin added section

		mov	dh, [hnum]	; we already know this is >0
		mov	dl, 80h
dohardx1:				
		mov	bh, 1		; do all subsequent primary partitions
dohardx2:				
		push	dx
		push	bx
		mov	di, [end_of_bdss]
		mov	bl, [drvmax]
		call	sethard
		jb	short dohardx4	; move to next hardfile	if error
		call	dmax_check	; make sure <=26 drives
		jnb	short dohardx4	; skip if error
		call	xinstall_bds	; insert new bds into linked list
		pop	bx		; get partition	number
		pop	dx		; restore physical drive counts
		inc	bh
		jmp	short dohardx2	; keep looping until we	fail
; ----------------------------------------------------------------------------

dohardx4:				
		pop	bx		; unjunk partition number from stack
		pop	dx		; restore physical drive counts
		inc	dl		; next hard drive
		dec	dh
		jnz	short dohardx1

; -- end changed section

;******************************************************************************
; if more than 2 diskette drives on the system, then it is necessary to remap
; the bds chain to adjust the logical drive num (drive letter) with greater
; than two diskette drives
;
; new scheme:	if more than 2 disktte drives, first map the bds structure
;		as usual and then rescan the bds chain to adjust the  drive
;		letters. to do this, scan for disk drives and assign logical
;		drive number starting from 2 and then rescan diskette drives
;		and assign next to the last logical drive number of last disk
;		drive to the 3rd and 4th diskette drives.
;******************************************************************************

		cmp	byte [dsktnum], 2 ; >2 diskette drives
		;jbe	short static_configure ; no - no need for remapping
		jbe	short no_remap
		call	remap		; remap	bds chain to adjust driver letters
no_remap:

; End of drive initialization.

; ----------------------------------------------------------------------------

;we now decide, based on the configurations available so far, what
;code or data we need to keep as a stay resident code. the following table
;shows the configurations under consideration. they are listed in the order
;of their current position memory.
;
;configuration will be done in two ways:
;
;first, we are going to set "static configuration". static configuration will
;consider from basic configuration to endof96tpi configuration. the result
;of static configuration will be the address the dynamic configuration will
;use to start with.
;
;secondly, "dynamic cofiguration" will be performed. dynamic configuration
;involves possible relocation of code or data. dynamic configuration routine
;will take care of bdsm tables and at rom fix module thru k09 suspend/resume
;code individually. after these operation, [dosdatasg] will be set.
;this will be the place sysinit routine will relocate msdos module for good.

; -- begin changed section
;
;   1.	 basic configuration for msbio (endfloppy)
;   2.   end96tpi	; a system that supports "change line error"
;   3.	 end of bdss	; end of bdss for hard disks
;   4.	 endatrom	;some of at rom fix module.
;   5.	 endcmosclockset;supporting program for cmos clock write.
;   6.	 endk09 	;k09 cmos clock module to handle suspend/resume operation.
;

; 02/10/2022 - Retro DOS v4.0 (MSDOS v5.0 IO.SYS)

static_configure:			
		mov	di, [end_of_bdss]
		cmp	di, bdss	; 19/10/2022
		;cmp	di, offset bdss	; did we allocate any hard drive bdss?
		jnz	short dynamic_configure	; that's the end, then
		; 18/10/2022
		mov	di, end96tpi
		;mov	di, offset harddrv ; end96tpi
					; keep everything up to	end96tpi
		cmp	byte [fhave96], 0
		jnz	short dynamic_configure
		
		mov	di, endfloppy
dynamic_configure:			
		; 20/12/2022
		;push	cs
		;pop	es
		
		cld

; -- end changed section

		; 21/12/2022
		; ds = cs <> es
		; ss = 0
		; sp = 700h

		cmp	byte [model_byte], 0FCh ; AT ?
		jnz	short checkcmosclock
		cmp	byte [hnum], 0	; No hard file?
		jz	short checkcmosclock
		xchg	ax, di		; save allocation pointer in ax
		mov	si, 0F000h
		mov	es, si		; ES ->	ROM BIOS segment
		mov	si, bios_date	; "01/10/84"
		mov	di, 0FFF5h	; ROM BIOS string is at	F000:FFF5
		mov	cx, 9		; bdate_l
					; Only patch ROM for bios 01/10/84
		repe cmpsb		; check	for date + zero	on end
		xchg	ax, di		; restore allocation pointer

; M015 -- begin changes

		;jnz	short checkcmosclock
		; 02/10/2022
		jnz	short checkcompaqbug

; install at rom fix

		; 19/10/2022
		;mov	cx, offset endatrom
		mov	cx, endatrom
		;mov	si, offset ibm_disk_io
		mov	si, ibm_disk_io
		jmp	short install_int13_patch
; ----------------------------------------------------------------------------

; M065 -- begin changes
;
; On certain systems with Western Digital disk controllers, the
; following detection scheme caused an unpredictable and serious
; failure. In particular, they've implemented a nonstandard
; Int13(ah=16h) which reconfigures the hard drive, depending on
; what happens to be at es:[bx] and other memory locations indexed
; off of it.
;
; Compaq was unable to tell us exactly which kind of systems have
; the bug, except that they guarantee that the bug was fixed in
; ROM BIOSs dated 08/04/86 and later. We'll check for the COMPAQ
; string, and then look for date codes before 08/04/86 to decide
; when to install the hook.

;checkcmosclock:
; 02/10/2022				
checkcompaqbug:
		; 21/12/2022
		; es = 0F000h
		;mov	ax, 0F000h	; point	to ROM BIOS
		;mov	es, ax

		; 19/10/2022
		cmp	word [es:0FFEAh], 'CO'
		;cmp	word ptr es:0FFEAh, 'OC' ; look for COMPAQ
		jnz	short not_compaq_patch
		cmp	word [es:0FFECh], 'MP'
		;cmp	word ptr es:0FFECh, 'PM'
		jnz	short not_compaq_patch
		cmp	word [es:0FFEEh], 'AQ'
		;cmp	word ptr es:0FFEEh, 'QA'
		jnz	short not_compaq_patch

; We're running on a COMPAQ. Now look at the date code.

		mov	ax, [es:0FFFBh]	; get year
		xchg	ah, al
		cmp	ax, 3836h ; 02/10/2022 (NASM syntax)
		;cmp	ax, '86'        ; 3836h
					; is it	86?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, [es:0FFF5h]	; get month
		xchg	ah, al
		cmp	ax, 3038h ; 02/10/2022 (NASM syntax)
		;cmp	ax, '08'        ; 3038h
					; is it	08?
		ja	short not_compaq_patch
		jb	short do_compaq_patch
		mov	ax, [es:0FFF8h]	; get day
		xchg	ah, al
		cmp	ax, 3034h ; 02/10/2022 (NASM syntax)
		;cmp	ax, '04'        ; 3034h
					; is it	04?
		jnb	short not_compaq_patch

do_compaq_patch:			
		mov	cx, end_compaq_i13hook
		mov	si, endatrom

install_int13_patch:			
		push	cs
		pop	es
		; 18/10/2022
		mov	[Orig13], di	; set new rom bios int 13 vector
		mov	[Orig13+2], cs
		sub	cx, si		; size of rom fix module
		rep movsb		; relocate it

; M065 -- end changes

; ----------------------------------------------------------------------------
not_compaq_patch:			; M065
		; 17/10/2022
checkcmosclock:	
		; 18/10/2022		
		push	cs
		pop	es

		; 21/12/2022
		; ds = cs = es
		; ss = 0
		; sp = 700h

		cmp	byte [havecmosclock], 1 ; cmos clock exists?
		jnz	short checkk09	; no
		mov	word [daycnttoday], di
		;mov	word ptr ds:daycnttoday, di ; set the address for mschar
		mov	cx, 209		; enddaycnttoday - daycnt_to_day
		mov	si, daycnt_to_day
		rep movsb
		mov	word [bintobcd], di
		;mov	word ptr ds:bintobcd, di ; set the address for msclock
					; let original segment stay
		mov	cx, 11
		mov	si, bin_to_bcd
		rep movsb
checkk09:				
		push	di ; ? ; save ? ; 21/12/2022
		mov	ax, 4101h	; wait for bh=es:[di]
		mov	bl, 1		; wait for 1 clock tick
		mov	bh, [es:di]
		stc			; Assume we will fail
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set
		pop	di ; ?
		jc	short configdone ; 21/12/2022

		mov	byte [fhavek09], 1
					; remember we have a k09 type
		push	ds
		xor	ax, ax
		mov	ds, ax
		
		mov	[6Ch*4], di
		;mov	ds:1B0h, di	; [6Ch*4]
					; new int 6ch handler
		;mov	word ptr ds:1B2h, cs ; [6Ch*4+2]
		mov	word [6Ch*4+2], cs
		pop	ds
		; 21/12/2022
		; ds = cs = es
		mov	si, int6c
		mov	cx, endk09-int6c ; 459
		;mov	cx, 459		; endk09 - int6c
					; size of k09 routine
		rep movsb		;
					; set up config	stuff for sysinit
; ----------------------------------------------------------------------------
; Set up config stuff for SYSINIT

; 17/10/2022
;SETDRIVE equ SetDrive - DOSBIOSEG_2C7h ; (4D7h for MSDOS 5.0 IO.SYS)
;GETBP equ GetBp - DOSBIOSEG_2C7h ; (606h for MSDOS 5.0 IO.SYS)
; 09/12/2022
SETDRIVE equ SetDrive
GETBP equ GetBp
		
		; 17/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
configdone:				
		push	cs		; di is	final ending address of	msbio.
		pop	ds
		add	di, 15		; round	(up) to	paragraph
		; 10/12/2022
		;shr	di, 1
		;shr	di, 1
		;shr	di, 1
		;shr	di, 1
		mov	cl, 4
		shr	di, cl		
		; 10/12/2022
		add	di, 70h		; KERNEL_SEGMENT (in fact: IO.SYS loading segment)
		; 19/10/2022 - Temporary !
		;db	81h, 0C7h, 70h, 0 ; add di, 0070h
		mov	[DosDataSg], di	; where	the dos	data segment will be
		mov	ax, [drvfat]	; get drive and	fat id
		; 22/12/2022
		; Note: SETDRIVES uses AL (drive number) only
		mov	bp, SETDRIVE
		;mov	bp, 4D7h	; set_drive (in	dosbios	code segment)
					; at 2C7h:4D7h = 70h:2A47h
		push	cs		; simulate far call
		call	call_bios_code	; get bds for drive
		mov	bp, GETBP	; ensure valid bpb is present	
		;mov	bp, 606h	; GetBp (2C7h:606h = 70h:2B76h) 
		push	cs
		call	call_bios_code

	; resort to funky old segment definitions for now

		; 22/12/2022
		;push	es		; copy bds to ds:di
		;pop	ds

	; the following read of es:0000 was spurious anyway. Should look into it.
	;
	; hmmmmmm. j.k. took out a call to getfat right here a while
	;	  back. Apparently it was what actually setup es: for the following
	; cas----

		; 22/12/2022
		;xor	di, di
		;mov	al, [es:di]	; get fat id byte
		;;mov	byte ptr es:drvfat+1, al ; save fat byte
		;mov	[es:drvfat+1], al
		;mov	ax, [es:drvfat]
		
		; 22/12/2022
		; ds = cs
	;;;	mov	al, [drvfat]

	; cas -- why do a SECOND setdrive here???

		; 22/12/2022
		;push	es		; save whatever's in es
		;push	ds		; copy bds to es:di
		;pop	es
		;push	cs		; copy Bios_Data to ds
		;pop	ds
	
	; 22/12/2022
	;;;	mov	bp, SETDRIVE
	;;;	;mov	bp, 4D7h	; SetDrive (2C7h:47Dh = 70h:2A47h)
	;;;	push	cs		; simulate far call
	;;;	call	call_bios_code	; get correct bds for this drive
	
		; 22/12/2022
		;push	es		; copy bds back to ds:di
		;pop	ds
		;pop	es		; pop whatever was in es

	; Now we load in the MSDOS.SYS file

	; 22/12/2022
	; -----
	;	mov	bx, [di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
	;	mov	[cs:md_sectorsize], bx	; used by get_fat_sector proc.
	;	mov	bl, [di+1Fh]	; [di+BDS.fatsiz]
	;				; get size of fat on media
	;	;mov	es:16DEh, bl
	;	mov	[es:fbigfat], bl
	;	mov	cl, [di+8]
	;	mov	ax, [di+17h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
	;	;sub	es:16D8h, ax
	;	sub	[es:bios_l], ax	; subtract hidden sectors since we
	;				; need a logical sector number that will
	;				; be used by getclus(diskrd procedure)
	;	mov	ax, [di+19h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
	;	;sbb	es:16DAh, ax
	;	sbb	[es:bios_h], ax	; subtract upper 16 bits of sector num
	; -----
		
	; -----	; 22/12/2022
		mov	bx, [es:di+6]	; [di+BDS.BDS_BPB.BPB_BYTESPERSECTOR]
		mov	[md_sectorsize], bx ; used by get_fat_sector proc.
		mov	bl, [es:di+1Fh]	; [di+BDS.fatsiz]
					; get size of fat on media
		mov	[fbigfat], bl
		mov	cl, [es:di+8]
		mov	ax, [es:di+17h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS]
		sub	[bios_l], ax	; subtract hidden sectors since we
					; need a logical sector number that will
					; be used by getclus(diskrd procedure)
		mov	ax, [es:di+19h] ; [di+BDS.BDS_BPB.BPB_HIDDENSECTORS+2]
		sbb	[bios_h], ax	; subtract upper 16 bits of sector num
	; ------

		xor	ch, ch	 ; cx = sectors/cluster

	; the boot program has left the directory at 0:500h

		push	ds
		xor	di, di
		mov	ds, di
		mov	bx, [53Ah]
		;mov	bx, ds:53Ah	; clus=*53Ah
					; (First cluster field of 2nd dir entry
					; of root directory in the buffer at 500h)
		pop	ds
loadit:
		mov	ax, SYSINITSEG	; 46Dh
		;mov	ax, 46Dh	; sysinit segment
		mov	es, ax
		mov	es, [es:CURRENTDOSLOCATION] ; 09/12/2022
		;mov	es, [es:271h]

		call	getclus		; read cluster at ES:DI (DI is updated)
; ----------------------------------------------------------------------------

		;test	byte [cs:fbigfat], fbig
		test	byte [cs:fbigfat], 40h ; fbig
		jnz	short eofbig
		cmp	bx, 0FF7h
		jmp	short iseofx
; ----------------------------------------------------------------------------

eofbig:
		cmp	bx, 0FFF7h
iseofx:
		jb	short loadit	; keep loading until cluster = eof
		call	setdrvparms	; 

		;;jmp	far ptr	46Dh:267h ; jmp	SYSINIT_SEG:SYSINIT_START
		;jmp	far 46Dh:267h
		jmp	SYSINITSEG:SYSINITSTART

; =============== S U B	R O U T	I N E ========================================

; Following are subroutines to support resident device driver initialization
;
;M011 -- note:  deleted setup_bdsms and reset_bdsms here

;	M035 -- begin changed section

;******************************************************************************
; module name: remap
;
; descriptive name: all the code for himem that could be separated from msbio
;
; function:  remap the bds chain to adjusted logical drive numbers (drive
;	     letters) if more than two diskette drives on the system.
;
;     scheme:  if more than 2 diskette drives, first map the bds structure
;	       as usual and then rescan the bds chain to adjust the drive
;	       letters. to do this, scan for disk drives and assign logical
;	       drive number starting from 2 and then rescan diskette drives
;	       and assign next to the last logical drive number of last disk
;	       drive to the 3rd and 4th diskette drives.

; input:       none
; exit:	drive letters have been remapped in bds chain
; exit error:  none
; called from: msinit
;
; notes:  this function  will be called only if more than 2 diskettes are
;	  found in the system
;	  this function assumes that there are no more than 26 drives assigned
;	    this is guaranteed by the code that creates bdss for partitions
;	  this function assumes that the first entries in the chain are
;	   floppy drives, and all the rest are hard drives
;	  will alter the boot drive if necessary to reflect remapping
;
;******************************************************************************

; 17/10/2022
; 02/10/2022

remap:		; proc near		
		mov	di, [cs:start_bds] ; get first bds

; search for 1st fixed disk physical drive num

drive_loop:				
		cmp	byte [di+4], 80h ; [di+BDS.drivenum]
					; first	hard disk??
		jz	short fdrv_found ; yes,	continue
		mov	di, [di]	; [di+BDS.link]
					; get next bds,	assume segment
		cmp	di, -1		; last bds?
		jnz	short drive_loop ; loop	if not
		jmp	short rmap_exit	; yes, no hard drive on	system

;------------------------------------------------------------------------------
;first disk drive bds, now change the logical drive num to 2 and the subsequent
;logical drive nums to 3, 4, 5 etc.
;------------------------------------------------------------------------------

fdrv_found:				
		mov	al, 2		; start	with logical drv num=2
fdrv_loop:				
		mov	[di+5],	al	; [di+BDS.drivelet]
					; found	??
		mov	di, [di]	; [di+BDS.link]
					; ds:di--> next	bds
		;inc	al		; set num for next drive
		; 18/12/2022
		inc	ax
		cmp	di, 0FFFFh	; last hard drive ??
		jnz	short fdrv_loop	; no - assign more disk	drives

;------------------------------------------------------------------------------
; now, rescan and find bds of 3rd floppy drive and assign next drive letter
; in al to 3rd. if the current drive letter is past z, then do not allocate
; any more.
;------------------------------------------------------------------------------

		mov	di, [cs:start_bds] ; [start_bds]
					; get first bds
		mov	di, [di]	; [di+BDS.link]
					; ds:di-->bds2
		mov	ah, [cs:dsktnum] ; get number of floppies to remap
		sub	ah, 2		; adjust for a:	& b:
remap_loop1:				
		mov	di, [di]	; [di+BDS.link]
					; set new num to next floppy
		mov	[di+5],	al	; [di+BDS.drivelet]
		inc	al		; new number for next floppy
		dec	ah		; count	down extra floppies
		jnz	short remap_loop1

; now we've got to adjust the boot drive if we reassigned it

		mov	al, [cs:drvfat]
		cmp	al, 2		; is it	a: or b: ?
		jb	short rmap_exit
		sub	al, [cs:dsktnum] ; is it one of the other floppies?
		jb	short remap_boot_flop ;	brif so

; we've got to remap the boot hard drive
; subtract the number of EXTRA floppies from it

		add	al, 2		; bootdrv -= (dsktnum-2)
		jmp	short remap_change_boot_drv
; ---------------------------------------------------------------------------

; we've got to remap the boot floppy.
; add the number of hard drive partitions to it

remap_boot_flop:			
		add	al, [cs:drvmax]	; bootdrv += (drvmax-dsktnum)
remap_change_boot_drv:			
		mov	[cs:drvfat], al ; alter msdos.sys load drive
		inc	al
		push	ds
		mov	di, SYSINITSEG	; 46Dh
		;mov	di, 46Dh	; SYSINIT segment
		mov	ds, di
		mov	[DEFAULTDRIVE], al
		;mov	ds:296h, al	; [SYSINIT+DEFAULT_DRIVE]
					; pass it to sysinit as	well
		pop	ds
rmap_exit:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 17/10/2022
; 02/10/2022 - Retro DOS v4.0 (MSDOS 5.0 -actual-)
; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21 -draft-)
; 02/06/2018 - Retro DOS v3.0 (MSDOS 3.3)	
; 19/03/2018 - Retro DOS v2.0 (MSDOS 2.11)
;**************************************************
; getboot - get the boot sector for a hard disk
;
; Reads the boot sector from a specified drive into
; a buffer at the top of memory.
;
; dl = int13 drive number to read boot sector for
;**************************************************

; 17/10/2022
bootbias equ 200h

getboot:	; proc near		
		
		; 08/04/2018
		; Retro DOS v2.0 (IBMBIO.COM, IBMDOS 2.1)
		; 28/03/2018 - MSDOS 6.0 - MSINIT.ASM, 1991
		; 02/10/2022 - Retro DOS v4.0
		;	      (disassembled IO.SYS code of MSDOS 5.0)

		mov	ax, [cs:init_bootseg] ; 17/10/2022
		mov	es, ax
		; 17/10/2022
		mov	bx, bootbias ; 200h
		;mov	bx, 200h	; bootbias
					; load BX, ES:BX is where sector goes
		mov	ax, 201h
		xor	dh, dh
		mov	cx, 1
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short erret
		; 17/10/2022
		cmp	word [es:bootbias+1FEh], 0AA55h
		;cmp	word ptr es:3FEh, 0AA55h ; [es:bootbias+1FEh]
					; Dave Litton magic word?
		jz	short norm_ret	; yes
erret:					
		stc
norm_ret:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 28/12/2018 - Retro DOS v4.0 

;***************************************************************************
;   sethard - generate bpb for a variable sized hard file. ibm has a
;   partitioned hard file; we must read physical sector 0 to determine where
;   our own logical sectors start. we also read in our boot sector to
;   determine version number
;
;   inputs:	dl is rom drive number (80...)
;		bh is partition number (0....) 
;		ds:di points to bds
;   outputs:	carry clear -> bpb is filled in
;		carry set   -> bpb is left uninitialized due to error
;	trashes (at least) si, cx
;	MUST PRESERVE ES:!!!!
;***************************************************************************

sethard:	; proc near		
		push	di
		push	bx
		push	ds
		push	es
		mov	[di+5],	bl	; [di+BDS.drivelet]
		mov	[di+4],	dl	; [di+BDS.drivenum]
		or	byte [di+23h], 1 ; [di+BDS.flags]
					; fnon_removable
		mov	byte [di+22h], 5 ; [di+BDS.formfactor]
					; ffHardFile
		mov	byte [fbigfat], 0 ; assume 12 bit FAT
		mov	dh, bh		; partition number
		push	dx
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		mov	[di+15h], dh	; [di+BDS.heads] ; get number of heads
		pop	dx
		jb	short setret	; error	if no hard disk
		and	cl, 3Fh
		mov	[di+13h], cl	; [di+BDS.secpertrack]
		push	dx		; save partition number
		call	getboot
		pop	dx		; restore partition number
		jb	short setret
		mov	bx, 3C2h	; 1C2h+bootbias

; The first 'active' partition is 00, the second is 01....
;   then the remainder of the 'primary' but non-active partitions

act_part:				
		test	byte [es:bx-4], 80h ; is the partition active?
		jz	short no_act	; no
		cmp	byte [es:bx], 1 ; reject if partitiontype != 1, 4 or 6
		jz	short got_good_act
		cmp	byte [es:bx], 4
		jz	short got_good_act
		cmp	byte [es:bx], 6
		jnz	short no_act
got_good_act:				
		or	dh, dh		; is this our target partition #?
		jz	short set2	; WE GOT THE ONE WANTED!!
		dec	dh		; count	down
no_act:					
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
					; last entry done?
		jnz	short act_part	; no, process next entry
		mov	bx, 3C2h	; 1C2h+bootbias
					; restore original value of bx

; Now scan the non-active partitions

get_primary:				
		test	byte [es:bx-4], 80h
		jnz	short not_prim	; we've already scanned
					; the ACTIVE ones
		cmp	byte [es:bx], 1 ; see if partitiontype == 1, 4 or 6
		jz	short got_prim
		cmp	byte [es:bx], 4
		jz	short got_prim
		cmp	byte [es:bx], 6
		jnz	short not_prim
got_prim:				
		or	dh, dh		; is this our target partition?
		jz	short set2
		dec	dh
not_prim:				
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short get_primary ; loop till we've gone through table
setret:					
		stc			; error	return
		jmp	ret_hard_err

; ---------------------------------------------------------------------------

;  until we get the real logical boot record and get the bpb,
;  BDS_BPB.BPB_BIGTOTALSECTORS will be used instead of BDS_BPB.BPB_TOTALSECTORS
;  for the convenience of the computation.
;
;  at the end of this procedure, if a bpb information is gotten from
;  the valid boot record, then we are going to use those bpb information
;  without change.
;
;  otherwise, if (hidden sectors + total sectors) <= a word, then we will move
;  BDS_BPB.BPB_BIGTOTALSECTORS (low) to BDS_BPB.BPB_TOTALSECTORS and zero out
;  BDS_BPB.BPB_BIGTOTALSECTORS entry to make it a conventional bpb format.

set2:					
		mov	[cs:rom_drv_num], dl
			; save the rom bios drive number we are handling now.
		mov	ax, [es:bx+4]	; hidden sectors (start	sector)
		mov	dx, [es:bx+6]

; decrement the sector count by 1 to make it zero based. exactly 64k
; sectors should be allowed	

		sub	ax, 1
		sbb	dx, 0
		add	ax, [es:bx+8]	; sectors in partition
		adc	dx, [es:bx+10]
		jnb	short okdrive
		or	byte [fbigfat], 80h ; ftoobig
okdrive:				
		mov	ax, [es:bx+4]
		mov	[di+17h], ax	; [di+BDS.hiddensecs]
					; BPB_HIDDENSECTORS = p->partitionbegin
		mov	ax, [es:bx+6]
		mov	[di+19h], ax	; [di+BDS.hiddensecs+2]
		mov	dx, [es:bx+10]	; # of sectors (high)
		mov	ax, [es:bx+8]	; # of sectors (low)
		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]
		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
					; bpb->maxsec =	p->partitionlength
		cmp	dx, 0
		ja	short okdrive_1
		cmp	ax, 64		; if (p->partitionlength < 64)
		jb	short setret	; return -1;
okdrive_1:				
		mov	dx, [di+19h]	; [di+BDS.hiddensecs+2]
		mov	ax, [di+17h]	; [di+BDS.hiddensecs]
		xor	bx, bx		; boot sector number - for mini	disk
					; usually equal	to the # of sec/trk.
		mov	bl, [di+13h]	; [di+BDS.secpertrack]
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	bx		; (sectors)dx:ax / (BDS.secpertrack)bx =
					; (track)temp_h:ax + (sector)dx
		; 17/10/2022
		mov	[cs:temp_h], ax
		pop	ax
		div	bx
		mov	cl, dl
		inc	cl
		xor	bx, bx
		mov	bl, [di+15h]	; [di+BDS.heads]
		push	ax
		xor	dx, dx
		mov	ax, [cs:temp_h]
		div	bx
		mov	[cs:temp_h], ax
		pop	ax
		div	bx		;  dl is head, ax is cylinder
		cmp	word [cs:temp_h], 0
		ja	short setret_brdg ; exceeds the	limit of int 13h
		cmp	ax, 1024
		ja	short setret_brdg ; exceeds the	limit of int 13h
			; Retro DOS v3.2 note by Erdogan Tan - 28/07/2019
			; **MSDOS code accepts if ax = 1024 but it is nonsense here
			; ('ja' must be 'jnb')
okdrive_2:
 		; 28/07/2019
; dl is head.
; ax is cylinder
; cl is sector number (assume less than 2**6 = 64 for int 13h)

;*** for mini disks ***

		cmp	word [di+47h], 1 ; [di+BDS.bdsm_ismini]
					; check	for mini disk
		jnz	short oknotmini	; not mini disk.
		add	ax, [di+49h]	; [di+BDS.bdsm_hidden_trks]
					; set the physical track number
oknotmini:
;*** end of added logic for mini disk
				
		ror	ah, 1		; move high two	bits of	cyl to high
		ror	ah, 1		; two bits of upper byte
		and	ah, 0C0h	; turn off remainder of	bits
		or	cl, ah		; move two bits	to correct spot
		mov	ch, al		; ch is	cylinder (low 8	bits)
					; cl is	sector + 2 high	bits of	cylinder
		mov	dh, dl		; dh is	head
		mov	dl, [cs:rom_drv_num] ; dl is drive number

; cl is sector + 2 high bits of cylinder
; ch is low 8 bits of cylinder
; dh is head
; dl is drive

; for convenience, we are going to read the logical boot sector
; into cs:disksector area.

; read in boot sector using bios disk interrupt. the buffer where it
; is to be read in is cs:disksector.

		push	cs
		pop	es
		mov	bx, disksector	; for convenience,
					; we are going to read the logical boot	sector
					; into cs:disksector area.
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read

; cs:disksec contains the boot sector. in theory, (ha ha) the bpb in this thing
; is correct. we can, therefore, suck out all the relevant statistics on the
; media if we recognize the version number.

		mov	bx, disksector
		push	bx
		push	ax
		cmp	byte [cs:bx], 0E9h ; is it a near jump?
		jz	short check_1_ok ; yes
		cmp	byte [cs:bx], 0EBh ; is it a short jump?
		jnz	short invalid_boot_record ; no
		cmp	byte [cs:bx+2], 90h ; yes, is the next one a nop?
		jnz	short invalid_boot_record
check_1_ok:				
		mov	bx, 159h	; disksector+EXT_BOOT.BPB
					; point	to the bpb in the boot record
		mov	al, [cs:bx+10]	; [bx+EBPB.MEDIADESCRIPTOR]
					; get the mediadescriptor byte
		and	al, 0F0h	; mask off low nibble
		cmp	al, 0F0h	; is high nibble = 0Fh?
		jnz	short invalid_boot_record ; no,	invalid	boot record
		cmp	word [cs:bx], 512 ; [bx+EBPB.BYTESPERSECTOR]
		jnz	short invalid_boot_record ; invalidate non 512 byte sectors

check2_ok:				; yes, mediadescriptor ok.
		mov	al, [cs:bx+2]	; now make sure	that
					; the sectorspercluster	is
					; a power of 2
					;
					; [bx+EBPB.SECTORSPERCLUSTER]
					; get the sectorspercluster
		or	al, al		; is it	zero?
		jz	short invalid_boot_record ; yes, invalid boot record

ck_power_of_two:			
		shr	al, 1		; shift	until first bit	emerges
		jnb	short ck_power_of_two
		jz	short valid_boot_record

invalid_boot_record:			
		pop	ax
		pop	bx
		jmp	unknown		; jump to invalid boot record
					; unformatted or illegal media.
; ---------------------------------------------------------------------------

valid_boot_record:			
		pop	ax
		pop	bx

; Signature found. Now check version.

		cmp	word [cs:bx+8], '2.' ; 03/10/2022 (NASM syntax)
		;cmp	word ptr cs:[bx+8], 2E32h ; '2.'
		jnz	short try5
		cmp	byte [cs:bx+0Ah], '0' ; 03/10/2022 (NASM syntax)
		;cmp	byte ptr cs:[bx+0Ah], 30h ; '0'
		jnz	short try5
		jmp	short copybpb
; ---------------------------------------------------------------------------

setret_brdg:				
		jmp	setret
; ---------------------------------------------------------------------------

unknown3_0_j:				
		jmp	unknown3_0	; legally formatted media,
					; although, content might be bad.
; ---------------------------------------------------------------------------

try5:					
		call	cover_fdisk_bug

; see if it is an os2 signature

		cmp	word [cs:bx+8], '0.' ; 03/10/2022 (NASM syntax)
		;cmp	word ptr cs:[bx+8], 2E30h ; '0.'
		jnz	short no_os2
		mov	al, [cs:bx+7]	; 17/10/2022 (NASM syntax)
		sub	al, '1'
		;sub	al, 31h		; '1'
		and	al, 0FEh
		jz	short copybpb	; accept either	'1' or '2'
		jmp	unknown
; ---------------------------------------------------------------------------

; no os2 signature, this is to check for real dos versions

no_os2:					
		cmp	word [cs:bx+8], '3.' ; 03/10/2022 (NASM syntax)
		;cmp	word ptr cs:[bx+8], 2E33h ; '3.'
		jb	short unknown3_0_j ; must be 2.1 boot record.
					; do not trust it, but still legal.
		jnz	short copybpb	; honor	os2 boot record
					; or dos 4.0 version
		cmp	byte [cs:bx+10], '1'
		;cmp	byte ptr cs:[bx+0Ah], 31h ; '1'
		jb	short unknown3_0_j ; if version >=	3.1, then o.k.
copybpb:

; 03/10/2022

; we have a valid boot sector. use the bpb in it to build the
; bpb in bios. it is assumed that only
;	BDS_BPB.BPB_SECTORSPERCLUSTER
;	BDS_BPB.BPB_ROOTENTRIES, and
;	BDS_BPB.BPB_SECTORSPERFAT
; need to be set (all other values in already). fbigfat is also set.

; if it is non fat based system, then just copy the bpb from the boot sector
; into the bpb in bds table, and also set the boot serial number, volume id,
; and system id according to the boot record.
; for the non_fat system, don't need to set the other value. so just do goodret.

		; 10/12/2022
		; (number of FATs optimization)
		mov	si, disksector+11 ; disksector+0Bh
		;mov	cl, [cs:disksector+10h] ; Number of FATs (may be 2 or 1)
		mov	cl, [cs:si+05h]
		
		cmp	byte [cs:si+1Bh], 29h ; 10/12/2022	
		;cmp	byte [cs:disksector+26h], 29h ; 17/10/2022
					; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short copybpb_fat ; conventional fat system

		; 03/10/2022
		; 29/12/2018 - Retro DOS v4.0 modification note:
		; Regarding 'fat_big_small' part of this (MSDOS 6.0) code
		;	     number of FATs must be 2 ; =*?=
		; (Otherwise, '# of data sectors' would be calculated as wrong!!!)
		;
		;cmp	byte [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS], 2 ; =*?=

		; 10/12/2022
		;cmp	byte [cs:disksector+10h], 0
					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
		;jnz	short copybpb_fat ; a fat system.
		or	cl, cl	 ; [cs:disksector+10h]
		jnz	short copybpb_fat ; a fat system.

; non fat based	media.

		push	di
		push	ds
		push	ds
		pop	es
		push	cs
		pop	ds

		; 10/12/2022
		; (number of FATs optimization)
		; SI = disksector+11
		; 17/10/2022
		;;mov	si, 159h	; disksector+EXT_BOOT.BPB
		;mov	si, disksector+11
		add	di, 6		; add di,BDS.BPB

; just for completeness, we'll make sure that total_sectors and
; big_total_sectors aren't both zero. I've seen examples of
; this on DOS 3.30 boot records. I don't know exactly how it
; got that way. If it occurs, then use the values from the
; partition table.

		; 18/12/2022
		sub	cx, cx 

		;cmp	word [cs:si+8], 0 	; [cs:si+EBPB.TOTALSECTORS]
		;jnz	short already_nonz 
		;			; how about big_total?
		;cmp	word [cs:si+15h], 0	; [cs:si+EBPB.BIGTOTALSECTORS]
		;jnz	short already_nonz ; we're okay if any are != 0
		;cmp	word [cs:si+17h], 0	; [cs:si+EBPB.BIGTOTALSECTORS+2]
		;jnz	short already_nonz

		; 18/12/2022
		cmp	[cs:si+8], cx ; 0	; [cs:si+EBPB.TOTALSECTORS]
		jnz	short already_nonz
					     ; how about big_total?
		cmp	word [cs:si+15h], cx ; 0 ; [cs:si+EBPB.BIGTOTALSECTORS]
		jnz	short already_nonz   ; we're okay if any are != 0
		cmp	word [cs:si+17h], cx ; 0 ; [cs:si+EBPB.BIGTOTALSECTORS+2]
		jnz	short already_nonz

; now let's copy the values from the partition table (now in the BDS)
; into the BPB in the boot sector buffer, before they get copied back.

		mov	ax, [di+8]	; [di+BDS.totalsecs16]
		mov	[cs:si+8], ax	; [cs:si+EBPB.TOTALSECTORS]
		mov	ax, [di+15h]	; [di+BDS.totalsecs32]
		mov	[cs:si+15h], ax	; [cs:si+EBPB.BIGTOTALSECTORS]
		mov	ax, [di+17h]	; [di+BDS.totalsecs32+2]
		mov	[cs:si+17h], ax	; [cs:si+EBPB.BIGTOTALSECTORS+2]

already_nonz:	
		; 18/12/2022
		; cx = 0
		mov	cl, 25		
		;mov	cx, 25		; A_BPB.size - 6 ; Use SMALL version!
		rep movsb
		pop	ds
		pop	di
		push	es
		push	ds
		pop	es
		push	cs
		pop	ds
		; 18/12/2022
		mov	bp, mov_media_ids
		;mov	bp, 751h	; mov_media_ids
					; at 2C7h:751h = 70h:2CC1h
					; set volume id, systemid, serial.
		push	cs		; simulate far call
		call	call_bios_code
		push	es
		pop	ds
		pop	es
		jmp	goodret
; ---------------------------------------------------------------------------

; ****** cas ---
; IBM DOS 3.30 doesn't seem to mind that the TOTAL_SECTORS and
; BIG_TOTAL_SECTORS field in the boot sector are 0000. This
; happens with some frequency -- perhaps through some OS/2 setup
; program. We haven't actually been COPYING the TOTAL_SECTORS
; from the boot sector into the DPB anyway, we've just been using
; it for calculating the fat size. Pretty scary, huh? For now,
; we'll go ahead and copy it into the DPB, except in the case
; that it equals zero, in which case we just use the values in
; the DPB from the partition table.

; 17/10/2022
;MOVMEDIAIDS equ mov_media_ids - DOSBIOSEG_2C7h ; (751h for MSDOS 5.0 IO.SYS)
;CLEARIDS equ clear_ids - DOSBIOSEG_2C7h ; (5D9h for MSDOS 5.0 IO.SYS)		    		
; 09/12/2022
MOVMEDIAIDS equ mov_media_ids
CLEARIDS equ clear_ids

copybpb_fat:
		; 10/12/2022
		; (number of FATs optimization)
		; SI = disksector+11				
		; 17/10/2022
		;mov	si, disksector+11
		;;mov	si, 159h	; disksector+EXT_BOOT.BPB
					; cs:si	-> bpb in boot
		xor	dx, dx
		mov	ax, [cs:si+8]	; [cs:si+EBPB.TOTALSECTORS]
					; get totsec from boot sec
		or	ax, ax
		jnz	short copy_totsec ; if non zero, use that
		mov	ax, [cs:si+15h]	; [cs:si+EBPB.BIGTOTALSECTORS]
					; get the big version
					; (32 bit total	sectors)
		mov	dx, [cs:si+17h]	; [cs:si+EBPB.BIGTOTALSECTORS+2]
		; 10/12/2022
		; (number of FATs optimization)
		; CL = number of FATs (2 or 1) 
		mov	bx, dx		; see if it is a big zero
		or	bx, ax
		jnz	short copy_totsec
			; screw it. it	was bogus.
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
		jmp	short fat_big_small

		;mov	cx, dx
		;or	cx, ax		; see if it is a big zero
		;jz	short totsec_already_set ; screw it. it	was bogus.
copy_totsec:				
		mov	[di+1Bh], ax	; [di+BDS.totalsecs32]
					; make DPB match boot sec
		mov	[di+1Dh], dx	; [di+BDS.totalsecs32+2]

		; 10/12/2022
;totsec_already_set:			
		;mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		;mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]

; determine fat entry size.

fat_big_small:

;at this moment dx;ax = total sector number

;Do not assume 1 reserved sector. Update the reserved sector field in BDS 
;from the BPB on the disk
				
		mov	bx, [cs:si+3]	; [cs:si+EBPB.RESERVEDSECTORS]
					; get #reserved_sectors	from BPB
		mov	[di+9],	bx	; [di+BDS.resectors]
					; update BDS field
		sub	ax, bx
		sbb	dx, 0		; update the count
		mov	bx, [cs:si+0Bh]	; [cs:si+EBPB.SECTORSPERFAT]
					; bx = sectors/fat
		mov	[di+11h], bx	; [di+BDS.fatsecs]
					; set in bds bpb
		; 10/12/2022
		; (number of FATs optimization)
		; CL = number of FATs (2 or 1) 
		;dec	cl ; *
		; 18/12/2022
		dec	cx ; *
		shl	bx, cl			
		;shl	bx, 1	; =*?=	; always 2 fats
		
		sub	ax, bx		; sub #	fat sectors
		sbb	dx, 0
		mov	bx, [cs:si+6]	; [cs:si+EBPB.ROOTENTRIES]
					; # root entries
		mov	[di+0Ch], bx	; [di+BDS.direntries]
					; set in bds bpb
		mov	cl, 4
		shr	bx, cl		; div by 16 ents/sector
		sub	ax, bx		; sub #	dir sectors
		sbb	dx, 0		;
					; dx:ax	now contains the
					; # of data sectors
		xor	cx, cx ; *
		mov	cl, [cs:si+2]	; [cs:si+EBPB.SECTORSPERCLUSTER]
					; sectors per cluster
		mov	[di+8],	cl	; [di+BDS.secperclus]
					; set in bios bpb
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx		; cx = sectors per cluster
		mov	[cs:temp_h], ax	; [temp_h]:ax now contains the
					; # clusters.
		pop	ax
		div	cx
		cmp	word [cs:temp_h], 0
		ja	short toobig_ret ; too big cluster number
		cmp	ax, 0FF6h	; 4096-10
					; is this 16-bit fat?
		jb	short copymediaid ; no,	small fat
		; 17/10/2022
		or	byte [fbigfat], 40h
		;or	ds:fbigfat, 40h	; fbig
					; 16 bit fat
copymediaid:				
		push	es
		push	ds
		pop	es
		push	cs
		pop	ds
		; 17/10/2022
		mov	bp, MOVMEDIAIDS
		;mov	bp, 751h	; mov_media_ids
					; at 2C7h:751h = 70h:2CC1h
					; copy filesys_id, volume label
		push	cs		; simulate far call
		call	call_bios_code
		push	es
		pop	ds
		pop	es
		jmp	massage_bpb	; now final check for bpb info
					; and return.
; ---------------------------------------------------------------------------

toobig_ret:				
		or	byte [cs:fbigfat], 80h
		jmp	goodret		; still	drive letter is	assigned
					; but useless. to big for
					; current pc dos fat file system
; ---------------------------------------------------------------------------

unknown:	
		; 12/12/2022
		or	byte [di+24h], 02h			
		;or	word [di+23h], 200h ; [di+BDS.flags]
					; unformatted_media
					; Set unformatted media	flag.

; the boot signature may not be	recognizable,
; but we should	try and	read it	anyway.

unknown3_0:				
		mov	dx, [di+1Dh]	; skip setting unformatted_media bit
					; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	si, disktable2

scan:					
		cmp	dx, [cs:si]
		jb	short gotparm
		ja	short scan_next
		cmp	ax, [cs:si+2]
		jbe	short gotparm

scan_next:				
		add	si, 10		; 5*2
		jmp	short scan	; covers upto 512 mb media
; ---------------------------------------------------------------------------

gotparm:				
		mov	cl, [si+8]	; fat size for fbigfat flag
		;or	ds:fbigfat, cl
		; 17/10/2022
		or	[fbigfat], cl
		mov	cx, [cs:si+4]	; ch = number of sectors per cluster
					; cl = log base	2 of ch
		mov	dx, [cs:si+6]	; dx = number of root dir entries

; now calculate size of fat table

		mov	[di+0Ch], dx	; [di+BDS.direntries]
					; save number of (root)	dir entries
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	[di+8],	ch	; [di+BDS.secperclus]
					; save sectors per cluster
		; 17/10/2022
		test	byte [fbigfat], 40h
		;test	ds:fbigfat, 40h	; fbig
					; if (fbigfat)
		jnz	short dobig	; goto dobig; (16 bit fat)

; we don't need to change "small fat" logic since it is gauranteed
; that double word total sector will not use 12 bit fat (unless
; it's sectors/cluster >= 16 which will never be in this case.)
; so in this case we assume dx = 0 !!

		xor	bx, bx		; (12 bit fat)
		mov	bl, ch
		dec	bx
		add	bx, ax		; dx=0
		shr	bx, cl		; bx = 1+(bpb->maxsec+BDS.secperclus-1)/
		inc	bx		; BDS.secperclus
		and	bl, 0FEh	; bx &= ~1; (=number of clusters)
		mov	si, bx
		shr	bx, 1
		add	bx, si
		add	bx, 511		; bx +=	511 + bx/2
		shr	bh, 1		; bh >>= 1; (=bx/512)
		mov	[di+11h], bh	; [di+BDS.fatsecs]
					; save number of fat sectors
		jmp	short massage_bpb
; ---------------------------------------------------------------------------

; for bigfat we do need to extend this logic to 32 bit sector calculation.

dobig:					
		mov	cl, 4		; 16 (2^4) directory entries per sector
		push	dx		; save total sectors (high)
		mov	dx, [di+0Ch]	; [di+BDS.direntries]
		shr	dx, cl		; root dir sectors = BDS.direntries / 16;
		sub	ax, dx
		pop	dx
		sbb	dx, 0		; dx:ax	= total	sectors	- root dir sectors
		sub	ax, 1
		sbb	dx, 0		; dx:ax	= t - r	- d
					; total	secs - reserved	secs - root dir	secs
		mov	bl, 2
		mov	bh, [di+8]	; [di+BDS.secperclus]
					; bx = 256 * BDS.secperclus + 2

; I don't understand why to add bx here!!!

		; 29/12/2018 - Erdogan Tan (Retro DOS v4.0)
		; 27/09/2022
		; (Microsoft FAT32 File	System Specification,
		; December 2000, Page 21)
		; TmpVal1 = DskSize - (BPB_ResvdSecCnt+RootrDirSectors)
		; TmpVal2 = (256*BPB_SecPerClus)+BPB_NumFATs
		; FATsz	= (TmpVal1+(TmpVal2-1))/TmpVal2
		; (If FATType == FAT16,	BPB_FATSz16 = LOWORD(FATSz))
		
		add	ax, bx		; ax = t-r-d+256*spc+2
		adc	dx, 0
		sub	ax, 1		; ax = t-r-d+256*spc+1
		sbb	dx, 0

; assuming dx in the table will never be bigger than bx.

		div	bx		; BDS.fatsecs =
					; ceil((total-dir-res)/(256*BDS.secperclus+2))
		mov	[di+11h], ax	; [di+BDS.fatsecs]
					; number of fat	sectors

; now, set the default filesys_id, volume label, serial number

		;mov	bl, ds:fbigfat
		; 17/10/2022
		mov	bl, [fbigfat]
		mov	[di+1Fh], bl	; [di+BDS.fatsiz] ; fat	size flag

		push	ds
		push	ds
		pop	es
		push	cs
		pop	ds
		; 17/10/2022
		mov	bp, CLEARIDS
		;mov	bp, 5D9h	; clear_ids
					; at 2C7h:5D9h = 70h:2B49h
		push	cs
		call	call_bios_code
		pop	ds

; at this point, in bpb of bds table, BDS_BPB.BPB_BIGTOTALSECTORS which is
; set according to the partition information. we are going to
; see if (hidden sectors + total sectors) > a word. if it is true,
; then no change. otherwise, BDS_BPB.BPB_BIGTOTALSECTORS will be moved
; to BDS_BPB.BPB_TOTALSECTORS and BDS_BPB.BPB_BIGTOTALSECTORS will be set to 0.
; we don't do this for the bpb information from the boot record. we
; are not going to change the bpb information from the boot record.

massage_bpb:
		; 12/12/2022
		mov	bl, [fbigfat]
		mov	[di+1Fh], bl	; [di+BDS.fatsiz]
					; set size of fat on media
		;
		mov	dx, [di+1Dh]	; [di+BDS.totalsecs32+2]
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		cmp	dx, 0		; double word total sectors?
		;ja	short goodret	; don't have to change it.
		; 12/12/2022
		ja	short short goodret2
		;cmp	word [di+19h], 0 ; [di+BDS.hiddensecs+2]
		;ja	short goodret	; don't have to change it.
		; 12/12/2022
		cmp	[di+19h], dx ; 0
		ja	short goodret2
		add	ax, [di+17h]	; [di+BDS.hiddensecs]
		;jb	short goodret
		; 12/12/2022
		jc	short goodret
		mov	ax, [di+1Bh]	; [di+BDS.totalsecs32]
		mov	[di+0Eh], ax	; [di+BDS.totalsecs16]
		;mov	word [di+1Bh], 0 ; [di+BDS.totalsecs32]
		; 12/12/2022
		mov	[di+1Bh], dx ; 0 
goodret:				
		;;mov	bl, ds:fbigfat
		; 12/12/2022
		;; 17/10/2022
		;mov	bl, [fbigfat]
		;mov	[di+1Fh], bl	; [di+BDS.fatsiz]
		;			; set size of fat on media
		clc
ret_hard_err:
		; 12/12/2022
goodret2:					
		pop	es
		pop	ds
		pop	bx
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

;fdisk of pc dos 3.3 and below, os2 1.0 has a bug. the maximum number of
;sector that can be handled by pc dos 3.3 ibmbio should be 0ffffh.
;instead, sometimes fdisk use 10000h to calculate the maximum number.
;so, we are going to check that if BPB_TOTALSECTORS + hidden sector = 10000h
;then subtract 1 from BPB_TOTALSECTORS.

		; 17/10/2022
cover_fdisk_bug:	
		push	ax
		push	dx
		push	si
		cmp	byte [cs:disksector+26h], 29h
					; [disksector+EXT_BOOT.SIG],
					; EXT_BOOT_SIGNATURE
		jz	short cfb_retit	; if extended bpb, then	>= pc dos 4.00
		cmp	word [cs:bx+7], 3031h ; '10' ; os2 1.0 = ibm 10.0
		jnz	short cfb_chk_BPB_TOTALSECTORS
		cmp	byte [cs:bx+10], '0'
		jnz	short cfb_retit
cfb_chk_BPB_TOTALSECTORS:
		; 17/10/2022		
		mov	si, disksector+11 ; 14Eh+0Bh
		;mov	si, 159h	; disksector+EXT_BOOT.BPB
		cmp	word [cs:si+8], 0 ; [cs:si+EBPB.TOTALSECTORS]
					; just to make sure.
		jz	short cfb_retit
		mov	ax, [cs:si+8]	; [cs:si+EBPB.TOTALSECTORS]
		add	ax, [cs:si+11h]	; [cs:si+EBPB.HIDDENSECTORS]
		jnb	short cfb_retit
		jnz	short cfb_retit	; if carry set and ax=0
		dec	word [cs:si+8]	; 0 -> 0FFFFh
					; then decrease	BPB_TOTALSECTORS by 1
		sub	word [di+1Bh], 1 ; [di+BDS.totalsecs32]
		sbb	word [di+1Dh], 0 ; [di+BDS.totalsecs32+2]
cfb_retit:				
		pop	si
		pop	dx
		pop	ax
		retn

; ---------------------------------------------------------------------------

word2		dw 2			
word3		dw 3			
word512		dw 512			

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

; setdrvparms sets up the recommended bpb in each bds in the system based on
; the form factor. it is assumed that the bpbs for the various form factors
; are present in the bpbtable. for hard files, the recommended bpb is the same
; as the bpb on the drive.
;
; no attempt is made to preserve registers since we are going to jump to
; sysinit straight after this routine.

setdrvparms:
		xor	bx, bx
		; 18/10/2022
		les	di, [start_bds] ; get first bds in list
_next_bds:				
		push	es
		push	di
		mov	bl, [es:di+22h]	; [es:di+BDS.formfactor]
		cmp	bl, 5		; ffHardFile
		jnz	short nothardff
		xor	dx, dx
		mov	ax, [es:di+0Eh]	; [es:di+BDS.totalsecs16]
		or	ax, ax
		jnz	short get_ccyl
		mov	dx, [es:di+1Dh]	; [es:di+BDS.totalsecs32+2]
		mov	ax, [es:di+1Bh]	; [es:di+BDS.totalsecs32]

get_ccyl:				
		push	dx
		push	ax
		mov	ax, [es:di+15h]	; [es:di+BDS.heads]
		mul	word [es:di+13h] ; [es:di+BDS.secpertrack]
					; assume sectors per cyl. < 64k.
		mov	cx, ax		; cx has # sectors per cylinder
		pop	ax
		pop	dx		; dx:ax	= total	sectors
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx
		mov	[cs:temp_h], ax	; ax be	0 here.
		pop	ax
		div	cx		; div #sec by sec/cyl to get # cyl.
		or	dx, dx
		jz	short no_cyl_rnd ; came out even
		inc	ax		; round	up

no_cyl_rnd:				
		mov	[es:di+25h], ax	; [es:di+BDS.cylinders]
		push	es
		pop	ds
		lea	si, [di+6]	; [di+BDS.bytespersec]
					; ds:si	-> bpb for hard	file
		jmp	short set_recbpb
; ---------------------------------------------------------------------------

nothardff:				
		push	cs
		pop	ds

; if fake floppy drive variable is set then we don't have to handle this bds.
; we can just go and deal with the next bds at label go_to_next_bds.

		; 10/12/2022
		; ds = cs
		; 17/10/2022 (ds=cs)
		cmp	byte [fakefloppydrv], 1
		;cmp	byte [cs:fakefloppydrv], 1
		jz	short go_to_next_bds
		cmp	bl, 7		; ffother
					; special case "other" type of medium
		jnz	short not_process_other
process_other:
		xor	dx, dx
		mov	ax, [di+25h]	; [di+BDS.cylinders]
		mul	word [di+36h]	; [di+BDS.rheads]
		mul	word [di+34h]	; [di+BDS.rsecpertrack]
		mov	[di+2Fh], ax	; [di+BDS.rtotalsecs16]
					; have the total number of sectors
		dec	ax
		mov	dl, 1
_again:					
		cmp	ax, 0FF6h	; 4096-10
		jb	short _@@
		shr	ax, 1
		shl	dl, 1
		jmp	short _again
; ---------------------------------------------------------------------------

_@@:					
		cmp	dl, 1		; is it	a small	disk ?
		jz	short __@@	; yes, 224 root	entries	is enuf
		mov	word [di+2Dh], 240 ; [di+BDS.rdirentries]
__@@:					
		mov	[di+29h], dl	; [di+BDS.rsecperclus]

; logic to get the sectors/fat area.
; fat entry is assumed to be 1.5 bytes!!!

		; 10/12/2022
		; ds = cs
		; 17/10/2022 (ds=cs)
		mul	word [word3]
		div	word [word2]
		xor	dx, dx
		div	word [word512]
		;
		; 10/12/2022
		;mul	word [cs:word3]	; * 3 ; mul word [cs:word3]
		;div	word [cs:word2]	; / 2 ; div word [cs:word2]
		;xor	dx, dx
		;div	word [cs:word512] ; / 512 ; div word [cs:word512]
		;
		inc	ax		; + 1
no_round_up:
		mov	[di+32h], ax	; [di+BDS.rfatsecs]
		jmp	short go_to_next_bds
; ---------------------------------------------------------------------------

not_process_other:			
		shl	bx, 1		; bx is	word index into	table of bpbs
		;mov	si, bpbtable
		;mov	si, [bpbtable+bx] ; 15/10/2022
		; 09/12/2022
		;mov	si, BPBTABLE
		;mov	si, [bx+si]	; get address of bpb
		; 10/12/2022
		;mov	si, [BPBTABLE+bx]
		; 13/12/2022
		mov	si, [SYSINITOFFSET+bpbtable+bx]
set_recbpb:				
		lea	di, [di+27h]	; [di+BDS.R_BPB]
					; es:di	-> recbpb
		mov	cx, 25		; bpbx.size
		rep movsb		; move (size bpbx) bytes	
go_to_next_bds:				
		pop	di
		pop	es		; restore pointer to bds
		les	di, [es:di]	; [es:di+BDS.link]
		cmp	di, 0FFFFh	; -1
		jz	short got_end_of_bds_chain
		jmp	_next_bds
; ---------------------------------------------------------------------------

		; 18/12/2022
;got_end_of_bds_chain:			
		;retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022
; 30/12/2018 - Retro DOS v4.0

; al = device number

print_init:	
		cbw
		mov	dx, ax
		mov	ah, 1
		int	17h		; PRINTER - INITIALIZE
					; DX = printer port (0-3)
					; Return: AH = status
got_end_of_bds_chain:	; 18/12/2022
		retn

; =============== S U B	R O U T	I N E =======================================

; al = device number

aux_init:
		cbw
		mov	dx, ax
		;mov	al, 0A3h	; RSINIT ; 0A3h
					; 2400,n,1,8 (msequ.inc)
		;mov	ah, 0
		; 10/12/2022
		mov	ax, 00A3h
		int	14h		; SERIAL I/O - INITIALIZE USART
					; 	AL = initializing parameters,
					;	DX = port number (0-3)
					; Return: AH = RS-232 status code bits,
					;	  AL = modem status bits
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022 (Modified MSDOS 5.0 IO.SYS)
; 30/12/2018 - Retro DOS v4.0
; 03/06/2018 - Retro DOS v3.0
; (19/03/2018 - Retro DOS v2.0)

; domini **********************************************************************
;
;mini disk initialization routine. called right after dohard
;modified for >2 hardfile support
;
; **cs=ds=es=datagrp
;
; **domini will search for every extended partition in the system, and
;   initialize it.
;
; **bdsm stands for bds table for mini disk and located right after the label
;   end96tpi. end_of_bdsm will have the offset value of the ending
;   address of bdsm table.
;
; **bdsm is the same as usual bds structure except that tim_lo, tim_hi entries
;   are overlapped and used to identify mini disk and the number of hidden_trks.
;   right now, they are called as ismini, hidden_trks respectively.
;
; **domini will use the same routine in sethard routine after label set2 to
;   save coding.
;
; **drvmax determined in dohard routine will be used for the next
;   available logical mini disk drive number.
;
; input: drvmax, dskdrvs
;
; output: minidisk installed. bdsm table established and installed to bds.
;	  end_of_bdsm - ending offset address of bdsm.
;
; called modules:
;		  getboot
;		  find_mini_partition (new), xinstall_bds (new), M038
;
;		  setmini (new, it will use set2 routine)
;
; variables used: end_of_bdsm
;		  rom_minidisk_num
;		  mini_hdlim, mini_seclim
;		  BDS_STRUC, start_bds
;
;******************************************************************************

		; 19/10/2022
domini:	
		mov	dh, [hnum]	; get number of hardfiles
		; 10/12/2022
		and	dh, dh
		;cmp	dh, 0
		jz	short dominiret	; no hard file?	then exit.
		mov	dl, 80h		; start	with hardfile 80h
domini_loop:				
		push	dx
		mov	[rom_minidisk_num], dl
		mov	ah, 8
		int	13h		; DISK - DISK -	GET CURRENT DRIVE PARAMETERS (XT,AT,XT286,CONV,PS)
					; DL = drive number
					; Return: CF set on error, AH =	status code, BL	= drive	type
					; DL = number of consecutive drives
					; DH = maximum value for head number, ES:DI -> drive parameter
		inc	dh
		xor	ax, ax
		mov	al, dh
		mov	[mini_hdlim], ax ; # of heads
		and	cl, 3Fh
		mov	al, cl
		mov	[mini_seclim], ax ; # of sectors/track
		push	es
		mov	dl, [rom_minidisk_num]
		call	getboot		; read master boot record into
					; initbootsegment:bootbias
		jb	short domininext
		call	find_mini_partition
domininext:				
		pop	es
		pop	dx
		inc	dl		; next hard file
		dec	dh
		jnz	short domini_loop
dominiret:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022 (Modified MSDOS 5.0 IO.SYS)
; 30/12/2018 - Retro DOS v4.0

;find_mini_partition tries to find every extended partition on a disk.
;at entry:	di -> bdsm entry
;		es:bx -> 07c0:bootbias - master boot record
;		rom_minidisk_num - rom drive number
;		drvmax - logical drive number
;		mini_hdlim, mini_seclim
;
;called routine: setmini which uses set2 (in sethard routine)
;variables & equates used from original bios - flags, fnon_removable, fbigfat


find_mini_partition:	
		add	bx, 1C2h	; bx ->	file system id
fmpnext:				
		cmp	byte [es:bx], 5 ; 5 = extended partition id.
		jz	short fmpgot
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short fmpnext
		;jmp	short fmpnextfound ; extended partition	not found
		; 18/12/2022
fmpnextfound:
		retn

;		; 30/07/2019 - Retro DOS v3.2
;		jb	short fmpnext
;fmpret:
;		retn	; 29/05/2019

; ---------------------------------------------------------------------------

		; 19/10/2022
fmpgot:					; found my partition.				
		call	dmax_check	; check	for drvmax already 26
		jnb	short fmpnextfound ; done if too many
		mov	di, [end_of_bdss] ; get next free	bds
		mov	word [di+47h], 1 ; [di+BDS.bdsm_ismini]
		; 10/12/2022
		or	byte [di+23h], 1
		;or	word [di+23h], 1 ; [di+BDS.flags]
					; fNon_Removable
		mov	byte [di+22h], 5 ; [di+BDS.formfactor]
					; ffHardFile
		mov	byte [fbigfat], 0 ; assume 12 bit fat.
		mov	ax, [mini_hdlim]
		mov	[di+15h], ax	; [di+BDS.heads]
		mov	ax, [mini_seclim]
		mov	[di+13h], ax	; [di+BDS.secpertrack]
		mov	al, [rom_minidisk_num]
		mov	[di+4],	al	; [di+BDS.drivenum]
					; set physical number
		mov	al, [drvmax]
		mov	[di+5],	al	; [di+BDS.drivelet]
					; set logical number
		cmp	word [es:bx+10], 0
		ja	short fmpgot_cont
		cmp	word [es:bx+8], 64 ; with current bpb,
					; only lower word is meaningful.
		jb	short fmpnextfound
					; should be bigger than 64 sectors at least
fmpgot_cont:				
		sub	bx, 4		; let bx point to the start of the entry
		mov	dh, [es:bx+2]	; cylinder
		and	dh, 0C0h	; get higher bits of cyl
		rol	dh, 1
		rol	dh, 1
		mov	dl, [es:bx+3]	; cyl byte
		mov	[di+49h], dx	; [di+BDS.bdsm_hidden_trks]
					; set hidden trks
		mov	cx, [es:bx+2]	; cylinder,cylinder/sector
		mov	dh, [es:bx+1]	; head
		mov	dl, [rom_minidisk_num]
		mov	bx, 200h	; bootbias
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		jb	short fmpnextfound
		mov	bx, 3C2h	; 1C2h+bootbias
		push	es
		call	setmini		; install a mini disk.
					; bx value saved.
		pop	es
		jb	short fmpnextchain
		call	xinstall_bds	; -- install the bdsm into table
fmpnextchain:				
		jmp	fmpnext		; let's find out
					; if we	have any chained partition
; ---------------------------------------------------------------------------

		; 18/12/2022
;fmpnextfound:				
		;retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 28/12/2018 - Retro DOS v4.0 (MSDOS 6.21)

setmini:	; 'setmini' is called from 'find_mini_partition' procedure
	
		push	di
		push	bx
		push	ds
		push	es
setmini_1:				
		cmp	byte [es:bx], 1 ; FAT12 partition
		jz	short setmini_2
		cmp	byte [es:bx], 4 ; FAT16 partition
		jz	short setmini_2
		cmp	byte [es:bx], 6 ; FAT16 BIG	partition
		jz	short setmini_2
		add	bx, 16
		cmp	bx, 402h	; 202h+bootbias
		jnz	short setmini_1
		stc
		pop	es
		pop	ds
		pop	bx
		pop	di
		retn

; ---------------------------------------------------------------------------
setmini_2:				
		jmp	set2		; branch into middle of sethard

; =============== S U B	R O U T	I N E =======================================

; 30/12/2022 - Retro DOS v4.2
; (SYSINITSEG is 473h for MSDOS 6.21 IO.SYS) 

; 15/10/2022
; 28/12/2018 - Retro DOS v4.0
;
; dmax_check --- call this when we want to install a new drive.
;		it checks for drvmax < 26 to see if there is
;		a drive letter left.
;
;	drvmax < 26 : carry SET!
;	drvmax >=26 : carry RESET!, error flag set for message later
;			trash ax

dmax_check:	
		cmp	byte [drvmax], 26 ; checks for drvmax < 26
		jb	short dmax_ok	; return with carry if okay
		push	es
		;mov	ax, 46Dh	; SYSINIT_SEG (SYSINIT segment)
		mov	ax, SYSINITSEG	; 17/10/2022	
		mov	es, ax
		; 18/10/2022
		mov	byte [es:TOOMANYDRIVESFLAG], 1 ; 09/12/2022 
		;mov	byte ptr es:3FFh, 1 ; [es:toomanydrivesflag]
					; set message flag
					; [SYSINIT+toomanydrivesflag]
		pop	es

		;;push	es
		;;mov	ax,SYSINIT_SEG
		;;mov	es,ax
		;;mov	byte [es:toomanydrivesflag],1
					; set message flag
		;;pop	es
		;
		;mov	byte [SYSINIT+toomanydrivesflag],1
dmax_ok:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 18/10/2022
; 15/10/2022
; 28/12/2018 - Retro DOS v4.0						
;								 
;	link next bds (at ds:di) into the chain. assume that the
;	  chain is entirely within ds == datagrp. also update drvmax,
;	  dskdrv_table, and end_of_bdss.	

xinstall_bds:		
		push	si
		push	bx
		mov	si, [start_bds]	; get first bds
xinstall_bds_1:				
		cmp	word [si], 0FFFFh ; is this the last one?
		jz	short xinstall_bds_2 ;	skip ahead if so
		;mov	si, [si+BDS.link]
		mov	si, [si]	; chain	through	list
		jmp	short xinstall_bds_1
; ---------------------------------------------------------------------------

xinstall_bds_2:				
		;mov	[si+BDS.link], di
		mov	[si], di
		;mov	[si+BDS.link+2], ds
		mov	[si+2], ds
		;mov	word [di+BDS.link], -1
		mov	word [di], 0FFFFh ; make sure it is a null ptr.
		;mov	[di+BDS.link+2], ds
		mov	[di+2], ds ; might as well plug segment
		; 20/03/2019 - Retro DOS v4.0
		;lea	bx, [di+BDS.BPB]
		lea	bx, [di+6]
		mov	si, [last_dskdrv_table]
		mov	[si], bx
		add	word [last_dskdrv_table], 2
		inc	byte [drvmax]
		add	word [end_of_bdss], 100 ; BDS.size = 100
		pop	bx
		pop	si
		retn

; =============== S U B	R O U T	I N E =======================================

; 17/10/2022
; 15/10/2022
; 28/12/2018 - Retro DOS v4.0
; 03/06/2018 - Retro DOS v3.0

cmos_clock_read:	
		push	ax
		push	cx
		push	dx
		push	bp
		xor	bp, bp
loop_clock:				
		xor	cx, cx
		xor	dx, dx
		mov	ah, 2
		int	1Ah		; CLOCK	- READ REAL TIME CLOCK (AT,XT286,CONV,PS)
					; Return: CH = hours in	BCD
					; CL = minutes in BCD
					; DH = seconds in BCD
		cmp	cx, 0
		jnz	short clock_present
		cmp	dx, 0
		jnz	short clock_present
		cmp	bp, 1		; read again after a slight delay, in case clock
		jz	short no_readdate ; was	at zero	setting.
		inc	bp		; only perform delay once.
		mov	cx, 4000h	; 16384
delay:					
		loop	delay
		jmp	short loop_clock
; ---------------------------------------------------------------------------

clock_present:				
		mov	byte [cs:havecmosclock], 1 ; set the flag for cmos clock
		call	cmosck		; reset	cmos clock rate	that may be
					; possibly destroyed by	cp dos and
					; post routine did not restore that.
		push	si
		call	read_real_date	; read real-time clock for date
		cli
		;mov	ds:daycnt, si	; set system date
		mov	[daycnt], si
		sti
		pop	si

no_readdate:				
		pop	bp
		pop	dx
		pop	cx
		pop	ax
		retn

; ---------------------------------------------------------------------------

; the following code is written by jack gulley in engineering group.
; cp dos (CP/DOS, OS/2) is changing cmos clock rate for its own purposes
; and if the use cold boot the system to use pc dos while running cp dos,
; the cmos clock rate are still slow which slow down disk operations
; of pc dos which uses cmos clock. pc dos is put this code in msinit
; to fix this problem at the request of cp dos.
;
; the program is modified to be run on msinit. equates are defined
; in cmosequ.inc. this program will be called by cmos_clock_read procedure.
;
;  the following code cmosck is used to insure that the cmos has not
;	had its rate controls left in an invalid state on older at's.
;
;	it checks for an at model byte "fc" with a submodel type of
;	00, 01, 02, 03 or 06 and resets the periodic interrupt rate
;	bits in case post has not done it. this initilization routine
;	is only needed once when dos loads. it should be run as soon
;	as possible to prevent slow diskette access.
;
;	this code exposes one to dos clearing cmos setup done by a
;	resident program that hides and re-boots the system.

cmosck:					; check and reset rtc rate bits	

;model byte and submodel byte were already determined in msinit.

	; 16/06/2018 - Retro DOS v3.0
	; 19/03/2018 (Model: 0FCh, Sub Model: 01h, REF: AMIBIOS Prog. Guide)
			
		push	ax
		cmp	byte [cs:model_byte], 0FCh
		jnz	short cmosck9	; Exit if not an AT model
		cmp	byte [cs:secondary_model_byte], 6
					; Is it 06 for the industral AT ?
		jz	short cmosck4	; Go reset CMOS	periodic rate if 06
		cmp	byte [cs:secondary_model_byte], 4
					; Is it 00, 01, 02, or 03 ?
		jnb	short cmosck9	; EXIT if problem fixed by POST  
					; Also,Secondary_model_byte = 0 
					;   when AH=0C0h, int 15h failed.
					;	RESET THE CMOS PERIODIC RATE 
					;  Model=FC submodel=00,01,02,03 or 06 
cmosck4:				
		mov	al, 8Ah		; cmos_reg_a|nmi
					; NMI disabled on return
		mov	ah, 26h		; 00100110b
					; Set divider &	rate selection
		call	cmos_write
		mov	al, 8Bh		; cmos_reg_b|nmi
					; NMI disabled on return
		call	cmos_read
		and	al, 7		; 00000111b
					; clear	SET,PIE,AIE,UIE,SQWE
		mov	ah, al
		mov	al, 0Bh		; cmos_reg_b
					; NMI enabled on return
		call	cmos_write
cmosck9:				
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

;--- CMOS_READ -----------------------------------------------------------------
;		read byte from cmos system clock configuration table	       :
;									       :
; input: (al)=	cmos table address to be read				       :
;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
;		bits 6-0 = address of table location to read		       :
;									       :
; output: (al)	value at location (al) moved into (al). if bit 7 of (al) was   :
;		on then nmi left disabled.  during the cmos read both nmi and  :
;		normal interrupts are disabled to protect cmos data integrity. :
;		the cmos address register is pointed to a default value and    :
;		the interrupt flag restored to the entry state on return.      :
;		only the (al) register and the nmi state is changed.	       :
;-------------------------------------------------------------------------------

cmos_read:				; read location (al) into (al)	
		pushf
		cli
		push	bx
		push	ax		; AL = cmos table address to be	read
		or	al, 80h
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop			; (undocumented	delay needed)
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	bx, ax
		pop	ax
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		mov	ax, bx
		pop	bx
		push	cs		; *place code segment in stack and
		call	cmos_popf	; *handle popf for b- level 80286
		retn			; return with flags restored

; ---------------------------------------------------------------------------

cmos_popf:				
		iret			; popf for level b- parts
					; return far and restore flags

; =============== S U B	R O U T	I N E =======================================

;--- cmos_write ----------------------------------------------------------------
;		write byte to cmos system clock configuration table	       :
;									       :
; input: (al)=	cmos table address to be written to			       :
;		bit    7 = 0 for nmi enabled and 1 for nmi disabled on exit    :
;		bits 6-0 = address of table location to write		       :
;	 (ah)=	new value to be placed in the addressed table location	       :
;									       :
; output:	value in (ah) placed in location (al) with nmi left disabled   :
;		if bit 7 of (al) is on. during the cmos update both nmi and    :
;		normal interrupts are disabled to protect cmos data integrity. :
;		the cmos address register is pointed to a default value and    :
;		the interrupt flag restored to the entry state on return.      :
;		only the cmos location and the nmi state is changed.	       :
;-------------------------------------------------------------------------------

cmos_write:				; write (ah) to location (al)	
		pushf			; write (ah) to location (al)
		push	ax		; save work register values
		cli
		push	ax		; save user nmi	state
		or	al, 80h		; disable nmi for us
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		mov	al, ah
		out	71h, al		; CMOS Memory/RTC Data Register
		pop	ax		; get user nmi
		and	al, 80h
		or	al, 0Fh
		out	70h, al		; CMOS Memory/RTC Index	Register:
					; RTC Seconds
		nop
		in	al, 71h		; CMOS Memory/RTC Data Register
		pop	ax		; restore work registers
		push	cs		; *place code segment in stack and
		call	cmos_popf	; *handle popf for b- level 80286
		retn

; ---------------------------------------------------------------------------
; MSINIT.ASM (MSDOS 6.0, 1991)
; ---------------------------------------------------------------------------
; The following routines provide support for reading in the file MSDOS.SYS.
; ---------------------------------------------------------------------------

; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
;
; (For Retro DOS, 'IO.SYS' and 'MSDOS.SYS' are already loaded together
;  at once -as single kernel file- by the Retro DOS boot sector code.
;  So, following disk reads -MSDOS.SYS loading- is not needed!
;  Only needing is to move MSDOS Kernel to it's final memory location.) 

; =============== S U B	R O U T	I N E =======================================

; GetClus, read in a cluster at a specified address
;
;  bx = cluster to read
;  cx = sectors per cluster
;  es:di = load location

; 17/10/2022
;DISKRD equ diskrd - DOSBIOSEG_2C7h	; (8E5h for MSDOS 5.0 IO.SYS)
; 09/12/2022
DISKRD equ diskrd

		; 17/10/2022
getclus:				
		push	cx
		push	di
		mov	[cs:doscnt], cx
		mov	ax, bx
		dec	ax
		dec	ax
		mul	cx		; convert to logical sector
					; dx:ax	= matching logical sector number
					;	  starting from the data sector
		add	ax, [cs:bios_l]
		adc	dx, [cs:bios_h]	; dx:ax	= first	logical	sector to read
unpack:					
		push	ds
		push	ax
		push	bx
		mov	si, [cs:fatloc]
		mov	ds, si
		mov	si, bx		; next cluster
		test	byte [cs:fbigfat], 40h	; fbig
					; 16 bit fat?
		jnz	short unpack16	; yes
		shr	si, 1		; 12 bit fat. si=si/2
					; si = clus + clus/2
		add	si, bx		;
					; (si =	byte offset of the cluster in the FAT)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		mov	ax, [bx]	; save it into ax
		jnz	short even_odd	; if not a splitted fat, check even-odd.
		; 25/06/2023
		;mov	al, [bx]	; splitted fat
		mov	[cs:temp_cluster], al
		inc	si		; (next	byte)
		push	dx
		xor	dx, dx
		call	get_fat_sector
		pop	dx
		;mov	al, ds:0
		mov	al, [0] ; 19/10/2022
		mov	[cs:temp_cluster+1], al
		mov	ax, [cs:temp_cluster]
even_odd:				
		pop	bx		; restore old fat entry	value
		push	bx		; save it right	away.
		shr	bx, 1		; was it even or odd?
		jnb	short havclus	; it was even.
		shr	ax, 1		; odd. massage fat value and keep
					; the highest 12 bits.
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
havclus:				
		mov	bx, ax		; now bx = new fat entry.
		and	bx, 0FFFh	; keep low 12 bits.
		jmp	short unpackx
; ---------------------------------------------------------------------------

unpack16:				
		push	dx
		xor	dx, dx
		shl	si, 1		; extend to 32 bit offset
		adc	dx, 0
		call	get_fat_sector
		pop	dx
		mov	bx, [bx]	;
					; bx = new fat entry.
unpackx:				
		pop	si		; restore old bx value into si
		pop	ax		; restore logical sector (low)
		pop	ds
		sub	si, bx
		cmp	si, -1		; one apart?
		jnz	short getcl2
		add	[cs:doscnt], cx
		jmp	short unpack
; ---------------------------------------------------------------------------

getcl2:					
		push	bx
		push	dx		; sector to read (high)
		push	ax		; sector to read (low)
		mov	ax, [cs:drvfat]	; get drive and	fat spec
		mov	cx, [cs:doscnt]
		pop	dx		; sector to read for diskrd (low)
		pop	word [cs:start_sec_h]
					; sector to read for diskrd (high)
		push	ds
		push	cs
		pop	ds
		push	cs		; simulate far call
		; 17/10/2022
		mov	bp, DISKRD	; 8E5h
		;mov	bp, 8E5h	; offset diskrd
					; 2C7h:8E5h = 70h:2E55h
		call	call_bios_code	; read the clusters
		pop	ds
		pop	bx
		pop	di
		mov	ax, [cs:doscnt]	; get number of	sectors	read
		xchg	ah, al		; multiply by 256
		shl	ax, 1		; times	2 equal	512
		add	di, ax		; update load location
		pop	cx		; restore sectors/cluster
		retn

; =============== S U B	R O U T	I N E =======================================


;function: find and read the corresponding fat sector into ds:0
;
;in). dx:si - offset value (starting from fat entry 0) of fat entry to find. M054
;     ds - fatloc segment
;     cs:drvfat - logical drive number, fat id
;     cs:md_sectorsize
;     cs:last_fat_secnum - last fat sector number read in.
;
;out). corresponding fat sector read in.
;      bx = offset value from fatlog segment.
;      other registera saved.
;      zero flag set if the fat entry is splitted, i.e., when 12 bit fat entry
;      starts at the last byte of the fat sector. in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value. (this will only happen with the 12 bit fat.)

		; 17/10/2022
get_fat_sector:	
		push	ax
		push	cx
		push	di
		push	si
		push	es
		push	ds
		mov	ax, si
		mov	cx, [cs:md_sectorsize] ; 512
		div	cx		; ax = sector number, dx = offset
		nop

		; Get rid of the assumption that
		; there	is only	one reserved sector

		push	es
		push	ds
		push	di
		push	ax
		push	cs
		pop	ds

		mov	ax, [cs:drvfat]	; get drive # and FAT id
		mov	bp, SETDRIVE
		;mov	bp, 4D7h	; setdrive
					; at 2C7h:4D7h = 70h:2A47h
		push	cs		; simulate far call
		call	call_bios_code	; get bds for drive
		pop	ax		; (sector number -without reserved and hidden sectors-)
		add	ax, [es:di+9]	; [es:di+BDS.resectors]
					; add #reserved_sectors
		pop	di
		pop	ds
		pop	es
		cmp	ax, [cs:last_fat_sec_num]
		jz	short gfs_split_chk ; don't need to read it again.
		mov	[cs:last_fat_sec_num], ax 
					; sector number
					; (in the partition, without hidden sectors)
		push	dx
		mov	word [cs:start_sec_h], 0 
					; prepare to read the fat sector
					; start_sec_h is always	0 for fat sector.
		mov	dx, ax
		mov	cx, 1		; 1 sector read
		mov	ax, [cs:drvfat]
		push	ds
		pop	es
		xor	di, di		; es:di	-> fatloc segment:0
		push	ds
		push	cs
		pop	ds
		push	cs		; simulate far call
		mov	bp, DISKRD	; 8E5h
		;mov	bp, 8E5h	; offset diskrd
					; 2C7h:8E5h = 70h:2E55h
		call	call_bios_code
		pop	ds
		pop	dx
		mov	cx, [cs:md_sectorsize] ; 512

gfs_split_chk:				
		dec	cx		; 511
		cmp	dx, cx		; if offset points to the
					; last byte of this sector,
					; then splitted	entry.
		mov	bx, dx		; set bx to dx
		pop	ds
		pop	es
		pop	si
		pop	di
		pop	cx
		pop	ax
		retn

; 15/10/2022
;Bios_Data_Init	ends

; ---------------------------------------------------------------------------

		; 09/12/2022
		;db 0

numbertodiv	equ ($-BData_start)
numbertomod	equ (numbertodiv % 16)

%if numbertomod>0 & numbertomod<16
		times (16-numbertomod) db 0
%endif

;align 16

; 09/12/2022
IOSYSCODESEGOFF	equ $ - BData_start
IOSYSCODESEG	equ (IOSYSCODESEGOFF>>4)+(700h>>4)

;--- End of DOSBIOS data segment --------------------------------------------
; ---------------------------------------------------------------------------
		;db 4 dup(0)
; 09/12/2022		
;		times 4 db 0	; 19/10/2022
; ---------------------------------------------------------------------------

;============================================================================
; DOS BIOS (IO.SYS) CODE SEGMENT 
;============================================================================
; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

section .BIOSCODE vstart=0 

; 30/12/2022
; (BIOSCODE SEGMENT is 2CCh for MSDOS 6.21 IO.SYS)  -- ((25C0h+700h)>>4) --

BCode_start:	 ; 09/12/2022
 
; 02/10/2022

;--- DOSBIOS code segment ---------------------------------------------------
;----------------------------------------------------------------------------
; MSBIO1.ASM (MSDOS 6.0, 1991)
;----------------------------------------------------------------------------

DOSBIOSEG_2C7h:	;db 30h dup(0)		; SEGMENT 2C7h (2C70h-700h=2570h)
		times 48 db 0		; 19/10/2022	
BiosDataWord:	dw 70h

; 15/10/2022
;BIOSDATAWORD	equ BiosDataWord - DOSBIOSEG_2C7h
; 09/12/2022
BIOSDATAWORD	equ BiosDataWord

; ---------------------------------------------------------------------------

; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS) 

;************************************************************************
;*									*
;*	seg_reinit is called with ax = our new code segment value,	*
;*	  trashes di, cx, es						*
;*									*
;*	cas -- should be made disposable!				*
;*									*
;************************************************************************

_seg_reinit:
		mov	es, [cs:BIOSDATAWORD]
					; at 2C7h:30h or 70h:25A0h
		;mov	di, (offset cdev+2)
		mov	di, cdev+2	; 19/10/2022
		mov	cx, 4		; (end_BC_entries - cdev)/4

_seg_reinit_1:				
		stosw			; modify Bios_Code entry points
		inc	di
		inc	di
		loop	_seg_reinit_1
		retf

; ---------------------------------------------------------------------------

; 15/10/2022

;************************************************************************
;*									*
;*	chardev_entry - main device driver dispatch routine		*
;*	   called with a dummy parameter block on the stack		*
;*	   dw dispatch_table, dw prn/aux numbers (optional)		*
;*									*
;*	will eventually take care of doing the transitions in		*
;*	   out of Bios_Code						*
;*									*
;************************************************************************

chardev_entry:				; 0070h:25B3h =	02C7h:0043h
		push	si
		push	ax
		push	cx
		push	dx
		push	di
		push	bp
		push	ds
		push	es
		push	bx
		mov	bp, sp
		mov	si, [bp+18]	; get return address (dispatch table)
		;;mov	ds, word [cs:0030h]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
		mov	ax, [si+2]	; get the device number	if present
		mov	[auxnum], al
		mov	[printdev], ah
		mov	si, [si]	; point	to the device dispatch table
		les	bx, [ptrsav]	; get pointer to i/o packet
		mov	al, [es:bx+1]	; [es:bx+unit]	; al = unit code
		mov	ah, [es:bx+13]	; [es:bx+media]	; ah = media descrip
		mov	cx, [es:bx+18]	; [es:bx+count]	; cx = count
		mov	dx, [es:bx+20]	; [es:bx+start]	; dx = start sector
		; 17/10/2022
		cmp	si, DSKTBL
		;cmp	si, 4A2h	; dsktbl
					; at 2C7h:4A2h = 70h:2A12h
		jnz	short no_sector32_mapping

; Special case for 32-bit start sector number:
;   if (si==dsktbl) /* if this is a disk device call */
;      set high 16 bits of secnum to 0
;      if (secnum == 0xffff) fetch 32 bit sector number
;
; pass high word of sector number in start_sec_h, low word in dx
;
; note: start_l and start_h are the offsets within the io_request packet
;	  which contain the low and hi words of the 32 bit start sector if
;	  it has been used.
;
; note: remember not to destroy the registers which have been set up before

		;mov	ds:start_sec_h,	0 ; initialize to 0
		mov	word [start_sec_h], 0
		cmp	dx, 0FFFFh
		jnz	short no_sector32_mapping
		mov	dx, [es:bx+28]	; [es:bx+start_h]
					; 32 bits dsk req
		;mov	ds:start_sec_h,	dx ; start_sec_h = packet.start_h
		mov	[start_sec_h], dx
		mov	dx, [es:bx+26]	; [es:bx+start_l]
					; dx = packet.start_l
no_sector32_mapping:			
		xchg	ax, di
		mov	al, [es:bx+2]	; [es:bx+cmd]
		cmp	al, cs:[si]
		jnb	short command_error
		cbw			; note that al <= 15 means ok
		shl	ax, 1
		add	si, ax
		xchg	ax, di
		les	di, [es:bx+14]	; [es:bx+trans]
		cld
		; 17/10/2022
		call	near [cs:si+1]
		;call	word ptr cs:si+1
		jb	short already_got_ah_status
		mov	ah, 1
already_got_ah_status:
		;;mov	ds, [cs:0030h]	; 15/10/2022			
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
					; cas note: shouldn't be needed!
		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
		;lds	bx, ds:ptrsav
		lds	bx, [ptrsav]
		mov	[bx+3],	ax	; [bx+status]
					; mark operation complete
		pop	bx
		pop	es
		pop	ds
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ax
		pop	si
		add	sp, 2		; get rid of fake return address
	
		; fall through into bc_retf
; ---------------------------------------------------------------------------	
bc_retf:
		retf
; ---------------------------------------------------------------------------

command_error:				
		call	bc_cmderr
		jmp	short already_got_ah_status
; 15/10/2022
; 01/05/2019

;----------------------------------------------------------------------------
; The following piece of hack is for supporting CP/M compatibility
; Basically at offset 5 we have a far call into 0:c0. But this does not call
; 0:c0 directly instead it call f01d:fef0, because it needs to support 'lhld 6'
; The following hack has to reside at ffff:d0 (= f01d:fef0) if BIOS is loaded
; high.
;----------------------------------------------------------------------------

		;db 7 dup(0)

		; 15/10/2022

		dw 0		; pad to bring offset to 0D0h

off_d0: 	times 5 db 0	; 5 bytes from 0:c0 will be copied onto here
				;  which is the CP/M call 5 entry point
		

; ---------------------------------------------------------------------------

;	exit - all routines return through this path

bc_cmderr:				
		mov	al, 3		; 2C7h:D5h = 70h:2645h
					; unknown command error

; =============== S U B	R O U T	I N E =======================================

;	now zero the count field by subtracting its current value,
;	  which is still in cx, from itself.

;	subtract the number of i/o's NOT YET COMPLETED from total
;	  in order to return the number actually complete

bc_err_cnt:	
		;les	bx, ds:ptrsav
		; 19/10/2022
		les	bx, [ptrsav]
		sub	[es:bx+18], cx	; [es:bx+count]
					; # of successful i/o's
		mov	ah, 81h		; mark error return
		stc			; indicate abnormal end
		retn

; 15/10/2022

;Bios_Code ends

;----------------------------------------------------------------------------
; MSCHAR.ASM - MSDOS 6.0 - 1991
;----------------------------------------------------------------------------
; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 10/01/2019 - Retro DOS v4.0

; 30/04/2019

;title	mschar - character and clock devices

;MODE_CTRLBRK	equ	0FFh

; BIOSCODE:00E4h (MSDOS 6.21, IO.SYS)

;************************************************************************
;*									*
;*	device driver dispatch tables					*
;*									*
;*	each table starts with a byte which lists the number of		*
;*	legal functions, followed by that number of words. Each		*
;*	word represents an offset of a routine in Bios_Code which	*
;*	handles the function. The functions are terminated with		*
;*	a near return. If carry is reset, a 'done' code is returned	*
;*	to the caller. If carry is set, the ah/al registers are		*
;*	returned as abnormal completion status. Notice that ds		*
;*	is assumed to point to the Bios_Data segment throughout.	*
;*									*
;************************************************************************

		; 13/12/2022
		;db 0

		; 13/12/202
con_table:	db ((con_table_end - con_table)-1)/2 ; 11
					; 2C7h:0E4h = 70h:2654h
		dw bc_exvec  ; 1FBh	; bc_exvec at 2C7h:1FBh	= 70h:276Bh
					; 00 init
		dw bc_exvec  ; 1FBh	; 01
		dw bc_exvec  ; 1FBh	; 02
		dw bc_cmderr ; 0D5h	; bc_exvec at 2C7h:D5h = 70h:2645h
					; 03
		dw con_read  ; 15Ch	; con_read at 2C7h:15Ch	= 70h:26CCh
					; 04
		dw con_rdnd  ; 19Fh	; con_rdnd at 2C7h:19Fh	= 70h:270Fh
					; 05
		dw bc_exvec  ; 1FBh	; 06
		dw con_flush ; 209h	; con_flush at 2C7h:209h = 70h:2779h
					; 07
		dw con_writ  ; 1FDh	; con_writ at 2C7h:1FDh	= 70h:276Dh
					; 08
		dw con_writ  ; 1FDh	; 09
		dw bc_exvec  ; 1FBh	; 0A
con_table_end:
prn_table:	db ((prn_table_end - prn_table)-1)/2 ; 26			
					; 2C7h:0FBh = 70h:266Bh
		dw bc_exvec   ; 1FBh	; bc_exvec
		dw bc_exvec   ; 1FBh	; 01
		dw bc_exvec   ; 1FBh	; 02
		dw bc_cmderr  ;	0D5h	; bc_cmderr
		dw prn_input  ;	21Ah	; prn_input
					; 04 indicate zero chars read
		dw z_bus_exit ; 1C8h	; z_bus_exit
					; 05 read non-destructive
		dw bc_exvec   ; 1FBh	; 06
		dw bc_exvec   ; 1FBh	; 07
		dw prn_writ   ;	21Fh	; prn_writ
		dw prn_writ   ; 21Fh	; 09
		dw prn_stat   ; 251h	; prn_stat
		dw bc_exvec   ; 1FBh	; 0B
		dw bc_exvec   ; 1FBh	; 0C
		dw bc_exvec   ; 1FBh	; 0D
		dw bc_exvec   ; 1FBh	; 0E
		dw bc_exvec   ; 1FBh	; 0F
		dw prn_tilbusy ; 28Bh	; prn_tilbusy
		dw bc_exvec   ; 1FBh	; 11
		dw bc_exvec   ; 1FBh	; 12
		dw prn_genioctl ; 2BAh	; prn_genioctl
		dw bc_exvec   ; 1FBh	; 14
		dw bc_exvec   ; 1FBh	; 15
		dw bc_exvec   ; 1FBh	; 16
		dw bc_exvec   ; 1FBh	; 17
		dw bc_exvec   ; 1FBh	; 18
		dw prn_ioctl_query ; 2F0h ; prn_ioctl_query
prn_table_end:
aux_table:	db ((aux_table_end - aux_table)-1)/2 ; 11			
					; 2C7h:130h = 70h:26A0h
		dw bc_exvec   ; 1FBh	; 00 - init
		dw bc_exvec   ; 1FBh	; 01
		dw bc_exvec   ; 1FBh	; 02
		dw bc_cmderr  ;	0D5h	; 03
		dw aux_read   ; 30Dh	; aux_read ; 04	- read
		dw aux_rdnd   ; 335h	; aux_rdnd - 05	- read non-destructive
		dw bc_exvec   ; 1FBh	; 06
		dw aux_flsh   ;	36Ch	; aux_flsh
		dw aux_writ   ;	374h	; aux_writ
		dw aux_writ   ;	374h	; 09
		dw aux_wrst   ;	355h	; aux_wrst
aux_table_end:
tim_table	db ((tim_table_end - tim_table)-1)/2 ; 10
					; 2C7h:147h = 70h:26B7h
		dw bc_exvec   ; 1FBh	; 00
		dw bc_exvec   ; 1FBh	; 01
		dw bc_exvec   ; 1FBh	; 02
		dw bc_cmderr  ;	0D5h	; 03
		dw tim_read   ;	435h	; tim_read
		dw z_bus_exit ; 1C8h	; z_bus_exit
		dw bc_exvec   ; 1FBh	; 06
		dw bc_exvec   ; 1FBh	; 07
		dw tim_writ   ; 3DBh	; tim_writ
		dw tim_writ   ; 3DBh	; 09
tim_table_end:

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	con_read - read cx bytes from keyboard into buffer at es:di	*
;*									*
;************************************************************************

con_read:				; 2C7h:15Ch = 70h:26CCh
		;jcxz	short con_exit	; read cx bytes	from keyboard into buffer
		jcxz	con_exit	; 19/10/2022
con_loop:				
		call	chrin		; get char in al
		stosb			; store	char at	es:di
		loop	con_loop
con_exit:				
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

;************************************************************************
;*									*
;*	chrin - input single char from keyboard into al			*
;*									*
;*	  we are going to issue extended keyboard function, if		*
;*	  supported. the returning value of the extended keystroke	*
;*	  of the extended keyboard function uses 0E0h in al		*
;*	  instead of 00h as in the conventional keyboard function.	*
;*	  this creates a conflict when the user entered real		*
;*	  greek alpha charater (= 0E0h) to  distinguish the extended	*
;*	  keystroke and the greek alpha. this case will be handled	*
;*	  in the following manner:					*
;*									*
;*	      ah = 16h							*
;*	      int 16h							*
;*	      if al == 0, then extended code (in ah)			*
;*	      else if al == 0E0h, then					*
;*	      if ah <> 0, then extended code (in ah)			*
;*		else greek_alpha character.				*
;*									*
;*	also, for compatibility reason, if an extended code is		*
;*	  detected, then we are going to change the value in al		*
;*	  from 0E0h to 00h.						*
;*									*
;************************************************************************

		; 19/10/2022
chrin:		
		mov	ah, [keyrd_func] ; set by msinit. 0 or 10h
		xor	al, al
		xchg	al, [altah]	; get character	& zero altah
		or	al, al
		jnz	short keyret
		int	16h		; KEYBOARD -
		or	ax, ax
		jz	short chrin
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short alt_ext_chk
		mov	al, 10h
		jmp	short keyret
; ---------------------------------------------------------------------------

;  if operation was extended function (i.e. keyrd_func != 0) then
;    if character read was 0E0h then
;      if extended byte was zero (i.e. ah == 0) then
;	 goto keyret
;      else
;	 set al to zero
;	 goto alt_save
;      endif
;    endif
;  endif

alt_ext_chk:
		cmp	byte [keyrd_func], 0
		jz	short not_ext
		cmp	al, 0E0h
		jnz	short not_ext
		or	ah, ah
		jz	short keyret
		xor	al, al
		jmp	short alt_save
; ---------------------------------------------------------------------------

not_ext:				
		or	al, al		; special case?
		jnz	short keyret
alt_save:				
		mov	[altah], ah	; store	special	key
keyret:					
		retn

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	con_rdnd - keyboard non destructive read, no wait		*
;*									*
;*	pc-convertible-type machine: if bit 10 is set by the dos	*
;*	in the status word of the request packet, and there is no	*
;*	character in the input buffer, the driver issues a system	*
;*	wait request to the rom. on return from the rom, it returns	*
;*	a 'char-not-found' to the dos.					*
;*									*
;************************************************************************

		; 19/10/2022
con_rdnd:				
		mov	al, [altah]
		or	al, al
		jnz	short rdexit
		mov	ah, [keysts_func]
		int	16h		; KEYBOARD -
		jnz	short gotchr
		cmp	byte [fhavek09], 0
		jz	short z_bus_exit
		les	bx, [ptrsav]
		; 12/12/2022
		test	byte [es:bx+4], 04h
		;test	word [es:bx+3], 400h ; [es:bx+status]
		jz	short z_bus_exit
		mov	ax, 4100h
		xor	bl, bl
		int	15h		; SYSTEM - WAIT	ON EXTERNAL EVENT (CONVERTIBLE)
					; AL = condition type, BH = condition compare or mask value
					; BL = timeout value times 55 milliseconds, 00h	means no timeout
					; DX = I/O port	address	if AL bit 4 set
z_bus_exit:				
		stc			; 2C7h:1C8h = 70h:2738h
		mov	ah, 3		; indicate busy	status
		retn
; ---------------------------------------------------------------------------

gotchr:					
		or	ax, ax
		jnz	short notbrk	; check	for null after break
		mov	ah, [keyrd_func] ; issue keyboard read function
		int	16h		; KEYBOARD -
		jmp	short con_rdnd	; get a	real status
; ---------------------------------------------------------------------------

notbrk:					
		cmp	ax, 7200h	; check	for ctrl-prtsc
		jnz	short rd_ext_chk
		mov	al, 10h		; ('P' & 1Fh) ; return control p
		jmp	short rdexit
; ---------------------------------------------------------------------------

rd_ext_chk:				
		cmp	byte [keyrd_func], 0 ; extended keyboard function?
		jz	short rdexit
		cmp	al, 0E0h	; extended key value or	greek alpha?
		jnz	short rdexit
		cmp	ah, 0		; scan code exist?
		jz	short rdexit	; yes. greek alpha char.
		mov	al, 0		; no. extended key stroke.
					; change it for	compatibility
rdexit:					
		les	bx, [ptrsav]
		mov	[es:bx+13], al	; [es:bx+media]
					; return keyboard character here
bc_exvec:				
		clc			; bc_exvec at 2C7h:1FBh	= 70h:276Bh
					; indicate normal termination
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	con_write - console write routine				*
;*									*
;*	entry:	es:di -> buffer						*
;*		cx    =  count						*
;*									*
;************************************************************************

con_writ:
		;jcxz	short bc_exvec
		jcxz	bc_exvec	; 19/10/2022
		; 12/12/2022
		;jcxz	cc_ret
con_lp:					
		mov	al, [es:di]
		inc	di
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		loop	con_lp
cc_ret:					
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

;************************************************************************
;*									*
;*	con_flush - flush out keyboard queue				*
;*									*
;************************************************************************

con_flush:
		mov	byte [altah], 0	; clear	out holding buffer
flloop:					; while	(charavail()) charread();	
		mov	ah, 1
		int	16h		; KEYBOARD - CHECK BUFFER, DO NOT CLEAR
					; Return: ZF clear if character	in buffer
					; AH = scan code, AL = character
					; ZF set if no character in buffer
		jz	short cc_ret
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		jmp	short flloop

; ---------------------------------------------------------------------------

; 15/10/2022

;************************************************************************
;*									*
;*	some equates for rom bios printer i/o				*
;*									*
;************************************************************************

; ibm rom status bits (i don't trust them, neither should you)
; warning!!! the ibm rom does not return just one bit. it returns a
; whole slew of bits, only one of which is correct.

;notbusystatus	equ 10000000b		; not busy
;nopaperstatus	equ 00100000b		; no more paper
;prnselected	equ 00010000b		; printer selected
;ioerrstatus	equ 00001000b		; some kinda error
;timeoutstatus	equ 00000001b		; time out.
;
;noprinter	equ 00110000b		; no printer attached

; 18/03/2019 - Retro DOS v4.0
;error_I24_out_of_paper	equ 9 ; MSDOS 6.0, ERR.INC, 1991

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	prn_input - return with no error but zero chars read		*
;*									*
;*	enter with cx = number of characters requested			*
;*									*
;************************************************************************

prn_input:				; 2C7h:21Ah = 70h:278Ah
		call	bc_err_cnt	; reset	count to zero
					; (sub reqpkt.count,cx)
		; 12/12/2022
prn_done:
		clc			; but return with carry	reset for no error
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	prn_writ - write cx bytes from es:di to printer device		*
;*									*
;*	auxnum has printer number					*
;*									*
;************************************************************************

prn_writ:				; 2C7h:21Fh = 70h:278Fh
		;jcxz	short prn_done	; no chars to output
		jcxz	prn_done	; 19/10/2022
prn_loop:				
		mov	bx, 2		; retry	count
prn_out:				
		call	prnstat		; get status
		jnz	short TestPrnError
		mov	al, [es:di]	; get character	to print
		xor	ah, ah
		call	prnop		; print	to printer
		jz	short prn_con	; no error - continue
		cmp	ah, 0FFh	; MODE_CTRLBRK
		jnz	short _prnwf
		mov	al, 0Ch		; error_I24_gen_failure
		mov	byte [altah], 0
		jmp	short pmessg
; ---------------------------------------------------------------------------

_prnwf:					
		test	ah, 1		; timeoutstatus
		jz	short prn_con
TestPrnError:				
		dec	bx		; retry	until count is exhausted.
		jnz	short prn_out
pmessg:					
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

prn_con:				
		inc	di		; point	to next	char and continue
		loop	prn_loop
;prn_done:				
		; 12/12/2022
prn_done2:
		;clc
		; cf=0
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	prn_stat - device driver entry to return printer status		*
;*									*
;************************************************************************

prn_stat:				; 2C7h:251h = 70h:27C1h
		call	prnstat		; device in dx
		jnz	short pmessg
		test	ah, 80h		; notbusystatus
		;jnz	short prn_done
		; 12/12/2022
		jnz	short prn_done2 ; cf=0
		jmp	z_bus_exit
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	prnstat - utility function to call ROM BIOS to check		*
;*		 printer status. Return meaningful error code		*
;*									*
;************************************************************************

prnstat:				
		mov	ah, 2		; set command for get status
					; PRINTER - GET	STATUS
					; DX = printer port (0-3)
					; Return: AH = status

; =============== S U B	R O U T	I N E =======================================

;************************************************************************
;*									*
;*	prnop - call ROM BIOS printer function in ah			*
;*		return zero true if no error				*
;*		return zero false if error, al = error code		*
;*									*
;************************************************************************

prnop:	
		mov	dx, [auxnum]	; get printer number
		int	17h		

	; This check was added to see if this is a case of no
	; printer being installed. This tests checks to be sure
	; the error is noprinter (30h)

		push	ax
		and	ah, 30h
		cmp	ah, 30h		; noprinter
		pop	ax
		jnz	short NextTest
		and	ah, 0DFh	; ~nopaperstatus
		or	ah, 8		; ioerrstatus

; examine the status bits to see if an error occurred. unfortunately, several
; of the bits are set so we have to pick and choose. we must be extremely
; careful about breaking basic.

NextTest:				
		test	ah, 28h		; (ioerrstatus+nopaperstatus)
					; i/o error?
		jz	short checknotready ; no, try not ready

; at this point, we know we have an error. the converse is not true

		mov	al, 9		; error_I24_out_of_paper
					; first, assume	out of paper
		test	ah, 20h		; out of paper set?
		jnz	short ret1	; yes, error is	set
		inc	al		; return al=10 (i/o error)
ret1:					
		retn
; ---------------------------------------------------------------------------

checknotready:				
		mov	al, 2		; assume not-ready
		test	ah, 1
		retn

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	prn_tilbusy - output until busy. Used by print spooler.		*
;*		     this entry point should never block waiting for	*
;*		     device to come ready.				*
;*									*
;*	inputs:	cx = count, es:di -> buffer				*
;*	outputs: set the number of bytes transferred in the		*
;*		 device driver request packet				*
;*									*
;************************************************************************

		; 19/10/2022
prn_tilbusy:				; 2C7h:28Bh = 70h:27FBh
		mov	si, di		; everything is	set for	lodsb
prn_tilbloop:				
		push	cx
		push	bx
		xor	bh, bh
		mov	bl, [printdev]
		shl	bx, 1
		;mov	cx, ds:wait_count[bx] ;	wait count times to come ready
		mov	cx, [wait_count+bx]
		pop	bx
prn_getstat:				
		call	prnstat		; get status
		jnz	short prn_bperr	; error
		test	ah, 80h		; ready	yet?
		loope	prn_getstat	; no, go for more
		pop	cx		; get original count
		jz	short prn_berr	; still	not ready => done
		es
		lodsb
		;lods	byte ptr es:[si] ; es
					; lodsb
		xor	ah, ah
		call	prnop
		jnz	short prn_berr	; error
		loop	prn_tilbloop
		; 12/12/2022
		; cf=0 (prnop)
		;clc			; normal no-error return
		retn			;   from device driver

; ---------------------------------------------------------------------------

prn_bperr:				
		pop	cx		; restore transfer count from stack
prn_berr:				
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

; 15/10/2022

;************************************************************************
;*									*
;*	prn_genioctl - get/set printer retry count			*
;*									*
;************************************************************************

; IOCTL.INC (MSDOS 6.0, 1991)
; 11/01/2019

;********************************;*
; CHARACTER DEVICES (PRINTERS)	 ;*
;********************************;*

;;RAWIO SUB-FUNCTIONS
;;get_retry_count equ 65h
;;set_retry_count equ 45h

;;struc A_RETRYCOUNT
;;.rc_count: resw 1
;;endstruc

;ioc_pc equ 5

; ---------------------------------------------------------------------------

		; 19/10/2022
prn_genioctl:				; 2C7h:2BAh = 70h:282Ah
		les	di, [ptrsav]
		cmp	byte [es:di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jz	short prnfunc_ok

prnfuncerr:				
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

prnfunc_ok:				
		mov	al, [es:di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		les	di, [es:di+19]	; [es:di+IOCTL_REQ.GENERICIOCTL_PACKET]
		xor	bh, bh
		;mov	bl, ds:printdev	; get index into retry counts
		mov	bl, [printdev]
		shl	bx, 1
		;mov	cx, ds:wait_count[bx] ;	pull out retry count for device
		mov	cx, [wait_count+bx]
		cmp	al, 65h		; get_retry_count
		jz	short prngetcount
		cmp	al, 45h		; set_retry_count
		jnz	short prnfuncerr
		mov	cx, [es:di]
prngetcount:				
		;mov	ds:wait_count[bx], cx
		mov	[wait_count+bx], cx
		mov	[es:di], cx	; [es:di+A_RETRYCOUNT.RC_COUNT]
					; return current retry count
		; 12/12/2022
		; cf=0
		;clc
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*  prn_ioctl_query							*
;*									*
;*  Added for 5.00							*
;************************************************************************

prn_ioctl_query:			; 2C7h:2F0h = 70h:2860h
		les	di, [ptrsav]
		cmp	byte [es:di+13], 5 ; [es:di+IOCTL_REQ.MAJORFUNCTION]
					; ioc_pc
		jnz	short prn_query_err
		mov	al, [es:di+14]	; [es:di+IOCTL_REQ.MINORFUNCTION]
		cmp	al, 65h		; GET_RETRY_COUNT
		jz	short IOCtlSupported
		cmp	al, 45h		; SET_RETRY_COUNT
		jnz	short prn_query_err
IOCtlSupported:	
		; 12/12/2022
		; cf=0		
		;clc
		retn
; ---------------------------------------------------------------------------

prn_query_err:
		; 12/12/2022				
		;stc
		jmp	bc_cmderr ; (bc_cmderr sets cf to 1)
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux port driver code -- "aux" == "com1"				*
;*									*
;*	the device driver entry/dispatch code sets up auxnum to		*
;*	give the com port number to use (0=com1, 1=com2, 2=com3...)	*
;*									*
;************************************************************************

;	values in ah, requesting function of int 14h in rom bios

;auxfunc_send	 equ	1	;transmit
;auxfunc_receive equ	2	;read
;auxfunc_status	 equ	3	;request status

;	error flags, reported by int 14h, reported in ah:

;flag_data_ready equ	01h	;data ready
;flag_overrun	 equ	02h	;overrun error
;flag_parity	 equ	04h	;parity error
;flag_frame	 equ	08h	;framing error
;flag_break	 equ	10h	;break detect
;flag_tranhol_emp equ	20h	;transmit holding register empty
;flag_timeout	 equ	80h	;timeout

;	these flags reported in al:

;flag_cts	 equ	10h	;clear to send
;flag_dsr	 equ	20h	;data set ready
;flag_rec_sig	 equ	80h	;receive line signal detect

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux_read - read cx bytes from [auxnum] aux port to buffer	*
;*		   at es:di						*
;*									*
;************************************************************************

aux_read:				; 2C7h:30Dh = 70h:287Dh
		;jcxz	short exvec2
		jcxz	exvec2		; 19/10/2022
		call	getbx		; put address of auxbuf	in bx
		xor	al, al
		xchg	al, [bx]
		or	al, al
		jnz	short aux2
aux1:					
		call	auxin		; get character	from port
					; won't return if error
aux2:					
		stosb
		loop	aux1		; if more characters, go around	again
exvec2:					
		clc			; all done, successful exit
auxin_retn:	; 18/12/2022
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	auxin - call rom bios to read character from aux port		*
;*		if error occurs, map the error and return one		*
;*		level up to device driver exit code, setting		*
;*		the number of bytes transferred appropriately		*
;*									*
;************************************************************************

auxin:					
		mov	ah, 2		; auxfunc_receive
		call	auxop
		test	ah, 0Eh		; flag_frame|flag_parity|flag_overrun
		;jnz	short arbad	; skip if any error bits set
		;retn
		; 25/06/2023 (BugFix)
		jz	short auxin_retn
; ---------------------------------------------------------------------------

arbad:					
		pop	ax		; remove return	address	(near call)
		xor	al, al
		or	al, 0B0h	; flag_rec_sig|	flag_dsr|flag_cts
		jmp	bc_err_cnt

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux_rdnd - non-destructive aux port read			*
;*									*
;************************************************************************

aux_rdnd:				; 2C7h:335h = 70h:28A5h
		call	getbx
		mov	al, [bx]	; have bx point	to auxbuf
		or	al, al		; if al	is non-zero (char in buffer)
		jnz	short auxdrx	; then return character
		call	auxstat		; if not, get status of	aux device
		test	ah, 1		; flag_data_ready - test data ready
		jz	short auxbus	; then device is busy (not ready)
		test	al, 20h		; flag_dsr - test data set ready
		jz	short auxbus	; then device is busy (not ready)
		call	auxin		; else aux is ready, get character
		mov	[bx], al
auxdrx:					
		jmp	rdexit		; return busy status
; ---------------------------------------------------------------------------

auxbus:					
		jmp	z_bus_exit
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux_wrst - return aux port write status				*
;*									*
;************************************************************************

aux_wrst:				; 2C7h:355h = 70h:28C5h
		call	auxstat		; get status of	aux in ax
		test	al, 20h		; test data set	ready
		jz	short auxbus	; then device is busy (not ready)
		test	ah, 20h		; flag_tranhol_emp - test transmit hold	reg empty
		jz	short auxbus	; then device is busy (not ready)
		; 12/12/2022
		; cf=0	; (test instruction resets cf)
		;clc
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	auxstat - call rom bios to determine aux port status		*
;*									*
;*	exit:	ax = status						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxstat:				
		mov	ah, 3		; auxfunc_status

		; fall into auxop

; =============== S U B	R O U T	I N E =======================================

;************************************************************************
;*									*
;*	auxop - perform rom-biox aux port interrupt			*
;*									*
;*	entry:	ah = int 14h function number				*
;*	exit:	ax = results						*
;*		dx = [auxnum]						*
;*									*
;************************************************************************

auxop:		; proc near		
		mov	dx, [auxnum]	; ah=function code
					; 0=init, 1=send, 2=receive, 3=status
					; get port number
		int	14h		; SERIAL I/O - GET USART STATUS
					; DX = port number (0-3)
					; Return: AX = port status code
		retn

; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux_flsh - flush aux input buffer - set contents of		*
;*		   auxbuf [auxnum] to zero				*
;*									*
;*	cas - shouldn't this code call the rom bios input function	*
;*	      repeatedly until it isn't ready?  to flush out any	*
;*	      pending serial input queue if there's a tsr like MODE	*
;*	      which is providing interrupt-buffering of aux port?	*
;*									*
;************************************************************************

aux_flsh:				; 2C7h:36Ch = 70h:28DCh
		call	getbx		; flush	aux input buffer
		mov	byte [bx], 0	; get bx to point to auxbuf
					; zero out buffer
		;clc			; all done, successful return
		; 12/12/2022
		; cf=0 ('add' instruction in 'getbx')
		retn
; ---------------------------------------------------------------------------

;************************************************************************
;*									*
;*	aux_writ - write to aux device					*
;*									*
;************************************************************************

aux_writ:				; 2C7h:374h = 70h:28E4h
		;jcxz	short exvec2	; write	to aux device (if cx > 0)
		jcxz	exvec2		; 19/10/2022
aux_loop:				
		mov	al, [es:di]	; get character	to be written
					; move di pointer to next character
		inc	di
		mov	ah, 1		; auxfunc_send - indicates a write
		call	auxop		; send character over aux port
		test	ah, 80h		; check	for error
		jz	short awok	; then no error
		mov	al, 10		; else indicate	write fault
		jmp	bc_err_cnt	; call error routines
; ---------------------------------------------------------------------------

awok:					
		loop	aux_loop	; if cx	is non-zero,
					; still	more character to print
		;clc			; all done, successful return
		; 12/12/2022
		; cf=0 (test instruction above)	
		retn

; =============== S U B	R O U T	I N E =======================================

;************************************************************************
;*									*
;*	getbx - return bx -> single byte input buffer for		*
;*		selected aux port ([auxnum])				*
;*									*
;************************************************************************

getbx:	
		mov	bx, [auxnum]	; return bx -> single byte input buffer
					; for selected aux port	([auxnum])
		;add	bx, offset auxbuf
		add	bx, auxbuf	; 19/10/2022
		; 12/12/2022
		; cf=0 (if [uaxnum] is valid number) 
		retn

; ---------------------------------------------------------------------------

; 15/10/2022

;----------------------------------------------------------------
;								:
;		    clock device driver 			:
;								:
;								:
;   this file contains the clock device driver. 		:
;								:
;   the routines in this files are:				:
;								:
;	routine 		function			:
;	------- 		--------			:
;	tim_writ		set the current time		:
;	tim_read		read the current time		:
;	time_to_ticks		convert time to corresponding	:
;				  number of clock ticks 	:
;								:
; the clock ticks at the rate of:				:
;								:
;	1193180/65536 ticks/second (about 18.2 ticks per second):
; see each routine for information on the use.			:
;								:
;----------------------------------------------------------------

; convert time to ticks
; input : time in cx and dx
; ticks returned in cx:dx

;19/07/2019
;09/03/2019

time_to_ticks:				; 0070h:2906h =	02C7h:0396h

; first convert from hour,min,sec,hund. to
; total number of 100th of seconds

		mov	al, 60
		mul	ch		; hours	to minutes
		mov	ch, 0
		add	ax, cx		; total	minutes
		mov	cx, 6000	; 60*100
		mov	bx, dx		; get out of the way of	the multiply
		mul	cx		; convert to 1/100 sec
		mov	cx, ax
		mov	al, 100
		mul	bh		; convert seconds to 1/100 sec
		add	cx, ax		; combine seconds with hours and min
		adc	dx, 0		; ripple carry
		mov	bh, 0
		add	cx, bx		; combine 1/100	sec
		adc	dx, 0

	; dx:cx is time in 1/100 sec

		xchg	ax, dx
		xchg	ax, cx		; now time is in cx:ax
		mov	bx, 59659
		mul	bx		; multiply low half
		xchg	dx, cx
		xchg	ax, dx		; cx->ax, ax->dx, dx->cx
		mul	bx		; multiply high	half
		add	ax, cx		; combine overlapping products
		adc	dx, 0
		xchg	ax, dx		; ax:dx=time*59659
		mov	bx, 5
		div	bl		; divide high half by 5
		mov	cl, al
		mov	ch, 0
		mov	al, ah		; remainder of divide-by-5
		cbw
		xchg	ax, dx		; use it to extend low half
		div	bx		; divide low half by 5
		mov	dx, ax		; cx:dx	is now number of ticks in time
		retf			; far return

; ---------------------------------------------------------------------------

; 17/10/2022
; 15/10/2022

;--------------------------------------------------------------------
;
; tim_writ sets the current time
;
; on entry es:[di] has the current time:
;
;	number of days since 1-1-80	(word)
;	minutes (0-59)			(byte)
;	hours (0-23)			(byte)
;	hundredths of seconds (0-99)	(byte)
;	seconds (0-59)			(byte)
;
; each number has been checked for the correct range.
;
;	NOTE: Any changes in this routine probably require corresponding
;	changes in the version that is built with the power manager driver.
;	See ptime.asm.
;
;--------------------------------------------------------------------

tim_writ:				; 2C7h:3DBh = 70h:294Bh
		mov	ax, [es:di]
		push	ax		; daycnt. we need to set this at the very
					; end to avoid tick windows.
		cmp	byte [havecmosclock], 0
		;cmp	ds:havecmosclock, 0
		jz	short no_cmos_1
		mov	al, [es:di+3]	; near indirect	calls
					; get binary hours
					; convert to bcd
		call	far [bintobcd]
		;call	ds:bintobcd	; call far [bintobcd]
		mov	ch, al		; ch = bcd hours
		mov	al, [es:di+2]	; get binary minutes
		call	far [bintobcd]
		;call	ds:bintobcd	; convert to bcd
		mov	cl, al		; cl = bcd minutes
		mov	al, [es:di+5]	; get binary seconds
		call	far [bintobcd]
		;call	ds:bintobcd
		mov	dh, al		; dh = bcd seconds
		mov	dl, 0		; dl = 0 (st) or 1 (dst)
		cli
		mov	ah, 3
		int	1Ah		; CLOCK	- SET REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; CH = hours in	BCD, CL	= minutes in BCD
					;  DH =	seconds	in BCD,DL = 01h	if daylight savings, 00h if standard time
					; Return: CMOS clock set
		sti
no_cmos_1:				
		mov	cx, [es:di+2]
		mov	dx, [es:di+4]
		; 17/10/2022
		call	far [ttticks]
		;call	dword ptr ds:ttticks ; call far	[ttticks]
					; convert time to ticks
					; cx:dx	now has	time in	ticks
		cli			; turn off timer
		mov	ah, 1
		int	1Ah		; CLOCK	- SET TIME OF DAY
					; CX:DX	= clock	count
					; Return: time of day set
		;pop	ds:daycnt
		pop	word [daycnt]
		sti
		;cmp	ds:havecmosclock, 0
		cmp	byte [havecmosclock], 0
		jz	short no_cmos_2
		call	far [daycnttoday]
		;call	ds:daycnttoday	; call far [daycnttoday]
					; convert to bcd format
		cli
		mov	ah, 5
		int	1Ah		; CLOCK	- SET DATE IN REAL TIME	CLOCK (AT,XT286,CONV,PS)
					; DL = day in BCD, DH =	month in BCD, CL = year	in BCD
					; CH = century (19h or 20h)
					; Return: CMOS clock set
		sti
no_cmos_2:
		; 12/12/2022
		; cf=0				
		;clc
		retn

; ---------------------------------------------------------------------------

; 15/10/2022

;----------------------------------------------------------------------------
; gettime reads date and time
; and returns the following information:
;
;	es:[di]  =count of days since 1-1-80
;	es:[di+2]=hours
;	es:[di+3]=minutes
;	es:[di+4]=seconds
;	es:[di+5]=hundredths of seconds
;
;	NOTE:  Any changes in this routine probably require corresponding
;	changes in the version that is built with the power manager driver.
;	See ptime.asm.
;----------------------------------------------------------------------------

tim_read:				; 2C7h:435h = 70h:29A5h
		call	GetTickCnt
		mov	si, [daycnt]

; we now need to convert the time in tick to the time in 100th of
; seconds. the relation between tick and seconds is:
;
;		 65,536 seconds
;	       ----------------
;		1,193,180 tick
;
; to get to 100th of second we need to multiply by 100. the equation is:
;
;	ticks from clock  * 65,536 * 100
;      --------------------------------- = time in 100th of seconds
;		1,193,180
;
; fortunately this formula simplifies to:
;
;	ticks from clock * 5 * 65,536
;      --------------------------------- = time in 100th of seconds
;		59,659
;
; the calculation is done by first multipling tick by 5. next we divide by
; 59,659. in this division we multiply by 65,536 by shifting the dividend
; my 16 bits to the left.
;
; start with ticks in cx:dx
; multiply by 5

		mov	ax, cx
		mov	bx, dx		; start	with ticks in cx:dx
					; multiply by 5
		shl	dx, 1
		rcl	cx, 1		; times	2
		shl	dx, 1
		rcl	cx, 1		; times	4
		add	dx, bx
		adc	ax, cx		; times	5
		xchg	ax, dx

; now have ticks * 5 in	dx:ax
; we now need to multiply by 65536 and divide by 59659 d.

		mov	cx, 59659	; get divisor
		div	cx		; dx now has remainder
					; ax has high word of final quotient
		mov	bx, ax		; put high word	in safe	place
		xor	ax, ax		; this is the multiply by 65536
		div	cx		; bx:ax	now has	time in	100th of seconds

; rounding based on the	remainder may be added here
; the result in	bx:ax is time in 1/100 second.

		mov	dx, bx		
		mov	cx, 200		;extract 1/100's

; division by 200 is necessary to ensure no overflow--max result
; is number of seconds in a day/2 = 43200.

		div	cx
		cmp	dl, 100		; remainder over 100?
		jb	short noadj
		sub	dl, 100		; keep 1/100's less than 100
noadj:					
		cmc			; if we	subtracted 100,	carry is now set
		mov	bl, dl		; save 1/100's

; to compensate	for dividing by	200 instead of 100, we now multiply
; by two, shifting a one in if the remainder had exceeded 100.

		rcl	ax, 1		
		mov	dl, 0
		rcl	dx, 1
		mov	cx, 60		; divide out seconds
		div	cx
		mov	bh, dl		; save the seconds
		div	cl		; break	into hours and minutes
		xchg	al, ah

; time is now in ax:bx (hours, minutes, seconds, 1/100 sec)

		push	ax
		mov	ax, si		; daycnt
		stosw
		pop	ax
		stosw
		mov	ax, bx
		stosw
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

;----------------------------------------------------------------------------
;
; procedure : GetTickCnt
;
;		Returns the tick count in CX:DX. Takes care of DayCnt in case
;		of rollover [except when power management driver is in use]. 
;		Uses the following logic for updating Daycnt
;
;		if ( rollover ) {
;			if ( t_switch )
;				daycnt++ ;
;			else
;				daycnt += rollover ;
;		}
;
; USES : AX
;
; RETURNS : CX:DX - tick count
; MODIFIES : daycnt
;
;----------------------------------------------------------------------------

		; 17/10/2022
GetTickCnt:	
		xor	ah, ah
		int	1Ah		; CLOCK	- GET TIME OF DAY
					; Return: CX:DX	= clock	count
					; AL = 00h if clock was	read or	written	(via AH=0,1) since the previous
					; midnight
					; Otherwise, AL	> 0
		cmp	byte [t_switch], 0 ; use old method ? (>0 is yes)
		jnz	short inc_case	; old method assumes  that Int 1Ah returns rollover flag
		xor	ah, ah		; new method assumes that Int 1Ah returns roll over count
					; and not flag
		add	[daycnt], ax
		retn
; ---------------------------------------------------------------------------

inc_case:				
		or	al, al
		jz	short no_rollover
		inc	word [daycnt]
no_rollover:				
		retn

;----------------------------------------------------------------------------
; MSDISK.ASM - MSDOS 6.0 - 1991
;----------------------------------------------------------------------------
; 15/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 09/03/2019 - Retro DOS v4.0

; MSDISK.ASM - MSDOS 3.3 - 02/02/1988
; 26/05/2018 - Retro DOS v3.0
; 23/03/2018 - Retro DOS v2.0

;error_unknown_media equ	7	; for use in BUILD BPB call

;struc BPB_TYPE
;.SECSIZE:	resw 1
;.SECALL:	resb 1
;.RESNUM:	resw 1
;.FATNUM:	resb 1
;.DIRNUM:	resw 1
;.SECNUM:	resw 1
;.FATID:	resb 1
;.FATSIZE:	resw 1
;.SLIM:		resw 1
;.HLIM:		resw 1
;.HIDDEN:	resw 1
;.size:
;endstruc

;-----------------------------------------------------------------
;	disk interface routines
;-----------------------------------------------------------------

; device attribute bits:
;	bit 6 - get/set map for logical drives and generic ioctl.

;MAXERR		equ	5
;MAX_HD_FMT_ERR	equ	2

;LSTDRV	equ 504h

; some floppies do not have changeline. as a result, media-check would
; normally return i-don't-know, the dos would continually reread the fat and
; discard cached data. we optimize this by implementing a logical door-latch:
; it is physically impossible to change a disk in under 2 seconds. we retain
; the time of the last successful disk operation and compare it with the current
; time during media-check. if < 2 seconds and at least 1 timer tick has passed,
; the we say no change. if > 2 seconds then we say i-don't-know. finally, 
; since we cannot trust the timer to be always available, we record the number 
; of media checks that have occurred when no apparent time has elapsed. while
; this number is < a given threshold, we say no change. when it exceeds that
; threshold, we say i-don't-know and reset the counter to 0. when we store 
; the time of last successful access, if we see that time has passed too,
; we reset the counter.

accessmax	equ	5

; due to various bogosities, we need to continually adjust what the head
; settle time is.  the following algorithm is used:
;
;   get the current head settle value.
;   if it is 0, then
;	set slow = 15
;   else
;	set slow = value
;   ...
;*********************************************
;************ old algorithm ******************
;*   if we are seeking and writing then
;*	 use slow
;*   else
;*	 use fast
;*********************************************
;*********** ibm's requested logic ***********
;   if we are seeking and writing and not on an at then
;	use slow
;   else
;	use fast
;   ...
;   restore current head settle value
;
;
;---------------------------------------
multrk_on	equ	10000000b	;user spcified mutitrack=on, or system turns
					; it on after handling config.sys file as a
					; default value, if multrk_flag = multrk_off1.
multrk_off1	equ	00000000b	;initial value. no "multitrack=" command entered.
multrk_off2	equ	00000001b	;user specified multitrack=off.

; close data segment, open Bios_Code segment

; 15/10/2022

; BIOSCODE:04A2h (MSDOS 6.21, IO.SYS)

;-----------------------------------------------------------------
;	command jump table
;-----------------------------------------------------------------

		db 0

; 11/12/2022
%if 0

dsktbl:		db 26			; 2C7h:4A2h = 70h:2A12h
					; ((dtbl_siz-1)/2) ; this is the size of the table ; 26
		dw 1742h		; dsk_init
		dw 4EBh			; media_chk
		dw 592h			; get_bpb
		dw 0D5h			; bc_cmderr
		dw 857h			; dsk_read
		dw 83Dh			; x_bus_exit
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 849h			; dsk_writ
		dw 841h			; dsk_writv
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 0D5h			; bc_cmderr
		dw 80Ah			; dsk_open
		dw 81Ah			; dsk_close
		dw 831h			; dsk_rem
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 0C6Bh		; do_generic_ioctl
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 558h			; ret_carry_clear
		dw 1124h		; ioctl_getown
		dw 1142h		; ioctl_setown
		dw 129Ah		; ioctl_support_query

;dtbl_siz equ $-dsktbl

%endif
		; 11/12/2022
dsktbl:		db (dtbl_siz-1)/2	; 26 ; this is the size of the table
		dw dsk_init
		dw media_chk
		dw get_bpb
		dw bc_cmderr
		dw dsk_read
		dw x_bus_exit
		dw ret_carry_clear
		dw ret_carry_clear
		dw dsk_writ
		dw dsk_writv
		dw ret_carry_clear
		dw ret_carry_clear
		dw bc_cmderr
		dw dsk_open
		dw dsk_close
		dw dsk_rem
		dw ret_carry_clear
		dw ret_carry_clear
		dw ret_carry_clear
		dw do_generic_ioctl
		dw ret_carry_clear
		dw ret_carry_clear
		dw ret_carry_clear
		dw ioctl_getown
		dw ioctl_setown
		dw ioctl_support_query

dtbl_siz equ $-dsktbl

; =============== S U B	R O U T	I N E =======================================

; ---------------------------------------------------------------------------
; setdrive scans through the data structure of bdss, and returns a pointer to
; the one that belongs to the drive specified. carry is set if none exists
; for the drive. Pointer is returned in es:[di]
;
;  AL contains the logical drive number.
; ---------------------------------------------------------------------------

SetDrive:	
		;les	di, ds:start_bds ; Point es:di to first bds	
		les	di, [start_bds] ; 19/10/2022
X_Scan_Loop:				
		cmp	[es:di+5], al	
		jz	short X_SetDrv
		les	di, [es:di]	; [es:di+BDS.link] ; Go	to next	bds
		cmp	di, 0FFFFh
		jnz	short X_Scan_Loop
		stc
X_SetDrv:				
		retn

; ---------------------------------------------------------------------------

; 15/10/2022

; ---------------------------------------------------------------------
; if id is f9, have a 96tpi disk else
; if bit 2 is 0 then media is not removable and could not have changed
;  otherwise if within 2 secs of last disk operation media could not
;    have changed, otherwise dont know if media has changed
; ---------------------------------------------------------------------

media_chk:				; 2C7h:4EBh = 70h:2A5Bh
		call	SetDrive
		mov	si, 1
		test	byte [es:di+24h], 1 ; [es:di+BDS.flags+1]
					; fchanged_by_format
		jz	short WeAreNotFakingIt
		; 12/12/2022
		and	byte [es:di+24h], 0FEh ; ~fchanged_by_format
		;and	word [es:di+23h], 0FEFFh ; [es:di+BDS.flags]
					; ~fchanged_by_format ;	reset flag
		mov	byte [tim_drv], 0FFh ; -1
					; Ensure that we ask the rom if media has changed
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jz	short wehaveafloppy
		mov	si, 0FFFFh	; Indicate media changed
		jmp	short Media_Done ; Media_Done
; ---------------------------------------------------------------------------

WeAreNotFakingIt:
		;test	byte [es:di+BDS.flags], fnon_removable			
		test	byte [es:di+23h], 1
		jnz	short Media_Done
wehaveafloppy:				
		xor	si, si		; Presume "I don't know"

		; If we have a floppy with changeline support, we ask the ROM
		; to determine if media has changed. We do not perform the
		; 2 second check for these drives.

		cmp	byte [fhave96], 0	; Do we	have changeline	support?
		jz	short mChk_NoChangeLine	; Brif not
		call	mediacheck	;  Call	into removable routine
		jb	short err_exitj
		call	haschange
		jnz	short Media_Done
mChk_NoChangeLine:
		; If we come here, we have a floppy with no changeline support
			
		mov	si, 1		; Presume no change
		mov	al, [tim_drv]	; Last drive accessed
		cmp	al, [es:di+4]	; [es:di+BDS.drivenum]
					; Is drive of last access the same?
		jnz	short Media_Unk	; No, then "i don't know"
		call	Check_Time_Of_Access
		jmp	short Media_Done
; ---------------------------------------------------------------------------

Media_Unk:				
		dec	si		; ; Return "I don't know"

		; SI now contains the correct value for media change.
		; Clean up the left overs
Media_Done:	
		; 19/10/2022			
		push	es
		les	bx, [ptrsav]
		mov	[es:bx+0Eh], si	; [es:bx+trans]
		pop	es
		or	si, si
		jns	short ret_carry_clear ;	volidok
		cmp	byte [fhave96], 0
		jz	short mChk1_NoChangeLine ; Brif	no changeline support
		call	media_set_vid
mChk1_NoChangeLine:			
		mov	byte [tim_drv], 0FFh ; -1
					; Make sure we ask rom for media check
ret_carry_clear:			
		clc			; volidok
		retn
; ---------------------------------------------------------------------------

err_exitj:				
		call	maperror	; guaranteed to	set carry
ret81:					
		mov	ah, 81h		; return error status
		retn			; return with carry set

; =============== S U B	R O U T	I N E =======================================

; ---------------------------------------------------------------------------
; perform a check on the time passed since the last access for this physical
; drive.
; we are accessing the same drive. if the time of last successful access was
; less than 2 seconds ago, then we may presume that the disk was not changed.
; returns in si:
;	0 - if time of last access was >= 2 seconds
;	1 - if time was < 2 seconds (i.e no media change assumed)
; registers affected ax,cx,dx, flags.
;
;	assume es:di -> bds, ds->Bios_Data
; ---------------------------------------------------------------------------

		; 19/10/2022
Check_Time_Of_Access:
		mov	si, 1		; presume no change.
		call	GetTickCnt	; cx:dx	is the elapsed time
		mov	ax, [es:di+47h]	; [es:di+BDS.tim_lo]
					; get stored time
		sub	dx, ax
		mov	ax, [es:di+49h]	; [es:di+BDS.tim_hi]
		sbb	cx, ax
		jnz	short timecheck_unk ; cx<>0 => >1 hour
		or	dx, dx		; time must pass
		jnz	short timepassed ; yes, examine max value
		inc	byte [accesscount]
		cmp	byte [accesscount], 5 
					; if count is less than threshold, ok
		jb	short timecheck_ret
		dec	byte [accesscount] ; don't let the count wrap
		jmp	short timecheck_unk ; "i don't know" if media changed
; ---------------------------------------------------------------------------

timepassed:				
		cmp	dx, 36		; 18*2 ; 18.2 tics per second.
					; min elapsed time? (2 seconds)
		jbe	short timecheck_ret ; yes, presume no change

		; everything indicates that we do not know what has happened.
timecheck_unk:				
		dec	si		; presume i don't know
timecheck_ret:				
		retn

; ---------------------------------------------------------------------------
; 15/10/2022
Err_Exitj2:
		jmp	short err_exitj

; ---------------------------------------------------------------------------

; 15/10/2022

; ==========================================================================
; Build a valid bpb for the disk in the drive.
; ==========================================================================

		; 19/10/2022
get_bpb:				; 2C7h:592h = 70h:2B02h
		mov	ah, [es:di]	; get fat id byte read by dos
		call	SetDrive	; get the correct bds for the drive
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jnz	short already_gotbpb ; no need to build	for fixed disks

		; let's set the default value for volid,vol_serial,
		; filesys_id in bds table

		call	clear_ids
		;mov	ds:set_id_flag,	1 ; indicate to	set system id in bds
		mov	byte [set_id_flag], 1
		call	GetBp		; build	a bpb if necessary
		jb	short ret81
		;cmp	ds:set_id_flag,	2 ; already, volume_label set from boot
		cmp	byte [set_id_flag], 2
		;mov	ds:set_id_flag,	0 ; record to bds table?
		mov	byte [set_id_flag], 0
		jz	short already_gotbpb ; do not set it again from	root dir
					; otherwise, conventional boot record
		;cmp	ds:fhave96, 0	; do we	have changeline	support?
		cmp	byte [fhave96], 0
		jz	short already_gotbpb ; brif not
		call	set_volume_id
already_gotbpb:				
		add	di, 6		; BDS.BPB
					; return the bpb from the current bds

;		 fall into setptrsav, es:di -> result

; ---------------------------------------------------------------------------

; 15/10/2022

; ==========================================================================
;Setptrsav is also jumped to from dsk_init (msbio2.asm). In both cases, the
;pointer to be returned is in es:di. We were incorrectly returning ds:di.
;Note that this works in most cases because most pointers are in Bios_Data.
;It fails, for instance, when we install an external drive using driver.sys
;because then the BDS segment is no longer Bios_Data. 
;NB: It is fine to corrupt cx because this is not a return value and anyway
;this returns to Chardev_entry (msbio1.asm) where all registers are 
;restored before returning to the caller.
; ==========================================================================

		; 19/10/2022
SetPtrSav:	; return point for dsk_init				
		mov	cx, es		; save es
		;les	bx, ds:ptrsav
		les	bx, [ptrsav]
		mov	[es:bx+0Dh], ah	; [es:bx+media]
		mov	[es:bx+12h], di	; [es:bx+count]
		mov	[es:bx+14h], cx	; [es:bx+count+2]
		clc
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

; -----------------------------------------------------
; clear ids in bds table. only applied for floppies.
;input:  es:di -> bds table
;	assumes ds: -> Bios_Data
;output: volid set to "NO NAME    "
;	 vol_serial set to 0.
;	 filesys_id set to "FAT12   " or "FAT16   "
;	   depending on the flag fatsize in bds.
;
;	trashes si, cx
; -----------------------------------------------------

;size_of_EXT_BOOT_VOL_LABEL equ 11
;size_of_EXT_SYSTEM_ID equ 8

clear_ids:		
		push	di
		xor	cx, cx		; no serial number
		mov	[es:di+57h], cx	; [es:di+BDS.vol_serial]
		mov	[es:di+59h], cx	; [es:di+BDS.vol_serial+2]

		; BUGBUG - there's a lot in common here and with
		; mov_media_ids.. see if we can save some space by
		; merging them... jgl

		;mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
		; 10/12/2022
		mov	cl, 11 ; cx = 11		

		;mov	si, offset vol_no_name ; "NO NAME    "
		mov	si, vol_no_name	; 19/10/2022
		add	di, 75		; BDS.volid
		rep movsb
		;test	byte [es:di+BDS.fatsiz], fbig
		test	byte [es:di+1Fh], 40h
		;mov	si, offset fat_16_id ; "FAT16	"
		mov	si, fat_16_id	; 19/10/2022
		jnz	short ci_bigfat
		;mov	si, offset fat_12_id ; "FAT12	"
		mov	si, fat_12_id	 ; 19/10/2022
ci_bigfat:				
		;mov	cx, 8		; size_of_EXT_SYSTEM_ID
		; 10/12/2022
		mov	cl, 8 ; cx = 8 
		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
					; filesys_id field
		rep movsb
		pop	di		; restore bds pointer
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

; ---------------------------------------------------------------------------
;	getbp - return bpb from the drive specified by the bds.
;	    if the return_fake_bpb flag is set, then it does nothing.
;	    note that we never come here for fixed disks.
;	    for all other cases,
;	      - it reads boot sector to pull out the bpb
;	      - if no valid bpb is found, it then reads the fat sector,
;		to get the fat id byte to build the bpb from there.
;
;   inputs:	es:di point to correct bds.
;
;   outputs:	fills in bpb in current bds if valid bpb or fat id on disk.
;		carry set, and al=7 if invalid disk.
;		carry set and error code in al if other error.
;		if failed to recognize the boot record, then will set the
;		set_id_flag to 0.
;		this routine will only work for a floppy diskette.
;		     for a fixed disk, it will just return.
;
;	****** Note: getbp is a clone of getbp which uses the newer
;	  segment definitions. It should be migrated towards.
;	   now es:di has the bds, ds: has Bios_Data
; ---------------------------------------------------------------------------

GetBp:		; if returning fake bpb then return bpb as is.
		;test	byte [es:di+BDS.flags], return_fake_bpb|fnon_removable		
		test	byte [es:di+23h], 5
		jz	short getbp1	; getbp1
		jmp	getret_exit
; ---------------------------------------------------------------------------

getbp1:					
		push	cx
		push	dx
		push	bx

		; attempt to read in boot sector and determine bpb.
		; we assume that the 2.x and greater dos disks all
		; have a valid boot sector.

		call	readbootsec
		jb	short getbp_err_ret_brdg ; carry set if there was error.
		or	bx, bx		; bx is	0 if boot sector is valid.
		jnz	short dofatbpb
		call	movbpb		; move bpb into	registers
		jmp	short Has1
; ---------------------------------------------------------------------------

getbp_err_ret_brdg:			
		jmp	getbp_err_ret
; ---------------------------------------------------------------------------

		; we have a 1.x diskette. In this case read in the fat ID byte
		; and fill in bpb from there.
dofatbpb:				
		call	readfat		; puts media descriptor	byte in	ah
		jb	short getbp_err_ret_brdg
		;cmp	ds:fhave96, 0	;  changeline support available?
		cmp	byte [fhave96], 0 ; 19/10/2022
		jz	short bpb_nochangeline ; brif not
		call	hidensity	; may not return! May add sp, 2	and
					; jump to has1!!!!!! or	has720K
bpb_nochangeline:		; test for a valid 3.5" medium			
		cmp	byte [es:di+22h], 2	; [es:di+BDS.formfactor]
					; ffSmall
		jnz	short is_floppy
		cmp	ah, 0F9h	; is it	a valid	fat id byte for	3.5" ?
		jnz	short got_unknown_medium
Has720K:				
		;mov	bx, offset sm92 ; pointer to correct bpb
		mov	bx, sm92	; 19/10/2022

		; es points to segment of bds. the following should be modified
		; to get spf,csec,spau,spt correctly. it had been wrong if
		; driver.sys is loaded since the bds is inside the driver.sys.

		; 10/12/2022
		;mov	al, [bx+0]	; [bx+bpbtype.spf]
		; 21/12/2022
		mov	al, [bx]
		mov	cx, [bx+3]	; [bx+bpbtype.csec]
		mov	dx, [bx+5]	; [bx+bpbtype.spau]
		mov	bx, [bx+1]	; [bx+bpbtype.spt]
		; 19/10/2022 - Temporary !
		;db	8Ah, 87h, 0, 0	; mov al, [bx+0]
		;db	8Bh, 8Fh, 3, 0	; mov cx, [bx+3]
		;db	8Bh, 97h, 5, 0	; mov dx, [bx+5]
		;db	8Bh, 9Fh, 1, 0	; mov bx, [bx+1]	

		jmp	short Has1
; ---------------------------------------------------------------------------

is_floppy:			; must be a 5.25" floppy if we come here
		cmp	ah, 0F8h	; valid	media??	(0F8h-0FFh)
		jb	short got_unknown_medium
		mov	al, 1		; set number of	fat sectors
		mov	bx, 16392	; 64*256+8
					; set dir entries and sector max
		mov	cx, 320		; 40*8
					; set size of drive
		mov	dx, 257		; 01*256+1
					; set head limit and sec/all unit
		test	ah, 2		; test for 8 or	9 sector
		jnz	short has8	; nz = has 8 sectors
		inc	al		; inc number of	fat sectors
		inc	bl		; inc sector max
		;add	cx, 40		; increase size	(to 360)
		; 18/12/2022
		add	cl, 40
has8:					
		test	ah, 1		; test for 1 or	2 heads
		jz	short Has1	; jz = 1 head
		add	cx, cx		; double size of disk
		mov	bh, 112		; increase number of directory entries
		inc	dh		; inc sec/all unit
		inc	dl		; inc head limit
Has1:					
		mov	[es:di+8], dh	; [es:di+BDS.secperclus]
		mov	[es:di+0Ch], bh	; [es:di+BDS.direntries]
		mov	[es:di+0Eh], cx	; [es:di+BDS.totalsecs16]
		mov	[es:di+10h], ah	; [es:di+BDS.media]
		mov	[es:di+11h], al	; [es:di+BDS.fatsecs]
		mov	[es:di+13h], bl	; [es:di+BDS.secpertrack]
		mov	[es:di+15h], dl	; [es:di+BDS.heads]

		; the BDS_BPB.BPB_HIDDENSECTORS+2 field and the
		; BDS_BPB.BPB_BIGTOTALSECTORS field need to be set
		; to 0 since this code is for floppies

		; 18/12/2022
		;mov	word [es:di+19h], 0 ; [es:di+BDS.hiddensecs+2]
		;mov	word [es:di+17h], 0 ; [es:di+BDS.hiddensecs]
		;mov	word [es:di+1Dh], 0 ; [es:di+BDS.totalsecs32+2]
		; 18/12/2022
		sub	cx, cx
		mov	[es:di+19h], cx ; 0 ; [es:di+BDS.hiddensecs+2]
		mov	[es:di+17h], cx ; 0 ; [es:di+BDS.hiddensecs]
		mov	[es:di+1Dh], cx ; 0 ; [es:di+BDS.totalsecs32+2]
getret:					
		pop	bx
		pop	dx
		pop	cx
getret_exit:				
		retn
; ---------------------------------------------------------------------------

getbp_err_ret:	; before doing anything else, set set_id_flag	to 0.			
		;mov	ds:set_id_flag,	0
		; 19/10/2022
		mov	byte [set_id_flag], 0
		call	maperror
		jmp	short getret
; ---------------------------------------------------------------------------

		; we have a 3.5" diskette for	which we cannot	build a	bpb.
		; we do	not assume any type of bpb for this medium.

got_unknown_medium:			
		;mov	ds:set_id_flag,	0 
		mov	byte [set_id_flag], 0
		mov	al, 7
		stc
		jmp	short getret

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)

; ----------------------------------------------------------------
; read in the boot sector. set carry if error in reading sector.
; bx is set to 1 if the boot sector is invalid, otherwise it is 0.
;
;	assumes es:di -> bds, ds-> Bios_Data
; ----------------------------------------------------------------

; 10/03/2019 - Retro DOS v4.0

; 30/12/2022 - Retro DOS v4.2
; (MSDOS 6.21 IO.SYS, BIOSCODE:06C3h)

readbootsec:	
		mov	dh, 0		; head 0
		mov	cx, 1		; cylinder 0, sector 1
		call	read_sector
		jb	short err_ret
		xor	bx, bx		; assume valid boot sector

		; put a sanity check for the boot sector in here to detect
		; boot sectors that do not have valid bpbs. we examine the
		; first two bytes - they must contain a long jump (69h) or a
		; short jump (EBh) followed by a nop (90h), or a short jump
		; (E9h). if this test is passed, we further check by examining
		; the signature at the end of the boot sector for the word
		; AA55h. if the signature is not present, we examine the media
		; descriptor byte to see if it is valid. for dos 3.3, this
		; logic is modified a little bit. we are not going to check
		; signature. instead we are going to sanity check the media
		; byte in bpb regardless of the validity of signature. this is
		; to save the already developed commercial products that have
		; good jump instruction and signature but with the false bpb
		; informations

; that will crash the diskette drive operation. (for example, symphony diskette).

		; 19/10/2022
		cmp	byte [disksector], 69h ; is it a direct jump?
		jz	short check_bpb_mediabyte ; don't need to find a nop
		cmp	byte [disksector], 0E9h ; dos 2.0 jump?
		jz	short check_bpb_mediabyte ; no need for	nop
		cmp	byte [disksector], 0EBh ; how about a short jump?
		jnz	short invalidbootsec
		cmp	byte [disksector+2], 90h ; is next one a nop?
		jnz	short invalidbootsec

; 15/10/5022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
;
;; 10/03/2019
;; (MSDOS 3.3, MSDISK.ASM, 1988)
;;
;; Don't have to perform the following signature check since
;; we need to check the media byte even with the good signatured diskette.
;;
;;check_signature:
;;		cmp	word [cs:disksector+1FEh],0AA55h ; see if non-ibm
;;							 ; disk or 1.x media.
;;		jz	short checksinglesided ; go see if singled sided medium.
;;					       ; may need some special handling

; check for non-ibm disks which do not have the signature AA55h at the
; end of the boot sector, but still have a valid boot sector. this is done
; by examining the media descriptor in the boot sector.

		; 19/10/2022
check_bpb_mediabyte:			
		mov	al, [disksector+15h]
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		and	al, 0F0h
		cmp	al, 0F0h	; allow	for strange media
		jnz	short invalidbootsec

; there were some (apparently a lot of them) diskettes that had been formatted
; under dos 3.1 and earlier versions which have invalid bpbs in their boot
; sectors. these are specifically diskettes that were formatted in drives
; with one head, or whose side 0 was bad. these contain bpbs in the boot
; sector that have the sec/clus field set to 2 instead of 1, as is standard
; in dos. in order to support them, we have to introduce a "hack" that will
; help our build bpb routine to recognise these specific cases, and to
; set up out copy of the bpb accordingly.
; we do this by checking to see if the boot sector is off a diskette that
; is single-sided and is a pre-dos 3.20 diskette. if it is, we set the
; sec/clus field to 1. if not, we carry on as normal.

checksinglesided:
		mov	al, [disksector+15h]
		cmp	al, 0F0h
		jz	short gooddsk
		test	al, 1
		jnz	short gooddsk
		cmp	word [disksector+8], 2E33h ; "3."
		jnz	short mustbeearlier
		cmp	byte [disksector+0Ah], 32h ; "2"
		jnb	short gooddsk

; we must have a pre-3.20 diskette. set the sec/clus field to 1

mustbeearlier:				
		mov	byte [disksector+0Dh], 1
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
		jmp	short gooddsk
; ---------------------------------------------------------------------------

invalidbootsec:				
		inc	bx		; indicate that boot sector invalid
		; 10/12/2022
movbpb_ret:
gooddsk:				
		clc
err_ret:
		retn
; ---------------------------------------------------------------------------

		; 10/12/2022
;err_ret:				
		;retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022
; ---------------------------------------------------------------------------
; 'movbpb' moves the bpb read from the boot sector into registers for use by
; getbp routine at has1
;
; if the set_id_flag is 1, and if an extended boot record, then set volume
; serial number, volume label, file system id in bds according to
; the boot record.  after that, this routine will set the set_id_flag to 2
; to signal that volume label is set already from the extended boot record
; (so, don't set it again by calling "set_volume_id" routine which uses
; the volume label in the root directory.)
; ---------------------------------------------------------------------------

; 10/03/2019 - Retro DOS v4.0

		; 19/10/2022
movbpb:	
		mov	dh, [disksector+0Dh]
					; disksector+EXT_BOOT.BPB+EBPB.SECTORSPERCLUSTER]
					; sectors per unit
		mov	bh, [disksector+11h]
					; [disksector+EXT_BOOT.BPB+EBPB.ROOTENTRIES]
					; number of directory entries
		mov	cx, [disksector+13h]
					; [disksector+EXT_BOOT.BPB+EBPB.TOTALSECTORS]
					; size of drive
		mov	ah, [disksector+15h]
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
					; media	descriptor
		mov	al, [disksector+16h];
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERFAT]
					; number of fat	sectors
		mov	bl, [disksector+18h]
					; [disksector+EXT_BOOT.BPB+EBPB.SECTORSPERTRACK]
					; sectors per track
		mov	dl, [disksector+1Ah]
					; [disksector+EXT_BOOT.BPB+EBPB.HEADS]
					; number of heads
		cmp	byte [set_id_flag], 1 ; called by get_bpb?
		jnz	short movbpb_ret
		call	mov_media_ids
		jb	short movbpb_conv ; conventional boot record?
		mov	byte [set_id_flag], 2 ; signals that volume id is set
movbpb_conv:				
		cmp	byte [fhave96], 1
		jnz	short movbpb_ret
		call	resetchanged	; reset	flags in bds to	not fchanged.
		; 10/12/2022
		; cf = 0
;movbpb_ret:				
		;clc
		retn

; =============== S U B	R O U T	I N E =======================================

;copy the boot_serial number, volume id, and filesystem id from the
;***extended boot record*** in ds:disksector to the bds table pointed
;by es:di.

;in.) es:di -> bds
;     ds:disksector = valid extended boot record.
;out.) vol_serial, bds_volid and bds_system_id in bds are set according to
;      the boot record information.
;     carry flag set if not an extended bpb.
;     all registers saved except the flag.

		; 19/10/2022
mov_media_ids:		
		cmp	byte [disksector+26h], 29h
					; [disksector+EXT_BOOT.SIG],
					; EXT_BOOT_SIGNATURE
		jnz	short mmi_not_ext
		push	cx
		mov	cx, [disksector+27h]
					; [disksector+EXT_BOOT.SERIAL]
		mov	[es:di+57h], cx	; [es:di+BDS.vol_serial]
		mov	cx, [disksector+29h]
					; [disksector+EXT_BOOT.SERIAL+2]
		mov	[es:di+59h], cx	; [es:di+BDS.vol_serial+2]
		push	di
		push	si
		mov	cx, 11		; size_of_EXT_BOOT_VOL_LABEL
		mov	si, disksector+2Bh
		;mov	si, (offset disksector+2Bh) ;
					; disksector+EXT_BOOT.VOL_LABEL
		add	di, 75		; BDS.volid
		rep movsb
		;mov	cx, 8		; size_of_EXT_SYSTEM_ID
		; 10/12/2022
		mov	cl, 8 ; cx = 8
		mov	si, disksector+36h
		;mov	si, (offset disksector+36h) ; disksector+EXT_BOOT.SYSTEM_ID
		add	di, 5		; (BDS.filesys_id-BDS.volid)-size_of_EXT_BOOT_VOL_LABEL
		rep movsb
		pop	si
		pop	di
		pop	cx
		; 10/12/2022
		; cf = 0
		;clc		; this clc is not required (16/06/2019 - Erdogan Tan)
				; (20/09/2022)
		retn
; ---------------------------------------------------------------------------

mmi_not_ext:				
		stc
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022
; --------------------------------------------------------------
; read in the fat sector and get the media byte from it.
; input : es:di -> bds
; output:
;	  carry set if an error occurs, ax contains error code.
;	  otherwise, ah contains media byte on exit
; --------------------------------------------------------------

readfat:	
		;mov	dh, 0
		; 10/12/2022
		xor	dh, dh
		mov	cx, 2		; head 0
					; cylinder 0, sector 2
		call	read_sector
		jb	short bad_fat_ret
		mov	ah, [bx]	; media	byte
bad_fat_ret:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

; ---------------------------------------------------------------------------
; read a single sector into the temp buffer.
; perform three retries in case of error.
;   inputs:	es:[di].bds_drivenum has physical drive to use
;		cx has sector and cylinder
;		dh has head
;		es:di has bds
;		ds has Bios_Data
;
;   outputs:	carry clear
;		    Bios_Data:bx point to sector
;		       (note: some callers assume location of buffer)
;
;		carry set
;		    ax has rom error code
;
; register bp is preserved.
; ---------------------------------------------------------------------------

; 10/03/2019 - Retro DOS v4.0

		; 19/10/2022
read_sector:	
		push	bp
		mov	bp, 3		; make 3 attempts
		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
		mov	bx, disksector	; get es:bx to point to	buffer
rd_ret:					
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		jnb	short okret2
rd_rty:					
		call	again		; reset	disk, decrement	bp, preserve ax
		jz	short err_rd_ret
		test	byte [es:di+23h], 1
		;test	byte ptr [es:di+23h], 1	; [es:di+BDS.flags]
					; fnon_removable
		jnz	short rd_ret
		cmp	byte [media_set_for_format], 0
		jnz	short rd_skip1_dpt
		push	ax
		push	ds		; for retry, set the head settle time to 0Fh
		lds	si, [dpt]
		;mov	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
		;mov	byte [si+9], 15 ; [si+DISK_PARMS.DISK_HEAD_STTL]
		;			; NORMSETTLE
		; 12/12/2022
		mov	al, 15
		xchg	al, [si+9]
		; 
		pop	ds
		mov	[save_head_sttl], al
		pop	ax
rd_skip1_dpt:				
		push	es
		push	ds
		pop	es
		mov	ax, 201h
		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		pop	es
		pushf
		cmp	byte [media_set_for_format], 0
		jnz	short rd_skip2_dpt
		push	ax
		mov	al, [save_head_sttl]
		push	ds
		lds	si, [dpt]
		mov	[si+9],	al	; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ds
		pop	ax
rd_skip2_dpt:				
		popf
		jnb	short okret2
		jmp	short rd_rty
; ---------------------------------------------------------------------------

err_rd_ret:				
		mov	dl, 0FFh	; make sure we ask rom if media	has changed
					; return error
		stc

; update information pertaining to last drive accessed, time of access, last
; track accessed in that drive.

okret2:					
		mov	[step_drv], dl	; set up for head settle logic in disk
		mov	[tim_drv], dl	; save drive last accessed
		mov	[es:di+46h], ch	; [es:di+BDS.track]
					; save last track accessed on this drive
					; preserve flags in case error occurred
		pushf
		call	set_tim
		popf			; restore flags
		pop	bp
		retn

;----------------------------------------------------------------------------
;	disk open/close routines
;----------------------------------------------------------------------------

dsk_open:				; 2C7h:80Ah = 70h:2D7Ah
		cmp	byte [fhave96], 0
		jz	short dsk_open_exit ; done if no changeline support
		call	SetDrive	; get bds for drive
		inc	word [es:di+20h] ; [es:di+BDS.opcnt]
dsk_open_exit:	
		; 10/12/2022
		; cf = 0			
		;clc		; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
				; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
		retn
; ---------------------------------------------------------------------------

dsk_close:				; 2C7h:81Ah = 70h:2D8Ah
		cmp	byte [fhave96], 0
		jz	short exitjx	; done if no changeline	support
		call	SetDrive	; get bds for drive
		cmp	word [es:di+20h], 0 ; [es:di+BDS.opcnt]
		jz	short exitjx	; watch	out for	wrap
		dec	word [es:di+20h]
exitjx:					
		; 10/12/2022
		; cf = 0
		;clc		; CF is	already	ZERO here (18/09/2022, MSDOS 5.0 IO.SYS)
				; (19/07/2019 -	Erdogan	Tan - MSDOS 6.0	IO.SYS - retrodos4.s)
		retn

;----------------------------------------------------------------------------
;		disk removable routine
;----------------------------------------------------------------------------

		; al is	unit #
dsk_rem:				; 2C7h:831h = 70h:2DA1h
		call	SetDrive	; get bds for this drive
		;test	byte [es:di+BDS.flags], fnon_removable
		test	byte [es:di+23h], 1
		;jnz	short x_bus_exit ; non_rem
		jnz	short non_rem	; 15/10/2022
		; 10/12/2022
		; cf = 0
		;clc			; CF is already ZERO here
					; 15/10/2022
		retn
; ---------------------------------------------------------------------------

non_rem:
x_bus_exit:				
		mov	ah, 3		; 2C7h:83Dh = 0070h:2DADh
					; return busy status
		stc
dsk_ret:				
		retn

;----------------------------------------------------------------------------
;		disk i/o routines
;----------------------------------------------------------------------------

dsk_writv:				; 2C7h:841h = 70h:2DB1h
		;mov	word [wrtverify], 103h
		; 19/10/2022
		mov	word [rflag], 103h
		;mov	word ptr ds:rflag, 103h	; write	and verify
		jmp	short dsk_cl
; ---------------------------------------------------------------------------

dsk_writ:				; 2C7h:849h = 70h:2DB9h
		;mov	word [wrtverify], 3
		; 19/10/2022
		mov	word [rflag], 3
		;mov	word ptr ds:rflag, 3 ; romwrite

dsk_cl:					
		call	diskio		; romwrite
; ---------------------------------------------------------------------------

dsk_io:					
		jnb	short dsk_ret
		jmp	bc_err_cnt
; ---------------------------------------------------------------------------

dsk_read:				; ; 2C7h:857h =	70h:2DC7h
		call	diskrd
		jmp	short dsk_io

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022
; 10/03/2019 - Retro DOS v4.0

;-----------------------------------------------------------
; miscellaneous odd jump routines. 
; moved out of mainline for speed.

; if we have a system where we have virtual drives, we need 
; to prompt the user to place the correct disk in the drive.
;
;	assume es:di -> bds, ds:->Bios_Data
;-----------------------------------------------------------

		; 19/10/2022
checksingle:		
		push	ax
		push	bx
		mov	bx, [es:di+23h]	; [es:di+BDS.flags]

; if hard drive, cannot change disk.
; if current owner of physical drive, no need to change diskette.

		test	bl, 21h		; fnon_removable|fi_own_physical
		jnz	short singleret
		test	bl, 10h		; fi_am_mult
					; is there a drive sharing this	physical drive?
		jz	short singleret


; look for the previous owner of this physical drive
; and reset its ownership flag.

		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
					; get physical drive number
		push	es		; preserve pointer to current bds
		push	di
		les	di, [start_bds] ; get first bds
scan_list:				
		cmp	[es:di+4], al
		jnz	short scan_skip	; Not our drive. Try next bds.
		mov	bl, 20h	; ' '   ; fi_own_physical ; test ownership flag
		test	[es:di+23h], bl
		jz	short scan_skip	; he doesn't own it either. continue
		xor	[es:di+23h], bl	; reset	ownership flag
		pop	di		; restore pointer to current bds
		pop	es
		or	[es:di+23h], bl	; ; set	ownership flag

; we examine the fsetowner flag. if it is set, then we are using the code in
; checksingle to just set the owner of a drive. we must not issue the prompt
; in this case.
		cmp	byte [fsetowner], 1
		jnz	short not_fsetowner
		;cmp	byte ptr es:[di+4], 0 ;	are we handling	drive number 0 ?
		cmp	byte [es:di+4], 0
		jnz	short singleret
		mov	al, [es:di+5]
		;mov	al, es:[di+5]	; [es:di+BDS.drivelet]
					; get the DOS drive letter
		push	es
		mov	es, [zeroseg]
		mov	[es:LSTDRV], al
		;mov	es:504h, al	; [es:LSTDRV]
					; set up sdsb
		pop	es		; restore bds pointer
		jmp	short singleret
; ---------------------------------------------------------------------------

; to support "backward" compatibility with ibm's "single drive status byte"
; we now check to see if we are in a single drive system and the application
; has "cleverly" diddled the sdsb

not_fsetowner:				
		cmp	byte [single], 2 ; if (single_drive_system)
		jnz	short ignore_sdsb
		push	ax
		mov	al, [es:di+5]	; if (curr_drv == req_drv)
		mov	ah, al
		push	es
		mov	es, [zeroseg]
		xchg	al, [es:LSTDRV]
		;xchg	al, es:504h	; [es:LSTDRV]
					; then swap(curr_drv,req_drv)
		pop	es
		cmp	ah, al		; else
		pop	ax		; swap(curr_drv,req_drv)
		jz	short singleret	; issue	swap_dsk_msg
ignore_sdsb:				
		call	swpdsk
		jmp	short singleret
; ---------------------------------------------------------------------------

scan_skip:	
		les	di, [es:di]			
		;les	di, es:[di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh	; end of list?
		jnz	short scan_list	; ontinue until	hit end	of list
		stc
		pop	di		; restore current bds
		pop	es

singleret:				
		pop	bx
		pop	ax
		retn

; ---------------------------------------------------------------------------

baddrive:				
		mov	al, 8		; sector not found
		jmp	short baddrive_ret
; ---------------------------------------------------------------------------

unformatteddrive:				
		mov	al, 7		; unknown media
baddrive_ret:				
		stc
; ---------------------------------------------------------------------------

ioret:		
		retn

; ---------------------------------------------------------------------------

; 15/10/52022

; ---------------------------------------------------------------------------
;	disk i/o handler
;
;	al = drive number (0-6)
;	ah = media descriptor
;	cx = sector count
;	dx = first sector (low)
;	[start_sec_h] = first sector (high)  32 bit calculation.
;	ds = cs
;	es:di = transfer address
;	[rflag]=operation (2=read, 3=write)
;	[verify]=1 for verify after write
;
;	if successful carry flag = 0
;	  else cf=1 and al contains error code
; ---------------------------------------------------------------------------

diskrd:	
		;mov	ds:rflag, 2	; romread
		; 19/10/2022
		mov	byte [rflag], 2 ; romread

; =============== S U B	R O U T	I N E =======================================

		; 19/10/2022
diskio:
		mov	bx, di		; es:bx	= transfer address
		mov	[xfer_seg], es	; save transfer	segment
		call	SetDrive
		mov	al, [es:di+10h]	; [es:di+BDS.media]
		mov	[medbyt], al
		;jcxz	short ioret
		jcxz	ioret

; see if the media is formatted or not by checking the flags field in
; in the bds. if it is unformatted we cannot allow i/o, so we should
; go to the error exit at label unformatteddrive.

		test	byte [es:di+24h], 2
		;test	byte ptr es:[di+24h], 2	; [es:di+BDS.flags+1]
					; unformatted_media
		jnz	short unformatteddrive
		mov	[seccnt], cx	; save sector count
		mov	[spsav], sp	; save sp

; ensure that we are trying to access valid sectors on the drive

		mov	ax, dx
		xor	si, si
		add	dx, cx
		adc	si, 0
		cmp	word [es:di+0Eh], 0 ; [es:di+BDS.totalsecs16]
					; > 32 bit sector ?
		jz	short sanity32
		cmp	si, 0
		jnz	short baddrive
		cmp	dx, [es:di+0Eh]	; [es:di+BDS.totalsecs16]
		ja	short baddrive
		jmp	short sanityok
; ---------------------------------------------------------------------------

sanity32:				
		add	si, [start_sec_h]
		cmp	si, [es:di+1Dh]	; [es:di+BDS.totalsecs32+2]
		jb	short sanityok
		ja	short baddrive
		cmp	dx, [es:di+1Bh]	; [es:di+BDS.totalsecs32]
		ja	short baddrive

sanityok:				
		mov	dx, [start_sec_h]
		add	ax, [es:di+17h]	; [es:di+BDS.hiddensecs]
		adc	dx, [es:di+19h]	; [es:di+BDS.hiddensecs+2]

; now dx;ax have the physical first sector.
; since the following procedures is going to destroy ax, let's
; save it temporarily to saved_word.

		mov	[saved_word], ax ; save the sector number (low)

; set up pointer to disk base table in [dpt]. we cannot assume that iosetup
; will do it because we will skip the set up stuff with hard disks.

		push	es
		mov	es, [zeroseg]
		les	si, [es:DSKADR]
		;les	si, es:78h	; [es:DSKADR]
					; current disk parm table
		mov	[dpt], si
		mov	[dpt+2], es
		pop	es
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jnz	short skip_setup
		call	checksingle

; check to see if we have previously noted a change line. the routine
; returns if everything is ok. otherwise, it pops off the stack and returns
; the proper error code.

		cmp	byte [fhave96], 0 ; do we have changeline support?
		jz	short diskio_nochangeline ; brif not
		call	checklatchio	; will do a sneaky pop stack return
					; if a disk error occurs
diskio_nochangeline:			
		call	iosetup		; set up tables	and variables for i/o

; now the settle values are correct for the following code

skip_setup:

; 32 bit sector calculation.
; dx:[saved_word] = starting sector number.
				
		mov	ax, dx
		xor	dx, dx
		div	word [es:di+13h] ; [es:di+BDS.secpertrack]
					 ; divide by sec per track
		mov	[temp_h], ax
		mov	ax, [saved_word]
		div	word [es:di+13h] ; [es:di+BDS.secpertrack]
					; now, [temp_h]:ax = track #, dx = sector
		;inc	dl		; sector number	is 1 based.
		; 18/12/2022
		inc	dx
		mov	[cursec], dl	; save current sector
		mov	cx, [es:di+15h]	; es:di+BDS.heads]
					; get number of	heads
		push	ax
		xor	dx, dx
		mov	ax, [temp_h]	; divide tracks	by heads per cylinder
		div	cx
		mov	[temp_h], ax
		pop	ax
		div	cx		; now, [temp_h]:ax = cylinder #, dx = head
		cmp	word [temp_h], 0
		ja	short baddrive_brdg
		cmp	ax, 1024	; 2^10 currently maxium	for track #.
		ja	short baddrive_brdg
		mov	[curhd], dl	; save current head
		mov	[curtrk], ax	; save current track

; we are now set up for the i/o. normally, we consider the dma boundary
; violations here. not true. we perform the operation as if everything is
; symmetric; let the int 13 handler worry about the dma violations.

		mov	ax, [seccnt]
		call	block		; (cas - call/ret)
		;call	done
		;retn
		; 18/12/2022
		jmp	done

; ---------------------------------------------------------------------------

baddrive_brdg:				
		jmp	baddrive

; =============== S U B	R O U T	I N E =======================================

;--------------------------------------------------------------
; set the drive-last-accessed flag for diskette only. 
; we know that the hard disk will not be removed.
; es:di -> current bds.
; ds -> Bios_Data
; ax,cx,si are destroyed.
;--------------------------------------------------------------

		; 19/10/2022
iosetup:	
		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
		mov	[tim_drv], al	; save drive letter

; determine proper head settle values

		cmp	byte [media_set_for_format], 0
		jnz	short skip_dpt_setting
		mov	al, [eot]	; fetch	up eot before changing ds
		push	ds
		lds	si, [dpt]	; get pointer to disk base table
		mov	[si+4],	al
		mov	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
		mov	ah, [si+4]	; [si+DISK_PARMS.DISK_EOT]
		pop	ds
		mov	[motorstartup], al
		mov	[save_eot], ah

; for 3.5" drives, both external as well as on the k09, we need to set the
; motor start time to 4. this checking for every i/o is going to affect
; performance across the board, but is necessary!!

		push	ds
		lds	si, [dpt]	; get pointer to disk base table
		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
					; ffSmall
		jnz	short motor_start_ok
		mov	al, 4
		xchg	al, [si+10]	; [si+DISK_PARMS.DISK_MOTOR_STRT]
motor_start_ok:

; ds:si now points to disk parameter table.
; get current settle and set fast settle
				
		;xor	al, al
		;inc	al		; ibm wants fast settle	to be 1
		; 18/12/2022
		xor	ax, ax
		inc	ax
		xchg	al, [si+9]	; [si+DISK_PARMS.DISK_HEAD_STTL]
					; get settle and set up	for fast
		pop	ds
		mov	[settlecurrent], al
		mov	al, 15		; NORMSETTLE
					; someone has diddled the settle
		mov	[settleslow], al
skip_dpt_setting:			
		retn

; =============== S U B	R O U T	I N E =======================================

;--------------------------------------------------------------
; set time of last access, and reset default values in the dpt.
;
;	  note: trashes (at least) si
;--------------------------------------------------------------

		; 19/10/2022
done:
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jnz	short ddbx	; do not set for non-removable media
		call	set_tim
;diddleback:
; 09/12/2022
diddle_back:				
		pushf
		cmp	byte [media_set_for_format], 0
		jnz	short nodiddleback
		push	ax
		push	es
		les	si, [dpt]
		mov	al, [save_eot]
		mov	[es:si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, [settlecurrent]
		mov	ah, [motorstartup]
		mov	[es:si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		mov	byte [es:si+3], 2 ; [es:si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	[es:si+0Ah], ah	; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
		pop	es
		pop	ax
nodiddleback:				
		popf
ddbx:					
		retn

; =============== S U B	R O U T	I N E =======================================

;--------------------------------------------------------------
;read the number of sectors specified in ax, 
;handling track boundaries
;es:di -> bds for this drive
;--------------------------------------------------------------

		 ; 19/10/2022
block:	
		or	ax, ax
		jz	short ddbx
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jz	short block_floppy ;

; check	to see if multi	track operation	is allowed. if not
; we have to go	to the block_floppy below to break up the operation.

		test	byte [multrk_flag], 80h
		;test	byte ptr ds:multrk_flag, 80h ; multrk_on
		jz	short block_floppy
		call	Disk
		xor	ax, ax
		retn
; ---------------------------------------------------------------------------

block_floppy:

; read at most 1 track worth. perform minimization at sector / track
				
		mov	cl, [es:di+19]	; [es:di+BDS.secpertrack]
		inc	cl
		sub	cl, [cursec]
		xor	ch, ch
		cmp	ax, cx
		jnb	short gotmin
		mov	cx, ax

gotmin:

; ax is the requested number of sectors to read
; cx is the number that we can do on this track
					
		push	ax
		push	cx
		mov	ax, cx
		call	Disk
		pop	cx
		pop	ax

; cx is the number of sectors just transferred

		sub	ax, cx		; reduce sectors-remaining by last i/o
		shl	cl, 1
		add	bh, cl		; adjust transfer address
		jmp	short block
dskerr_brdg:				
		jmp	dskerr

; =============== S U B	R O U T	I N E =======================================

; 15/10/2022

;--------------------------------------------------------------
;perform disk i/o with retries
; al = number of sectors (1-8, all on one track)
; es:di point to drive parameters
; xfer_seg:bx = transfer address 
;		(must not cross a 64k physical boundary)
; [rflag] = 2 if read, 3 if write
; [verify] = 0 for normal, 1 for verify after write
;--------------------------------------------------------------

		 ; 19/10/2022
Disk:

; Check for hard disk format and
; if TRUE then set max error count to 2

		mov	bp, 5		; MAXERR
					; set up retry count
		test	byte [es:di+23h], 1	;
					; [es:di+BDS.flags], fnon_removable
		jz	short GetRdWrInd
		cmp	ah, 4		; romverify ; Is this a	track verify?
		jz	short GetRdWrInd
		mov	bp, 2		; This is not verify so only 1 retry
GetRdWrInd:				
		mov	[vretry_cnt], bp ; verify op. retry cnt for write-verify
		mov	[soft_ecc_cnt], bp ; soft ecc error retry count.
		mov	ah, [rflag]	; get read/write indicator
;retry:
; 09/12/2022
_retry:					
		push	ax
		mov	dx, [curtrk]
		test	byte [es:di+23h], 1
		jz	short disk_not_mini
		cmp	word [es:di+47h], 1 ; [es:di+BDS.bdsm_ismini]
					; is this a mini disk? ((logical dos partition))
		jnz	short disk_not_mini ; no. continue to next.
		add	dx, [es:di+49h]	; [es:di+BDS.bdsm_hidden_trks]
					; add hidden trks.
disk_not_mini:				
		ror	dh, 1
		ror	dh, 1
		or	dh, [cursec]
		mov	cx, dx
		xchg	ch, cl		;  cl =	sector,	ch = cylinder
		mov	dh, [curhd]	; load current head number and
		mov	dl, [es:di+4]	; physical drive number
					; [es:di+BDS.drivenum]
		cmp	byte [es:di+22h], 5 ; [es:di+BDS.formfactor], ffHardFile
		jz	short do_fast	; hard files use fast speed

; if we have [step_drv] set to -1, we use the slow settle time.
; this helps when we have just done a reset disk operation and the head has
; been moved to another cylinder - the problem crops up with 3.5" drives.

		cmp	byte [step_drv], 0FFh ; -1
		jz	short do_writej
		cmp	ah, 2		; romread
		jz	short do_fast
		cmp	ah, 4		; romverify
		jz	short do_fast
do_writej:	

; reads always fast, unless we have just done a disk reset operation
			
		jmp	short do_write	; reads	always fast
; ---------------------------------------------------------------------------

do_fast:				
		call	fastspeed	; change settle	mode

testerr:				
		jb	short dskerr_brdg

; set drive and track of last access

		mov	[step_drv], dl
		mov	[es:di+46h], ch	; [es:di+BDS.track]
no_set:
		;cmp	word [wrtverify], 103h
		cmp	word [rflag], 103h ; check for write and verify
		jz	short doverify
noverify:				
		pop	ax

; check the flags word in the bds to see if the drive is non removable
; if not we needn't do anything special
; if it is a hard disk then check to see if multi-track operation
; is specified. if specified we don't have to calculate for the next
; track since we are already done. so we can go to the exit of this routine.

		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jz	short its_removable
		test	byte [multrk_flag], 80h ; multrk_on
		jnz	short disk_ret
its_removable:				
		and	cl, 3Fh		; eliminate cylinder bits from sector
		xor	ah, ah
		sub	[seccnt], ax	; reduce count of sectors to go	next sector
		add	cl, al
		mov	[cursec], cl
		cmp	cl, [es:di+13h]	; [es:di+BDS.secpertrack]
					; see if sector/track limit reached
		jbe	short disk_ret
		mov	byte [cursec], 1 ; start with first sector of next track
		mov	dh, [curhd]
		inc	dh
		cmp	dh, [es:di+15h]	; [es:di+BDS.heads]
		jb	short noxor
		xor	dh, dh
		inc	word [curtrk]
noxor:					
		mov	[curhd], dh
disk_ret:				
		clc
		retn
; ---------------------------------------------------------------------------

; 15/10/2022

;--------------------------------------------------------------
; the request is for write. determine if we are talking about
; the same track and drive. if so, use the fast speed.
;--------------------------------------------------------------

do_write:				
		cmp	dl, [step_drv]
		jnz	short do_norm	; we have changed drives
		cmp	ch, [es:di+46h]	; [es:di+BDS.track]
		jz	short do_fast	; we are still on the same track

do_norm:				
		call	normspeed
		jmp	short testerr
; ---------------------------------------------------------------------------

;--------------------------------------------------------------
; we have a verify request also. get state info and go verify
;--------------------------------------------------------------

doverify:				
		pop	ax
		push	ax
		mov	ah, 4
		call	fastspeed
		jnb	short noverify

; check the error returned in ah to see if it is a soft ecc error.
; if it is not we needn't do anything special. if it is a soft
; ecc error then decrement the soft_ecc_cnt error retry count. if
; this retry count becomes 0 then we just ignore the error and go to
; no_verify but if we can still try then we call the routine to reset
; the disk and go to dskerr1 to retry the operation.

		cmp	ah, 11h		; soft ecc error ?
		jnz	short not_softecc_err
		dec	word [soft_ecc_cnt]
		jz	short noverify	; no more retry
		call	ResetDisk	; reset	disk
		jmp	short dskerr1	; retry
; ---------------------------------------------------------------------------

not_softecc_err:			; other error.			
		call	ResetDisk
		dec	word [vretry_cnt]
		jmp	short dskerr0
; ---------------------------------------------------------------------------

;--------------------------------------------------------------
; need to special case the change-line error ah=06h.
; if we get this, we need to return it.
;--------------------------------------------------------------

dskerr:					
		cmp	byte [fhave96], 0	; do we	have changeline	support?
		jz	short dskerr_nochangeline ; brif not
		call	checkio
dskerr_nochangeline:			
		cmp	byte [multitrk_format_flag], 1 ; multi trk format request?
		jnz	short dochkagain ; no more retry.
		mov	bp, 1
		mov	byte [multitrk_format_flag], 0 ; clear the flag.
dochkagain:				
		call	again
dskerr0:				
		jz	short harderr
		test	byte [es:di+23h], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jnz	short skip_timeout_chk
		cmp	ah, 80h		; timeout?
		jz	short harderr
skip_timeout_chk:			
		cmp	ah, 0CCh	; write	fault error?
		jz	short write_fault_err ;	then, don't retry.
		mov	word [soft_ecc_cnt], 5 ; MAXERR
					; set soft_ecc_cnt back	to maxerr
dskerr1:				
		pop	ax		; restore sector count
		;jmp	retry
		; 09/12/2022
		jmp	_retry
; ---------------------------------------------------------------------------

write_fault_err:			
		mov	bp, 1		; just retry only once
					; for write fault error.
		jmp	short dskerr1

		; fall into harderr
; ---------------------------------------------------------------------------

; entry point for routines that call maperror themselves

harderr:				
		call	maperror
harderr2:				
		mov	byte [tim_drv], 0FFh
					; force a media check through rom
		mov	cx, [seccnt]	; get count of sectors to go
		mov	sp, [spsav]	; recover entry	stack pointer

; since we are performing a non-local goto, restore the disk parameters

		;jmp	diddleback
		; 09/12/2022
		jmp	diddle_back

; =============== S U B	R O U T	I N E =======================================

; change settle value from settlecurrent to whatever is appropriate
; note that this routine is never called for a fixed disk.

		; 19/10/2022
normspeed:
		cmp	byte [media_set_for_format], 0
		jnz	short fastspeed
		push	es
		push	ax
		mov	al, [settleslow]
		les	si, [dpt]	; current disk parm table
		mov	[es:si+9], al	; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	ax
		pop	es
		call	fastspeed
		push	es
		les	si, [dpt]
		mov	byte [es:si+9], 1 ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
					; 1 is fast settle value
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

; if the drive has been marked as too big (i.e. starting sector of the
; partition is > 16 bits, then always return drive not ready.

fastspeed:		
		test	byte [es:di+1Fh], 80h ; [es:di+BDS.fatsiz]
					; ftoobig
		jnz	short notready
		push	es
		mov	es, [xfer_seg]
		int	13h		; DISK -
		mov	[xfer_seg], es
		pop	es
		retn
; ---------------------------------------------------------------------------

notready:				
		stc
		mov	ah, 80h
		retn

; =============== S U B	R O U T	I N E =======================================

; map error returned by rom in ah into corresponding code to be returned to
; dos in al. trashes di. guaranteed to set carry.

maperror:	
		push	cx
		push	es
		push	ds		; set es=Bios_Data
		pop	es
		mov	al, ah		; put error code in al
		mov	[lsterr], al	; terminate list with error code
		mov	cx, 9		; numerr (= errout-errin)
					; number of possible error conditions
		mov	di, errin	; point to error conditions
		repne scasb
		; 10/12/2022
		mov	al, [di+8]	; [di+numerr-1]
					; get translation
		; 19/10/2022 - Temporary ! 
		;db	8Ah, 85h, 8, 0	; mov al, [di+8]
		pop	es
		pop	cx
		stc			; flag error condition
		retn

; =============== S U B	R O U T	I N E =======================================

; set the time of last access for this drive.
; this is done only for removable media. es:di -> bds

set_tim:		
		push	ax
		call	GetTickCnt	; Does INT 1A ah=0 & updates daycnt

; we have the new time. if we see that the time has passed,
; then we reset the threshold counter...

		cmp	dx, [es:di+47h]	; [es:di+BDS.tim_lo]
		jnz	short setaccess
		cmp	cx, [es:di+49h]	; [es:di+BDS.tim_hi]
		;jz	short done_set
		; 12/12/2022
		je	short done_set2
setaccess:				
		mov	byte [accesscount], 0
		mov	[es:di+47h], dx	; [es:di+BDS.tim_lo]
		mov	[es:di+49h], cx	; [es:di+BDS.tim_hi]
done_set:				
		clc
done_set2:		; 12/12/2022
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; this routine is called if an error occurs while formatting or verifying.
; it resets the drive,and decrements the retry count.
; on entry - ds:di - points to bds for the drive
;	     bp    - contains retry count
; on exit    flags indicate result of decrementing retry count

again:	
		call	ResetDisk
		cmp	ah, 6
		jz	short dont_dec_retry_count ; If	it is a	media change error
					; do not decrement retry count.
		dec	bp		; decrement retry count
		retn
; ---------------------------------------------------------------------------

dont_dec_retry_count:			
		or	ah, ah
		retn

; 16/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)

;----------------------------------------------------------------------------
; MSDIOCTL.ASM - MSDOS 6.0 - 1991
;----------------------------------------------------------------------------
; 11/03/2019 - Retro DOS v4.0

; 18/03/2019

; ==========================================================================
;
; NOTE: GetAccessFlag/SetAccessFlag is unpublished function.
;
;      This function is intended to give the user to control the
;      bds table flags of unformatted_media bit.
;      GetAccessFlag will show the status -
;	 a_DiskAccess_Control.dac_access_flag = 0 disk i/o not allowed
;						1 disk i/o allowed
;      SetAccessFlag will set/reset the unformatted_media bit in flags -
;	 a_DiskAccess_Control.dac_access_flag = 0 allow disk i/o
;						1 disallow disk i/o
; ==========================================================================

		; generic ioctl dispatch tables

; BIOSCODE:0C3Ch (MSDOS 6.21, IO.SYS)

; ---------------------------------------------------------------------------
		db 0

; 09/12/2022 
%if 0

IoReadJumpTable: db 8	; ((IoWriteJumpTable-IoReadJumpTable)-1)/2
		dw 0CA7h	; 60h	; GetDeviceParameters
		dw 0EE8h	; 61h	;gh ReadTrack
		dw 0E86h	; 62h	; VerifyTrack
		dw 0CA3h	 	; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 119Ah	; 66h	; GetMediaId
		dw 1269h	; 67h	; GetAccessFlag ; unpublished function
		dw 12C1h	; 68h	; SenseMediaType

IoWriteJumpTable: db 7	; ((IOC_DC_Table-IoWriteJumpTable)-1)/2
		dw 0CF3h	; 40h	; SetDeviceParameters
		dw 0EEFh	; 41h	; WriteTrack
		dw 0DC1h	; 42h	; FormatTrack
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 0CA3h		; Cmd_Error_Proc
		dw 11D2h	; 46h	; SetMediaId
		dw 1280h	; 47h	; SetAccessFlag ; unpublished function

%endif

		; 09/12/2022
IoReadJumpTable: db ((IoWriteJumpTable-IoReadJumpTable)-1)/2 ; 8
		dw GetDeviceParameters	; 60h
		dw ReadTrack		; 61h
		dw VerifyTrack		; 62h
		dw Cmd_Error_Proc
		dw Cmd_Error_Proc
		dw Cmd_Error_Proc
		dw GetMediaId		; 66h
		dw GetAccessFlag	; 67h ; unpublished function
		dw SenseMediaType	; 68h

IoWriteJumpTable: db ((IOC_DC_Table-IoWriteJumpTable)-1)/2 ; 7
		dw SetDeviceParameters	; 40h
		dw WriteTrack		; 41h
		dw FormatTrack		; 42h
		dw Cmd_Error_Proc
		dw Cmd_Error_Proc
		dw Cmd_Error_Proc
		dw SetMediaId		; 46h
		dw SetAccessFlag	; 47h ; unpublished function

; ==========================================================================
; IOC_DC_Table
;
; This table contains all of the valid generic IOCtl Minor codes for
; major function 08 to be used by the Ioctl_Support_Query function.
; Added for 5.00
; ==========================================================================

IOC_DC_Table:	db 60h			; GET_DEVICE_PARAMETERS
		db 40h			; SET_DEVICE_PARAMETERS
		db 61h			; READ_TRACK
		db 41h			; WRITE_TRACK
		db 62h			; VERIFY_TRACK
		db 42h			; FORMAT_TRACK
		db 66h			; GET_MEDIA_ID
		db 46h			; SET_MEDIA_ID
		db 67h			; GET_ACCESS_FLAG
		db 47h			; SET_ACCESS_FLAG
		db 68h			; SENSE_MEDIA_TYPE

;IOC_DC_TABLE_LEN EQU $ - IOC_DC_Table

; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
; Do_Generic_IOCtl: perform generic ioctl request
;
;    input: AL contains logical drive
;
;	functions are dispatched through a call. On return, carry indicates
;	error code in al. Note::bES:b& ds undefined on return from
;	subfunctions.
;
; ==========================================================================

; 11/03/2019
		; 19/10/2022
do_generic_ioctl:			; 2C7h:0C6Bh = 70h:31DBh
		call	SetDrive	; ES:DI	Points to bds for drive
		push	es
		les	bx, [ptrsav]	; ES:BX	Points to request header
		cmp	byte [es:bx+0Dh], 8 ; [es:bx+IOCTL_REQ.MAJORFUNCTION]
					; RAWIO
		mov	al, [es:bx+0Eh]	; [es:bx+IOCTL_REQ.MINORFUNCTION]
		pop	es
		jnz	short IoctlFuncErr

		; cas note: Could do the above two blocks in reverse order.
		; Would have to preserve al for SetDrive

		; 10/12/2022
		mov	si, IoReadJumpTable
		;mov	si, 0C3Ch	; IoReadJumpTable
					; at 2C7h:0C3Ch	= 70h:31ACh
		test	al, 20h		; GEN_IOCTL_FN_TST ; test of req. function
		jnz	short NotGenericWrite ; function is a read.
		; 10/12/2022
		mov	si, IoWriteJumpTable
		;mov	si, 0C4Fh	; IoWriteJumpTable
					; at 2C7h:0C4Fh	= 70h:31BFh
NotGenericWrite:			
		and	al, 0DFh	; ~GEN_IOCTL_FN_TST ; get rid of read/write bit
		sub	al, 40h		; offset for base function
		cmp	al, [cs:si]
		ja	short IoctlFuncErr
		cbw
		shl	ax, 1
		inc	si
		add	si, ax
		call	near [cs:si]
		;call	word ptr cs:[si]
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
		mov	ah, 81h		; Return this status in	case of	carry
		retn			; Pass carry flag through to exit code
; ---------------------------------------------------------------------------

		; Cmd_Error_Proc is called as a procedure and also use
		; as a fall through from above
Cmd_Error_Proc:				; 2C7h:0CA3h = 70h:3213h
		pop	dx

IoctlFuncErr:				
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;**	GetDeviceParameters:
;
;	GetDeviceParameters implements the generic ioctl function:
;	majorcode=RAWIO, minorcode=GetDeviceParameters (60h)
;
;	ENTRY	(ES:di) = BDS for drive
;		PtrSav = long pointer to request header
;	EXIT	??? BUGBUG
;	USES	??? BUGBUG
; ==========================================================================

		; 19/10/2022
GetDeviceParameters:
		; Copy info from bds to the device parameters packet

		lds	bx, [ptrsav]	; DS:BX	points to request header
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
					; (DS:BX) = return buffer
		mov	al, [es:di+34]	; [es:di+BDS.formfactor]
		mov	[bx+1],	al	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	ax, [es:di+35]	; [es:di+BDS.flags]
		and	ax, 3		; fnon_removable+fchangeline
					; Mask off other bits
		mov	[bx+2],	ax	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		mov	ax, [es:di+37]	; [es:di+BDS.cylinders]
		mov	[bx+4],	ax	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		xor	al, al		; Set media type to default
		mov	[bx+6],	al	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
					
		; copy recommended bpb
		lea	si, [di+39]	; [di+BDS.rbytespersec]	= [di+BDS.R_BPB]
		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; BUILD_DEVICE_BPB
		jz	short UseBpbPresent
		push	ds		; Save request packet segment
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
					; Point back to Bios_Data
		call	checksingle
		call	GetBp		; Build	the bpb	from scratch
		pop	ds		; Restore request packet segment
		jb	short GetParmRet
		lea	si, [di+6]	; [di+BDS.bytespersec] = [di+BSD.DP_BPB]
					; Use this subfield of bds instead
UseBpbPresent:				
		lea	di, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
					; This is where	the result goes
		mov	cx, 25		; A_BPB.size - 6
					; For now use 'small' bpb
		push	ds		; reverse segments for copy
		push	es
		pop	ds
		pop	es
		rep movsb
		
		; 12/12/2022
		; cf=0 (test instruction -above- resets cf) 	
		;clc
GetParmRet:				
		retn
; ---------------------------------------------------------------------------

; 17/10/2022
; 16/10/2022

; ==========================================================================
; SetDeviceParameters:
;
; input: ES:di points to bds for drive
; ==========================================================================

		; 19/10/2022
SetDeviceParameters:			; 2C7h:0CF3h = 70h:3263h
		lds	bx, [ptrsav]	; DS:BX	points to request header
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		or	word [es:di+23h], 140h ; [es:di+BDS.flags]
					; fchanged_by_format|fchanged
		test	byte [bx], 2	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; ONLY_SET_TRACKLAYOUT
		jnz	short setTrackTable
		mov	al, [bx+1]	; [bx+A_DEVICEPARAMETERS.DP_DEVICETYPE]
		mov	[es:di+34], al	; [es:di+BDS.formfactor]
		mov	ax, [bx+4]	; [bx+A_DEVICEPARAMETERS.DP_CYLINDERS]
		mov	[es:di+37], ax	; [es:di+BDS.cylinders]
		mov	ax, [bx+2]	; [bx+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES]
		push	ds
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; 2C7h:30h = 70h:25A0h
		;cmp	byte [fhave96], 0
		cmp	byte [fhave96], 0
		pop	ds
		jnz	short HaveChange ; we have changeline support
		; 10/12/2022
		and	al, 0FDh
		;and	ax, 0FFFDh	; ~fchangeline

		; Ignore all bits except non_removable and changeline
HaveChange:				
		and	ax, 3		; fnon_removable|fchangeline
		mov	cx, [es:di+35]	; [es:di+BDS.flags]
		and	cx, 0FDF4h	; ~(fnon_removable|fchangeline|good_tracklayout|unformatted_media)
		or	ax, cx
		mov	[es:di+35], ax	; [es:di+BDS.flags]
		mov	al, [bx+6]	; [bx+A_DEVICEPARAMETERS.DP_MEDIATYPE]
					; Set media type
		push	ds
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
		mov	[mediatype], al
		;mov	ds:mediatype, al
		pop	ds

		; The media changed (maybe) so we will have to do a set dasd
		; the next time we format a track

		; 10/12/2022
		or	byte [es:di+35], 80h
		;or	word [es:di+35], 80h ; [es:di+BDS.flags]
					; set_dasd_true
		push	di		; Save bds pointer

		; Figure out what we are supposed to do with the bpb
		; were we asked to install a fake bpb?

		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; INSTALL_FAKE_BPB
		jnz	short InstallFakeBpb

		; were we returning a fake bpb when asked to build a bpb?

		; 10/12/2022
		test	byte [es:di+35], 4
		;test	word [es:di+35], 4 ; [es:di+BDS.flags]
					; return_fake_bpb
		jz	short InstallRecommendedBpb

		; we were returning a fake bpb but we can stop now

		; 10/12/2022
		and	byte [es:di+35], 0FBh
		;and	word [es:di+35], 0FFFBh ; [es:di+BDS.flags]
					; ~return_fake_bpb
InstallRecommendedBpb:			
		mov	cx, 31		; A_BPB.size
		lea	di, [di+27h]	; [di+BDS.R_BPB] = [di+BDS.rbytespersec]
		jmp	short CopyTheBpb
; ---------------------------------------------------------------------------

InstallFakeBpb:
		; 10/12/2022
		or	byte [es:di+35], 4				
		;or	word [es:di+35], 4 ; byte [es:di+BDS.flags]
					; return_fake_bpb
		mov	cx, 25		; A_BPB.size - 6
					; move 'smaller' bpb
		lea	di, [di+6]	; [es:di+BDS.BPB] = [es:di+BDS.bytespersec]

CopyTheBpb:				
		lea	si, [bx+7]	; [bx+A_DEVICEPARAMETERS.DP_BPB]
		rep movsb
		push	ds		; Save packet segment
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; Setup	for ds -> Bios_Data
		call	RestoreOldDpt	; Restore the old Dpt from TempDpt
		pop	ds		; Restore packet segment
		pop	di		; Restore bds pointer
setTrackTable:				
		mov	cx, [bx+38]
		push	ds
		mov	ds, [cs:BIOSDATAWORD]
		mov	[sectorspertrack], cx
		pop	ds
		; 10/12/2022
		and	byte [es:di+35], 0F7h
		;and	word [es:di+35], 0FFF7h ; [es:di+BDS.flags]
					; ~good_tracklayout
		test	byte [bx], 4	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; TRACKLAYOUT_IS_GOOD
		jz	short UglyTrackLayOut
		; 10/12/2022
		or	byte [es:di+35], 8
		;or	word [es:di+35], 8 ; [es:di+BDS.flags]
					; good_tracklayout
UglyTrackLayOut:			
		cmp	cx, 63		; MAX_SECTORS_IN_TRACK
		ja	short TooManyPerTrack
		;jcxz	short SectorInfoSaved
		jcxz	SectorInfoSaved	; 19/10/2022
		mov	di, tracktable
		lea	si, [bx+40]	; [bx+A_DEVICEPARAMETERS.DP_SECTORTABLE]
		; 17/10/2022
		mov	es, [cs:BIOSDATAWORD]
		;mov	es, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; Trash	our bds	pointer
StoreSectorInfo:			
		inc	di
		inc	di		; Skip over cylinder and head
		lodsw			; Get sector id
		stosb			; Copy it
		lodsw			; Get sector size
		call	SectSizeToSectIndex
		stosb			; Store	sector SIZE index
		loop	StoreSectorInfo
SectorInfoSaved:			
		clc
		retn
; ---------------------------------------------------------------------------

TooManyPerTrack:			
		mov	al, 0Ch
		stc
		retn
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
; FormatTrack:
; if specialfunction byte is 1,then this is a status call to see if there is
; rom support for the combination of sec/trk and # of cyln,and if the
; combination is legal. if specialfunction byte is 0,then format the track.
;
; input: ES:di points to bds for drive
;
; output:
;	for status call:
;	specialfunction byte set to:
;		0 - rom support + legal combination
;		1 - no rom support
;		2 - illegal combination
;		3 - no media present
;	carry cleared.
;
;	for format track:
;		carry set if error
;
; ==========================================================================

; 16/03/2019

		; 19/10/2022
FormatTrack:
		lds	bx, [ptrsav]
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET
		test	byte [bx], 1	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
					; STATUS_FOR_FORMAT
		jz	short DoFormatTrack
		push	ds
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		pop	ds
		mov	[bx], al	; [bx+A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS]
		clc
		retn
; ---------------------------------------------------------------------------

DoFormatTrack:				
		cmp	byte [es:di+34], 5 ; [es:di+BDS.formfactor]
					; DEV_HARDDISK
		jnz	short DoFormatDiskette
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; Point	to Bios_Data (at 2C7h:30h or 70h:25A0h)
		jmp	VerifyTrack
; ---------------------------------------------------------------------------

DoFormatDiskette:			
		mov	cx, [bx+1]
		mov	dx, [bx+3]
		test	byte [bx], 2
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; Setup	ds-> Bios_Data for verify
		jz	short DoFormatDiskette_1
		jmp	VerifyTrack_Err
; ---------------------------------------------------------------------------

DoFormatDiskette_1:			
		call	SetMediaForFormat ; Also moves current Dpt to TempDpt
		cmp	al, 1		;  ROM support for sec/trk,# trks comb?
		jz	short NeedToSetDasd ; Old rom
		cmp	al, 3		; Time out error?
		jnz	short NoSetDasd	; No,fine. (at this point, don't care
					; about	the illegal combination)
		jmp	short FormatFailed
; ---------------------------------------------------------------------------

NeedToSetDasd:				
		push	dx
		call	SetDasd		; INT 13h, AH=17h
		pop	dx
NoSetDasd:				
		call	checksingle	; Do any needed	diskette swapping
		mov	ax, dx		; Get track from packet
		mov	[trknum], ax
		mov	[hdnum], cl	; Store	head from packet
		mov	ah, cl
		mov	bx, tracktable
		mov	cx, [sectorspertrack]

StoreCylinderHead:			
		mov	[bx], ax	; Store	into TrackTable
		add	bx, 4		; Skip to next sector field
		loop	StoreCylinderHead
		mov	cx, 5		; MAXERR - Set up retry	count
FormatRetry:				
		push	cx
		mov	bx, tracktable
		mov	al, [sectorspertrack]
		mov	ah, 5		; romformat
		mov	[xfer_seg], ds
		call	ToRom
		pop	cx
		jb	short FormatError
		push	cx		; Now verify the sectors just formatted.
					; NOTE:	because	of bug in some BIOSes we have to
					;	set ES:BX to 00:00
		push	bx
		xor	bx, bx
		mov	[xfer_seg], bx
		mov	al, [sectorspertrack]
		mov	ah, 4		; romverify
		mov	cl, 1
		call	ToRom
		pop	bx
		pop	cx
		jnb	short FormatOk
FormatError:				
		call	ResetDisk
		mov	byte [had_format_error], 1
		push	ax
		push	cx
		push	dx
		call	SetMediaForFormat
		cmp	al, 1
		jnz	short WhileErr
		call	SetDasd
WhileErr:				
		pop	dx
		pop	cx
		pop	ax
		loop	FormatRetry
FormatFailed:				
		mov	byte [had_format_error], 1
					; Set the format error flag
		cmp	ah, 6		; DSK_CHANGELINE_ERR - convert change line
		jnz	short DoMapIt	; Error	to time	out error
		mov	ah, 80h		; DSK_TIMEOUT_ERR
DoMapIt:				
		jmp	maperror
; ---------------------------------------------------------------------------

FormatOk:				
		mov	byte [had_format_error], 0 ; reset the format error flag
		retn
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;
; VerifyTrack:
;
; input: ES:di points to bds for drive
; ==========================================================================

VerifyTrack:				
		push	ds
		lds	bx, [ptrsav]	; DS:BX points to request header.
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]

		; Come here with DS:[BX] -> packet, ES:[DI] -> bds

		mov	cx, [bx+3]	; [bx+A_VERIFYPACKET.VP_CYLINDER]
		mov	ax, [bx+1]	; [bx+A_VERIFYPACKET.VP_HEAD]
		mov	dx, [bx+5]	; [bx+A_FORMATPACKET.FP_TRACKCOUNT]
		mov	bl, [bx]	; [bx+A_FORMATPACKET.FP_SPECIALFUNCTIONS]
					; Get option flag word
		pop	ds
		mov	byte [rflag], 4	; romverify
		mov	[curtrk], cx
		mov	[curhd], al	; ASSUME heads < 256
		mov	cx, [sectorspertrack]

		; Check specialfunctions to see if DO_FAST_FORMAT has been
		; specified if not we should go to the normal track verification
		; routine. If fast format has been specified we should get the
		; number of tracks to be verified and check it to see if it is
		; > 255. If it is then it is an error and we should go to
		; VerifyTrack_Err. If not multiply the number of tracks by the
		; sectors per track to get the total number of sectors to be
		; verified. This should also be less than equal to 255
		; otherwise we go to same error exit. If everything is okay
		; we initalise cx to the total sectors. use ax as a temporary
		; register.

					; Special function requested?	
		test	bl, 2		; DO_FAST_FORMAT
		jz	short NormVerifyTrack
		mov	ax, dx		; Get ax = number of trks to verify
		or	ah, ah
		jnz	short VerifyTrack_Err ; #tracks > 255
		mul	cl
		or	ah, ah
		jnz	short VerifyTrack_Err ; #sectors > 255	
		mov	cx, ax
		; 10/12/2022
		test	byte [es:di+35], 1
		;test	word [es:di+35], 1 ; [es:di+BDS.flags]
					; fnon_removable
		jz	short NormVerifyTrack
					; Multitrack operation = on?
		; 10/12/2022
		; 19/10/2022
		test	byte [multrk_flag], 80h
		;test	word [multrk_flag], 80h ; MULTI_TRK_ON
		;;test	ds:multrk_flag,	80h ; MULTI_TRK_ON
		jz	short NormVerifyTrack
		mov	byte [multitrk_format_flag], 1
NormVerifyTrack:			
		xor	ax, ax		; 1st sector
		xor	bx, bx
		mov	[xfer_seg], bx	; Use 0:0 as the transfer address for verify
		call	TrackIo
		mov	byte [multitrk_format_flag], 0
		retn
; ---------------------------------------------------------------------------

VerifyTrack_Err:			
		mov	ah, 1
		jmp	maperror
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;
; ReadTrack:
;
; input: ES:di points to bds for drive
;
; ==========================================================================

ReadTrack:				
		mov	byte [rflag], 2	; romread
		jmp	short ReadWriteTrack
; ---------------------------------------------------------------------------

WriteTrack:

; ==========================================================================
;
; WriteTrack:
;
; input: ES:di points to bds for drive
;
; ==========================================================================
				
		mov	byte [rflag], 3	; romwrite

		; Fall into ReadWriteTrack

; ==========================================================================
;
; readWriteTrack:
;
; input:
;    ES:di points to bds for drive
;    rFlag - 2 for read,3 for write
;
; ==========================================================================

ReadWriteTrack:	
		; save bds pointer segment so we can use it to access
		; our packet. Notice that this is not the standard register
		; assignment for accessing packets
		
		; 19/10/2022	
		push	es
		les	bx, [ptrsav]	; ES:BX	-> to request header
		les	bx, [es:bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		mov	ax, [es:bx+3]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_CYLINDER]
		mov	[curtrk], ax
		mov	ax, [es:bx+1]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_HEAD]
		mov	[curhd], al	; Assume heads < 256!!!
		mov	ax, [es:bx+5]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_FIRSTSECTOR]
		mov	cx, [es:bx+7]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_SECTORSTOREADWRITE]
		les	bx, [es:bx+9]	; [es:bx+A_TRACKREADWRITEPACKET.TRWP_TRANSFERADDRESS]
					; Get transfer address

		; we just trashed our packet address, but we no longer care

		mov	[xfer_seg], es	; Pass transfer	segment
		pop	es

		; Fall into TrackIo

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

; ==========================================================================
;
; TrackIo:
;    performs track read/write/verify
;
;   input:
;      rFlag	- 2 = read
;		  3 = write
;		  4 = verify
;      AX	- Index into track table of first sector to io
;      CX	- Number of sectors to io
;      Xfer_Seg:BX - Transfer address
;      ES:DI	- Pointer to bds
;      CurTrk	- Current cylinder
;      CurHd	- Current head
;
; ==========================================================================

; 16/03/2019 - Retro DOS v4.0
		
		; 19/10/2022
TrackIo:	
					; Procedure `disk' will pop stack to
		mov	[spsav], sp	; SpSav	and return if error
		call	checksingle	; Ensure correct disk is in drv
		cmp	byte [media_set_for_format], 1
					; See if we have already set	disk
		jz	short Dptalreadyset ; base table
		push	ax		; set up tables	and variables for i/o
		push	cx
		call	iosetup
		pop	cx
		pop	ax
Dptalreadyset:				; Point si at the table entry of the			
		mov	si, tracktable	; first sector to be io'd
		shl	ax, 1
		shl	ax, 1
		add	si, ax

		; WE WANT:
		; CX to	be the number of times we have to loop
		; DX to	be the number of sectors we read on each iteration
		
		mov	dx, 1
		; 12/12/2022
		test	byte [es:di+23h], 8
		;test	word [es:di+35], 8 ; [es:di+BDS.flags]
					; good_tracklayout
		jz	short ionextsector
		
		xchg	dx, cx		; HEY! We can read all secs in one blow
ionextsector:				
		push	cx
		push	dx
		inc	si
		inc	si		; Skip over the	cylinder and head in
					; the track table
		lodsb			; Get sector ID	from track table
		mov	[cursec], al

		; assumptions for a fixed disk multi-track disk	i/o
		; 1). In the input CX (# of sectors to go) to TrackIo,
		;     only CL is valid.
		; 2). Sector size should be set	to 512 bytes.
		; 3). Good track layout
		
		; 12/12/2022
		test	byte [es:di+23h], 1
		;test	word [es:di+35], 1 ; [es:di+BDS.flags]
					; fnon_removable ; Fixed disk?
		jz	short IoRemovable ; No
		; 12/12/2022
		test	byte [multrk_flag], 80h
		;test	word [multrk_flag], 80h ; MULTI_TRK_ON
						; Allow multi-track operation?
		jz	short IoRemovable ; No,don't do that.
		mov	[seccnt], dx
		mov	ax, dx
		call	Disk
		pop	dx
		pop	cx
		clc
		retn
; ---------------------------------------------------------------------------

IoRemovable:				
		lodsb			; Get sector size index	from track
					; table	and save it
		push	ax
		push	si
		push	ds		; Save Bios_Data
		push	ax
		mov	ah, [eot]	; Preserve whatever might be in	ah
					; Fetch	EOT while ds-> Bios_Data
		lds	si, [dpt]
		mov	[si+3],	al	; [si+DISK_PARMS.DISK_SECTOR_SIZ]
		mov	[si+4],	ah	; [si+DISK_PARMS.DISK_EOT]
		pop	ax
		pop	ds
		mov	al, dl
		mov	[seccnt], ax
		call	Disk
		pop	si		; Advance buffer pointer by adding
					; sector size
		pop	ax
		call	SectorSizeIndexToSectorSize
		add	bx, ax
		pop	dx
		pop	cx
		loop	ionextsector
		cmp	byte [media_set_for_format], 1
		;jz	short NoNeedDone
		; 12/12/2022
		je	short NoNeedDone2
		call	done		; set time of last access, and reset
					; entries in Dpt.
NoNeedDone:				
		clc
NoNeedDone2:
		retn

; =============== S U B	R O U T	I N E =======================================

; ---------------------------------------------------------------------------
;
; The sector size in bytes needs to be converted to an index value for the ibm
; rom. (0=>128,1=>256,2=>512,3=>1024). It is assumed that only these values
; are permissible.
;
; On Input   AX contains sector size in bytes
; On Output  AL Contains index
; All other registers preserved
;
; ---------------------------------------------------------------------------

SectSizeToSectIndex:	
		cmp	ah, 2		; (0=>128,1=>256,2=>512,3=>1024)
					; examine upper	byte only
		ja	short OneK
		mov	al, ah		; value	in AH is the index!
		retn
; ---------------------------------------------------------------------------

OneK:					
		mov	al, 3
		retn

; =============== S U B	R O U T	I N E =======================================


SectorSizeIndexToSectorSize:
		mov	cl, al
		mov	ax, 128
		shl	ax, cl
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;
; SetDASD
;
; Set up the rom for formatting.
; we have to tell the rom bios what type of disk is in the drive.
;
; On Input   - ES:di - Points to bds
;
; ---------------------------------------------------------------------------

		; 19/10/2022
SetDasd:	
		cmp	byte [had_format_error], 1 ;
					; See if we've previously set dasd type
		jz	short DoSetDasd
		; 10/12/2022
		test	byte [es:di+23h], 80h
		;test	word [es:di+23h], 80h ; [es:di+BDS.flags]
					; set_dasd_true
		jz	short DasdHasBeenSet
		; 10/12/2022
		and	byte [es:di+23h], 7Fh
		;and	word [es:di+23h], 0FF7Fh ; [es:di+BDS.flags]
					; ~set_dasd_true
DoSetDasd:				
		mov	byte [had_format_error], 0 ; Reset it
		mov	byte [gap_patch], 50h ; Format gap for 48tpi disks
		mov	al, 4
		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
					; DEV_3INCH720KB
		jz	short DoSet
		cmp	byte [es:di+22h], 1 ; [es:di+BDS.formfactor]
					; DEV_5INCH96TPI
		jz	short GotBig
		mov	al, 1
		jmp	short DoSet
; ---------------------------------------------------------------------------

GotBig:					
		mov	al, 2		; 160/320k in a	1.2 meg	drive
		cmp	byte [mediatype], 0
		jnz	short DoSet
		;mov	al, 3		; 1.2meg in a 1.2meg drive
		; 10/12/2022
		;inc	al  ; al = 3
		; 18/12/2022
		inc	ax  ; al = 3
		mov	byte [gap_patch], 54h
DoSet:					
		push	ds
		push	si
		mov	ds, [zeroseg]	; Point	to interrupt vectors

		lds	si, [DSKADR]
		;lds	si, [78h]	; [DSKADR]  (Int 1Eh)
		;;lds	si, ds:78h		

		mov	byte [si+9], 0Fh ;
					; [si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	ds
		mov	ah, 17h
		mov	dl, [es:di+4]
		int	13h		; DISK - DISK -	SET TYPE (AT,XT2,XT286,CONV,PS
					; AL = disk type AL = 03h - high-capacity disk in high-capacity	drive
DasdHasBeenSet:				
		mov	ah, [es:di+13h]	; [es:di+BDS.secpertrack]
		mov	[formt_eot], ah
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;
; Set Media Type for Format
; Performs the int 13 with ah = 18h to see if the medium described in the
; BPB area in the BDS can be handled by the rom.
; On Input, ES:DI -> current BDS.
; The status of the operation is returned in AL
;
;	- 0 - if the support is available,and the combination is valid.
;	- 1 - no rom support
;	- 2 - illegal combination
;	- 3 - no media present (rom support exists but cannot determine now)
;
; Flags also may be altered. All other registers preserved.
; If the call to rom returns no error,then the current Dpt is "replaced" by
; the one returned by the rom. This is Done by changing the pointer in [Dpt]
; to the one returned. the original pointer to the disk base table is stored
; in TempDpt, until it is restored.
;
; ---------------------------------------------------------------------------

		; 19/10/2022
SetMediaForFormat:	
		push	cx
		push	dx

		; If we have a format error, then do not change Dpt, TempDpt.
		; but we need to call int 13h, ah=18h again.

		cmp	byte [had_format_error], 1
		jz	short SkipSaveDskAdr
		xor	al, al		; If already done return 0
		cmp	byte [media_set_for_format], 1
		jnz	short DoSetMediaForFormat
		jmp	SetMediaRet	; Media	already	set
; ---------------------------------------------------------------------------

DoSetMediaForFormat:			
		push	es
		push	si
		mov	es, [zeroseg]	; Point to interrupt vectors
		les	si, [es:DSKADR]
		;les	si, es:78h	; [es:DSKADR]
					; Get pointer to disk base table
		mov	[dpt], si
		mov	[dpt+2], es	; Save pointer to table

		; Initialize the head settle time to 0Fh. See the offsets
		; given in dskprm.inc.

		mov	byte [es:si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
		pop	si
		pop	es

SkipSaveDskAdr:				
		mov	cx, [es:di+25h]	; [es:di+BDS.cylinders]
		dec	cx
		and	ch, 3
		ror	ch, 1
		ror	ch, 1
		xchg	ch, cl
		or	cl, [es:di+13h]	; [es:di+BDS.secpertrack]
		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
		push	es
		push	ds
		push	si
		push	di
		mov	ah, 18h
		int	13h		; DISK - SET MEDIA TYPE	FOR FORMAT (AT model 3x9,XT2,XT286,PS)
					; DL = drive number, CH	= lower	8 bits of number of tracks, CL = sectors per track
		jb	short FormaStatErr
		cmp	byte [had_format_error], 1
		jz	short skip_disk_base_setting
		push	es		; Save segment returned	by the rom
		mov	es, [zeroseg]	; Point	to interrupt vector segment
		les	si, [es:DSKADR]
		;les	si, es:78h	; [es:DSKADR] (Int 1Eh)
					; Get current disk base	table
		mov	[tempdpt], si
		mov	[tempdpt+2], es ; Save it
		mov	es, [zeroseg]
		;mov	es:78h,	di
		mov	[es:DSKADR], di
		;pop	word ptr es:7Ah	; replace with one returned by rom
		pop	word [es:DSKADR+2]
		mov	byte [media_set_for_format], 1
skip_disk_base_setting:			
		xor	al, al		; Legal	combination + rom support code
		;mov	ds:had_format_error, al	; Reset	the flag
		mov	[had_format_error], al
		jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormaStatErr:
		; 10/12/2022
		mov	al, 3
				
		cmp	ah, 0Ch		; DSK_ILLEGAL_COMBINATION
					; Illegal combination =	0Ch
		jz	short FormatStatIllegalComb
		cmp	ah, 80h		; DSK_TIMEOUT_ERR
		jz	short FormatStatTimeOut
		; 10/12/2022
		;dec	al
		; 18/12/2022
		dec	ax
		; al = 2
		;mov	al, 1		; Function not supported.
		;jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatIllegalComb:
		; 10/12/2022
		;dec	al	; 3 -> 2 or 2 -> 1
		; 18/12/2022
		dec	ax
		; al = 2				
		;mov	al, 2		; Function supported, but
					; Illegal sect/trk,trk combination.
		; 10/12/2022
		;jmp	short PopStatRet
; ---------------------------------------------------------------------------

FormatStatTimeOut:			
		; 10/12/2022
		; al = 3
		;mov	al, 3		; Function supported, but
					; Media	not present.
PopStatRet:				
		pop	di
		pop	si
		pop	ds
		pop	es
SetMediaRet:				
		pop	dx
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;
; RESET THE DRIVE
;
; we also set [Step_Drv] to -1 to force the main disk routine to use the
; slow head settle time for the next operation. this is because the reset
; operation moves the head to cylinder 0,so we need to do a seek the next
; time around - there is a problem with 3.5" drives in that the head does
; not settle down in time,even for read operations!!
;
; ---------------------------------------------------------------------------

ResetDisk:	
		push	ax
		cmp	byte [media_set_for_format], 1
					; Reset while formatting?
		jnz	short ResetDisk_cont
					; Then verify operation in "fmt & vrfy"
		mov	byte [had_format_error], 1 ; Might have failed.
ResetDisk_cont:				
		xor	ah, ah		; So signals that we had a format error
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		mov	byte [step_drv], 0FFh ; -1
					; Zap up the speed
		pop	ax
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;
; This routine sets up the drive parameter table with the values needed for
; format,does an int 13. values in Dpt are restored after a verify is done.
;
; on entry  -	ES:DI - points to bds for the drive
;		Xfer_Seg:BX - points to trkbuf
;		AL    - number of sectors
;		AH    - int 13 function code
;		CL    - sector number for verify
;		DS    - Bios_Data
;
; ON EXIT   -	DS,DI,ES,BX remain unchanged.
;		AX and flags are the results of the int 13
;
; ---------------------------------------------------------------------------

		; 19/10/2022
ToRom:	
		push	bx
		push	si

		; Compaq bug fix - check whether we are using new ROM
		; functionality to set up format, not merely if it exists.
		; This was formerly a check against [new_rom]

		test	byte [media_set_for_format], 1
		jnz	short GotValidDpt
		push	ax
		push	es		; Save bds segment
		cmp	byte [es:di+22h], 2 ; [es:di+BDS.formfactor]
					; ffSmall ; is it a 3.5" drive?
		pushf			; (Save	the cmp	result)
		mov	es, [zeroseg]
		;les	si, es:78h	; Get pointer to disk base table
		les	si, [es:DSKADR]
		;mov	word ptr ds:dpt, si
		;mov	word ptr ds:dpt+2, es ;	 Save pointer to table
		mov	[dpt], si
		mov	[dpt+2], es	; Save pointer to table
		
		mov	al, [formt_eot]
		mov	[es:si+4], al	; [es:si+DISK_PARMS.DISK_EOT]
		mov	al, [gap_patch]
		mov	[es:si+7], al	; [es:si+DISK_PARMS.DISK_FORMT_GAP]
					; Important for	format
		mov	byte [es:si+9], 0Fh ; [es:si+DISK_PARMS.DISK_HEAD_STTL]
					; Assume we are	doing a	seek operation
					; Setup	motor start correctly for 3.5" drives
		popf			; Get result of	earlier	cmp
		jnz	short MotorStrtOK
		mov	byte [es:si+0Ah], 4 ; [es:si+DISK_PARMS.DISK_MOTOR_STRT]
MotorStrtOK:				
		pop	es		; Restore bds segment
		pop	ax
GotValidDpt:				
		mov	dx, [trknum]	; Set track number
		mov	ch, dl		; Set low 8 bits in ch
		mov	dl, [es:di+4]	; Set drive number
		mov	dh, [hdnum]	; Set head number
		push	es		; Save bds segment
		mov	es, [xfer_seg]
		int	13h		; DISK -
		pop	es		; Restore bds segment
		pop	si
		pop	bx
		retn

; ---------------------------------------------------------------------------

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

; BIOSCODE:1124h (MSDOS 6.21, IO.SYS)

; ==========================================================================
;
; get the owner of the physical drive represented by the logical drive in al.
; the assumption is that we **always** keep track of the owner of a drive!!
; if this is not the case, the system may hang, just following the linked list.
;
; ==========================================================================

		; 19/10/2022
ioctl_getown:
		call	SetDrive
		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
					; Get physical drive number
		les	di, [start_bds] ; Get start of bds chain
ownloop:				
		cmp	[es:di+4], al	; [es:di+BDS.drivenum]
		jnz	short getnextBDS
		; 10/12/2022
		test	byte [es:di+23h], 20h
		;test	word [es:di+23h], 20h ; [es:di+BDS.flags]
					; fi_own_physical
		jnz	short exitown
getnextBDS:				
		les	di, [es:di]	; [es:di+BDS.link]
		jmp	short ownloop
; ---------------------------------------------------------------------------

; ==========================================================================
;
; set the ownership of the physical drive represented by the logical drive
; in al to al.
;
; ==========================================================================

		; 19/10/2022
ioctl_setown:
		call	SetDrive
		mov	byte [fsetowner], 1
					; set flag for CheckSingle to look at.
		call	checksingle
		mov	byte [fsetowner], 0
					; set ownership	of drive reset flag
		; Fall into ExitOwn

; ==========================================================================
;
; if there is only one logical drive assigned to this physical drive, return
; 0 to user to indicate this. Enter with ES:di -> the owner's bds.
;
; ==========================================================================

exitown:				
		xor	cl, cl
		; 12/12/2022
		test	byte [es:di+23h], 10h
		;test	word [es:di+23h], 10h ; [es:di+BDS.flags]
					; fi_am_mult
		jz	short exitnomult
		mov	cl, [es:di+5]	; [es:di+BDS.drivelet]
					; Get logical drive number
					; Get it 1-based
		inc	cl
exitnomult:				
		lds	bx, [ptrsav]
		mov	[bx+1],	cl	; [bx+unit]
					; Exit normal termination
		; 12/12/2022
		; cf=0
		;clc
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;
; moves the old Dpt that had been saved in TempDpt back to Dpt. this is done
; only if the first byte of TempDpt is not -1.
; all registers (including flags) are preserved.
;
; ---------------------------------------------------------------------------

		; 19/10/2022
RestoreOldDpt:
		; if we have already restored the disk base table earlier,
		; do not do it again.
	
		push	ax
		xor	al, al
		mov	[had_format_error], al	; Reset flag and 
		xchg	al, [media_set_for_format] ; get current flag setting
		or	al, al
		jz	short DontRestore
		push	si
		push	ds
		push	es
		lds	si, [tempdpt]

		; 17/10/2022
		mov	es, [cs:BIOSDATAWORD]
		;mov	es, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
		mov	es, [es:zeroseg]
		;mov	es, es:zeroseg	; CAS -- bleeeech!

		;mov	es:78h,	si	; [es:DSKADR]
		mov	[es:DSKADR], si
		;mov	word ptr es:7Ah, ds ; [es:DSKADR+2]
		mov	[es:DSKADR+2], ds
		pop	es
		pop	ds
		pop	si
DontRestore:				
		pop	ax
		; 12/12/2022
		; cf=0
		;clc			;  Clear carry
		retn

; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;	get media id
; ==========================================================================
;
; FUNCTION: get the volume label,the system id and the serial number from
;	    the media that has the extended boot record.
;	    for the conventional media,this routine will return "unknown
;	    media type" error to dos.
;
; INPUT :   ES:di -> bds table for this drive.
;
; OUTPUT:   the request packet filled with the information,if not carry.
;	    if carry set,then al contains the device driver error number
;	    that will be returned to dos.
;	    register DS,DX,AX,CX,DI,SI destroyed.
;
; SUBROUTINES TO BE CALLED:
;	BootIo:NEAR
;
; LOGIC:
;	to recognize the extended boot record,this logic will actually
;	access the boot sector even if it is a hard disk.
;	note:the valid extended bpb is recognized by looking at the mediabyte
;	field of bpb and the extended boot signature.
;
; {
;	get logical drive number from bds table;
;	rFlag = read operation;
;	BootIo;		 /*get the media boot record into the buffer
;	if (no error) then
;	     if (extended boot record) then
;		{ set volume label,volume serial number and system id
;		  of the request packet to those of the boot record;
;		};
;	     else		  /*not an extended bpb */
;		{ set register al to "unknown media.." error code;
;		  set carry bit;
;		};
;	else
;	     ret;	/*already error code is set in the register al
;
; ==========================================================================

;size_of_EXT_BOOT_SERIAL equ 4
;;size_of_EXT_BOOT_VOL_LABEL equ 11
;;size_of_EXT_SYSTEM_ID equ 8

		; 19/10/2022
GetMediaId:
		call	ChangeLineChk
		mov	al, [es:di+5]	; [es:di+BDS.drivelet] ; Logical drive number
		mov	byte [rflag], 2	; Read operation
		call	BootIo		; Read boot sector into	DiskSector
		jb	short IOCtl_If1
					; Valid? (0F0h-0FFh?)
		cmp	byte [disksector+15h], 0F0h
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		jb	short IOCtl_If2	; brif not valid (0F0h - 0FFh)
		; 10/12/2022
		mov	si, disksector+26h
		cmp	byte [si], 29h
		;cmp	byte [disksector+26h], 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short IOCtl_If2	; not extended boot record
		les	di, [ptrsav]	; es:di	points to request header
		les	di, [es:bx+19]	; [es:bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		; 10/12/2022
		inc	si
		; si = disksector+27h 
		;mov	si, disksector+27h ; disksector+EXT_BOOT.SERIAL
		add	di, 2		; A_MEDIA_ID_INFO.MI_SERIAL
		mov	cx, 23		; size_of_EXT_BOOT_SERIAL
					; L+size_of_EXT_BOOT_VOL_LABEL
					; +size_of_EXT_SYSTEM_ID
		rep movsb		; Move from Bios_Data into request packet
	
		; 10/12/2022
		; cf = 0
		;clc

		retn
; ---------------------------------------------------------------------------

IOCtl_If2:				
		mov	al, 7		; error_unknown_media
		stc
IOCtl_If1:				
		retn
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;  set media id
; ==========================================================================

; function: set the volume label, the system id and the serial number of
;	    the media that has the extended boot record.
;	    for the conventional media, this routine will return "unknown
;	    media.." error to dos.
;	    this routine will also set the corresponding informations in
;	    the bds table.
;
; input :   ES:di -> bds table for this drive.
;
; output:   the extended boot record in the media will be set according to
;	    the request packet.
;	    if carry set, then al contains the device driver error number
;	    that will be returned to dos.
;
; subroutines to be called:
;	BootIo:NEAR
;
; logic:
;
; {
;	get drive_number from bds;
;	rFlag = "read operation";
;	BootIo;
;	if (no error) then
;	     if (extended boot record) then
;		{ set volume label,volume serial number and system id
;		  of the boot record to those of the request packet;
;		  rFlag = "write operation";
;		  get drive number from bds;
;		  BootIo;	  /*write it back*/
;		};
;	     else		  /*not an extended bpb */
;		{ set register al to "unknown media.." error code;
;		  set carry bit;
;		  ret;	 /*return back to caller */
;		};
;	else
;	     ret;		 /*already error code is set */
;
; ==========================================================================

		; 19/10/2022
SetMediaId:
		call	ChangeLineChk
		mov	al, [es:di+5]	; [es:di+BDS.drivelet]
					; Logical drive	number
		mov	dl, al
		mov	byte [rflag], 2	; romread
		push	dx
		call	BootIo		; Read boot sec	to Bios_Data:DiskSector
		pop	dx
		jb	short IOCtl_If6
					; Valid? (0F0h-0FFh?)
		cmp	byte [disksector+15h], 0F0h
					; [disksector+EXT_BOOT.BPB+EBPB.MEDIADESCRIPTOR]
		jb	short IOCtl_If7	; Brif not
		cmp	byte [disksector+26h], 29h ; [disksector+EXT_BOOT.SIG]
					; EXT_BOOT_SIGNATURE
		jnz	short IOCtl_If7	; not extended boot record
		push	es		; Save BDS pointer
		push	di
		push	ds		; Point	ES To boot record
		pop	es
		mov	di, disksector+27h ; disksector+EXT_BOOT.SERIAL
		lds	si, [ptrsav]	; ds:si	points to request header.
		lds	si, [si+19]	; [si+IOCTL_REQ.GENERICIOCTL_PACKET]
		add	si, 2		; A_MEDIA_ID_INFO.MI_SERIAL
		mov	cx, 23		; size_of_EXT_BOOT_SERIAL
					; +size_of_EXT_BOOT_VOL_LABEL
					; +size_of_EXT_SYSTEM_ID
		rep movsb
		push	es		; point	ds back	to Bios_Data
		pop	ds
		pop	di		; restore bds pointer
		pop	es
		call	mov_media_ids	; update the bds media id info.
		mov	al, dl
		mov	byte [rflag], 3	; romwrite
		call	BootIo		; write	it back.
		mov	byte [tim_drv], 0FFh
					; make sure chk_media check the driver
					; return with error code from BootIo
		retn
; ---------------------------------------------------------------------------

IOCtl_If7:				
		mov	al, 7		; error_unknown_media
		stc
IOCtl_If6:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;	BootIo
; ---------------------------------------------------------------------------
;
; function: read/write the boot record into boot sector.
;
; input :
;	    al=logical drive number
;	    rFlag = operation (read/write)
;
; output:   for read operation,the boot record of the drive specified in bds
;	    be read into the DiskSector buffer.
;	    for write operation,the DiskSector buffer image will be written
;	    to the drive specified in bds.
;	    if carry set,then al contains the device driver error number
;	    that will be returned to dos.
;	    AX,CX,DX register destroyed.
;	    if carry set,then al will contain the error code from DiskIO.
;
; subroutines to be called:
;	DiskIO:NEAR
;
; logic:
;
; {
;	first_sector = 0;	 /*logical sector 0 is the boot sector */
;	sectorcount = 1;	 /*read 1 sector only */
;	buffer = DiskSector;	 /*read it into the DiskSector buffer */
;	call DiskIO (rFlag,drive_number,first_sector,sectorcount,buffer);
; }
; ==========================================================================

		; 19/10/2022
BootIo:	
		push	es
		push	di
		push	bx
		push	ds
		pop	es		; Point ES: to Bios_Data

		; Call DiskIO to read/write the boot sec. The parameters which
		; need to be initialized for this subroutine out here are
		; - Transfer address to Bios_Data:DiskSector
		; - Low sector needs to be initalized to 0. this is a reg. param
		; - Hi sector in [Start_Sec_H] needs to be initialised to 0.
		; - Number of sectors <-- 1

		mov	di, disksector	; es:di -> transfer address
		xor	dx, dx		; First	sector (h) -> 0
		mov	[start_sec_h], dx ; Start sector (h) -> 0
		mov	cx, 1
		call	diskio
		pop	bx
		pop	di
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; ---------------------------------------------------------------------------
;	ChangeLineChk
; ---------------------------------------------------------------------------
;
; when the user calls get/set media id call before dos establishes the media
; by calling "media_chk",the change line activity of the drive is going to be
; lost.	this routine will check the change line activity and will save the
; history in the flags.
;
; FUNCTION: check the change line error activity
;
; INPUT :  ES:di -> bds table.
;
; OUTPUT:   flag in bds table will be updated if change line occurs.
;
; SUBROUTINES TO BE CALLED:
;	Set_Changed_DL
;
; ---------------------------------------------------------------------------

ChangeLineChk:	
		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
		or	dl, dl		; Fixed	disk?
		js	short ChangeLnChkRet ; Yes, skip it.
		; 12/12/2022
		test	byte [es:di+23h], 4
		;test	word [es:di+23h], 4 ; [es:di+BDS.flags]
					; return_fake_bpb
		jnz	short ChangeLnChkRet
		cmp	byte [fhave96], 1	; This rom support change line?
		jnz	short ChangeLnChkRet
		call	haschange	; This drive support change line?
		jz	short ChangeLnChkRet ; Do nothing

		; Execute the rom disk interrupt to check changeline activity.

		mov	ah, 16h
		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
					; DL = drive to	check
					; Return: AH = disk change status
		jnb	short ChangeLnChkRet
		push	bx
		mov	bx, 40h		; fchanged
					; Update flag in BDS for this
					; physical drive
		call	set_changed_dl
		pop	bx
ChangeLnChkRet:				
		retn

; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;	GetAccessFlag
; ==========================================================================
;
; FUNCTION: get the status of UNFORMATTED_MEDIA bit of flags in bds table
;
; INPUT :
;	    ES:di -> bds table
;
; OUTPUT:   a_DiskAccess_Control.dac_access_flag = 0 if disk i/o not allowed.
;						 = 1 if disk i/o allowed.
; ==========================================================================

		; 19/10/2022
GetAccessFlag:				
		lds	bx, [ptrsav]	; DS:BX	points to request header
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		;mov	al, 0		; Assume result	is unformatted
		; 10/12/2022
		sub	al, al
		; 10/12/2022
		test	byte [es:di+36], 02h
		;test	word [es:di+35], 200h ; [es:di+BDS.flags]
					; unformatted_media
		jnz	short GafDone	; Done if unformatted
		inc	al		; Return true for formatted

GafDone:				
		mov	[bx+1],	al	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		retn
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;	SetAccessFlag
; ==========================================================================
;
; function: set/reset the UNFORMATTED_MEDIA bit of flags in bds table
;
; input :
;	    ES:di -> bds table
;
; output:   unformtted_media bit modified according to the user request
; ==========================================================================

		; 19/10/2022
SetAccessFlag:				
		lds	bx, [ptrsav]	; ES:BX	points to request header
		lds	bx, [bx+19]	; [bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		; 10/12/2022
		and	byte [es:di+36], 0FDh
		;and	word [es:di+35], 0FDFFh ; [es:di+BDS.flags]
					; ~unformatted_media
		cmp	byte [bx+1], 0	; [bx+A_DISKACCESS_CONTROL.DAC_ACCESS_FLAG]
		jnz	short saf_Done
		; 10/12/2022
		or	byte [es:di+36], 02h
		;or	word [es:di+35], 200h ; [es:di+BDS.flags]
					; unformatted_media
saf_Done:				
		retn
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
; Ioctl_Support_Query
; ==========================================================================
;
; New device command which was added in DOS 5.00 to allow a query of a 
; specific GENERIC IOCtl to see if it is supported. Bit 7 in the
; device attributes specifies if this function is supported.
;
; ==========================================================================

		; 19/10/2022
ioctl_support_query:
		push	es
		les	bx, [ptrsav]	; ES:BX Points to request header.
		mov	ax, [es:bx+13]	; [es:bx+IOCTL_REQ.MAJORFUNCTION]
					; AL ==	Major, AH == Minor
		cmp	al, 8		; IOC_DC
					; See if major code is 8
		jnz	short nosupport
		push	cs
		pop	es
		mov	cx, 11		; IOC_DC_TABLE_LEN
		; 10/12/2022
		mov	di, IOC_DC_Table
		;mov	di, 0C60h	; IOC_DC_Table
					; at 2C7h:0C60h	= 70h:31D0h
		xchg	al, ah		; Put minor code in AL
		repne scasb		; Scan for minor code in AL
		jnz	short nosupport	; it was not found
		mov	ax, 100h
		; 10/12/2022
		; (jump to ioctlsupexit is not required)
		;jmp	short $+2	; ioctlsupexit
					; Signal ioctl is supported
		;;jmp	short ioctlsupexit
; ---------------------------------------------------------------------------
ioctlsupexit:				
		pop	es
		; 10/12/2022
		; cf = 0
		;clc
		retn
; ---------------------------------------------------------------------------
nosupport:				
		pop	es
		jmp	bc_cmderr
; ---------------------------------------------------------------------------

; 16/10/2022

; ==========================================================================
;	GetMediaSenseStatus
; ==========================================================================
;
; FUNCTION: Will return the type of diskette media in the specified DOS
;	    diskette drive and whether the media is the default type
;	    for that drive. (default type means the max size for that
;	    drive)
;
; INPUT :   ES:DI -> BDS table
; OUTPUT:   If carry clear
;	    DS:BX -> Updated IOCtlPacket
;
;			 Special Function at offset 0:
;				0	- Media detected is not default type
;				1	- Media detected is default type
;
;			 Device Type at offset 1:
;				2       - 720K 3.5" 80 tracks
;				7	- 1.44M 3.5" 80 tracks
;				9	- 2.88M 3.5" 80 tracks
;
; Error Codes returned in AX if carry set:
;
; 8102 - Drive not ready	- No disk is in the drive.
; 8107 - Unknown media type	- Drive doesn't support this function or
;				  the media is really unkown, any error
;				  other than "media not present"
; 
; ==========================================================================

		; 19/10/2022
SenseMediaType:				
		lds	bx, [ptrsav]	; DS:BX	points to request header.
		lds	bx, [bx+19]	; bx+IOCTL_REQ.GENERICIOCTL_PACKET]
		; 10/10/2022
		;mov	word [bx], 0	; Initialize the 2 packet bytes
		xor	dx, dx
		mov	[bx], dx ; 0
		;
		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
					; Get int 13h drive number from	BDS
		; 10/12/2022
		;xor	dh, dh		; DX = physical	drive number
		mov	ah, 20h		; Get Media Type function
					; If no	carry media type in AL
		int	13h		; DISK - QCACHE	- DISMOUNT
		jb	short MediaSenseEr ; error code	in AH
		inc	byte [bx]	; Signal media type is default (bit 1)
DetermineMediaType:			
		dec	al
		cmp	al, 2		; Chk for 720K ie: (3-1) = 2
		jz	short GotMediaType
		add	al, 4
		cmp	al, 7		; Chk for 1.44M ie: (4-1+4) = 7
		jz	short GotMediaType
		cmp	al, 9		; Chk for 2.88M	ie: (6-1+4) = 9
		jnz	short UnknownMediaType ; Just didn't recognize media type
GotMediaType:				
		mov	[bx+1],	al	; Save the return value
		; 10/12/2022
		; cf = 0
		;clc			; Signal success
		retn
; ---------------------------------------------------------------------------

MediaSenseEr:				
		cmp	ah, 32h		; See if not default media error
		jz	short DetermineMediaType ; Not really an error
		mov	al, 2		; Now assume drive not ready
		cmp	ah, 31h		; See if media was present
		jz	short SenseErrExit ; Return drive not ready
UnknownMediaType:			
		mov	al, 7		; Just don't know the media type
SenseErrExit:				
		mov	ah, 81h		; Signal error return
		stc
		retn

; ---------------------------------------------------------------------------
		; 10/12/2022
		;db    0
; ---------------------------------------------------------------------------

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;-----------------------------------------------------------------------------
; MSINT13.ASM - MSDOS 6.0 - 1991
;-----------------------------------------------------------------------------
; 16/03/2019 - Retro DOS v4.0

;	int 2f function 13h allows the user to change the orig13 int_13 vector
;	after booting. this allows testing and implementation of custom int_13
;	handlers, without giving up ms-dos error recovery
;	entry:	ds:dx	== addr. of new int_13 handler
;		es:bx	== addr. of new int_13 vector used by warm boot (int19)
;	exit:	orig13	== address of new int_13 handler
;		ds:dx	== old orig13 value
;		es:bx	== old old13  value
;
; int 2f handler for external block drivers to communicate with the internal
; block driver in msdisk. the multiplex number chosen is 8. the handler
; sets up the pointer to the request packet in [ptrsav] and then jumps to
; dsk_entry, the entry point for all disk requests.
;
; on exit from this driver, we will return to the external driver
; that issued this int 2f, and can then remove the flags from the stack.
; this scheme allows us to have a small external device driver, and makes
; the maintainance of the various drivers (driver and msbio) much easier,
; since we only need to make changes in one place (most of the time).
;
;   ax=800h - check for installed handler - reserved
;   ax=801h - install the bds into the linked list
;   ax=802h - dos request
;   ax=803h - return bds table starting pointer in ds:di
;	   (ems device driver hooks int 13h to handle 16kb dma overrun
;	    problem. bds table is going to be used to get head/sector
;	    informations without calling generic ioctl get device parm call.)

;BIOSSEGMENT equ 70h
DOSBIOSSEG equ 0070h ; 17/10/2022	

;;BIOSCODE:1302h (MSDOS 6.21, IO.SYS)

i2f_handler:				; here is 02C7h:1302h =	0070h:3872h
		cmp	ah, 13h
		jz	short int2f_replace_int13
		cmp	ah, 8
		jz	short mine

; Check for WIN386 startup and return the BIOS instance data

		cmp	ah, 16h		; MultWin386
		jz	short win386call
		cmp	ah, 4Ah		; multMULT
		jnz	short i2f_handler_iret
		jmp	handle_multmult
; ---------------------------------------------------------------------------

i2f_handler_iret:			
		iret
; ---------------------------------------------------------------------------

int2f_replace_int13:			
		push	ax	; free up a register for caller's ds
		mov	ax, ds	; then we can use ds: -> Bios_Data
		;;mov	ds, word [cs:0030h] ; 15/10/2022	
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
					; = [02C7h:0030h] = [0070h:25A0h]
		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022
		; 19/10/2022
		;push	word ptr ds:Orig13	; save old value of old13 and
		;push	word ptr ds:Orig13+2	; orig13 so that we can
		;push	word ptr ds:Old13	; return them to caller
		;push	word ptr ds:Old13+2
		push	word [Orig13]
		push	word [Orig13+2]
		push	word [Old13]
		push	word [Old13+2]

		;mov	word ptr ds:Orig13, dx	; orig13 := addr. of new int_13
		;mov	word ptr ds:Orig13+2, ax
		;mov	word ptr ds:Old13, bx	; old13 := addr. of new boot_13
		;mov	word ptr ds:Old13+2, es
		mov	[Orig13], dx
		mov	[Orig13+2], ax
		mov	[Old13], bx
		mov	[Old13+2], es

		pop	es			; es:bx := old old13 vector
		pop	bx
		pop	ds			; ds:dx := old orig13 vector
		pop	dx
		pop	ax
i2f_iret:				
		iret
; ---------------------------------------------------------------------------

mine:					
		cmp	al, 0F8h 		; iret on reserved functions
		jnb	short i2f_iret
		or	al, al			; a get installed state request?
		jnz	short disp_func
		mov	al, 0FFh
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

disp_func:				
		cmp	al, 1			; request for installing bds?
		jz	short do_subfun_01
		cmp	al, 3			; get bds vector?
		jz	short do_get_bds_vector

; set up pointer to request packet

		push	ds
		mov	ds, [cs:BIOSDATAWORD] ; 17/10/2022	
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; = [0070h:25A0h] = [02C7h:0030h]
		; 19/10/2022
		;mov	word ptr ds:ptrsav, bx
		;mov	word ptr ds:ptrsav+2, es
		mov	[ptrsav], bx
		mov	[ptrsav+2], es
		pop	ds
		;jmp	far ptr	i2f_dskentry
		; 17/10/2022
		;jmp	far DOSBIOSSEG:dsk_entry		
		jmp	DOSBIOSSEG:i2f_dskentry ; 70h:i2f_dskentry
					; NOTE: jump to a FAR function, not an
					;  IRET type function. Callers of
					;  this int2f subfunction will have
					;  to be careful to do a popf

; ---------------------------------------------------------------------------

do_subfun_01:				
		push	es
		push	ds
		push	ds
		pop	es
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]	
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; point	ds: -> Bios_Data
		call	install_bds
		pop	ds
		pop	es
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

do_get_bds_vector:
		; 17/10/2022
		mov	ds, [cs:BIOSDATAWORD]			
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
		lds	di, [start_bds]
		;lds	di, ds:start_bds
;ii2f_iret:	; 10/12/2022				
		jmp	short i2f_iret
; ---------------------------------------------------------------------------

; 17/10/2022
; 16/10/2022

; WIN386 startup stuff is done here. If starting up we set our WIN386 present
; flag and return instance data. If exiting, we reset the WIN386 present flag
; NOTE: We assume that the BIOS int 2fh is at the bottom of the chain.

win386call:				
		push	ds
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
					; at 2C7h:30h =	70h:25A0h
		cmp	al, 5		; Win386_Init
					; is it	win386 initializing?
		jz	short Win386Init
		cmp	al, 6		; Win386_Exit
					; is it	win386 exiting?
		jnz	short win_iret	; if not, continue int2f chain
		; 12/12/2022
		test	dl, 1
		;test	dx, 1		; is it	win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		;and	ds:IsWin386, 0	; indicate that	win386 is not present  
		and	byte [IsWin386], 0 
		jmp	short win_iret
; ---------------------------------------------------------------------------

Win386Init:	
		; 12/12/2022
		test	dl, 1			
		;test	dx, 1		; is it win386 or win286 dos extender?
		jnz	short win_iret	; if not win386, then continue
		;or	ds:IsWin386, 1	; Indicate WIN386 present
		or	byte [IsWin386], 1
		;mov	word ptr ds:SI_Next, bx	; Hook our structure into chain
		;mov	word ptr ds:SI_Next+2, es
		mov	[SI_Next], bx
		mov	[SI_Next+2], es
		;mov	bx, offset Win386_SI ; point ES:BX to Win386_SI
		mov	bx, Win386_SI	; 19/10/2022
		push	ds
		pop	es
win_iret:				
		pop	ds
ii2f_iret:	; 10/12/2022	
		jmp	short i2f_iret	; return back up the chain
; ---------------------------------------------------------------------------

handle_multmult:			
		cmp	al, 1
		jnz	short try_2
		push	ds
		call	HMAPtr		; get offset of free HMA
		; 10/12/2022
		;xor	bx, bx
		;dec	bx
		mov	bx, 0FFFFh
		mov	es, bx		; seg of HMA
		mov	bx, di
		not	bx
		or	bx, bx
		jz	short try_1
		inc	bx
try_1:					
		pop	ds
		jmp	short ii2f_iret
; ---------------------------------------------------------------------------

try_2:					
		cmp	al, 2		; multMULTALLOCHMA
		jnz	short try_3
		push	ds
		; 10/12/2022
		;xor	di, di
		;dec	di
		mov	di, 0FFFFh	; assume not enough space
		mov	es, di
		call	HMAPtr		; get offset of free HMA
		cmp	di, 0FFFFh
		jz	short InsuffHMA
		neg	di		; free space in HMA
		cmp	bx, di
		jbe	short try_4
		; 10/12/2022
		;sub	di, di
		;dec	di
		mov	di, 0FFFFh
		jmp	short InsuffHMA
; ---------------------------------------------------------------------------

try_4:					
		;mov	di, ds:FreeHMAPtr
		mov	di, [FreeHMAPtr]
		add	bx, 15
		;and	bx, 0FFF0h
		; 10/12/2022
		and	bl, 0F0h
		;add	ds:FreeHMAPtr, bx ; update the free pointer	
		add	[FreeHMAPtr], bx
		jnz	short InsuffHMA
		mov	word [FreeHMAPtr], 0FFFFh ; -1
		;mov	ds:FreeHMAPtr, 0FFFFh
					; no more HMA if we have wrapped
InsuffHMA:				
		pop	ds
		; 10/12/2022
try_3:		
		jmp	short ii2f_iret
; ---------------------------------------------------------------------------

		; 10/12/2022
;try_3:					
		;jmp	ii2f_iret

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

;--------------------------------------------------------------------------
;
; procedure : HMAPtr
;
;		Gets the offset of the free HMA area ( with respect to
;							seg ffff )
;		If DOS has not moved high, tries to move DOS high.
;		In the course of doing this, it will allocate all the HMA
;		and set the FreeHMAPtr to past the end of the BIOS and 
;		DOS code. The call to MoveDOSIntoHMA (which is a pointer)
;		enters the routine in sysinit1 called FTryToMovDOSHi.
;
;	RETURNS : offset of free HMA in DI
;		  BIOS_DATA, seg in DS
;
;--------------------------------------------------------------------------

		; 17/10/2022
HMAPtr:
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:Bios_Data_Word]
		mov	di, [FreeHMAPtr]
		;mov	di, ds:FreeHMAPtr
		cmp	di, 0FFFFh
		jnz	short HMAPtr_retn
		cmp	byte [SysinitPresent], 0
		;cmp	ds:SysinitPresent, 0
		jz	short HMAPtr_retn
		call	far [MoveDOSIntoHMA]
		;call	ds:MoveDOSIntoHMA ; call far [MoveDOSIntoHMA]
		mov	di, [FreeHMAPtr]
		;mov	di, ds:FreeHMAPtr
HMAPtr_retn:				
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; move a 512 byte sector from ds:si to es:di, do not trash cx
; but go ahead and update direction flag, si, & di

move_sector:

; The 80386 microprocessor considers an access to WORD 0FFFFh in
; any segment to be a fault. Theoretically, this could be handled
; by the fault handler and the behavior of an 8086 could be emulated
; by wrapping the high byte to offset 0000h. This would be a lot
; of work and was, indeed, blown off by the Win386 guys. COMPAQ
; also handles the fault incorrectly in their ROM BIOS for real
; mode. Their fault handler was only designed to deal with one
; special case which occurred in a magazine benchmark, but didn't
; handle the general case worth beans.
;
; Simply changing this code to do a byte loop would work okay but
; would involve a general case performance hit. Therefore, we'll
; check for either source or destination offsets being within one
; sector of the end of their segments and only in that case fall
; back to a byte move.

		cld
		push	cx
		mov	cx, 256
		cmp	si, 0FE00h
		ja	short movsec_bytes
		cmp	di, 0FE00h
		ja	short movsec_bytes
		rep movsw
		pop	cx
		retn
; ---------------------------------------------------------------------------

movsec_bytes:				
		shl	cx, 1
		rep movsb
		pop	cx
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; check_wrap is a routine that adjusts the starting sector, starting head
; and starting cylinder for an int 13 request that requests i/o of a lot
; of sectors. it only does this for fixed disks. it is used in the sections
; of code that handle ecc errors and dma errors. it is necessary, because
; ordinarily the rom would take care of wraps around heads and cylinders,
; but we break down a request when we get an ecc or dma error into several
; i/o of one or more sectors. in this case, we may already be beyond the
; number of sectors on a track on the medium, and the request would fail.
;
; input conditions:
;	all registers set up for an int 13 request.
;
; output:
;	dh - contains starting head number for request
;	cx - contains starting sector and cylinder numbers
;	(the above may or may not have been changed, and are 0-based)
;	all other registers preserved.

check_wrap:	
		push	ax
		push	bx
		push	es
		push	di
		call	find_bds	; get pointer to bds for drive in dl
		jb	short no_wrap	; finished if DOS doesn't use it
		; 12/12/2022
		test	byte [es:di+23h], 1
		;test	word [es:di+23h], 1 ; [es:di+BDS.flags],fnon_removable
		jz	short no_wrap	; no wrapping for removable media
		mov	bx, [es:di+13h]	; [es:di+BDS.secpertrack]
		mov	ax, cx
		and	ax, 3Fh		; extract sector number
		cmp	ax, bx		; are we going to wrap?
		jbe	short no_wrap
		div	bl		; ah=new sector	#, al=#	of head	wraps

; we need to be careful here. if the new sector # is 0, then we are on the
; last sector on that track.

		or	ah, ah
		jnz	short not_on_bound
		; 18/12/2022
		dec	ax ; *
		mov	ah, bl		; set sector=BDS_BPB.BPB_SECTORSPERTRACK
					; if on	boundary
		;dec	al ; *		; also decrement # of head wraps
not_on_bound:				
		and	cl, 0C0h	; zero out sector #
		or	cl, ah		; or in	new sector #
		xor	ah, ah		; ax = # of head wraps
		inc	ax
		add	al, dh		; add in starting head #
		adc	ah, 0		; catch	any carry
		cmp	ax, [es:di+15h]	; [es:di+BDS.heads]
					; are we going to wrap around a	head?
		jbe	short no_wrap_head ; do	not lose new head number!!
		push	dx		; preserve drive number and head number
		xor	dx, dx
		mov	bx, [es:di+15h]	; [es:di+BDS.heads]
		div	bx		; dx=new head #, ax=# of cylinder wraps

; careful here! if new head # is 0, then we are on the last head.

		or	dx, dx
		jnz	short no_head_bound
		mov	dx, bx		; on boundary. set to BDS_BPB.BPB_HEADS

; if we had some cylinder wraps, we need to reduce them by one!!

		or	ax, ax
		jz	short no_head_bound
		dec	ax		; reduce number	of cylinder wraps
no_head_bound:				
		mov	bh, dl		; bh has new head number
		pop	dx		; restore drive number and head number
		dec	bh		; get it 0-based
		mov	dh, bh		; set up new head number in dh
		mov	bh, cl
		and	bh, 3Fh		; preserve sector number
		mov	bl, 6
		xchg	cl, bl
		shr	bl, cl		; get ms cylinder bits to ls end
		add	ch, al		; add in cylinder wrap
		adc	bl, ah		; add in high byte
		shl	bl, cl		; move up to ms	end
		xchg	bl, cl		; restore cylinder bits	into cl
		or	cl, bh		; or in	sector number
no_wrap:				
		clc
		pop	di
		pop	es
		pop	bx
		pop	ax
		retn
; ---------------------------------------------------------------------------

no_wrap_head:				
		mov	dh, al		; do not lose new head number
		dec	dh		; get it 0-based
		jmp	short no_wrap

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; this is a special version of the bds lookup code which is
; based on physical drives rather than the usual logical drives
; carry is set if the physical drive in dl is found, es:di -> its bds
; otherwise carry is clear
;
; guaranteed to trash no registers except es:di

		; 19/10/2022
find_bds:	
		les	di, [start_bds]	; point es:di to first bds
fbds_1:					
		cmp	[es:di+4], dl	; [es:di+BDS.drivenum]
		jz	short fdbs_2
		les	di, [es:di]	; [es:di+BDS.link]
					; go to next bds
		cmp	di, 0FFFFh
		jnz	short fbds_1
		stc
fdbs_2:					
		retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022
		; 17/10/2022
doint:
		; 10/12/2022
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get physical drive number
		; 19/10/2022 - Temporary !
		;db	8Ah, 96h, 8, 0	; mov dl, [bp+8]	
		
		xor	ah, ah
		or	al, al
		jz	short dointdone	; if zero sectors, return ax=0
		; 10/12/2022
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
					; get request code
		;db	8Ah, 0A6h, 3, 0	; mov ah, [bp+3]
		push	word [bp+10h]	; [bp+INT13FRAME.oldf]
		;db	0FFh, 0B6h, 10h, 0 ; push word [bp+10h]
		popf
		;call	far 70h:797h ; MSDOS 6.21 IO.SYS BIOSCODE:14EAh
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;;call	call_orig13	; call far 70h:797h
					; call far KERNEL_SEGMENT:call_orig13
		pushf
		; 10/12/2022
		pop	word [bp+10h]	; [bp+INT13FRAME.oldf]
		;db	8Fh, 86h, 10h, 0 ; pop word [bp+10h]
dointdone:				
		retn

;----------------------------------------------------------------------------

; 16/10/2022

; this is the true int 13 handler. we parse the request to see if there is
; a dma violation. if so, depending on the function, we:
;   read/write break the request into three pieces and move the middle one
;	       into our internal buffer.
;
;   format     copy the format table into the buffer
;   verify     point the transfer address into the buffer
;
; this is the biggest bogosity of all. the ibm controller does not handle
; operations that cross physical 64k boundaries. in these cases, we copy
; the offending sector into the buffer below and do the i/o from there.

;struc INT13FRAME
;.oldbp: resw
;.oldax: resw 
;.oldbx: resw
;.oldcx: resw
;.olddx: resw
;.oldds: resw	; now we save caller's ds, too
;.olddd: resd
;.oldf:	resw
;end struc

;----------------------------------------------------------------------------

;   entry conditions:
;	ah = function
;	al = number of sectors
;	es:bx = dma address
;	cx = packed track and sector
;	dx = head and drive
;   output conditions:
;	no dma violation.

;	use extreme caution when working with this code. In general,
;	  all registers are hot at all times.
;
;	question:  does this code handle cases where dma errors
;	  occur during ecc retries, and where ecc errors occur during
;	  dma breakdowns???? Hmmmmm.

;----------------------------------------------------------------------------

; ---------------------------------------------------------------------------

dtype_array:	dd 400090h		; 40:90	is drive type array

; 17/10/2022
;DTYPEARRAY equ dtype_array - DOSBIOSEG_2C7h ; (14F5h for MSDOS 5.0 IO.SYS)
; 09/12/2022
DTYPEARRAY equ dtype_array

; ---------------------------------------------------------------------------

; stick some special stuff out of mainline

; we know we're doing a format command. if we have changeline
; support, then flag some special changed stuff and set changed
; by format bit for all logical drives using this physical drive

format_special_stuff:			
		cmp	byte [fhave96], 0	; do we have changeline support?
		jz	short format_special_stuff_done ; brif not
		push	bx
		mov	bx, 140h	; fchanged_by_format+fchanged
		call	set_changed_dl	; indicate that media changed by format
		pop	bx
		jmp	short format_special_stuff_done
; ---------------------------------------------------------------------------

; 16/10/2022

; we know we've got ec35's on the system. Now see if we're doing
; a floppy. If so, create a mask and see if this particular
; drive is an ec35. If so, set dtype_array[drive]=93h

		; 19/10/2022
ec35_special_stuff:			
		test	dl, dl		; floppy or hard disk?
		js	short ec35_special_stuff_done ;	if hard	drive, we're done
		push	ax		; see if this PARTICULAR drive is ec35
		push	cx
		mov	cl, dl		; turn drive number into bit map
		mov	al, 1		; assume drive 0
		shl	al, cl		; shift	over correct number of times
		test	[ec35flag], al	; electrically compatible 3.5 incher?
		pop	cx
		pop	ax
		jz	short ec35_special_stuff_done
					; done if this floppy is not an	ec35
		push	bx		; free up a far	pointer	(es:bx)
		push	es
		; 17/10/2022
		les	bx, [cs:DTYPEARRAY]
		;les	bx, dword ptr cs:DTYPEARRAY ; [cs:dtype_array]
					; 0070h:3A65h =	2C7h:14F5h
		add	bl, dl
		adc	bh, 0		; find entry for this drive
		mov	byte [es:bx], 93h ; establish drive type as:
					; (360k	disk in	360k drive,
					; no double-stepping, 250 kbs transfer rate)
		pop	es
		pop	bx
		jmp	short ec35_special_stuff_done
; ---------------------------------------------------------------------------

; 16/10/2022

; ps2_30 machine has some problem with ah=8h (read drive parm), int 13h.
; this function does not reset the common buses after the execution.
; to solve this problem, when we detect ah=8h, then we will save the result and
; will issue ah=1 (read status) call to reset the buses.

ps2_special_stuff:			
		cmp	byte [prevoper], 8 ; (ps2_30)
					; read driver parm ?
		jz	short ps2_30_problem
		cmp	byte [prevoper], 15h
					; apparently function 15h fails, too
		jnz	short ps2_special_stuff_done
ps2_30_problem:				
		push	ax
		mov	ah, 1
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1543h
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far 70:797h
					; call far KERNEL_SEGMENT:call_orig13
		pop	ax
		jmp	short ps2_special_stuff_done
; ---------------------------------------------------------------------------

; 17/10/2022
; 16/10/2022

; here is the actual int13 handler

i13z:					; 0070h:3ABBh =	02C7h:154Bh

; cas -- inefficient! could push ds and load ds-> Bios_Data before
; vectoring up here from Bios_Data

		; 19/10/2022
		push	ds		; save caller's ds register first thing
		;;mov	ds, word [cs:0030h]
					; and set up our own ds -> Bios_Data
		mov	ds, [cs:BIOSDATAWORD]
		;mov	ds, word ptr cs:BIOSDATAWORD ; [cs:0030h]
					; = [02C7h:0030h] = [0070h:25A0h]

; let the operation proceed. if there is a dma violation, then we do things

		mov	[prevoper], ax	; save request
		cmp	ah, 5		; romformat
		jz	short format_special_stuff
					; go do special stuff for format
 format_special_stuff_done:		
		cmp	byte [ec35flag], 0 ; any electrically compat 3.5 inchers?
		jnz	short ec35_special_stuff
					; go handle it out of line if so
ec35_special_stuff_done:
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1560h		
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		
		pushf			; save result flags
		
		cmp	byte [model_byte], 0FAh ; is this a ps2/30?
					; mdl_ps2_30
		jz	short ps2_special_stuff
					; exit mainline to address special
ps2_special_stuff_done:			; ps2/30 problem if so		
		popf
		jb	short goterr13	; error	on original orig13 call-thru?
ret_from_i13:				
		pop	ds
		retf	2		; restore ds &	iret w/flags
; ---------------------------------------------------------------------------

; most of our code exits through here. If carry isn't set, then
; just do a simple exit. Else doublecheck that we aren't getting
; a changeline error.

i13ret_ck_chglinerr:			
		jnb	short ret_from_i13 ; done if not an error termination
i13_ret_error:				
		cmp	ah, 6		; did i	see a change event?
		jnz	short int13b	; skip if wrong	error
		or	dl, dl		; is this for the hard disk?
		js	short int13b	; yes, ignore
		cmp	byte [fhave96], 0
		jz	short int13b	; just in case ROM returned this
					; error	even though it told us it
					; never	would
		push	bx
		mov	bx, 40h		; fchanged
		call	set_changed_dl
		pop	bx
int13b:					
		stc			; now return the error
		jmp	short ret_from_i13
; ---------------------------------------------------------------------------

; some kind of error occurred. see if it is dma violation

goterr13:				
		cmp	ah, 9		; dma error?
		jz	short gotdmaerr
goterr13_xxxx:				
		cmp	ah, 11h		; ecc error?
		jnz	short i13_ret_error ; other error. just	return back.
		cmp	byte [media_set_for_format], 1 ; formatting?
		jz	short i13_ret_error

		cmp	byte [prevoper+1], 2
		;cmp	byte ptr ds:prevoper+1,	2 ; ecc-corrected error
					; (2 = romread)
					; ECC correction only applies to reads
		jnz	short i13_ret_error

		xor	ah, ah
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15ABh
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
					; call far 70:797h
		mov	ax, [prevoper]
		xor	ah, ah		; return code =	no error
		cmp	al, 1		; if request for one sector, assume ok
		jz	short ret_from_i13 ; return with carry clear
		push	bx
		push	cx
		push	dx
		mov	[number_of_sec], al
loop_ecc:				
		mov	ax, 201h	; read one sector

; we do reads one sector at a time. this ensures that we will eventually
; finish the request since ecc errors on one sector do read in that sector.
;
; we need to put in some "intelligence" into the ecc handler to handle reads
; that attempt to read more sectors than are available on a particular
; track.
;
; we call check_wrap to set up the sector #, head # and cylinder # for
; this request.
;
; at this point, all registers are set up for the call to orig13, except
; that there may be a starting sector number that is bigger than the number
; of sectors on a track.
;
		call	check_wrap	; get correct parameters for int 13
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15C5h
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		jnb	short ok11_op
		cmp	ah, 9		; DMA error during ECC read?
		jz	short handle_dma_during_ecc
		cmp	ah, 11h		; only allow ecc errors
		jnz	short ok11_exit_err
		; 10/12/2022
		; xor ax ax -> ah = 0
		;mov	ah, 0		; ecc error. reset the system again.
		xor	ax, ax		; clear	the error code so that if this
					; was the last sector, no error	code
					; will be returned for the corrected
					; read.	(clear carry too.)
ok11_op:				
		dec	byte [number_of_sec]
		jz	short ok11_exit	; all done?
		inc	cl		; advance sector number
					; add 200h to address
		inc	bh
		inc	bh
		jmp	short loop_ecc
; ---------------------------------------------------------------------------

; locate error returns centrally

ok11_exit_err:				
		stc			; set carry bit again.
ok11_exit:				
		pop	dx
		pop	cx
		pop	bx
		jmp	short i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

; do the single sector read again, this time into our temporary
; buffer, which is guaranteed not to have a DMA error, then
; move the data to its proper location and proceed

handle_dma_during_ecc:			
		push	es
		push	bx
		mov	bx, disksector
		push	ds
		pop	es		; point es:bx to buffer
		mov	ax, 201h	; read one sector
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:15F8h
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		pop	bx
		pop	es
		jnb	short handle_dma_during_ecc_noerr
		cmp	ah, 11h
		jnz	short ok11_exit_err ; if anything but ecc error, bomb out

; now we're kosher. Copy the data to where it belongs and resume
; the ECC looping code.

handle_dma_during_ecc_noerr:		
		push	si
		push	di
		mov	di, bx
		mov	si, disksector
		call	move_sector
		pop	di
		pop	si
		jmp	short ok11_op
; ---------------------------------------------------------------------------

; we truly have a dma violation. restore register ax and retry the
; operation as best we can.

gotdmaerr:				
		mov	ax, [prevoper]	; 19/10/2022
		sti
		cmp	ah, 2		; romread
		jb	short i13_done_dmaerr
					; just pass dma error thru for
					; functions we don't handle
		cmp	ah, 4		; romverify
		jz	short intverify
		cmp	ah, 5		; romformat
		jz	short intformat
		ja	short i13_done_dmaerr

; we are doing a read/write call. check for dma problems

;	******** set up stack frame here!!! ********

		push	dx
		push	cx
		push	bx
		push	ax
		push	bp
		mov	bp, sp
		mov	dx, es		; check	for 64k	boundary error
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1
		shl	dx, 1		; segment converted to absolute	address
		add	dx, bx		; combine with offset
		add	dx, 511		; simulate a transfer

; if carry is set, then we are within 512 bytes of the end of the segment.
; we skip the first transfer and perform the remaining buffering and transfer

		jnb	short no_skip_first
		jmp	bufferx		; restore dh=head & do buffer
; ---------------------------------------------------------------------------

no_skip_first:				
		shr	dh, 1		; dh = number of sectors before	address
		mov	ah, 128		; ah = max number of sectors in	segment
		sub	ah, dh

; ah is now the number of sectors that we can successfully write in this
; segment. if this number is above or equal to the requested number, then we
; continue the operation as normal. otherwise, we break it into pieces.
;
; wait a sec. this is goofy. the whole reason we got here in the
; first place is because we got a dma error. so it's impossible
; for the whole block to fit, unless the dma error was returned
; in error.

		cmp	ah, al		; can we fit it	in?
		jb	short doblock	; no, perform blocking.

; yes, the request fits. let it happen.

		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number
		call	doint
		jmp	bad13		; and return from this place
; ---------------------------------------------------------------------------

i13_done_dmaerr:			
		mov	ah, 9		; pass dma error thru to caller
		stc
		jmp	ret_from_i13	; return with error,
					; we know it's not a changeline error
; ---------------------------------------------------------------------------

; verify the given sectors. place the buffer pointer into our space.

intverify:				
		push	es		; save caller's dma address
		push	bx
		push	ds		; es:bx	-> Bios_Data:disksector
		pop	es
dosimple:				
		mov	bx, disksector
					; do the i/o from Bios_Data:disksector
		;;call	far 70:797h ; MSDOS 6.21 IO.SYS BIOSCODE:1665h
		; 17/10/2022
		call	DOSBIOSSEG:call_orig13
		;call	call_orig13	; call far KERNEL_SEGMENT:call_orig13
		pop	bx
		pop	es
		jmp	i13ret_ck_chglinerr
; ---------------------------------------------------------------------------

; format operation. copy the parameter table into Bios_Data:disksector

intformat:				
		push	es
		push	bx
		push	si
		push	di
		push	ds

; point ds to the caller's dma buffer, es to Bios_Data
; in other words, swap (ds, es)

		push	es
		push	ds
		pop	es
		pop	ds
		mov	si, bx
		mov	di, disksector
		call	move_sector	; user's data into Bios_Data:disksector
		pop	ds
		pop	di
		pop	si		; do the i/o from
		jmp	short dosimple	; Bios_Data:disksector
; ---------------------------------------------------------------------------

; we can't fit the request into the entire block. perform the operation on
; the first block.
;
; doblock is modified to correctly handle multi-sector disk i/o.
; old doblock had added the number of sectors i/oed (ah in old doblock) after
; the doint call to cl. observing only the lower 6 bits of cl(=max. 64) can
; represent a starting sector, if ah was big, then cl would be clobbered.
; by the way, we still are going to use cl for this purpose since checkwrap
; routine will use it as an input. to prevent cl from being clobbered, a
; safe number of sectors should be calculated like "63 - # of sectors/track".
; doblock will handle the first block of requested sectors within the
; boundary of this safe value.

doblock:

; try to get the # of sectors/track from bds via rom drive number.
; for any mini disks installed, here we have to pray that they have the
; same # of sector/track as the main dos partition disk drive.
				
		mov	dx, [bp+8]	; [bp+INT13FRAME.olddx]
					; get head #, drive #
		push	cx
		push	es
		push	di		; ah - # of sectors before dma boundary
					; al - requested # of sectors for i/o.
		call	find_bds
		mov	cx, [es:di+13h]	; [es:di+BDS.secpertrack]
		; 12/12/2022
		test	byte [es:di+23h], 1
		;test	word [es:di+23h], 1 ; [es:di+BDS.flags],fnon_removable
		pop	di
		pop	es
		mov	al, ah		; set al=ah for	floppies
		jz	short doblockflop ; they are track by track operation
		mov	ah, 63		; ah = 63-secpt	(# safe	sectors??)
		sub	ah, cl		; al - # of sectors before dma boundary
doblockflop:				
		pop	cx
doblockcontinue:			
		cmp	ah, al		; if safe_# >= #_of_sectors_to_go_before dma,
		jnb	short doblocklast ; then #_of_sectors_to_go as it is for doint.
		push	ax
		mov	al, ah		; otherwise, set al to ah to operate.
		jmp	short doblockdoint
; ---------------------------------------------------------------------------

doblocklast:				
		mov	ah, al
		push	ax
doblockdoint:				; let ah = al =	# of sectors for this shot	
		call	doint
		jb	short bad13	; something happened, bye!
		pop	ax
		sub	[bp+2],	ah	; sub [bp+INT13FRAME.oldax], ah
					; decrement by the successful operation
		add	cl, ah		; advance sector #. safety gauranteed.
		add	bh, ah		; advance dma addres
		add	bh, ah		; twice	for 512	byte sectors
		cmp	ah, al		; check	the previous value
		jz	short buffer	; if #_of_sectors_to_go	< safe_#,
					; then we are done already.
		sub	al, ah		; otherwise,
					; #_sector_to_go = #_of_sector_to_go - safe_#
		call	check_wrap	; get new cx, dh for the next operation.
		jmp	short doblockcontinue ;	handles	next sectors left.
; ---------------------------------------------------------------------------

bufferx:				
		mov	dh, [bp+9]	; [bp+INT13FRAME.olddx+1]
					; set up head number
buffer:					
		push	bx
		mov	ah, [bp+3]	; [bp+INT13FRAME.oldax+1]
		cmp	ah, 3		; romwrite
		jnz	short doread	;
					
; copy the offending sector into local buffer

		push	es
		push	ds
		push	si
		push	di
		push	ds		; exchange segment registers
		push	es
		pop	ds
		pop	es
		mov	di, disksector	; where to move
		push	di		; save it
		mov	si, bx		; source
		call	move_sector	; move sector into local buffer
		pop	bx		; new transfer address
					; (es:bx = Bios_Data:diskbuffer)
		pop	di		; restore caller's di & si
		pop	si
		pop	ds		; restore Bios_Data

; see if we are wrapping around a track or head

		mov	al, 1		; [bp+INT13FRAME.olddx]
					; get drive number
		mov	dl, [bp+8]
		call	check_wrap	; sets up registers if wrap-around
					;
					; ah is	function
					; al is	1 for single sector transfer
					; es:bx	is local transfer addres
					; cx is	track/sector number
					; dx is	head/drive number
					; si,di	unchanged
		call	doint
		pop	es		; restore caller's dma segment
		jb	short bad13	; go clean up
		jmp	short dotail
; ---------------------------------------------------------------------------

; reading a sector. do int first, then move things around

doread:					
		push	es
		push	bx
		push	ds		; es = Bios_Code
		pop	es
		mov	bx, disksector
		mov	al, 1
		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
					; get drive number
		call	check_wrap	;
					; ah = function
					; al = 1 for single sector
					; es:bx	points to local	buffer
					; cx, dx are track/sector, head/drive
		call	doint
		pop	bx
		pop	es
		jb	short bad13
		push	si
		push	di
		mov	di, bx
		mov	si, disksector
		call	move_sector
		pop	di
		pop	si

; note the fact that we've done 1 more sector

dotail:					
		pop	bx		; retrieve new dma area
		add	bh, 2		; advance over sector
		inc	cx
		mov	al, [bp+2]	; [bp+INT13FRAME.oldax]
		clc
		dec	al
		jz	short bad13	; no more i/o

; see if we wrap around a track or head boundary with starting sector
; we already have the correct head number to pass to check_wrap

		mov	dl, [bp+8]	; [bp+INT13FRAME.olddx]
		call	check_wrap
		call	doint

; we are done. ax has the final code; we throw away what we got before

; M046  -- okay gang. Now we've either terminated our DMA loop,
;	   or we've finished. If carry is set now, our only
;	   hope for salvation is that it was a read operation
;	   and the error code is ECC error. In that case, we'll
;	   just pop the registers and go do the old ECC thing.
;	   When the DMA error that got us here in the first
;	   place occurs, it'll handle it.

bad13:					
		mov	sp, bp
		pop	bp
		pop	bx
		pop	bx
		pop	cx
		pop	dx
		jb	short xgoterr13_xxxx ; go handle ECC errors
		jmp	ret_from_i13	; non-error exit
; ---------------------------------------------------------------------------

xgoterr13_xxxx:				
		jmp	goterr13_xxxx

; ---------------------------------------------------------------------------
		; 10/12/2022
		;db 	0
; ---------------------------------------------------------------------------

;Bios_Code ends

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;-----------------------------------------------------------------------------
; MSBIO2.ASM - MSDOS 6.0 - 1991
;-----------------------------------------------------------------------------
; 17/03/2019 - Retro DOS v4.0

		; 19/10/2022
dsk_init:				; 2C7h:1742h = 70h:3CB2h
		mov	ah, [drvmax]
		mov	di, dskdrvs
		push	ds		; pass result in es:di
		pop	es
		jmp	SetPtrSav

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; install_bds installs a bds at location es:di into the current linked list of
; bds maintained by this device driver. it places the bds at the end of the
; list. Trashes (at least) ax, bx, di, si
;---------------------------------------------------------------------------

install_bds:		
		push	ds		; save Bios_Data segment
		mov	si, start_bds	; beginning of chain

		; ds:si now points to link to first bds
		; assume bds list is non-empty
loop_next_bds:				
		lds	si, [si]	; [si+BDS.link]
					; fetch	next bds
		mov	al, [es:di+4]	; [es:di+BDS.drivenum]
		cmp	[si+4],	al	; does this one	share a	physical
					; drive	with new one?
		jnz	short next_bds
		mov	bl, 10h		; fi_am_mult
		or	[es:di+23h], bl	; [es:di+BDS.flags]
					; set both of them to i_am_mult	if so
		or	[si+23h], bl	; [si+BDS.flags]
		and	byte [es:di+23h], 0DFh ; [es:di+BDS.flags],~fi_own_physical
					; we don't own it
		mov	bl, [si+23h]	; [si+BDS.flags]
					; determine if changeline available
		and	bl, 2		; fchangeline
		or	[es:di+23h], bl	; [es:di+BDS.flags]
next_bds:				
		cmp	word [si], 0FFFFh ; [si+BDS.link],-1
					; are we at end	of list?
		jnz	short loop_next_bds
		mov	word [si+2], es ; [si+BDS.link+2],es
					; install bds
		mov	[si], di
		mov	word [es:di], 0FFFFh ; [es:di+BDS.link],-1
					; set next pointer to null
		pop	ds

; 16/10/2022 (MSDOS 6.0 Code)
;
; **** If the new drive has a higher EOT value, we must alter the
;      'eot' variable appropriately.
;
;		; 01/06/2019
;		;mov	al,[es:di+52]
;		mov	al,[es:di+BDS.rsecpertrack]
;
;		cmp	al,[eot]
;		jbe	short _eot_ok
;		mov	[eot],al

		retn

; ---------------------------------------------------------------------------

; 17/10/2022
;DRVLET	equ drvlet - DOSBIOSEG_2C7h
;SNGMSG	equ sngmsg - DOSBIOSEG_2C7h	
; 09/12/2022
DRVLET equ drvlet
SNGMSG equ sngmsg

; 16/10/2022

;---------------------------------------------------------------------------
;  ask to swap the disk in drive a:
;	es:di -> bds
;	ds -> Bios_Data
;---------------------------------------------------------------------------

		; 19/10/2022
swpdsk:		test	byte [IsWin386], 1			
		;test	ds:IsWin386, 1	; Is win386 present?
		jz	short no_win386	; no, skip SetFocus
		
		; set focus to the correct VM
		;;call	far 70h:8D1h	; MSDOS 6.21 IO.SYS BIOSCODE:179Ah
		; 17/10/2022
		call	DOSBIOSSEG:V86_Crit_SetFocus
		;call	far ptr	V86_Crit_SetFocus ; call far 70h:8D1h
					; call far KERNEL_SEGMENT:V86_Crit_SetFocus
no_win386:				
		push	cx
		push	dx
		mov	dl, [es:di+5]	; [es:di+BDS.drivelet]
					; get the drive	letter

; WARNING : next two instructions assume that if the new disk is for drive B
;           then existing dsk is drive A & vice versa

		mov	dh, dl
		xor	dh, 1
		sub	cx, cx		; nobody has handled swap disk
		mov	ax, 4A00h	; multMULT<<8)|multMULTSWPDSK
					; broad	cast code for swap disk
					; Broadcast it
		int	2Fh	
		inc	cx		; cx == -1 ?
		jz	short swpdsk9	; somebody has handled it

; using a different drive in a one drive system so request the user change disks

		add	dl, 'A'
		; 17/10/2022
		mov	[cs:DRVLET], dl
		; 16/10/2022
		;;mov	byte [cs:drvlet], dl
		;mov	byte ptr cs:17E4h, dl ; [cs:drvlet]
					; 0070h:3D54h =	2C7h:17E4h
		mov	si, SNGMSG
		;mov	si, 17C8h	; sngmsg
					; 0070h:3D38h =	2C7h:17C8h
		push	bx
		cs
		lodsb			; get the next character of the message
		;lods	byte ptr cs:[si]
wrmsg_loop:				
		int	29h		; DOS 2+ internal - FAST PUTCHAR
					; AL = character to display
		cs
		lodsb
		;lods	byte ptr cs:[si] ; cs lodsb
					; get the next character of the	message
		or	al, al
		jnz	short wrmsg_loop
		call	con_flush	; flush out keyboard queue
					; call rom-bios
		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character
		pop	bx
swpdsk9:				
		pop	dx
		pop	cx
		retn

; ---------------------------------------------------------------------------

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;--------------------------------------------------------
; include msbio.cl2 (MSDOS 6.0, 1991)
;--------------------------------------------------------
; (MSDOS 6.21 IO.SYS BIOSCODE:17D5h)
;--------------------------------------------------------
; 17/03/2019 - Retro DOS v4.0

		; MSDOS 5.0 IO.SYS offset 0070h:3D38h or 02C7h:17C8h
sngmsg:		db 0Dh,0Ah
		db 'Insert diskette for drive '

		; MSDOS 5.0 IO.SYS offset 0070h:3D54h or 02C7h:17E4h
drvlet:		db 'A: and press any key when ready',0Dh,0Ah
		db 0Ah,0

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; input : es:di points to current bds for drive.
; return : zero set if no open files
;	   zero reset if open files
;---------------------------------------------------------------------------

chkopcnt:		
		cmp	word [es:di+20h], 0 ; [es:di+BDS.opcnt]
		retn

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; at media check time, we need to really get down and check what the change is.
; this is guaranteed to be expensive.
;
;	es:di -> bds, ds -> Bios_Data
;---------------------------------------------------------------------------

mediacheck:	
		call	checksingle	; make sure correct disk is in place
		xor	si, si
		call	haschange
		jz	short mediaret
		call	checkromchange
		jnz	short mediadovolid
		push	ax
		push	dx
		mov	dl, [es:di+4]	; [es:di+BDS.drivenum]
					; set logical drive number
		mov	ah, 16h
		int	13h		; DISK - FLOPPY	DISK - CHANGE OF DISK STATUS (AT,XT2,XT286,CONV,PS)
					; DL = drive to	check
					; Return: AH = disk change status
		pop	dx
		pop	ax
		jb	short mediadovolid
		mov	si, 1		; signal no change

; there are some drives with changeline that "lose" the changeline indication
; if a different drive is accessed after the current one. in order to avoid
; missing a media change, we return an "i don't know" to dos if the changeline
; is not active and we are accessing a different drive from the last one.
; if we are accessing the same drive, then we can safely rely on the changeline
; status.
		; 19/10/2022
		mov	bl, [tim_drv]	; get last drive accessed
		cmp	[es:di+4], bl	; [es:di+BDS.drivenum]
					; (If the last drive accessed is not current drive
					; media	change status may be incorrect.	So,
					; "I don't now" will be returned even if it is indicated
					; as media is not changed.)
		jz	short mediaret	; (same	drive,
					; media	changeline indication is reliable)

; do the 2 second twiddle. if time >= 2 seconds, do a volid check.
; otherwise return "i don't know" (strictly speaking, we should return a
; "not changed" here since the 2 second test said no change.)

		push	ax
		push	cx
		push	dx
		call	Check_Time_Of_Access
		pop	dx
		pop	cx
		pop	ax
		or	si, si
		jz	short mediadovolid ; check_time	says ">= 2 secs	passed"
					; (volume id will be checked)
		xor	si, si		; return "i don't know"
mediaret:				
		retn
; ---------------------------------------------------------------------------

; somehow the media was changed. look at vid to see. we do not look at fat
; because this may be different since we only set medbyt when doing a read
; or write.

mediadovolid:				
		call	GetBp		; build	a new bpb in current bds
		jb	short mediaret
		call	check_vid
		jnb	short mediaret
		jmp	maperror	; fix up al for	return to dos
; ---------------------------------------------------------------------------

; simple, quick check of latched change. if no indication, then return
; otherwise do expensive check. if the expensive test fails, pop off the
; return and set al = 15 (for invalid media change) which will be returned to
; dos.
;
; for dos 3.3, this will work only for the drive that has changeline.

;	call with es:di -> bds, ds -> Bios_Data
;	***** warning:  this routine will return one level up on the stack
;			if an error occurs!

checklatchio:	

; if returning fake bpb then assume the disk has not changed
			
		call	chkopcnt
		jz	short checkret	; done if zero

; check for past rom indications. if no rom change indicated, then return ok.

		call	checkromchange
		jz	short checkret

; we now see that a change line has been seen in the past. let's do the
; expensive verification.

		call	GetBp		; build	bpb in current bds
		jb	short ret_no_error_map ; getbp has already called maperror
		call	check_vid
		jb	short checklatchret ; disk error trying	to read	in.
		or	si, si		; is changed for sure?
		jns	short checkret
		call	returnvid
checklatchret:				
		call	maperror	; fix up al for	return to dos
ret_no_error_map:			
		stc
		pop	si		; pop off return address
checkret:				
		retn
; ---------------------------------------------------------------------------

; check the fat and the vid. return in di -1 or 0. return with carry set
; only if there was a disk error. return that error code in ax.
;
;	called with es:di -> bds, ds -> Bios_Data

checkfatvid:				
		call	fat_check	; check	the fat	and the	vid
		or	si, si
		js	short changed_drv ;

; the fat was the same. fall into check_vid and check volume id.

		; fall into check_vid

; =============== S U B	R O U T	I N E =======================================

; now with the extended boot record, the logic should be enhanced.
;
; if it is the extended boot record, then we check the volume serial
; number instead of volume id. if it is different, then set si to -1.
;
; if it is same, then si= 1 (no change).
;
; if it is not the extended boot record, then just follows the old
; logic. dos 4.00 will check if the # of fat in the boot record bpb
; is not 0.  if it is 0 then it must be non_fat based system and
; should have already covered by extended boot structure checking.
; so, we will return "i don't know" by setting si to 0.
;
; this routine assume the newest valid boot record is in cs:[disksector].
; (this will be gauranteed by a successful getbp call right before this
; routine.)
;
;	called with es:di -> bds, ds -> bds

		; 19/10/2022
check_vid:

; check the disksector.EXT_BOOT_SIG variable for the extended
; boot signature. if it is set then go to do the extended
; id check otherwise continue with code below

		cmp	byte [disksector+26h], 29h
					; [disksector+EXT_BOOT.SIG],
					; EXT_BOOT_SIGNATURE
		jz	short do_ext_check_id
		call	haschange
		jz	short checkret
		xor	si, si
		cmp	byte [disksector+10h], 0 
					; [disksector+EXT_BOOT.BPB+EBPB.NUMBEROFFATS]
		jz	short checkfatret ; don't read vol id
					; if not fat system
		call	read_volume_id
		jb	short checkfatret
		call	check_volume_id
		mov	si, 0FFFFh	; -1
					; definitely changed
		jnz	short changed_drv

		inc	si		; not changed
vid_no_changed:				
		call	resetchanged
		; 12/12/2022
		; cf=0 ('and' instruction in 'resetchanged' clears cf) 
		;clc
checkfatret:				
		retn
; ---------------------------------------------------------------------------

		; 12/12/2022
changed_drv:
		clc			; cas -- return	no error
		mov	byte  [tim_drv], 0FFh 
					; ensure that we ask rom for media
		retn			; check	next time round
; ---------------------------------------------------------------------------

; extended id check

; 16/10/2022

; the code to check extended id is basically a check to see if the
; volume serial number is still the same. the volume serial number
; previously read is in cs:disksector.EXT_BOOT_SERIAL
; ds:di points to the bds of the drive under consideration.
; the bds has fields containing the high and low words 
; of the volume serial number of the media in the drive.
; compare these fields to the fields mentioned above. if these fields
; do not match the media has changed and so we should jump to the code
; starting at ext_changed else return "i don't know" status
; in the register used for the changeline status and continue executing
; the code given below. for temporary storage use the register which
; has been saved and restored around this block.
;
; bds fields in inc\msbds.inc

		; 19/10/2022
do_ext_check_id:			
		push	ax
		;mov	ax, word ptr ds:disksector+27h
					; [DiskSector+EXT_BOOT.SERIAL]
		mov	ax, [disksector+27h]
		cmp	ax, [es:di+57h]	; [di+BDS.vol_serial]
		jnz	short ext_changed
		mov	ax, [disksector+29h] ; [DiskSector+EXT_BOOT.SERIAL+2]
		cmp	ax, [es:di+59h]	; [di+BDS.vol_serial+2]
		jnz	short ext_changed
		xor	si, si		; 0
					; don't know
		pop	ax
		jmp	short vid_no_changed
					; reset the flag
; ---------------------------------------------------------------------------

ext_changed:				
		pop	ax
		mov	si, 0FFFFh	; -1
					; disk changed!
		; 12/12/2022
		; ('changed_drv' clears cf)
		;clc
		jmp	short changed_drv

; ---------------------------------------------------------------------------

; at i/o time, we detected the error. now we need to determine whether the
; media was truly changed or not. we return normally if media change unknown.
; and we pop off the call and jmp to harderr if we see an error.
;
; es:di -> bds

checkio:				
		cmp	ah, 6
		jnz	short checkfatret
		call	chkopcnt
		jz	short checkfatret
		call	GetBp
		jb	short no_error_map
		call	checkfatvid
		jb	short checkioret ; disk	error trying to	read in.
		or	si, si		; is changed for sure?
		js	short checkioerr ; yes changed
		inc	bp		; allow	a retry
		retn
; ---------------------------------------------------------------------------

checkioerr:				
		call	returnvid

checkioret:				
		stc			; make sure carry gets passed through
		jmp	harderr
; ---------------------------------------------------------------------------

no_error_map:				
		jmp	harderr2

; =============== S U B	R O U T	I N E =======================================

; return vid sets up the vid for a return to dos.
;  es:di -> bds, returns pointer in packet to bds_volid
;  **** trashes si! ****

returnvid:		
		mov	si, 22		; extra
					; offset into pointer to return	value
		call	vid_into_packet
		mov	ah, 6
		stc
		retn

; ---------------------------------------------------------------------------

; moves the pointer to the volid for the drive into the original request packet
; no attempt is made to preserve registers.
;
; assumes es:di -> bds
; **trashes si**

media_set_vid:				
		mov	si, 15		; trans+1
					; return the value here	in packet

		; fall into vid_into_packet

; =============== S U B	R O U T	I N E =======================================

; return pointer to vid in bds at es:di in packet[si]

		; 19/10/2022
vid_into_packet:
		push	ds		; return pointer to vid	in bds at es:di	in packet[si]
		lds	bx, [ptrsav]
		add	di, 75		; BDS.volid
		mov	[bx+si], di
		sub	di, 75		; BDS.volid
		mov	[bx+si+2], es
		pop	ds
dofloppy:	; 18/12/2022
		retn

; ---------------------------------------------------------------------------

;----------------------------------------------------------------------------
;   hidensity - examine a drive/media descriptor to set the media type. if
;   the media descriptor is not f9 (not 96tpi or 3 1/2), we return and let the
;   caller do the rest. otherwise, we pop off the return and jump to the tail
;   of getbp. for 3.5" media, we just return.
;
;   inputs:	es:di point to correct bds for this drive
;		ah has media byte
;
;   outputs:	carry clear
;		    no registers modified
;		carry set
;		    al = sectors/fat
;		    bh = number of root directory entries
;		    bl = sectors per track
;		    cx = number of sectors
;		    dh = sectors per allocation unit
;		    dl = number of heads
;
;----------------------------------------------------------------------------

hidensity:

; check for correct drive
		
		; 12/12/2022
		test	byte [es:di+23h], 2		
		;test	word [es:di+23h], 2 ; is it special?	
					; [es:di+BDS.flags], fchangeline
		jz	short dofloppy	; no, do normal floppy test

; we have a media byte that is pretty complex. examine drive information
; table to see what kind it is.

		cmp	byte [es:di+22h], 2 ; is it single-media?
		jz	short dofloppy	; [es:di+BDS.formfactor], ffSmall
					; yes, use fatid...
; 96 tpi drive?
		cmp	ah, 0F9h
		jnz	short dofloppy

;------ If formfactor of drive = ffother or ff288 it has to be
;------ a 720K diskette

		cmp	byte [es:di+22h], 7 ; [es:di+BDS.formfactor]
					; ffOther
		jz	short Is720K
		cmp	byte [es:di+22h], 9 ; [es:di+BDS.formfactor]
					; ff288
		jz	short Is720K
		mov	al, 7		; seven	sectors	/ fat
		mov	bx, 57359	; 224*256+0Fh
					; 224 root dir entries
					; & 0Fh sector max
		mov	cx, 2400	; 80*15*2
					; 80 tracks, 15 sectors/track,
					; 2 sides
		mov	dx, 258		; 1*256+2
					; sectors/allocation unit
					; & head max
		add	sp, 2		; pop off return address
		jmp	Has1		; return to tail of getbp
; ---------------------------------------------------------------------------

Is720K:					
		add	sp, 2		; pop off return address
		jmp	Has720K		; return to 720K code
; ---------------------------------------------------------------------------

		; 18/12/2022
;dofloppy:				
		;retn

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

;---------------------------------------------------------------------------
; set_changed_dl - sets flag bits according to bits set in bx.
;		   essentially used to indicate changeline, or format.
;
;   inputs:	dl contains physical drive number
;		bx contains bits to set in the flag field in the bdss
;   outputs:	none
;   registers modified: flags
;
;	called from int13 hooker.  Must preserve ALL registers!!!
;
; in the virtual drive system we *must* flag the other drives as being changed
;---------------------------------------------------------------------------

set_changed_dl:	
		push	es
		push	di
		;les	di, ds:start_bds
		; 19/10/2022
		les	di, [start_bds]

; note: we assume that the list is non-empty

scan_bds:				
		cmp	[es:di+4], dl	; [es:di+BDS.drivenum]
		jnz	short get_next_bds

; someone may complain, but this *always* must be done when a disk change is
; noted. there are *no* other compromising circumstances.

		or	[es:di+23h], bx	; [es:di+BDS.flags]
					; signal change	on other drive
get_next_bds:				
		les	di, [es:di]	; [es:di+BDS.link]
					; go to	next bds
		cmp	di, 0FFFFh
		jnz	short scan_bds	; loop unless we hit end of chain
		pop	di
		pop	es
		retn

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; checkromchange - see if external program has diddled rom change line.
;
;   inputs:	es:di points to current bds.
;   outputs:	zero set - no change
;		zero reset - change
;   registers modified: none
;---------------------------------------------------------------------------

checkromchange:	
		;test	word [es:di+BDS.flags], fchanged ; 40h
		; 10/12/2022
		test	byte [es:di+23h], 40h
		;test	word [es:di+23h], 40h ; [es:di+BDS.flags]
					; fchanged
		retn

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; resetchanged - restore value of change line
;
;   inputs:	es:di points to current bds
;   outputs:	none
;   registers modified: none
;---------------------------------------------------------------------------

resetchanged:	
		;and	word [es:di+BDS.flags], ~fchanged ; 0FFBFh	
		; 10/12/2022
		and	byte [es:di+23h], 0BFh
		;and	word [es:di+23h], 0FFBFh ; [es:di+BDS.flags]
					; ~fchanged
		retn

; =============== S U B	R O U T	I N E =======================================

;---------------------------------------------------------------------------
; haschange - see if drive can supply change line
;
;   inputs:	es:di points to current bds
;   outputs:	zero set - no change line available
;		zero reset - change line available
;   registers modified: none
;---------------------------------------------------------------------------

haschange:
		;test	word [es:di+BDS.flags], fchangeline ; 2
		; 10/12/2022
		test	byte [es:di+23h], 2		
		;test	word [es:di+23h], 2 ; [es:di+BDS.flags]
					; fchangeline
		retn

; ---------------------------------------------------------------------------

; 16/10/2022

;-------------------------------------------------------------------------
; set_volume_id      -	main routine, calls other routines.
; read_volume_id     -	read the volume id and tells if it has been changed.
; transfer_volume_id -	copy the volume id from tmp to special drive.
; check_volume_id    -	compare volume id in tmp area with one expected for drive.
; fat_check          -	see of the fatid has changed in the specified drive.
;-------------------------------------------------------------------------

; set_volume_id
;   if drive has changeline support, read in and set the volume_id
; and the last fat_id byte. if no change line support then do nothing.
;
;   on entry:
;	es:di points to the bds for this disk.
;	ah contains media byte
;
;   on exit:
;	carry clear:
;	   successful call
;	carry set
;	   error and ax has error code

set_volume_id:				
		push	dx		; save registers
		push	ax
		call	haschange	; does drive have changeline support?
		jz	short setvret	; no, get out
		call	read_volume_id
		jb	short seterr
		call	transfer_volume_id ; copy the volume id	to special drive
		call	resetchanged	; restore value	of change line
setvret:				
		; 10/12/2022
		; cf = 0
		;clc			; no error, clear carry flag
		pop	ax		; restore registers
		pop	dx
		retn
; ---------------------------------------------------------------------------

seterr:					
		pop	dx		; pop stack but don't overwrite ax
		pop	dx		; restore dx
		retn
; ---------------------------------------------------------------------------
root_sec:	dw 0			; root sector #

; 16/10/2022
;ROOTSEC equ root_sec - DOSBIOSEG_2C7h		
; 09/12/2022
ROOTSEC equ root_sec

; =============== S U B	R O U T	I N E =======================================

; 16/10/2022

; read_volume_id read the volume id and tells if it has been changed.
;
;   on entry:
;	es:di points to current bds for drive.
;
;   on exit:
;	carry clear
;	    si = 1  no change
;	    si = 0  ?
;	    si = -1 change
;
;	carry set:
;	    error and ax has error code.

read_volume_id:
		push	dx		; preserve registers
		push	cx
		push	bx
		push	ax
		push	es		; stack the bds last
		push	di
		push	ds		; point es to Bios_Data
		pop	es
		mov	di, tmp_vid	; "NO NAME	 "
		mov	si, nul_vid	; "NO NAME	 "
		mov	cx, 12		; initialize tmp_vid to	null vi_id
		rep movsb
		pop	di
		pop	es
		mov	al, [es:di+11]	; [es:di+BDS.fats]
					; # of fats
		mov	cx, [es:di+17]	; [es:di+BDS.fatsecs]
					; sectors / fat
		mul	cl		; size taken by	fats
		add	ax, [es:di+9]	; [es:di+BDS.resectors]
					; add on reserved sectors
					;
					; ax is	now sector # (0	based)
		; 17/10/2022
		mov	[cs:ROOTSEC], ax
		;mov	word ptr cs:198Fh, ax ; [cs:root_sec]
					; 0070h:3EFFh =	2C7h:198Fh
		mov	ax, [es:di+12]	; [es:di+BDS.direntries]
					; # root dir entries
		mov	cl, 4		; 16 entries/sector
		shr	ax, cl		; divide by 16
		mov	cx, ax		; cx is	# of sectors to	scan
next_sec:				
		push	cx		; save outer loop counter
		mov	ax, [cs:ROOTSEC]
		;mov	ax, word ptr cs:198Fh ; [cs:root_sec]
					; get sector #
		mov	cx, [es:di+19]	; [es:di+BDS.secpertrack]
					; sectors / track
		xor	dx, dx
		div	cx

; set up registers for call to read_sector

		inc	dx		; dx= sectors into track
					; ax= track count from 0
		mov	cl, dl		; sector to read
		xor	dx, dx
		div	word [es:di+21] ; [es:di+BDS.heads]
					; # heads on this disc
		mov	dh, dl		; head number
		mov	ch, al		; track	#
		call	read_sector	; get first sector of the root directory,
					; ds:bx	-> directory sector
		jb	short readviderr
		mov	cx, 16		; # of dir entries in a	block of root
		mov	al, 8		; volume label bit
fvid_loop:				
		cmp	byte [bx], 0 ; end of dir?
		jz	short no_vid	; yes, no vol id
		cmp	byte [bx], 0E5h ; empty entry?
		jz	short ent_loop	; yes, skip
		test	[bx+11], al	; is volume label bit set in fcb?
		jnz	short found_vid	; jmp yes
ent_loop:				
		add	bx, 32		; add length of	directory entry
		loop	fvid_loop
		pop	cx		; outer loop
		inc	word [cs:ROOTSEC]
		;inc	word ptr cs:198Fh ; inc word [root_sec]
					; next sector
		loop	next_sec	; continue
notfound:				
		xor	si, si
		jmp	short fvid_ret
; ---------------------------------------------------------------------------

found_vid:				
		pop	cx		; clean stack of outer loop counter
		mov	si, bx		; point	to volume_id
		push	es		; preserve current bds
		push	di
		push	ds
		pop	es		; point es to Bios_Data
		mov	di, tmp_vid	; "NO NAME	 "
		mov	cx, 11		; VOLID_SIZ-1
					; length of string minus nul
		rep movsb		; mov volume label to tmp_vid
		xor	al, al
		stosb			; null terminate
		xor	si, si
		pop	di		; restore current bds
		pop	es
fvid_ret:				
		pop	ax
		; 10/12/2022
		; cf = 0
		;clc
rvidret:				
		pop	bx		; restore registers
		pop	cx
		pop	dx
		retn
; ---------------------------------------------------------------------------

no_vid:					
		pop	cx		; clean stack of outer loop counter
		jmp	short notfound	; not found
; ---------------------------------------------------------------------------

readviderr:				
		pop	si		; trash the outer loop counter
		pop	si		; caller's ax, return error code instead 
		jmp	short rvidret

; =============== S U B	R O U T	I N E =======================================

; transfer_volume_id - copy the volume id from tmp to special drive
;
; inputs:	es:di has current bds
; outputs:	bds for drive has volume id from tmp

transfer_volume_id:	
		push	di		; copy the volume id from tmp to special drive
		push	si
		push	cx
		mov	si, tmp_vid	; "NO NAME	 "
		;add	di, BDS.volid
		add	di, 75		; BDS.volid
		;mov	cx, VOLID_SIZ
		mov	cx, 12		; VOLID_SIZ
		cld
		rep movsb
		pop	cx
		pop	si
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

;  check_volume_id - compare volume id in tmp area with
;		     one expected for drive
;
;   inputs:	es:di has current bds for drive
;   outputs:	zero true means it matched

check_volume_id:	
		push	di
		push	cx
		mov	si, tmp_vid	; "NO NAME	 "
		;add	di, BDS.volid
		add	di, 75		; BDS.volid
		;mov	cx, VOLID_SIZ
		mov	cx, 12		; VOLID_SIZ
		cld
		repe cmpsb		; are the 2 volume_ids the same?
		pop	cx
		pop	di
		retn

; =============== S U B	R O U T	I N E =======================================

;   fat_check - see of the fatid has changed in the specified drive.
;	      - uses the fat id obtained from the boot sector.
;
;   inputs:	medbyt is expected fat id
;		es:di points to current bds
;
;   output:	si = -1 if fat id different,
;		si = 0 otherwise
;
;   no other registers changed.

fat_check:		
		push	ax
		xor	si, si		; say fat id's are same.
		mov	al, [medbyt]	; 19/10/2022
		cmp	al, [es:di+10h]	; [es:di+BDS.media]
					; compare it with the bds medbyte
		jz	short okret1	; carry	clear
		dec	si
okret1:					
		pop	ax
		retn

; ---------------------------------------------------------------------------

; BIOSCODE:1A69h (MSDOS 6.21, IO.SYS)
		;times 7 db 0

; BIOSCODE:180Bh (MSDOS 5.0 IO.SYS)	

		; 09/12/2022
		;times 4 db 0	; 17/10/2022
		;db 4 dup(0)	; times 4 db 0

; ---------------------------------------------------------------------------

		; 09/12/2022
		;db 0

number2div	equ ($-BCode_start)
number2mod	equ (number2div % 16)

%if number2mod>0 & number2mod<16
		times (16-number2mod) db 0
%endif

;align 16

; 09/12/2022
BCODE_END	equ $ - BCode_start
;SYSINITSEG	equ IOSYSCODESEG+(BCODE_END>>4)
; 13/12/2022
SYSINITOFFSET	equ BCODE_END
SYSINITSEG	equ IOSYSCODESEG+(SYSINITOFFSET>>4)

; 30/12/2022 - Retro DOS v4.2
; (SYSINITSEG is 473h for MSDOS 6.21 IO.SYS)

;--- End of DOSBIOS code segment ---------------------------------------------

; 16/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 01/05/2019 - Retro DOS v4.0 
; ============================================================================
; end of BIOSCODE

; ----------------------------------------------------------------------------
; %include sysinit5.s	; 09/12/2022
; ----------------------------------------------------------------------------

;=============================================================================
; (IO.SYS) SYSINIT SEGMENT 
;=============================================================================
; 09/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

section .SYSINIT vstart=0

; ****************************************************************************
; SYSINIT.BIN (MSDOS 6.21 IO.SYS) - RETRO DOS v4.0 by ERDOGAN TAN - 21/10/2022
; ----------------------------------------------------------------------------
; Last Update: 04/01/2023 (Modified IO.SYS)  ((Previous: 30/12/2022))
; ----------------------------------------------------------------------------
; Beginning: 03/06/2018 (Retro DOS 3.0), 21/03/2019 (Retro DOS 4.0)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15
; ----------------------------------------------------------------------------
;	   ((nasm sysinit6.s -l sysinit6.lst -o SYSINIT6.BIN -Z error.txt)) 	
; ----------------------------------------------------------------------------
; Modified from 'sysinit2.s' (SYSINIT2.BIN) file of Retro DOS v3.0 (6/7/2018)
; ----------------------------------------------------------------------------
; Derived from 'SYSINIT1.ASM' and 'SYSINIT2.ASM' files of MSDOS 6.0
; source code by Microsoft, 1991 
; ----------------------------------------------------------------------------
; Derived from 'SYSINIT.ASM' file of MSDOS 2.0 (IBM PCDOS v2.0) source code
; by Microsoft, 12/10/1983
; ****************************************************************************
; main file: 'retrodos4.s'
; incbin 'SYSINIT3.BIN' ; (SYINITSEG)

; 30/12/2022 - Retro DOS v4.2 
; Retro DOS v4.0 - 2019
; SYSINIT (MSDOS 6.21 IO.SYS) draft: 'sysinit3.s' (01/07/2019)
 
; 21/10/2022
; ----------------------------------------------------------------------------
; This source code (version) is based on SYSINIT source code of disassembled
; MSDOS 5.0 IO.SYS file (SYSINIT.BIN) 
; Dissassembler: Hex-Rays Interactive Disassembler (IDA)
; ----------------------------------------------------------------------------
; Binary file splitter & joiner: FFSJ v3.3

;--------------------------------------------------------------
; SYSINIT.TXT (27/01/1983)
;--------------------------------------------------------------
;    SYSINIT is  a module linked behind the OEM bios.  It takes
;over  the  system  initialization  after  the  OEM  bios   has
;performed any  initialization  it  needs  to  do.   Control is
;transfered with a long jump to the external  variable  SYSINIT
;
;
;   The OEM  has  the  following  variables declared external:
;
;   CURRENT_DOS_LOCATION    WORD
;
;This word  contains  the  segment  number of the DOS before it
;is relocated.  The OEM bios must set this value.
;
;   FINAL_DOS_LOCATION      WORD
;
;This word contains the segment number of the DOS after SYSINIT
;moves it.  The OEM bios must set this value.
;
;   DEVICE_LIST             DWORD
;
;This  double  word  pointer  points  to  the  linked  list  of
;character and block device drivers.  The  OEM  must  set  this
;value.
;
;   MEMORY_SIZE             WORD
;
;This word  contains  the  number  of  RAM  paragraphs.  If the
;bios doesn't set  this  variable  SYSINIT  will  automatically
;calculate it.   NOTE:  systems with PARITY checked memory must
;size memory in the BIOS.  SYSINITs method is to  write  memory
;and read it back until it gets a mismatch.
;
;   DEFAULT_DRIVE           BYTE
;
;This is  the initial default drive when the system first comes
;up.  drive a=0, drive b=1,  etc.   If  the  bios  doesn't  set
;it then drive a is assumed.
;
;   BUFFERS                 BYTE
;
;This is  the  default  number of buffers for the system.  This
;value may be overridden by the user in  the  CONFIG.SYS  file.
;It is DBed to 2 in SYSINIT it should be greater than 1.
;
;   FILES                   BYTE
;
;This is  the  default  number  of  files for the system.  This
;value may be overridden by the user in  the  CONFIG.SYS  file.
;It is  DBed  to  8 in SYSINIT, values less than 5 are ignored.
;
;   SYSINIT                 FAR
;
;The entry  point  of  the  SYSINIT  module.  OEM BIOS jumps to
;this label at the end of its INIT code.
;
;   The OEM  has  the  following  variables declared public:
;
;   RE_INIT                 FAR
;
;This is an entry point which allows the BIOS to do some INIT
;work  after  the  DOS is initialized.  ALL REGISTERS MUST BE
;PRESERVED.  On entry DS points to the first available memory
;(after  the DOS).  DS:0 points to a 100H byte program header
;prefix which represents  the  "program"  currently  running.
;This  program  should  be  thought  of  as  the OEM BIOS and
;SYSINIT taken together.  This is not  a  normal  program  in
;that  no  memory  is  allocated to it, it is running in free
;memory.
;NOTES:
;     At the time this routine is called SYSINIT occupies the
;highest 10K of memory ("highest" is determined by the  value
;of the MEMORY_SIZE variable), DO NOT DO WRITES THERE.
;     Since this is called AFTER DOS is initialized, you can
;make system calls.  This also implies that the code for this
;routine    CANNOT   be   thrown   away   by   use   of   the
;FINAL_DOS_LOCATION since the DOS has already been moved.
;     If you don't want  anything done just set this to point
;at a FAR RET instruction.

; ----------------------------------------------------------------------
; TITLE   BIOS SYSTEM INITIALIZATION
; ----------------------------------------------------------------------

;include version.inc
; ----------------------------------------------------------------------

;FALSE   EQU     0
;TRUE    EQU     0FFFFh

;IBMVER	    EQU     TRUE
;IBMCOPYRIGHT EQU   FALSE
;STACKSW    EQU	    TRUE		;Include Switchable Hardware Stacks
;IBMJAPVER  EQU     FALSE		; If TRUE set KANJI true also
;MSVER      EQU     FALSE
;ALTVECT    EQU     FALSE		; Switch to build ALTVECT version
;KANJI      EQU     FALSE

;(MSDOS 6.0, versiona.inc, 1991)
; ----------------------------------------------------------------------
;MAJOR_VERSION  EQU	6
;;MINOR_VERSION	EQU	0	;6.00
;MINOR_VERSION  EQU	21	;6.21  ; 21/03/2019 - Retro DOS v4.0

; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0)
; ----------------------------------------------------------------------
;MAJOR_VERSION   EQU	5
;MINOR_VERSION   EQU	0

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21)
MAJOR_VERSION   EQU	6
MINOR_VERSION   EQU	22

expected_version equ	(MINOR_VERSION<<8)+MAJOR_VERSION

;DOSREVNM equ	00000000b       ; m037 - bits 0-2 = revision number of DOS
				; currently 0.
DOSREVNM equ	00000111b	; [[[ 7 for Retro DOS v4.0 ]]] (21/03/2019)	
DOSINROM equ	00001000B       ; bit 3 of ver flags returned in BH
DOSINHMA equ	00010000B       ; bit 4 of ver flags 

;      if1
;      %OUT  ... for DOS Version 5.00 ...
;      endif

       ;******************************
       ;Each assembler program should:
       ;  mov ah,030h                   ;DOS Get Version function
       ;  int 021h                      ;Version ret. in AX,minor version first
       ;  cmp ax,expected_version       ;ALL utilities should check for an
       ;  jne error_handler             ; EXACT version match.
       ;******************************

; ----------------------------------------------------------------------
; device definitions

;Attribute bit masks
DEVTYP  EQU     8000h           ;Bit 15 - 1  if Char, 0 if block
DEVIOCTL EQU    4000h           ;Bit 14 - CONTROL mode bit
ISFATBYDEV EQU  2000h           ;Bit 13 - Device uses FAT ID bytes, comp media.
ISCIN   EQU     0001h           ;Bit 0 - This device is the console input.
ISCOUT  EQU     0002h           ;Bit 1 - This device is the console output.
ISNULL  EQU     0004h           ;Bit 2 - This device is the null device.
ISCLOCK EQU     0008h           ;Bit 3 - This device is the clock device.
ISIBM   EQU     0010h           ;Bit 4 - This device is special

; The device table list has the form:
struc	SYSDEV
.NEXT:		resd 1		;Pointer to next device header
.ATT:		resw 1		;Attributes of the device
.STRAT:		resw 1		;Strategy entry point
.INT:		resw 1		;Interrupt entry point
.NAME:		resb 8		;Name of device (only first byte used for block)
.size:
endstruc

;Static Reguest Header
struc	SRHEAD
.REQLEN:	resb 1		;Length in bytes of request block
.REQUNIT:	resb 1		;Device unit number
.REQFUNC:	resb 1		;Type of request
.REQSTAT:	resw 1		;Status Word
        	resb 8		;Reserved for queue links
.size:
endstruc

;Status word masks
STERR   EQU     8000H           ;Bit 15 - Error
STBUI   EQU     0200H           ;Bit 9 - Buisy
STDON   EQU     0100H           ;Bit 8 - Done
STECODE EQU     00FFH           ;Error code
WRECODE EQU     0

;Function codes
DEVINIT EQU     0               ;Initialization
DINITHL EQU     26              ;Size of init header
DEVMDCH EQU     1               ;Media check
DMEDHL  EQU     15              ;Size of media check header
DEVBPB  EQU     2               ;Get BPB
DEVRDIOCTL EQU  3               ;IOCTL read
DBPBHL  EQU     22              ;Size of Get BPB header
DEVRD   EQU     4               ;Read
DRDWRHL EQU     22              ;Size of RD/WR header
DEVRDND EQU     5               ;Non destructive read no wait (character devs)
DRDNDHL EQU     14              ;Size of non destructive read header
DEVIST  EQU     6               ;Input status
DSTATHL EQU     13              ;Size of status header
DEVIFL  EQU     7               ;Input flush
DFLSHL  EQU     15              ;Size of flush header
DEVWRT  EQU     8               ;Write
DEVWRTV EQU     9               ;Write with verify
DEVOST  EQU     10              ;Output status
DEVOFL  EQU     11              ;Output flush
DEVWRIOCTL EQU  12              ;IOCTL write

; ----------------------------------------------------------------------
struc	SYS_FCB
.fcb_drive:	resb 1
.fcb_name:	resb 8
.fcb_ext:	resb 3
.fcb_EXTENT:	resw 1
.fcb_RECSIZ:	resw 1	; Size of record (user settable)
.fcb_FILSIZ:	resw 1	; Size of file in bytes; used with the following
                        ; word
.fcb_DRVBP:	resw 1	; BP for SEARCH FIRST and SEARCH NEXT
.fcb_FDATE:	resw 1	; Date of last writing
.fcb_FTIME:	resw 1	; Time of last writing
.fcb_DEVID:	resb 1	; Device ID number, bits 0-5 if file.
                        ; bit 7=0 for file, bit 7=1 for I/O device
                        ; If file, bit 6=0 if dirty
                        ; If I/O device, bit 6=0 if EOF (input)
                        ;               Bit 5=1 if Raw mode
                        ;               Bit 0=1 if console input device
                        ;               Bit 1=1 if console output device
                        ;               Bit 2=1 if null device
                        ;               Bit 3=1 if clock device
.fcb_FIRCLUS:	resw 1	; First cluster of file
.fcb_CLUSPOS:	resw 1	; Position of last cluster accessed
.fcb_LSTCLUS:	resw 1	; Last cluster accessed and directory
             	resb 1	; pack 2 12 bit numbers into 24 bits...
.fcb_NR:	resb 1	; Next record
.fcb_RR:	resb 4	; Random record
.size:
endstruc

; ----------------------------------------------------------------------
; Field definition for I/O buffer information

; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, BUFFER.INC, 1991)

struc buffinfo
.buf_next:	resw 1	; Pointer to next buffer in list
.buf_prev:	resw 1	; Pointer to previous buffer in list
.buf_ID:	resb 1	; Drive of buffer (bit 7 = 0)
			; SFT table index (bit 7 = 1)
			; = FFh if buffer free
.buf_flags:	resb 1	; Bit 7 = 1 if Remote file buffer
			;	= 0 if Local device buffer
			; Bit 6 = 1 if buffer dirty
			; Bit 5 = Reserved
			; Bit 4 = Search bit (bit 7 = 1)
			; Bit 3 = 1 if buffer is DATA
			; Bit 2 = 1 if buffer is DIR
			; Bit 1 = 1 if buffer is FAT
			; Bit 0 = Reserved
.buf_sector:	resd 1	; Sector number of buffer (bit 7 = 0)
; The next two items are often refed as a word (bit 7 = 0)
.buf_wrtcnt:	resb 1	; For FAT sectors, # times sector written out
.buf_wrtcntinc:	resw 1	; "   "     "   , # sectors between each write
.buf_DPB :	resd 1	; Pointer to drive parameters
.buf_fill:	resw 1	; How full buffer is (bit 7 = 1)
.buf_reserved:	resb 1	; make DWORD boundary for 386
.size:
endstruc

%define buf_offset	dword [buf_sector]
			;For bit 7 = 1, this is the byte
			;offset of the start of the buffer in
			;the file pointed to by buf_ID.  Thus
			;the buffer starts at location
			;buf_offset in the file and contains
			;buf_fill bytes.

bufinsiz	equ	buffinfo.size ; ; Size of structure in bytes


buf_Free	equ	0FFh		; buf_id of free buffer

;Flag byte masks
buf_isnet	EQU	10000000B
buf_dirty	EQU	01000000B
;***
buf_visit	EQU	00100000B
;***
buf_snbuf	EQU	00010000B

buf_isDATA	EQU	00001000B
buf_isDIR	EQU	00000100B
buf_isFAT	EQU	00000010B
buf_type_0	EQU	11110001B	; AND sets type to "none"

buf_NetID	EQU	bufinsiz

; ----------------------------------------------------------------------

; ----------------------------------------------------------------------
;**	DPB - Drive Parameter Block

; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DPB.INC, 1991)

;	BUGBUG - this isn't authorative - it's my probably incomplete and
;	possibly inaccurate deductions from code study... - jgl
;
;	The DPB is DOS's main structure for describing block devices.
;	It contains info about the "Drive" intermingled with info about
;	the FAT file system which is presumably on the drive.  I don't know
;	how those fields are used if it's not the FAT file system - BUGBUG
;
;	The DPBs are statically allocated and chained off of DPBHead.
;	Users scan this chain looking for a match on DPB_DRIVE.
;	The DPBs are built at init time from info in the SYSDEV structure.

; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3, DPB.INC, 24/07/1987)

; 12/05/2019 - Retro DOS v4.0

struc	DPB
.DRIVE:		resb 1		; Logical drive # assoc with DPB (A=0,B=1,...)
.UNIT:		resb 1		; Driver unit number of DPB
.SECTOR_SIZE:	resw 1		; Size of physical sector in bytes
.CLUSTER_MASK:	resb 1		; Sectors/cluster - 1
.CLUSTER_SHIFT:	resb 1		; Log2 of sectors/cluster
.FIRST_FAT:	resw 1		; Starting record of FATs
.FAT_COUNT:	resb 1		; Number of FATs for this drive
.ROOT_ENTRIES:	resw 1		; Number of directory entries
.FIRST_SECTOR:	resw 1		; First sector of first cluster
.MAX_CLUSTER:	resw 1		; Number of clusters on drive + 1
;.FAT_SIZE:	resb 1  ; MSDOS 3.3
.FAT_SIZE:	resw 1		; Number of records occupied by FAT
.DIR_SECTOR:	resw 1		; Starting record of directory
.DRIVER_ADDR:	resd 1		; Pointer to driver
.MEDIA:		resb 1		; Media byte
.FIRST_ACCESS:	resb 1		; This is initialized to -1 to force a media
				; check the first time this DPB is used
.NEXT_DPB:	resd 1		; Pointer to next Drive parameter block
.NEXT_FREE:	resw 1		; Cluster # of last allocated cluster
.FREE_CNT:	resw 1		; Count of free clusters, -1 if unknown
.size:
endstruc

DPBSIZ  EQU     DPB.size	; Size of the structure in bytes

DSKSIZ  EQU	DPB.MAX_CLUSTER	; Size of disk (temp used during init only)

; ----------------------------------------------------------------------
; 26/03/2018

; IOCTL SUB-FUNCTIONS
IOCTL_GET_DEVICE_INFO	EQU	0
IOCTL_SET_DEVICE_INFO	EQU	1
IOCTL_READ_HANDLE	EQU	2
IOCTL_WRITE_HANDLE	EQU	3
IOCTL_READ_DRIVE	EQU	4
IOCTL_WRITE_DRIVE	EQU	5
IOCTL_GET_INPUT_STATUS	EQU	6
IOCTL_GET_OUTPUT_STATUS EQU	7
IOCTL_CHANGEABLE?	EQU	8
IOCTL_SHARING_RETRY	EQU	11
GENERIC_IOCTL_HANDLE	EQU	12
GENERIC_IOCTL		EQU	13

; GENERIC IOCTL SUB-FUNCTIONS
RAWIO			EQU	8

; RAWIO SUB-FUNCTIONS
GET_DEVICE_PARAMETERS	EQU	60H
SET_DEVICE_PARAMETERS	EQU	40H
READ_TRACK		EQU	61H
WRITE_TRACK		EQU	41H
VERIFY_TRACK		EQU	62H
FORMAT_TRACK		EQU	42H

; DEVICETYPE VALUES
MAX_SECTORS_IN_TRACK	EQU	63
DEV_5INCH		EQU	0
DEV_5INCH96TPI		EQU	1
DEV_3INCH720KB		EQU	2
DEV_8INCHSS		EQU	3
DEV_8INCHDS		EQU	4
DEV_HARDDISK		EQU	5
DEV_OTHER		EQU	7
;DEV_3INCH1440KB	EQU	7
DEV_3INCH2880KB		EQU	9
; Retro DOS v2.0 - 26/03/2018
;;DEV_TAPE		EQU	6
;;DEV_ERIMO		EQU	8
;DEV_3INCH2880KB	EQU	9
DEV_3INCH1440KB		EQU	10

;MAX_DEV_TYPE		EQU	9	; MAXIMUM DEVICE TYPE THAT WE
					; CURRENTLY SUPPORT.
MAX_DEV_TYPE		EQU	10

struc A_SECTORTABLE
.ST_SECTORNUMBER:	resw	1
.ST_SECTORSIZE:		resw	1
.size:
endstruc

; 25/03/2019 - Retro DOS v4.0  (MSDOS 6.0, BPB.INC, IOCTL.INC)

;**	BIOS PARAMETER BLOCK DEFINITION
;
;	The BPB contains information about the disk structure.  It dates
;	back to the earliest FAT systems and so FAT information is
;	intermingled with physical driver information.
;
;	A boot sector contains a BPB for its device; for other disks
;	the driver creates a BPB.  DOS keeps copies of some of this
;	information in the DPB.
;
;	The BDS structure contains a BPB within it.

struc A_BPB
.BPB_BYTESPERSECTOR:	resw	1
.BPB_SECTORSPERCLUSTER:	resb	1
.BPB_RESERVEDSECTORS:	resw	1
.BPB_NUMBEROFFATS:	resb	1
.BPB_ROOTENTRIES: 	resw	1
.BPB_TOTALSECTORS:	resw	1
.BPB_MEDIADESCRIPTOR:	resb	1
.BPB_SECTORSPERFAT:	resw	1
.BPB_SECTORSPERTRACK:	resw	1
.BPB_HEADS:		resw	1
.BPB_HIDDENSECTORS:	resw	1
			resw	1
.BPB_BIGTOTALSECTORS:	resw	1
			resw	1
			resb	6	; NOTE:  many times these
;					; 	 6 bytes are omitted
;					;	 when BPB manipulations
;					;	 are performed!
.size:
endstruc

struc A_DEVICEPARAMETERS
.DP_SPECIALFUNCTIONS:	resb	1
.DP_DEVICETYPE:		resb	1
.DP_DEVICEATTRIBUTES:	resw	1
.DP_CYLINDERS:		resw	1
.DP_MEDIATYPE:		resb	1
.DP_BPB:		resb	A_BPB.size
.DP_TRACKTABLEENTRIES:	resw	1
.DP_SECTORTABLE:	resb	MAX_SECTORS_IN_TRACK * A_SECTORTABLE.size
endstruc

; ----------------------------------------------------------------------
; structure, equates for devmark for mem command.

; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.0, DEVMARK.INC, 1991)

struc devmark
 .id:	    resb 1
 .seg:	    resw 1
 .size:	    resw 1
 .dum:	    resb 3
 .filename: resb 8
endstruc

devmark_stk	equ	'S'
devmark_device	equ	'D'
devmark_ifs	equ	'I'
devmark_buf	equ	'B'
devmark_cds	equ	'L' ; lastdrive
devmark_files	equ	'F'
devmark_fcbs	equ	'X'
devmark_inst	equ	'T' ; used for sysinit base for install= command.
devmark_ems_stub equ	'E'

setbrkdone	equ	00000001b
for_devmark	equ	00000010b
not_for_devmark equ	11111101b

; ----------------------------------------------------------------------
; Memory arena structure

; 24/03/2019 - Retro DOS v4.0 
; (MSDOS 6.0, ARENA.INC)

;** Arena Header

struc ARENA
.SIGNATURE:	resb 1		; 4D for valid item, 5A for last item
.OWNER:		resw 1		; owner of arena item
.SIZE:		resw 1		; size in paragraphs of item
.RESERVED	resb 3		; reserved
.NAME:		resb 8		; owner file name
endstruc

; 12/04/2019

arena_owner_system	EQU 0	; free block indication

arena_signature_normal	EQU 4Dh ; valid signature, not end of arena
arena_signature_end	EQU 5Ah ; valid signature, last block in arena

; ----------------------------------------------------------------------
; Process data block (otherwise known as program header)

; 23/03/2019 - Retro DOS v4.0

; (MSDOS 6.0 - PDB.INC, 1991)

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
.ENVIRON:	resw 1		; seg addr of environment
.USER_STACK:	resd 1		; stack of self during system calls
.JFN_LENGTH:	resw 1 		; number of handles allowed
.JFN_POINTER:	resd 1 		; pointer to JFN table
.NEXT_PDB:	resd 1		; pointer to nested PDB's
.INTERCON:	resb 1 		; *** jh-3/28/90 ***
.APPEND:	resb 1		; *** Not sure if still used ***
.NOVELL_USED:	resb 2		; Novell shell (redir) uses these
.VERSION:	resw 1		; DOS version reported to this app
.PAD1:		resb 14		; 	
.CALL_SYSTEM:	resb 5		; portable method of system call
.PAD2:		resb 7 		; reserved so FCB 1 can be used as an extended FCB
.FCB1:		resb 16		; default FCB 1
.FCB2:		resb 16		; default FCB 2
.PAD3:		resb 4		; not sure if this is used by PDB_FCB2
.TAIL:		resb 128	; command tail and default DTA
;.size:
endstruc

; ----------------------------------------------------------------------
; <system call definitions>

; 23/03/2019 - Retro DOS v4.0

; (MSDOS 6.0 - SYSCALL.INC, 1991)

ABORT                           EQU 0   ;  0      0
STD_CON_INPUT                   EQU 1   ;  1      1
STD_CON_OUTPUT                  EQU 2   ;  2      2
STD_AUX_INPUT                   EQU 3   ;  3      3
STD_AUX_OUTPUT                  EQU 4   ;  4      4
STD_PRINTER_OUTPUT              EQU 5   ;  5      5
RAW_CON_IO                      EQU 6   ;  6      6
RAW_CON_INPUT                   EQU 7   ;  7      7
STD_CON_INPUT_NO_ECHO           EQU 8   ;  8      8
STD_CON_STRING_OUTPUT           EQU 9   ;  9      9
STD_CON_STRING_INPUT            EQU 10  ; 10      A
STD_CON_INPUT_STATUS            EQU 11  ; 11      B
STD_CON_INPUT_FLUSH             EQU 12  ; 12      C
DISK_RESET                      EQU 13  ; 13      D
SET_DEFAULT_DRIVE               EQU 14  ; 14      E
FCB_OPEN                        EQU 15  ; 15      F
FCB_CLOSE                       EQU 16  ; 16     10
DIR_SEARCH_FIRST                EQU 17  ; 17     11
DIR_SEARCH_NEXT                 EQU 18  ; 18     12
FCB_DELETE                      EQU 19  ; 19     13
FCB_SEQ_READ                    EQU 20  ; 20     14
FCB_SEQ_WRITE                   EQU 21  ; 21     15
FCB_CREATE                      EQU 22  ; 22     16
FCB_RENAME                      EQU 23  ; 23     17
GET_DEFAULT_DRIVE               EQU 25  ; 25     19
SET_DMA                         EQU 26  ; 26     1A
GET_DEFAULT_DPB                 EQU 31  ; 31     1F
FCB_RANDOM_READ                 EQU 33  ; 33     21
FCB_RANDOM_WRITE                EQU 34  ; 34     22
GET_FCB_FILE_LENGTH             EQU 35  ; 35     23
GET_FCB_POSITION                EQU 36  ; 36     24
SET_INTERRUPT_VECTOR            EQU 37  ; 37     25
CREATE_PROCESS_DATA_BLOCK       EQU 38  ; 38     26
FCB_RANDOM_READ_BLOCK           EQU 39  ; 39     27
FCB_RANDOM_WRITE_BLOCK          EQU 40  ; 40     28
PARSE_FILE_DESCRIPTOR           EQU 41  ; 41     29
GET_DATE                        EQU 42  ; 42     2A
SET_DATE                        EQU 43  ; 43     2B
GET_TIME                        EQU 44  ; 44     2C
SET_TIME                        EQU 45  ; 45     2D
SET_VERIFY_ON_WRITE             EQU 46  ; 46     2E
; Extended functionality group
GET_DMA                         EQU 47  ; 47     2F
GET_VERSION                     EQU 48  ; 48     30
KEEP_PROCESS                    EQU 49  ; 49     31
GET_DPB                         EQU 50  ; 50     32
SET_CTRL_C_TRAPPING             EQU 51  ; 51     33
GET_INDOS_FLAG                  EQU 52  ; 52     34
GET_INTERRUPT_VECTOR            EQU 53  ; 53     35
GET_DRIVE_FREESPACE             EQU 54  ; 54     36
CHAR_OPER                       EQU 55  ; 55     37
INTERNATIONAL                   EQU 56  ; 56     38
;   Directory Group
MKDIR                           EQU 57  ; 57     39
RMDIR                           EQU 58  ; 58     3A
CHDIR                           EQU 59  ; 59     3B
;   File Group
CREAT                           EQU 60  ; 60     3C
OPEN                            EQU 61  ; 61     3D
CLOSE                           EQU 62  ; 62     3E
READ                            EQU 63  ; 63     3F
WRITE                           EQU 64  ; 64     40
UNLINK                          EQU 65  ; 65     41
LSEEK                           EQU 66  ; 66     42
CHMOD                           EQU 67  ; 67     43
IOCTL                           EQU 68  ; 68     44
XDUP                            EQU 69  ; 69     45
XDUP2                           EQU 70  ; 70     46
CURRENT_DIR                     EQU 71  ; 71     47
;    Memory Group
ALLOC                           EQU 72  ; 72     48
DEALLOC                         EQU 73  ; 73     49
SETBLOCK                        EQU 74  ; 74     4A
;    Process Group
EXEC                            EQU 75  ; 75     4B
EXIT                            EQU 76  ; 76     4C
WAITPROCESS			EQU 77  ; 77     4D
FIND_FIRST                      EQU 78  ; 78     4E
;   Special Group
FIND_NEXT                       EQU 79  ; 79     4F
; SPECIAL SYSTEM GROUP
SET_CURRENT_PDB                 EQU 80  ; 80     50
GET_CURRENT_PDB                 EQU 81  ; 81     51
GET_IN_VARS                     EQU 82  ; 82     52
SETDPB                          EQU 83  ; 83     53
GET_VERIFY_ON_WRITE             EQU 84  ; 84     54
DUP_PDB                         EQU 85  ; 85     55
RENAME                          EQU 86  ; 86     56
FILE_TIMES                      EQU 87  ; 87     57
;
ALLOCOPER			EQU 88	; 88     58	
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
Set_Printer_Flag		EQU 100 ; 100	 64
GetExtCntry			EQU 101 ; 101	 65
GetSetCdPg			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;
;ifdef ROMEXEC
;ROM_FIND_FIRST			EQU 109 ; 109    6D
;ROM_FIND_NEXT			EQU 110 ; 110    6E
;ROM_EXCLUDE			EQU 111 ; 111	 6F
;endif
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

; ----------------------------------------------------------------------
; SYSCONF.ASM (MSDOS 3.3 - 24/07/1987) 	
; ----------------------------------------------------------------------

;;	IF	STACKSW

;;
;; Internal Stack Parameters
;EntrySize		equ	8
;
;MinCount		equ	8
;DefaultCount		equ	9
;MaxCount		equ	64
;
;MinSize 		equ	32
;DefaultSize		equ	128
;MaxSize 		equ	512

;;	ENDIF

; ----------------------------------------------------------------------
; BIOSTRUC.INC (MSDOS 3.3 - 24/07/1987) 	
; ----------------------------------------------------------------------
					  ;;Rev 3.30 Modification
; ROM BIOS CALL PACKET STRUCTURES					  
									  
;*******************************					  
;System Service call ( Int 15h )					  
;*******************************					  
;Function AH = 0C0h, Return system configuration			  
;For PC and PCJR on return:						  
;	(AH)	= 80h							  
;	(CY)	= 1							  
;For PCXT, PC PORTABLE and PCAT on return:				  
;	(AH)	= 86h							  
;	(CY)	= 1							  
;For all others:							  
;	(AH)	= 0							  
;	(CY)	= 0							  
;	(ES:BX) = pointer to system descriptor vector in ROS		  
; System descriptor :							  
;	DW	xxxx		length of descriptor in bytes,		  
;				minimum length = 8			  
;	DB	xx		model byte				  
;				0FFh	= PC				  
;				0FEh	= PC/XT, Portable		  
;				0FDh	= PC/JR 			  
;				0FCh	= PC/AT				  
;				0F9h	= Convertable			  
;				0F8h	= Model 80			  
;				0E0 thru 0EFh = reserved		  
;									  
;	DB	xx		secondary model byte			  
;				000h	= PC1				  
;				000h	= PC/XT, Portable		  
;				000h	= PC/JR 			  
;				000h	= PC/AT 			  
;				001h	= PC/AT Model 339		  
;				003h	= PC/RT				  
;				000h	= Convertable			  
;									  
;	DB	xx		bios revision level			  
;				00 for first release, subsequent release  
;				of code with same model byte and	  
;				secondary model byte require revison level
;				to increase by one.			  
;									  
;	DB	xx		feature information byte 1		  
;				X0000000 = 1, bios use DMA channel 3	  
;					 = 0, DMA channel 3 not used	  
;									  
;				0X000000 = 1, 2nd Interrupt chip present  
;					 = 0, 2nd Interrupt chip not present
;									  
;				00X00000 = 1, Real Time Clock present	  
;					 = 0, Real Time Clock not present 
;									  
;				000X0000 = 1, Keyboard escape sequence(INT 15h)
;						called in keyboard interrupt
;						(Int 09h).		  
;					 = 0, Keyboard escape sequence not
;						called. 		  
;				0000XXXX reserved			  
;									  
;	DB	xx		feature information byte 2 - reserved	  
;									  
;	DB	xx		feature information byte 2 - reserved	  
;									  
;	DB	xx		feature information byte 2 - reserved	  
;									  
;	DB	xx		feature information byte 2 - reserved	  
;									  

; 22/03/2019									  
struc ROMBIOS_DESC		; BIOS_SYSTEM_DESCRIPTOR						  
.bios_sd_leng:		resw 1				  
.bios_sd_modelbyte:	resb 1					  
.bios_sd_scnd_modelbyte: 
			resb 1					  
			resb 1					  
.bios_sd_featurebyte1:	resb 1					  
			resb 4					  
endstruc					  
									  
;FeatureByte1	bit map equates 					  
DMAchannel3		equ 10000000b					  
ScndIntController	equ 01000000b					  
RealTimeClock		equ 00100000b					  
KeyEscapeSeq		equ 00010000b					  
					;;End of Modification

; ----------------------------------------------------------------------
; SYSVAR.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 22/03/2019 - Retro DOS v4.0

;	SCCSID = @(#)sysvar.asm 1.1 85/04/10

struc SysInitVars
; MSDOS 3.3
.SYSI_DPB:    resd 1			; DPB chain
.SYSI_SFT:    resd 1			; SFT chain
.SYSI_CLOCK:  resd 1			; CLOCK device
.SYSI_CON:    resd 1			; CON device
.SYSI_MAXSEC: resw 1			; maximum sector size
.SYSI_BUF:    resd 1			; buffer chain
.SYSI_CDS:    resd 1			; CDS list
.SYSI_FCB:    resd 1			; FCB chain
.SYSI_KEEP:   resw 1			; keep count
.SYSI_NUMIO:  resb 1			; number of block devices
.SYSI_NCDS:   resb 1			; number of CDS's
.SYSI_DEV:    resd 1			; device list
; MSDOS 6.0
.SYSI_ATTR:	    resw 1		; null device attribute word
.SYSI_STRAT:	    resw 1		; null device strategy entry point
.SYSI_INTER:	    resw 1		; null device interrupt entry point
.SYSI_NAME:	    resb 8		; null device name
.SYSI_SPLICE:	    resb 0		; TRUE -> splicees being done
.SYSI_IBMDOS_SIZE:  resw 1		; DOS size in paragraphs
.SYSI_IFS_DOSCALL@: resd 1		; IFS DOS service rountine entry
.SYSI_IFS:	    resd 1	 	; IFS header chain
.SYSI_BUFFERS:	    resw 2		; BUFFERS= values (m,n)
.SYSI_BOOT_DRIVE:   resb 1		; boot drive A=1 B=2,..
.SYSI_DWMOVE:	    resb 1		; 1 if 386 machine
.SYSI_EXT_MEM:	    resw 1		; Extended memory size in KB.
.size:
endstruc

;This is added for more information exchage between DOS, BIOS.
;DOS will give the pointer to SysInitTable in ES:DI. - J.K. 5/29/86

; 22/03/2019
struc SysInitVars_Ext
.SYSI_InitVars:	   resd 1	; Points to the above structure.
.SYSI_Country_Tab: resd 1	; DOS_Country_cdpg_info
endstruc

; 09/06/2018
; 08/06/2018 - Retro DOS v3.0 (MSDOS 3.3)
SYSI_DPB    equ	0
SYSI_SFT    equ 4
SYSI_CLOCK  equ 8
SYSI_CON    equ 12
SYSI_MAXSEC equ 16
SYSI_BUF    equ 18 		
SYSI_CDS    equ 22
SYSI_FCB    equ 26
SYSI_KEEP   equ 30
SYSI_NUMIO  equ	32
SYSI_NCDS   equ	33
SYSI_DEV    equ 34
; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0)
SYSI_ATTR	  equ 38
SYSI_STRAT	  equ 40
SYSI_INTER	  equ 42
SYSI_NAME	  equ 44
SYSI_SPLICE	  equ 52
SYSI_IBMDOS_SIZE  equ 53
SYSI_IFS_DOSCALL@ equ 55
SYSI_IFS	  equ 59
SYSI_BUFFERS	  equ 63
SYSI_BOOT_DRIVE   equ 67
SYSI_DWMOVE	  equ 68
SYSI_EXT_MEM	  equ 69

;The SYSI_BUF of SysInitVars points to the following structure

EMS_MAP_BUFF_SIZE EQU 12	; EMS map buffer size

struc BUFFINF 	; BUFFINFO
.Buff_Queue:	   resd	1	; Head of list of buffers
.Dirty_Buff_Count: resw 1	; number of dirty buffers in list
.Cache_ptr:	   resd 1	; pointer to secondary cache
.Cache_count:      resw 1	; number of secondary cache entries

.Buff_In_HMA:	   resb 1	; flag to indicate that buffers
				; are in HMA
.Lo_Mem_Buff:	   resd 1	; Ptr to scratch buff in Low Mem
				;  used to read/write on disks
.UU_EMS_FIRST_PAGE:	resw 2
.UU_EMS_NPA640:		resw 1
.UU_EMS_mode:		resb 1	 ; no EMS = -1
.UU_EMS_handle:		resw 1	 ; EMS handle for buffers
.UU_EMS_PageFrame_Number: resw 1 ; EMS page frame number
.UU_EMS_Seg_Cnt:	resw 1	 ; EMS segment count
.UU_EMS_Page_Frame:	resw 1	 ; EMS page frame segment address
.UU_EMS_reserved:	resw 1	 ; EMS segment count
.UU_EMS_Map_Buff:	resb 1	 ; map buffer
.size:
endstruc

; ----------------------------------------------------------------------
; CURDIR.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 22/03/2019 - Retro DOS v4.0

;**	CDS - Current Directory Structure
;
; CDS items are used bu the internal routines to store cluster numbers and
; network identifiers for each logical name.  The ID field is used dually,
; both as net ID and for a cluster number for local devices. In the case
; of local devices, the cluster number will be -1 if there is a potential
; of the disk being changed or if the path must be recracked.
;
;	Some pathnames have special preambles, such as
;
;		\\machine\sharename\...
;	For these pathnames we can't allow ".." processing to back us
;	up into the special front part of the name.  The CURDIR_END field
;	holds the address of the seperator character which marks
;	the split between the special preamble and the regular
;	path list; ".." processing isn't allowed to back us up past
;	(i.e., before) CURDIR_END
;	For the root, it points at the leading /. For net
;	assignments it points at the end (nul) of the initial assignment:
;	A:/	\\foo\bar	    \\foo\bar\blech\bozo
;	  ^		 ^		     ^

DIRSTRLEN	EQU	64+3		; Max length in bytes of directory strings
TEMPLEN 	EQU	DIRSTRLEN*2

struc 		curdir_list
; MSDOS 3.3
.cdir_text	resb	DIRSTRLEN	; text of assignment and curdir
.cdir_flags	resw	1		; various flags
.cdir_devptr	resd	1		; local pointer to DPB or net device
.cdir_ID	resw	2		; cluster of current dir (net ID)
.cdir_usr_word	resw	1
.cdir_end	resw	1		; end of assignment
; MSDOS 6.0
.cdir_type:	resb	1		; IFS drive (2=ifs, 4=netuse)
.cdir_ifd_hdr:	resd	1		; Ptr to File System Header
.cdir_fsda:	resb	2		; File System Dependent Data Area
.size:
endstruc

curdirlen	EQU	curdir_list.size	; Needed for screwed up
						; ASM87 which doesn't allow
						; Size directive as a macro
						; argument
%define curdir_netID	dword [curdir_list.cdir_ID]

;**	Flag values for CURDIR_FLAGS

;Flag word masks
curdir_isnet	EQU	1000000000000000B
curdir_isifs	EQU	1000000000000000B
curdir_inuse	EQU	0100000000000000B
curdir_splice	EQU	0010000000000000B
curdir_local	EQU	0001000000000000B

; ----------------------------------------------------------------------
; SF.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 25/03/2019 - Retro DOS v4.0

; system file table

;**	System File Table SuperStructure
;
;	The system file table entries are allocated in contiguous groups.
;	There may be more than one such groups; the SF "superstructure"
;	tracks the groups.

struc	SF
.SFLink:	resd	1
.SFCount:	resw	1		; number of entries
.SFTable:	resw	1		; beginning of array of the following
.size:
endstruc

;**	System file table entry
;
;	These are the structures which are at SFTABLE in the SF structure.

struc	SF_ENTRY
.sf_ref_count:	resw	1		; number of processes sharing entry
					;   if FCB then ref count
.sf_mode: 	resw	1		; mode of access or high bit on if FCB
.sf_attr: 	resb	1		; attribute of file
.sf_flags:	resw	1		;Bits 8-15
					; Bit 15 = 1 if remote file
					;	 = 0 if local file or device
					; Bit 14 = 1 if date/time is not to be
					;   set from clock at CLOSE.  Set by
					;   FILETIMES and FCB_CLOSE.  Reset by
					;   other reseters of the dirty bit
					;   (WRITE)
					; Bit 13 = Pipe bit (reserved)
					;
					; Bits 0-7 (old FCB_devid bits)
					; If remote file or local file, bit
					; 6=0 if dirty Device ID number, bits
					; 0-5 if local file.
					; bit 7=0 for local file, bit 7
					;      =1 for local I/O device
					; If local I/O device, bit 6=0 if EOF (input)
					;		Bit 5=1 if Raw mode
					;		Bit 0=1 if console input device
					;		Bit 1=1 if console output device
					;		Bit 2=1 if null device
					;		Bit 3=1 if clock device
.sf_devptr:	resd	1		; Points to DPB if local file, points
					; to device header if local device,
					; points to net device header if
					; remote
.sf_firclus:	resw	1		; First cluster of file (bit 15 = 0)
;.sf_lstclus:	resw	1 ; *	
.sf_time: 	resw	1		; Time associated with file
.sf_date: 	resw	1		; Date associated with file
.sf_size: 	resd	1		; Size associated with file
.sf_position:	resd	1		; Read/Write pointer or LRU count for FCBs
;
; Starting here, the next 7 bytes may be used by the file system to store an
; ID
;
.sf_cluspos:	resw	1		; Position of last cluster accessed
.sf_dirsec:	resw	1		; Sector number of directory sector for this file
.sf_dirpos:	resb	1		; Offset of this entry in the above
;
; End of 7 bytes of file-system specific info.
;
.sf_name:	resb	11		; 11 character name that is in the
					; directory entry.  This is used by
					; close to detect file deleted and
					; disk changed errors.
; SHARING INFO
.sf_chain:	resd	1		; link to next SF
.sf_UID:	resw	1
.sf_PID:	resw	1
.sf_MFT:	resw	1
.sf_lstclus:	resw	1 ; *		; Last cluster accessed
.sf_IFS_HDR:	resd 	1 ; **
.size:
endstruc

; ----------------------------------------------------------------------
; DOSCNTRY.INC (MSDOS 3.3 - 24/07/1987) 	
; ----------------------------------------------------------------------
; 11/06/2018 - Retro DOS v3.0

;Equates for COUNTRY INFORMATION.
SetCountryInfo		EQU	1	;country info
SetUcase		EQU	2	;uppercase table
SetLcase		EQU	3	;lowercase table (Reserved)
SetUcaseFile		EQU	4	;uppercase file spec table
SetFileList		EQU	5	;valid file character list
SetCollate		EQU	6	;collating sequence
SetDBCS 		EQU	7	;double byte character set
SetALL			EQU	-1	;all the entries

;DOS country and code page information table structure.
;Internally, IBMDOS gives a pointer to this table.
;IBMBIO, MODE and NLSFUNC modules communicate with IBMDOS through
;this structure.

struc country_cdpg_info ; DOS_country_cdpg_info
.ccInfo_reserved :	resb	8	;reserved for internal use
.ccPath_CountrySys:	resb	64	;path and filename for country info
.ccSysCodePage:		resw	1	;system code page id
.ccNumber_of_entries:	resw	1 ; dw 5
.ccSetUcase:		resb	1 ; db SetUcase ; = 2
.ccUcase_ptr:		resd	1	;pointer to Ucase table

.ccSetUcaseFile:	resb	1 ; db SetUcaseFile ; = 4
.ccFileUcase_ptr: 	resd	1	;pointer to File Ucase table

.ccSetFileList:		resb	1 ; db SetFileList ; = 5
.ccFileChar_ptr:	resd	1	;pointer to File char list table

.ccSetCollate:		resb	1 ; db SetCollate ; = 6
.ccCollate_ptr:		resd	1	;pointer to collate table

.ccSetCountryInfo:	resb	1 ; db SetCountryInfo ; = 1
.ccCountryInfoLen:	resw	1	;length of country info
.ccDosCountry:		resw	1	;system country code id
.ccDosCodePage:		resw	1	;system code page id
.ccDFormat:		resw	1	;date format
.ccCurSymbol:		resb	5 ; db "    ",0
					;5 byte of (currency symbol+0)
.cc1000Sep:		resb	2 ; db " ",0 ;2 byte of (1000 sep. + 0)
.ccDecSep:		resb	2 ; db " ",0 ;2 byte of (Decimal sep. + 0)
.ccDateSep:		resb	2 ; db " ",0 ;2 byte of (date sep. + 0)
.ccTimeSep:		resb 	2 ; db " ",0 ;2 byte of (time sep. + 0)
.ccCFormat:		resb	1 	;currency format flags
.ccCSigDigits:		resb	1	;# of digits in currency
.ccTFormat:		resb	1	;time format
.ccMono_Ptr:		resd	1	;monocase routine entry point
.ccListSep:		resb	2 ; db " ",0 ;data list separator
.ccReserved_area: 	resw	5 ; dw 5 dup(?) ;reserved
.size:
endstruc

NEW_COUNTRY_SIZE    equ  country_cdpg_info.size - country_cdpg_info.ccDosCountry

; ======================================================================
; retrodos4.s (offset addresses in MSDOS.SYS or RETRODOS.SYS)
; ======================================================================
; 21/03/2019 - Retro DOS v4.0
; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)

;KERNEL_SEGMENT	equ 0070h  ; (IO.SYS loading segment, BIOS_DATA segment)
; 21/10/2022
DOSBIODATASEG equ 0070h	; (IO.SYS loading segment, BIOS_DATA segment)
; 22/10/2022
;DOSBIOCODESEG equ 02C7h ; (MSDOS 5.0 IO.SYS, BIOS_CODE segment)
; 09/12/2022
DOSBIOCODESEG equ IOSYSCODESEG

; Note: These offset addresses must be chanqed when the code 
; 	in retrodos4.s (MSDOS.SYS) file will be changed.

; (following addresses can be verified by searching them in retrodos4.lst) 

; 09/12/2022
%if 0

; 13/05/2019

;IsWin386         equ 08CFh
;V86_Crit_SetFocus equ 08D0h
; 21/10/2022
IsWin386          equ 08D0h
V86_Crit_SetFocus equ 08D1h 

;seg_reinit	  equ 0772h ; not used in Retro DOS v4.0
; 21/10/2022 - Retro DOS v4.0 (MOdified MSDOS 5.0 IO.SYS)
seg_reinit	  equ 0032h ; DOSBIOCODESEG:0032h

;SysinitPresent	  equ 08FCh
; 21/10/2022
SysinitPresent	  equ 08FDh

inHMA		  equ 000Dh
xms		  equ 000Eh
;FreeHMAPtr	  equ 08F6h
;multrk_flag	  equ 0533h
;ec35_flag	  equ 0535h
;EOT		  equ 012Eh
; 21/10/2022
FreeHMAPtr	  equ 08F7h
multrk_flag	  equ 052Fh
ec35_flag	  equ 0531h
EOT		  equ 012Ch

;NextStack	  equ 08BFh
;IT_StackLoc	  equ 08C5h
;IT_StackSize	  equ 08C9h
; 21/10/2022
NextStack	  equ 08C0h
IT_StackLoc	  equ 08C6h
IT_StackSize	  equ 08CAh

;MoveDOSIntoHMA	  equ 08F8h
; 21/10/2022
MoveDOSIntoHMA	  equ 08F9h

;INT19SEM equ 0644h ; 01/05/2019 - retrodos4.lst
;I19_LST  equ 0645h ; 27/03/2019 - retrodos4.lst
; 21/10/2022
INT19SEM equ 0640h ; (iosys5.txt)
I19_LST  equ 0641h ; (iosys5.txt)

%endif

; 09/12/2022
seg_reinit equ _seg_reinit
ec35_flag  equ ec35flag		
INT19SEM   equ int19sem
I19_LST    equ i19_lst

INT19OLD02 equ I19_LST+1 ; 0642h ; 21/10/2022
INT19OLD08 equ I19_LST+6
INT19OLD09 equ I19_LST+11
INT19OLD0A equ I19_LST+16
INT19OLD0B equ I19_LST+21
INT19OLD0C equ I19_LST+26
INT19OLD0D equ I19_LST+31
INT19OLD0E equ I19_LST+36
INT19OLD70 equ I19_LST+41
INT19OLD72 equ I19_LST+46
INT19OLD73 equ I19_LST+51
INT19OLD74 equ I19_LST+56
INT19OLD76 equ I19_LST+61
INT19OLD77 equ I19_LST+66 ; 0683h ; 21/10/2022

; 09/12/2022
%if 0

;keyrd_func	equ 04E9h
;keysts_func	equ 04EAh
;t_switch	equ 04F6h
; 21/10/2022
keyrd_func	equ 04E5h
keysts_func	equ 04E6h
t_switch	equ 04F2h

; 22/10/2022
SYSINITSEG	equ 046Dh  ; SYSINIT segment
BCODE_END	equ (SYSINITSEG-DOSBIOCODESEG)*16 ; = 1A60h
BCODE_START	equ 30h  ; (offset BiosDataWord in DOSBIOCODESEG) 
RE_INIT		equ 089Bh ; (re_init offset in DOSBIODATASEG)

%endif

; 09/12/2022
BCODESTART	equ BIOSDATAWORD
RE_INIT		equ re_init

; ----------------------------------------------------------------------
; CONFIG.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 15/04/2019 - Retro DOS v4.0

CONFIG_BEGIN        equ  '['
CONFIG_BREAK        equ  'C'
CONFIG_BUFFERS      equ  'B'
CONFIG_COMMENT      equ  'Y'
CONFIG_COUNTRY      equ  'Q'
CONFIG_DEVICE       equ  'D'
CONFIG_DEVICEHIGH   equ  'U'
CONFIG_DOS          equ  'H'
CONFIG_DRIVPARM     equ  'P'
CONFIG_FCBS         equ  'X'
CONFIG_FILES        equ  'F'
CONFIG_INCLUDE      equ  'J'
CONFIG_INSTALL      equ  'I'
CONFIG_INSTALLHIGH  equ  'W'
CONFIG_LASTDRIVE    equ  'L'
CONFIG_MENUCOLOR    equ  'R'
CONFIG_MENUDEFAULT  equ  'A'
CONFIG_MENUITEM     equ  'E'
CONFIG_MULTITRACK   equ  'M'
CONFIG_NUMLOCK      equ  'N'
CONFIG_REM          equ  '0'
CONFIG_SEMICOLON    equ  ';'
CONFIG_SET          equ  'V'
CONFIG_SHELL        equ  'S'
CONFIG_STACKS       equ  'K'
CONFIG_SUBMENU      equ  'O'
CONFIG_SWITCHES     equ  '1'

CONFIG_UNKNOWN      equ  'Z'

CONFIG_OPTION_QUERY equ 80h

; ----------------------------------------------------------------------
; SYSINIT1.ASM (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 21/03/2019 - Retro DOS v4.0

true	equ	0FFFFh
false	equ	0
cr	equ	13
lf	equ	10
tab	equ	9

multMULT	   equ	4Ah
multMULTGETHMAPTR  equ	1
multMULTALLOCHMA   equ	2

;NOEXEC    equ	FALSE

stacksw    equ	true	;include switchable hardware stacks
mycds_size equ	88	;size of curdir_list. if it is not
			;the same, then will generate compile error.

entrysize   equ     8

mincount    equ     8
defaultcount equ    9
maxcount    equ     64

minsize     equ     32
defaultsize equ     128
maxsize     equ     512

;%define allocbyte  byte [es:bp+0]
;%define intlevel   byte [es:bp+1]
;%define savedsp    word [es:bp+2]
;%define savedss    word [es:bp+4]
;%define newsp	    word [es:bp+6]

allocbyte   equ     0
intlevel    equ     1
savedsp     equ     2
savedss     equ     4
newsp       equ     6

free	    equ     0
allocated   equ     1
overflowed  equ     2
clobbered   equ     3

;---------------------------------------
; external variable defined in ibmbio module for multi-track

multrk_on equ	10000000b ;user specified mutitrack=on,or system turns
			  ; it on after handling config.sys file as a
			  ; default value,if multrk_flag = multrk_off1.
multrk_off1 equ 00000000b ;initial value. no "multitrack=" command entered.
multrk_off2 equ 00000001b ;user specified multitrack=off.

; SYSINITSEG	SEGMENT PUBLIC 'SYSTEM_INIT'

SYSINIT$:
	;IF	STACKSW 
	; include MSSTACK.INC	;Main stack program and data definitions
	; include STKMES.INC	;Fatal stack error message
	;   public Endstackcode
;Endstackcode	label byte
	;ENDIF

; 05/07/2018
; ----------------------------------------------------------------------
; 04/06/2018 - Retro DOS v3.0

; ----------------------------------------------------------------------
; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS - SYSINIT)
; ----------------------------------------------------------------------

;	MSStack.inc
;
;	Interrupt level 2, 3, 4, 5, 6, 7,(10, 11, 12, 14, 15 - AT level)
;	should follow the standard Interrupt Sharing Scheme which has
;	a standard header structure.
;	Fyi, the following shows the relations between
;	the interrupt vector and interrupt level.
; VEC(Hex)    2  8  9  A  B  C	D  E  70  72  73  74  76  77
; LVL(Deci)   9  0  1  2  3  4	5  6   8  10  11  12  14  15
;	MSSTACK module modifies the following interrupt vectors
;	to meet the standard Interrupt Sharing standard;
;	  A, B, C, D, E, 72, 73, 74, 76, 77.
;	Also, for interrupt level 7 and 15, the FirstFlag in a standard header
;	should be initialized to indicat whether this interrupt handler is
;	the first (= 80h) or not.  The FirstFlag entry of INT77h's
;	program header is initialized in STKINIT.INC module.
;	FirstFlag is only meaningful for interrupt level 7 and 15.
;

;  User specifies the number of stack elements - default = 9
;						 minimum = 8
;						 maximum = 64
;
;  Intercepts Asynchronous Hardware Interrupts only
;
;  Picks a stack from pool of stacks and switches to it
;
;  Calls the previously saved interrupt vector after pushing flags
;
;  On return, returns the stack to the stack pool
;

; This is a modification of STACKS:
; 1. To fix a bug which was causing the program to take up too much space.
; 2. To dispense stack space from hi-mem first rather than low-mem first.
;    . Clobbers the stack that got too big instead of innocent stack
;    . Allows system to work if the only stack that got too big was the most
;      deeply nested one
; 3. Disables NMI interrupts while setting the NMI vector.
; 4. Does not intercept any interupts on a PCjr.
; 5. Double checks that a nested interrupt didn't get the same stack.
; 6. Intercepts Ints 70, 72-77 for PC-ATs and other future products

		;EVEN
;align 2
		; 21/10/2022

		dw	0	; spare field but leave these in order
stackcount:	dw	0
stackat: 	dw	0
stacksize:	dw	0
stacks:		dw	0
		dw	0

firstentry:	dw	stacks
lastentry:	dw	stacks+(defaultcount*entrysize)-entrysize
nextentry:	dw	stacks+(defaultcount*entrysize)-entrysize

;***********************************************************************
; THESE ARE THE INDIVIDUAL INTERRUPT HANDLERS

; ----------------------------------------------------------------------

old02:	dd	0

int02:

; *********************************************************************
;
; this is special support for the pc convertible / nmi handler
;
;	on the pc convertible, there is a situation where an nmi can be 
;	caused by using the "out" instructions to certain ports. when this
;	occurs, the pc convertible hardware *guarantees* that **nothing** 
;	can stop the nmi or interfere with getting to the nmi handler. this
;	includes other type of interrupts (hardware and software), and
;	also includes other type of nmi's. when any nmi has occured,
;	no other interrtupt (hardware, software or nmi) can occur until
;	the software takes specific steps to allow further interrupting.
;
;	for pc convertible, the situation where the nmi is generated by the
;	"out" to a control port requires "fixing-up" and re-attempting. in
;	otherwords, it is actually a "restartable exception". in this
;	case, the software handler must be able to get to the stack in
;	order to figure out what instruction caused the problem, where
;	it was "out"ing to and what value it was "out"ing.  therefore,
;	we will not switch stacks in this situation. this situation is
;	detected by interrogating port 62h, and checking for a bit value
;	of 80h. if set, *****do not switch stacks*****.
;
; *********************************************************************

	push	ax
	push	es
	mov	ax,0F000h
	mov	es,ax
	; 02/11/2022
	cmp	byte [es:0FFFEh],0F9h ; mdl_convert ; check if convertible
	pop	es
	jne	short normal02

	in	al,62h		; PC/XT PPI port C. Bits:
				; 0-3: values of DIP switches
				; 5: 1=Timer 2 channel out
				; 6: 1=I/O channel check
				; 7: 1=RAM parity check error occurred.
	test	al,80h
	jz	short normal02
special02:
	pop	ax
	jmp	far [cs:old02]
normal02:
	pop	ax
	call	do_int_stacks
	dw	old02

; ----------------------------------------------------------------------

old08:	dd	0

int08:
	call	do_int_stacks
	dw	old08

; ----------------------------------------------------------------------

old09:	dd	0

int09:

; keyboard interrupt must have a three byte jump, a nop and a zero byte
; as its first instruction for compatibility reasons

	jmp	short keyboard_lbl
	nop
	db	0

keyboard_lbl:
	call	do_int_stacks
	dw	old09

; ----------------------------------------------------------------------

old70:	dd	0

int70:
	call	do_int_stacks
	dw	old70

; ----------------------------------------------------------------------

;	irp	a,<0a,0b,0c,0d,0e,72,73,74,76,77>
;public	int&a
;public	old&a
;public	firstflag&a
;int&a	proc	far
;	jmp	short entry_int&a&_stk
;old&a	dd	  0		;forward pointer
;	dw	  424bh 	;compatible signature for int. sharing
;firstflag&a db   0		;the firstly hooked.
;	jmp	short intret_&a	;reset routine. we don't care this.
;	db	7 dup (0)	;reserved for future.
;entry_int&a&_stk:
;	call	do_int_stacks
;	dw	old&a
;intret_&a:
;	iret
;int&a	endp
;	endm

; ----------------------------------------------------------------------

int0A:
	jmp	short entry_int0A_stk
old0A:	dd	0	
	dw	424Bh
firstflag0A:
	db	0
	jmp	short intret_0A
	times	7 db 0

entry_int0A_stk:
	call	do_int_stacks
	dw	old0A
intret_0A:
	iret

; ----------------------------------------------------------------------

int0B:
	jmp	short entry_int0B_stk
old0B:	dd	0	
	dw	424Bh
firstflag0B:
	db	0
	jmp	short intret_0B
	times	7 db 0

entry_int0B_stk:
	call	do_int_stacks
	dw	old0B
intret_0B:
	iret

; ----------------------------------------------------------------------

int0C:
	jmp	short entry_int0C_stk
old0C:	dd	0	
	dw	424Bh
firstflag0C:
	db	0
	jmp	short intret_0C
	times	7 db 0

entry_int0C_stk:
	call	do_int_stacks
	dw	old0C
intret_0C:
	iret

; ----------------------------------------------------------------------

int0D:
	jmp	short entry_int0D_stk
old0D:	dd	0	
	dw	424Bh
firstflag0D:
	db	0
	jmp	short intret_0D
	times	7 db 0

entry_int0D_stk:
	call	do_int_stacks
	dw	old0D
intret_0D:
	iret

; ----------------------------------------------------------------------

int0E:
	jmp	short entry_int0E_stk
old0E:	dd	0	
	dw	424Bh
firstflag0E:
	db	0
	jmp	short intret_0E
	times	7 db 0

entry_int0E_stk:
	call	do_int_stacks
	dw	old0E
intret_0E:
	iret

; ----------------------------------------------------------------------

int72:
	jmp	short entry_int72_stk
old72:	dd	0	
	dw	424Bh
firstflag72:
	db	0
	jmp	short intret_72
	times	7 db 0

entry_int72_stk:
	call	do_int_stacks
	dw	old72
intret_72:
	iret

; ----------------------------------------------------------------------

int73:
	jmp	short entry_int73_stk
old73:	dd	0	
	dw	424Bh
firstflag73:
	db	0
	jmp	short intret_73
	times	7 db 0

entry_int73_stk:
	call	do_int_stacks
	dw	old73
intret_73:
	iret

; ----------------------------------------------------------------------

int74:
	jmp	short entry_int74_stk
old74:	dd	0	
	dw	424Bh
firstflag74:
	db	0
	jmp	short intret_74
	times	7 db 0

entry_int74_stk:
	call	do_int_stacks
	dw	old74
intret_74:
	iret

; ----------------------------------------------------------------------

int76:
	jmp	short entry_int76_stk
old76:	dd	0	
	dw	424Bh
firstflag76:
	db	0
	jmp	short intret_76
	times	7 db 0

entry_int76_stk:
	call	do_int_stacks
	dw	old76
intret_76:
	iret

; ----------------------------------------------------------------------

int77:
	jmp	short entry_int77_stk
old77:	dd	0	
	dw	424Bh
firstflag77:
	db	0
	jmp	short intret_77
	times	7 db 0

entry_int77_stk:
	call	do_int_stacks
	dw	old77
intret_77:
	iret

; ----------------------------------------------------------------------

;********************************************************************
;common routines
;********************************************************************

; do interrupt stack switching. the fake return address holds
; a pointer to the far-pointer of the actual interrupt
; service routine

; 21/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 SYSINIT)
; 21/03/2019 - Retro DOS v4.0

;allocbyte   equ 0
;intlevel    equ 1
;savedsp     equ 2
;savedss     equ 4
;newsp       equ 6

; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 SYSINIT)
; (MSDOS 6.21 IO:SYS, SYSINIT:0147h)

do_int_stacks:
	push	ax
	push	bp
	push	es
	mov	es,[cs:stacks+2]	; Get segment of stacks
	mov	bp,[cs:nextentry]	; get most likely candidate
	mov	al,allocated ; 1
	; 21/10/2022
	;xchg	[es:bp+allocbyte],al 
	; 11/12/2022
	xchg	[es:bp],al		; grab the entry
	cmp	al,free ; 0		; still avail?
	jne	short notfree02

	sub	word [cs:nextentry],entrysize ; set for next interrupt

found02:
	mov	[es:bp+savedsp],sp	; save sp value
	mov	[es:bp+savedss],ss	; save ss also

	mov	ax,bp			; temp save of table offset

	mov	bp,[es:bp+newsp]	; get new SP value
	; 21/10/2022
	;mov	bp,[es:bp+6]
	; 11/12/2022
	;cmp	[es:bp+0],ax	
	cmp	[es:bp],ax		; check for offset into table
	jne	short foundbad02

	;mov	ax,es			; point ss,sp to the new stack
	;mov	es,bp
	;mov	bp,sp
	;mov	bp,[bp+6]
	;mov	ss,ax
	;mov	sp,es
	;mov	es,ax
	;mov	bp,[cs:bp]

	; 21/10/2022 (MSDOS 5.0 code SYSINIT code)
	push    bp
	mov     bp,sp
	mov     ax,[bp+8]
	pop     bp
	push    es
	pop     ss
	mov     sp,bp
	mov     bp,ax
	; 11/12/2022
	;mov	bp,[cs:bp+0]	
	mov	bp,[cs:bp]	

	pushf				; go execute the real interrupt handler
	; 11/12/2022
	call	far [cs:bp]		;  which will iret back to here
	; 21/10/2022
	;call	far [cs:bp+0]

	mov	bp,sp			; retrieve the table offset for us
	; 11/12/2022
	mov	bp,[es:bp]		;  but leave it on the stack
	; 21/10/2022
	;mov	bp,[es:bp+0]
	mov	ss,[es:bp+savedss]	; get old stack back
	mov	sp,[es:bp+savedsp]

	; 11/12/2022
	;mov	byte [es:bp+allocbyte],free ; free the entry
	; 21/10/2022
	mov	byte [es:bp],free ; 0
	mov	[cs:nextentry],bp	; setup to use next time

	pop	es
	pop	bp			; saved on entry
	pop	ax			; saved on entry
	add	sp,2
	iret				; done with this interrupt

notfree02:
	cmp	al,allocated		; error flag
	je	short findnext02	;  no, continue
	; 11/12/2022
	;xchg	[es:bp+allocbyte],al	;  yes, restore error value
	; 21/10/2022
	xchg	[es:bp],al

findnext02:
	call	longpath
	jmp	short found02

foundbad02:
	cmp	bp,[cs:firstentry]
	jc	short findnext02
	mov	bp,ax			; flag this entry
	; 11/12/2022
	;mov	byte [es:bp+allocbyte],clobbered
	; 21/10/2022
	mov	byte [es:bp],clobbered ; 3
	jmp	short findnext02	; keep looking

; ----------------------------------------------------------------------

; Common routines

longpath:
	; 21/03/2019
	mov	bp,[cs:lastentry]	; start with last entry in table
lploopp:
	; 11/12/2022
	;cmp	byte [es:bp+allocbyte],free ; is entry free?
	; 21/10/2022
	cmp	byte [es:bp],free
	jne	short inuse		;  no, try next one

	mov	al,allocated
	; 11/12/2022
	;xchg	[es:bp+allocbyte],al	; allocate entry
	; 21/10/2022
	xchg	[es:bp],al
	cmp	al,free 		; is it still free?
	je	short found		;  yes, go use it

	cmp	al,allocated		; is it other than Allocated or Free?
	je	short inuse		;  no, check the next one

	; 11/12/2022
	;mov	[es:bp+allocbyte],al	;  yes, put back the error state
	; 21/10/2022
	mov	[es:bp],al
inuse:
	cmp	bp,[cs:firstentry]
	je	short fatal
	sub	bp,entrysize
	jmp	short lploopp
found:
	retn
fatal:
	push	ds
	mov	ax,0F000h		;look at the model byte
	mov	ds,ax
	cmp	byte [0FFFEh],0F9h ; mdl_convert ; convertible?
	pop	ds
	jne	short skip_nmis

	mov	al,07h			; disable pc convertible nmis
	out	72h,al

skip_nmis:
	cli				; disable and mask
	mov	al,0FFh			;   all other ints
	out	021h,al
	out	0A1h,al

	mov	si,cs
	mov	ds,si
	mov	si,fatal_msg
;SR;
;   We set all foci to this VM to issue the stack failure message
;
	push	ax
	push	ds
	;;mov	ax,Bios_Data ; 0070h
	;mov	ax,KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	mov	ax,DOSBIODATASEG
	mov	ds,ax

	;test	byte [08D0h],1 	; (MSDOS 6.21, IO.SYS - SYSINIT:021Eh)
	test	byte [IsWin386],1 ; (retrodos4.sys, offset: ****h)
	pop	ds
	pop	ax
	jz	short fatal_loop	; win386 not present, continue

	;;call	far ptr 0070h:08D1h ; (MSDOS 621, IO.SYS - SYSINIT:0227h)
	;call	KERNEL_SEGMENT:V86_Crit_SetFocus ; set focus to this VM
	; 21/10/2022
	call	DOSBIODATASEG:V86_Crit_SetFocus ; 0070h:08D1h
;
;SR; We do not bother about the returned status of this call. 
;
fatal_loop:
	lodsb
	cmp	al,'$'
	je	short fatal_done

	mov	bl,7
	mov	ah,14
	int	10h			; whoops, this enables ints
	jmp	short fatal_loop

fatal_done:
	jmp	short fatal_done


; 21/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
; ----------------------------------------------------------------------
;	include msbio.cl5		; fatal stack error message

; MSDOS 6.21, IO.SYS, SYSINIT:023Bh

; STKMES.INC - MSDOS 3.3 (24/07/1987)
; ----------------------------------------------------------------------
; 04/06/2018 - Retro DOS v3.0

fatal_msg:
	db	0Dh,0Ah
	db	7,0Dh,0Ah
	db	"Internal stack overflow",0Dh,0Ah
	db	"System halted",0Dh,0Ah,"$" 

endstackcode:

; ----------------------------------------------------------------------
; SYINIT1.ASM (MSDOS 6.0, 1991) 'SYSINIT' jump addr from 'MSINIT.ASM'
; ----------------------------------------------------------------------
; 04/06/2018 - Retro DOS v3.0 (MSDOS 3.3, SYSINIT1.ASM, 24/07/1987)

; 22/03/2019 - Retro DOS v4.0

; SYSINIT:0269h (MSDOS 6.21 IO.SYS, SYSINIT segment, offset: 0269h)

; ('SYSINIT:' location/address is used in 'retrodos4.s'. If following
; address will be changed, it must also be changed in 'retrodos4.s'.)

; 21/10/2022- Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; ----------------------------------------------------------------------
; SYSINITSEG:0267h (MSDOS 5.0 IO.SYS, SYSINIT segment, offset: 0267h)

SYSINIT:	
        JMP	GOINIT
	;JMP	SYSIN ; 25/02/2018 - Retro DOS 2.0 modification

; ----------------------------------------------------------------------

struc DDHighInfo
 .ddhigh_CSegPtr resd 1	; pointer to code segment to be relocated
 .ddhigh_CSegLen resw 1	; length of code segment to be relocated
 .ddhigh_CallBak resd 1	; pointer to the call back routine
endstruc

; 22/03/2019 - Retro DOS v4.0

runhigh: db	0

; 02/11/2022
;align 4

DOSINFO: 
	dd	0	; address of the DOS Sysini Variables
;MSDOS:
dos_temp_location: ; dword ; MSDOS 6.0
dosinit:		; MSDOS 6.0
	dw	0

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;FINAL_DOS_LOCATION: ; 20/04/2019 - Retro DOS v4.0
;	dw	0
;MSDOS 5.0 IO.SYS - SYSINIT:0271h

CURRENT_DOS_LOCATION:
	dw	0

;DOSSIZE: ; Retro DOS 2.0 feature - 25/02/2018
;	dw	0   ; 'MSDOS.BIN' kernel size in words

; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; (MSDOS 5.0 MSDOS.SYS size is 37394 bytes)
DOSSIZE	equ	0A000h	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)

DEVICE_LIST:
	dd	0

; 04/06/2018 - Retro DOS v3.0
; 28/03/2018
;; MSDOS 3.3 - SYSINIT1.ASM - 24/07/1987
;
sysi_country:	
	dd	0 ; 5/29/86 Pointer to country table in DOS

; MSDOS 6.0
dos_segreinit:	dw	0,0	; room for dword

lo_doscod_size:	dw	0	; dos code size when in low mem
hi_doscod_size:	dw	0	; dos code size when in HMA

def_php:	dw	0

; M022--
; pointer for calling into Bios_Code for re-initializing segment values.
;  call with ax = new segment for Bios_Code. Notice that we'll
;  call it in its temporary home, cuz seg_reinit won't get moved to
;  the new home.

;Bios_Code	equ	KERNEL_SEGMENT  ; 0070h
; 21/10/2022
;DOSBIOCODESEG	equ	02C7h ; (MSDOS 5.0 IO.SYS)

; 22/10/2022
seg_reinit_ptr:	; label dword
		dw	seg_reinit ; Bios_Code:0032h for MSDOS 6.21 IO.SYS
temp_bcode_seg:
		;dw	Bios_Code  ; 02CCh for MSDOS 6.21 IO.SYS
		; 22/10/2022
		dw	DOSBIOCODESEG ; 02C7h for MSDOS 5.0 IO.SYS 		

fake_floppy_drv:
		db	0	; set to 1 if this machine
				; does not have any floppies!!!

; Internal Stack Parameters

stack_count:	dW	defaultcount ; 9
stack_size:	dw	defaultsize  ; 128
stack_addr:	dd	0	

; 05/06/2018 - Retro DOS v3.0

; various default values

MEMORY_SIZE:	dw	1

; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0 source, MSDOS 6.21 disassembled src.)

RPLMemTop:	dw	0  ; 22/10/2022 (MSDOS 5.0 IO.SYS SYSINIT:0294h)	
DEFAULT_DRIVE:	db	0	;initialized by ibminit.
buffers:	dw	0FFFFh	; initialized during buffer allocation
h_buffers:	dw	0	; # of the heuristic buffers. initially 0.
singlebuffersize: dw	0	; maximum sector size + buffer head

FILES:	db	8	; enough files for pipe
FCBS:	db	4	; performance for recycling
KEEP:	db	0	; keep original set
NUM_CDS: db	5	; 5 net drives

; 22/10/2022 (MSDOS 5.0 SYSINIT)
;;CONFBOT: dw	0
;;ALLOCLIM: dw	0
;CONFBOT: ; 02/11/2022
;top_of_cdss: dw 0

; 30/12/2022 - Retrodos v4.2 (MSDOS 6.21 SYSINIT)
; (SYSINITSEG:02A3h)
CONFBOT: dw	0
ALLOCLIM: dw	0
top_of_cdss: dw 0

; 02/11/2022 (MSDOS 5.0 SYSINIT)
; 30/12/2022 (MSDOS 6.21 SYSINIT)
;ALLOCLIM: dw	0	; (SYSINIT:02A3h)	

DirStrng: db	"A:\",0	; string for the root directory of a drive

; 30/12/2022 - Retro DOS v4.2 (MSDOS 6.21 SYSINIT)
%if 0
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
; (SYSINIT:02A9h)

command_line:
	db	2,0
	db	'P'
	db	0
	times	124 db 0 ; db 124 dup(0)

%endif

	
; (SYSINIT:0329h)
ZERO:	db	0
sepchr:	db	0
linecount: dw	0			; line count in config.sys
showcount: db	'     ',cr,lf,'$'	; used to convert linecount to ascii.
buffer_linenum: dw	0		; line count for "buffers=" command if entered.

sys_model_byte:	db	0FFh		; model byte used in sysinit
sys_scnd_model_byte: db 0		; secondary model byte used in sysinit

buf_prev_off:	dw	0

        ;IF      NOT NOEXEC
;COMEXE EXEC0 <0,COMMAND_LINE,DEFAULT_DRIVE,ZERO>
        ;ENDIF

; 01/05/2018
COMEXE:
EXEC0.ENVIRON:	dw	0	; seg addr of environment
EXEC0.COM_LINE:	dw	command_line ; pointer to asciz command line
		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
EXEC0.5C_FCB:	dw	DEFAULT_DRIVE ; default fcb at 5C
		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
EXEC0.6C_FCB:	dw	ZERO	; default fcb at 6C
		dw	0

; variables for install= command.

multi_pass_id:	db	0		; parameter passed to multi_pass
					;  indicating the pass number
					; 0 - do scan for DOS=HIGH/LOW
					; 1 - load device drivers
					; 2 - was to load IFS
					;      now it is unused
					; 3 - do install=
					; >3 - nop
install_flag:	dw	0

have_install_cmd equ	00000001b	; config.sys has install= commands
has_installed	equ	00000010b	; sysinit_base installed.

config_size:	dw	0		; size of config.sys file. set by sysconf.asm
sysinit_base_ptr: dd	0		; pointer to sysinit_base
sysinit_ptr:	dd	0		; returning addr. from sysinit_base
checksum:	dw	0		; used by sum_up

ldexec_fcb:	times 20 db 20h ; db 20 dup (' ') ;big enough
ldexec_line:	db	0		;# of parm characters
ldexec_start:	db	' '
ldexec_parm:	times 80 db 0	; db 80 dup (0)

;instexe exec0	<0,ldexec_line,ldexec_fcb,ldexec_fcb>

instexe:
iexec.environ:	dw	0		; seg addr of environment
iexec.ldexec_line: dw	ldexec_line ; pointer to asciz command line
		dw	0 	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
iexec.ldexec_5c_fcb: dw	ldexec_fcb	; default fcb at 5C
		dw	0	; SYSINIT segment (0473h for MSDOS 6.21 IO.SYS)
iexec.ldexec_6c_fcb: dw	ldexec_fcb	; default fcb at 6C
		dw	0

; variables for comment=

com_level:	db	0		; level of " " in command line
cmmt:		db	0		; length of comment string token
cmmt1:		db	0		; token
cmmt2:		db	0		; token
cmd_indicator:	db	0
donotshownum:	db	0

count:		dw	0
org_count:	dw	0
chrptr:		dw	0
cntryfilehandle: dw	0
old_area:	dw	0
impossible_owner_size: dw 0		; paragraph

bucketptr: ; label dword
bufptr:	   ; label dword		; leave this stuff in order!
memlo:	dw	0
prmblk:	   ; label word
memhi:	dw	0
ldoff:	dw	0
area:	dw	0

; Following is the request packet used to call INIT routines for 
; all device drivers. Some fields may be accessed individually in
; the code, and hence have individual labels, but they should not
; be separated.

packet:	db	24			; was 22
	db	0
	db	0			; initialize code
	dw	0
	times	8 db 0	; db 8 dup (?)

unitcount:	db	0
break_addr:	dd	0
bpb_addr:	dd	0
drivenumber:	; 22/10/2022
devdrivenum:	db	0 
configmsgflag:	dw	0  ; used to control "error in config.sys line #" message

; end of request packet

;drivenumber:	db	0  ; 22/03/2019

toomanydrivesflag:
		db	0  ; >24 fixed disk partitions flag ; M029 
align 2

BCodeSeg:	; 21/10/2022
	dw	DOSBIOCODESEG ; (02C7h for MSDOS 5.0 IO.SYS)
	;dw	Bios_Code  ; = KERNEL_SEGMENT = 0070h (for Retro DOS v4.0)
			   ; BCodeSeg = 2CCh (for MSDOS 6.21 IO.SYS)

; 30/12/2022
; MSDOS 6.21 IO.SYS, SYSINIT:0387h
;
; Magicbackdoor: dd 0
; NullBackdoor: 
;		retf

; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; 19/04/2019
_timer_lw_:
	dw	0  ; MSDOS 6.21 IO.SYS - SYSINIT:038Ch

;SR;
; This is the communication block between the DOS and the BIOS. It starts at
;the SysinitPresent flag. Any other data that needs to be communicated 
;to the DOS should be added after SysinitPresent. The pointer to this block
;is passed to DOS as part of the DOSINIT call.
;

BiosComBlock:
	;dd	Bios_Data:SysinitPresent 
		; 0070h:08FDh for MSDOS 6.21 IO.SYS
	dw	SysinitPresent  ; (retrodos4.sys, offset: ****h)
	;dw	KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	dw	DOSBIODATASEG ; 0070h

;align 2

	; 22/10/2022 - (MSDOS 5.0 IO.SYS, SYSINIT:0406h)
	; 30/12/2022 - (MSDOS 6.21 IO.SYS, SYSINIT:0392h)
tempstack:	
	times	128 db 0  ; db	80h dup (?)

; ----------------------------------------------------------------------------

	; 22/10/2022 - Retro DOS v4.0
	;	; (MSDOS 5.0 IO.SYS, SYSINIT:0486h)
GOINIT:		; (MSDOS 6.21 IO.SYS, SYSINIT:0412h)
	; 12/12/2022
	; 22/03/2019 - Retro DOS v4.0
	; 06/07/2018
	; 04/06/2018 - Retro DOS v3.0
; before doing anything else, let's set the model byte
	mov	ah,0C0h 		; get system configuration
	int	15h			; *
	jc	short no_rom_config

	cmp	ah,0			; double check
	jne	short no_rom_config
	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_modelbyte]
	mov	[cs:sys_model_byte],al 
	mov	al,[es:bx+ROMBIOS_DESC.bios_sd_scnd_modelbyte]
	mov	[cs:sys_scnd_model_byte],al
	;jmp	short SYSIN
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	jmp	short move_myself

no_rom_config:				; Old ROM
	mov	ax,0F000h
	mov	ds,ax
	mov	al,[0FFFEh]
	mov	[cs:sys_model_byte],al	; set the model byte.

; set fake_floppy_drv if there is no diskette drives in this machine.
; execute the equipment determination interrupt and then
; check the returned value to see if we have any floppy drives
; if we have no floppy drive we set cs:fake_floppy_drv to 1
; see the at tech ref bios listings for help on the equipment
; flag interrupt (11h)	

	; 22/10/2022
check_for_fake_floppy:			; entry point for rom_config above
	int	11h			; check equipment flag

	; 12/12/2022
	test	al,1		
	;test	ax,1			; have any floppies?
	jnz	short move_myself	; yes,normal system

; Some ROM BIOSs lie that there are no floppy drives. Lets find out
; whether it is an old ROM BIOS or a new one
;
; WARNING !!!
;
; This sequence of code is present in MSINIT.ASM also. Any modification
; here will require an equivalent modification in MSINIT.ASM also

	push	es

	xor	cl,cl	
	mov	ah,8			; get disk parameters
	mov	dl,0			; of drive 0
	int	13h

	pop	es

	jc	short move_myself	; if error lets assume that the
					;  ROM BIOS lied
	cmp	cl,0			; double check (max sec no cannot be 0)
	je	short move_myself

	or	dl,dl			; number of flp drvs == 0?
	jnz	short move_myself

	mov	byte [cs:fake_floppy_drv],1 ; set fake flag.

move_myself:
	cld				; set up move
	xor	si,si
	mov	di,si

	; 12/12/2022
	push	cs
	pop	ds

	;mov	cx,[cs:MEMORY_SIZE]
	mov	cx,[MEMORY_SIZE] ; 12/12/2022

	; (MSDOS 6.0 - SYSINIT1.ASM - 1991)
;;;	if	msver
;	cmp	cx,1		; 1 means do scan
;	jnz	short noscan
;	mov	cx,2048		; start scanning at 32k boundary
;	xor	bx,bx
;
;memscan:inc	cx
;	jz	setend
;	mov	ds,cx
;	mov	al,[bx]
;	not	al
;	mov	[bx],al
;	cmp	al,[bx]
;	not	al
;	mov	[bx],al
;	jz	short memscan
;setend:
;	mov	cs:[memory_size],cx
;;;	endif

;noscan: 				; cx is mem size in para
;;
;;	cas -- a) if we got our memory size from the ROM, we should test it
;;		  before we try to run.
;;	       b) in any case, we should check for sufficient memory and give
;;		  an appropriate error diagnostic if there isn't enough
;
;	push	cs
;	pop	ds
;
;;	cas note:  It would be better to put dos + bios_code BELOW sysinit
;;	  that way it would be easier to slide them down home in a minimal
;;	  memory system after sysinit.  As it is, you need room to keep
;;	  two full non-overlapping copies, since sysinit sits between the
;;	  temporary home and the final one.  the problem with doing that
;;	  is that sys*.asm are filled with "mov ax,cs, sub ax,11h" type stuff.
;
;	dec	cx			; one para for an arena at end of mem
;					; in case of UMBs

	; 22/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:04DBh)

	; 12/12/2022
	;push	cs
	;pop	ds

	dec	cx

;------ Check if an RPL program is present at TOM and do not tromp over it

	xor	bx,bx
	mov	es,bx
	mov	bx,[es:(2Fh*4)] ; INT 2Fh address (0:0BCh)
	mov	es,[es:((2Fh*4)+2)] ; INT 2Fh segment (0:0BEh)
	cmp	word [es:bx+3],'RP'
	jne	short NoRPL
	cmp	byte [es:bx+5],'L'
	jne	short NoRPL

	mov	dx,cx			; get TOM into DX
	push	dx
	mov	ax,4A06h
	;mov	ax,(multMULT<<8)+multMULTRPLTOM
	int	2Fh			; Get new TOM from any RPL
	pop	ax
	mov	cx,dx
	cmp	dx,ax
	je	short NoRPL
	
	; 11/12/2022
	; ds = cs
	mov	[RPLMemTop],dx
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	[cs:RPLMemTop],dx
	
	dec	cx
NoRPL:
	mov	ax,SI_end		; need this much room for sysinit
					; (SI_end == sysinit code size)
	call	off_to_para
	sub	cx,ax

; we need to leave room for the DOS and (if not ROMDOS) for the BIOS
; code above sysinit in memory
;
	sub	cx,DOSSIZE/16 ; (0A00h)	; leave this much room for DOS

	mov	ax,BCODE_END 		; (1A60h for MSDOS 5.0 IO.SYS)
					; (1A70h for MSDOS 6.21 IO.SYS
	call	off_to_para		; leave this much room for BIOS code
	sub	cx,ax
	mov	es,cx			; offset where sysinit will be located

	mov	cx,SI_end		; (sysinit code size)
	shr	cx,1			; divide by 2 to get words
	rep	movsw			; relocate sysinit

	push	es			; push relocated segment
	mov	ax,SYSIN
	push	ax			; push relocated entry point

	retf				; far jump to relocated sysinit

; ----------------------------------------------------------------------------

;	MOVE THE DOS TO ITS PROPER LOCATION

	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0533h)
	; 30/12/2022 - Retro DOS 4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:04BFh)	
SYSIN:
	; Retro DOS 4.0 - 22/03/2019
	; Retro DOS 2.0 - 25/02/2018

	; 23/04/2019
	;;mov	ax,Bios_Data
	;mov	ax,KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax
	mov	[MoveDOSIntoHMA+2],cs	; set seg of routine to move DOS
	mov	byte [SysinitPresent],1	; flag that MoveDOSIntoHMA can be called

; first move the MSDOS.SYS image up to a harmless place 
; on top of our new sysinitseg

	; 22/10/2022
	mov	ax,SI_end		; how big is sysinitseg?
	call	off_to_para
	mov	cx,cs			; pick a buffer for msdos above us
	add	ax,cx
	mov	es,ax
	
	xor	si,si
	mov	di,si

	mov	ds,[cs:CURRENT_DOS_LOCATION] ; where it is (set by msinit)

	;mov	ax,cs	
	;mov	ds,ax

	;;;mov	cx,20480  ; MSDOS 6.21 IO.SYS - SYSINIT:04E2h
	;;mov	cx,dossize/2 ; MSDOS 6.0
	;mov	cx,[DOSSIZE] ; words (not bytes!)  ; Retro DOS v4.0 (3.0, 2.0)
	;mov	es,[FINAL_DOS_LOCATION] ; on top of SYSINIT code
	;mov	ds,[CURRENT_DOS_LOCATION]

	; 22/10/2022
	mov	cx,DOSSIZE/2 ; 5000h
	rep     movsw
	mov	[cs:CURRENT_DOS_LOCATION],es

; The DOS code is ORGed at a non-zero value to allow it to be located in
; HIMEM. Thus, the DOS segment location must be adjusted accordingly.
; If this is ROMDOS, however, only the init code is loaded into RAM, so
; this ORG is not done. The entry point is at offset zero in the segment.

	; 22/04/2019 (MSDOS 6.0 & MSDOS 6.21 kernel address modification)
	;mov	ax,cs
	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
	;mov	ds,ax

; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !

;	; 24/04/2019 
;;ifndef ROMDOS
;	mov	ax,[es:3] 		; get offset of dos
;		; ax = 3DE0h for MSDOS 6.21 kernel (MSDOS.SYS, offset 3) 
;	mov	[dosinit],ax		; that's the entry point offset
;	call	off_to_para		; subtract this much from segment
;	; 23/04/2019
;	;sub	[CURRENT_DOS_LOCATION],ax
;	sub	[FINAL_DOS_LOCATION],ax
;;else
;;	mov	word [dosinit],0	; entry to init is at zero
;;
;;endif ; ROMDOS

	; 29/04/2019 - Retro DOS v4.0 ! important MODIFICATION !
	; (! MSDOS6.BIN starts with DOSDATA ! - Retro DOS v4.0 modification) 

	;mov	ax,[es:0] ; DOSCODE start address = DOSDATA size (= 136Ah)
	;		  ; (Valid for Retro DOS v4.0 only!)

	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
	; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
	mov	ax, [3]		; mov ax, word ptr ds:3

	mov	[cs:dosinit],ax ; (SYSINIT:0563h for MSDOS 5.0 IO.SYS SYSINIT)
	; 02/11/2022
	call	off_to_para		; subtract this much from segment
	sub	[cs:CURRENT_DOS_LOCATION],ax

	; Current DOSCODE start address = dword [dosinit]

;; If this is not ROMDOS, then the BIOS code is moved to the top of memory
;; until it is determined whether it will be running in HIMEM or not.

;ifndef ROMDOS

; now put Bios_Code up on top of that. Assume Bios_Code + dossize < 64k

	; 22/10/2022
	mov	ax,es
	add	ax,DOSSIZE/16		; get paragraph of end of dos
	mov	es,ax
	xchg	ax,[cs:temp_bcode_seg]	; swap with original home of Bios_Code
	mov	ds,ax			; point to loaded image of Bios_Code

	;mov	si,BCODE_START ; mov si,30h
	; 09/12/2022
	mov	si,BCODESTART
	; 02/11/2022
	mov	di,si
	mov	cx,BCODE_END   ; mov cx,1A60h ; mov cx,1A70h ; 30/12/2022
	sub	cx,si
	shr	cx,1
	rep	movsw			; move Bios_Code into place

	mov	ax,es			; tell it what segment it's in
	call	far [cs:seg_reinit_ptr]	; far call to seg_reinit in Bios_Code (M022)

;endif	; not ROMDOS

; now call dosinit while it's in its temporary home

	;mov	ax,cs
	;mov	ds,ax	 

	;mov	dx,[MEMORY_SIZE]	; set for call to dosinit

	; 22/10/2022

	les	di,[cs:BiosComBlock]	; ptr to BIOS communication block
		; es = KERNEL_SEGMENT (70h), di = 'SysInitPresent' address
	lds	si,[cs:DEVICE_LIST]	; set for call to dosinit
		; ds = KERNEL_SEGMENT (70h), si = 'res_dev_list' address

	mov	dx,[cs:MEMORY_SIZE]	; set for call to dosinit

	cli
	mov	ax,cs
	mov	ss,ax

; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM)
%define locstack ($ - SYSINIT$) & 0FFFEh  ; 532h in MSDOS 6.21 IO.SYS
					  ; 5A6h in MSDOS 5.0 IO.SYS SYSINIT
;SYSINIT:0532h: 

; 22/10/2022
; ----------------------------------------------------------------------------
;SYSINIT:05A6h:
;locstack:	; (at SYSINIT:05A6h for MSDOS 5.0 IO.SYS)

	;mov	sp, 05A6h
	mov     sp,locstack		; set stack

	sti

;align 2
	; 30/03/2018
;LOCSTACK:
        ;CALL	FAR [CS:MSDOS]	; FINAL_DOS_LOCATION:0 
		       		;('jmp DOSINIT' in 'MSHEAD.ASM')
		       		;('DOSINIT:' is in 'MSINIT.ASM')

	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21)

; This call to DOSINIT will relocate the DOS data from its present location
; at the top of memory, to its final location in low memory just above the
; BIOS data. It will then build important DOS data structures in low 
; memory following the DOS data. It returns (among many other things) the
; new starting address of free memory.

	call	far [cs:dosinit]	; call dosinit	
			 ; es:di -> sysinitvars_ext

	mov	[cs:def_php],ds		; save pointer to PSP
	
	; 11/12/2022
	; 22/03/2019
	push	cs
	pop	ds
	; 22/10/2022
	mov	[hi_doscod_size],ax
	mov	[lo_doscod_size],cx
	mov	[dos_segreinit],dx
	
	; 11/12/2022
	; ds = cs
	;mov	[cs:hi_doscod_size],ax	; size of doscode (including exepatch)
	;mov	[cs:lo_doscod_size],cx	; (not including exepatch)
	;mov	[cs:dos_segreinit],dx	; save offset of segreinit

	; 05/06/2018 - Retro DOS v3.0
	; ES:DI = Address of pointer to SYSINITVARS structure (MSDOS 3.3)

	; 11/12/2022
	; ds = cs
	; 22/10/2022
	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars] ; 5/29/86
	mov	ax,[es:di] ; 22/03/2019
	;mov	[cs:DOSINFO],ax
	mov	[DOSINFO],ax
	;mov	ax,[es:di+SysInitVars_Ext.SYSI_InitVars+2]
	mov	ax,[es:di+2]
	;mov	[cs:DOSINFO+2],ax
	mov	[DOSINFO+2],ax	; set the sysvar pointer

	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab]
	mov	ax,[es:di+4]
	;mov	[cs:sysi_country],ax
	mov	[sysi_country],ax
	;mov	ax,[es:di+SysInitVars_Ext.SYSI_Country_Tab+2]
	mov	ax,[es:di+6]
	;mov	[cs:sysi_country+2],ax
	mov	[sysi_country+2],ax	; set the SYSI_Country pointer

	; 20/04/2019
	;mov	ax,[CURRENT_DOS_LOCATION]
	;;mov	es,[CURRENT_DOS_LOCATION]
	;mov	ax,[FINAL_DOS_LOCATION] ; give dos its temporary location
	; 22/10/2022
	;mov	ax,[cs:CURRENT_DOS_LOCATION]
	;;;mov	[dos_segreinit+2],es
	;;mov	[dos_segreinit+2],ax
	;mov	[cs:dos_segreinit+2],ax
	; 11/12/2022
	; ds = cs
	mov	es,[CURRENT_DOS_LOCATION]
	mov	[dos_segreinit+2],es
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	es,[cs:CURRENT_DOS_LOCATION]
	;mov	[cs:dos_segreinit+2],es

; ----------------------------------------------------------------------------

;SYSINIT:0577h:
	; ... RPLArena ... MSDOS 6.21 IO.SYS (SYSINIT:0577h to SYSINIT:05D1h)
;SYSINIT:05D1h:	; NoRPLArena 

	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
;------ Cover up RPL code with an arena
;SYSINIT:05EBh:
	; 11/12/2022
	; ds = cs
	xor	bx,bx
	cmp	[RPLMemTop],bx ; 0
	;cmp	word [RPLMemTop],0
	;;cmp	word [cs:RPLMemTop],0
	je	short NoRPLArena

;------ alloc all memory

	; 11/12/2022
	;mov	bx,0FFFFh
	dec	bx
	; bx = 0FFFFh
	mov	ah,48h
	int	21h
			; DOS - 2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	mov	ah,48h
	int	21h

	mov	es,ax			; get it into ES and save it
	push	es

;------ resize upto RPL mem

	; 11/12/2022
	; ds = cs
	;sub	ax,[cs:RPLMemTop]
	sub	ax,[RPLMemTop]
	neg	ax
	dec	ax
	mov	bx,ax
	mov	ah,4Ah
	int	21h
  			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block to change
			; BX = new size in paragraphs

;------ allocate the free (RPL MEM)

	mov	bx,0FFFFh
	mov	ah,48h
	int	21h
	mov	ah,48h
	int	21h

;----- mark that it belongs to RPL

	dec	ax
	mov	es,ax
	;mov	word [es:arena_owner],8
	mov	word [es:1],8
	;mov	word [es:arena_name],'RP'
	mov	word [es:8],'RP'
	;mov	word [es:arena_name+2],'L'
	mov	word [es:10],'L'
	;mov	word [es:arena_name+4],0
	mov	word [es:12],0
	;mov	word [es:arena_name+6],0
	mov	word [es:14],0	

        pop     es                      ; get back ptr to first block
        mov     ah,49h	; Dealloc	; and free it
	int	21h		
					; DOS - 2+ - FREE MEMORY
					; ES = segment address of area to be freed
	; 11/12/2022
	clc

; ----------------------------------------------------------------------------

NoRPLArena:
	; 11/12/2022
	; ds = cs
	; 22/03/2019 - Retro DOS v4.0 (MSDOS 6.0, 6.21, IO.SYS)
	les	di,[DOSINFO]	; es:di -> dosinfo
	; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
	;les	di,[cs:DOSINFO]	; es:di -> dosinfo

	; 11/12/2022
	;clc				; get the extended memory size

;	execute the get extended memory size subfunction in the bios int 15h
;	if the function reports an error do nothing else store the extended
;	memory size reported at the appropriate location in the dosinfo buffer
;	currently pointed to by es:di. use the offsets specified in the
;	definition of the sysinitvars struct in inc\sysvar.inc

	mov	ah,88h
	int	15h			; check extended memory size
	jc	short no_ext_memory
			; Get Extended Memory Size
			; Return: CF clear on success
			; AX = size of memory above 1M in K	
	;mov	[es:di+SYSI_EXT_MEM],ax ; save extended memory size
	; 22/10/2022
	mov	[es:di+45h],ax ; save extended memory size
	or	ax,ax
	jz	short no_ext_memory
	call	ClrVDISKHeader
no_ext_memory:
	;mov	ax,[es:di+SYSI_MAXSEC]	; get the sector size
	mov	ax,[es:di+10h]
	;add	ax,bufinsiz
	add	ax,20			; size of buffer header
	; 11/12/2022
	; ds = cs
	mov	[singlebuffersize],ax	; total size for a buffer
	;mov	[cs:singlebuffersize],ax	
	; 11/12/2022
	mov	al,[DEFAULT_DRIVE]	; get the 1 based boot drive number set by msinit
	;mov	al,[cs:DEFAULT_DRIVE]
	;mov	[es:di+SYSI_BOOT_DRIVE],al ; set sysi_boot_drive
	mov	[es:di+43h],al

; determine if 386 system...

	;get_cpu_type			; macro to determine cpu type

get_cpu_type:
	; 11/12/2022
	pushf
	;push	bx
	;xor	bx,bx
	; 11/12/2022
	;xor	cx,cx
	;
	xor	ax,ax
	; ax = 0
	push    ax
	popf
	pushf
	pop	ax
	and	ax,0F000h
	;cmp	ax,0F000h
	cmp	ah,0F0h 
	je	short cpu_8086
	;mov	ax,0F000h
	mov	ah,0F0h
	; ax = 0F000h
	push	ax
	popf
	pushf
	pop	ax
	;and	ax,0F000h
	and	ah,0F0h
	jz	short cpu_286
cpu_386:
	; 11/12/2022
	;;inc	bx
	;inc	cx
	; 11/12/2022
	;mov	byte [es:di+SYSI_DWMOVE],1
	mov	byte [es:di+44h],1
cpu_286:
	;;;inc	bx
	;;inc	cx
cpu_8086:
	; 11/12/2022
	;;mov	ax,bx	
	;pop	bx
	popf

	;...

	; 11/12/2022
	;or	cl,cl
	;jz	short not_386_system
	; 11/12/202
	;cmp	cl,2
	;;cmp	ax,2			; is it a 386?
	;jne	short not_386_system	; no: don't mess with flag
	;;mov	byte [es:di+SYSI_DWMOVE],1
	; 11/12/2022
	; 22/10/2022
	;mov	byte [es:di+44h],1
not_386_system:
	;mov	al,[es:di+SYSI_NUMIO]
	mov	al,[es:di+20h]
	; 11/12/2022
	; ds = cs
	mov	[drivenumber],al	; save start of installable block drvs
	;mov	[cs:drivenumber],al

	mov	ax,cs
	sub	ax,11h			; room for PSP we will copy shortly
	; 11/12/2022
	;mov	cx,[singlebuffersize]	; temporary single buffer area
	;;mov	cx,[cs:singlebuffersize]
	;shr	cx,1			
	;shr	cx,1			; divide size by 16...
	;shr	cx,1
	;shr	cx,1			; ...to get paragraphs...
	;inc	cx			; ... and round up
	; 11/12/2022
	mov	bx,[singlebuffersize]
	mov	cl,4
	shr	bx,cl
	inc	bx

;	cas note: this unorthodox paragraph rounding scheme wastes a byte
;	  if [singlebuffersize] ever happens to be zero mod 16. Could this
;	  ever happen? Only if the buffer overhead was zero mod 16, since
;	  it is probably safe to assume that the sector size always will be.
;
;	 mohans also found a bug in CONFIG.SYS processing where it replaces
;	  EOF's with cr,lf's, without checking for collision with [confbot].
;	  perhaps the extra byte this code guarantees is what has kept that
;	  other code from ever causing a problem???

	; 11/12/2022
	sub	ax,bx
	;sub	ax,cx
	mov	[top_of_cdss],ax	; temp "unsafe" location
	; 22/10/2022
	;mov	[cs:top_of_cdss],ax

;	chuckst -- 25 Jul 92 -- added code here to pre-allocate space
;	for 26 temporary CDSs, which makes it easier to use alloclim
;	for allocating memory for MagicDrv.

	push	es			; preserve pointer to dosinfo
	push	di

	; 22/10/2022
;	mov	cx,ax			; save pointer for buffer
;
;;	now allocate space for 26 CDSs
;
;	sub	ax,((26 *(curdirlen))+15)/16
;	mov	[ALLOCLIM],ax		; init top of free memory pointer
;	mov	[CONFBOT],ax		; init this in case no CONFIG.SYS

	; 30/12/2022 - Retro DOS v4.2 (MSDOS 6.21 IO.SYS)
	; (SYSINIT:064Ch)
	mov	cx,ax ; (*)
	sub	ax,((26 *(curdirlen))+15)/16 ; sub ax,143
	mov	[ALLOCLIM],ax		; init top of free memory pointer
	mov	[CONFBOT],ax		; init this in case no CONFIG.SYS
	 	
; setup and initialize the temporary buffer at cx

	;les	di,[es:di+SYSI_BUF]	; get the buffer chain entry pointer
	les	di,[es:di+12h]
	; 11/12/2022
	xor	bx,bx
	;xor	ax,ax
	;mov	[es:di+BUFFINF.Dirty_Buff_Count],ax ; 0
	;mov	word [es:di+4],0
	mov	[es:di+4],bx ; 0
	;mov	[es:di+BUFFINF.Buff_Queue],ax ; 0
	;mov	word [es:di],0
	mov	[es:di],bx ; 0
	;mov	[es:di+BUFFINF.Buff_Queue+2],cx ; cx = [top_of_cdss] ; 6.21
	;;mov	[es:di+BUFFINF.Buff_Queue+2],ax ; ax = [top_of_cdss] ; 5.0
	;mov	[es:di+2],ax
	;mov	es,ax	; [top_of_cdss] = [CONFBOT]
	; 30/12/2022 - Retro DOS v4.2 (MSDOS 6.21 IO.SYS, SYSINIT)
	mov	[es:di+2],cx ; [top_of_cdss] ; (*)	
	mov	es,cx

	; 11/12/2022
	;xor	ax,ax
	;mov	di,ax			; es:di -> single buffer
	mov	di,bx
	; di = 0

	;mov	[es:di+buffinfo.buf_next],ax ; points to itself
	; 11/12/2022
	;mov	[es:di],ax ; 0
	mov	[es:di],bx ; 0
	;mov	[es:di+buffinfo.buf_prev],ax ; points to itself
	; 11/12/2022
	;mov	[es:di+2],ax ; 0
	mov	[es:di+2],bx ; 0 

	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS SYINIT)
	; MSDOS 5.0 IO.SYS - SYSINIT:06E0h

	;mov	word [es:di+buffinfo.buf_ID],00FFh ; free buffer,clear flag
	mov	word [es:di+4],00FFh
;SYSINIT:06E6h
	;;mov	[es:di+buffinfo.buf_sector],ax ; 0
	;mov	word [es:di+6],0
	; 11/12/2022
	;mov	[es:di+buffinfo.buf_sector],bx ; 0
	mov	[es:di+6],bx ; 0
	;;mov	[es:di+buffinfo.buf_sector+2],ax ; 0
	;mov	word [es:di+8],0
	; 11/12/2022
	;mov	[es:di+buffinfo.buf_sector+2],bx ; 0
	mov	[es:di+8],bx ; 0

	pop	di			; restore pointer to DOSINFO data
	pop	es

	; 11/12/2022
	; ds = cs
	; 22/10/2022
	;push	cs
	;pop	ds

	call	TempCDS			; set up cdss so re_init and sysinit
					;  can make disk system calls
					; tempcds trashes ds
	; 10/05/2019
	mov	ds,[cs:def_php]		; retrieve pointer to PSP returned by DOSINIT

	;if not ibmjapver
	;call	far KERNEL_SEGMENT:re_init ; re-call the bios
	;endif

	; 22/10/2022
;SYSINIT:06FEh:	; (MSDOS 5.0 IO.SYS, SYSINIT)
	; 30/12/2022
;SYSINIT:0697h:	; (MSDOS 6.21 IO.SYS, SYSINIT)
	;call	far ptr 70h:89Bh
	call	DOSBIODATASEG:RE_INIT

	sti				; ints ok
	cld				; make sure

; 23/03/2019

;SYSINIT:069Eh	; 30/12/2022

; dosinit has set up a default "process" (php) at ds:0. we will move it out
; of the way by putting it just below sysinit at end of memory.

	mov	bx,cs
	sub	bx,10h
	mov	es,bx
	xor	si,si
	mov	di,si
	mov	cx,128
	rep	movsw

	;mov	[es:PDB.JFN_POINTER+2],es ; Relocate
	; 22/10/2022
	mov	[es:36h],es

 	; Set Process Data Block - Program Segment Prefix address
	; BX = PDB/PSP segment
        mov	ah,50h	; SET_CURRENT_PDB
	int	21h			; tell DOS we moved it
			; DOS - 2+ internal - SET PSP SEGMENT
			; BX = segment address of new PSP
	; 22/10/2022
	; 27/03/2019
	push	ds ; */			; preserve DS returned by DOSINIT

	push	cs	
	pop	ds

	; set up temp. critical error handler
	mov	dx,int24		; set up int 24 handler
	;;mov	ax,(SET_INTERRUPT_VECTOR*256)+24h
	;mov	ax,(SET_INTERRUPT_VECTOR<<8)|24h
	mov	ax,2524h
	int	21h

        cmp     byte [toomanydrivesflag],0 ; Q: >24 partitions?      M029
        je      short no_err		   ;  N: continue            M029
        mov     dx,TooManyDrivesMsg	   ;  Y: print error message M029
        ; 22/10/2022
	;call	print 			   ;		             M029
	; 12/12/2022
	jmp	short p_dosinit_msg ; 23/03/2019 - Retro DOS v4.0                    
no_err:
	; 12/05/2019
	;----------------------------------------------
	; 27/06/2018 - Retro DOS v3.0	; 23/03/2019 - Retro DOS v4.0
	; 22/10/2022 - Retro DOS v4.0
	; 12/12/2022
	mov	dx,BOOTMES		; Display (fake) MSDOS version message
p_dosinit_msg:
	call	print			; Print message
	;----------------------------------------------
	
	; 11/12/2022
	; 22/10/2022
	; 23/03/2019 - Retro DOS v4.0
	;pop	ds			; start of free memory
	;mov	dl,[cs:DEFAULT_DRIVE]
	
	; 11/12/2022
	; 27/03/2019
	mov	dl,[DEFAULT_DRIVE]	
	pop	ds ; */

	or	dl,dl
	;jz	short nodrvset		; bios didn't say
	jz	short ProcessConfig  ; (Retro DOS v4.0 does not contain DBLSPACE code)
	;dec	dl			; A = 0
	; 18/12/2022
	dec	dx
	mov	ah,0Eh	; SET_DEFAULT_DRIVE
	int	21h			; select the disk
			; DOS - SELECT DISK
			; DL = new default drive number (0 = A, 1 = B, etc.)
			; Return: AL = number of logical drives
nodrvset:
	; 04/01/2023 - Retro DOS 4.2 (Modified MSDOS 6.21 IO.SYS SYINIT)
	; (SYSINIT:06DFh)
	;push	ds
	sub	ax,ax
	mov	ds,ax ; 0 ; ROM BIOS Data Area
	mov	ax,[46Ch] ; timer tick count (18.2 ticks per second)
	mov	[cs:_timer_lw_],ax
	;pop	ds
	; ds <> cs

	; ---------------------

	;ifdef	dblspace_hooks
	;	....
	;	....
	;endif	

	; ---------------------

; MSDOS 6.21 IO.SYS, SYSINIT:0744h

; 23/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSINIT1.ASM, 1991)
; ----------------------------------------------------------------------------
; 22/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS SYSINIT)
; ----------------------------------------------------------------------------
; 30/12/2022 - Retro DOS v4.2 (MSDOS 6.21 IO.SYS SYSINIT)

ProcessConfig:
	;; ds = cs ; 27/03/2019
	; 11/12/2022
	; ds <> cs	

; (MSDOS 5.0 IO.SYS - SYSINIT:0746h)

	call	doconf			; do pre-scan for dos=high/low

	; 11/12/2022
	; 27/03/2019
	; ds = cs (at return from doconf)

; Now, if this is not romdos, we decide what to do with the DOS code.
; It will either be relocated to low memory, above the DOS data structures,
; or else it will be located in HiMem, in which case a stub with the DOS
; code entry points will be located in low memory. Dos_segreinit is used
; to tell the DOS data where the code has been placed, and to install the
; low memory stub if necessary. If the DOS is going to go into HiMem, we
; must first initialize it in its present location and load the installable
; device drivers. Then, if a HiMem driver has been located, we can actually
; relocate the DOS code into HiMem.
;
; For ROMDOS, if DOS=HIGH is indicated, then we need to call dos_segreinit
; to install the low memory stub (this must be done before allowing any
; device drivers to hook interrupt vectors). Otherwise, we don't need to 
; call dos_segreinit at all, since the interrupt vector table has already 
; been patched.

	; 22/10/2022 - Retro DOS v4.0
	; (MSDOS 5.0 IO.SYS - SYSINIT:0749h)
	;cmp	byte [cs:runhigh],0	; Did user choose to run low ?
	; 11/12/2022
	cmp	byte [runhigh],0
	je	short dont_install_stub	; yes, don't install dos low mem stub

;------ user chose to load high

	; 22/10/2022
	;mov	es,[cs:CURRENT_DOS_LOCATION] ; MSDOS 6.21 (& MSDOS 6.0)
	; 11/12/2022
	; ds = cs
	mov	es,[CURRENT_DOS_LOCATION]

	;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
	; 27/03/2019
	;;mov	es,[FINAL_DOS_LOCATION]

	xor	ax,ax			; ax = 0 ---> install stub
	; 11/12/2022
	; ds = cs
	;call	far [cs:dos_segreinit]	; call dos segreinit
	call	far [dos_segreinit]

	jmp	short do_multi_pass

;------ User chose to load dos low

dont_install_stub:
	; 22/10/2022
	xor	bx,bx			; M012
					; don't use int 21 call to alloc mem
	call	MovDOSLo		; move it !

	mov	ax,1			; dont install stub
	; 11/12/2022
	; ds = cs
	mov	es,[CURRENT_DOS_LOCATION]
	;mov	es,[cs:CURRENT_DOS_LOCATION] ; set_dos_final_position set it up
	;;mov	es,[cs:FINAL_DOS_LOCATION]   ; Retro DOS v4.0
	; 27/03/2019
;do_multi_pass:
	;;mov	es,[FINAL_DOS_LOCATION] 

	; 11/12/2022
	; ds =cs
	;call	far [cs:dos_segreinit]	; inform dos about new seg
	call	far [dos_segreinit]
do_multi_pass:
	call	AllocFreeMem		; allocate all the free mem
					; & update [memhi] & [area]
					; start of free memory.
	;ifdef	dblspace_hooks
	;mov	bx,0			; magic backdoor to place int hooks
	;call	cs:MagicBackdoor
	;endif

; Now, process config.sys some more.  
; Load the device drivers and install programs

	; 22/10/2022
	;inc	byte [cs:multi_pass_id]	; multi_pass_id = 1
	; 11/12/2022
	; ds = cs
	inc	byte [multi_pass_id]
	call	multi_pass		; load device drivers
	call	ShrinkUMB
	call	UnlinkUMB		; unlink all UMBs	;M002
	; 02/11/2022
	;inc	byte [cs:multi_pass_id]	; multi_pass_id = 2
	; 11/12/2022
	; ds = cs
	inc	byte [multi_pass_id]
	call	multi_pass		; was load ifs (now does nothing)

	;ifdef	dblspace_hooks
	;call	MagicPostload		; make sure Magicdrv is final placed
	;endif

	; ds = cs
	
	call	endfile			; setup fcbs, files, buffers etc

	;ifdef	dblspace_hooks
	;call	MagicSetCdss		; disable CDSs of reserved drives
	;endif

;Reset SysinitPresent flag here. This is needed for the special fix for lying
;to device drivers. This has been moved up to this point to avoid problems 
;with overlays called from installed programs

	; 11/12/2022
	; ds = cs

	;;mov	ax,Bios_Data ; 0070h
	;mov	ax,KERNEL_SEGMENT
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	es,ax			; point ES to bios data

	mov	byte [es:SysinitPresent],0 ; clear SysinitPresent flag

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;test	word [cs:install_flag],have_install_cmd ; 1
	;test	byte [cs:install_flag],1
	; 11/12/2022
	; ds = cs
	test	byte [install_flag],1
	;test	byte [cs:install_flag],have_install_cmd
					; are there install commands?
	jz	short dolast		; no, no need for further processing
	;inc	byte [cs:multi_pass_id]	; mult_pass_id = 3
	; 11/12/2022
	; ds =cs
	inc	byte [multi_pass_id]
	call	multi_pass		; execute install= commands

dolast:
	
; [area] has the segment address for the allocated memory of sysinit, confbot.
;  free the confbot area used for config.sys and sysinit itself.

; Now if DOS is supposed to run high, we actually move it into high memory 
; (if HiMem manager is available). For ROMDOS, we don't actually move
; anything, but just set up the ROM area for suballocation (or print
; a message if HiMem is not available).
;
; There is also this little hack for CPM style DOS calls that needs to
; be done when A20 is set...

	; 11/12/2022
	; ds = cs

	; 22/10/2022
	;cmp	byte [cs:runhigh],0FFh	; are we still waiting to be moved?
	; 11/12/2022
	cmp	byte [runhigh],0FFh
	jne	short _@@_ ; 09/12/2022 ; no, our job is over
	call	LoadDOSHiOrLo
_@@_:
	;cmp	byte [cs:runhigh],0	; are we running low
	; 11/12/2022
	; ds = cs
	cmp	byte [runhigh],0
	;je	short _@@@
	je	short ConfigDone	; yes, no CPM hack needed
	call	CPMHack			; make ffff:d0 same as 0:c0
_@@@:

; We are now done with CONFIG.SYS processing

ConfigDone:
	; 12/12/2022
	; 22/10/2022
	;mov	byte [cs:donotshownum],1 
					; done with config.sys.
					; do not show line number message.
	;mov	es,[cs:area]
	; 12/12/2022
	; ds = cs
	; 27/03/2019
	mov	byte [donotshownum],1
	mov	es,[area]

        mov     ah,49h ; DEALLOC	; free allocated memory for command.com
	int	21h
			; DOS - 2+ - FREE MEMORY
			; ES = segment address of area to be freed

	; 22/10/2022
	;test	word [cs:install_flag],2
	;test	word [cs:install_flag],has_installed ; sysinit_base installed?
	;test	byte [cs:install_flag],has_installed
	; 11/12/2022
	; ds = cs
	test	byte [install_flag],2 ; has_installed
	;test	byte [install_flag],has_installed
	jz	short skip_free_sysinitbase ; no.

; set block from the old_area with impossible_owner_size.
; this will free the unnecessary sysinit_base that had been put in memory to
; handle install= command.

	; 12/12/2022
        ;push	es		; BUGBUG 3-30-92 JeffPar: no reason to save ES
	;push	bx
	
	; 22/10/2022
	;mov	es,[cs:old_area]
	;mov	bx,[cs:impossible_owner_size]
	; 12/12/2022
	; ds = cs
	mov	es,[old_area]
	mov	bx,[impossible_owner_size]
	
	mov	ah,4Ah ; SETBLOCK
	int	21h
			; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block to change
			; BX = new size in paragraphs
	mov	ax,es
	dec	ax
	mov	es,ax			; point to arena
	;mov	word [es:ARENA.OWNER],8	; set impossible owner
	mov	word [es:1],8
	;mov	word [es:ARENA.NAME],'SD' ; 4453h ; System Data
	mov	word [es:8],'SD'
	
	; 12/12/2022
	;pop	bx
        ;pop     es		; BUGBUG 3-30-92 JeffPar: no reason to save ES

skip_free_sysinitbase:
	; 22/10/2022
	;cmp	byte [cs:runhigh],0
	; 12/12/2022
	; ds = cs
	cmp	byte [runhigh],0	
	je	short _@@@@

	call	InstVDiskHeader	; Install VDISK header (allocates some mem from DOS)

; ----------------------------------------------------------------------------

_@@@@:
	; 12/12/2022
	; ds = cs
	; 22/10/2022
	; 27/03/2019
	;push	cs
	;pop	ds			; point DS to sysinitseg

; set up the parameters for command

;	; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
;;ifdef	MULTI_CONFIG
;	mov	byte [config_cmd],0	; set special code for query_user
;       call    query_user		; to issue the AUTOEXEC prompt
;	jnc	short process_autoexec	; we should process autoexec normally
;	; !!!
;	or	byte [bQueryOpt],4 ; MSDOS 6.21 IO.SYS - SYSINIT:081Fh
;       ; !!!
;	call    disable_autoexec        ; no, we should disable it
;process_autoexec:
;;endif	; !!!
;	call	CheckQueryOpt	; MSDOS 6.21 IO.SYS - SYSINIT:0827h	
;	; !!!

	; 22/10/2022 
	;mov     cl,[command_line]
        ;mov     ch,0
        ;inc     cx
        ;mov     si,command_line	
	;add     si,cx
        ;mov     byte [si],cr	; cr-terminate command line

	; 22/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0809h)

	;;;;

	; 30/12/2022 - Retro DOS 4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:0813h)
	; ds = cs
	; push	cs
	; pop	ds

	mov	byte [config_cmd],0	; set special code for query_user
	call    query_user		; to issue the AUTOEXEC prompt
	jnc	short process_autoexec	; we should process autoexec normally
	; !!!
	or	byte [bQueryOpt],4 ; MSDOS 6.21 IO.SYS - SYSINIT:081Fh
	; !!!
	call    disable_autoexec        ; no, we should disable it
process_autoexec:
	; !!!
	call	CheckQueryOpt	; MSDOS 6.21 IO.SYS - SYSINIT:0827h	

	;mov     cl,[command_line]
	; 30/12/2022
	mov	si,command_line
	mov	cl,[si]
	mov     ch,0
	inc     cx
	;mov	si,command_line
	add     si,cx
	mov     byte [si],cr	; cr-terminate command line
	
	;;;;		

; 30/12/2022 - Retro DOS v4.2
%if 0
	;mov	si,(offset command_line+1)
	mov	si,command_line+1
	push    ds
	pop     es
	mov     di,si
	mov     cl,0FFh ; -1
_@_loop:
	inc     cl ; +1
	lodsb
	stosb
	or      al,al
	jnz     short _@_loop
	dec     di
	mov     al,0Dh
	stosb			; cr-terminate command line
	mov     [command_line],cl ; command line length (except CR)

%endif

; ----------------------------------------------------------------------------

;   Once we get to this point, the above code, which is below "retry"
;   in memory, can be trashed (and in fact is -- see references to retry
;   which follow....)

retry:
	mov	dx,commnd	; now pointing to file description

; we are going to open the command interpreter and size it as is done in
; ldfil. the reason we must do this is that sysinit is in free memory. if
; there is not enough room for the command interpreter,exec will probably
; overlay our stack and code so when it returns with an error sysinit won't be
; here to catch it. this code is not perfect (for instance .exe command
; interpreters are possible) because it does its sizing based on the
; assumption that the file being loaded is a .com file. it is close enough to
; correctness to be usable.

; first, find out where the command interpreter is going to go.

	push	dx		; save pointer to name
	mov	bx,0FFFFh
	mov	ah,48h	; ALLOC
        int     21h             ; get biggest piece
	mov	ah,48h	; ALLOC
	int	21h		; second time gets it
	jc	short memerrjx	; oooops

	mov	es,ax
	mov	ah,49h	; DEALLOC
	int	21h		; give it right back
	mov	bp,bx

; es:0 points to block,and bp is the size of the block in para.

; we will now adjust the size in bp down by the size of sysinit.
; we need to do this because exec might get upset if some of the exec
; data in sysinit is overlayed during the exec.

	; 22/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:083Bh)
        mov     bx,[MEMORY_SIZE] ; get location of end of memory
	mov	ax,cs		 ; get location of beginning of sysinit

; Note that the "config_wrkseg" environment data is a segment in
; unallocated memory (as of the Dealloc of [area], above). This is ideal
; in one sense, because Exec is going to make a copy of it for COMMAND.COM
; anyway, and no one has responsibility for freeing "config_wrkseg". But
; we need to make sure that there's no way Exec will stomp on that data
; before it can copy it, and one way to do that is to make the available
; memory calculation even more "paranoid", by subtracting "config_wrkseg"
; from the "memory_size" segment value (which is typically A000h) instead
; of the current sysinit CS....
;
; The reason I use the term "paranoid" is because this code should have
; slid the data required by Exec up to the very top of memory, because as
; it stands, you have to have sizeof(COMMAND.COM) PLUS 64K to load just
; COMMAND.COM (64k is about what sysinit, and all the goop above sysinit,
; consumes). Now it's just a little worse (65K or more, depending on
; the size of your CONFIG.SYS, since the size of the environment workspace
; is determined by the size of CONFIG.SYS.... -JTP

	; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21, IO.SYS)
	; (SYSINIT:0858h)
	mov	cx,[config_envlen]
        jcxz	no_env		; use config_wrkseg only if there's env data
        mov	ax,[config_wrkseg]	

	; 22/10/2022
	;mov	cx,[config_envlen]
        ;jcxz	no_env		; use config_wrkseg only if there's env data
        ;mov	ax,[config_wrkseg]
;no_env:
	; 22/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:0841h)
no_env:
	; 30/12/2022
	; (MSDOS 6.21 IO.SYS SYSINIT:0861h)
  	sub     bx,ax           ; bx is size of sysinit in para
	add	bx,11h		; add the sysinit php
	sub	bp,bx		; sub sysinit size from amount of free memory
	jc	short memerrjx	; if there isn't even this much memory, give up

        ;mov	ax,(OPEN<<8)	; open the file being execed
        mov	ax,3D00h
	stc                     ; in case of int 24
	int	21h
	jc	short comerr	; ooops
			; DOS - 2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX -> ASCIZ filename
			; AL = access mode
			; 0 - read
	; 22/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:0852h)
        mov     bx,ax           ; handle in bx

;   If the standard command interpreter is being used, verify it is correct

	; 30/12/2022 - Retro DOS v4.2
	; (MSDOS 6.21 IO.SYS, SYSINIT:0874h)
	cmp	byte [newcmd],0	; was a new shell selected?
	jne	short skip_validation ; yes
	mov	dx,retry-4
	mov	cx,4		;
	mov	ah,READ		;
	int	21h		;
	cmp	byte [retry-4],0E9h
	jne	short comerr
	; 20/04/2019 - Retro DOS v4.0
	; 30/12/2022 
	;cmp	byte [retry-1],64h ; MSDOS 6.21 IO.SYS - SYSINIT:088Ch
				; .. COMMAND.COM Version 6.20 (14h&0Fh)	
	cmp	byte [retry-1],((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
	jne	short comerr	;

	; 22/10/2022
	;cmp	byte [newcmd],0	; was a new shell selected?
	;jne	short skip_validation ; yes
	;mov	dx,retry-4
	;mov	cx,4		;
	;mov	ah,READ		;
	;int	21h		;
	;cmp	byte [retry-4],0E9h
	;jne	short comerr
	;; 20/04/2019 - Retro DOS v4.0
	;cmp	byte [retry-1],64h ; MSDOS 6.21 IO.SYS - SYSINIT:088Ch
	;;cmp	byte [retry-1],((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
	;jne	short comerr	;

;skip_validation:
	; 22/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:0854h)
skip_validation:
	; 30/12/2022
	; (MSDOS 6.21 IO.SYS SYSINIT:0893h)
	xor	cx,cx
	xor	dx,dx
	;mov	ax,(LSEEK<<8)|2
	mov	ax,4202h
	stc			;in case of int 24
	int	21h		; get file size in dx:ax
	jc	short comerr
				; convert size in dx:ax to para in ax
	add	ax,15		; round up size for conversion to para
	adc	dx,0
	call	off_to_para
	mov	cl,12
	shl	dx,cl		; low nibble of dx to high nibble
	or	ax,dx		; ax is now # of para for file
	add	ax,10h		; 100h byte php
	cmp	ax,bp		; will command fit in available mem?
	jb	short okld	; jump if yes.

; 30/12/2022
%if 0
	; 22/10/2022
memerrjx:	; (MSDOS 5.0 IO.SYS SYSINIT:0876h)
	;jmp	memerr	; (MSDOS 5.0 IO.SYS SYSINIT:34D5h)
	; 02/11/2022
	;jmp	mem_err
	; 11/12/2022
	; ds = cs
	jmp	mem_err2
%endif
	; 30/12/2022
	; (MSDOS 6.21, IO.SYS, SYSINIT:08B5h)
memerrjx:
	mov	dx,badmem 	; "Configuration too large for memory"
	call	print
	jmp     short continue

okld:
	mov	ah,3Eh ; CLOSE
	int	21h		; close file

	; 22/10/2022
	pop	dx	; (MSDOS 5.0 IO.SYS SYSINIT:087Dh)

	; 24/03/2019

	push	cs		; point es to sysinitseg
	pop	es
        mov     bx,COMEXE	; point to exec block
	; 22/10/2022
	;pop	dx              ; recover pointer to name

;;ifdef	MULTI_CONFIG

;   If there's any environment data in "config_wrkseg", pass it to shell;
;   there will be data if there were any valid SET commands and/or if a menu
;   selection was made (in which case the CONFIG environment variable will be
;   set to that selection).

	; 23/10/2022
	;mov	cx,[config_envlen]
	;jcxz	no_envdata
        ;mov	cx,[config_wrkseg]
;no_envdata:
	;;mov	[bx+EXEC0.ENVIRON],cx
	;mov	[bx],cx

;;endif	;MULTI_CONFIG

	; 30/12/2022 - Retro DOS v4.2
	; (MSDOS 6.21 IO.SYS SYSINIT:08C7h)
	mov	cx,[config_envlen]
	jcxz	no_envdata
        mov	cx,[config_wrkseg]
no_envdata:
	;mov	[bx+EXEC0.ENVIRON],cx
	mov	[bx],cx	
	
	; 23/10/2022
	; (MSDOS 5.0 IO.SYS SYSINIT:0883h)

	;mov	[bx+EXEC0.COM_LINE+2],cs ; set segments
	mov	[bx+4],cs
	;mov	[bx+EXEC0.5C_FCB+2],cs
	mov	[bx+8],cs
	;mov	[bx+EXEC0.6C_FCB+2],cs
	mov	[bx+12],cs

	;mov	ax,(EXEC<<8) + 0
	; 23/10/2022
	xor	ax,ax
	mov	ah,4Bh        

	stc                     ; in case of int 24
        int     21h             ; go start up command
			; DOS - 2+ - LOAD OR EXECUTE (EXEC)
			; DS:DX -> ASCIZ filename
			; ES:BX -> parameter block
			; AL = subfunc: load & execute program
	;push	cs
	;pop	ds

	; 23/10/2022
	;push	dx		; push to balance fall-through pop

; note fall through if exec returns (an error)
comerr:
	; 23/10/2022
;;ifdef	MULTI_CONFIG
	;cmp	byte [commnd4],0
	;je	short comerr2	; all defaults exhausted, print err msg
	;cmp	byte [newcmd],0
	;je	short continue	; don't print err msg for defaults just yet
;comerr2:
;;endif

	; 30/12/2022 - Retro DOS v4.2
	push	cs
	pop	ds
	cmp	byte [commnd4],0
	je	short comerr2	; all defaults exhausted, print err msg
	cmp	byte [newcmd],0
	je	short continue	; don't print err msg for defaults just yet
comerr2:
	push	dx ; 30/12/2022

	; 23/10/2022
        mov     dx,badcom	; want to print command error
	call	badfil
	
	pop	dx  ; 30/12/2022
continue:
	; 23/10/2022
	;pop	dx

; 30/12/2022
%if 0

;;ifndef MULTI_CONFIG
	;jmp	stall
	; 24/10/2022
stall:		; (MSDOS 5.0 IO.SYS, SYSINIT:0899h)
	jmp	short stall
;;else

%endif
	
; 30/12/2022 (MSDOS 6.21 SYSINIT, Retro DOS v4.2)
;%if 1
; 23/10/2022 (MSDOS 5.0 SYSINIT, Retrodos v4.0)
;%if 0	
	mov	ah,GET_DEFAULT_DRIVE ; 19h
	int	21h             ;
	add	al,'A'          ;
	mov	dl,al           ; DL == default drive letter
	mov	si,commnd2
	cmp	byte [newcmd],0 ; if a SHELL= was given
	jne	short do_def2	; then try the 2nd alternate;
	mov	byte [si],0	; otherwise, the default SHELL= was tried,
	jmp	short do_def3   ; which is the same as our 2nd alt, so skip it
do_def2:			
	cmp	byte [si],0	; has 2nd alternate been tried?
        jne	short do_alt    ; no
do_def3:
	mov	si,commnd3
	cmp	byte [si],0	; has 3rd alternate been tried?
	jne	short do_alt	; no
	mov	si,commnd4
	cmp	byte [si],0	; has 4th alternate been tried?
	jne	short do_alt	; no
	push	dx              ;
	mov	dx,badcomprmpt
	call	print		;
	pop	dx              ; recover default drive letter in DL
request_input:			;
	mov	ah,STD_CON_OUTPUT
	int	21h             ;
	push	dx              ;
	mov	dl,'>'          ;
	int	21h             ;
	mov	bl,[tmplate+1]	;
	mov	bh,0            ;
	mov	byte [commnd+bx],0Dh
	mov	dx,tmplate
	mov	ah,STD_CON_STRING_INPUT
	int	21h             ; read a line of input
	mov	dx,crlfm	;
	call	print           ;
	pop	dx              ;
	mov	bl,[tmplate+1]	;
	or	bl,bl           ; was anything typed?
	jz	short request_input ;
	mov	byte [newcmd],1 ; disable validation for user-specified binaries
	mov	byte [commnd+bx],0 ; NULL-terminate it before execing it
	mov	word [command_line],0D00h
	jmp	short do_exec   ;
do_alt:
	push	ds
	pop	es
	mov	byte [newcmd],0 ; force validation for alternate binaries
	mov	di,commnd	;
do_alt1:
	lodsb			; copy the alternate, zapping it as we go,
	mov	byte [si-1],0	; so that we know it's been tried
	stosb 			;
	or	al,al		;
	jnz	short do_alt1	;
	mov	di,command_line
	cmp	byte [si+2],':'
	jne	short do_alt2	;
	mov	[si+1],dl	; stuff default drive into alt. command line
do_alt2:			;
	lodsb			;
	stosb			;
	or	al,al           ;
	jnz	short do_alt2   ;
	mov	byte [di-1],cr

;;   Last but not least, see if we need to call disable_autoexec

	; MSDOS 6.0 (SYSINIT1.ASM)
	;cmp	[command_line-1],0
        ;jne	short do_exec   ;
        ;mov	[command_line-1],'/'
	;call	disable_autoexec ;

	; MSDOS 6.21 IO.SYS (SYSINIT:0994h)
	mov	byte [dae_flag],0 ; 24/03/2019 - Retro DOS v4.0 	
	call	disable_autoexec
	call	CheckQueryOpt	; 24/03/2019 - Retro DOS v4.0
do_exec:
	jmp	retry		;

;;endif	;MULTI_CONFIG

;%endif ; 23/10/2022 (MSDOS 5.0 SYSINIT)
;%endif ; 30/12/2022 (MSDOS 6.21 SYSINIT)

; 24/03/2019 - Retro DOS v4.0

; ----------------------------------------------------------------------
; procedure : AllocFreeMem
;
; Allocate Max memory from DOS to find out where to load DOS.
; DOS is at temporary location when this call is being made
;
; Inputs : None
; Outputs: The biggest chunk of memory is allocated (all mem at init time)
;	   [area] & [memhi] set to the para value of the start of the
;	   free memory.
;
; Uses   : AX, BX
;
; ----------------------------------------------------------------------
	
	; 30/12/2022 - Retro DOS v4.2
	; (MSDOS 6.21 IO.SYS, SYSINIT:09A2h)

	; 23/10/2022
AllocFreeMem:
	mov	bx,0FFFFh
	mov	ah,48h ; ALLOC
	int	21h			; first time fails
	mov	ah,48h ; ALLOC
	int	21h			; second time gets it
	; 11/12/2022
	; ds = cs
	;mov	[cs:area],ax
	;mov	[cs:memhi],ax		; memhi:memlo now points to
	mov	[area],ax
	mov	[memhi],ax		; memhi:memlo now points to			
	retn				; start of free memory
				
	; include msbio.cl6
; ----------------------------------------------------------------------
DOSLOMSG:
	db	'HMA not available: Loading DOS low',0Dh,0Ah,'$'
FEmsg:
	db	'Fatal Error: Cannot allocate Memory for DOS',0Dh,0Ah,'$'

; ----------------------------------------------------------------------
;
; procedure : LoadDOSHiOrLo
;
;		Tries to move DOS into HMA. If it fails then loads
;		DOS into Low memory. For ROMDOS, nothing is actually
;		moved; this just tries to allocate the HMA, and prints
;		a message if this is not possible.
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
LoadDOSHiOrLo:
	; 27/03/2019 - Retro DOS v4.0
	; ds = cs
	call	TryToMovDOSHi		; Try moving it into HMA (M024)
	;jc	short LdngLo		; If that don't work...
	;retn
	; 18/12/2022
	jnc	short LoadDosHi_ok
LdngLo:
	; 23/10/2022
	;push	cs
	;pop	ds
	; 11/12/2022
	; ds = cs
	mov	ah,9
	mov	dx,DOSLOMSG		; inform user that we are
	int	21h			; loading low

;ifndef ROMDOS
	; actually move the dos, and reinitialize it.

	mov	bx,1				; M012
						;  use int 21 alloc for mem
	call	MovDOSLo
	; 11/12/2022
	; ds = cs
	;mov	es,[cs:CURRENT_DOS_LOCATION]	; give dos its temporary loc.
	; 23/10/2022
	mov	es,[CURRENT_DOS_LOCATION]
	;;mov	es,[cs:FINAL_DOS_LOCATION]  ; 24/03/2019 - Retro DOS v4.0
	;mov	es,[FINAL_DOS_LOCATION] ; 27/03/2019
	xor	ax,ax				; ax = 00 ---> install stub
	; 11/12/2022
	; ds = cs
	;call	far [cs:dos_segreinit]		; call dos segreinit
	call	far [dos_segreinit] ; 27/03/2019
	
;endif ; ROMDOS
	; 23/10/2022
	;mov	byte [cs:runhigh],0		; mark that we are running lo
	; 11/12/2022
	; ds = cs
	mov	byte [runhigh],0 ; 27/03/2019
LoadDosHi_ok:	; 18/12/2022
	retn

; ----------------------------------------------------------------------
;
; procedure : TryToMovDOSHi
;
;		This tries to move DOS into HMA.
;		Returns CY if it failed.
;		If it succeeds returns with carry cleared.
;
;		For ROMDOS, dos_segreinit must be called again to allow
;		the A20 switching code in the low mem stub to be installed.
; 
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (MSDOS 5.0 IO.SYS - SYSINIT:092Ah)
TryToMovDOSHi:
	; 11/12/2022
	; 27/03/2019 - Retro DOS v4.0
	; ds = cs
	call	MovDOSHi
	jc	short ttldhx

;ifndef ROMDOS
	; 23/10/2022
	;mov	es,[cs:CURRENT_DOS_LOCATION] ; give dos its temporary loc.
	;;mov	es,[cs:FINAL_DOS_LOCATION] ; 24/03/2019 - Retro DOS v4.0
	; 11/12/2022
	; ds = cs
	mov	es,[CURRENT_DOS_LOCATION]
;else
;	..
;endif ; ROMDOS

	; 11/12/2022
	; ds = cs
	xor	ax,ax			; ax = 00 ---> install stub
	;call	far [cs:dos_segreinit]	; call dos segreinit
	call	far [dos_segreinit]
	;mov	byte [cs:runhigh],1
	mov	byte [runhigh],1
	clc
ttldhx:
	retn

; ----------------------------------------------------------------------
;
; procedure : MovDOSHi
;
;		Tries to allocate HMA and Move DOS/BIOS code into HMA
;		For ROMDOS, the code is not actually moved, but the
;		HMA is allocated and prepared for sub-allocation.
;
;		Returns : CY if it failed
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
MovDOSHi:
	; 14/05/2019
	; 27/03/2019 - Retro DOS v4.0
	; ds = cs
	call	AllocHMA
	jc	short mdhx			; did we get HMA?
	mov	ax,0FFFFh			; yes, HMA seg = 0ffffh
	mov	es,ax

;ifndef ROMDOS
	; actually move the BIOS and DOS

	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
	; 24/03/2019
	
	; 23/10/2022
	call	MovBIOS				; First move BIOS into HMA

	; ES:DI points to free HMA after BIOS
	
	; 14/05/2019
	; 24/03/2019 - Retro DOS v4.0
	;xor	di,di
	
	; 23/10/2022
	;mov	cx,[cs:hi_doscod_size]		; pass the code size of DOS
	; 11/12/2022
	; ds = cs
	mov	cx,[hi_doscod_size]		; when it is in HMA
	call	MovDOS				; and move it

	; ES:DI points to free HMA after DOS
;else
;	; allocate space at beginning of HMA to allow for CPMHack
;
;	mov	di,0E0h				; room for 5 bytes at ffff:d0
;
;endif ; ROMDOS

	call	SaveFreeHMAPtr			; Save the Free HMA ptr
	clc
mdhx:
	retn

; ----------------------------------------------------------------------
;
; procedure : MovDOSLo
;
;		Allocates memory from DOS and moves BIOS/DOS code into it
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;ifndef ROMDOS

MovDOSLo:
	; 14/05/2019
	; 27/03/2019 - Retro DOS v4.0
	; ds = cs
	call	AllocMemForDOS			; incestuosly!!!
	
	; 23/10/2022
	; 14/05/2019
	;inc	ax  ; skip MCB
	
	mov	es,ax				; pass the segment to MovBIOS
	; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
	; 24/03/2019
	
	; 23/10/2022
	call	MovBIOS

;------ ES:DI points memory immediately after BIOS

	; 14/05/2019
	; NOTE: 
	;     Order of (RETRO) DOS kernel sections at memory:
	;	BIOSDATA+BIOSCODE+BIOSDATAINIT+DOSDATA+DOSCODE(LOW)

	; 24/03/2019 - Retro DOS v4.0
	;xor	di,di	

	; 23/10/2022
	;mov	cx,[cs:lo_doscod_size]		; DOS code size when loaded
	; 11/12/2022
	; ds = cs
	mov	cx,[lo_doscod_size]		; low
	;call	MovDOS
	;retn
	; 11/12/2022
	;jmp	short MovDOS

;endif ; ROMDOS

; 11/12/2022

; ----------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
; ----------------------------------------------------------------------

	; 11/12/2022
	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;ifndef ROMDOS

MovDOS:
	; 14/05/2019
	; 27/03/2019 - Retro DOS v4.0

	; 11/12/2022
	; ds = cs

	; 23/10/2022
	;push	ds ; *//
	
	push	es
	push	di

	; 11/12/2022
	push	ds ; *// ; 11/12/202

	; 29/04/2019
	lds	si,[dosinit] ; 11/12/2022
	; 23/10/2022
	;lds	si,[cs:dosinit]
	;;mov	ax,si

	rep	movsb

	pop	ds ; *// ; 11/12/2022

	pop	bx				; get back offset into which
						;  DOS was moved

	mov	ax,[cs:dosinit]			; get the offset at which DOS
						;  wants to run
	sub	ax,bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx,ax				; Adjust segment
	
	; 11/12/2022
	; 23/10/2022
	;mov	[cs:CURRENT_DOS_LOCATION],bx	; and save it
	;;mov	[cs:FINAL_DOS_LOCATION],bx
	; 11/12/2022
	mov	[CURRENT_DOS_LOCATION],bx
		
	; 27/03/2019
	;pop	ds ; *//
	; ds = cs
	;mov	[FINAL_DOS_LOCATION],bx

	retn

;endif ;ROMDOS

; NOTE: Retro DOS v4.0 does not move BIOS (IO.SYS) to HMA
; 24/03/2019
; ----------------------------------------------------------------------
;
; procedure : MovBIOS
;
;		Moves BIOS code into requested segment
;
;	In : ES - segment to which BIOS is to be moved
;		  ( it moves always into offset BCode_Start)
;
;	Out : ES:DI - pointer to memory immediately after BIOS
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;ifndef ROMDOS

MovBIOS: ; proc	near
	; 11/12/2022
	push	ds ; ds = cs	
	;
	; 23/10/2022
	mov	ds,[cs:temp_bcode_seg]		; current BIOS code seg
	;mov	si,BCODE_START ; mov si,30h
	; 09/12/2022
	mov	si,BCODESTART
	mov	di,si
	mov	cx,BCODE_END ; mov cx,1A60h
	sub	cx,si				; size of BIOS
	shr	cx,1				; Both the labels are para
						;  aligned
	rep	movsw
	
	; 11/12/2022
	pop	ds ; ds = cs
	;
	push	es
	push	di				; save end of BIOS
	mov	ax,es
	;
	; 11/12/2022
	;mov	[cs:BCodeSeg],ax		; save it for later use
	;;call	dword ptr cs:_seg_reinit_ptr
	;call	far [cs:seg_reinit_ptr]		; far call to seg_reinit (M022)
	; ds = cs
	mov	[BCodeSeg],ax
	call	far [seg_reinit_ptr]
	;
	pop	di
	pop	es				; get back end of BIOS
	retn

;MovBIOS endp

;endif ; ROMDOS

; 11/12/2022
%if 0

; 24/03/2019

; ----------------------------------------------------------------------
;
; procedure : MovDOS
;
;		Moves DOS code into requested area
;
;	In : ES:DI - pointer to memory where DOS is to be moved
;	     CX    - size of DOS code to be moved
;
;	Out : ES:DI - pointer to memory immediately after DOS
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;ifndef ROMDOS

MovDOS:
	; 14/05/2019
	; 27/03/2019 - Retro DOS v4.0

	; 11/12/2022
	; ds = cs

	; 23/10/2022
	;push	ds ; *//
	
	push	es
	push	di

	; 11/12/2022
	push	ds ; *// ; 11/12/202

	; 29/04/2019
	lds	si,[dosinit] ; 11/12/2022
	; 23/10/2022
	;lds	si,[cs:dosinit]
	;;mov	ax,si

	rep	movsb

	pop	ds ; *// ; 11/12/2022

	pop	bx				; get back offset into which
						;  DOS was moved

	mov	ax,[cs:dosinit]			; get the offset at which DOS
						;  wants to run
	sub	ax,bx
	call	off_to_para
	pop	bx				; get the segment at which
						;  we moved DOS into
	sub	bx,ax				; Adjust segment
	
	; 11/12/2022
	; 23/10/2022
	;mov	[cs:CURRENT_DOS_LOCATION],bx	; and save it
	;;mov	[cs:FINAL_DOS_LOCATION],bx
	; 11/12/2022
	mov	[CURRENT_DOS_LOCATION],bx
		
	; 27/03/2019
	;pop	ds ; *//
	; ds = cs
	;mov	[FINAL_DOS_LOCATION],bx

	retn

;endif ;ROMDOS

%endif

; ----------------------------------------------------------------------
;
; procedure : AllocMemForDOS
;
;		Allocate memory for DOS/BIOS code from DOS !!!
;
;	Out : AX - seg of allocated memoryblock
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

;ifndef ROMDOS

AllocMemForDOS:
	; 11/12/2022
	; 14/05/2019
	; 27/03/2019 - Retro DOS v4.0
	; ds = cs
	;mov	ax,BCode_end
	;sub	ax,BCode_start		; BIOS code size
	; 23/10/2022
	mov	ax,BCODE_END ; 1A60h	; 1A70h for MSDOS 6.21
					; 30/12/2022
	;sub	ax,BCODE_START ; 30h
	; 09/12/2022
	sub	ax,BCODESTART 
	; 24/03/2019 - Retro DOS v4.0 
	; 02/11/2022
	;add	ax,[cs:lo_doscod_size]	; DOS code size
	; 11/12/2022
	; ds = cs
	add	ax,[lo_doscod_size]
	add	ax,15
	call	off_to_para			; convert to para
	; 23/10/2022
	; 14/05/2019
	;inc	ax ; + 1 paragraph for MCB
	or	bx,bx				; M012
	mov	bx,ax				;  can we use int 21 for alloc
	jz	short update_arena		; M012
	mov	ah,48h				; request DOS
	int	21h
	jc	short FatalErr			; IF ERR WE ARE HOSED
 	; 23/10/2022
	; 24/03/2019 - Retro DOS v4.0 (ORG 0)
	sub	ax,3				; Take care ORG 30h of
						;  BIOS code
	mov	es,ax
	;mov	word [es:20h+ARENA.OWNER],08h	; mark it as system
	;mov	word [es:20h+ARENA.NAME],'SC'	;  code area
	; 14/05/2019
	;mov	word [es:ARENA.OWNER],08h	; mark it as system
	;mov	word [es:ARENA.NAME],'SC'	;  code area
	; 23/10/2022
	mov	word [es:20h+1],08h		; mark it as system
	mov	word [es:20h+8],'SC'		;  code area

	retn

; BUGBUG -- 5 Aug 92 -- chuckst -- Allocating space for DOS
;	  using DOS itself causes an arena to be generated.
;	  Unfortunately, certain programs (like PROTMAN$)
;	  assume that the device drivers are loaded into
;	  the first arena. For this reason, MagicDrv's
;	  main device driver header arena is manually
;	  truncated from the arena chain, and the space
;	  for DOS is allocated using the following
;	  simple code, which also assumes that the
;	  first arena is the free one where DOS's low
;	  stub will go.
;
; M012 : BEGIN

	; 23/10/2022
update_arena:
	push	ds ; ds = cs
	push	di
	push	cx
	push	dx
	; 23/10/2022
	;lds	di,[cs:DOSINFO]			; get ptr to DOS var
	; 11/12/2022
	; ds = cs 
	lds	di,[DOSINFO] ; 27/03/2019	
	dec	di
	dec	di				; Arena head is immediately
						;  before sysvar
	mov	es,[di]				; es = arena head
	;mov	cx,[es:ARENA.SIZE]		; cx = total low mem size
	mov	cx,[es:3]
	cmp	cx,bx				; is it sufficient ?
	jb	short FatalErr			; no, fatal error

	;mov	dl,[es:ARENA.SIGNATURE]
	mov	dl,[es:0]
	mov	ax,es
	add	ax,bx				; ax = new arena head
	mov	[di],ax				; store it in DOS data area
	mov	ds,ax
	;mov	[ARENA.SIGNATURE],dl		; type of arena
	mov	[0],dl
	;mov	word [ARENA.OWNER],0		; free
	mov	word [1],0
	sub	cx,bx				; size of the new block
	;mov	[ARENA.SIZE],cx			; store it in the arena
	mov	[3],cx
	mov	ax,es				; return seg to the caller
	; 23/10/2022
	;; 24/03/2019 - Retro DOS v4.0 (ORG 0)	; Take care ORG 30h of
	sub	ax,3				;  BIOS code
	pop	dx
	pop	cx
	pop	di
	pop	ds ; ds = cs
	retn
;
; M012 : END
;
FatalErr:
	push	cs
	pop	ds
	mov	dx,FEmsg
	mov	ah,9
	int	21h 		; DOS - PRINT STRING
				; DS:DX -> string terminated by "$"
	; 30/12/2022 (MSDOS 6.21 SYSINIT)
	jmp	stall
	; 23/10/2022 (MSDOS 5.0 SYSINIT)
	;cli
	;hlt

;endif ;ROMDOS

; 25/03/2019 - Retro DOS v4.0

; ----------------------------------------------------------------------
;
; procedure : AllocHMA
;
;	grab_the_hma tries to enable a20 and make sure there is memory
;	  up there. If it gets any sort of error, it will return with
;	  carry set so that we can resort to running low.
;
;	It also returns ES: -> 0ffffh if it returns success
;
; ----------------------------------------------------------------------

AllocHMA:
;	cas note:  The pre-286 check is no longer needed here since the
;		   presence of XMS is sufficient. However, this code hasn't
;		   been deleted because it can be recycled for skipping the
;		   extra pass of CONFIG.SYS and assuming we're running low
;		   in the case of a pre-286.

;;	see if we're running on a pre-286. If not, force low.
;
;	xor	ax,ax
;	pushf			; save flags (like int)
;	push	ax
;	popf
;	pushf
;	pop	ax
;	popf			; restore original flags (like int)
;	and	ax,0F000h
;	cmp	ax,0F000h	; 8088/8086?
;	jz	short grab_hma_error

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0A26h)

	push	ds
	;;mov	ax,Bios_Data
	;mov	ax,KERNEL_SEGMENT
	; 21/10/2022
	mov	ax,DOSBIODATASEG
	mov	ds,ax

	call	IsXMSLoaded
	jnz	short grabhma_error

	mov	ax,4310h
	int	2Fh		; get the vector into es:bx
		; - Multiplex - XMS - GET DRIVER ADDRESS
		; Return: ES:BX -> driver entry point

	mov	[xms],bx
	;mov	[0Eh], bx
	mov	[xms+2],es
	;mov	[10h],es

	mov	ah,1		; request HMA
	mov	dx,0FFFFh
	;call	dword ptr ds:0Eh
	call	far [xms]
	dec	ax
	jz	short allocHMA_1 ; error if not able to allocate HMA

;------ Himem may be lying because it has allocated mem for int 15

	mov	ah,88h
	int	15h
		; Get Extended Memory Size
		; Return: CF clear on success
		; AX = size of memory above 1M in K
	cmp	ax,64		; less than 64 K of hma ?
	;jb	short grabhma_error
	; 11/12/2022
	jb	short grabhma_err ; cf=1
allocHMA_1:
	mov	ah,5		; localenableA20
	;call	dword ptr ds:0Eh
	call	far [xms]
	dec	ax
	jnz	short grabhma_error ; error if couldn't enable A20

	call	IsVDiskInstalled
	jz	short grabhma_error ; yes, we cant use HMA

	mov	ax,0FFFFh
	mov	es,ax
	mov	word [es:10h],1234h ; see if we can really read/write there
	cmp	word [es:10h],1234h
	;jne	short grabhma_error ; don't try to load there if XMS lied
	; 11/12/2022
	je	short allocHMA_ok	

; 11/12/2022
;	; 11/12/2022
;	; cf=0
;	;clc
;	pop	ds
;	retn

grabhma_error:
	stc
	; 11/12/022
grabhma_err:	; cf=1
allocHMA_ok:	; cf=0
	pop	ds
	retn

; ----------------------------------------------------------------------
;
; procedure : IsXMSLoaded
;
;             Checks whether a XMS driver is loaded
;
; Returns : Z flag set if XMS driver loaded
;           Z flag reset if no XMS drivers are present
;
; ----------------------------------------------------------------------

IsXMSLoaded:
	mov	ax,4300h
	int	2Fh		; - Multiplex - XMS - INSTALLATION CHECK
				; Return: AL = 80h XMS driver installed
				; AL <> 80h no driver
	cmp	al,80h		; XMS installed?
	retn

; ----------------------------------------------------------------------
; procedure : FTryToMovDOSHi
;
;		Called from HMA suballoc calls
;	
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0A84h)

FTryToMovDOSHi:	; proc	far

	push	ax
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	ds
	push	es

	; 23/10/2022
	; 27/03/2019 - Retro DOS v4.0
	; 11/12/2022
	push	cs
	pop	ds

	;cmp	byte [cs:runhigh],0FFh
	; 11/12/2022
	cmp	byte [runhigh],0FFh
	jne	short _ftymdh_1

	; ds = cs
	call	TryToMovDOSHi
_ftymdh_1:
	pop	es
	pop	ds
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx
	pop	ax

	retf

; ----------------------------------------------------------------------
;
; following piece of code will be moved into a para boundary. And the para
; address posted in seg of int 19h vector. Offset of int 19h will point to
; VDint19. This is to protect HMA from apps which use VDISK header method
; to determine free extended memory.
;
; For more details read "power programming" column by Ray Duncan in the
; May 30 1989 issue of PC Magazine (pp 377-388) [USING EXTENDED MEMORY,PART 1]
;
; ----------------------------------------------------------------------

StartVDHead:
;-------------- what follows is a dummy device driver header (not used by DOS)

	dd	0		; link to next device driver
	dw	8000h		; device attribute
	dw	0		; strategy routine offset
	dw	0		; interrupt routine offset
	db	1		; number of units
	;db	7 dup(0) 
	times	7 db 0 		; reserved area
VDiskSig1:
	db	'VDISK'

VLEN1	equ	($-VDiskSig1)

	db	'  V3.3'	; vdisk label
	;db	15 dup (0)	; pad
	times	15 db 0
	dw	0		; bits 0-15 of free HMA
	db	11h		; bits 16-23 of free HMA (1M + 64K)
VDInt19:
	db	0EAh		; jmp to old vector
OldVDInt19:
	dd	0		; Saved int 19 vector

EndVDHead: ; label byte

VDiskHMAHead:	
	db	0,0,0		; non-bootable disk
VDiskSig2:
	db	'VDISK'

VLEN2	equ	($-VDiskSig2)

	db	'3.3'		; OEM - signature
	dw	128		; number of bytes/sector
	db	1		; sectors/cluster
	dw	1		; reserved sectors
	db	1		; number of FAT copies
	dw	64		; number of root dir entries
	dw	512		; number of sectors
	db	0FEh		; media descriptor
	dw	6		; number of sectors/FAT
	dw	8		; sectors per track
	dw	1		; number of heads
	dw	0		; number of hidden sectors
	dw	440h		; Start of free HMA in K (1M+64K)

EndVDiskHMAHead: ; label byte

; ----------------------------------------------------------------------
;
; procedure : InstVDiskHeader
;
;             Installs the VDISK header to reserve the 64k of HMA
;	      It puts a 32 byte header at 10000:0 and
;	      another header at (seg of int19):0
;
; Inputs : None
;
; Outputs : None
;
; USES : DS,SI,AX,CX,DX
;
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

InstVDiskHeader:
	xor	ax,ax
	mov	ds,ax			; seg of int vect table

;-------------- save old int 19 vector

	; 23/10/2022
	mov	ax,[19h*4]
	;mov	[OldVDInt19],ax
	mov	[cs:OldVDInt19],ax
	mov	ax,[19h*4+2]
	;mov	[OldVDInt19+2],ax
	mov	[cs:OldVDInt19+2],ax

;-------------- calculate seg of new int 19 handler

	mov	ah,48h			; allocate memory
	;mov	bx,(EndVDHead-StartVDHead+15)>>4
	; 23/10/2022
	mov	bx,4
	int	21h

;	if carry, fatal hanging error!!!!!

	dec	ax			; point to arena
	mov	es,ax
	;mov	word [es:ARENA.OWNER],8	; owner = System
	mov	word [es:1],8
	;mov	word [es:ARENA.NAME],'SC' ; System Code
	mov	word [es:8],'SC'
	inc	ax
	mov	es,ax			; get back to allocated memory

;-------------- install new int 19 vector

	cli				; no reboots at this time
	;mov	word [19h*4],(VDInt19-StartVDHead)
	mov	word [19h*4],47
	mov	[19h*4+2],ax

;-------------- move the code into proper place

	;mov	cx,(EndVDHead-StartVDHead)
	mov	cx,52
	mov	si,StartVDHead
	xor	di,di
	push	cs
	pop	ds
	cld
	rep	movsb
	sti				; BUGBUG is sti OK now?

;-------------- mov the HMA VDisk head into HMA

	; 23/10/2022
	push	di
	push	es

	mov	ax,0FFFFh
	mov	es,ax
	mov	di,10h
	;mov	cx,(EndVDiskHMAHead-VDiskHMAHead)
	mov	cx,32
	mov	si,VDiskHMAHead
	rep	movsb			; ds already set to cs

	pop	di
	pop	es

	retn

; ----------------------------------------------------------------------
; procedure : ClrVDISKHeader
;
;		Clears the first 32 bytes at 1MB boundary
;		So that DOS/HIMEM is not confused about the VDISK header
;		left by previous DOS=HIGH session
;
; ----------------------------------------------------------------------

struc desc
 .seg_lim:	resw	1		; seg limit 64K 
 .lo_word:	resw	1		; 24 bit seg physical 
 .hi_byte:	resb 	1		; address
 .acc_rights:	resb	1		; access rights ( CPL0 - R/W )
 .reserved:	resw	1		;
 .size:
endstruc

		; 23/10/2022
bmove:		;label byte

dummy:		;times desc.size db 0	; desc	<>
		times 8 db 0		 
gdt:		;times desc.size db 0	; desc	<>
		times 8 db 0
src_desc:	dw	0FFFFh		; desc	<0ffffh,0,0,93h,0>
		dw	0
		db	0
		db	93h
		dw	0
tgt_desc:	dw	0FFFFh		; desc	<0ffffh,0,10h,93h,0>  ; 1MB
		dw	0
		db	10h
		db	93h
		dw	0

rombios_code:	;times desc.size db 0	; desc	<>
		times 8 db 0
temp_stack:	;times desc.size db 0	; desc	<>
		times 8 db 0

ClrdVDISKHead:	times 32 db 0		; db 32 dup (0)


; 25/03/2019 - Retro DOS v4.0 (MSDOS 6.21 IO.SYS, MSDOS 6.0 SYSINIT1.ASM)

; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:0CA6h)

ClrVDISKHeader:	; proc	near

;;-----------------------------------------------------------	      ;I070
;; The following workaround get around a problem with the	      ;I070
;; Tortugas and PS/2 30-286 BIOS when password server mode	      ;I070
;; is set. On those machines the INT 15h block move code	      ;I070
;; goes through the 8042 to twiddle A20 instead of port 92h.	      ;I070
;; In password server mode the 8042 is disabled so the block	      ;I070
;; move crashes the system. We can do this because these	      ;I070
;; systems clear all of memory on a cold boot.			      ;I070
;								      ;I070
;               in      al,64h         ; Test for password servr mode ;I070
;               test    al,10h         ; Is keyboard inhibited?	      ;I070
;               jnz     short ClrVDISKok ; No, go do block move.      ;I070
;                                      ; Check for Tortugas...	      ;I070
;               cmp     word [cs:sys_model_byte],19F8h                ;I070
;               je      short ClrVDISKno                              ;I070
;                                      ; Check for mod 30-286	      ;I070
;               cmp     word [cs:sys_model_byte],09FCh                ;I070
;               jne     short ClrVDISKok			      ;I070
;ClrVDISKno: 	retn	               ; Return w/o block move.	      ;I070
;								      ;I070
;ClrVDISKok:							      ;I070
;-----------------------------------------------------------	      ;I070

	; 12/12/2022
	; ds = cs

	; 30/12/2022 - Retro DOS v4.2
	; (MSDOS 6.21 IO.SYS SYSINIT:0CBFh)

	push	es
	mov	ax,cs
	mov	dx,ax
	mov	cl,12
	shr	dx,cl
	mov	cl,4
	shl	ax,cl
	add	ax,ClrdVDISKHead
	adc	dl,0

	;; 23/10/2022
	;;mov	[cs:src_desc+desc.lo_word],ax
	;mov	[cs:src_desc+2],ax
	;;mov	[cs:src_desc+desc.hi_byte],dl
	;mov	[cs:src_desc+4],dl
	; 12/12/2022
	;mov	[src_desc+desc.lo_word],ax
	mov	[src_desc+2],ax
	;mov	[src_desc+desc.hi_byte],dl
	mov	[src_desc+4],dl

	mov	cx,16	; 16 words
	push	cs
	pop	es
	mov	si,bmove
	mov	ah,87h
	int	15h	; EXTENDED MEMORY - BLOCK MOVE (AT,XT286,PS)
			; CX = number of words to move 
			; ES:SI -> global descriptor table
			; Return: CF set on error, AH = status
	pop	es
	retn

; ----------------------------------------------------------------------
;
; procedure : SaveFreeHMAPtr
;
;		Save the Free HMA pointer in BIOS variable for later use.
;		(INT 2f ax==4a01 call returns pointer to free HMA)
;		Normalizes the pointer to ffff:xxxx format and stores only
;		the offset.
;
; Inputs : ES:DI - pointer to free HMA
; Output : FreeHMAPtr in BIOS data segment updated
;
; ----------------------------------------------------------------------

SaveFreeHMAPtr:
	mov	bx,es
	mov	ax,0FFFFh		; HMA segment
	sub	ax,bx
	add	di,15			; para round
	and	di,0FFF0h
	mov	cl,4
	shl	ax,cl
	sub	di,ax
	push	ds
	;;mov	ax,Bios_Data ; 0070h
	;mov	ax,KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax
	mov	[FreeHMAPtr],di	   ; (ds:8F7h for MSDOS 6.21 IO.SYS)
	mov	byte [inHMA],0FFh  ; (ds:0Dh)
	pop	ds
	retn

; ----------------------------------------------------------------------
;
; procedure : IsVDiskInstalled
;
;		Checks for the presence of VDISK header at 1MB boundary
;		& INT 19 vector
;
; Inputs  : A20 flag should be ON
; Outputs : Zero set if VDISK header found else Zero cleared
;
; ----------------------------------------------------------------------

IsVDiskInstalled:
	xor	ax,ax
	mov	ds,ax
	mov	ds,[19*4+2]
	;mov	si,VDiskSig1-StartVDHead ; 12h
	; 23/10/2022
	mov	si,18
	;mov	cx,VLEN1 ; 5
	mov	cx,5
	push	cs
	pop	es
	mov	di,VDiskSig1
	rep	cmpsb
	je	short ivdins_retn
	mov	ax,0FFFFh
	mov	ds,ax
	;mov	si,10h+(VDiskSig2-VDiskHMAHead) ; 13h
	mov	si,13h
	mov	di,VDiskSig2
	;mov	cx,VLEN2  ; 5
	mov	cx,5
	rep	cmpsb
ivdins_retn: 
	retn			; returns the Zero flag

; ----------------------------------------------------------------------
;
; procedure : CPMHack
;
;		Copies the code from 0:c0 into ffff:0d0h
;		for CPM compatibility
;
; ----------------------------------------------------------------------

	; 11/12/2022
CPMHack:
	push	ds
	mov	cx,0FFFFh
	mov	es,cx		; ES = FFFF
	;xor	cx,cx
	; 11/12/2022
	inc	cx  ; cx = 0
	mov	ds,cx		; DS = 0
	mov	si,0C0h
	mov	di,0D0h
	;mov	cx,5
	mov	cl,5
	cld
	rep	movsb		; move 5 bytes from 0:C0 to FFFF:D0
	pop	ds
	retn

; ----------------------------------------------------------------------
;
; procedure : off_to_para
;
; ----------------------------------------------------------------------
off_to_para:
	shr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	retn

; ----------------------------------------------------------------------
;**	TempCDS - Create (Temporary?) CDS
;
;	ENTRY	?? BUGBUG
;		(DS) = SysInitSeg
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
TempCDS:
	les	di,[DOSINFO]
	mov	cl,[es:di+SYSI_NUMIO]
	;mov	cl,[es:di+20h]
	xor	ch,ch			; (cx) = # of block devices

	mov	[es:di+SYSI_NCDS],cl	; one CDS per device
	;mov	[es:di+21h],cl	

	mov	al,cl
	mov	ah,curdirlen ; curdir_list.size ; 88
	;mov	ah,88
	mul	ah			; (ax) = byte size for those CDSs
	call	ParaRound		; (ax) = paragraph size for CDSs
	mov	si,[top_of_cdss] ; 31/12/2022

;	BUGBUG - we don't update confbot - won't someone else use it?
;	chuckst -- answer: no. Confbot is used to access the CDSs,
;	25 jul 92  which are stored BELOW it. Alloclim is the
;		   variable which has the top of free memory for
;		   device driver loads, etc.

	sub	si,ax

;	chuckst, 25 Jul 92 -- note: I'm removing the code here
;		that automatically updates alloclim every time we
;		set up some new CDSs. Instead, I've added code
;		which pre-allocates space for 26 CDSs. This
;	        way we've got room for worst case CDSs before
;		we place MagicDrv.sys
;
;	mov	[ALLOCLIM],si		; can't alloc past here!

	; 30/12/2022
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (SYSINIT:0C52h)
	;mov	[ALLOCLIM],si ; (MSDOS 5.0 SYSINIT)

	mov	[es:di+SYSI_CDS+2],si
	;mov	[es:di+18h],si
	mov	ax,si
	mov	word [es:di+SYSI_CDS],0	; set address of CDS list
	;mov	[word es:di+16h],0
	;lds	si,[es:di+SYSI_DPB]	; (ds:si) = address of first DPB
	lds	si,[es:di]
	mov	es,ax
	xor	di,di			; (es:di) = address of 1st CDS

;*	Initialize our temporary CDSs. We'll init each CDS with the
;	info from the corresponding DPB.
;
;	(cx) = count of CDSs left to process
;	(es:di) = address of next CDS

fooset:
	; 23/10/2022
	mov	ax,[cs:DirStrng] ; "A:"
	stosw				; setup the root as the curdir
	
	; 23/10/2022 (MSDOS 5.0 SYSINIT)
	;call	get_dpb_for_drive_al	; get dpb for drive in dpb

	; 30/12/2022
	; (MSDOS 6.21 SYSINIT:0D8Bh)
	call	get_dpb_for_drive_al	; get dpb for drive in dpb

;	(ds:si) = address of DPB
;		 (si) = -1 if no drive

	mov	ax,[cs:DirStrng+2] ; "\",0
	stosw
	inc	byte [cs:DirStrng]
	xor	ax,ax
	push	cx
	;mov	cx,curdir_list.cdir_flags - 4 ; 63
	mov	cx,63	; 23/10/2022
	rep	stosb			; zero out rest of CURDIR_TEXTs

;	should handle the system that does not have any floppies.
;	in this case,we are going to pretended there are two dummy floppies
;	in the system. still they have dpb and cds,but we are going to
;	0 out curdir_flags,curdir_devptr of cds so ibmdos can issue
;	"invalid drive specification" message when the user try to
;	access them.
;
;	(ax) = 0
;	(es:di) = CURDIR_FLAGS in the CDS records
;	(ds:si) = Next DPB (-1 if none)

	cmp	si,-1	; cmp si,0FFFFh
	je	short fooset_zero	; don't have any physical drive.

;	check to see if we are faking floppy drives. if not go to normcds.
;	if we are faking floppy drives then see if this cds being initialised
;	is for drive a: or b: by checking the appropriate field in the dpb
;	pointed to by ds:si. if not for a: or b: then go to normcds. if
;	for a: or b: then execute the code given below starting at fooset_zero.
;	for dpb offsets look at inc\dpb.inc.

	cmp	byte [cs:fake_floppy_drv],1
	jne	short normcds 		; machine has floppy drives
	;cmp	byte [si+DPB.drive],1	; if dpb_drive = 0 (a) or 1 (b).
	cmp	byte [si],1
	ja	short normcds
	mov	cl,3			; the next dbp pointer
					; AX should be zero here
	rep	stosw
	pop	cx
	jmp	short get_next_dpb

;	(ax) = 0

fooset_zero:
	mov	cl,3
	rep	stosw
	pop	cx
	jmp	short fincds

;*	We have a "normal" DPB and thus a normal CDS.
;
;	(ax) = 0
;	(es:di) = CURDIR_FLAGS in the CDS records
;	(ds:si) = Next DPB (-1 if none)

normcds:
	pop	cx

;	if a non-fat based media is detected (by dpb.numberoffat == 0), then
;	set curdir_flags to 0. this is for signaling ibmdos and ifsfunc that
;	this media is a non-fat based one.

	;cmp	byte [si+DPB.FAT_COUNT],0 ; non fat system?
	; 23/10/2022
	cmp	byte [si+8],0
	je	short setnormcds	; yes. set curdir_flags to 0. ax = 0 now.
	mov	ax,curdir_inuse ; 4000h	; else,fat system. set the flag to curdir_inuse.
	;mov	ax,4000h
setnormcds:
	stosw				; curdir_flags
	mov	ax,si
	stosw				; curdir_devptr
	mov	ax,ds
	stosw

get_next_dpb:				; entry point for fake_fooset_zero
	; 30/12/2022
	; (MSDOS 6.21 SYSINIT:0DD1h)
	; 23/10/2022
	;lds	si,[si+19h] ; (MSDOS 5.0 SYSINIT)
	;;lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
fincds:	; get_next_dpb
	; 30/12/2022
	; (MSDOS 6.21 SYSINIT:0DD1h)
	mov	ax,-1	; mov ax,0FFFFh
	stosw				; curdir_id
	stosw				; curdir_id
	stosw				; curdir_user_word
	mov	ax,2
	stosw				; curdir_end
	mov	al,0			; clear out 7 bytes (curdir_type,
	stosb
	stosw				;  curdir_ifs_hdr,curdir_fsda)
	stosw
	stosw

	loop	fooset
	
	mov	byte [cs:DirStrng],"A"	; "A:\"
	
	retn

; ----------------------------------------------------------------------
;***	get_dpb_for_drive_al -- lookup the DPB for drive in al
;
;	entry:
;	   al == ASCII CAPS drive letter
;
;	exit:
;	   ds:si -> DPB, or si = -1 if not found
; ----------------------------------------------------------------------

; 30/12/2022
; (MSDOS 6.21 SYSINIT:0DEAh)
; 23/10/2022
;%if 0
get_dpb_for_drive_al:
	lds	si,[cs:DOSINFO]		; point to first DPB
	;lds	si,[si+SYSI_DPB]	; (ds:si) = address of first DPB
	lds	si,[si]
	sub	al,'A'

get_dpb_for_drive_1:
	;cmp	al,[si+DPB.DRIVE]	; match?
	cmp	al,[si]
	je	short got_dpb_for_drive	;  done if so

	lds	si,[si+DPB.NEXT_DPB] ; [si+19h]
	cmp	si,-1
	jne	short get_dpb_for_drive_1 ; loop until hit end of DPBs

got_dpb_for_drive:
	retn
;%endif  ; 23/10/2022

;=======================================================================

;**	EndFile - Build DOS structures
;
; This procedure is called after the config.sys has been processed and
; installable device drivers have been loaded (but before "install="
; programs are loaded) to create the dos structures such as SFTs, buffers,
; FCBs, CDSs, etc. It also loads the sysinit_base module in low memory
; to allow for the safe EXECing of "install=" programs. All memory
; above these structures is deallocated back to DOS.
;
;	ENTRY	?? BUGBUG
;	EXIT	?? BUGBUG
;	USES	?? BUGBUG

;=======================================================================
; allocate files
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0CCDh)

	; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:0E00h)
endfile:
; we are now setting up final cdss,buffers,files,fcss strings etc. we no
; longer need the space taken by the temp stuff below confbot,so set alloclim
; to confbot.

;	if this procedure has been called to take care of install= command,
;	   then we have to save es,si registers.

	; 11/12/2022
	; ds = cs

	; 23/10/2022
	; 31/03/2019
	push	ds

	;;mov	ax,Bios_Data ; 0070h
	;mov	ax,KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax

	;cmp	word [052Fh],0
	cmp	word [multrk_flag],multrk_off1 ;=0,multrack= command entered?
	jne	short multrk_flag_done
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;or	word [multrk_flag],multrk_on ; 80h  ; default will be on.
	; 12/12/2022
	or	byte [multrk_flag],multrk_on ; 80h
multrk_flag_done:
	; 23/10/2022
	; 31/03/2019
	pop	ds

	; 11/12/2022
	; ds = cs
	;mov	ax,[top_of_cdss] ; mov ax,[CONFBOT]
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:0E14h)
	mov	ax,[CONFBOT]
	mov	[ALLOCLIM],ax
	; 23/10/2022
	;mov	ax, [cs:top_of_cdss]
	;mov	[cs:ALLOCLIM], ax 

	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds
	
	;mov	ax,[CONFBOT]
	;mov	[ALLOCLIM],ax

	call	round
	; 11/12/2022
	; ds = cs
	mov	al,[FILES]
	; 23/10/2022
	;mov	al,[cs:FILES]
	sub	al,5
	jbe	short dofcbs

	push	ax
	;mov	al,devmark_files ; 'F'
	mov	al,'F'
	call	setdevmark		; set devmark for sfts (files)
	pop	ax
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	; 11/12/2022
	; ds = cs
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,[DOSINFO]		;get pointer to dos data
	; 23/10/2022
	;mov	bx,[cs:memlo]
	;mov	dx,[cs:memhi]
	;lds	di,[cs:DOSINFO]		

	;lds	di,[di+SYSI_SFT]	;ds:bp points to sft
	lds	di,[di+4]

	;mov	[di+SF.SFLink],bx
	mov	[di],bx
	mov	[di+SF.SFLink+2],dx	;set pointer to new sft

	push	cs
	pop	ds

	; 11/12/2022
	; ds = cs
	les	di,[memlo]		;point to new sft
	; 23/10/2022
	;les	di,[cs:memlo]

	;mov	word [es:di+SF.SFLink],-1
	mov	word [es:di],-1		; 0FFFFh
	;mov	[es:di+SF.SFCount],ax
	mov	[es:di+4],ax
	;mov	bl,SF_ENTRY.size ; 59
	mov	bl,59
	mul	bl			;ax = number of bytes to clear
	mov	cx,ax
	; 11/12/2022
	; ds = cs
	add	[memlo],ax		;allocate memory
	; 23/10/2022
	;add	[cs:memlo],ax
	mov	ax,6
	; 11/12/2022
	add	[memlo],ax		;remember the header too
	;add	[cs:memlo],ax
	; 11/12/2022
	or	byte [setdevmarkflag],for_devmark ; 2
	; 23/10/2022
	;or	byte [cs:setdevmarkflag],2
	call	round			; check for mem error before the stosb
	add	di,ax
	xor	ax,ax
	rep	stosb			;clean out the stuff

; allocate fcbs
; ----------------------------------------------------------------------

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0D48h)
dofcbs:
	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds
	call	round
	;mov	al,devmark_fcbs	; 'X'	;='x'
	mov	al,'X'
	call	setdevmark
	; 11/12/2022
	; ds = cs
	mov	al,[FCBS]
	;mov	al,[cs:FCBS]
	xor	ah,ah			; do not use cbw instruction!!!!!
					;  it does sign extend.
	; 11/12/2022
	mov	bx,[memlo]
	mov	dx,[memhi]
	lds	di,[DOSINFO]		;get pointer to dos data
	; 23/10/2022
	;mov	bx,[cs:memlo]
	;mov	dx,[cs:memhi]
	;lds	di,[cs:DOSINFO]

	;mov	[di+SYSI_FCB],bx
	;mov	[di+SYSI_FCB+2],dx ;set pointer to new table
	; 23/10/2022
	mov	[di+1Ah],bx		; [di+SYSI_FCB]
	mov	[di+1Ch],dx		; [di+SYSI_FCB+2]

	mov	bl,[cs:KEEP]
	xor	bh,bh
	;mov	[di+SYSI_KEEP],bx
	mov	[di+1Eh],bx		; [di+SYSI_KEEP]	

	push	cs
	pop	ds
	
	les	di,[memlo]		;point to new table
	;mov	word [es:di+SF.SFLink],-1
	mov	word [es:di],-1
	;mov	[es:di+SF.SFCount],ax
	; 02/11/2022
	mov	[es:di+4],ax
	mov	bl,SF_ENTRY.size ; 59
	mov	cx,ax
	mul	bl			;ax = number of bytes to clear
	add	[memlo],ax		;allocate memory
	;mov	ax,6
	mov	ax,SF.size-2 ; 6
	add	[memlo],ax		;remember the header too
	;or	byte [setdevmarkflag],for_devmark ; 2
	or	byte [setdevmarkflag],2
	call	round			; check for mem error before the stosb
	add	di,ax			;skip over header
	mov	al,'A'
fillloop:
	push	cx			; save count
	mov	cx,SF_ENTRY.size ; 59	; number of bytes to fill
	cld
	rep	stosb			; filled

	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],0  ; [es:di-59]
	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],0   ; [es:di-38]	
	;mov	word [es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],0 ; [es:di-36]

	; 18/12/2022
	;cx = 0
	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_ref_count],cx ;0  ; [es:di-59]
	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position],cx ;0   ; [es:di-38]	
	mov	[es:di-(SF_ENTRY.size)+SF_ENTRY.sf_position+2],cx ;0 ; [es:di-36]
	
	; 23/10/2022	
	;mov     word [es:di-3Bh],0
	;mov     word [es:di-26h],0
	;mov     word [es:di-24h],0

	pop	cx
	loop	fillloop

; allocate buffers
; ----------------------------------------------------------------------

; search through the list of media supported and allocate 3 buffers if the
; capacity of the drive is > 360kb

	; 18/12/2022
	; cx = 0
	cmp	word [buffers],-1	; has buffers been already set?
	je	short dodefaultbuff
	jmp	dobuff			; the user entered the buffers=.

dodefaultbuff:
	; 18/12/2022
	mov	[h_buffers],cx ; 0
	inc	cx
	inc	cx
	mov	[buffers],cx ; 2	
	
	;mov	word [h_buffers],0	; default is no heuristic buffers.
	;mov	word [buffers],2	; default to 2 buffers

	; 23/10/2022	
	push	ax
	push	ds ; 26/03/2019
	;les	bp,[DOSINFO]		; search through the dpb's
	les	bp,[cs:DOSINFO]
	;les	bp,[es:bp+SYSI_DPB]	; get first dpb
	; 11/12/2022
	les	bp,[es:bp]
	; 23/10/2022
	;les	bp,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !	

	push	cs
	pop	ds
;SYSINIT:0DE2h:
nextdpb:				; test if the drive supports removeable media
	;mov	bl,[es:bp+DPB.drive]
	; 11/12/2022
	mov	bl,[es:bp]
	; 23/10/2022
	;mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !

	;inc	bl
	; 18/12/2022
	inc	bx

	;mov	ax,(IOCTL<<8)|8
	mov	ax,4408h
	int	21h		; DOS - 2+ - IOCTL -

; ignore fixed disks

	or	ax,ax			; ax is nonzero if disk is nonremoveable
	jnz	short nosetbuf

; get parameters of drive

	xor	bx,bx
	;;mov	bl,[es:bp+DPB.drive]
	; 11/12/2022
	mov	bl,[es:bp]
	; 23/10/2022
	;mov	bl,[es:bp+0]	; ! (MSDOS 5.0 IO.SYS address compability) !
	
	;inc	bl
	; 18/12/2022
	inc	bx

	mov	dx,deviceparameters
	;mov	ax,(IOCTL<<8)|GENERIC_IOCTL
	mov	ax,440Dh
	;mov	cx,(RAWIO<<8)|GET_DEVICE_PARAMETERS
	mov	cx,860h
	int	21h		; DOS - 2+ - IOCTL -
	jc	short nosetbuf		; get next dpb if driver doesn't support
					; generic ioctl
; determine capacity of drive
; media capacity = #sectors * bytes/sector

	;mov	bx,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS]
	; 23/10/2022
	mov	bx,[deviceparameters+15] ; total sectors (16 bit)
	
; to keep the magnitude of the media capacity within a word,
; scale the sector size
; (ie. 1 -> 512 bytes,2 -> 1024 bytes,...)

	;mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_BYTESPERSECTOR]
	; 23/10/2022
	mov	ax, [deviceparameters+7] ; bytes per sector
	xor	dx,dx
	mov	cx,512
	div	cx			; scale sector size in factor of
					; 512 bytes
	mul	bx			; ax = #sectors * size factor
	or	dx,dx			; just in case of large floppies
	jnz	short setbuf
	cmp	ax,720			; 720 sectors * size factor of 1
	jbe	short nosetbuf
setbuf:
	; 18/12/2022
	; word [buffers] = 2
	mov	byte [buffers],3
	;mov	word [buffers],3
	jmp	short chk_memsize_for_buffers ; now check the memory size
					; for default buffer count
nosetbuf:
	; 23/10/2022
	;cmp	word [es:bp+DPB.NEXT_DPB],-1
	cmp	word [es:bp+19h], -1 ; 0FFFFh
	je	short chk_memsize_for_buffers
	;les	bp,[es:bp+DPB.NEXT_DPB] ; [es:bp+19h]
	les	bp,[es:bp+19h]
	jmp	short nextdpb

;from dos 3.3,the default number of buffers will be changed according to the
;memory size too.
; default buffers = 2
; if diskette media > 360 kb,then default buffers = 3
; if memory size > 128 kb (2000h para),then default buffers = 5
; if memory size > 256 kb (4000h para),then default buffers = 10
; if memory size > 512 kb (8000h para),then default buffers = 15.

chk_memsize_for_buffers:
	; 18/12/2022
	;cmp	word [MEMORY_SIZE],2000h
	;jbe	short bufset
	;mov	word [buffers],5
	;cmp	word [MEMORY_SIZE],4000h
	;jbe	short bufset
	;mov	word [buffers],10
	;cmp	word [MEMORY_SIZE],8000h
	;jbe	short bufset
	;mov	word [buffers],15

	; 18/12/2022
	; word [buffers] = 3 or 2
	mov	bx,buffers
	mov	ax,[MEMORY_SIZE]
	dec	ax	; [MEMORY_SIZE] - 1

	cmp	ah,20h	; ax >= 2000h ([MEMORY_SIZE] > 2000h) ; *
	jb	short bufset
	mov	byte [bx],15 ; [buffers] = 15 ; ***
	cmp	ah,80h	; ax >= 8000h ([MEMORY_SIZE] > 8000h) ; ***
	jnb	short bufset
	mov	byte [bx],10 ; [buffers] = 10 ; **
	cmp	ah,40h	; ax >= 4000h ([MEMORY_SIZE] > 4000h) ; **
	jnb	short bufset
	mov	byte [bx],5  ; [buffers] = 5 ; *
bufset:
	; 23/10/2022
	; 26/03/2019
	pop	ds
	pop	ax

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;j.k. here we should put extended stuff and new allocation scheme!!!
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; 26/03/2019

;*******************************************************************************
;									       *
; function: actually allocate buffers in the memory and initialize it. 	       *
; input :								       *
;    memhi:memlo - start of the next available memory			       *
;    buffers = number of buffers					       *
;    h_buffers = number of secondary buffers				       *
;									       *
; output:								       *
;	buffinfo.cache_count - # of caches to be installed.		       *
;	buffinfo set.							       *
;	bufferqueue set.						       *
;									       *
; subroutines to be called:						       *
;									       *
;*******************************************************************************

	; 23/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0E60h)
dobuff:
	; ds = cs ; 31/03/2019
	; 23/10/2022
	lds	bx,[cs:DOSINFO]	; ds:bx -> sysinitvar
	;mov	ax,[buffers] ; 31/03/2019
	;lds	bx,[DOSINFO]
	mov	ax,[cs:buffers]	; set sysi_buffers
	;mov	[bx+SYSI_BUFFERS],ax ; [bx+3Fh]
	mov	[bx+3Fh],ax
	mov	ax,[cs:h_buffers]
	;mov	[bx+SYSI_BUFFERS+2],ax ; [bx+41h]
	mov	[bx+41h],ax
	lds	bx,[bx+12h]
	;lds	bx,[bx+SYSI_BUF] ; now,ds:bx -> buffinfo
	call	round		; get [memhi]:[memlo]
	;mov	al,devmark_buf	; ='B'
	mov	al,'B'	
	call	setdevmark

;allocate buffers

	push	ds			; save buffer info. ptr.
	push	bx

	call	set_buffer

	pop	bx
	pop	ds

;now set the secondary buffer if specified.

	cmp	word [cs:h_buffers],0
	je	short xif16
	call	round
	; 23/10/2022
	mov	cx,[cs:memlo]
	;mov	[bx+BUFFINF.Cache_ptr],cx  ; [bx+6]
	mov	[bx+6],cx
	mov	cx,[cs:memhi]
	;mov	[bx+BUFFINF.Cache_ptr+2],cx ; [bx+8]
	mov	[bx+8],cx
	mov	cx,[cs:h_buffers]
	;mov	[bx+BUFFINF.Cache_count],cx ; [bx+10]
	mov	[bx+10],cx
	mov	ax,512			; 512 byte
	mul	cx
	mov	[cs:memlo],ax
	;or	byte [cs:setdevmarkflag],for_devmark ; 2
	or	byte [cs:setdevmarkflag],2
	call	round
xif16:

; ----------------------------------------------------------------------
; allocate cdss
; ----------------------------------------------------------------------

buf1:
	call	round

	push	ax
	; 23/10/2022
	;mov	ax,devmark_cds		;='L'
	mov	ax, 'L'
	call	setdevmark
	pop	ax

	les	di,[cs:DOSINFO]
	;mov	cl,[es:di+SYSI_NUMIO]
	mov	cl,[es:di+20h]
	cmp	cl,[cs:NUM_CDS]
	jae	short gotncds 		; user setting must be at least numio
	mov	cl,[cs:NUM_CDS]
gotncds:
	xor	ch,ch
	;mov	[es:di+SYSI_NCDS],cl	; [es:di+33]
	mov	[es:di+21h],cl
	mov	ax,[cs:memhi]
	;mov	[es:di+SYSI_CDS+2],ax
	mov	[es:di+18h],ax
	mov	ax,[cs:memlo]
	;mov	[es:di+SYSI_CDS],ax
	mov	[es:di+16h],ax
	mov	al,cl
	;mov	ah,curdirlen ; curdir_list.size
	mov	ah,88
	mul	ah
	call	ParaRound
	add	[cs:memhi],ax

	;or	byte [cs:setdevmarkflag],for_devmark ; 2
	or	byte [cs:setdevmarkflag],2
	call	round			; check for mem error before initializing
	;lds	si,[es:di+SYSI_DPB] ; [es:di+0]
	lds	si,[es:di]
	;les	di,[es:di+SYSI_CDS] ; [es:di+22]
	les	di,[es:di+16h]
	call	fooset

; ----------------------------------------------------------------------
; allocate space for internal stack
; ----------------------------------------------------------------------

	push	cs
	pop	ds

;	if the user did not entered stacks= command, as a default, do not install
;	sytem stacks for pc1,pc xt,pc portable cases.
;	otherwise,install it to the user specified value or to the default
;	value of 9,128 for other systems.

	cmp	word [stack_addr],-1 ; has the user entered "stacks=" command?
	je	short doinstallstack	; then install as specified by the user
	cmp	byte [sys_scnd_model_byte],0 ; pc1,xt has the secondary model byte = 0
	jne	short doinstallstack	; other model should have default stack of 9,128
	cmp	byte [sys_model_byte],0FEh ; pc1, pc/xt or pc portable ?
	jae	short skipstack
doinstallstack:
	mov	ax,[stack_count]	; stack_count = 0?
	or	ax,ax			; then, stack size must be 0 too.
	jz	short skipstack		; don't install stack.

;	dynamic relocation of stack code.

	call	round			;[memhi] = seg. for stack code
					;[memlo] = 0

; set devmark block into memory for mem command
; devmark_id = 's' for stack

	;mov	al,devmark_stk	;='S'
	; 23/10/2022
	mov	al,'S'
	call	setdevmark

	mov	ax,[memhi]
	mov	es,ax		;es -> seg. the stack code is going to move.
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds
	xor	si,si		;!!we know that stack code is at the beginning of sysinit.
	xor	di,di
	mov	cx,endstackcode
	mov	[memlo],cx
	call	round		;have enough space for relocation?
	rep	movsb

	push	ds		; stick the location of the NextStack entry
	;;mov	ax,Bios_Data	; into the Win386 Instance Data tables
	;mov	ax,KERNEL_SEGMENT ; 70h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax
	mov	word [NextStack],nextentry ; (8C0h for MSDOS 6.21 IO.SYS)
	mov	[NextStack+2],es	   ; (8C2h for MSDOS 6.21 IO.SYS)

	mov	ax,[cs:memlo]
	mov	[cs:stack_addr],ax ;set for stack area initialization
	mov	[IT_StackLoc],ax ; pass it as Instance Data, too
	mov	ax,[cs:memhi]	;this will be used by stack_init routine.
	mov	[cs:stack_addr+2],ax
	mov	[IT_StackLoc+2],ax

;	space for internal stack area = stack_count(entrysize + stack_size)

	;mov	ax,entrysize ; mov ax,8
	; 23/10/2022
	mov	ax,8
	add	ax,[cs:stack_size]
	mul	word [cs:stack_count]

	mov	[IT_StackSize],ax ; pass through to Instance Tables

	pop	ds		; no more need to access Instance Table

	call	ParaRound	; convert size to paragraphs
	
	; 11/12/2022
	; ds = cs
	;add	[cs:memhi],ax
	add	[memhi],ax
	;or	byte [cs:setdevmarkflag],for_devmark ; 2
	;or	byte [cs:setdevmarkflag],2
	or	byte [setdevmarkflag],2
	;or	byte [setdevmarkflag],for_devmark ; 2
				;to set the devmark_size for stack by round routine.
	call	round		; check for memory error before
				; continuing
	call	stackinit	; initialize hardware stack. 
				; cs=ds=sysinitseg,es=relocated stack code & data
skipstack:
	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:0F99h)

	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds

	mov	al,[FILES]
	xor	ah,ah		; do not use cbw instruction!!!!!
				;  it does sign extend.
	mov	cx,ax
	xor	bx,bx		;close standard input
	mov	ah,3Eh ; CLOSE
	int	21h
	mov	bx,2
rcclloop:			;close everybody but standard output
	mov	ah,3Eh ; CLOSE	; need output so we can print message
	int	21h		; in case we can't get new one open.
	inc	bx
	loop	rcclloop

	mov	dx,condev
	mov	al,2
	mov	ah,3Dh ; OPEN 	;open con for read/write
	stc			; set for possible int 24
	int	21h
	jnc	short goaux
	call	badfil
	jmp	short goaux2
goaux:	
	push	ax
	mov	bx,1		;close standard output
	mov	ah,3Eh ; CLOSE
	int	21h
	pop	ax

	mov	bx,ax		;new device handle
	mov	ah,45h ; XDUP
	int	21h		;dup to 1,stdout
	mov	ah,45h ; XDUP
	int	21h		;dup to 2,stderr
goaux2: 
	mov	dx,auxdev
	mov	al,2		;read/write access
	call	open_dev

	mov	dx,prndev
	mov	al,1		;write only
	call	open_dev

;global rearm command for shared interrupt devices attached in the system;
;shared interrupt attachment has some problem when it issues interrupt
;during a warm reboot. once the interrupt is presented by the attachment,
;no further interrupts on that level will be presented until a global rearm
;is issued. by the request of the system architecture group, msbio will
;issue a global rearm after every device driver is loaded.
;to issue a global rearm:	;for pc1,xt,palace
;
;			  out 02f2h,xx  ; interrupt level 2
;			  out 02f3h,xx  ; interrupt level 3
;			  out 02f4h,xx  ; interrupt level 4
;			  out 02f5h,xx  ; interrupt level 5
;			  out 02f6h,xx  ; interrupt level 6
;			  out 02f7h,xx  ; interrupt level 7
;
;	for pc at,in addition to the above commands,
;	need to handle the secondary interrupt handler
;
;			  out 06f2h,xx  ; interrupt level 10
;			  out 06f3h,xx  ; interrupt level 11
;			  out 06f4h,xx  ; interrupt level 12
;			  out 06f6h,xx  ; interrupt level 14
;			  out 06f7h,xx  ; interrupt level 15
;
;	for round-up machine
;
;			  none.

; where xx stands for any value.
;
; for your information,after naples level machine,the system service bios
; call (int 15h),function ah=0c0h returns the system configuration parameters

	; 24/10/2022

	push	ax
	push	bx
	push	dx
	push	es

	mov	al,0FFh 		;reset h/w by writing to port
	mov	dx,2F2h 		;get starting address
	out	dx,al			; out 02f2h,0ffh
	inc	dx
	out	dx,al			; out 02f3h,0ffh
	inc	dx
	out	dx,al			; out 02f4h,0ffh
	inc	dx
	out	dx,al			; out 02f5h,0ffh
	inc	dx
	out	dx,al			; out 02f6h,0ffh
	inc	dx
	out	dx,al			; out 02f7h,0ffh

;sb secondary global rearm

	mov	ax,0F000h		;get machine type
	mov	es,ax
	cmp	byte [es:0FFFEh],0FCh ;q:is it a at type machine
	je	short startrearm	; *if at no need to check

	mov	ah,0C0h 		;get system configuration
	int	15h			; *
	jc	short finishrearm	; *jmp if old rom

; test feature byte for secondary interrupt controller

	test	byte [es:bx+5],40h
	; 24/10/2022
	;test	byte [es:bx+ROMBIOS_DESC.bios_sd_featurebyte1],ScndIntController
	je	short finishrearm	;jmp if it is there

startrearm:
	mov	al,0FFh 		;write any pattern to port
	mov	dx,6F2h 		;get starting address
	out	dx,al			;out 06f2h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f3h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f4h,0ffh
	inc	dx			;bump address
	inc	dx			;bump address
	out	dx,al			;out 06f6h,0ffh
	inc	dx			;bump address
	out	dx,al			;out 06f7h,0ffh

finishrearm:
	pop	es
	pop	dx
	pop	bx
	pop	ax

;    global rearm end *******************

; ----------------------------------------------------------------------
; allocate sysinit_base for install= command
; ----------------------------------------------------------------------
; sysinit_base allocation.
;   check if endfile has been called to handle install= command.

set_sysinit_base:

; ----------------------------------------------------------------------
;sysinit_base will be established in the secure area of
;lower memory when it handles the first install= command.
;sysinit_base is the place where the actual exec function will be called and
;will check sysinit module in high memory if it is damaged by the application
;program.  if sysinit module has been broken,then "memory error..." message
;is displayed by sysinit_base.
; ----------------------------------------------------------------------

	; 24/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
	; (SYSINIT:1028h)

	; 11/12/2022
	; ds = cs
	push	ax			; set devmark for mem command
	mov	ax,[memhi]
	sub	ax,[area]
	mov	[impossible_owner_size],ax ;remember the size in case.
	;mov	al,devmark_inst ; 'T'
	mov	al,'T'
	call	setdevmark
	pop	ax

	mov	di,[memhi]
	mov	es,di
	mov	[sysinit_base_ptr+2],di ; save this entry for the next use.
	xor	di,di
	mov	[sysinit_base_ptr],di	; es:di -> destination.
	mov	si,sysinit_base		;ds:si -> source code to be relocated.
	mov	cx,end_sysinit_base-sysinit_base ; 129
	; 24/10/2022 
	;mov	cx,128	; 11DCh-115Ch 	; (MSDOS 5.0 IO.SYS, SYSINIT)
	add	[memlo],cx
	;or	byte cs:[setdevmarkflag],for_devmark ; 2
	; 11/12/2022
	; ds = cs
	;or	byte [cs:setdevmarkflag],2
	or	byte [setdevmarkflag],2
	;or	byte [setdevmarkflag],for_devmark
	call	round			; check mem error. also,readjust memhi for the next use.
	rep	movsb			; reallocate it.

	mov	word [sysinit_ptr],sysinitptr ; returning address from
	mov	[sysinit_ptr+2],cs	 ; sysinit_base back to sysinit.
	;or	word [install_flag],has_installed ; set the flag.
	;or	byte [install_flag],has_installed ; 2
	; 11/12/2022
	or	byte [install_flag],2
	; 24/10/2022
	;or	word [install_flag],2	

; ----------------------------------------------------------------------
; free the rest of the memory from memhi to confbot. still from confbot to
; the top of the memory will be allocated for sysinit and config.sys if
; have_install_cmd.
; ----------------------------------------------------------------------

	call	round
	mov	bx,[memhi]
	mov	ax,[area]
	mov	[old_area],ax		; save [area]
	mov	es,ax			;calc what we needed
	sub	bx,ax
	; 24/10/2022
	mov	ah,4Ah ; SETBLOCK
	int	21h			;give the rest back
		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
		; ES = segment address of block to change
		; BX = new size in paragraphs
	push	es
	mov	ax,es
	dec	ax
	mov	es,ax			;point to arena
	;mov	word [es:ARENA.OWNER],8	;set impossible owner
	;;mov	word [es:ARENA.NAME],4453h	; System Data
	;mov	word [es:ARENA.NAME],'SD'	; System Data
	; 24/10/2022
	mov	word [es:1],8		;set impossible owner
	mov	word [es:8],'SD'	; System Data
	pop	es

	mov	bx,0FFFFh
	mov	ah,48h ; ALLOC
	int	21h
	mov	ah,48h ; ALLOC
	int	21h			; allocate the rest of the memory
		; DOS - 2+ - ALLOCATE MEMORY
		; BX = number of 16-byte paragraphs desired
	mov	[memhi],ax		; start of the allocated memory
	mov	word [memlo],0		;  to be used next.

;;;; at this moment,memory from [memhi]:0 to top-of-the memory is
;;;; allocated.
;;;; to protect sysinit,confbot module (from confbot (or =alloclim at
;;;; this time) to the top-of-the memory),here we are going to
;;;; 1). "setblock" from memhi to confbot.
;;;; 2). "alloc" from confbot to the top of the memory.
;;;; 3). "free alloc memory" from memhi to confbot.

;memory allocation for sysinit,confbot module.

	mov	es,ax
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:11DFh)
	mov	bx,[CONFBOT]
	; 24/10/2022
	;mov	bx,[top_of_cdss] ; mov bx,[confbot]
	sub	bx,ax			; confbot - memhi
	dec	bx			; make a room for the memory block id.
	dec	bx			; make sure!!!.
	mov	ah,4Ah ; SETBLOCK
	int	21h			; this will free (confbot to top of memory)
		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
		; ES = segment address of block to change
		; BX = new size in paragraphs
	mov	bx,0FFFFh
	mov	ah,48h ; ALLOC
	int	21h
	mov	ah,48h ; ALLOC
	int	21h			; allocate (confbot to top of memory)
		; DOS - 2+ - ALLOCATE MEMORY
		; BX = number of 16-byte paragraphs desired
	mov	[area],ax		; save allocated memory segment.
					; need this to free this area for command.com.
	mov	es,[memhi]
	mov	ah,49h			; free allocated memory.
	int	21h			; free (memhi to confbot(=area))
		; DOS - 2+ - FREE MEMORY
		; ES = segment address of area to be freed
endfile_ret:
	retn

; End of "EndFile" DOS structure configuration.

; ----------------------------------------------------------------------
; 26/03/2019 - Retro DOS v4.0
; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)	
; ----------------------------------------------------------------------
; Do_Install_Exec
;
; This procedure is used to EXEC a program being loaded via the 
; "install=" mechanism in config.sys. It does this by setting up
; the parameters, and then jumping to sysinit_base, which has been
; setup in low memory. When complete, sysinit_base will jump back
; up to this procedure (if sysinit remains uncorrupted by the installed
; program).

;SYSINIT:10CFh:

do_install_exec:			; now,handles install= command.

	push	si			; save si for config.sys again.

; we are going to call load/exec function.
; set es:bx to the parameter block here;;;;;;;
; set ds:dx to the asciiz string. remember that we already has 0
; after the filename. so parameter starts after that. if next
; character is a line feed (i.e. 10),then assume that the 0
; we already encountered used to be a carrage return. in this
; case,let's set the length to 0 which will be followed by
; carridge return.

; es:si -> command line in config.sys. points to the first non blank
;character after =.

	push	es
	push	ds
	pop	es
	pop	ds			; es->sysinitseg,ds->confbot seg
	mov	dx,si			; ds:dx->file name,0 in config.sys image.

	xor	cx,cx
	cld
	mov	byte [cs:ldexec_start],' ' ; clear out the parm area
	mov	di,ldexec_parm
installfilename:			; skip the file name
	lodsb				; al = ds:si; si++
	cmp	al,0
	je	short got_installparm
	jmp	short installfilename
got_installparm:			; copy the parameters to ldexec_parm
	lodsb
	mov	[es:di],al
	cmp	al,lf	; cmp al,0Ah	; line feed?
	je	short done_installparm
	inc	cl			; # of char. in the parm.
	inc	di
	jmp	short got_installparm
done_installparm:
	mov	byte [cs:ldexec_line],cl ; length of the parm.
	cmp	cl,0			; if no parm,then
	jne	short install_seg_set 	; let the parm area
	mov	byte [cs:ldexec_start],cr ; 0Dh 
					; starts with cr.
install_seg_set:
	mov	word [cs:0],0		; make a null environment segment
	mov	ax,cs			; by overlap jmp instruction of sysinitseg.

;---------------------------------------------------M067----------------
;
; 	the environment pointer is made 0. so the current environment ptr.
; 	will be the same as pdb_environ which after dosinit is 0.
;
; 	mov	cs:[instexe.exec0_environ],0 ; set the environment seg.
;
; 	instexe.exec0_environ need not be initialized to 0 above. It was
; 	done as a fix for bug #529. The actual bug was in NLSFUNC and
; 	was fixed. 
;
; ----------------------------------------------------------------------

;;ifdef   MULTI_CONFIG

; If there's any environment data in "config_wrkseg", pass to app

; 30/12/2022 - Retro DOS v4.0 (Modified MSDOS 6.21 IO.SYS SYSINIT)
; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)
;%if 0
        mov     cx,ax
        cmp     word [cs:config_envlen],0
        je      short no_envdata2
        mov     cx,[cs:config_wrkseg]
no_envdata2:
;;endif  ;MULTI_CONFIG

;%endif	; 24/10/2022

	;mov	[cs:instexe.exec0_environ],cx ; set the environment seg.
	; 24/10/2022
	;mov	[cs:iexec.environ],cx
	; 02/11/2022
	mov	[cs:iexec.environ],ax	

	;mov	[cs:instexe.exec0_com_line+2],ax ; set the seg.
	mov	[cs:iexec.ldexec_line+2],ax
	;mov	[cs:instexe.exec0_5c_fcb+2],ax
	mov	[cs:iexec.ldexec_5c_fcb+2],ax
	;mov	[cs:instexe.exec0_6c_fcb+2],ax
	mov	[cs:iexec.ldexec_6c_fcb+2],ax
	call	sum_up
	mov	[es:checksum],ax	; save the value of the sum
	xor	ax,ax
	mov	ah,4Bh ; EXEC		; load/exec
	mov	bx,instexe		; es:bx -> parm block.
	push	es			; save es,ds for load/exec
	push	ds			; these registers will be restored in sysinit_base.
	jmp	far [cs:sysinit_base_ptr] ; jmp to sysinit_base to execute
					; load/exec function and check sum.

;----------------------------------------

;j.k. this is the returning address from sysinit_base.

	; 24/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS SYSINIT)

sysinitptr:				; returning far address from sysinit_base
	pop	si			; restore si for config.sys file.
	push	es
	push	ds
	pop	es
	pop	ds			; now ds - sysinitseg, es - confbot
        jnc     short install_exit_ret

	push	si			; error in loading the file for install=.
	call	badload 		; es:si-> path,filename,0.
	pop	si

	; 24/10/2022
	;jmp	short sysinitptr_retn ; (MSDOS 5.0 IO.SYS, SYSINIT:1140h)
	; 11/12/2022
	; ds = cs

	; 30/12/2022 - Retro DOS v4.2
	; (MSDOS 6.21 IO.SYS, SYSINIT:1283h)

install_exit_ret:
	retn

; 30/12/2022 - Retro DOS v4.2
%if 0
install_exit_ret:
	;retn		; retn (MSDOS 6.21 IO.SYS, SYSINIT:1283h) ; 18/12/2022

	; 24/10/2022 (MSDOS 5.0 IO.SYS SYSINIT)
;SYSINIT:1142h:
	mov     ah,4Dh
	int     21h             ; DOS - 2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
	cmp     ah,3
	jz      short sysinitptr_retn
	call    error_line
	stc
sysinitptr_retn:	; (SYSINIT:114Fh)
	retn		

%endif ; 24/10/2022

; ----------------------------------------------------------------------

;**	ParaRound - Round Up length to paragraph multiple
;
;	ParaRound rounds a byte count up to a multiple of 16, then divides
;	by 16 yielding a "length in paragraphs" value.
;
;	ENTRY	(ax) = byte length
;	EXIT	(ax) = rounded up length in paragraphs
;	USES	ax, flags

ParaRound:
	add	ax,15
	rcr	ax,1
	shr	ax,1
	shr	ax,1
	shr	ax,1
	retn

; ----------------------------------------------------------------------
; sysinit_base module.
;
; This module is relocated by the routine EndFile to a location in low
; memory. It is then called by SYSINIT to perform the EXEC of programs
; that are being loaded by the "install=" command. After the EXEC call
; completes, this module performs a checksum on the SYSINIT code (at the
; top of memory) to be sure that the EXECed program did not damage it.
; If it did, then this module will print an error message and stop the
; system. Otherwise, it returns control to SYSINIT.
;
;in: after relocation,
;    ax = 4b00h - load and execute the program dos function.
;    ds = confbot. segment of config.sys file image
;    es = sysinitseg. segment of sysinit module itself.
;    ds:dx = pointer to asciiz string of the path,filename to be executed.
;    es:bx = pointer to a parameter block for load.
;    SI_end (byte) - offset vaule of end of sysinit module label
;    bigsize (word) - # of word from confbot to SI_end.
;    chksum (word) - sum of every byte from confbot to SI_end in a
;			word boundary moduler form.
;    sysinit_ptr (dword ptr) - return address to sysinit module.
;
;note: sysinit should save necessary registers and when the control is back

	; 24/10/2022
	; (SYSINIT:115Ch for MSDOS 5.0 SYSINIT)
sysinit_base:				
	mov	[cs:sysinit_base_ss],ss	; save stack
	mov	[cs:sysinit_base_sp],sp	
	int	21h			; load/exec dos call.
	mov	ss,[cs:sysinit_base_ss]	; restore stack
	mov	sp,[cs:sysinit_base_sp]
	pop	ds			; restore confbot seg
	pop	es			; restore sysinitseg
	jc	short sysinit_base_end	; load/exec function failed.
					; at this time,i don't have to worry about
					; that sysinit module has been broken or not.
	call	sum_up			; otherwise,check if it is good.
	cmp	[es:checksum],ax
	je	short sysinit_base_end

;	memory broken. show "memory allocation error" message and stall.

	mov	ah,9
	push	cs
	pop	ds
	; 30/12/2022
	; (MSDOS 6.21 IO.SYS, SYSINIT:12B8h)
	;mov	dx, 102
	mov	dx,mem_alloc_err_msgx-sysinit_base ; 65h (for MSDOS 5.0 SYSINIT)
					; 66h (for MSDOS 6.21 SYSINIT)
	int	21h
		; DOS - PRINT STRING
		; DS:DX -> string terminated by "$"

	; 30/12/2022 - Retro DOS v4.2
stall:
	; 24/10/2022
_stall: 
	; 11/12/2022
	hlt 
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;hlt				;use HLT to minimize energy consumption
        jmp	short _stall

sysinit_base_end: 
	jmp	far [es:sysinit_ptr]	;return back to sysinit module

;-------------------------------------

sum_up:

;in:   es - sysinitseg.
;out:  ax - result
;
;remark: since this routine will only check starting from "locstack" to the end of
;	 sysinit segment,the data area, and the current stack area are not
;	 coverd. in this sense,this check sum routine only gives a minimal
;	 gaurantee to be safe.
;
;first sum up confbot seg.

	push	ds
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:12C6h)
	mov	ax,[es:CONFBOT]
	; 24/10/2022
	;mov	ax,[es:top_of_cdss]
	mov	ds,ax
	xor	si,si
	xor	ax,ax
	mov	cx,[es:config_size]	; if config_size has been broken,then this
					; whole test better fail.
	shr	cx,1			; make it a word count
	jz	short sum_sys_code	; when config.sys file not exist.
sum1:
	add	ax,[si]
	inc	si
	inc	si
	loop	sum1
;now,sum up sysinit module.
sum_sys_code:
	; 24/10/2022
	mov	si,locstack ; 5A6h (MSDOS 5.0 IO.SYS, SYSINIT)
			    ; 532h (MSDOS 6.21 IO.SYS, SYSINIT)
				        ; starting after the stack.  M069
					;  this does not cover the possible stack code!!!
	;;mov	cx,22688  ; for MSDOS 6.21 IO.SYS
	; 02/11/2022
	;mov	cx,3D20h  ; (15648) for MSDOS 5.0 IO.SYS (SYSINIT)	
	; 30/12/2022  
	mov	cx,SI_end ; (22688) 	; SI_end is the label at the end of sysinit
	sub	cx,si			;  from after_checksum to SI_end
	shr	cx,1
sum2:
	add	ax,[es:si]
	inc	si
	inc	si
	loop	sum2
	pop	ds
	retn

; 24/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
; 30/12/2022 - Retro DOS 4.2 (Modified MSDOS 6.21 IO.SYS, SYSINIT)
; (SYSINIT:12F2h)

sysinit_base_ss equ $-sysinit_base  ; = 61 (MSDOS 5.0 IO.SYS, SYSINIT:115Ch)
;SYSINIT:11BDh:			    ; = 62 (MSDOS 6.21 IO.SYS, SYSINIT:1290h) 	
	dw	0
sysinit_base_sp equ $-sysinit_base  ; = 63 (MSDOS 5.0 IO.SYS, SYSINIT:1161h)
;SYSINIT:11BFh:			    ; = 64 (MSDOS 6.21 IO.SYS, SYSINIT:1292h)
	dw	0	

mem_alloc_err_msgx:

       ;include msbio.cl4		; memory allocation error message

;SYSINIT:12F6:  ; MSDOS 6.21 IO.SYS SYSINIT:12F6h
	db	0Dh,0Ah
	db 	'Memory allocation error $'

end_sysinit_base: ; label byte
	; 24/10/2022
	; (SYSINIT:11DCh for MSDOS 5.0 SYSINIT)

; ----------------------------------------------------------------------
; Set_Buffer
;
;function: set buffers in the real memory.				  
;	   lastly set the memhi,memlo for the next available free address.
;
;input:    ds:bx -> buffinfo.
;	   [memhi]:[memlo = 0] = available space for the hash bucket.	  
;	   singlebuffersize = buffer header size + sector size		  
;
;output:   buffers Queue established.	       				   
;	   [memhi]:[memlo] = address of the next available free space.	   
; ----------------------------------------------------------------------

	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
	; (SYSINIT:11DCh)

set_buffer:
	xor	dl,dl				; assume buffers not in HMA
	call	GetBufferAddr
	jz	short set_buff_1
	mov	dl,1				; buffers in HMA
set_buff_1:
	; 25/10/2022
	;mov	[bx+BUFFINF.Buff_Queue],di	; head of Buff Q
	mov	[bx],di
	;mov	[bx+BUFFINF.Buff_Queue+2],es
	mov	[bx+2],es
	;mov	word [bx+BUFFINF.Dirty_Buff_Count],0 ;set dirty_count to 0.
	mov	word [bx+4],0

	mov	ax,di
	mov	cx,[cs:buffers]
	push	di				; remember first buffer

;	for each buffer

nxt_buff:
	call	set_buffer_info 		; set buf_link,buf_id...
	mov	di,ax
	loop	nxt_buff

	sub	di,[cs:singlebuffersize]	; point to last buffer

	pop	cx				; get first buffer
	;mov	[es:di+buffinfo.buf_next],cx	; last->next = first
	mov	[es:di],cx
	xchg	cx,di
	;mov	[es:di+buffinfo.buf_prev],cx	; first->prev = last
	; 25/10/2022
	mov	[es:di+2],cx

	or	dl,dl				; In HMa ?
	jz	short set_buff_2		; no
	;mov	byte [bx+BUFFINF.Buff_In_HMA],1
	mov	byte [bx+12],1
	mov	ax,[cs:memhi]			; seg of scratch buff
	;mov	word [bx+BUFFINF.Lo_Mem_Buff],0	; offset of sctarch buff is 0
	mov	word [bx+13],0
	;mov	[bx+BUFFINF.Lo_Mem_Buff+2],ax
	mov	word [bx+15],ax
	mov	ax,[cs:singlebuffersize]	; size of scratch buff
	;sub	ax,bufinsiz ; 20		; buffer head not required
	sub	ax,20
set_buff_2:
	add	[cs:memlo],ax
	;or	byte [cs:setdevmarkflag],for_devmark ; 2
	or	byte [cs:setdevmarkflag],2
	;call	round
	;retn
	; 12/12/2022
	jmp	round

; ----------------------------------------------------------------------
; procedure : GetBufferAddr
;
;	      Gets the buffer address either in HMA or in Lo Mem
;
; returns in es:di the buffer adress
; returns NZ if allocated in HMA
; ----------------------------------------------------------------------

	; 25/10/2022 
GetBufferAddr:
	push	bx
	push	dx
	mov	ax, [cs:singlebuffersize]
	mul	word [cs:buffers]
	;add	ax,0Fh
	add	ax,15 
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;and	ax,~15	; 0FFF0h	; para round
	; 12/12/2022
	and	al,~15	; 0F0h
	mov	bx,ax
	mov	ax,4A02h
	;mov	ax,((multMULT<<8)+multMULTALLOCHMA)
	int	2Fh
	cmp	di,0FFFFh
	jne	short got_hma
	mov	di,0			; dont xor di,di Z flag needed
	;zf=1
	;xor	di,di	; 25/10/2022
	;zf=1
	mov	es,[cs:memhi]
got_hma:
	pop	dx
	pop	bx
	retn

; ----------------------------------------------------------------------

set_buffer_info:

;function: set buf_link,buf_id,buf_sector
;
;in: es:di -> buffer header to be set.
;    ax = di
;
;out:
;    above entries set.

	; 25/10/2022 
	push	word [cs:buf_prev_off]
	;pop	word [es:di+buffinfo.buf_prev]
	pop	word [es:di+2]
	mov	[cs:buf_prev_off],ax
	add	ax,[cs:singlebuffersize]	;adjust ax
	;mov	[es:di+buffinfo.buf_next],ax
	mov	[es:di],ax
	;mov	word [es:di+buffinfo.buf_ID],00FFh  ; new buffer free
	mov	word [es:di+4],00FFh
	;mov	word [es:di+buffinfo.buf_sector],0   ; to compensate the masm 3 bug
	mov	word [es:di+6],0
	;mov	word [es:di+buffinfo.buf_sector+2],0 ; to compensate the masm 3 bug
	mov	word [es:di+8],0
	retn

; ======================================================================
; MSSTACK initialization routine - MSDOS 6.0 - SYSDINIT1.ASM - 1991
; ----------------------------------------------------------------------
; 27/03/2019 - Retro DOS v4.0

; ----------------------------------------------------------------------
; ibmstack initialization routine.
;
;	to follow the standard interrupt sharing scheme, msstack.asm
;	has been modified. this initialization routine also has to
;	be modified because for the interrupt level 7 and 15, firstflag
;	should be set to signal that this interrupt handler is the
;	first handler hooked to this interrupt vector.
;	we determine this by looking at the instruction pointed by
;	this vector. if it is iret, then this handler should be the
;	first one. in our case, only the interrupt vector 77h is the
;	interrupt level 15. (we don't hook interrupt level 7.)
;
;	the followings are mainly due to m.r.t; ptm fix of p886 12/3/86
;	some design changes are needed to the above interrupt sharing
;	method. the above sharing scheme assumes that 1). interrupt
;	sharing is never done on levels that have bios support. 2). "phantom"
;	interrupts would only be generated on levels 7 and 15.
;	these assumptions are not true any more. we have to use the firstflag
;	for every level of interrupt. we will set the firstflag on the following
;	conditions:
;
;	 a.	 if the cs portion of the vector is 0000, then "first"
;	 b. else if cs:ip points to valid shared header, then not "first"
;	 c. else if cs:ip points to an iret, then "first"
;	 d. else if cs:ip points to dummy, then "first"
;
;	where dummy is - the cs portion must be f000, and the ip portion must
;	be equal to the value at f000:ff01. this location is the initial value
;	from vector_table for interrupt 7, one of the preserved addresses in all
;	the bioses for all of the machines.
;
;	system design group requests bios to handle the phantom interrupts.
;
;	the "phantom" interrupt is an illegal interrupt such as an interrupt
;	produced by the bogus adapter card even without interrupt request is
;	set.  more specifically, 1). the 8259 has a feature when running in
;	edge triggered mode to latch a pulse and present the interrupt when
;	the processor indicates interrupt acknowledge (inta). the interrupt
;	pulse was exist at the time of inta to get a "phantom" interrupt.
;	2). or, this is caused by adapter cards placing a glitch on the
;	interrupt line.
;
;	to handle those "phantom" interrupts, the main stack code will check
;	the own firstflag, and if it is not "first" (which means the forward
;	pointer points to the legal shared interrupt handler), then pass the
;	control. if it is the first, then the following action should be
;	taken. we don't have to implement skack logic in this case.
;
;	to implement this logic, we rather choose a simple method.
;	if ont of the above "firstflag" conditions is met, we are not
;	going to hook this interrupt vector. the reason is if the original
;	vector points to "iret" and do nothing, we don't need
;	to implement the stack logic for it. this will simplify implementation
;	while maintaining compatibility with the old version of dos.
;	this implies that in the main stack code, there might be a stack code
;	that will never be used, a dead code.
;
;in - cs, ds -> sysinitseg, es -> relocated stack code & data.

	; 25/10/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
	; (SYSINIT:1287h)

	; 14/12/2022
stackinit:
	push	ax
	push	ds
	push	es
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	bp

;currently es -> stack code area

	; 12/12/2022
	; ds = cs
	mov	ax,[stack_count]
	mov	cx,ax  ; *!*!*  
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (MSDOS 5.0 IO.SYS - SYSINIT:1290h)
	;mov	ax,[cs:stack_count] ; !!	;defined in cs
	mov	[es:stackcount],ax		;defined in stack code area
	; (MSDOS 5.0 IO.SYS - SYSINIT:1298h)
	mov	ax,[stack_size]	 ; !!		;in cs
	mov	[es:stacksize],ax
	; 12/12/2022
	mov	ax,[stack_addr]			; offset
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
	;mov	ax,[cs:stack_addr]  ; !!
	mov	[es:stacks],ax
	; 12/12/2022
	mov	bp,ax ; *!*
	mov	ax,[stack_addr+2]
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (MSDOS 5.0 IO.SYS - SYSINIT:129Fh)
	;mov	ax,[cs:stack_addr+2] ; !!	; segment
	mov	[es:stacks+2],ax

; initialize the data fields with the parameters

; "firstentry" will always be at stacks

	;mov	bp,[es:stacks]			; get offset of stack
	; 12/12/2022
	; bp = [es:stacks] ; *!*
	mov	[es:firstentry],bp

; the stacks will always immediately follow the table entries

	mov	ax,entrysize ; 8
	;mov	cx,[es:stackcount]
	; 12/12/2022
	; cx = [es:stackcount] ; *!*!*
	mul	cx
	add	ax,bp
	mov	[es:stackat],ax
	mov	bx,ax
	sub	bx,2

; zero the entire stack area to start with

	mov	di,[es:stackat]
	mov	ax,[es:stacksize]
	mul	cx
	mov	cx,ax
	xor	ax,ax
	push	es
	pop	ds				;ds = relocated stack code seg.

;now, ds -> stack code area

	mov	es,[stacks+2]			; get segment of stack area.
	cld
	rep	stosb

	mov	cx,[stackcount]

; loop for "count" times, building a table entry
;  cs = sysinitseg, ds = relocated stack code seg, es = segment of stack space
;  cx = number of entries
;  es:bp => base of stacks - 2
;  es:bx => first table entry

buildloop:
	; 11/12/2022
	;mov	byte [es:bp+allocbyte],free	; mov [es:bp+0],0
	; 25/10/2022
	mov	byte [es:bp],free
	mov	[es:bp+intlevel],al	; ax = 0
	;mov	[es:bp+1],al
	mov	[es:bp+savedsp],ax
	;mov	[es:bp2],ax
	mov	[es:bp+savedss],ax
	;mov	[es:bp+4],ax
	add	bx,[stacksize]
	mov	[es:bp+newsp],bx		; mov [es:bp+6],bx
	;mov	[es:bp+6],bx
	mov	[es:bx],bp
	add	bp,entrysize ; 8

	loop	buildloop

	sub	bp,entrysize ; 8
	mov	[lastentry],bp
	mov	[nextentry],bp

	push	ds
	mov	ax,0F000h		;look at the model byte
	mov	ds,ax
	cmp	byte [0FFFEh],0F9h ; mdl_convert ;convertible?
	pop	ds
	jne	short skip_disablenmis

	mov	al,07h			; disable convertible nmis
	out	72h,al

skip_disablenmis:
	xor	ax,ax
	mov	es,ax			;es - segid of vector table at 0
					;ds - relocated stack code segment
	cli

	;irp	aa,<02,08,09,70>
	;
	;mov	si,aa&h*4		;pass where vector is to be adjusted
	;mov	di,offset int19old&aa	;we have to set old&aa for int19 handler too.
	;mov	bx,offset old&aa	;pass where to save original owner pointer
	;mov	dx,offset int&aa	;pass where new handler is
	;call	new_init_loop		;adjust the vector to new handler,
	;				;saving pointer to original owner
	;endm

stkinit_02:
	mov	si,02h*4 ; 8
	mov	di,INT19OLD02
	mov	bx,old02
	mov	dx,int02
	call	new_init_loop
stkinit_08:
	mov	si,08h*4 ; 32
	mov	di,INT19OLD08
	mov	bx,old08
	mov	dx,int08
	call	new_init_loop
stkinit_09:
	mov	si,09h*4 ; 36
	mov	di,INT19OLD09
	mov	bx,old09
	mov	dx,int09
	call	new_init_loop
stkinit_70:
	mov	si,70h*4 ; 448
	mov	di,INT19OLD70
	mov	bx,old70
	mov	dx,int70
	call	new_init_loop

	;irp	aa,<0a,0b,0c,0d,0e,72,73,74,76,77> ;shared interrupts
	;
	;mov	si,aa&h*4		;pass where vector is to be adjusted
	;push	ds			;save relocated stack code segment
	;lds	bx, es:[si]		;ds:bx -> original interrupt handler
	;push	ds
	;pop	dx			;dx = segment value
	;	
	;cmp	dx,0
	;jz	int&aa&_first
	;
	;cmp	byte ptr ds:[bx],0cfh	;does vector point to an iret?
	;jz	int&aa&_first
	;
	;cmp	word ptr ds:[bx.6],424bh ;magic offset (see int&aa, msstack.inc)
	;jz	int&aa&_not_first
	;
	;cmp	dx,0f000h		;rom bios segment
	;jnz	int&aa&_not_first
	;
	;push	es
	;push	dx
	;mov	dx,0f000h
	;mov	es,dx
	;cmp	bx,word ptr es:0ff01h
       	;pop	dx
	;pop	es
	;jz	int&aa&_first
	;
;int&aa&_not_first:			;not the first. we are going to hook vector.
	;pop	ds
	;mov	di, offset int19old&aa	;we have to set old&aa for int19 handler too.
	;mov	bx, offset old&aa	;pass where to save original owner pointer
	;mov	dx, offset int&aa	;pass where new handler is
	;call	new_init_loop		;adjust the vector to new handler, saving
	;				;pointer to original owner.
	;jmp	short int&aa&_end
;int&aa&_first:				;the first. don't have to hook stack code.
	;pop	ds
;int&aa&_end:
	;
	;endm

stkinit_0A:
	mov	si,0Ah*4 ; 40
	
; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_0A_first
	
	cmp	byte [bx],0CFh
	je	short int_0A_first
	
	cmp	word [bx+6],424Bh
	je	short int_0A_not_first
	
	cmp	dx,0F000h
	jne	short int_0A_not_first
	
	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
       	pop	dx
	pop	es
	je	short int_0A_first
%Endif

	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
	jnc	short int_0A_first
	
int_0A_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD0A
	mov	bx,old0A
	mov	dx,int0A
	call	new_init_loop
	
	; 14/12/2022	
	;jmp	short int_0A_end
;int_0A_first:
	; 25/10/2022
	;pop	ds

	; 14/12/2022
int_0A_first:
int_0A_end:

stkinit_0B:
	mov	si,0Bh*4 ; 44
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check ; 27/03/2019 - Retro DOS v4.0
	jnc	short int_0B_end ; int_0B_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_0B_first

	cmp	byte [bx],0CFh
	je	short int_0B_first
	
	cmp	word [bx+6],424Bh
	je	short int_0B_not_first
	
	cmp	dx,0F000h
	jne	short int_0B_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_0B_first
%endif

int_0B_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD0B
	mov	bx,old0B
	mov	dx,int0B
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_0B_end
;int_0B_first:
	; 25/10/2022
	;pop	ds

int_0B_end:
	
stkinit_0C:
	mov	si,0Ch*4 ; 48
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_0C_end ; int_0C_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_0C_first

	cmp	byte [bx],0CFh
	je	short int_0C_first
	
	cmp	word [bx+6],424Bh
	je	short int_0C_not_first
	
	cmp	dx,0F000h
	jne	short int_0C_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_0C_first
%endif
	
int_0C_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD0C
	mov	bx,old0C
	mov	dx,int0C
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_0C_end
;int_0C_first:
	; 25/10/2022
	;pop	ds

int_0C_end:

stkinit_0D:
	mov	si,0Dh*4 ; 52

	; 14/12/2022	
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_0D_end ; int_0D_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_0D_first

	cmp	byte [bx],0CFh
	je	short int_0D_first
	
	cmp	word [bx+6],424Bh
	je	short int_0D_not_first
	
	cmp	dx,0F000h
	jne	short int_0D_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_0D_first
%endif
	
int_0D_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD0D
	mov	bx,old0D
	mov	dx,int0D
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_0D_end
	; 02/11/2022
;int_0D_first:
	;pop	ds

int_0D_end:

stkinit_0E:
	mov	si,0Eh*4 ; 56

	; 14/12/2022	
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_0E_end ; int_0E_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_0E_first

	cmp	byte [bx],0CFh
	je	short int_0E_first
	
	cmp	word [bx+6],424Bh
	je	short int_0E_not_first
	
	cmp	dx,0F000h
	jne	short int_0E_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_0E_first
%endif
	
int_0E_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD0E
	mov	bx,old0E
	mov	dx,int0E
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_0E_end
;int_0E_first:
	; 25/10/2022
	;pop	ds	

int_0E_end:

stkinit_72:
	mov	si,72h*4 ; 456
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_72_end ; int_72_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_72_first

	cmp	byte [bx],0CFh
	je	short int_72_first
	
	cmp	word [bx+6],424Bh
	je	short int_72_not_first
	
	cmp	dx,0F000h
	jne	short int_72_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_72_first
%endif
	
int_72_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD72
	mov	bx,old72
	mov	dx,int72
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_72_end
;int_72_first:
	; 25/10/2022
	;pop	ds

int_72_end:

stkinit_73:
	mov	si,73h*4 ; 460
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_73_end ; int_73_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_73_first

	cmp	byte [bx],0CFh
	je	short int_73_first
	
	cmp	word [bx+6],424Bh
	je	short int_73_not_first
	
	cmp	dx,0F000h
	jne	short int_73_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_73_first
%endif	
	
int_73_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD73
	mov	bx,old73
	mov	dx,int73
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_73_end
;int_73_first:
	; 25/10/2022
	;pop	ds

int_73_end:

stkinit_74:
	mov	si,74h*4 ; 464
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_74_end ; int_74_first

; 14/12/2022
%if 0		
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_74_first

	cmp	byte [bx],0CFh
	je	short int_74_first
	
	cmp	word [bx+6],424Bh
	je	short int_74_not_first
	
	cmp	dx,0F000h
	jne	short int_74_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_74_first
%endif

int_74_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD74
	mov	bx,old74
	mov	dx,int74
	call	new_init_loop
	
	; 14/12/2022
	;jmp	short int_74_end
;int_74_first:
	; 25/10/2022
	;pop	ds

int_74_end:

stkinit_76:
	mov	si,76h*4 ; 472
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_76_end ; int_76_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_76_first

	cmp	byte [bx],0CFh
	je	short int_76_first
	
	cmp	word [bx+6],424Bh
	je	short int_76_not_first
	
	cmp	dx,0F000h
	jne	short int_76_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_76_first
%endif
	
int_76_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD76
	mov	bx,old76
	mov	dx,int76
	call	new_init_loop

	; 14/12/2022
	jmp	short int_76_end
;int_76_first:
	; 25/10/2022
	;pop	ds

int_76_end:

stkinit_77:
	mov	si,77h*4 ; 476
	
	; 14/12/2022
	; 25/10/2022
	call	int_xx_first_check
	jnc	short int_77_end ; int_77_first

; 14/12/2022
%if 0	
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_77_first

	cmp	byte [bx],0CFh
	je	short int_77_first
	
	cmp	word [bx+6],424Bh
	je	short int_77_not_first
	
	cmp	dx,0F000h
	jne	short int_77_not_first

	push	es
	push	dx
	mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
	pop	dx
	pop	es
	je	short int_77_first
%endif
	
int_77_not_first:
	; 14/12/2022
	; 25/10/2022
	;pop	ds
	mov	di,INT19OLD77
	mov	bx,old77
	mov	dx,int77
	call	new_init_loop

	; 14/12/2022
	;jmp	short int_77_end
;int_77_first:
	; 25/10/2022
	;pop	ds

int_77_end:
	push	ds
	mov	ax,0F000h		; look at the model byte
	mov	ds,ax
	cmp	byte [0FFFEh],0F9h ; mdl_convert ; pc convertible?
	pop	ds
	jne	short skip_enablenmis

	mov	al,27h			; enable convertible nmis
	out	72h,al

; 25/10/2022
; (MSDOS 5.0 SYSINIT:15FBh)

skip_enablenmis:
	sti
	;;mov	ax,Bios_Data ; 70h
	;mov	ax,KERNEL_SEGMENT ; 70h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax

	;mov	[640h],1 ; SYSINIT:1736h for MSDOS 6.21 IO.SYS

	mov	byte [INT19SEM],1	; indicate that int 19
					; initialization is complete

	pop	bp			; restore all
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	es
	pop	ds
	pop	ax
	retn

; 14/12/2022
; ----------------------------------------------------------------------

	; 14/12/2022
	; 25/10/2022
;%if 0
	; 27/03/2019 - Retro DOS v4.0
int_xx_first_check:
	push	ds
	lds	bx,[es:si]
	push	ds
	pop	dx
		
	cmp	dx,0
	je	short int_xx_first
	
	cmp	byte [bx],0CFh
	je	short int_xx_first
	
	cmp	word [bx+6],424Bh
	je	short int_xx_not_first
	
	cmp	dx,0F000h
	jne	short int_xx_not_first

	push	es
	;push	dx
	;mov	dx,0F000h
	mov	es,dx
	cmp	bx,[es:0FF01h]
      	;pop	dx
	pop	es
	je	short int_xx_first

int_xx_not_first:
	stc
int_xx_first:
	pop	ds
	retn

;%endif

; ----------------------------------------------------------------------
; 27/03/2019 - Retro DOS v4.0

; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
; (SYSINIT:1610h)

new_init_loop:

;input: si=ofset into vector table of the particular int vector being adjusted
;	bx=ds:offset of oldxx, where will be saved the pointer to original owner
;	dx=ds:offset of intxx, the new interrupt handler
;	di=offset value of int19old&aa variable in bios.
;	es=zero, segid of vector table
;	ds=relocated stack code segment

	mov	ax,[es:si]		;remember offset in vector
	mov	[bx],ax			; to original owner in ds
	mov	ax,[es:si+2]		;remember segid in vector
	mov	[bx+2],ax		; to original owner in ds

	push	ds
	;;mov	ax,Bios_Data ; 70h
	;mov	ax,KERNEL_SEGMENT ; 70h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax			;set int19oldxx value in bios for
	mov	ax,[es:si]		;int 19 handler
	mov	[di],ax
	mov	ax,[es:si+2]
	mov	word [di+2],ax
	pop	ds

	mov	[es:si],dx  	;set vector to point to new int handler
	mov	[es:si+2],ds
	retn

; End of STACK initialization routine
; ----------------------------------------------------------------------

; ----------------------------------------------------------------------
;set the devmark for mem command.
;in: [memhi] - the address to place devmark
;    [memlo] = 0
;    al = id for devmark_id
;out: devmark established.
;     the address saved in cs:[devmark_addr]
;     [memhi] increase by 1.
; ----------------------------------------------------------------------

; 25/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS, SYSINIT)
; (SYSINIT:1637h)

setdevmark:

	push	es
	push	cx

	mov	cx,[cs:memhi]
	mov	[cs:devmark_addr],cx
	mov	es,cx
	; 25/10/2022
	;mov	[es:devmark.id],al
	mov	[es:0],al
	inc	cx
	;mov	[es:devmark.seg],cx
	mov	[es:1],cx

	pop	cx
	pop	es
	inc	word [cs:memhi]
	retn

; ----------------------------------------------------------------------
; SYSCONF.ASM - MSDOS 6.0 - 1991
; ----------------------------------------------------------------------
; 27/03/2019 - Retro DOS v4.0

;MULTI_CONFIG	equ 1

HIGH_FIRST 	equ 080h		; from ARENA.INC - modifier for
                                        ; allocation strategy call

;have_install_cmd equ 00000001b 	; config.sys has install= commands
;has_installed	  equ 00000010b 	; sysinit_base installed.

default_filenum equ 8

;stacksw	equ true		; include switchable hardware stacks

; external variable defined in ibmbio module for multi-track

;multrk_on	equ 10000000b		;user spcified mutitrack=on,or system turns
					; it on after handling config.sys file as a
					; default value,if multrk_flag = multrk_off1.
;multrk_off1	equ 00000000b		;initial value. no "multitrack=" command entered.
;multrk_off2	equ 00000001b		;user specified multitrack=off.

; if stacksw

; internal stack parameters

;entrysize	equ 8

;mincount	equ 8
;defaultcount	equ 9
;maxcount	equ 64

;minsize 	equ 32
;defaultsize	equ 128
;maxsize 	equ 512

DOS_FLAG_OFFSET	equ 86h

;ifdef MULTI_CONFIG
;
;   config_envlen must immediately precede config_wrkseg, because they
;   may be loaded as a dword ptr

; 30/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; 25/10/2022
config_envlen:	dw  0  			; when config_wrkseg is being used as
               				;  a scratch env, this is its length
config_wrkseg:	dw  0			; config work area (above confbot)
                   			;  segment of work area

config_cmd:	db  0  			; current config cmd
                 			;  (with CONFIG_OPTION_QUERY bit intact)
config_multi:	db  0                   ; non-zero if multi-config config.sys

;endif ; MULTI_CONFIG

multdeviceflag:	db  0

devmark_addr:	dw  0			;segment address for devmark.

setdevmarkflag: db  0			;flag used for devmark

; 30/12/2022
; 12/12/2022
driver_units:	db  0			;total unitcount for driver

; 12/12/2022
;ems_stub_installed:
;		db  0

; 12/12/2022	
;align 2

badparm_ptr:	; label	dword
badparm_off:	dw  0
badparm_seg:	dw  0

;******************************************************************************
;take care of config.sys file.
;system parser data and code.
;******************************************************************************

;*******************************************************************
; parser options set for msbio sysconf module
;*******************************************************************
;
;**** default assemble swiches definition **************************

;farsw	equ 0		; near call expected
;datesw	equ 0		; check date format
;timesw	equ 0		; check time format
;filesw	equ 1		; check file specification
;capsw	equ 0		; perform caps if specified
;cmpxsw	equ 0		; check complex list
;numsw	equ 1		; check numeric value
;keysw	equ 0		; support keywords
;swsw	equ 1		; support switches
;val1sw	equ 1		; support value definition 1
;val2sw	equ 0		; support value definition 2
;val3sw	equ 1		; support value definition 3
;drvsw	equ 1		; support drive only format
;qussw	equ 0		; support quoted string format

; psdata_seg equ cs

	;.xlist
	;include parse.asm		;together with psdata.inc
	;.list

; PSDATA.INC - MSDOS 6.0 - 1991
; ======================================================================
; 27/03/2019 - Retro DOS v4.0

; 30/03/2019
; VERSION.INC (MSDOS 6.0) 
; Set DBCS Blank constant

; ifndef DBCS
DB_SPACE EQU 2020h
DB_SP_HI EQU 20h
DB_SP_LO EQU 20h
; else

;*******************************************************************
; Parser include file
;*******************************************************************

;**** Equation field
;-------- Character code definition

_$P_DBSP1	   equ	DB_SP_HI	;AN000; 1st byte of DBCS blank
_$P_DBSP2	   equ	DB_SP_LO	;AN000; 2nd byte of DBCS blank
_$P_Period	   equ	"."             ;AN020;
_$P_Slash	   equ	"/"             ;AN020;
_$P_Space	   equ	" "             ;AN000; SBCS blank
_$P_Comma	   equ	","             ;AN000;
_$P_Switch	   equ	"/"             ;AN000;
_$P_Keyword	   equ	"="             ;AN000;
_$P_Colon	   equ	":"             ;AN000;
_$P_Plus 	   equ	"+"             ;AN000;
_$P_Minus	   equ	"-"             ;AN000;
_$P_Rparen	   equ	")"             ;AN000;
_$P_Lparen	   equ	"("             ;AN000;
;_$P_SQuote        equ  "'"			;AN025; deleted
_$P_DQuote	   equ	'"'             ;AN000;
_$P_NULL 	   equ	0		;AN000;
_$P_TAB		   equ	9		;AN000;
_$P_CR		   equ	0Dh		;AN000;
_$P_LF		   equ	0Ah		;AN000;
_$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code

;-------- Masks
_$P_Make_Lower	   equ	20h		;AN000; make lower case character
_$P_Make_Upper	   equ	0FFh-_$P_Make_Lower ;AN000; make upper case character

;-------- DOS function call related equs

_$P_DOS_Get_CDI	   equ	3800h		;AN000; get country dependent information
					; by this call, following information
struc _$P_CDI	
 .DateF: resw 1
 .Money: resb 5
 .1000:	 resb 2
 .Dec:	 resb 2
 .DateS: resb 2
 .TimeS: resb 2
    	 resb 1
	 resb 1
 .TimeF: resb 1	 
	 resw 2
	 resb 2
	 resw 5
 .size:
endstruc

_$P_Date_MDY	   equ	0		;AN000;
_$P_Date_DMY	   equ	1		;AN000;
_$P_Date_YMD	   equ	2		;AN000;
;-------------
_$P_DOS_GetEV	   equ	6300h		;AN000; get DBCS EV call
					;AN000; DS:SI will points to DBCS EV
;-------------
_$P_DOS_Get_TBL	   equ	65h		;AN000; get uppercase table call
					;AN000; following parameters are set
					;AN000; to get casemap table.
_$P_DOSTBL_Def	   equ	-1		;AN000; get default
_$P_DOSTBL_BL	   equ	5		;AN000; buffer length for Tbl pointer
_$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
_$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
					; By this call following information
					; is returned.
struc _$P_DOS_TBL
 .InfoID: resb 1			;AN000; information id for the table
 .Off:	 resw 1				;AN000; offset address of the table
 .Seg:	 resw 1				;AN000; segment address of the table
endstruc

; ----------------------------------------------------------------------------
; PARMS 	LABEL	BYTE
;		DW	PARMSX
;		DB	2		; NUMBER OF STRINGS (0, 1, 2)
;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "          ; EXTRA DELIMITER LIST,
;					; TYPICAL ARE ";", "="
;					; "," & WHITESPACE ALWAYS
;		DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
;		DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
; ----------------------------------------------------------------------------

;-------------------------------- PARMS block structure
struc _$P_PARMS_Blk
 .PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 .Num_Extra:	   resb 1		;AN000; Number of extra stuff
 .Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
endstruc

_$P_Len_PARMS	   equ	4		;AN000;
_$P_I_Use_Default  equ	0		;AN000; no extra stuff specified
_$P_I_Have_Delim   equ	1		;AN000; extra delimiter specified
_$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified

; ----------------------------------------------------------------------------
; PARMSX	LABEL	BYTE
;		DB	minp,maxp	; MIN, MAX POSITIONAL OPERANDS ALLOWED
;		DW	CONTROL 	; DESCRIPTION OF POSITIONAL 1
;		:			; REPEATS maxp-1 TIMES
;		DB	maxs		; # OF SWITCHES
;		DW	CONTROL 	; DESCRIPTION OF SWITCH 1
;		:			; REPEATS maxs-1 TIMES
;		DB	maxk		; # OF KEYWORD
;		DW	CONTROL 	; DESCRIPTION OF KEYWORD 1
;		:			; REPEATS maxk-1 TIMES
; ----------------------------------------------------------------------------

;-------------------------------- PARMSX block structure
struc _$P_PARMSX_Blk		;AN000;
 .MinP: resb 1			;AN000; Minimum positional number
 .MaxP:	resb 1			;AN000; Maximum positional number
 .1st_Control: resw 1		;AN000; Address of the 1st CONTROL block
endstruc

; ----------------------------------------------------------------------------
; << Control field definition  >>
;
;
;CONTROL   LABEL   BYTE
;	   DW	   MATCH_FLAGS	   ; CONTROLS TYPE MATCHED
;				   ; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
;				   ; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
;				   ; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
;				   ; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
;				   ; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
;				   ; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
;				   ; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
;				   ; 0010H=IGNORE ":" AT END IN MATCH
;				   ; 0002H=REPEATS ALLOWED
;				   ; 0001H=OPTIONAL
;	   DW	   FUNCTION_FLAGS
;				   ; 0001H=CAP RESULT BY FILE TABLE
;				   ; 0002H=CAP RESULT BY CHAR TABLE
;				   ; 0010H=REMOVE ":" AT END
; (tm10)			   ; 0020H=colon is not necessary for switch
;	   DW	   RESULT	   ; RESULT BUFFER
;	   DW	   VALUES	   ; VALUE LISTS
;	   DB	   nid		   ; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
;	   DB	   "...",0         ; IF n >0, KEYWORD 1
;	   :
;
;Note:
;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
;      DATE bit simalteniously.
;
;      The parser examins each bit along with the following priority.
;
;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
;      FILE SPEC -> SIMPLE STRING.
;
;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
;      in the result buffer is capitalized.
;
;    - Match_Flags 0001H and 0002H have meaning only for the positional.
;
;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
;      switch, for example, '/A', then STRING points to;
;
;			DB    1 	; number of following synonyms
;			DB   '/A',0
;
;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
;
;			DB    1 	; number of following synonyms
;			DB   'CODEPAGE=',0
;
;    - "..." must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;
;    - One "..." can contain only one switch or keyword. If you need, for
;      example /A and /B, the format will be;
;
;			DB    2 	; number of following synonyms
;			DB    '/A',0
;			DB    '/B',0
; ----------------------------------------------------------------------------

;**** Match_Flags

_$P_Num_Val	   equ	8000h		;AN000; Numeric Value
_$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
_$P_Simple_S	   equ	2000h		;AN000; Simple string
_$P_Date_S	   equ	1000h		;AN000; Date string
_$P_Time_S	   equ	0800h		;AN000; Time string
_$P_Cmpx_S	   equ	0400h		;AN000; Complex string
_$P_File_Spc	   equ	0200h		;AN000; File Spec
_$P_Drv_Only	   equ	0100h		;AN000; Drive Only
_$P_Qu_String	   equ	0080h		;AN000; Quoted string
_$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
_$P_Repeat	   equ	0002h		;AN000; Repeat allowed
_$P_Optional	   equ	0001h		;AN000; Optional

;**** Function flags

_$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
_$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
_$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
_$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10

;-------------------------------- Control block structure
struc _$P_Control_Blk
 .Match_Flag:	 resw 1		;AN000; Controls type matched
 .Function_Flag: resw 1		;AN000; Function should be taken
 .Result_Buf:	 resw 1		; Result buffer address
 .Value_List:	 resw 1		;AN000; Value list address
 .nid:		 resb 1		;AN000; # of keyword/SW synonyms
 .KEYorSW:	 resb 1		;AN000; keyword or sw
endstruc

; ----------------------------------------------------------------------------
; << Value List Definition >>
;
;VALUES 	LABEL	BYTE
;		DB	nval			; NUMBER OF VALUE DEFINITIONS (0 - 3)
;	     +-
;	     |	DB	nrng			; NUMBER OF RANGES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF RANGE MATCHED
;	     | +DD	X,Y			; RANGE OF VALUES
;	     |	:
;	     |	DB	nnval			; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF NUMBER CHOICE MATCHED
;	     | +DD	VALUE			; SPECIFIC CHOICE IF NUMBER
;	     |	:
;	     |	DB	nstrval 		; NUMBER OF CHOICES
;	     | +DB	ITEM_TAG		; RETURN VALUE IF STRING CHOICE MATCHED
;	     | +DW	STRING			; SPECIFIC CHOICE IF STING
;	     +-	:
;
;STRING 	DB	"...",0                 ; ASCIIZ STRING IMAGE
;
;Note:
;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
;      when no choice lists are provided.
;
;    - STRING must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
; ----------------------------------------------------------------------------

_$P_nval_None	   equ	0		;AN000; no value list ID
_$P_nval_Range	   equ	1		;AN000; range list ID
_$P_nval_Value	   equ	2		;AN000; value list ID
_$P_nval_String	   equ	3		;AN000; string list ID
_$P_Len_Range	   equ	9		;AN000; Length of a range choice(two DD plus one DB)
_$P_Len_Value	   equ	5		;AN000; Length of a value choice(one DD plus one DB)
_$P_Len_String	   equ	3		;AN000; Length of a string choice(one DW plus one DB)
_$P_No_nrng	   equ	0		;AN000; (tm07) no nrng. nnval must not be 0.

struc _$P_Val_List
 .NumofList: resb 1			;AN000; number of following choice
 .Val_XL:    resw 1			;AN000; lower word of value
 .Val_XH:    resw 1			;AN000; higher word of value
 .Val_YL:    resw 1			;AN000; lower word of another value
 .Val_YH:    resw 1			;AN000; higher word of another value
endstruc

; ----------------------------------------------------------------------------
; << Result Buffer Definition  >>
;
;RESULT 	LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
;		DB	type			; TYPE RETURNED: 0=RESERVED,
;						;	1=NUMBER, 2=LIST INDEX,
;						;	3=STRING, 4=COMPLEX,
;						;	5=FILESPEC, 6=DRIVE
;						;	7=DATE, 8=TIME
;						;	9=QUOTED STRING
;		DB	ITEM_TAG		; MATCHED ITEM TAG
;
;		dw	synonym@		; es:@ points to found SYNONYM if provided.
;
;            +-
;	    | DD	n			; VALUE IF NUMBER
;	    | or
;	    |	DW	i			; INDEX (OFFSET) INTO VALUE LIST
;	    |					; (ES presents Segment address)
;	    | or
;	    |	DD	STRING			; OFFSET OF STRING VALUE
;	    | or
;	    |	DB	drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
;	    | or
;	    |	DW	YEAR	   ;(1980-2099)  IN CASE OF DATE
;	    |	DB	MONTH	   ;(1-12)	 Note: Range check is not performed.
;	    |	DB	DATE	   ;(1-31)	       0 is filled when the corresponding field was not specified.
;	    | or
;	    |	DB	HOUR	   ;(0-23)	  IN CASE OF TIME
;	    |	DB	MINUTES    ;(0-59)	  Note: Range check is not performed .
;	    |	DB	SECONDS    ;(0-59)		0 is filled when the corresponding field was not specified .
;	    |	DB	HUNDREDTHS ;(0-99)
;	    +-
;
;
;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
;      list.
;
;      YEAR: If the input value for the year is less than 100, parser
;	     adds 1900 to it.  For example, when 87 is input to parser for
;	     the year value, he returns 1987.
; ----------------------------------------------------------------------------

;-------------------------------- Result block structure
struc _$P_Result_Blk
 .Type:        resb 1		;AN000; Type returned
 .Item_Tag:    resb 1		;AN000; Matched item tag
 .SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 .Picked_Val:  resb 4		;AN000; value
endstruc

;--------------------------------
;**** values for the type field in the result block

_$P_EOL		   equ	0		;AN000; End of line
_$P_Number	   equ	1		;AN000; Number
_$P_List_Idx	   equ	2		;AN000; List Index
_$P_String	   equ	3		;AN000; String
_$P_Complex	   equ	4		;AN000; Complex
_$P_File_Spec	   equ	5		;AN000; File Spec
_$P_Drive	   equ	6		;AN000; Drive
_$P_Date_F	   equ	7		;AN000; Date
_$P_Time_F	   equ	8		;AN000; Time
_$P_Quoted_String  equ	9		;AN000; Quoted String

_$P_No_Tag	   equ	0FFh		;AN000; No ITEM_TAG found

;**** Return code
;
; following return code will be returned in the AX register.

_$P_No_Error	   equ	0		;AN000; No error
_$P_Too_Many	   equ	1		;AN000; Too many operands
_$P_Op_Missing	   equ	2		;AN000; Required operand missing
_$P_Not_In_SW	   equ	3		;AN000; Not in switch list provided
_$P_Not_In_Key	   equ	4		;AN000; Not in keyword list provided
_$P_Out_Of_Range   equ	6		;AN000; Out of range specified
_$P_Not_In_Val	   equ	7		;AN000; Not in value list provided
_$P_Not_In_Str	   equ	8		;AN000; Not in string list provided
_$P_Syntax	   equ	9		;AN000; Syntax error
_$P_RC_EOL	   equ	-1		;AN000; End of command line

; DATA - Retro DOS v4.0 - 27/03/2019

; MSDOS 6.2 IO.SYS SYSINIT:179Ch

;********************** Local Data *************************************
_$P_ORDINAL:	   dw	0		;AN000; Operand ordinal save area
_$P_RC:		   dw	0		;AN000; Return code from parser
_$P_SI_Save:	   dw	0		;AN000; Pointer of command buffer
_$P_DX:		   dw	0		;AN000; Return result buffer address
_$P_Terminator:	   db	0		;AN000; Terminator code (ASCII)
_$P_DBCSEV_OFF:	   dw	0		;AN000; Offset of DBCS EV
_$P_DBCSEV_SEG:	   dw	0		;AN000; Segment of DBCS EV
_$P_Flags:	   dw	0		;AN000; Parser internal flags
%define _$P_Flags1 _$P_Flags		;AN038; to reference first byte flags
%define _$P_Flags2 _$P_Flags+1		;AN038; to reference second byte flags only

;in second byte of _$P_Flags, referenced as _$P_Flags2:
_$P_equ		   equ	01h	      ;AN000; "=" packed in string buffet
_$P_Neg		   equ	02h	      ;AN000; Negative value
_$P_Time12	   equ	04h	      ;AN000; set when PM is specified
_$P_Key_Cmp	   equ	08h	      ;AN000; set when keyword compare
_$P_SW_Cmp	   equ	10h	      ;AN000; set when switch compare
_$P_Extra	   equ	20h	      ;AN000; set when extra delimiter found
_$P_SW		   equ	40h	      ;AN000; set when switch found (tm08)
_$P_Signed	   equ	80h	      ;AN000; signed numeric specified

;in first byte of _$P_Flags, referenced as _$P_Flags1:
_$P_time12am	   equ	01h	      ;AN038; set when AM is specified on time
_$P_TIME_AGAIN	   equ	02h	      ;AN039; SET WHEN READY TO RE-PARSE TIME

_$P_SaveSI_Cmpx:   dw	0		;AN000; save si for later use by complex
_$P_KEYorSW_Ptr:   dw	0		;AN000; points next to "=" or ":" code
_$P_Save_EOB:	   dw	0		;AN000; save pointer to EOB
_$P_Found_SYNONYM: dw	0		;AN000; es:@ points to found synonym

_$P_STRING_BUF:	   times 128 db 0	;AN000; Pick a operand from command line
_$P_STRING_BUF_END equ	$		;AN000;

; 25/10/2022
; (MSDOS 5.0 IO.SYS, SYSINIT:16F8h)

_$P_Char_CAP_Ptr:  db	0FFh		;AN000; info id
		   dw	0		;AN000; offset	of char case map table
		   dw	0		;AN000; segment of char case map table
; 25/10/2022
;IF CAPSW
;_$P_File_CAP_Ptr: db	0FFh		;AN000; info id
;		   dw	0		;AN000; offset	of file case map table
;		   dw	0		;AN000; segment of file case map table
;ENDIF

; (tm06) IF FileSW			;AN000;(Check if file spec is supported)
;

;M029
;!!!WARNING!!!
; In routine SYSPARSE (parse.asm), _$P_FileSp_Char is reinitialized using 
;hardcoded strings. If the chars in the string are changed here, corresponding
;changes need to be made in SYSPARSE

;IF FileSW+DrvSW 			;AN000;(Check if file spec is supported)

; 25/10/2022
; (MSDOS 5.0 IO.SYS, SYSINIT:16FDh)

_$P_FileSp_Char	   db	'[]|<>+=;"'     ;AN000; delimitter of file spec
_$P_FileSp_Len	   equ	$-_$P_FileSp_Char ;AN000;

;ENDIF					;AN000;(of FileSW)

; delimiter parsing
_$P_colon_period   equ	01h		;AN032; check for colon & period
_$P_period_only	   equ	02h		;AN032; check only for period

;filespec error flag
_$P_err_flag:	   db	0		;AN033; flag set if filespec parsing error
					;AN033;  was detected.
_$P_error_filespec equ	01h		;AN033; mask to set flag


; PARSE.ASM - MSDOS 6.0 - 1991
; ======================================================================
; 27/03/2019 - Retro DOS v4.0

;***********************************************************************
; SysParse;
;
;  Function : Parser Entry
;
;  Input: DS:SI -> command line
;	  ES:DI -> parameter block
;	  cs -> psdata.inc
;	  CX = operand ordinal
;
;	  Note:  ES is the segment containing all the control blocks defined
;		 by the caller, except for the DOS COMMAND line parms, which
;		 is in DS.
;
;  Output: CY = 1   error of caller, means invalid parameter block or
;		    invalid value list. But this parser does NOT implement
;		    this feature. Therefore CY always zero.
;
;	   CY = 0   AX = return code
;		    BL = terminated delimiter code
;		    CX = new operand ordinal
;		    SI = set past scaned operand
;		    DX = selected result buffer
;
; Use:	_$P_Skip_Delim, _$P_Chk_EOL, _$P_Chk_Delim, _$P_Chk_DBCS
;	_$P_Chk_Swtch, _$P_Chk_Pos_Control, _$P_Chk_Key_Control
;	_$P_Chk_Sw_Control, _$P_Fill_Result
;
; Vars: _$P_Ordinal(RW), _$P_RC(RW), _$P_SI_Save(RW), _$P_DX(R), _$P_Terminator(R)
;	_$P_SaveSI_Cmpx(W), _$P_Flags(RW), _$P_Found_SYNONYM(R), _$P_Save_EOB(W)
;
;-------- Modification History -----------------------------------------
;
;  4/04/87 : Created by K. K,
;  4/28/87 : _$P_Val_YH assemble error (tm01)
;	   : JMP SHORT assemble error (tm02)
;  5/14/87 : Someone doesn't want to include psdata (tm03)
;  6/12/87 : _$P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
;	     DateSW equ 1)	      (tm04)
;  6/12/87 : _$P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
;				      (tm05) in PSDATA.INC
;  6/12/87 : _$P_FileSp_Char and _$P_FileSP_Len are missing
;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
;	     value-list block	      (tm07)
;  6/20/87 : Add _$P_SW to check if there's an omiting parameter after
;	     switch (keyword) or not. If there is, backup si for next call
;	     (tm08)
;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
;  6/24/87 : New function flag _$P_colon_is_not_necessary for switch
;	     /+15 and /+:15 are allowed for user (tm10)
;  6/29/87 : ECS call changes DS register but it causes the address problem
;	     in user's routines. _$P_Chk_DBCS (tm11)
;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
;					  (tm12)
;  7/10/87 : Invalid switch/keyword does not work correctly
;					  (tm13)
;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
;					  (tm14)
;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
;					  (tm15)
;  7/24/87 : Negative lower bound on numeric ranges cause trouble

;  7/24/87 : Quoted strings being returned with quotes.

;  7/28/87 : Kerry S (;AN018;)
;	     Non optional value on switch (match flags<>0 and <>1) not flagged
;	     as an error when missing.	Solution: return error 2.  Modules
;	     affected: _$P_Chk_SW_Control.

;  7/29/87 : Kerry S (;AN019;)
;	     Now allow the optional bit in match flags for switches.  This
;	     allows the switch to be encountered with a value or without a
;	     value and no error is returned.
;

;  8/28/87 : Ed K, Kerry S (;AN020;)
;  9/14/87   In PROC _$P_Get_DecNum, when checking for field separators
;	     within a date response, instead of checking just for the one
;	     character defined by the COUNTRY DEPENDENT INFO, check for
;	     all three chars, "-", "/", and ".". Change _$P_Chk_Switch to allow
;	     slashes in date strings when DateSw (assembler switch) is set.

;  9/1/87  : Kerry S (;AN021)
;	     In PROC _$P_String_Comp, when comparing the switch or keyword on
;	     the command line with the string in the control block the
;	     comparing was stopping at a colon (switch) or equal (keyword)
;	     on the command line and assuming a match.	This allowed a shorter
;	     string on the command line than in the synonym list in the control
;	     block.  I put in a test for a null in the control block so the
;	     string in the control block must be the same length as the string
;	     preceeding the colon or equal on the command line.

;  8/28/87 : Kerry S (;AN022;)
;	     All references to data in PSDATA.INC had CS overrides.  This caused
;	     problems for people who included it themselves in a segment other
;	     than CS.  Added switch to allow including PSDATA.INC in any
;	     segment.

;  9/16/87 : Ed K (;AN023;) PTM1040
;	     in _$P_set_cdi PROC, it assumes CS points to psdata. Change Push CS
;	     into PUSH cs.  In _$P_Get_DecNum PROC, fix AN020
;	     forced both TIME and DATE to use the delims, "-","/",".".
;	     Created FLag, in _$P_time_Format PROC, to request the delim in
;	     BL be used if TIME is being parsed.

;  9/24/87 : Ed K
;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
;	     invocations with their normally expanded code; made comments
;	     out of the STRUC macro invocation statements to maintain readability.

;  9/24/87 : Ed K (;AN024;) PTM1222
;	     When no CONTROL for a keyword found, tried to fill in RESULT
;	     pointed to by non-existant CONTROL.

; 10/15/87 : Ed K (;AN025;) PTM1672
;	     A quoted text string can be framed only by double quote.  Remove
;	     support to frame quoted text string with single quote.
;	     (apostrophe) _$P_SorD_Quote is removed from PSDATA.INC.
;	     _$P_SQuote EQU also removed from PSDATA.INC.  Any references to
;	     single quote in PROC prologues are left as is for history reasons.

;	     This fixes another bug, not mentioned in p1672, in that two
;	     quote chars within a quoted string is supposed to be reported as
;	     one quote character, but is reported as two quotes.  This changed
;	     two instructions in PROC _$P_Quoted_Str.

;	     Also fixed are several JMP that caused a NOP, these changed to
;	     have the SHORT operator to avoid the unneeded NOP.

;	     The code and PSDATA.INC have been aligned for ease of reading.

; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
;	     psdata buffer should have cs.

; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
;	     positional missing.

; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
;	     as a line delimiter, should use carriage return.
;	     Define switch: LFEOLSW, if on, accept LF as end of line char.

; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".

; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
;	     endless loop since SI is returned still pointing to start
;	     of that parm.

; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
;	     Vector to returned string has CS instead of cs, but
;	     when tried to fix it on previous version, changed similar
;	     but wrong place.

; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
;	     delimiters between hours, minutes, seconds for time. And period
;	     and comma are valid delimiters between seconds and 100th second.

; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
;	     in a filespec, then flag an error.

; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
;	     indexed off of the cs equate instead of the DS register.
;	     Using this method, DS can point to the segment of PSP or to psdata
;  -->	     local parser data. Why were some references to local data changed
;	     to do this before, but not all ?????

; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.

; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, cs HOSED.
;
; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.

; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error

; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
;	     separator in TIME before hundredths field.
;
; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
;			strings as keywords.
;
;***********************************************************************

;IF FarSW				;AN000;(Check if need far return)
;SysParse proc far			;AN000;
;ELSE					;AN000;
;SysParse proc near			;AN000;
;ENDIF					;AN000;(of FarSW)

; 27/03/2019 - Retro DOS v4.0
; (MSDOS 6.21 IO.SYS - SYSINIT:1842h)

; 25/10/2022 - Retro DOS v4.0
; (MSDOS 5.0 IO.SYS - SYSINIT:1707h)

SysParse:
	mov	word [cs:_$P_Flags],0	;AC034; Clear all internal flags
	cld				;AN000; confirm forward direction
	mov	word [cs:_$P_ORDINAL],cx ;AC034; save operand ordinal
	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; Assume no error
	mov	word [cs:_$P_Found_SYNONYM],0 ;AC034; initalize synonym pointer

	mov	word [cs:_$P_DX],0	;AC034; (tm15)

;M029 -- Begin changes
; The table of special chars _$P_FileSp_Char should be initialized on every
;entry to SysParse. This is in the non-checksum region and any program that
;corrupts this table but does not corrupt the checksum region will leave
;command.com parsing in an inconsistent state.
; NB: The special characters string has been hardcoded here. If any change
;is made to it in psdata.inc, a corresponding change needs to be made here.

;IF FileSW + DrvSW
	mov	word [cs:_$P_FileSp_Char], ']['
	mov	word [cs:_$P_FileSp_Char+2], '<|'
	mov	word [cs:_$P_FileSp_Char+4], '+>'
	mov 	word [cs:_$P_FileSp_Char+6], ';='
;ENDIFtHHH

;M029 -- End of changes

	call	_$P_Skip_Delim		;AN000; Move si to 1st non white space
	jnc	short _$P_Start		;AN000; If EOL is not encountered, do parse
;--------------------------- End of Line
	mov	ax,_$P_RC_EOL		;AN000; set exit code to -1
	push	bx			;AN000;
	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address]
					;AN000; Get the PARMSX address to
	mov	bx,[es:di]
	;cmp	cl,[es:bx+_$P_PARMSX_Blk.MinP]
					;AN000; check ORDINAL to see if the minimum
	cmp	cl,[es:bx]	
	jae	short _$P_Fin		;AN000; positional found.

	mov	ax,_$P_Op_Missing	;AN000; If no, set exit code to missing operand
_$P_Fin: 				;AN000;
	pop	bx			;AN000;
	jmp	_$P_Single_Exit		;AN000; return to the caller
;---------------------------
_$P_Start:				;AN000;
	mov	[cs:_$P_SaveSI_Cmpx],si ;AN000;AC034; save ptr to command line for later use by complex,
	push	bx			;AN000; quoted string or file spec.
	push	di			;AN000;
	push	bp			;AN000;
	;lea	bx,[cs:_$P_STRING_BUF] ;AC034; set buffer to copy from command string
	; 02/11/2022
	lea	bx,[_$P_STRING_BUF]
	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 extra delimiter encountered ?
	jnz	short _$P_Pack_End	;AN000; 3/9 if yes, no need to copy

_$P_Pack_Loop:				;AN000;
	lodsb				;AN000; Pick a operand from buffer
	call	_$P_Chk_Switch		;AN000; Check switch character
	jc	short _$P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue

	call	_$P_Chk_EOL		;AN000; Check EOL character
	je	short _$P_Pack_End_BY_EOL ;AN000; need backup si

	call	_$P_Chk_Delim		;AN000; Check delimiter
	jne	short _$P_PL01 		;AN000; If no, process next byte

	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; 3/9 If yes and white spec,
; (tm08)jne	short _$P_Pack_End	;AN000; 3/9 then
	jnz	short _$P_Pack_End_backup_si ;AN000; (tm08)

	call	_$P_Skip_Delim		;AN000; skip subsequent white space,too
	jmp	short _$P_Pack_End	;AN000; finish copy by placing NUL at end

_$P_Pack_End_backup_si:			;AN000; (tm08)
	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AN000;AC034;  (tm08)
	jz	short _$P_Pack_End	;AN000; (tm08)

	dec	si			;AN000; (tm08)
	jmp	short _$P_Pack_End	;AN025; (tm08)

_$P_PL01:				;AN000;
	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
	cmp	al,_$P_Keyword  ;'='	;AN000; if it is equal character,
	jne	short _$P_PL00 		;AN000; then

	or	byte [cs:_$P_Flags2],_$P_equ ;AC034; remember it in flag
_$P_PL00:				;AN000;
	inc	bx			;AN000; ready to see next byte
	call	_$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
	jnc	_$P_Pack_Loop		;AN000; if no, process to next byte

	lodsb				;AN000; if yes, store
	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
	inc	bx			;AN000; update pointer
	jmp	short _$P_Pack_Loop	;AN000; process to next byte

_$P_Pack_End_BY_EOL:			;AN000;
	dec	si			;AN000; backup si pointer
_$P_Pack_End:				;AN000;
	mov	[cs:_$P_SI_Save],si     ;AC034; save next pointer, SI
	mov	byte [cs:bx],_$P_NULL	;AN000; put NULL at the end
	mov	[cs:_$P_Save_EOB],bx    ;AC034; 3/17/87 keep the address for later use of complex
	;mov	bx,[es:di+_$P_PARMS_Blk.PARMSX_Address] ;AN000; get PARMSX address
	mov	bx,[es:di]
	;lea	si,[cs:_$P_STRING_BUF]	;AC034;
	; 02/11/2022
	lea	si,[_$P_STRING_BUF]
	cmp	byte [cs:si],_$P_Switch ;AN000; the operand begins w/ switch char ?
	je	short _$P_SW_Manager	;AN000; if yes, process as switch

	cmp	byte [cs:si],_$P_DQuote	;M005;is it a string?
	je	short _$P_Positional_Manager ;M005;if so, process as one!

	test	byte [cs:_$P_Flags2],_$P_equ ;AC034; the operand includes equal char ?
	jnz	short _$P_Key_Manager	;AN000; if yes, process as keyword

_$P_Positional_Manager:			;AN000; else process as positional
	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	cmp	[cs:_$P_ORDINAL],ax	;AC034; too many positional ?
	jae	short _$P_Too_Many_Error ;AN000; if yes, set exit code to too many

	mov	ax,[cs:_$P_ORDINAL]	;AC034; see what the current ordinal
	shl	ax,1			;AN000; ax = ax*2
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; now bx points to 1st CONTROL
	add	bx,ax			;AN000; now bx points to specified CONTROL address
	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
	call	_$P_Chk_Pos_Control	;AN000; Do process for positional
	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller

_$P_Too_Many_Error:			;AN000;
	mov	word [cs:_$P_RC],_$P_Too_Many ;AC034; set exit code
	jmp	short _$P_Return_to_Caller ;AN000; and return to the caller

_$P_SW_Manager:				;AN000;
	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	cl,[es:bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxs
	or	cx,cx			;AN000; at least one switch ?
	jz	short _$P_SW_Not_Found 	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL address

_$P_SW_Mgr_Loop: 			;AN000;
	push	bx			;AN000;
	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
	call	_$P_Chk_SW_Control	;AN000; do process for switch
	pop	bx			;AN000;
	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the switch, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
	loop	_$P_SW_Mgr_Loop		;AN000; and loop

_$P_SW_Not_Found:			;AN000;
	mov	word [cs:_$P_RC],_$P_Not_In_SW ;AC034; here no CONTROL for the switch has
	jmp	short _$P_Return_to_Caller ;AN000; not been found, means error.

_$P_Key_Manager: 			;AN000;
	mov	al,[es:bx+_$P_PARMSX_Blk.MaxP] ;AN000; get maxp
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	al,[es:bx]		;AN000;
	xor	ah,ah			;AN000; ax = maxs
	shl	ax,1			;AN000;
	inc	ax			;AN000; ax = ax*2+1
	add	bx,ax			;AN000; now bx points to maxk
	mov	cl,[es:bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxk
	or	cx,cx			;AN000; at least one keyword ?
	je	short _$P_Key_Not_Found	;AN000;

	inc	bx			;AN000; now bx points to 1st CONTROL

_$P_Key_Mgr_Loop:			;AN000;
	push	bx			;AN000;
	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
	call	_$P_Chk_Key_Control	;AN000; do process for keyword
	pop	bx			;AN000;
	jnc	short _$P_Return_to_Caller ;AN000; if the CONTROL is for the keyword, exit

	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
	loop	_$P_Key_Mgr_Loop 	;AN000; and loop

_$P_Key_Not_Found:			;AN000;
	mov	word [cs:_$P_RC],_$P_Not_In_Key ;AC034; here no CONTROL for the keyword has
_$P_Return_to_Caller:			;AN000;
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	bx			;AN000;
	mov	cx,[cs:_$P_ORDINAL]	;AC034; return next ordinal
	mov	ax,[cs:_$P_RC]		;AC034; return exit code
	mov	si,[cs:_$P_SI_Save]	;AC034; return next operand pointer
	mov	dx,[cs:_$P_DX]		;AC034; return result buffer address
	mov	bl,[cs:_$P_Terminator]	;AC034; return delimiter code found
_$P_Single_Exit: 			;AN000;
	clc				;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Chk_Pos_Control
;
; Function: Parse CONTROL block for a positional
;
; Input:     ES:BX -> CONTROL block
;	     cs:SI -> _$P_STRING_BUF
;
; Output:    None
;
; Use:	 _$P_Fill_Result, _$P_Check_Match_Flags
;
; Vars: _$P_Ordinal(W), _$P_RC(W)
;***********************************************************************

_$P_Chk_Pos_Control:
	push	ax			;AN000;
	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag] ;AN000;
	mov	ax,[es:bx]
	; 12/12/2022
	test	al,_$P_Repeat
	;test	ax,_$P_Repeat		;AN000; repeat allowed ?
	jnz	short _$P_CPC00		;AN000; then do not increment ORDINAL

	inc	word [cs:_$P_ORDINAL]	;AC034; update the ordinal
_$P_CPC00:				;AN000;
	cmp	byte [cs:si],_$P_NULL	;AN000; no data ?
	jne	short _$P_CPC01		;AN000;

	; 12/12/2022
	test	al,_$P_Optional
	;test	ax,_$P_Optional		;AN000; yes, then is it optional ?
	jnz	short _$P_CPC02		;AN000;

	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; no, then error 3/17/87
	jmp	short _$P_CPC_Exit	;AN000;

_$P_CPC02:				;AN000;
	push	ax			;AN000;
	mov	al,_$P_String		;AN000; if it is optional return NULL
	mov	ah,_$P_No_Tag		;AN000; no item tag indication
	call	_$P_Fill_Result		;AN000;
	pop	ax			;AN000;
	jmp	short _$P_CPC_Exit	;AN000;

_$P_CPC01:				;AN000;
	call	_$P_Check_Match_Flags	;AN000;
_$P_CPC_Exit:				;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Chk_Key_Control
;
; Function: Parse CONTROL block for a keyword
;
; Input:     ES:BX -> CONTROL block
;	     cs:SI -> _$P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
;
; Vars: _$P_RC(W), _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
;***********************************************************************

_$P_Chk_Key_Control:
	stc				;AN000; this logic works when the KeySW
	retn				;AN000; is reset.

;***********************************************************************
; _$P_Search_KEYorSW:
;
; Function: Seach specified keyword or switch from CONTROL
;
; Input:     ES:BX -> CONTROL block
;	     cs:SI -> _$P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 _$P_String_Comp, _$P_MoveBP_NUL, _$P_Found_SYNONYM
;***********************************************************************

	; 25/10/2022 - Retro DOS v4.0
	; (MSDOS 5.0 IO.SYS - SYSINIT:18B6h)

_$P_Search_KEYorSW:			;AN000;
	push	bp			;AN000;
	push	cx			;AN000;
	mov	cl,[es:bx+_$P_Control_Blk.nid] ;AN000; Get synonym count
	xor	ch,ch			;AN000; and set it to cx
	or	cx,cx			;AN000; No synonyms specified ?
	jz	short _$P_KEYorSW_Not_Found ;AN000; then indicate not found by CY

	;lea	bp,[es:bx+_$P_Control_Blk.KEYorSW] ;AN000; BP points to the 1st synonym
	; 25/10/2022
	lea	bp,[bx+_$P_Control_Blk.KEYorSW]
	;lea	bp,[bx+9]
_$P_KEYorSW_Loop:			;AN000;
	call	_$P_String_Comp		;AN000; compare string in buffer w/ the synonym
	jnc	short _$P_KEYorSW_Found	;AN000; If match, set it to synonym pointer

	call	_$P_MoveBP_NUL		;AN000; else, bp points to the next string
	loop	_$P_KEYorSW_Loop 	;AN000; loop nid times
_$P_KEYorSW_Not_Found:			;AN000;
	stc				;AN000; indicate not found in synonym list
	jmp	short _$P_KEYorSW_Exit	;AN000; and exit

_$P_KEYorSW_Found:			;AN000;
	mov	[cs:_$P_Found_SYNONYM],bp ;AC034; set synonym pointer
	clc				;AN000; indicate found
_$P_KEYorSW_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bp			;AN000;
	retn				;AN000;
 
;***********************************************************************
; _$P_MoveBP_NUL
;***********************************************************************

_$P_MoveBP_NUL:
_$P_MBP_Loop:				;AN000;
	; 11/12/2022
	cmp	byte [es:bp],_$P_NULL	;AN000; Increment BP that points
	; 25/10/2022 (MSDOS 5.0 IO.SYS compatibility)
	; (SYSINIT:18DBh)
 	;cmp     byte [es:bp+0],0
	je	short _$P_MBP_Exit	;AN000; to the synomym list

	inc	bp			;AN000; until
	jmp	short _$P_MBP_Loop	;AN000; NULL encountered.

_$P_MBP_Exit:				;AN000;
	inc	bp			;AN000; bp points to next to NULL
	retn				;AN000;

;***********************************************************************
; _$P_Chk_SW_Control
;
; Function: Parse CONTROL block for a switch
;
; Input:     ES:BX -> CONTROL block
;	     cs:SI -> _$P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 _$P_Fill_Result, _$P_Search_KEYorSW, _$P_Check_Match_Flags
;
; Vars:  _$P_SaveSI_Cmpx(W), _$P_KEYorSW_Ptr(R), _$P_Flags(W)
;***********************************************************************

_$P_Chk_SW_Control:

;IF SwSW				;AN000;(Check if switch is supported)
	;or	byte [cs:_$P_Flags+1],10h
	or	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; Indicate switch for later string comparison
	call	_$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
	jc	short _$P_Chk_SW_Err0	;AN000; not found, then try next CONTROL

	;and	[cs:_$P_Flags+],0EFh
	and	byte [cs:_$P_Flags2],0FFh-_$P_SW_Cmp 
					;AC034; reset the indicator previously set
	push	ax			;AN000; 	      /switch:
	mov	ax,[cs:_$P_KEYorSW_Ptr] ;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	[cs:_$P_SaveSI_Cmpx],ax	;AC034; update for complex list
	pop	ax			;AN000;

	mov	si,[cs:_$P_KEYorSW_Ptr] ;AC034; set si at the end or colon
	cmp	byte [cs:si],_$P_NULL	;AN000; any data after colon
	jne	short _$P_CSW00		;AN000; if yes, process match flags

	cmp	byte [cs:si-1],_$P_Colon ;AN000; if no, the switch terminated by colon ?
	jne	short _$P_Chk_if_data_required ;AN000; if yes,

	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; return syntax error
	jmp	short _$P_Chk_SW_Exit	;AN000;

_$P_Chk_if_data_required:		;AN018; no data, no colon
	;cmp	word [es:bx+_$P_Control_Blk.Match_Flag],0 
	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
	je	short _$P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on

	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional 
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYINIT compatibility)
	;test	word [es:bx],1
	; 12/12/2022
	;test	word [es:bx],_$P_Optional ;AN019; see if no value is valid
	test	byte [es:bx],_$P_Optional
	jnz	short _$P_Chk_SW_Exit	;AN019; if so, then leave, else yell

	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; return required operand missing
	jmp	short _$P_Chk_SW_Exit	;AN018;

_$P_CSW00:				;AN000;
	call	_$P_Check_Match_Flags	;AN000; process match flag
	clc				;AN000; indicate match
	;jmp	short _$P_Chk_SW_Single_Exit ;AN000;
	; 12/12/2022
	retn

_$P_Chk_SW_Err0: 			;AN000;
	stc				;AN000; not found in switch synonym list
	;jmp	short _$P_Chk_SW_Single_Exit ;AN000;
	; 12/12/2022
	retn	

_$P_Chk_SW_Exit: 			;AN000;
	push	ax			;AN000;
	mov	al,_$P_String		;AN000; set
	mov	ah,_$P_No_Tag		;AN000;    result
	call	_$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
_$P_Chk_SW_Single_Exit:			;AN000;
	retn				;AN000;
;ELSE					;AN000;(of IF SwSW)
;	stc				;AN000; this logic works when the SwSW
;	retn				;AN000; is reset.

;***********************************************************************
; _$P_Fill_Result
;
; Function: Fill the result buffer
;
; Input:    AH = Item tag
;	    AL = type
;		  AL = 1: CX,DX has 32bit number (CX = high)
;		  AL = 2: DX has index(offset) into value list
;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
;		  AL = 7: DX has year, CL has month and CH has date
;		  AL = 8: DL has hours, DH has minutes, CL has seconds,
;			  amd CH has hundredths
;		  AL = else: cs:SI points to returned string buffer
;	    ES:BX -> CONTROL block
;
; Output:   None
;
; Use:	_$P_Do_CAPS_String, _$P_Remove_Colon, _$P_Found_SYNONYM
;
; Vars: _$P_DX(W)
;***********************************************************************

_$P_Fill_Result:
	push	di			;AN000;
	mov	di,[es:bx+_$P_Control_Blk.Result_Buf]
					;AN000; di points to result buffer
	mov	[cs:_$P_DX],di		;AC034; set returned result address
	mov	[es:di+_$P_Result_Blk.Type],al ;AN000; store type
	mov	[es:di+_$P_Result_Blk.Item_Tag],ah ;AN000; store item tag
	push	ax			;AN000;
	mov	ax,[cs:_$P_Found_SYNONYM] ;AC034; if yes,
	mov	[es:di+_$P_Result_Blk.SYNONYM_Ptr],ax 
					;AN000;   then set it to the result
	pop	ax			;AN000;
_$P_RLT04:				;AN000;
	cmp	al,_$P_Number		;AN000; if number
	jne	short _$P_RLT00		;AN000;

_$P_RLT02:				;AN000;
	mov	[es:di+_$P_Result_Blk.Picked_Val],dx ;AN000; then store 32bit
	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cx ;AN000; number
	jmp	short _$P_RLT_Exit	;AN000;

_$P_RLT00:				;AN000;
	cmp	al,_$P_List_Idx		;AN000; if list index
	jne	short _$P_RLT01		;AN000;

	mov	word [es:di+_$P_Result_Blk.Picked_Val],dx 
					;AN000; then store list index
	jmp	short _$P_RLT_Exit	;AN000;

_$P_RLT01:				;AN000;
	cmp	al,_$P_Date_F		;AN000; Date format ?
	je	short _$P_RLT02		;AN000;

	cmp	al,_$P_Time_F		;AN000; Time format ?
	je	short _$P_RLT02		;AN000;

	cmp	al,_$P_Drive		;AN000; drive format ?
	jne	short _$P_RLT03		;AN000;

	mov	[es:di+_$P_Result_Blk.Picked_Val],dl ;AN000; store drive number
	jmp	short _$P_RLT_Exit	;AN000;

_$P_RLT03:				;AN000;
	cmp	al,_$P_Complex		;AN000; complex format ?
	jne	short _$P_RLT05		;AN000;

	mov	ax,[cs:_$P_SaveSI_Cmpx] ;AC034; then get pointer in command buffer
	inc	ax			;AN000; skip left Parentheses
	mov	[es:di+_$P_Result_Blk.Picked_Val],ax ;AN000; store offset
	mov	[es:di+_$P_Result_Blk.Picked_Val+2],ds ;AN000; store segment
	jmp	short _$P_RLT_Exit	;AN000;

_$P_RLT05:				;AN000;
;------------------------  AL = 3, 5, or 9
	mov	[es:di+_$P_Result_Blk.Picked_Val],si 
					;AN000; store offset of STRING_BUF
	mov	[es:di+_$P_Result_Blk.Picked_Val+2],cs 
					;AN031; store segment of STRING_BUF
	push	ax			;AN000;
	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_File 
					;AN000; need CAPS by file table?
	jz	short _$P_RLT_CAP00	;AN000;

	mov	al,_$P_DOSTBL_File	;AN000; use file upper case table
	jmp	short _$P_RLT_CAP02	;AN000;

_$P_RLT_CAP00:				;AN000;
	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_CAP_Char 
					;AN000; need CAPS by char table ?
	jz	short _$P_RLT_CAP01	;AN000;

	mov	al,_$P_DOSTBL_Char	;AN000; use character upper case table
_$P_RLT_CAP02:				;AN000;
	call	_$P_Do_CAPS_String	;AN000;  process CAPS along the table
_$P_RLT_CAP01:				;AN000;
	pop	ax			;AN000;
	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_Rm_Colon 
					;AN000; removing colon at end ?
	jz	short _$P_RLT_Exit	;AN000;

	call	_$P_Remove_Colon 	;AN000; then process it.
_$P_RLT_Exit:				;AN000;
	pop	di			;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Check_Match_Flags
;
; Function:  Check the mutch_flags and make the exit code and set the
;	     result buffer
;
;	    Check for types in this order:
;		Complex
;		Date
;		Time
;		Drive
;		Filespec
;		Quoted String
;		Simple String
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	     _$P_Value, P$_SValue, _$P_Simple_String, _$P_Date_Format
;	     _$P_Time_Format, _$P_Complex_Format, _$P_File_Foemat
;	     _$P_Drive_Format
;***********************************************************************

	; 25/10/2022 - Retro DOS v4.0
	; (MSDOS 5.0 IO.SYS - SYSINIT:19CFh)

	; 12/12/2022
_$P_Check_Match_Flags:
	mov	byte [cs:_$P_err_flag],_$P_NULL 
					;AN033;AC034;; clear filespec error flag.
	push	ax			;AN000;
	;mov	ax,[es:bx+_$P_Control_Blk.Match_Flag]
	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
	or	ax,ax			;AC035; test ax for zero
	jnz	short _$P_Mat		;AN000; (tm12)
	push	ax			;AN000; (tm12)
	push	bx			;AN000; (tm12)
	push	dx			;AN000; (tm12)
	push	di			;AN000; (tm12)
	mov	word [cs:_$P_RC],_$P_Syntax ;AC034; (tm12)
	mov	ah,_$P_No_Tag		;AN000; (tm12)
	mov	al,_$P_String		;AN000; (tm12)
	call	_$P_Fill_Result		;AN000; (tm12)
	pop	di			;AN000; (tm12)
	pop	dx			;AN000; (tm12)
	pop	bx			;AN000; (tm12)
	pop	ax			;AN000; (tm12)
	; 12/12/2022
	;jmp	short _$P_Bridge 	;AC035; (tm12)
	; 12/12/2022
;_$P_Mat: 				;AN000; (tm12)
	;jmp	short _$P_Match03	;AN025; (tm09)
_$P_Bridge:
	jmp	short _$P_Match_Exit	;AN000; (tm02)
	
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (SYSINIT:19F9h)
	; 12/12/2022
	;nop	; db 90h

; 12/12/2022
_$P_Mat:
_$P_Match03:				;AN000;
	test	ax,_$P_Num_Val		;AN000; Numeric value
	jz	short _$P_Match04	;AN000;

	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
	call	_$P_Value		;AN000; do process
	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
	jne	short _$P_Match_Exit	;AN000;
_$P_Match04:				;AN000;
	test	ax,_$P_SNum_Val		;AN000; Signed numeric value
	jz	short _$P_Match05	;AN000;

	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
	call	_$P_SValue		;AN000; do process
	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
	jne	short _$P_Match_Exit	;AN000;
_$P_Match05:				;AN000;
	test	ax,_$P_Drv_Only		;AN000; Drive only
	jz	short _$P_Match06	;AN000;

	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
	call	_$P_File_Format		;AN000; 1st, call file format
	call	_$P_Drive_Format	;AN000; check drive format, next
	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
	jne	short _$P_Match_Exit	;AN000;
_$P_Match06:				;AN000;
	test	ax,_$P_File_Spc		;AN000; File spec
	jz	short _$P_Match07	;AN000;

	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
	call	_$P_File_Format		;AN000; do process
	cmp	word [cs:_$P_RC],_$P_Syntax ;AC034; if error, examine the next type
	jne	short _$P_Match_Exit	;AN000;
_$P_Match07:				;AN000;
	test	ax,_$P_Simple_S		;AN000; Simple string
	jz	short _$P_Match09	;AN000;

	mov	word [cs:_$P_RC],_$P_No_Error ;AC034; assume no error
	call	_$P_Simple_String	;AN000; do process
_$P_Match09:				;AN000;
_$P_Match_Exit:				;AN000;
	cmp	word [cs:_$P_err_flag],_$P_error_filespec ;AC034; bad filespec ?
	jne	short _$P_Match2_Exit	;AN033; no, continue
	cmp	word [cs:_$P_RC],_$P_No_Error ;AN033;AC034;; check for other errors ?
	jne	short _$P_Match2_Exit	;AN033; no, continue
	mov	word [cs:_$P_RC],_$P_Syntax ;AN033;AC034;; set error flag
_$P_Match2_Exit: 			;AN033;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Remove_Colon;
;
; Function: Remove colon at end
;
; Input:    cs:SI points to string buffer to be examineed
;
; Output:   None
;
; Use:	_$P_Chk_DBCS
;***********************************************************************

_$P_Remove_Colon:
	push	ax			;AN000;
	push	si			;AN000;
_$P_RCOL_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get character
	or	al,al			;AN000; end of string ?
	jz	short _$P_RCOL_Exit	;AN000; if yes, just exit

	cmp	al,_$P_Colon		;AN000; is it colon ?
	jne	short _$P_RCOL00	;AN000;

	cmp	byte [cs:si+1],_$P_NULL ;AN000; if so, next is NULL ?
	jne	short _$P_RCOL00	;AN000; no, then next char

	mov	byte [cs:si],_$P_NULL	;AN000; yes, remove colon
	jmp	short _$P_RCOL_Exit	;AN000; and exit.

_$P_RCOL00:				;AN000;
	call	_$P_Chk_DBCS		;AN000; if not colon, then check if
	jnc	short _$P_RCOL01	;AN000; DBCS leading byte.

	inc	si			;AN000; if yes, skip trailing byte
_$P_RCOL01:				;AN000;
	inc	si			;AN000; si points to next byte
	jmp	short _$P_RCOL_Loop	;AN000; loop until NULL encountered

_$P_RCOL_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Do_CAPS_String;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    AL = 2 : Use character table
;	    AL = 4 : Use file table
;	    cs:SI points to string buffer to be capitalized
;
; Output:   None
;
; Use:	_$P_Do_CAPS_Char, _$P_Chk_DBCS
;***********************************************************************

_$P_Do_CAPS_String:
	push	si			;AN000;
	push	dx			;AN000;
	mov	dl,al			;AN000; save info id

_$P_DCS_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; load charater and
	call	_$P_Chk_DBCS		;AN000; check if DBCS leading byte
	jc	short _$P_DCS00		;AN000; if yes, do not need CAPS

	or	al,al			;AN000; end of string ?
	jz	short _$P_DCS_Exit	;AN000; then exit.

	call	_$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
	mov	[cs:si],al		;AN000; stored upper case char to buffer
	jmp	short _$P_DCS01		;AN000; process next
_$P_DCS00:				;AN000;
	inc	si			;AN000; skip DBCS leading and trailing byte
_$P_DCS01:				;AN000;
	inc	si			;AN000; si point to next byte
	jmp	short _$P_DCS_Loop	;AN000; loop until NULL encountered
_$P_DCS_Exit:				;AN000;
	pop	dx			;AN000;
	pop	si			;AN000;
	retn

;***********************************************************************
; _$P_Do_CAPS_Char;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    DL = 2 : Use character table
;	    DL = 4 : Use file table
;	    AL = character to be capitalized
;
; Output:   None
;
; Use:	INT 21h /w AH=65h
;***********************************************************************

_$P_Do_CAPS_Char:
	cmp	al,_$P_ASCII80	;80h	;AN000; need upper case table ?
	jae	short _$P_DCC_Go	;AN000;

	cmp	al,"a"                  ;AN000; if no,
	jb	short _$P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"

	cmp	al,"z"                  ;AN000;
	ja	short _$P_CAPS_Ret	;AN000;   if yes, make CAPS

	and	al,_$P_Make_Upper ;0DFh ;AN000;   else do nothing.
	jmp	short _$P_CAPS_Ret	;AN000;

_$P_DCC_Go:				;AN000;
	push	bx			;AN000;
	push	es			;AN000;
	push	di			;AN000;

	;lea	di,[cs:_$P_Char_CAP_Ptr] ;AC034; or use char CAPS table ?
	lea	di,[_$P_Char_CAP_Ptr]
_$P_DCC00:				;AN000;
	cmp	[cs:di],dl		;AN000; already got table address ?
	je	short _$P_DCC01		;AN000; if no,

;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
; the GET COUNTYRY INFO call. This usage of ES is required by the function
; call, regardless of what base register is currently be defined as cs.

	push	ax			;AN000; get CAPS table thru DOS call
	push	cx			;AN000;
	push	dx			;AN000;

	push	cs			;AC036; pass current base seg into
					;(Note: this used to push CS.  BUG...
	pop	es			;AN000;   ES reg, required for
					;get extended country information
	mov	ah,_$P_DOS_Get_TBL	;AN000; get extended CDI
	mov	al,dl			;AN000; upper case table
	mov	bx,_$P_DOSTBL_Def	;AN000; get active CON
	mov	cx,_$P_DOSTBL_BL 	;AN000; buffer length
	mov	dx,_$P_DOSTBL_Def	;AN000; get for default code page
					;DI already set to point to buffer
	int	21h			;AN000; es:di point to buffer that
					;now has been filled in with info
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;

_$P_DCC01:				;AN000;

;In this next section, ES will be used as the base of the XLAT table, provided
; by the previous GET COUNTRY INFO DOS call.  This usage of ES is made
; regardless of which base reg is currently the cs reg.

	mov	bx,[cs:di+_$P_DOS_TBL.Off] ;AN000; get offset of table
	mov	es,[cs:di+_$P_DOS_TBL.Seg] ;AN000; get segment of table
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; skip length field
	sub	al,_$P_ASCII80 ; 80h	;AN000; make char to index
	;xlat	es:[bx] 		;AN000; perform case map
	es
	xlat
	pop	di			;AN000;
	pop	es			;AN000;
	pop	bx			;AN000;
_$P_CAPS_Ret:				;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_Value / _$P_SValue
;
; Function:  Make 32bit value from cs:SI and see value list
;	     and make result buffer.
;	     _$P_SValue is an entry point for the signed value
;	     and this will simply call _$P_Value after the handling
;	     of the sign character, "+" or "-"
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	_$P_Fill_Result, _$P_Check_OVF
;
; Vars: _$P_RC(W), _$P_Flags(RW)
;***********************************************************************

	; 26/10/2022 - Retro DOS v4.0
	; (MSDOS 5.0 IO.SYS - SYSINIT:1B0Bh)

_$P_SValue:				;AN000; when signed value here
	push	ax			;AN000;
	or	byte [cs:_$P_Flags2],_$P_Signed ;AC034; indicate a signed numeric
	and	byte [cs:_$P_Flags2],0FFh-_$P_Neg ;AC034; assume positive value
	mov	al,[cs:si]		;AN000; get sign
	cmp	al,_$P_Plus		;AN000; "+" ?
	je	short _$P_SVal00	;AN000;

	cmp	al,_$P_Minus		;AN000; "-" ?
	jne	short _$P_Sval01	;AN000; else

	or	byte [cs:_$P_Flags2],_$P_Neg ;AC034; set this is negative value
_$P_SVal00:				;AN000;
	inc	si			;AN000; skip sign char
_$P_Sval01:				;AN000;
	call	_$P_Value		;AN000; and process value
	pop	ax			;AN000;
	retn

;***********************************************************************

	; 26/10/2022
_$P_Value:				;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	xor	cx,cx			;AN000; cx = higher 16 bits
	xor	dx,dx			;AN000; dx = lower 16 bits
	push	bx			;AN000; save control pointer
_$P_Value_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get character
	or	al,al			;AN000; end of line ?
	jz	short _$P_Value00	;AN000;

	call	_$P_0099 		;AN000; make asc(0..9) to bin(0..9)
	jc	short _$P_Value_Err0	;AN000;

	xor	ah,ah			;AN000;
	mov	bp,ax			;AN000; save binary number
	shl	dx,1			;AN000; to have 2*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	_$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short _$P_Value_Err0	;AN000; then error, exit

	mov	bx,dx			;AN000; save low(2*x)
	mov	ax,cx			;AN000; save high(2*x)
	shl	dx,1			;AN000; to have 4*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	_$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short _$P_Value_Err0	;AN000; then error, exit

	shl	dx,1			;AN000; to have 8*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	_$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short _$P_Value_Err0	;AN000; then error, exit

	add	dx,bx			;AN000; now have 10*x
	adc	cx,ax			;AN000; 32bit ADD
	call	_$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short _$P_Value_Err0	;AN000; then error, exit

	add	dx,bp			;AN000; Add the current one degree decimal
	adc	cx,0			;AN000; if carry, add 1 to high 16bit
	call	_$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short _$P_Value_Err0	;AN000; then error, exit

	inc	si			;AN000; update pointer
	jmp	short _$P_Value_Loop	;AN000; loop until NULL encountered
;
_$P_Value_Err0:				;AN000;
	pop	bx			;AN000;
	jmp	_$P_Value_Err		;AN000; Bridge
;
_$P_Value00:				;AN000;
	pop	bx			;AN000; restore control pointer
	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; here cx,dx = 32bit value
	jz	short _$P_Value01	;AN000; was it negative ?

	not	cx			;AN000; +
	not	dx			;AN000; |- Make 2's complement
	add	dx,1			;AN000; |
	adc	cx,0			;AN000; +

_$P_Value01:				;AN000; / nval =0
	mov	si,[es:bx+_$P_Control_Blk.Value_List] ;AN000; si points to value list
	mov	al,[es:si]		;AN000; get nval
	cmp	al,_$P_nval_None 	;AN000; no value list ?
	jne	short _$P_Value02	;AN000;

	mov	al,_$P_Number		;AN000; Set type
	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short _$P_Value_Exit	;AN000;

	; 26/10/2022 (MSDOS 5.0 IO.SYS, SYSINIT compatibility)
	; (SYSINIT:1BA5h)
	; 12/12/2022
	;nop	; db  90h

_$P_Value02:				;AN000; / nval = 1
;IF	Val1SW				;AN000;(Check if value list id #1 is supported)
;(tm07) cmp	al,_$P_nval_Range	;AN000; have range list ?
;(tm07) jne	short _$P_Value03	;AN000;

	inc	si			;AN000;
	mov	al,[es:si]		;AN000; al = number of range
	cmp	al,_$P_No_nrng		;AN000; (tm07)
	je	short _$P_Value03	;AN000; (tm07)

	inc	si			;AN000; si points to 1st item_tag
_$P_Val02_Loop:				;AN000;
	test	byte [cs:_$P_Flags2],_$P_Signed ;AC034;
	jnz	short _$P_Val02_Sign	;AN000;

	cmp	cx,[es:si+_$P_Val_List.Val_XH] ;AN000; comp cx with XH
	jb	short _$P_Val02_Next	;AN000;
	ja	short _$P_Val_In	;AN000;

	cmp	dx,[es:si+_$P_Val_List.Val_XL] ;AN000; comp dx with XL
	jb	short _$P_Val02_Next	;AN000;

_$P_Val_In:				;AN000;
	cmp	cx,[es:si+_$P_Val_List.Val_YH] ;AN000; comp cx with YH (tm01)
	ja	short _$P_Val02_Next	;AN000;
	jb	short _$P_Val_Found	;AN000;

	cmp	dx,[es:si+_$P_Val_List.Val_YL] ;AN000; comp dx with YL
	ja	short _$P_Val02_Next	;AN000;

	jmp	short _$P_Val_Found	;AN000;

_$P_Val02_Sign:				;AN000;
	cmp	cx,[es:si+_$P_Val_List.Val_XH]	;AN000; comp cx with XH
	jl	short _$P_Val02_Next	;AN000;
	jg	short _$P_SVal_In	;AN000;

	cmp	dx,[es:si+_$P_Val_List.Val_XL]	;AN000; comp dx with XL
	jl	short _$P_Val02_Next	;AN000;

_$P_SVal_In:				;AN000;
	cmp	cx,[es:si+_$P_Val_List.Val_YH]	;AN000; comp cx with YH
	jg	short _$P_Val02_Next	;AN000;

	jl	short _$P_Val_Found	;AN000;

	cmp	dx,[es:si+_$P_Val_List.Val_YL]	;AN000; comp dx with YL
	jg	short _$P_Val02_Next	;AN000;

	jmp	short _$P_Val_Found	;AN000;

_$P_Val02_Next:				;AN000;
	add	si,_$P_Len_Range 	;AN000;
	dec	al			;AN000; loop nrng times in AL
	jne	short _$P_Val02_Loop	;AN000;
					; / Not found
	mov	word [cs:_$P_RC],_$P_Out_Of_Range ;AC034;
	mov	al,_$P_Number		;AN000;
	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short _$P_Value_Exit	;AN000;

_$P_Val_Found:				;AN000;
	mov	al,_$P_Number		;AN000;
	mov	ah,[es:si]		;AN000; found ITEM_TAG set
	jmp	short _$P_Value_Exit	;AN000;

_$P_Value03:				;AN000; / nval = 2

;IF	Val2SW				;AN000;(Check if value list id #2 is supported)
;;;;	cmp	al,$P_nval_Value	; have match list ? ASSUME nval=2,
;;;;	jne	$P_Value04		; even if it is 3 or more.
;(tm07) inc	si			;AN000;
;(tm07) mov	al,es:[si]		;AN000; al = nrng
;	mov	ah,$P_Len_Range 	;AN000;
;	mul	ah			;AN000;  Skip nrng field
;	inc	ax			;AN000;
;	add	si,ax			;AN000; si points to nnval
;	mov	al,es:[si]		;AN000; get nnval
;	inc	si			;AN000; si points to 1st item_tag
;$P_Val03_Loop:				;AN000;
;	cmp	cx,es:[si+$P_Val_XH]	;AN000; comp cx with XH
;	jne	$P_Val03_Next		;AN000;
;
;	cmp	dx,es:[si+$P_Val_XL]	;AN000; comp dx with XL
;	je	$P_Val_Found		;AN000;
;
;$P_Val03_Next:				;AN000;
;	add	si,$P_Len_Value 	;AN000; points to next value choice
;	dec	al			;AN000; loop nval times in AL
;	jne	$P_Val03_Loop		;AN000;
;					;AN000; / Not found
;	mov	psdata_seg:$P_RC,$P_Not_in_Val ;AC034;
;	mov	al,$P_Number		;AN000;
;	mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
;	jmp	short $P_Value_Exit	;AN000;
;
;ENDIF					;AN000;(of Val2SW)
;$P_Value04:

_$P_Value_Err:				;AN000;
	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
	mov	al,_$P_String		;AN000; Set type
	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
_$P_Value_Exit:				;AN000;
	call	_$P_Fill_Result		;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

; 28/03/2019 - Retro DOS v4.0

;***********************************************************************
; _$P_Check_OVF
;
; Function:  Check if overflow is occurred with consideration of
;	     signed or un-signed numeric value
;
; Input:     Flag register
;
; Output:    CY = 1  :	Overflow
;
; Vars:     _$P_Flags(R)
;***********************************************************************

	; 26/10/2022
_$P_Check_OVF:
	pushf				;AN000;
	test	byte [cs:_$P_Flags2],_$P_Neg ;AC034; is it negative value ?
	jnz	short _$P_COVF 		;AN000; if no, check overflow

	popf				;AN000; by the CY bit
	retn				;AN000;

_$P_COVF:				;AN000;
	popf				;AN000; else,
	jo	short _$P_COVF00	;AN000; check overflow by the OF

	clc				;AN000; indicate it with CY bit
	retn				;AN000; CY=0 means no overflow

_$P_COVF00:				;AN000;
	stc				;AN000; and CY=1 means overflow
	retn				;AN000;

;***********************************************************************
; _$P_0099;
;
; Function:  Make ASCII 0-9 to Binary 0-9
;
; Input:     AL = character code
;
; Output:    CY = 1 : AL is not number
;	     CY = 0 : AL contains binary value
;***********************************************************************

_$P_0099:
	cmp	al,"0"                  ;AN000;
	;jb	short _$P_0099Err	;AN000; must be 0 =< al =< 9
	; 12/12/2022
	jb	short _$P_0099Err2  ; cf=1

	cmp	al,"9"                  ;AN000;
	ja	short _$P_0099Err	;AN000; must be 0 =< al =< 9

	sub	al,"0"                  ;AN000; make char -> bin
	; 12/12/2022
	; cf=0	
	;clc				;AN000; indicate no error
	retn				;AN000;

_$P_0099Err:				;AN000;
	stc				;AN000; indicate error
_$P_0099Err2: ; 12/12/2022	
	retn				;AN000;

;***********************************************************************
; _$P_Simple_String
;
; Function:  See value list for the simple string
;	     and make result buffer.
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	_$P_Fill_Result, _$P_String_Comp
;
; Vars: _$P_RC(W)
;***********************************************************************

_$P_Simple_String:
	push	ax			;AN000;
	push	bx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	mov	di,[es:bx+_$P_Control_Blk.Value_List] ;AN000; di points to value list
	mov	al,[es:di]		;AN000; get nval
	or	al,al			;AN000; no value list ?
	jnz	short _$P_Sim00		;AN000; then

	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short _$P_Sim_Exit	;AN000; and set result buffer

_$P_Sim00:				;AN000;
;IF	Val3SW+KeySW			;AN000;(Check if keyword or value list id #3 is supported)
	cmp	al,_$P_nval_String	;AN000; String choice list provided ?
	jne	short _$P_Sim01		;AN000; if no, syntax error

	inc	di			;AN000;
	mov	al,[es:di]		;AN000; al = nrng
	mov	ah,_$P_Len_Range 	;AN000;
	mul	ah			;AN000; Skip nrng field
	inc	ax			;AN000; ax = (nrng*9)+1
	add	di,ax			;AN000; di points to nnval
	mov	al,[es:di]		;AN000; get nnval
	mov	ah,_$P_Len_Value 	;AN000;
	mul	ah			;AN000; Skip nnval field
	inc	ax			;AN000; ax = (nnval*5)+1
	add	di,ax			;AN000; di points to nstrval
	mov	al,[es:di]		;AN000; get nstrval c
	inc	di			;AC035; add '2' to
	inc	di			;AC035;  DI reg
					;AN000; di points to 1st string in list
_$P_Sim_Loop:				;AN000;
	mov	bp,[es:di]		;AN000; get string pointer
	call	_$P_String_Comp		;AN000; compare it with operand
	jnc	short _$P_Sim_Found	;AN000; found on list ?

	add	di,_$P_Len_String ; 3	;AN000; if no, point to next choice
	dec	al			;AN000; loop nstval times in AL
	jne	short _$P_Sim_Loop	;AN000;
					;AN000; / Not found
	mov	word [cs:_$P_RC],_$P_Not_In_Str ;AC034;
	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short _$P_Sim_Exit	;AN000;

_$P_Sim_Found:				;AN000;
	mov	ah,[es:di-1]		;AN000; set item_tag
	mov	al,_$P_List_Idx		;AN000;
	mov	dx,[es:di]		;AN000; get address of STRING
	jmp	short _$P_Sim_Exit0	;AN000;
;ENDIF					;AN000;(of Val3SW+KeySW)
_$P_Sim01:				;AN000;
	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
	mov	ah,_$P_No_Tag		;AN000; No ITEM_TAG set
_$P_Sim_Exit:				;AN000;
	mov	al,_$P_String		;AN000; Set type
_$P_Sim_Exit0:				;AN000;
	call	_$P_Fill_Result		;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	bx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; _$P_String_Comp:
;
; Function:  Compare two string
;
; Input:     cs:SI -> 1st string
;	     ES:BP -> 2nd string  (Must be upper case)
;	     ES:BX -> CONTROL block
;
; Output:    CY = 1 if not match
;
; Use:	_$P_Chk_DBCS, _$P_Do_CAPS_Char
;
; Vars: _$P_KEYor_SW_Ptr(W), _$P_Flags(R). _$P_KEYorSW_Ptr
;***********************************************************************

_$P_String_Comp:
	push	ax			;AN000;
	push	bp			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	mov	dl,_$P_DOSTBL_Char	;AN000; use character case map table
_$P_SCOM_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get command character
	call	_$P_Chk_DBCS		;AN000; DBCS ?
	jc	short _$P_SCOM00	;AN000; yes,DBCS

	call	_$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
;IF KeySW+SwSW				;AN000;(Check if keyword or switch is supported)
	test	byte [cs:_$P_Flags2],_$P_Key_Cmp ;AC034; keyword search ?
	jz	short _$P_SCOM04	;AN000;

	cmp	al,_$P_Keyword		;AN000; "=" is delimiter
	jne	short _$P_SCOM03	;AN000; IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)

	cmp	byte [es:bp+1],_$P_NULL ;AN021;  at end of keyword string in the control block THEN
	jne	short _$P_SCOM_Differ	;AN021;

	jmp	short _$P_SCOM05 	;AN000; keyword found in synonym list

_$P_SCOM04:				;AN000;
	test	byte [cs:_$P_Flags2],_$P_SW_Cmp ;AC034; switch search ?
	jz	short _$P_SCOM03	;AN000;

	cmp	al,_$P_Colon		;AN000; ":" is delimiter, at end of switch on command line
	jne	short _$P_SCOM03	;AN000; continue compares

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;cmp	byte [es:bp+0],_$P_NULL
	; 11/12/2022
	cmp	byte [es:bp],_$P_NULL	;AN021; IF at end of switch on command AND
	jne	short _$P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN

_$P_SCOM05:				;AN000;   found a match
	inc	si			;AN000; si points to just after "=" or ":"
	jmp	short _$P_SCOM_Same	;AN000; exit

_$P_SCOM03:				;AN000;
;ENDIF					;AN000;(of KeySW+SwSW)
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;cmp	al,[es:bp+0]
	; 11/12/2022
	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
	jne	short _$P_SCOM_Differ0 	;AN000; if different, check ignore colon option

	or	al,al			;AN000; end of line
	jz	short _$P_SCOM_Same	;AN000; if so, exit

	; 12/12/2022
	;inc	si			;AN000; update operand pointer
	;inc	bp			;AN000;    and synonym pointer
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	jmp	short _$P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case

_$P_SCOM00:				;AN000; Here al is DBCS leading byte
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;cmp	al,[es:bp+0]
	; 11/12/2022
	cmp	al,[es:bp]		;AN000; compare leading byte
	jne	short _$P_SCOM_Differ	;AN000; if not match, say different

	inc	si			;AN000; else, load next byte
	mov	al,[cs:si]		;AN000; and
	inc	bp			;AN000;
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;cmp	al,[es:bp+0]
	; 11/12/2022
	cmp	al,[es:bp]		;AN000; compare 2nd byte
	jne	short _$P_SCOM_Differ	;AN000; if not match, say different, too

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
_$P_SCOM01:
	inc	si			;AN000; else update operand pointer
	inc	bp			;AN000; 		and synonym pointer
;_$P_SCOM01:				;AN000;
	jmp	short _$P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case

_$P_SCOM_Differ0:			;AN000;
;IF SwSW				;AN000;(tm10)
	test	byte [cs:_$P_Flags2],_$P_SW ;AC034;(tm10)
	jz	short _$P_not_applicable ;AN000;(tm10)

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;test	word [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary ;AN000;(tm10)
	; 12/12/2022
	test	byte [es:bx+_$P_Control_Blk.Function_Flag],_$P_colon_is_not_necessary
	je	short _$P_not_applicable ;AN000;(tm10)

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;cmp	byte [es:bp+0],_$P_NULL
	; 11/12/2022
	cmp	byte [es:bp],_$P_NULL	;AN000;(tm10)
;(deleted ;AN025;) jne short _$P_not_applicable ;AN000;(tm10)
	je	short _$P_SCOM_Same	;AN025;(tm10)

_$P_not_applicable:			;AN000;(tm10)
;ENDIF					;AN000;(tm10)

	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
					;AN000; ignore colon option specified ?
	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon
	; 12/12/2022
	test	byte [es:bx],_$P_Ig_Colon
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;test	word [es:bx],_$P_Ig_Colon ; 10h
	jz	short _$P_SCOM_Differ	;AN000; if no, say different.

	cmp	al,_$P_Colon		;AN000; End up with ":" and
	jne	short _$P_SCOM02	;AN000;    subseqently

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;cmp	byte [es:bp+0],_$P_NULL
	; 11/12/2022
	cmp	byte [es:bp],_$P_NULL	;AN000; NULL ?
	jne	short _$P_SCOM_Differ	;AN000; if no, say different

	jmp	short _$P_SCOM_Same	;AN000; else, say same

_$P_SCOM02:				;AN000;
	cmp	al,_$P_NULL		;AN000; end up NULL and :
	jne	short _$P_SCOM_Differ	;AN000;

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;cmp	byte [es:bp+0],_$P_Colon
	; 11/12/2022
	cmp	byte [es:bp],_$P_Colon	;AN000; if no, say different
	je	short _$P_SCOM_Same	;AN000; else, say same

_$P_SCOM_Differ: 			;AN000;
	stc				;AN000; indicate not found
	jmp	short _$P_SCOM_Exit	;AN000;

_$P_SCOM_Same:				;AN000;
	; 12/12/2022
	; cf=0
	mov	[cs:_$P_KEYorSW_Ptr],si ;AC034; for later use by keyword or switch
	; 12/12/2022
	;clc				;AN000; indicate found
_$P_SCOM_Exit:				;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	bp			;AN000;
	pop	ax			;AN000;
	retn

; 30/03/2019

;IF FileSW+DrvSW			;AN000;(Check if file spec or drive only is supported)

;***********************************************************************
; _$P_File_Format;
;
; Function:  Check if the input string is valid file spec format.
;	     And set the result buffer.
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	_$P_Fill_Result, _$P_Chk_DBCS, _$P_FileSp_Chk
;
; Vars: _$P_RC(W), _$P_SI_Save(W), _$P_Terminator(W), _$P_SaveSI_Cmpx(R)
;	_$P_SaveSI_Cmpx(R)
;***********************************************************************

_$P_File_Format:
	push	ax			;AN000;
	push	di			;AN000;
	push	si			;AN000;
	mov	di,[cs:_$P_SaveSI_Cmpx]	;AC034; get user buffer address
_$P_FileF_Loop0: 			;AN000; / skip special characters
	mov	al,[cs:si]		;AN000; load character
	or	al,al			;AN000; end of line ?
	jz	short _$P_FileF_Err	;AN000; if yes, error exit

	call	_$P_FileSp_Chk		;AN000; else, check if file special character
	jne	short _$P_FileF03	;AN000; if yes,

	mov	byte [cs:_$P_err_flag],_$P_error_filespec 
					;AN033;AC034;; set error flag- bad char.
	pop	si			;AN033;
	mov	byte [cs:si],_$P_NULL	;AN033;
	pop	di			;AN033;
	jmp	short _$P_FileF02	;AN033;

_$P_FileF_Err:				;AN000;
	pop	si			;AN000;
	mov	byte [cs:si],_$P_NULL	;AN000;
	pop	di			;AN000;

	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional ;AN000; is it optional ?
	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Optional
	; 12/12/2022
	test	byte [es:bx],_$P_Optional
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;test	word [es:bx],_$P_Optional
	jnz	short _$P_FileF02	;AN000;

	mov	word [cs:_$P_RC],_$P_Op_Missing ;AC034; 3/17/87
	jmp	short _$P_FileF02	;AN000;

_$P_FileF03:				;AN000;
	pop	ax			;AN000; discard save si
	push	si			;AN000; save new si
_$P_FileF_Loop1: 			;AN000;
	mov	al,[cs:si]		;AN000; load character (not special char)
	or	al,al			;AN000; end of line ?
	jz	short _$P_FileF_RLT	;AN000;

	call	_$P_FileSp_Chk		;AN000; File special character ?
	je	short _$P_FileF00	;AN000;

	call	_$P_Chk_DBCS		;AN000; no, then DBCS ?
	jnc	short _$P_FileF01	;AN000;
	inc	di			;AN000; if yes, skip next byte
	inc	si			;AN000;
_$P_FileF01:				;AN000;
	inc	di			;AN000;
	inc	si			;AN000;
	jmp	short _$P_FileF_Loop1	;AN000;
;
_$P_FileF00:				;AN000;
	mov	[cs:_$P_Terminator],al	;AC034;
	mov	byte [cs:si],_$P_NULL	;AN000; update end of string
	inc	di			;AN000;
	mov	[cs:_$P_SI_Save],di	;AC034; update next pointer in command line
_$P_FileF_RLT:				;AN000;
	pop	si			;AN000;
	pop	di			;AN000;
_$P_FileF02:				;AN000;
	pop	ax			;AN000; (tm14)
	test	ax,_$P_File_Spc		;AN000; (tm14)
	jz	short _$P_Drv_Only_Exit	;AN000; (tm14)

	push	ax			;AN000;  (tm14)

	mov	ah,_$P_No_Tag		;AN000; set
	mov	al,_$P_File_Spec 	;AN000;    result
	call	_$P_Fill_Result		;AN000; 	 buffer to file spec
	pop	ax			;AN000;

_$P_Drv_Only_Exit:			;AN000; (tm14)
	retn				;AN000;

;***********************************************************************
; _$P_FileSp_Chk
;
; Function:  Check if the input byte is one of file special characters
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     AL = character code to be examineed
;
; Output:    ZF = 1 , AL is one of special characters
;***********************************************************************

_$P_FileSp_Chk:
	push	bx			;AN000;
	push	cx			;AN000;
	;lea	bx,[cs:_$P_FileSp_Char] ;AC034; special character table
	lea	bx,[_$P_FileSp_Char]
	mov	cx,_$P_FileSp_Len	;AN000; load length of it
_$P_FileSp_Loop: 			;AN000;
	cmp	al,[cs:bx]		;AN000; is it one of special character ?
	je	short _$P_FileSp_Exit	;AN000;

	inc	bx			;AN000;
	loop	_$P_FileSp_Loop		;AN000;

	inc	cx			;AN000; reset ZF
_$P_FileSp_Exit: 			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn

;ENDIF					;AN000;(of FileSW+DrvSW)

;IF	DrvSW				;AN000;(Check if drive only is supported)

;***********************************************************************
; _$P_Drive_Format;
;
; Function:  Check if the input string is valid drive only format.
;	     And set the result buffer.
;
; Input:     cs:SI -> _$P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	_$P_Fill_Result, _$P_Chk_DBCS
;
; Vars: _$P_RC(W)
;***********************************************************************

_$P_Drive_Format:
	push	ax			;AN000;
	push	dx			;AN000;
	mov	al,[cs:si]		;AN000;
	or	al,al			;AN000; if null string
	je	short _$P_Drv_Exit	;AN000; do nothing

	call	_$P_Chk_DBCS		;AN000; is it leading byte ?
	jc	short _$P_Drv_Err	;AN000;

	cmp	word [cs:si+1],_$P_Colon ;AN000; "d", ":", 0  ?
	je	short _$P_DrvF00	;AN000;

	;test	word [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon 
	;test	byte [es:bx+_$P_Control_Blk.Match_Flag],_$P_Ig_Colon ;AN000; colon can be ignored?
	; 12/12/2022
	test	byte [es:bx],_$P_Ig_Colon
	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;test	word [es:bx],_$P_Ig_Colon
	jz	short _$P_Drv_Err	;AN000;

	cmp	byte [cs:si+1],_$P_NULL ;AN000; "d", 0  ?
	jne	short _$P_Drv_Err	;AN000;

_$P_DrvF00:				;AN000;
	or	al,_$P_Make_Lower	;AN000; lower case
	cmp	al,"a"                  ;AN000; drive letter must
	jb	short _$P_Drv_Err	;AN000; in range of

	cmp	al,"z"                  ;AN000; "a" - "z"
	ja	short _$P_Drv_Err	;AN000; if no, error

	sub	al,"a"-1                ;AN000; make text drive to binary drive
	mov	dl,al			;AN000; set
	mov	ah,_$P_No_Tag		;AN000;    result
	mov	al,_$P_Drive		;AN000; 	 buffer
	call	_$P_Fill_Result		;AN000; 	       to drive
	jmp	short _$P_Drv_Exit	;AN000;

_$P_Drv_Err:				;AN000;
	mov	word [cs:_$P_RC],_$P_Syntax ;AC034;
_$P_Drv_Exit:				;AN000;
	pop	dx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;ENDIF					;AN000;(of DrvSW)

;***********************************************************************
; _$P_Skip_Delim;
;
; Function: Skip delimiters specified in the PARMS list, white space
;	    and comma.
;
; Input:    DS:SI -> Command String
;	    ES:DI -> Parameter List
;
; Output:   CY = 1 if the end of line encounterd
;	    CY = 0 then SI move to 1st non-delimiter character
;	    AL = Last examineed character
;
; Use:	    _$P_Chk_EOL, _$P_Chk_Delim,
;
; Vars:     _$P_Flags(R)
;***********************************************************************

_$P_Skip_Delim:
_$P_Skip_Delim_Loop:			;AN000;
	lodsb				;AN000;
	call	_$P_Chk_EOL		;AN000; is it EOL character ?
	jz	short _$P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on

	call	_$P_Chk_Delim		;AN000; is it one of delimiters ?
	jnz	short _$P_Skip_Delim_NCY ;AN000; if no, exit w/ CY off

	test	byte [cs:_$P_Flags2],_$P_Extra ;AC034; extra delim or comma found ?
	jz	short _$P_Skip_Delim_Loop ;AN000; if no, loop

	test	byte [cs:_$P_Flags2],_$P_SW+_$P_equ ;AC034; /x , or xxx=zzz , (tm08)
	jz	short _$P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)

	;dec	si			;AN000; backup si for next call (tm08)
	;jmp	short _$P_Exit_At_Extra	;AN000; else exit w/ CY off
	; 12/12/2022
	; cf=0
	jmp	short _$P_Skip_Delim_Exit

_$P_Skip_Delim_CY:			;AN000;
	stc				;AN000; indicate EOL
	jmp	short _$P_Skip_Delim_Exit ;AN000;

_$P_Skip_Delim_NCY:			;AN000;
	clc				;AN000; indicate non delim
_$P_Skip_Delim_Exit:			;AN000; in this case, need
	dec	si			;AN000;  backup index pointer
	; 12/12/2022
_$P_Exit_At_Extra:	 ; cf=0
	retn				;AN000;

	; 12/12/2022
;_$P_Exit_At_Extra:			;AN000;
	;clc				;AN000; indicate extra delim
	;retn				;AN000;

;***********************************************************************
; _$P_Chk_EOL;
;
; Function: Check if AL is one of End of Line characters.
;
; Input:    AL = character code
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of End of Line characters
;**********************************************************************

_$P_Chk_EOL:
	push	bx			;AN000;
	push	cx			;AN000;
	cmp	al,_$P_CR		;AN000; Carriage return ?
	je	short _$P_Chk_EOL_Exit 	;AN000;

	cmp	al,_$P_NULL		;AN000; zero ?
	je	short _$P_Chk_EOL_Exit 	;AN000;

;IF LFEOLSW				;AN028; IF LF TO BE ACCEPTED AS EOL
	cmp	al,_$P_LF		;AN000; Line feed ?
	je	short _$P_Chk_EOL_Exit 	;AN000;
;ENDIF					;AN028;

	cmp	byte [es:di+_$P_PARMS_Blk.Num_Extra],_$P_I_Have_EOL 
					;AN000; EOL character specified ?
	jb	short _$P_Chk_EOL_Exit 	;AN000;

	xor	bx,bx			;AN000;
	mov	bl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim]
					;AN000; get length of delimiter list
	add	bx,_$P_Len_PARMS 	;AN000; skip it
	cmp	byte [es:bx+di],_$P_I_Use_Default ;AN000; No extra EOL character ?
	je	short _$P_Chk_EOL_NZ	;AN000;

	;xor	cx,cx			;AN000; Get number of extra character
	xor	ch,ch
	mov	cl,[es:bx+di]		;AN000;
_$P_Chk_EOL_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
	je	short _$P_Chk_EOL_Exit 	;AN000;

	loop	_$P_Chk_EOL_Loop 	;AN000;

_$P_Chk_EOL_NZ:				;AN000;
	cmp	al,_$P_CR		;AN000; reset ZF
_$P_Chk_EOL_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn

;***********************************************************************
; _$P_Chk_Delim;
;
; Function: Check if AL is one of delimiter characters.
;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
;	    blanks.
;
; Input:    AL = character code
;	    DS:SI -> Next Character
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of delimiter characters
;	    SI points to the next character
; Vars:  _$P_Terminator(W), _$P_Flags(W)
;***********************************************************************

_$P_Chk_Delim:
	push	bx			;AN000;
	push	cx			;AN000;
	mov	byte [cs:_$P_Terminator],_$P_Space 
					;AC034; Assume terminated by space
	;and	byte [cs:_$P_Flags20,0DFh
	and	byte [cs:_$P_Flags2],0FFh-_$P_Extra ;AC034;
	cmp	al,_$P_Space ; 20h	;AN000; Space ?
	je	short _$P_Chk_Delim_Exit ;AN000;

	cmp	al,_$P_TAB		;AN000; TAB ?
	je	short _$P_Chk_Delim_Exit ;AN000;

	cmp	al,_$P_Comma		;AN000; Comma ?
	je	short _$P_Chk_Delim_Exit0 ;AN000;

	; 26/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
_$P_Chk_Delim00: 			;AN000;
	cmp	al,_$P_DBSP1	; 20h	;AN000; 1st byte of DBCS Space ?
	jne	short _$P_Chk_Delim01	;AN000;

	cmp	byte [si],_$P_DBSP2 ; 20h ;AN000; 2nd byte of DBCS Space ?
	jne	short _$P_Chk_Delim01	;AN000;

	mov	al,_$P_Space		;AN000;
	inc	si			;AN000; make si point to next character
	cmp	al,al			;AN000; Set ZF
	jmp	short _$P_Chk_Delim_Exit ;AN000;

_$P_Chk_Delim01: 			;AN000;
	cmp	byte [es:di-_$P_PARMS_Blk.Num_Extra],_$P_I_Have_Delim 
					;AN000; delimiter character specified ?
	jb	short _$P_Chk_Delim_Exit ;AN000;

	;xor	cx,cx			;AN000;
	xor	ch,ch
	;mov	cl,[es:di+3]
	mov	cl,[es:di+_$P_PARMS_Blk.Len_Extra_Delim] 
					;AN000; get length of delimiter list
	or	cx,cx			;AN000; No extra Delim character ?
	jz	short _$P_Chk_Delim_NZ 	;AN000;

	mov	bx,_$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
_$P_Chk_Delim_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
	je	short _$P_Chk_Delim_Exit0 ;AN000;

	loop	_$P_Chk_Delim_Loop	;AN000; examine all extra delimiter

_$P_Chk_Delim_NZ:			;AN000;
	cmp	al,_$P_Space		;AN000; reset ZF
_$P_Chk_Delim_Exit:			;AN000;
_$P_ChkDfin:				;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn				;AN000;

_$P_Chk_Delim_Exit0:			;AN000;
	mov	[cs:_$P_Terminator],al ;AC034; keep terminated delimiter
	test	byte [cs:_$P_Flags2],_$P_equ ;AN027;AC034;; if terminating a key=
	jnz	short _$P_No_Set_Extra 	;AN027; then do not set the EXTRA bit

	or	byte [cs:_$P_Flags2],_$P_Extra 
					;AC034; flag terminated extra delimiter or comma
_$P_No_Set_Extra:			;AN027;
	cmp	al,al			;AN000; set ZF
	jmp	short _$P_Chk_Delim_Exit ;AN000;


;***********************************************************************
; _$P_Chk_Switch;
;
; Function: Check if AL is the switch character not in first position of
;	    _$P_STRING_BUF
;
; Input:    AL = character code
;	    BX = current pointer within _$P_String_Buf
;	    SI =>next char on command line (following the one in AL)
;
; Output:   CF = 1 (set)if AL is switch character, and not in first
;		 position, and has no chance of being part of a date string,
;		 i.e. should be treated as a delimiter.

;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
;		 position, or is a slash but may be part of a date string, i.e.
;		 should not be treated as a delimiter.
;
; Vars:  _$P_Terminator(W)

; Use:	 _$P_0099
;***********************************************************************

_$P_Chk_Switch:
	;lea	bp,[cs:_$P_STRING_BUF]	;AN020;AC034
	lea	bp,[_$P_STRING_BUF]	;BP=OFFSET of _$P_String_Buf even in group addressing
;	.IF <BX NE BP> THEN		;AN020;IF not first char THEN
	cmp	bx,bp			;AN000;
	je	short _$P_STRUC_L2	;AN000;

;	.IF <AL EQ _$P_Switch> THEN	;AN020;otherwise see if a slash
	cmp	al,_$P_Switch		;AN000;
	jne	short _$P_STRUC_L5 	;AN000;

	stc				;AN020;not in first position and is slash
	;jmp     short _$P_STRUC_L1	;AN000;
	; 12/12/2022
	retn

; 12/12/2022
;_$P_STRUC_L5:				;AN000;
;	CLC				;AN020;not a slash
;;	    .ENDIF			;AN020;
;;	.ELSE				;AN020;is first char in the buffer, ZF=0
;	jmp	short _$P_STRUC_L1	;AN000;

_$P_STRUC_L2:				;AN000;
;	.IF <AL EQ _$P_Switch> THEN	;AN020;
	cmp     al,_$P_Switch		;AN000;
	jne	short _$P_STRUC_L12	;AN000;

	or	byte [cs:_$P_Flags2],_$P_SW ;AN020 ;AC034;;could be valid switch, first char and is slash
;	.ENDIF				;AN020;

	; 12/12/2022
	; cf=0
	;retn

_$P_STRUC_L5:
	; 12/12/2022
_$P_STRUC_L12:				;AN000;
	clc				;AN020;CF=0 indicating first char
;	.ENDIF				;AN020;
_$P_STRUC_L1:				;AN000;
	retn				;AN000;

;**************************************************************************
; _$P_Chk_DBCS:
;
;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
;
;  Input:
;	  AL	= Code to be examineed
;
;  Output:
;	  If CF is on then a lead byte of DBCS
;
; Use: INT 21h w/AH=63
;
; Vars:  _$P_DBCSEV_Seg(RW), _$P_DBCSEV_Off(RW)
;***************************************************************************

_$P_Chk_DBCS:
	push	ds			;AN000;
	push	si			;AN000;
	push	bx			;AN000; (tm11)
	
	cmp	word [cs:_$P_DBCSEV_SEG],0 ;AC034; ALREADY SET ?
	jne	short _$P_DBCS00	;AN000;

	push	ax			;AN000;
	push	ds			;AN000; (tm11)
	push	cx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	push	bp			;AN000;
	push	es			;AN000;
	xor	si,si			;AN000;
	mov	ds,si			;AN000;
	MOV	ax,_$P_DOS_GetEV ; 6300h ;AN000; GET DBCS EV CALL
	int	21h			;AN000;
		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
	mov	bx,ds			;AN000; (tm11)
	or	bx,bx			;AN000; (tm11)
	pop	es			;AN000;
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ds			;AN000; (tm11)
	pop	ax			;AN000;
	jz	short _$P_NON_DBCS	;AN000;

_$P_DBCS02:				;AN000;
	mov	[cs:_$P_DBCSEV_OFF],si	;AC034; save EV offset
	mov	[cs:_$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
_$P_DBCS00:				;AN000;
	mov	si,[cs:_$P_DBCSEV_OFF]	;AC034; load EV offset
	mov	ds,[cs:_$P_DBCSEV_SEG]	;AC034; and segment

_$P_DBCS_LOOP:				;AN000;
	cmp	word [si],0		;AN000; zero vector ?
	je	short _$P_NON_DBCS	;AN000; then exit

	cmp	al,[si] 		;AN000;
	jb	short _$P_DBCS01	;AN000; Check if AL is in

	cmp	al,[si+1]		;AN000;   range of
	ja	short _$P_DBCS01	;AN000;      the vector

	stc				;AN000; if yes, indicate DBCS and exit
	jmp	short _$P_DBCS_EXIT	;AN000;

_$P_DBCS01:				;AN000;
	inc	si			;AC035; add '2' to
	inc	si			;AC035;  SI reg
					;AN000; get next vector
	jmp	short _$P_DBCS_LOOP	;AN000; loop until zero vector found

_$P_NON_DBCS:				;AN000;
	; 12/12/2022
	; cf=0
	;clc				;AN000; indicate SBCS
_$P_DBCS_EXIT:				;AN000;
	pop	bx			;AN000; (tm11)
	pop	si			;AN000;
	pop	ds			;AN000;
	retn				;AN000;

; SYSCONF.ASM - MSDOS 6.0 - 1991
; ======================================================================
; 27/03/2019 - Retro DOS v4.0

;control block definitions for parser.
;-----------------------------------------------------------------------
; buffer = [n | n,m] {/e}

; 30/03/2019

struc p_parms
	resw	1	; dw ?
	resb	1	; db 1	; an extra delimiter list
	resb	1	; db 1	; length is 1
	resb 	1	; db ';' ; delimiter
.size:
endstruc

struc p_pos
	resw	1	; dw ?	; numeric value??
	resw	1	; dw ?	; function
	resw	1	; dw ?	; result value buffer

; note: by defining result_val before this structure, we could remove
;  the "result_val" from every structure invocation

	resw	1	; dw ?	; value list
	resb	1	; db 0	; no switches/keywords
.size:
endstruc

struc	p_range
	resb	1	; db 1	; range definition
	resb 	1	; db 1	; 1 definition of range
	resb 	1	; db 1	; item tag for this range
	resd	1	; dd ?	; numeric min
	resd	1	; dd ?	; numeric max
.size:
endstruc

;-----------------------------------------------------------------------

	; 26/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:1F48h)

; buffer = [n | n,m] {/e}

;buf_parms p_parms <buf_parmsx>
buf_parms: 
	dw	buf_parmsx
	db	1	; an extra delimiter list
	db	1	; length is 1
	db	';'	; delimiter

buf_parmsx:
	dw	201h,buf_pos1,buf_pos2	; min 1, max 2 positionals
	db	1			; one switch
	dw	sw_x_ctrl
	db	0			; no keywords

;buf_pos1 p_pos <8000h,0,result_val,buf_range_1>  ; numeric
buf_pos1:
	dw	8000h	; numeric value??
	dw	0	; function
	dw	result_val ; result value buffer	
	dw	buf_range_1 ; value list
	db	0  	; no switches/keywords

;buf_range_1 p_range <,,,1,99>		; M050
buf_range_1:
	db	1	; range definition
	db	1	; 1 definition of range
	db	1	; item tag for this range
	dd	1	; numeric min
	dd	99	; numeric max

;buf_pos2 p_pos <8001h,0,result_val,buf_range_2> ; optional num.
buf_pos2:
	dw	8001h
	dw	0
	dw	result_val	
	dw	buf_range_2
	db	0

;buf_range_2 p_range <,,,0,8>
buf_range_2:
	db	1
	db	1
	db	1
	dd	0
	dd	8

;sw_x_ctrl p_pos <0,0,result_val,noval,1> ; followed by one switch
sw_x_ctrl:
	dw	0
	dw	0
	dw	result_val	
	dw	noval
	db	1	; 1 switch
	
switch_x:
	db	'/X',0		; M016

p_buffers:
	dw	0	; local variables
p_h_buffers:
	dw	0
	; 26/10/2022  (MSDOS 5.0 IO.SYS SYSINIT compatibility)
p_buffer_slash_x:
	db	0 ; 31/03/2019

;-- common definitions -------------------------------------------------

noval:	db	0

result_val: 	;label	byte
	db	0		; type returned
result_val_itag:
	db	0		; item tag returned
result_val_swoff:
	dw	0		; es:offset of the switch defined
rv_byte:	;label	byte
rv_dword: dd	0		; value if number,or seg:offset to string.

;-----------------------------------------------------------------------

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:1F99h)

; break = [ on | off ]

;brk_parms p_parms  <brk_parmsx>
brk_parms:
	dw	brk_parmsx
	db	1	; an extra delimiter list
	db	1	; length is 1
	db	';'	; delimiter

brk_parmsx:
	dw	101h,brk_pos	; min,max = 1 positional
	db	0		; no switches
	db	0		; no keywords

;brk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
brk_pos:
	dw	2000h
	dw	0
	dw	result_val	
	dw	on_off_string
	db	0

on_off_string:	;label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	2		; 2 strings for choice
	db	1		; the 1st string tag
	dw	on_string
	db	2		; the 2nd string tag
	dw	off_string

on_string:
	db	"ON",0
off_string:
	db	"OFF",0

p_ctrl_break:
	db	0	; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; country = n {m {path}}
; or
; country = n,,path

;cntry_parms p_parms <cntry_parmsx>
cntry_parms:
	dw	cntry_parmsx
	db	1
	db	1
	db	';'
	
cntry_parmsx:
	dw	301h,cntry_pos1,cntry_pos2,cntry_pos3 ; min 1, max 3 pos.
	db	0		; no switches
	db	0		; no keywords

;cntry_pos1 p_pos <8000h,0,result_val,cc_range> ; numeric value
cntry_pos1:
	dw	8000h
	dw	0
	dw	result_val	
	dw	cc_range
	db	0

;cc_range p_range <,,,1,999>
cc_range:
	db	1
	db	1
	db	1
	dd	1
	dd	999

;cntry_pos2 p_pos <8001h,0,result_val,cc_range> ; optional num.
cntry_pos2:
	dw	8001h
	dw	0
	dw	result_val	
	dw	cc_range
	db	0

;cntry_pos3 p_pos <201h,0,result_val,noval>     ; optional filespec
cntry_pos3:
	dw	201h
	dw	0
	dw	result_val	
	dw	noval
	db	0	

p_cntry_code:
	dw	0	; local variable
p_code_page:
	dw	0	; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; files = n

;files_parms p_parms <files_parmsx>
files_parms:
	dw	files_parmsx
	db	1
	db	1
	db	';'

files_parmsx:
	dw	101h,files_pos	; min,max 1 positional
	db	0		; no switches
	db	0		; no keywords

;files_pos p_pos <8000h,0,result_val,files_range,0> ; numeric value
files_pos:
	dw	8000h
	dw	0
	dw	result_val	
	dw	files_range
	db	0

;files_range p_range <,,,8,255>
files_range:
	db	1
	db	1
	db	1
	dd	8
	dd	255

p_files:
	db	0		; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; fcbs = n,m

;fcbs_parms p_parms <fcbs_parmsx>
fcbs_parms:
	dw	fcbs_parmsx
	db	1
	db	1
	db	';'

fcbs_parmsx:
	dw	201h,fcbs_pos_1,fcbs_pos_2 ; min,max = 2 positional
	db	0		; no switches
	db	0		; no keywords

;fcbs_pos_1 p_pos <8000h,0,result_val,fcbs_range> ; numeric value
fcbs_pos_1:
	dw	8000h
	dw	0
	dw	result_val	
	dw	fcbs_range
	db	0

;fcbs_range p_range <,,,1,255>
fcbs_range:
	db	1
	db	1
	db	1
	dd	1
	dd	255

;fcbs_pos_2 p_pos <8000h,0,result_val,fcbs_keep_range> ; numeric value
fcbs_pos_2:
	dw	8000h
	dw	0
	dw	result_val	
	dw	fcbs_keep_range
	db	0

;fcbs_keep_range p_range <,,,0,255>
fcbs_keep_range:
	db	1
	db	1
	db	1
	dd	0
	dd	255

p_fcbs:	db	0		; local variable
p_keep:	db	0		; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; lastdrive = x

;ldrv_parms p_parms <ldrv_parmsx>
ldrv_parms:
	dw	ldrv_parmsx
	db	1
	db	1
	db	';'

ldrv_parmsx:
	dw	101h,ldrv_pos	; min,max = 1 positional
	db	0		; no switches
	db	0		; no keywords

;ldrv_pos p_pos	<110h,10h,result_val,noval> ; drive only, ignore colon
ldrv_pos:				    ; remove colon at end
	dw	110h
	dw	10h
	dw	result_val	
	dw	noval
	db	0
	
p_ldrv:	db	0		; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; stacks = n,m

;stks_parms p_parms <stks_parmsx>
stks_parms:
	dw	stks_parmsx
	db	1
	db	1
	db	';'

stks_parmsx:
	dw	202h,stks_pos_1,stks_pos_2 ; min,max = 2 positionals
	db	0		; no switches
	db	0		; no keywords

;stks_pos_1 p_pos <8000h,0,result_val,stks_range> ; numeric value
stks_pos_1:
	dw	8000h
	dw	0
	dw	result_val	
	dw	stks_range
	db	0

;stks_range p_range <,,,0,64>
stks_range:
	db	1
	db	1
	db	1
	dd	0
	dd	64

;stks_pos_2 p_pos <8000h,0,result_val,stk_size_range> ; numeric value
stks_pos_2:
	dw	8000h
	dw	0
	dw	result_val	
	dw	stk_size_range
	db	0

;stk_size_range p_range <,,,0,512>
stk_size_range:
	db	1
	db	1
	db	1
	dd	0
	dd	512	

p_stack_count:
	dw	0	; local variable
p_stack_size:
	dw	0	; local variable

;-----------------------------------------------------------------------

	; 27/10/2022

; multitrack = [ on | off ]

;mtrk_parms p_parms <mtrk_parmsx>
mtrk_parms:
	dw	mtrk_parmsx
	db	1
	db	1
	db	';'

mtrk_parmsx:
	dw	101h,mtrk_pos	; min,max = 1 positional
	db	0		; no switches
	db	0		; no keywords

;mtrk_pos p_pos <2000h,0,result_val,on_off_string> ; simple string
mtrk_pos:
	dw	2000h
	dw	0
	dw	result_val	
	dw	on_off_string
	db	0

p_mtrk:	db	0		; local variable

;-----------------------------------------------------------------------

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:20B2h)

; switches=/k

;swit_parms p_parms <swit_parmsx>
swit_parms:
	dw	swit_parmsx
	db	1
	db	1
	db	';'

swit_parmsx:
	dw	0		; no positionals
	;db	5               ; # of switches
	; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
	db	3
	dw	swit_k_ctrl	; /k control
	; 01/01/2023 - Retro DOS v4.2 ; *
	dw	swit_n_ctrl ; * ; /n control (for MULTI_CONFIG only)
	dw	swit_f_ctrl ; * ; /f control (for MULTI_CONFIG only)
	dw	swit_t_ctrl     ; /t control
	dw	swit_w_ctrl     ; /w control
	db	0		; no keywords

;swit_k_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_k_ctrl:
	dw	0,0,result_val,noval
	db	1
swit_k:	db	'/K',0

; 01/01/2023 - Retro DOS v4.2 (MSDOS 6.21 IO.SYS)
; (SYSINIT:220Ch) ; *

; 27/10/2022 - Retro DOS v4.0 (MSDOS 5.0 IO.SYS, SYSINIT)
;
;swit_n_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_n_ctrl: ; *
	dw	0,0,result_val,noval
	db	1
swit_n: db	'/N',0

;swit_f_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows
swit_f_ctrl: ; *
	dw	0,0,result_val,noval
	db	1
swit_f: db 	'/F',0

	; 27/10/2022

;swit_t_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M059
swit_t_ctrl:
	dw	0,0,result_val,noval
	db	1
swit_t:	db	'/T',0			   ;				M059
;swit_w_ctrl p_pos <0,0,result_val,noval,1> ; switch string follows	M063
swit_w_ctrl:
	dw	0,0,result_val,noval
	db	1
swit_w:	db	'/W',0			   ;				M063

;   There doesn't need to be p_swit_n or p_swit_f because /N and /F are
;   acted upon during MULTI_CONFIG processing; we only needed entries
;   in the above table to prevent the parsing code from complaining about them

p_swit_k:	db     0	; local variable
p_swit_t:	db     0	; local variable			M059
p_swit_w:	db     0	; local variable			M063

;-----------------------------------------------------------------------

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:20E8h)

; DOS = [ high | low ]

;dos_parms p_parms  <dos_parmsx>
dos_parms:
	dw	dos_parmsx
	db	1
	db	1
	db	';'
dos_parmsx:
	db	1		; min parameters
	db	2		; max parameters
	dw	dos_pos		; 
	dw	dos_pos		; 
	db	0		; no switches
	db	0		; no keywords

;dos_pos p_pos	<2000h,0,result_val,dos_strings> ; simple string
;        p_pos	<2000h,0,result_val,dos_strings> ; simple string
dos_pos:
	dw	2000h,0,result_val,dos_strings
	db	0
	dw	2000h,0,result_val,dos_strings
	db	0	

dos_strings:	;label	byte
	db	3		; signals that there is a string choice
	db	0		; no range definition
	db	0		; no numeric values choice
	db	4		; 4 strings for choice
	db	1		; the 1st string tag
	dw	hi_string
	db	2		; the 2nd string tag
	dw	lo_string
	db	3
	dw	umb_string
	db	4
	dw	noumb_string

hi_string:	db	"HIGH",0
lo_string:	db	"LOW",0
umb_string:	db	"UMB",0
noumb_string:	db	"NOUMB",0

p_dos_hi:	db	0	; local variable
				; BUGBUG : I dont know whether PARSER uses
				;          this variable or not

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
;%if 0

;****************************************************************** RICHID ****

;include	highvar.inc	; devicehigh variables (used by loadhigh also)

; 30/03/2019 - Retro DOS v4.0
;------------------------------------------------------------------------------

;   Module:   HIGHVAR.INC - Data common to LOADHIGH and DEVICEHIGH, res seg
;
;   Date:     May 14, 1992
;
;******************************************************************************
;
;   Modification log:
;
;     DATE    WHO      DESCRIPTION
;   --------  -------  --------------------------------------------------------
;   05/14/92  t-richj  Original
;   06/21/92  t-richj  Final revisions before check-in
;
;******************************************************************************
;
; There are two primary definitions which need to be made, selectively, before
; this include file should be used.  These are:
;    HV_Extern - If this has been defined, variables for this module will be
;                declared as external.  Otherwise, variables will be declared
;                public, as well as defined, here.  LoadHigh declares HV_Extern
;                in stub.asm and loadhi.asm, and does not declare it in
;                rdata.asm... DeviceHigh does not declare HV_Extern anywhere
;                (as only one module, sysconf.asm, includes this file).
;    HV_LoadHigh - This should be defined when this module is going into
;                  command.com, for LoadHigh.  All of loadhi.asm, stub.asm and
;                  rdata.asm define this, while io.sys' sysconf.asm does not.
;
;******************************************************************************

; To keep track of which UMBs were specified on the DH/LH command lines, and
; to keep track of the minimum sizes given for each, there're two arrays kept
; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
; big.  16 should be around 14 too many for most users, so there's no expected
; space problem (it's just such a nice round number, eh?).

MAXUMB	equ	16

; Memory elements owned by the system are marked as PSP address 8 in both the
; USA and Japan; Japanese systems also use 9 under more bizzarre conditions.

FreePSPOwner	equ	0	; Free MCBs all have an owner PSP address of 0
SystemPSPOwner	equ	8
;JapanPSPOwner	equ	9

; for LoadHigh and DeviceHigh:
;
;	fInHigh - Is set to 1 during HideUMBs(), and back to zero in
;	          UnHideUMBs().
;	fUmbTiny - Is set to 1 iff the user has specified /S on the command-
;	           line.
;	SegLoad - Segment address for first UMB specified; set automatically.
;	UmbLoad - The load UMB number; for example, this is 3 if the user has
;	          given a command-line like "/L:3,500;4"
;	UmbUsed - An array of characters, each of which is 1 iff the UMB
;	          matching its index number was specified on the command-line;
;	          for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
;	          will be set to 1.  All others will be set to 0.
;	UmbSize - An array of words, each of which is interpereted as a size
;	          specified by the user for a UMB (in the above example, all
;	          elements would be zero save UmbSize[3], which would be 500.
;	fm_umb - Set to the old UMB link-state (0x80 or 0x00)
;	fm_strat - Set to the old memory-allocation strategy (0$00000???)
;	fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
;	           for details).

fInHigh:  db	0
fUmbTiny: db	0
SegLoad:  dw	0
UmbLoad:  db	0
UmbUsed:  times MAXUMB db 0 ; times 16 db 0  ; db 16 dup(?)
UmbSize:  times MAXUMB dw 0 ; times 16 dw 0  ; dw 16 dup(?)
fm_umb:   db	0
fm_strat: db	0
fm_argc:  db	0	

; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
; UmbLoad is set to the UMB number given.

UNSPECIFIED	equ	-1

;%endif ; 27/10/2022

;****************************************************************** RICHID ****

; 30/03/2019 - Retro DOS v4.0 (MSDOS 6.0, SYSCONF.ASM)
; ((MSDOS 6.21 IO.SYS -> SYNINIT:22BAh))

; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; (SYSINIT:212Bh)	

		;public	DevEntry

DevSize:	dw	0	; size of the device driver being loaded(paras)
DevLoadAddr:	dw	0	; Mem addr where the device driver is 2 b loaded
DevLoadEnd:	dw	0	; MaxAddr to which device can be loaded
DevEntry:	dd	0	; Entry point to the device driver
DevBrkAddr:	dd	0	; Break address of the device driver
; 30/12/2022
; 27/10/2022 
ConvLoad:	db	0	; Use conventional (dos 5 -style) InitDevLoad?
;
DevUMB:		db	0	; byte indicating whether to load DDs in UMBs
DevUMBAddr:	dw	0	; cuurent UMB used fro loading devices (paras)
DevUMBSize:	dw	0	; Size of the current UMB being used   (paras)
DevUMBFree:	dw	0	; Start of free are in the current UMB (paras)
;
DevXMSAddr:	dd	0
;
DevExecAddr:	dw	0	; Device load address parameter to Exec call
DevExecReloc:	dw	0	; Device load relocation factor
;
DeviceHi:	db	0	; Flag indicating whther the current device
				;  is being loaded into UMB
DevSizeOption:	dw	0	; SIZE= option
;
Int12Lied:	db	0	; did we trap int 12 ?
OldInt12Mem:	dw	0	; value in 40:13h (int 12 ram)
ThreeComName:	db	'PROTMAN$'	; 3Com Device name
;
FirstUMBLinked:	db	0
DevDOSData:	dw	0	; segment of DOS Data
DevCmdLine:	dd	0	; Current Command line
DevSavedDelim:	db	0	; The delimiter which was replaced with null
				; to use the file name in the command line
;
;	ifdef	dblspace_hooks
;MagicHomeFlag:	db	0	; set non-zero when MagicDrv is final placed
;	endif

; ===========================================================================

; 31/03/2019 - Retro DOS v4.0

; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; (SYSINIT:215Eh)

;----------------------------------------------------------------------------
;
; procedure : doconf
;
;             Config file is parsed initially with this routine. For the
;             Subsequent passes 'multi_pass' entry is used .
;
;----------------------------------------------------------------------------

	; 27/10/2022
doconf:
	push	cs
	pop	ds

	mov	ax,3700h
        ;mov	ax,(CHAR_OPER<<8)	; get switch character
	int	21h
	mov	[command_line+1],dl	; set in default command line

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21  IO.SYS)
; 27/10/2022
;;ifdef	MULTI_CONFIG
;	;mov	[command_line-1],dl     ; save default switchchar
	mov	[def_swchr],dl ; 31/03/2019 
;;endif	;MULTI_CONFIG

	mov	dx,config ;'\CONFIG.SYS' ;now pointing to file description
	mov	ax,3D00h
	;mov	ax,OPEN<<8		;open file "config.sys"
	stc				;in case of int 24
	int	21h			;function request
	jnc	short noprob		; brif opened okay

; 31/12/2022
; 27/10/2022
;;ifdef	MULTI_CONFIG
	call	kbd_read		; we still want to give the guy
;					; a chance to select clean boot!
;;endif					; (ie, no autoexec.bat processing)
	mov	byte [multi_pass_id],11	; set it to unreasonable number
	retn
noprob: 				;get file size (note < 64k!!)
	mov	bx,ax  ; File handle
	xor	cx,cx
	xor	dx,dx
	;mov	ax,4202h
	mov	ax,(LSEEK<<8)|2
	int	21h
	mov	[count],ax

	xor	dx,dx
	;mov	ax,4200h
	mov	ax,LSEEK<<8		;reset pointer to beginning of file
	int	21h

	; 31/12/2022 - Retro DOS v4.2 
	mov	dx,[ALLOCLIM]		;use current alloclim value
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	dx,[top_of_cdss] 

	mov	ax,[count]
	mov	[config_size],ax	;save the size of config.sys file.
	call	ParaRound
	sub	dx,ax

; 31/12/2022
; 27/10/2022
;ifdef	MULTI_CONFIG
;
;  The size of the CONFIG.SYS workspace (for recreating the in-memory
;  CONFIG.SYS image, and later for building the initial environment) need
;  not be any larger than CONFIG.SYS itself, EXCEPT for the fact that
;  we (may) add a variable to the environment that does not explicity appear
;  in CONFIG.SYS, and that variable is CONFIG (as in CONFIG=COMMON).
;  The default setting for CONFIG cannot result in more than 1 paragraph
;  of extra space, so here we account for it (the worst case of course is
;  when CONFIG.SYS is some very small size, like 0 -JTP)
;
	dec	dx                      ;reserve 1 additional paragraph
	mov	[config_wrkseg],dx      ;this is the segment to be used for
	sub	dx,ax                   ;rebuilding the config.sys memory image
;;endif	;MULTI_CONFIG

	sub	dx,11h			;room for header
	
	; 31/12/2022
	mov	[ALLOCLIM],dx		;config starts here. new alloclim value.
	mov	[CONFBOT],dx
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	[top_of_cdss],dx
	;call    TempCDS 
	
	; 31/12/2022
	; 11/12/2022
	; ds <> cs 
	;mov	dx,[cs:top_of_cdss]
 
	mov	ds,dx
	mov	es,dx

	xor	dx,dx
	mov	cx,[cs:count]
	mov	ah,3Fh
	;mov	ah,READ  ; 3Fh
	stc				;in case of int 24
	int	21h			;function request
	pushf

; find the eof mark in the file. if present,then trim length.

	push	ax
	push	di
	push	cx
	mov	al,1Ah			; eof mark
	mov	di,dx			; point to buffer
	jcxz	puteol			; no chars
	repnz	scasb			; find end
	jnz	short puteol		; none found and count exhausted

; we found a 1a. back up

	dec	di			; backup past 1Ah

;  just for the halibut, stick in an extra eol

puteol:
	mov	al,cr ; 0Dh
	stosb
	mov	al,lf  ;0Ah
	stosb
	sub	di,dx			; difference moved
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	[cs:count],di		; new count

	; 11/12/2022	
	; 31/03/2019 - Retro DOS v4.0
	push	cs
	pop	ds

	mov	[count],di		; new count

	pop	cx
	pop	di
	pop	ax

	; 11/12/2022
	; 27/10/2022
	;push	cs
	;pop	ds

	push	ax
	;mov	ah,CLOSE
	mov	ah,3Eh
	int	21h
	pop	ax
	popf
	jc	short conferr 		;if not we've got a problem
	cmp	cx,ax
	jz	short getcom		;couldn't read the file
conferr:
	mov	dx,config		;want to print config error
	call	badfil
;endconv:	; 01/01/2023
	retn

;----------------------------------------------------------------------------
;
; entry : multi_pass
;
;             called to execute device=,install= commands
;
;----------------------------------------------------------------------------

	; 27/10/2022
multi_pass:
	push	cs
	pop	ds

	cmp	byte [multi_pass_id],10
;jae_endconv:
	jae	short endconv 		; do nothing. just return.

	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	push	word [CONFBOT]
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;push	word [top_of_cdss]
	pop	es			; es -> confbot

	mov	si,[org_count]
	mov	[count],si		; set count
	xor	si,si ; 0
        mov     [chrptr],si		; reset chrptr
        mov     [linecount],si		; reset linecount

	call	getchr
	jmp	short conflp

	; 01/01/2023
endconv:
	retn	

getcom:
	; 03/01/2023
	; ds = cs
        call    organize                ; organize the file
	call	getchr
conflp: 
	jc	short endconv

        inc     word [linecount]	; increase linecount

	mov	byte [multdeviceflag],0	; reset multdeviceflag.
	mov	byte [setdevmarkflag],0	; reset setdevmarkflag.
	cmp	al,lf			; linefeed?
	je	short blank_line	;  then ignore this line.

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:23CCh)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

;ifdef	MULTI_CONFIG

;   If this is a genuine CONFIG.SYS command, then there should be a line
;   number immediately following it....

        mov     [config_cmd],al         ; save original command code
	;and	al,NOT CONFIG_OPTION_QUERY
	and	al,~CONFIG_OPTION_QUERY ; and al,7Fh
        cmp     byte [config_multi],0	; is this a multi-config config.sys?
        je      short not_final		; no, line number is not embedded

        push    ax                      ;
        call    getchr                  ; ignore end-of-image errors,
        mov     ah,al                   ; because if there's an error
        call    getchr                  ; fetching the line number that's
        xchg    al,ah                   ; supposed to be there, the next
        mov     [linecount],ax          ; getchr call will get the same error
        pop     ax
;
;   HACK: when 4DOS.COM is the shell and it doesn't have an environment from
;   which to obtain its original program name, it grovels through all of
;   memory to find the filename that was used to exec it; it wants to find
;   the SHELL= line in the in-memory copy of CONFIG.SYS, and it knows that
;   sysinit converts the SHELL= keyword to an 'S', so it expects to find an 'S'
;   immediately before the filename, but since we are now storing line # info
;   in the config.sys memory image, 4DOS fails to find the 'S' in the right
;   spot.
;
;   So, on the final pass of CONFIG.SYS, copy the command code (eg, 'S')
;   over the line number info, since we no longer need that info anyway. This
;   relies on the fact that getchr leaves ES:SI pointing to the last byte
;   retrieved.
;
        cmp	byte [multi_pass_id],2	; final pass?
        jb	short not_final		; no
        ;test	word [install_flag],have_install_cmd
	test	byte [install_flag],have_install_cmd ; 1
        jz	short final		; no install cmds, so yes it is
        cmp	byte [multi_pass_id],3	; final pass?
        jb	short not_final		; no
final:                                  ;
	mov	[es:si],al		; save backward-compatible command code
not_final:                              ;
;endif

; 31/12/2022
;%endif ; 27/10/2022

	mov	ah,al
	call	getchr
	jnc	short tryi

	cmp	byte [multi_pass_id],2
	;jae	short jae_endconv	; do not show badop again for multi_pass.
	; 27/10/2022
	jnb	short endconv	
	jmp	badop
	
coff:	
	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds
	call	newline
	jmp	short conflp	; 13/05/2019

blank_line:
	call	getchr
	jmp	short conflp

	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
; 11/12/2022
; (there is not a jump or call to here from anywhere!)
;coff_p:
	;push	cs
	;pop	ds

;to handle install= commands,we are going to use multi-pass.
;the first pass handles the other commands and only set install_flag when
;it finds any install command. the second pass will only handle the
;install= command.

;------------------------------------------------------------------------------
;install command
;------------------------------------------------------------------------------

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2250h)
tryi:
	cmp	byte [multi_pass_id],0	; the initial pass for DOS=HI
	jne	short not_init_pass
	jmp	multi_try_doshi
not_init_pass:
	cmp	byte [multi_pass_id],2	; the second pass was for ifs=
        ; 11/12/2022
	;je	short multi_pass_coff2	; now it is NOPs
	je	short coff
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;je	short multi_pass_coff	
					; This pass can be made use of if
					; we want do some config.sys process
					; after device drivers are loaded
					; and before install= commands
					; are processed

	cmp	byte [multi_pass_id],3	; the third pass for install= ?
	je	short multi_try_i
        cmp     ah, CONFIG_DOS  ; 'H'
	; 11/12/2022
	;je	short multi_pass_coff2
	je	short coff
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;je	short multi_pass_coff	

;       make note of any INSTALL= or INSTALLHIGH= commands we find,
;       but don't process them now.        
        
        cmp     ah,CONFIG_INSTALL ; 'I'	; install= command?
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	jne	short precheck_installhigh ; the first pass is for normal operation.
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jne	short tryb	
	
	;or	word [install_flag],have_install_cmd ; set the flag
	or	byte [install_flag],have_install_cmd ; 1
multi_pass_coff2:
	jmp	short coff ; 13/05/2019	; and handles the next command

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2448h)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
precheck_installhigh:
	cmp     ah,CONFIG_INSTALLHIGH ; 'W' ; signifier for INSTALLHIGH
	jne     short tryb		; carry on with normal processing
	;or	word [install_flag],have_install_cmd
	or	byte [install_flag],have_install_cmd ; 1
	jmp	short coff
;%endif ; 27/10/2022

multi_try_i:
        cmp     ah,CONFIG_INSTALL ; 'I' ; install= command?
	; 31/12/2022 - Retro DOS v4.2
	jne	short multi_try_n	; no, check for installhigh
	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jne	short multi_pass_filter

; 31/12/2022
;%if 1 
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 27/10/2022

	call	do_install_exec 	;install it.
	jmp	short coff		;to handle next install= command.

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2463h)
;%if 1
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

multi_try_n:
        cmp     ah,CONFIG_INSTALLHIGH   ; installhigh= command?
        jne	short multi_pass_filter	; no. ignore this.
;ifdef	MULTI_CONFIG
        call    query_user              ; query the user if config_cmd
        jc      short multi_pass_filter	; has the CONFIG_OPTION_QUERY bit set
;endif

;       The memory environment is in its normal DOS state, so do
;       the standard calls to set the alloc strategy for loading high

	mov	ax,(ALLOCOPER<<8)|0 ; 5800h
	int	21h			;get alloc strategy
	mov	bx,ax
        push    bx                      ; save for the return

        or	bx,HIGH_FIRST  ; 80h	;set alloc to HighFirst
	mov	ax,(ALLOCOPER<<8)|1 ; 5801h
	int	21h			;set alloc strategy

	mov     ax,(ALLOCOPER<<8)|2 ; 5802h
        int     21h                     ; get link state
        xor     ah,ah                   ; clear top byte
        push    ax                      ; save for return

        mov	ax,(ALLOCOPER<<8)|3 ; 5803h
	mov	bx,1
	int	21h			;link in UMBs

	call	do_install_exec 	;install it.

        mov     ax,(ALLOCOPER<<8)|3
        pop     bx                      ; recover original link state
        int     21h
        pop     bx                      ; recover original alloc strategy
        mov     ax,(ALLOCOPER<<8)|1
        int     21h

	;jmp	short coff		;to handle next install= command.
	; 01/01/2023
	jmp	short multi_pass_coff2

;%endif ; 27/10/2022

multi_pass_filter:
        cmp     ah,CONFIG_COMMENT ; 'Y' ; comment?
	je	short multi_pass_adjust
        cmp     ah,CONFIG_UNKNOWN ; 'Z' ; bad command?
	je	short multi_pass_adjust
        cmp     ah,CONFIG_REM  ; '0' 	; rem?
	jne	short multi_pass_coff 	; ignore the rest of the commands.

multi_pass_adjust:			; these commands need to
	dec	word [chrptr]		;  adjust chrptr,count
	inc	word [count]		;  for newline proc.

multi_pass_coff:
	; 11/12/2022
	;jmp	short coff		; to handle next install= commands.
	; 01/01/2023
	jmp	short multi_pass_coff2

;------------------------------------------------------------------------------
; buffer command
;------------------------------------------------------------------------------

;******************************************************************************
;									      *
; function: parse the parameters of buffers= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	buffers set							      *
;	buffer_slash_x	flag set if /x option chosen.			      *
;	h_buffers set if secondary buffer cache specified.		      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to buf_parms;  /*parse control definition*/	      *
;	set dx,cx to 0; 						      *
;	reset buffer_slash_x;						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val._$P_synonym_ptr == slash_e) then /*not a switch *
;		    buffer_slash_x = 1					      *
;	       else if	 (cx == 1) then 	    /* first positional */    *
;			  buffers = result_val._$P_picked_val;		      *
;		    else  h_buffers = result_val._$P_picked_val; 	      *
;	  else	{show error message;error exit} 			      *
;	};								      *
;	if (buffer_slash_x is off & buffers > 99) then show_error;	      *
; };									      *
;									      *
;******************************************************************************

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:229Ch)
tryb:
        cmp     ah,CONFIG_BUFFERS ; 'B'
	jne	short tryc

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:24BFh)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user		; query the user if config_cmd
	jc	short tryc		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 27/10/2022

	; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 18/12/2022
	xor	cx,cx
	;mov	byte [p_buffer_slash_x],0 ; 31/03/2019
	mov	[p_buffer_slash_x],cl ; 0

	mov	di,buf_parms
	;xor	cx,cx	; 18/12/2022
	; 03/01/2023
	;mov	dx,cx
do7:
	call	sysinit_parse
	jnc	short if7		; parse error,
	;call	badparm_p		;  and show messages and end the search loop.
	;;jmp	short sr7
	; 31/12/2022
;sr7:
	;jmp	coff
	; 03/01/2023
	jmp	badparm_p_coff
if7:
	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
	je	short en7		;  then jmp to $endloop for semantic check
	;cmp	word [result_val_swoff],switch_x
	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],switch_x
	;jne	short if11
	; 31/12/2022
	je	short do7 ;je short en11

;	mov	byte [p_buffer_slash_x],1 ; set the flag M016
	;jmp	short en11 ; 31/12/2022
if11:
	;mov	ax,[rv_dword]
	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
	cmp	cx,1
	jne	short if13

	mov	[p_buffers],ax
	;jmp	short en11
	; 31/12/2022
	jmp	short do7
if13:
	mov	[p_h_buffers],ax
en11:
	jmp	short do7
en7:
	cmp	word [p_buffers],99
	jbe	short if18

;	cmp	byte [p_buffer_slash_x],0 ; M016
;	jne	short if18

	call	badparm_p
	mov	word [p_h_buffers],0
	jmp	short sr7
if18:
	mov	ax,[p_buffers]	; we don't have any problem.
	mov	[buffers],ax	; now,let's set it really.

	mov	ax,[p_h_buffers]
	mov	[h_buffers],ax

;	mov	al,[p_buffer_slash_x]	; M016
;	mov	[buffer_slash_x],al

	mov	ax,[linecount]
	mov	[buffer_linenum],ax ; save the line number for the future use.
	; 31/12/2022
	;jmp	short sr7
	; 03/01/2023
sr7:
	jmp	coff

;------------------------------------------------------------------------------
; break command
;------------------------------------------------------------------------------

;****************************************************************************
;									    *
; function: parse the parameters of break = command.			    *
;									    *
; input :								    *
;	es:si -> parameters in command line.				    *
; output:								    *
;	turn the control-c check on or off.				    *
;									    *
; subroutines to be called:						    *
;	sysinit_parse							    *
; logic:								    *
; {									    *
;	set di to brk_parms;						    *
;	set dx,cx to 0; 						    *
;	while (end of command line)					    *
;	{ sysinit_parse;						    *
;	  if (no error) then						    *
;	       if (result_val._$P_item_tag == 1) then	  /*on		 */ *
;		   set p_ctrl_break,on;					    *
;	       else					  /*off 	 */ *
;		   set p_ctrl_break,off;				    *
;	  else {show message;error_exit};				    *
;	};								    *
;	if (no error) then						    *
;	   dos function call to set ctrl_break check according to	    *
; };									    *
;									    *
;****************************************************************************

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:22FFh)
tryc:
        cmp     ah,CONFIG_BREAK ; 'C'
	jne	short trym

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2527h)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short trym		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 27/10/2022

	mov	di,brk_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do22:
	call	sysinit_parse
	jnc	short if22		; parse error
	;call	badparm_p		;  show message and end the search loop.
	;;jmp	short sr22
	; 31/12/2022
;sr22:
	;jmp	coff
	; 03/01/2023
	jmp	badparm_p_coff
if22:
	cmp	ax,_$P_RC_EOL		; end of line?
	je	short en22		; then end the $endloop

	;cmp	byte [result_val_itag],1
	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
	jne	short if26

	mov	byte [p_ctrl_break],1	; turn it on
	;jmp	short en26
	; 31/12/2022
	jmp	short do22
if26:
	mov	byte [p_ctrl_break],0	; turn it off
en26:
	jmp	short do22		; we actually set the ctrl break
en22:
	mov	ah,SET_CTRL_C_TRAPPING ; if we don't have any parse error.
	mov	al,1
	mov	dl,[p_ctrl_break]
	int	21h
	; 31/12/2022
	;jmp	short sr22
	; 03/01/2023
sr22:
	jmp	coff

;------------------------------------------------------------------------------
; multitrack command
;------------------------------------------------------------------------------

;******************************************************************************
;									      *
; function: parse the parameters of multitrack= command.		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	turn multrk_flag on or off.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di to brk_parms;						      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	       if (result_val._$P_item_tag == 1) then	  /*on		 */   *
;		   set p_mtrk,on;					      *
;	       else					  /*off 	 */   *
;		   set p_mtrk,off;					      *
;	  else {show message;error_exit};				      *
;	};								      *
;	if (no error) then						      *
;	   dos function call to set multrk_flag according to p_mtrk.	      *
;									      *
; };									      *
;									      *
;******************************************************************************

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
trym:
        cmp     ah,CONFIG_MULTITRACK  ; 'M'
	jne	short tryu

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2569h)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user      ; query the user if config_cmd
	jc	short tryu	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif	; 27/10/2022

	mov	di,mtrk_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do31:
	call	sysinit_parse
	jnc	short if31	; parse error
	;call	badparm_p	;  show message and end the search loop.
	;;jmp	short sr31
	; 31/12/2022
;sr31:
	;jmp	coff
	; 03/01/2023
	jmp	badparm_p_coff
if31:
	cmp	ax,_$P_RC_EOL	; end of line?
	je	short en31	; then end the $endloop

	;cmp	byte [result_val_itag],1
	cmp	byte [result_val+_$P_Result_Blk.Item_Tag],1
	jne	short if35

	mov	byte [p_mtrk],1	; turn it on temporarily.
	;jmp	short en35
	; 31/12/2022
	jmp	short do31
if35:
	mov	byte [p_mtrk],0	; turn it off temporarily.
en35:
	jmp	short do31	; we actually set the multrk_flag here
en31:
	push	ds
	;;mov	ax,Bios_Data ; 70h
	;mov	ax,KERNEL_SEGMENT ; 70h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax

	cmp	byte [cs:p_mtrk],0
	jne	short if39

	mov	word [multrk_flag],multrk_off2	; 0001h
	jmp	short en39
if39:
	mov	word [multrk_flag],multrk_on	; 0080h
en39:
	pop	ds
	; 31/12/2022
	;jmp	short sr31
	; 03/01/2023
sr31:
	jmp	coff

;----------------------------------------------------------------------------
; DOS=HIGH/LOW command
;----------------------------------------------------------------------------

	; 27/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
multi_try_doshi:
        cmp     ah,CONFIG_DOS ; 'H'
	je	short it_is_h
skip_it:
	jmp	multi_pass_filter
it_is_h:				; M003 - removed initing DevUMB
					;	 & runhigh
; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:25C1h)
; 27/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short skip_it		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 27/10/2022

	mov	di,dos_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
h_do_parse:
	call	sysinit_parse
	jnc	short h_parse_ok	; parse error
h_badparm:
	; 03/01/2023
	;call	badparm_p		; show message and end the search loop.
	;;jmp	short h_end
	; 11/12/2022
;h_end:
	;jmp	coff
	; 03/01/2023
	jmp	badparm_p_coff	
h_parse_ok:
	cmp	ax,_$P_RC_EOL		; end of line?
	je	short h_end		; then end the $endloop
	call	ProcDOS
	jmp	short h_do_parse
	; 11/12/2022
	; 03/01/2023
h_end:
	jmp	coff

;-----------------------------------------------------------------------------
; devicehigh command
;-----------------------------------------------------------------------------

	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
tryu:
        cmp     ah,CONFIG_DEVICEHIGH ; 'U'
	jne	short tryd

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:25E9h)
; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short tryd		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 28/10/2022

; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	; 01/01/2023
	; ds = cs

	call	InitVar
	call	ParseSize		; process the size= option
	;jnc	short tryu_0
	; 31/12/2022
	jc	short tryu_1 ; 31/03/2019 - Retro DOS v4.0

;%endif ; 28/10/2022

; 31/12/2022
%if 0
	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	[cs:badparm_off], si	; stash it there in case of an error
	;mov	[cs:badparm_seg], es
	; 11/12/2022
	; ds = cs
	mov	[badparm_off], si
	mov	[badparm_seg], es

	; 31/12/2022
	;call	ParseSize
	;jnc	short tryu_2	; 28/10/2022
	
	;call	badparm_p
	;jmp	coff
	; 03/01/2023
	jmp	badparm_p_coff
%endif

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2606h)
; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
tryu_0:
	;mov	ax,[cs:DevSizeOption]
	; 31/12/2022
	mov	ax,[DevSizeOption] ; ds = cs
	or	ax,ax
	jnz	short tryu_2

	call	ParseVar
	jnc	short tryu_2
tryu_1:
	; 31/12/2022
	; ds = cs
	mov	[badparm_off], si
	mov	[badparm_seg], es
	;mov	[cs:badparm_off], si	; If ParseVar up there failed, then
	;mov	[cs:badparm_seg], es	; ES:SI points to its problem area...
	
	;call	badparm_p		; so all we have to do is choke and
	;jmp	coff			; die, rather verbosely.
	; 03/01/2023
	jmp	badparm_p_coff

;%endif ; 28/10/2022

tryu_2:	
	push	si
	push	es
tryu_3:
	mov	al,[es:si]
	cmp	al,cr
	je	short tryu_4
	cmp	al,lf
	je	short tryu_4
	call	delim
	jz	short tryu_4
	inc	si
	jmp	short tryu_3
tryu_4:	
	; 11/12/2022
	; ds = cs
	mov	[DevSavedDelim],al
	;mov	[cs:DevSavedDelim],al	; Save the delimiter before replacing
					;  it with null
	; 18/12/2022
	sub	bx,bx
	mov	[es:si],bl ; 0
 	;mov	byte [es:si],0

	pop	es
	pop	si

;------------------------------------------------------------------------------
; BEGIN PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
;------------------------------------------------------------------------------

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2642h)
; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	; 01/01/2023
	; ds = cs
	call	UmbTest			; See if UMBs are around...
	; 01/01/2023
	;jnc	short NrmTst		; ...yep. So do that normal thang.
	
	;mov	byte [cs:DeviceHi],0	; ...nope... so load low.
	; 31/12/2022
	; ds = cs, bx = 0
	;mov	byte [DeviceHi],bl ; 0
	;jmp	short LoadDevice
	; 01/01/2023
	jc	short LoadDevice ; bl = 0

;%endif

;------------------------------------------------------------------------------
; END PATCH TO CHECK FOR NON-EXISTANT UMBs   -- t-richj 7-21-92
;------------------------------------------------------------------------------

NrmTst:
	; 11/12/2022
	; ds = cs
	;;mov	byte [cs:DeviceHi],0
	;mov	byte [DeviceHi],0
	; 18/12/2022
	; bx = 0
	cmp	[DevUMB],bl ; 0
	;cmp	byte [DevUMB],0
	;;cmp	byte [cs:DevUMB],0	; do we support UMBs
	je	short LoadDevice	; no, we don't
	;mov	byte [cs:DeviceHi],1
	; 11/12/2022
	;mov	byte [DeviceHi],1
	; 18/12/2022
	inc	bl ; mov bl,1 ; (*)
	; 11/12/2022
	;jmp	short LoadDevice2	; 11/12/2022
	jmp	short LoadDevice

;------------------------------------------------------------------------------
; device command
;------------------------------------------------------------------------------

	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2665h)

	; 28/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2401h)
tryd:
	; 11/12/2022
	;xor 	bx,bx ; 31/12/2022
	;
        cmp     ah,CONFIG_DEVICE ; 'D'
	je	short gotd
skip_it2:
	jmp	tryq
gotd:

; 31/12/2022 - Retro DOS v4.2
; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short skip_it2		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 28/10/2022

	; 31/12/2022
	sub	bx,bx
	; bx = 0
	; 11/12/2022
	; ds = cs
	;mov	byte [DeviceHi],0
	;mov	word [DevSizeOption],0
	mov	[DevSizeOption],bx ; 0
	mov	byte [DevSavedDelim],' '
	;mov	byte [cs:DeviceHi],0	; not to be loaded in UMB ;M007
	;mov	word [cs:DevSizeOption],0
	;mov	byte [cs:DevSavedDelim],' ' ; In case of DEVICE= the null has to
					;  be replaced with a ' '
LoadDevice:                             ; device= or devicehigh= command.
	; 11/12/2022
	;mov	byte [DeviceHi],0
	mov	byte [DeviceHi],bl	; 0 or 1 (*)
LoadDevice2:
	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)        
	;
	;push    cs
        ;pop     ds
	;
	;mov	[bpb_addr],si		; pass the command line to the dvice
	;mov	[bpb_addr+2],es
	;
	;mov	[DevCmdLine],si		; save it for ourself
	;mov	[DevCmdLine+2],es
	;
	;mov	byte [driver_units],0	; clear total block units for driver	

	; 11/12/2022
	; ds = cs
	;mov	bx,cs
	;mov	ds,bx

	;mov	[cs:bpb_addr],si	; pass the command line to the dvice
	mov	[bpb_addr],si
	;mov	[cs:bpb_addr+2],es
	mov	[bpb_addr+2],es

	;mov	[cs:DevCmdLine],si	; save it for ourself
	mov	[DevCmdLine],si
	;mov	[cs:DevCmdLine+2],es	
	mov	[DevCmdLine+2],es

	; 31/12/2022 - Retro DOS v4.2
	mov	byte [driver_units],0	; clear total block units for driver	

	call	round
	
	call	SizeDevice
	jc	short BadFile

	; 11/12/2022
	; ds = cs

; - Begin DeviceHigh primary logic changes ------------------------------------

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:26A4h)

; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	mov	byte [ConvLoad],1	; Doesn't matter if DeviceHi==0

	mov	al,[DeviceHi]		; If not using upper memory,
	or	byte [DeviceHi],0	; Skip all this and go on to
	jz	short DevConvLoad	; the actual load.

	;call	GetLoadUMB		; Returns first UMB spec'ed in AX
	mov	al,[UmbLoad]	; 19/04/2019 - Retro DOS v4.0

	cmp	al,-1			; If umb0 not specified, it's old style
	jz	short DevConvLoad	; so load high even if SIZE= is smaller

	dec	byte [ConvLoad] ; 0 	; They specified /L, so use new loader

	call	GetLoadSize		; Returns size of first UMB specified
	or	ax,ax
	jz	short tryd_1		; If size1 not specified, nada to do:

	cmp	ax,[DevSize]		; /L:...,Size < DevSize?
	jge	short DevConvLoad
tryd_1:
	mov	ax,[DevSize]		; Size < DevSize, so write DevSize as
	call	StoLoadSize		; minsize for load UMB.

;%endif ; 28/10/2022

; - End DeviceHigh primary logic changes --------------------------------------

DevConvLoad:
	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	call	InitDevLoad

	; 11/12/2022
	; ds = cs
	mov	ax,[DevLoadAddr]
	add	ax,[DevSize]
	jc	short NoMem
	cmp	[DevLoadEnd],ax
	jae	short LoadDev
	
	; 11/12/2022
	;mov	ax,[cs:DevLoadAddr]
	;add	ax,[cs:DevSize]
	;jc	short NoMem
	;cmp	[cs:DevLoadEnd],ax
	;jae	short LoadDev
NoMem:
	; 11/12/2022
	; ds = cs
	;jmp	mem_err
	jmp	mem_err2

BadFile:
	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;;call	RetFromUM		; Does nothing if didn't call HideUMBs
	;;cmp	byte [es:si],' '
        ;;jae	short tryd_2
	; 31/12/2022	
	;cmp	byte [es:si],0Dh	; cr
        ;jne	short tryd_2
	;jmp	badop
	; 31/12/2022
	; ds = cs
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:26E6h)
	call	RetFromUM		; Does nothing if didn't call HideUMBs
	cmp	byte [es:si],' ' 
	;cmp	byte [es:si],20h ; space
	jnb	short tryd_2
	jmp	badop
tryd_2:
	call	badload
	jmp	coff

LoadDev:
	push	es
	pop	ds

	mov	dx,si			;ds:dx points to file name
	call	ExecDev			; load device driver using exec call
badldreset:
	push	ds
	pop	es			;es:si back to config.sys
	push	cs
	pop	ds			;ds back to sysinit
	jc	short BadFile
goodld:
	; 11/12/2022
	; ds = cs

	push	es ; +	; 31/12/2022
	push	si ; ++
	call	RemoveNull
	push	es
	push	si

	push	cs
	pop	es

	push	ds ; **  ; ds = cs
	push	si

	;lds	si,[cs:DevEntry]	; peeks the header attribute
	; 31/12/2022
	; ds = cs
	lds	si,[DevEntry]

	;test	word [si+4],8000h
	; 11/12/2022
	test	byte [si+SYSDEV.ATT+1],DEVTYP>>8
	;test	word [si+SYSDEV.ATT],DEVTYP ; block device driver?
	jnz	short got_device_com_cont   ; no.

	lds	si,[cs:DOSINFO]		; ds:si -> sys_var
	;cmp	byte [si+32],26
	cmp	byte [si+SYSI_NUMIO],26	; no more than 26 drive number
	jb	short got_device_com_cont

	pop	si
	pop	ds ; **

	pop	si			; clear the stack
	pop	es

	; 28/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;call	RetFromUM
	; 31/12/2022
	; ds = cs ; **
	call	RetFromUM		; Do this before we leave

	;jmp	short badnumblock
	; 31/12/2022
	jmp	short badnumblock2  ; ds = cs

got_device_com_cont:
	pop	si
	pop	ds

	; 11/12/2022
	; ds = cs

	call	LieInt12Mem
	call	UpdatePDB		; update the PSP:2 value M020

	; 11/12/2022
	; ds = cs
	cmp	byte [multdeviceflag],0
	;cmp	byte [cs:multdeviceflag],0 ; Pass limit only for the 1st device
					;  driver in the file ; M027
	jne	short skip_pass_limit	;		      ; M027

	; 11/12/2022
	; ds = cs
	;mov	word [cs:break_addr],0	; pass the limit to the DD
	;mov	bx,[cs:DevLoadEnd]
	;mov	[cs:break_addr+2],bx

	mov	word [break_addr],0
	mov	bx,[DevLoadEnd]
	mov	[break_addr+2],bx

skip_pass_limit:
;	Note: sysi_numio (in DOS DATA) currently reflects the REAL
;	number of installed devices (including DblSpace drives) where
;	"drivenumber" is the number that the next block device will
;	be assigned to. Because some naughty device drivers (like
;	interlnk) look at the internal DOS variable instead of the
;	value we pass it, we'll temporarily stick our value into
;	DOS DATA while we're initializing the device drivers.
;
;	Note that this will make it impossible for this device
;	driver to access the DblSpace drive letters, whether
;	they are swapped-hosts or unswapped compressed drives,
;	during its initialization phase.

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2752h)
; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	; 31/12/2022
	;push	ds
	
	;lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
	; 31/12/2022
	; ds = cs
	lds	bx,[DOSINFO]		; ds:bx -> sys_var

	mov	al,[cs:drivenumber]	; temporarily use this next drv value
	mov	[cs:devdrivenum],al	; pass drive number in packet to driver
	mov	ah,al
	
	xchg	ax,[bx+SYSI_NUMIO]	; swap with existing values
	; 31/12/2022
	;pop	ds
	
	push	ax			; save real sysi_numio/ncds in ax

;%endif ; 29/10/2022

	; 29/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:24B9h)

	mov	bx,SYSDEV.STRAT ; 6
	call	calldev 		; calldev (sdevstrat);
	mov	bx,SYSDEV.INT ; 8
	call	calldev 		; calldev (sdevint);

	; 11/12/2022
	; ds <> cs (from calldev) ; 31/12/2022

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2773h)
; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	pop	ax			; get real sysi_numio value
	; 31/12/2022
	;push	ds
	lds	bx,[cs:DOSINFO]		; ds:bx -> sys_var
	mov	[bx+SYSI_NUMIO],ax	; swap with existing values
	; 31/12/2022
	;pop	ds

;%endif ; 29/10/2022

	; 11/12/2022
	push	cs
	pop	ds

	call	TrueInt12Mem

	; 11/12/2022
	; ds = cs
	;mov	ax,[cs:break_addr]	; move break addr from the req packet
	;mov	[cs:DevBrkAddr],ax
	;mov	ax,[cs:break_addr+2]
	;mov	[cs:DevBrkAddr+2],ax
	mov	ax,[break_addr]	
	mov	[DevBrkAddr],ax
	mov	ax,[break_addr+2]
	mov	[DevBrkAddr+2],ax

	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;call	RetFromUM		; There we go... all done.
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2791h)
	call	RetFromUM		; There we go... all done.	

	; 31/12/2022
	; ds = cs

	; 11/12/2022
	cmp	byte [DevUMB],0	
	;cmp	byte [cs:DevUMB],0
	je	short tryd_3
	call	AllocUMB
	; 31/12/2022
	; ds = cs
tryd_3:

;ifndef ROMDOS
;------ If we are waiting to be moved into hma lets try it now !!!

	; 11/12/2022
	; ds = cs
	
	;cmp	byte [cs:runhigh],0FFh
	cmp	byte [runhigh],0FFh ; 11/12/2022
	jne	short tryd_4
	
	; 11/12/2022
	; ds = cs
	call	TryToMovDOSHi		; move DOS into HMA if reqd
tryd_4:
;endif ; ROMDOS

	pop	si
	pop	ds
	mov	byte [si],0		; *p = 0;

	push	cs
	pop	ds

	jmp	short was_device_com

;----------------------------------------------------------------------------

; 02/04/2019 - Retro DOS v4.0

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:27B3h)

badnumblock:
	push	cs
	pop	ds
badnumblock2:	; 31/12/2022 (ds=cs)
	mov	dx,badblock
	call	print

;------ fall thru -----------------------------------------------------------

	; 31/12/2022 - Retro DOS v4.2

erase_dev_do:				; modified to show message "error in config.sys..."
	
	;call	CheckDoubleSpace ; MSDOS 6.21 IO.SYS SYSINIT:27BBh
	
	pop	si ; ++
	pop	es ; + ; 31/12/2022

	push	cs
	pop	ds

skip1_resetmemhi:
	; 11/12/2022
	; ds = cs
	cmp	word [configmsgflag],0
	;cmp	word [cs:configmsgflag],0
	je	short no_error_line_msg

	call	error_line		; no "error in config.sys" msg for device driver. dcr d493
	; 11/12/2022
	; ds = cs
	;mov	word [cs:configmsgflag],0
	mov	word [configmsgflag],0	; set the default value again.

no_error_line_msg:
	jmp	coff

;----------------------------------------------------------------------------

was_device_com:
	; 14/12/2022
	; ds = cs
	mov	ax,[DevBrkAddr+2]
	;mov	ax,[cs:DevBrkAddr+2] ; 13/05/2019
	cmp	ax,[DevLoadEnd]
	;cmp	ax,[cs:DevLoadEnd]
	jbe	short breakok

	pop	si
	pop	es
	jmp	BadFile

breakok:
	; 14/12/2022
	; ds = cs
	les	di,[DOSINFO] 
	lds	dx,[DevEntry]
	;lds	dx,[cs:DevEntry]	;set ds:dx to header
	mov	si,dx

	; 14/11/2022
	;les	di,[cs:DOSINFO] 	;es:di point to dos info

	; 14/12/2022
	; ds <> cs
	
	;mov	ax,[si+4]
	mov	ax,[si+SYSDEV.ATT]	;get attributes
	; 12/12/2022
	test	ah,DEVTYP>>8 ; 80h 
	;test	ax,DEVTYP ; 8000h	;test if block dev
	jz	short isblock

;------ lets deal with character devices

	or	byte [cs:setdevmarkflag],for_devmark ; 2
	call	DevSetBreak		;go ahead and alloc mem for device
jc_edd:
	jc	short erase_dev_do	;device driver's init routine failed.

	; 12/12/2022
	test	al,ISCIN
	;test	ax,ISCIN ; 1		;is it a console in?
	jz	short tryclk

	mov	[es:di+SYSI_CON],dx   ; es:di+12
	mov	[es:di+SYSI_CON+2],ds ; es:di+14
tryclk: 
	; 12/12/2022
	test	al,ISCLOCK
	;test	ax,ISCLOCK ; 8		;is it a clock device?
	jz	short golink

	mov	[es:di+SYSI_CLOCK],dx	; es:di+8
	mov	[es:di+SYSI_CLOCK+2],ds ; es:di+10
golink: 
	jmp	linkit

;------ deal with block device drivers

isblock:
	mov	al,[cs:unitcount]	;if no units found,erase the device
	or	al,al
	jz	short erase_dev_do
	;mov	[si+10],al
	mov	[si+SYSDEV.NAME],al	; number of units in name field
	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;add	[cs:driver_units],al
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	add	[cs:driver_units],al	; keep total for all drivers in file
perdrv:
	cbw				; warning no device > 127 units
	mov	cx,ax
	mov	dh,ah
	;mov	dl,[es:di+32]
	mov	dl,[es:di+SYSI_NUMIO]	;get number of devices
	mov	ah,dl
	add	ah,al			; check for too many devices
	cmp	ah,26			; 'A' - 'Z' is 26 devices
	jbe	short ok_block
	jmp	badnumblock

ok_block:
	or	byte [cs:setdevmarkflag],for_devmark ; 2
	call	DevSetBreak		; alloc the device
	jc	short jc_edd
	add	[es:di+SYSI_NUMIO],al	; update the amount

	add	[cs:drivenumber],al	; remember amount for next device
	lds	bx,[cs:bpb_addr]	; point to bpb array
perunit:
	les	bp,[cs:DOSINFO]
	;les	bp,[es:bp+SYSI_DPB]	; get first dpb
	; 11/12/2022
	les	bp,[es:bp]
	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;les	bp,[es:bp+0]		; [es:bp+SYSI_DPB]
scandpb:
	;cmp	word [es:bp+25],-1
	cmp	word [es:bp+DPB.NEXT_DPB],-1
	je	short foundpb
	;les	bp,[es:bp+25]
	les	bp,[es:bp+DPB.NEXT_DPB]
	jmp	short scandpb
foundpb:
	mov	ax,[cs:DevBrkAddr]
	mov	[es:bp+DPB.NEXT_DPB],ax
	mov	ax,[cs:DevBrkAddr+2]
	mov	[es:bp+DPB.NEXT_DPB+2],ax

	les	bp,[cs:DevBrkAddr]
	add	word [cs:DevBrkAddr],DPBSIZ ; 33

	call	RoundBreakAddr

	mov	word [es:bp+DPB.NEXT_DPB],-1
	mov	byte [es:bp+DPB.FIRST_ACCESS],-1

	mov	si,[bx] 		;ds:si points to bpb
	inc	bx
	inc	bx			;point to next guy
	;mov	[es:bp+DPB.DRIVE],dx
	; 11/12/2022
	mov	[es:bp],dx ; 13/05/2019
	; 29/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	[es:bp+0],dx		; [es:bp+DPB.DRIVE]
	
	mov	ah,SETDPB ; 53h		;hidden system call
	int	21h
			; DOS - 2+ internal - TRANSLATE BIOS PARAMETER BLOCK
			; DS:SI -> BPB (BIOS Parameter Block)
			; ES:BP -> buffer for DOS Drive Parameter Block

	;mov	ax,[es:bp+2]
	mov	ax,[es:bp+DPB.SECTOR_SIZE]
	push	es
	les	di,[cs:DOSINFO] 	;es:di point to dos info
	;cmp	ax,[es:di+10h]
	cmp	ax,[es:di+SYSI_MAXSEC]
	pop	es
	;jna	short iblk_1
	;jmp	short bad_bpb_size_sector
	; 29/10/2022
	ja	short bad_bpb_size_sector
iblk_1:
	push	ds
	push	dx

	lds	dx,[cs:DevEntry]
	;mov	[es:bp+13h],dx
	mov	[es:bp+DPB.DRIVER_ADDR],dx
	;mov	[es:bp+15h],ds
	mov	[es:bp+DPB.DRIVER_ADDR+2],ds

	pop	dx
	pop	ds

	inc	dx
	inc	dh
	loop	perunit

	push	cs
	pop	ds

	call	TempCDS 		; set cds for new drives
	; 31/12/2022
	; ds <> cs
linkit:
	les	di,[cs:DOSINFO] 	;es:di = dos table
	mov	cx,[es:di+SYSI_DEV]	;dx:cx = head of list
	mov	dx,[es:di+SYSI_DEV+2]

	lds	si,[cs:DevEntry]	;ds:si = device location
	mov	[es:di+SYSI_DEV],si	;set head of list in dos
	mov	[es:di+SYSI_DEV+2],ds
	mov	ax,[si]			;get pointer to next device
	mov	[cs:DevEntry],ax	;and save it

	mov	[si],cx			;link in the driver
	mov	[si+2],dx
enddev:
	pop	si
	pop	es
	inc	ax			;ax = ffff (no more devs if yes)?
	jz	short coffj3

	inc	byte [cs:multdeviceflag] ; possibly multiple device driver.
	call	DevBreak		; M009
	; 11/12/2022
	; ds = cs (DevBreak)

	; 03/04/2019 - Retro DOS v4.0
	; MSDOS 6.21 IO.SYS - SYSINIT:290Dh
	jmp	goodld			; otherwise pretend we loaded it in
coffj3: 
	; 18/12/2022
	; ax = 0
	mov	[cs:multdeviceflag],al ; 0
	;mov	byte [cs:multdeviceflag],0 ; reset the flag
	call	DevBreak
	; 11/12/2022
	; ds = cs (DevBreak)
	
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2919h)
	;call	CheckProtmanArena
	; 02/11/2022 (MSDOS 5.0 IO.SYS compatibility)
	;;call	CheckProtmanArena	; adjust alloclim if Protman$ just
;					;  created a bogus arena to try
;					;  to protect some of its resident-
;					;  init code.
	;call	CheckDoubleSpace
	jmp	coff

;----------------------------------------------------------------------------

;CheckDoubleSpace:
;;;;	ifdef	dblspace_hooks
;
;;	Now check for two special MagicDrv cases:
;;
;;       a) the last driver load was MagicDrv final placement:
;;	   -> add number of MagicDrv reserved drives to drivenumber
;;
;;       b) MagicDrv is currently in temporary home:
;;          -> call it to give it a chance to mount and shuffle drives
;
;	cmp	byte [cs:MagicHomeFlag],0 ; already home?
;	jnz	short no_more_magic_calls ;  nothing more to do if so
;
;;	Now inquire of driver whether it is present, and final located
;
;	mov	ax,multMagicdrv ; 4A11h
;	mov	bx,MD_VERSION ; 0
;	int	2fh			; ch = number of MagicDrv drive letters
;	or	ax,ax			; is it there?
;	jnz	short no_more_magic_calls ; done if not
;
;	test	dx,8000h		; is it final placed?
;	jnz	short magic_not_yet_home ;  skip if not
;
;;	Okay, now the driver is final placed!  Set the flag so we
;;	don't keep checking it, and add its number of drive letters
;;	to drivenumber.
;
;	mov	byte [cs:MagicHomeFlag],0ffh ; set the flag!
;	add	[cs:drivenumber],ch	; add number of MagicDrv volumes to
;;					;  the drive number we'll pass to the
;;					;  next loadable block device.
;
;	jmp	short no_more_magic_calls ; and finished.
;
;magic_not_yet_home:
;	push	es
;	push	si
;
;	mov	cx,[cs:memhi]		; pass it a work buffer
;	mov	dx,[cs:ALLOCLIM]	;   address in cx (segment)
;	sub	dx,cx			;   for len dx (paragraphs)
;
;	mov	bx,2
;	mov	al,[cs:driver_units]	; shuffle magicdrives and new drives
;;					;   by this many units
;
;;BUGBUG 29-Oct-1992 bens Take this 55h out after Beta 4
;	mov	ah,55h			; backdoor won't shuffle unless it
;;					;  sees this, to prevent bad things
;;					;  from happening if people run the
;;					;  new driver with an old BIOS
;	call	far [cs:MagicBackdoor]
;
;	pop	si
;	pop	es
;
;no_more_magic_calls:
;
;;;;	endif
;	retn

; 03/04/2019 - Retro DOS v4.0

bad_bpb_size_sector:
	pop	si
	pop	es
	mov	dx,badsiz_pre
	mov	bx,crlfm
	call	prnerr

	jmp	coff

;------------------------------------------------------------------------------
; country command
;      the syntax is:
;	country=country id {,codepage {,path}}
;	country=country id {,,path}	:default codepage id in dos
;------------------------------------------------------------------------------

	; 30/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2663h)
tryq:
        cmp     ah,CONFIG_COUNTRY ; 'Q'
	je	short tryq_cont
skip_it3:
	jmp	tryf
tryq_cont:

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:297Eh)
; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user		; query the user if config_cmd
	jc	short skip_it3		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 02/11/2022

	; 31/12/2022
	;xor	bx,bx
	xor	cx,cx
	; 14/12/2022
	; ds = cs
	; bx = 0
	;mov	byte [cs:cntry_drv],0	; reset the drive,path to default value.
	;mov	word [cs:p_code_page],0
	; 31/12/2022
	; cx = 0
	;mov	[cntry_drv],bl ; 0
	;mov	[p_code_page],bx ; 0
	mov	[cntry_drv],cl ; 0
	mov	[p_code_page],cx ; 0	

	mov	di,cntry_parms
	;xor	cx,cx	; 31/12/2022
	; 03/01/2023
	;mov	dx,cx
do52:
	call	sysinit_parse
	jnc	short if52		; parse error,check error code and

	call	cntry_error		; show message and end the search loop.
	; 14/12/2022
	; ds = cs
	mov	word [p_cntry_code],-1
	;mov	word [cs:p_cntry_code],-1 ; signals that parse error.
	jmp	short sr52
if52:
	cmp	ax,_$P_RC_EOL ; 0FFFFh	; end of line?
	jz	short sr52		; then end the search loop

	;cmp	byte [cs:result_val+_$P_Result_Blk.Type],_$P_number ; numeric?
	; 14/12/2022
	; ds = cs
	cmp	byte [result_val],_$P_Number	
	;cmp	byte [cs:result_val],_$P_Number
	jnz	short if56

	;;mov	ax,[cs:rw_dword]
	;mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
	; 14/12/2022
	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]
	cmp	cx,1
	jne	short if57

	;mov	[cs:p_cntry_code],ax
	; 14/12/2022
	mov	[p_cntry_code],ax

	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short en57
	; 12/12/2022
	;jmp	short en56
	jmp	short do52
if57:
	;mov	[cs:p_code_page],ax
	; 14/12/2022
	; ds = cs
	mov	[p_code_page],ax
en57:
	;jmp	short en56		; path entered
	; 12/12/2022
	jmp	short do52
if56:
	push	ds
	push	es
	push	si
	push	di

	push	cs
	pop	es

	;lds	si,[cs:rv_dword]	; move the path to known place.
	; 14/12/2022
	lds	si,[rv_dword]
	mov	di,cntry_drv
	call	move_asciiz

	pop	di
	pop	si
	pop	es
	pop	ds

en56:
	jmp	short do52

sr52:
	; 14/12/2022
	; ds = cs
	cmp	word [p_cntry_code],-1
	;cmp	word [cs:p_cntry_code],-1	; had a parse error?
	jne	short tryq_open
	jmp	coff

tryqbad:				;"invalid country code or code page"
	stc
	mov     dx,badcountry
	jmp     tryqchkerr

tryq_open:
	; 14/12/2022
	; ds = cs
	cmp	byte [cntry_drv],0
	;cmp	byte [cs:cntry_drv],0
	je	short tryq_def
	mov	dx,cntry_drv
	jmp	short tryq_openit

tryq_def:
	mov	dx,cntry_root
tryq_openit:
	mov	ax,3D00h		;open a file
	stc
	int	21h
	jc	short tryqfilebad	;open failure

	; 14/12/2022
	; ds = cs
	mov	[cntryfilehandle],ax
	;mov	[cs:cntryfilehandle],ax	;save file handle
	mov	bx,ax
	mov	ax,[p_cntry_code]
	mov	dx,[p_code_page]
	;mov	ax,[cs:p_cntry_code]
	;mov	dx,[cs:p_code_page]	;now,ax=country id,bx=filehandle
	;mov	cx,[cs:memhi]
	mov	cx,[memhi]
	add	cx,384			;need 6k buffer to handle country.sys
					;M023
	; 14/12/2022
	; ds = cs
	cmp	cx,[ALLOCLIM]
	;cmp	cx,[cs:ALLOCLIM]
	ja	short tryqmemory	;cannot allocate the buffer for country.sys

	mov	si,cntry_drv		;ds:si -> cntry_drv
	cmp	byte [si],0 		;default path?
	jne	short tryq_set_for_dos

	inc	si
	inc	si			;ds:si -> cntry_root

tryq_set_for_dos:
	; 14/12/2022
	; ds = cs
	les	di,[sysi_country]
	;les	di,[cs:sysi_country]	;es:di -> country info tab in dos
	push	di			;save di
	;add	di,8
	add	di,country_cdpg_info.ccPath_CountrySys ; 8
	call	move_asciiz		;set the path to country.sys in dos.
	pop	di			;es:di -> country info tab again.

	; 14/12/2022	
	mov	cx,[memhi]
	;mov	cx,[cs:memhi]
	mov	ds,cx
	xor	si,si			;ds:si -> 2k buffer to be used.
	call	setdoscountryinfo	;now do the job!!!
	; ds <> cs ; 14/12/2022
	jnc	short tryqchkerr	;read error or could not find country,code page combination

	cmp	cx,-1			;could not find matching country_id,code page?
	je	short tryqbad 		;then "invalid country code or code page"

tryqfilebad:
	push	cs
	pop	es
	cmp	byte [cs:cntry_drv],0	;is the default file used?
	je	short tryqdefbad

	mov	si,cntry_drv
	jmp	short tryqbadload

tryqdefbad:				;default file has been used.
	mov	si,cntry_root		;es:si -> \country.sys in sysinit_seg
tryqbadload:
	call	badload 		;ds will be restored to sysinit_seg
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2A69h)
	mov	cx,[CONFBOT] ; ds = cs (from badload)
	;mov	cx,[cs:CONFBOT]
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	cx,[cs:top_of_cdss]
	; 11/12/2022
	; ds = cs
	;mov	cx,[top_of_cdss]  ; mov cx,[CONFBOT]	
	mov	es,cx			;restore es -> confbot.
	jmp	short coffj4

tryqmemory:
	mov	dx,insufmemory
tryqchkerr:
	;mov	cx,[cs:CONFBOT]
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	cx,[cs:top_of_cdss]
	; 12/12/2022
	push	cs
	pop	ds
	; 31/12/2022 - Retro DOS v4.2
	mov	cx,[CONFBOT] ; (MSDOS 6.21 IO.SYS, SYSINIT)
	;mov	cx,[top_of_cdss]  ; mov cx,[CONFBOT]
	mov	es,cx			;restore es -> confbot seg
	;push	cs
	;pop	ds			;restore ds to sysinit_seg
	jnc	short coffj4		;if no error,then exit

	call	print			;else show error message
	call	error_line
coffj4:
	;mov	bx,[cs:cntryfilehandle]
	; 11/12/2022
	; ds = cs
	mov	bx,[cntryfilehandle]
	mov	ah,3Eh
	int	21h			;close a file. don't care even if it fails.
	jmp	coff

;--------------------------------------------

cntry_error:

;function: show "invalid country code or code page" messages,or
;		"error in country command" depending on the error code
;		in ax returned by sysparse;
;in:	ax - error code
;	ds - sysinitseg
;	es - confbot
;out:	show message.  dx destroyed.

	cmp	ax,_$P_Out_Of_Range ; 6
	jne	short if64
	mov	dx,badcountry		;"invalid country code or code page"
	jmp	short en64
if64:
	mov	dx,badcountrycom	;"error in contry command"
en64:
	call	print
	;call	error_line
	;retn
	; 11/12/2022
	jmp	error_line

;------------------------------------------------------------------------------
; files command
;------------------------------------------------------------------------------

;******************************************************************************
; function: parse the parameters of files= command.			      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	variable files set.						      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to files_parms;					      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	     files = result_val._$P_picked_val				      *
;	  else								      *
;	     error exit;						      *
;	};								      *
; };									      *
;									      *
;******************************************************************************

tryf:
        cmp     ah,CONFIG_FILES ;  'F'
	jne	short tryl

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2AABh)
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short tryl		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 30/10/2022

	; 14/12/2022
	; ds = cs

	mov	di,files_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do67:
	call	sysinit_parse
	jnc	short if67		; parse error
	;call	badparm_p		;  and show messages and end the search loop.
	;jmp	short sr67
	; 03/01/2023
	jmp	badparm_p_coff
if67:
	cmp	ax,_$P_RC_EOL		; end of line?
	je	short en67		; then end the $endloop

	; 14/12/2022
	; ds = cs
	;;mov	al,[cs:rv_dword]
	;mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
	;mov	[cs:p_files],al		; save it temporarily
	;mov	al,[rv_dword]
	mov	al,[result_val+_$P_Result_Blk.Picked_Val]
	mov	[p_files],al

	jmp	short do67
en67:
	; 14/12/2022
	; ds = cs
	mov	al,[p_files]
	mov	[FILES],al	
	;mov	al,[cs:p_files]
	;mov	[cs:FILES],al		; no error. really set the value now.
sr67:
	jmp	coff

; 04/04/2019 - Retro DOS v4.0

;------------------------------------------------------------------------------
; lastdrive command
;------------------------------------------------------------------------------

;******************************************************************************
; function: parse the parameters of lastdrive= command. 		      *
;									      *
; input :								      *
;	es:si -> parameters in command line.				      *
; output:								      *
;	set the variable num_cds.					      *
;									      *
; subroutines to be called:						      *
;	sysinit_parse							      *
; logic:								      *
; {									      *
;	set di points to ldrv_parms;					      *
;	set dx,cx to 0; 						      *
;	while (end of command line)					      *
;	{ sysinit_parse;						      *
;	  if (no error) then						      *
;	     set num_cds to the returned value; 			      *
;	  else	/*error exit*/						      *
;	     error exit;						      *
;	};								      *
; };									      *
;									      *
;******************************************************************************

tryl:
        cmp     ah,CONFIG_LASTDRIVE ; 'L'
	jne	short tryp

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2AE0h)
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
	call	query_user      ; query the user if config_cmd
	jc	short tryp	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 30/10/2022

	; 14/12/2022
	; ds = cs

	mov	di,ldrv_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do73:
	call	sysinit_parse
	jnc	short if73	; parse error
	;call	badparm_p	;  and show messages and end the search loop.
	;jmp	short sr73
	; 03/01/2023
	jmp	badparm_p_coff
if73:
	cmp	ax,_$P_RC_EOL	; end of line?
	je	short en73	; then end the $endloop

	; 14/12/2022
	; ds = cs
	;;mov	al,[cs:rv_dword]
	;mov	al,[cs:rv_byte]	; pick up the drive number
	;mov	[cs:p_ldrv],al	; save it temporarily

	;mov	al,[rv_dword]
	mov	al,[rv_byte]
	mov	[p_ldrv],al

	jmp	short do73
en73:
	; 14/12/2022
	; ds = cs
	mov	al,[p_ldrv]
	mov	[NUM_CDS],al
	;mov	al,[cs:p_ldrv]
	;mov	[cs:NUM_CDS],al	; no error. really set the value now.
sr73:
	jmp	coff

;--------------------------------------------------------------------------
; setting drive parameters
;--------------------------------------------------------------------------

tryp:
        cmp     ah,CONFIG_DRIVPARM ; 'P'
	jne	short tryk

; 31/12/2022 - Retro DOS v4.2
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user      ; query the user if config_cmd
	jc	short tryk	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 30/10/2022

	call	parseline
	jc	short trypbad
	call	setparms
	call	diddleback

; No error check here, because setparms and diddleback have no error 
; returns, and setparms as coded now can return with carry set. 
;       jc	short trypbad

	; 12/12/2022
	; cf = 0
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jc	short trypbad
	
	jmp	coff
trypbad:
	jmp	badop

;--------------------------------------------------------------------------
; setting internal stack parameters
; stacks=m,n where
;	m is the number of stacks (range 8 to 64,default 9)
;	n is the stack size (range 32 to 512 bytes,default 128)
; j.k. 5/5/86: stacks=0,0 implies no stack installation.
;	any combinations that are not within the specified limits will
;	result in "unrecognized command" error.
;--------------------------------------------------------------------------

;**************************************************************************
;									  *
; function: parse the parameters of stacks= command.			  *
;	    the minimum value for "number of stacks" and "stack size" is  *
;	    8 and 32 each.  in the definition of sysparse value list,they *
;	    are set to 0.  this is for accepting the exceptional case of  *
;	    stacks=0,0 case (,which means do not install the stack.)	  *
;	    so,after sysparse is done,we have to check if the entered	  *
;	    values (stack_count,stack_size) are within the actual range,  *
;	    (or if "0,0" pair has been entered.)			  *
; input :								  *
;	es:si -> parameters in command line.				  *
; output:								  *
;	set the variables stack_count,stack_size.			  *
;									  *
; subroutines to be called:						  *
;	sysinit_parse							  *
; logic:								  *
; {									  *
;	set di points to stks_parms;					  *
;	set dx,cx to 0; 						  *
;	while (end of command line)					  *
;	{ sysinit_parse;						  *
;	  if (no error) then						  *
;	     { if (cx == 1) then /* first positional = stack count */	  *
;		   p_stack_count = result_val._$P_picked_val;		  *
;	       if (cx == 2) then /* second positional = stack size */	  *
;		   p_stack_size = result_val._$P_picked_val;		  *
;	     }								  *
;	  else	/*error exit*/						  *
;	     error exit;						  *
;	};								  *
;	here check p_stack_count,p_stack_size if it meets the condition;  *
;	if o.k.,then set stack_count,stack_size;			  *
;	 else error_exit;						  *
; };									  *
;**************************************************************************

tryk:
        ;if      stacksw

        cmp     ah,CONFIG_STACKS ; 'K'
	je	short do_tryk
skip_it4:
	jmp	short trys	; 15/12/2022
do_tryk:

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2B33h)
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
       call	query_user              ; query the user if config_cmd
       jc	short skip_it4		; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif	; 30/10/2022

	; 14/12/2022
	; ds = cs

	mov	di,stks_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do79:
	call	sysinit_parse
	jnc	short if79		; parse error

	mov	dx,badstack		; "invalid stack parameter"
	call	print			;  and show messages and end the search loop.
	call	error_line
	;jmp	sr79
	; 11/12/2022
	jmp	short sr79
if79:
	cmp	ax,_$P_RC_EOL		; end of line?
	je	short en79		; then end the $endloop

	; 14/12/2022
	; ds = cs

	;;mov	ax,[cs:rv_dword]
	;mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
	;mov	ax,[rv_dword]
	mov	ax,[result_val+_$P_Result_Blk.Picked_Val]

	cmp	cx,1
	jne	short if83

	; 14/12/2022
	;mov	[cs:p_stack_count],ax
	;jmp	short en83
	mov	[p_stack_count],ax
	jmp	short do79
if83:
	; 14/12/2022
	;mov	[cs:p_stack_size],ax
	mov	[p_stack_size],ax
en83:
	jmp	short do79
en79:
	; 14/12/2022
	; ds = cs
	mov	ax,[p_stack_count]
	or	ax,ax
	jz	short if87		

	; 14/12/2022
	;cmp	word [p_stack_count],0
	;;cmp	word [cs:p_stack_count],0
	;je	short if87

	; 14/12/2022
	cmp	ax, mincount ; 8
	;cmp	word [cs:p_stack_count],mincount ; 8
	; 15/12/2022
	jb	short en87
	cmp	word [p_stack_size],minsize ; 32
	;cmp	word [cs:p_stack_size],minsize ; 32
	; 15/12/2022
	jb	short en87
if94:
	; 14/12/2022
	; ds = cs
	; ax = [p_stack_count]
	;mov	ax,[p_stack_count]
	;;mov	ax,[cs:p_stack_count]
	mov	[stack_count],ax
	;mov	[cs:stack_count],ax
	;mov	ax,[cs:p_stack_size]
	mov	ax,[p_stack_size]
	;mov	[cs:stack_size],ax
	mov	[stack_size],ax
	;mov	word [cs:stack_addr],-1	; stacks= been accepted.
	mov	word [stack_addr],-1
sr79:
	jmp	coff

if87:
	; 14/12/2022
	cmp	[p_stack_size],ax ; 0
	je	short if94 ; ax = [p_stack_count] = 0
	;cmp	word [cs:p_stack_size],0
	;je	short if94
en87:
	; 15/12/2022
	; ([p_stack_count] is invalid, use default values)
	; 14/12/2022
	; ds = cs
	mov	word [stack_count],defaultcount ; 9
	mov	word [stack_size],defaultsize ; 128
	mov	word [stack_addr],0
	;mov	word [cs:stack_count],defaultcount ; 9
	;				; reset to default value.
	;mov	word [cs:stack_size],defaultsize ; 128
	;mov	word [cs:stack_addr],0

	mov	dx,badstack
	call	print
	call	error_line
	jmp	short sr79

; 15/12/2022
%if 0
	mov	di,stks_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do79:
	call	sysinit_parse
	jnc	short if79		; parse error

	mov	dx,badstack		; "invalid stack parameter"
	call	print			;  and show messages and end the search loop.
	call	error_line
	;jmp	sr79
	; 11/12/2022
	jmp	short sr79
if79:
	cmp	ax,_$P_RC_EOL		; end of line?
	je	short en79		; then end the $endloop

	;mov	ax,[cs:rv_dword]
	mov	ax,[cs:result_val+_$P_Result_Blk.Picked_Val]
	cmp	cx,1
	jne	short if83

	mov	[cs:p_stack_count],ax
	jmp	short en83
if83:
	mov	[cs:p_stack_size],ax
en83:
	jmp	short do79
en79:
	cmp	word [cs:p_stack_count],0
	je	short if87

	cmp	word [cs:p_stack_count],mincount ; 8
	jb	short ll88
	cmp	word [cs:p_stack_size],minsize ; 32
	jnb	short if88
ll88:
	mov	word [cs:p_stack_count],-1 ; invalid
if88:
	jmp	short en87

	; 11/12/2022
if94:
	mov	ax,[cs:p_stack_count]
	mov	[cs:stack_count],ax
	mov	ax,[cs:p_stack_size]
	mov	[cs:stack_size],ax
	mov	word [cs:stack_addr],-1	; stacks= been accepted.
sr79:
	jmp	coff

if87:
	cmp	word [cs:p_stack_size],0
	je	short en87
	mov	word [cs:p_stack_count],-1 ; invalid
en87:
	cmp	word [cs:p_stack_count],-1 ; invalid?
	jne	short if94

	mov	word [cs:stack_count],defaultcount ; 9
					; reset to default value.
	mov	word [cs:stack_size],defaultsize ; 128
	mov	word [cs:stack_addr],0

	mov	dx,badstack
	call	print
	call	error_line
	jmp	short sr79

%endif

; 11/12/2022
%if 0 

if94:
	mov	ax,[cs:p_stack_count]
	mov	[cs:stack_count],ax
	mov	ax,[cs:p_stack_size]
	mov	[cs:stack_size],ax
	mov	word [cs:stack_addr],-1	; stacks= been accepted.
sr79:
	jmp	coff

%endif

	;endif

;------------------------------------------------------------------------
; shell command
;------------------------------------------------------------------------

trys:
        cmp     ah,CONFIG_SHELL ; 'S'
	jne	short tryx

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2BE1h)
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user              ; query the user if config_cmd
	jc	short tryx		; has the CONFIG_OPTION_QUERY bit set
	mov	byte [cs:newcmd],1
;endif
;%endif ; 30/10/2022

	;;mov	word [cs:command_line],0 ; zap length,first byte of command-line
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	byte [cs:command_line+1],0
	; 15/12/2022
	; ds = cs
	mov	byte [command_line+1],0

        mov     di,commnd+1		; we already have the first char
        mov     [di-1],al               ; of the new shell in AL, save it now
storeshell:
	call	getchr
        or      al,al                   ; this is the normal case: "organize"
        jz	short getshparms	; put a ZERO right after the filename

        cmp     al," "                  ; this may happen if there are no args
        jb	short endofshell	; I suppose...
	mov	[di],al
	inc	di
        ;cmp    di,commnd+63		; this makes sure we don't overflow
        ;jb	short storeshell	; commnd (the filename)
        ;jmp	short endofshell
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short storeshell
	; 03/01/2023
	cmp	di,commnd+63		; this makes sure we don't overflow
        jb	short storeshell	; commnd (the filename)
	;jmp	short endofshell

; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;getshparms:
;	mov     byte [di],0		; zero-terminate the filename
;	mov     di,command_line+1	; prepare to process the command-line
;
;parmloop:
;	call	getchr
;	cmp	al," "
;	jb	short endofparms
;	mov	[di],al
;	inc	di
;	cmp     di,command_line+126
;	jb	short parmloop
;endofparms:
;	mov     cx,di
;	sub     cx,command_line+1
;	mov     [cs:command_line],cl
;
;endofshell:
;	mov     byte [di],0		; zero-terminate the filename (or
;					; the command-line as the case may be)
;skipline:
;       cmp     al,lf	; 0Ah		; the safest way to eat the rest of
;       je	short endofline		; the line: watch for ever-present LF
;call	getchr
;       jnc	short skipline		; keep it up as long as there are chars
;
;endofline:
;       jmp     conflp

	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
endofshell:
     	mov     byte [di],0		; zero-terminate the filename (or
					; the command-line as the case may be)
	call	getchr
skipline:
	cmp     al,lf	; 0Ah		; the safest way to eat the rest of
	je	short endofline		; the line: watch for ever-present LF
	call	getchr
	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.1 IO.SYS)
	; (SYSINIT:2C3Ah)
	jnb	short skipline
	
endofline:
	jmp     conflp

	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
getshparms:
	; 18/12/2022
	; al = 0
	mov	[di],al ; 0
	;mov	byte [di],0		; zero-terminate the filename
	mov     di,command_line+1	; prepare to process the command-line
parmloop:
	call	getchr
	cmp	al," " ; 20h
	;jb	short endofshell
	; 03/01/2023
	jb	short endofparms

	mov	[di],al
	inc	di
	;jmp	short parmloop
	; 03/01/2023 - Retro DOS v4.2
	cmp     di,command_line+126
	jb	short parmloop

	; 03/01/2023 - Retro DOS v4.2
endofparms:
	mov	cx,di
	sub	cx,command_line+1
	;mov	[cs:command_line],cl
	; 03/01/2023
	mov	[command_line],cl
	jmp	short endofshell

;------------------------------------------------------------------------
; fcbs command
;------------------------------------------------------------------------

;************************************************************************
; function: parse the parameters of fcbs= command.			*
;									*
; input :								*
;	es:si -> parameters in command line.				*
; output:								*
;	set the variables fcbs,keep.					*
;									*
; subroutines to be called:						*
;	sysinit_parse							*
; logic:								*
; {									*
;	set di points to fcbs_parms;					*
;	set dx,cx to 0; 						*
;	while (end of command line)					*
;	{ sysparse;							*
;	  if (no error) then						*
;	     { if (cx == 1) then /* first positional = fcbs */		*
;		   fcbs = result_val._$P_picked_val;			*
;	       if (cx == 2) then /* second positional = keep */ 	*
;		   keep = result_val._$P_picked_val;			*
;	     }								*
;	  else	/*error exit*/						*
;	     error exit;						*
;	};								*
; };									*
;************************************************************************

tryx:
        cmp     ah,CONFIG_FCBS  ; 'X'
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	jne	short try1
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jne	short tryy	; comment command

; 31/12/2022 - Retro DOS v4.2
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user      ; query the user if config_cmd
	jc	short try1	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 30/10/2022

	mov	di,fcbs_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do98:
	call	sysinit_parse
        ; 03/01/2023
	;jnc	short if98	; parse error
        ;call	badparm_p	;  and show messages and end the search loop.
	;jmp	short sr98
	;------------------------
	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	jc	short badparm_p_coff
if98:
	cmp	ax,_$P_RC_EOL	; end of line?
	je	short en98	; then end the $endloop

	;;mov	al,[cs:rv_dword]
	;mov	al,[cs:result_val+_$P_Result_Blk.Picked_Val]
	; 15/12/2022
	; ds = cs
	mov	al,[result_val+_$P_Result_Blk.Picked_Val]
	cmp	cx,1		; the first positional?
	jne	short if102
	;mov	[cs:p_fcbs],al
	; 15/12/2022
	mov	[p_fcbs],al
	;jmp	short en102
	jmp	short do98
if102:
	;mov	[cs:p_keep],al
	; 15/12/2022
	mov	[p_keep],al
en102:
	jmp	short do98
en98:
	; 15/12/2022
	; ds = cs
	mov	al,[p_fcbs]
	mov	[FCBS],al
	mov	byte [KEEP],0
	;mov	al,[cs:p_fcbs]	 ; M017
	;mov	[cs:FCBS],al	 ; M017
	;mov	byte [cs:KEEP],0 ; M017
sr98:
	jmp	coff

; 31/12/2022 - Retro DOS v4.2
%if 0

; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;-------------------------------------------------------------------------
; comment= do nothing. just decrease chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

tryy:
	cmp     ah,CONFIG_COMMENT ; 'Y'
	jne	short try0

donothing:
	; 15/12/2022
	; ds = cs
	dec	word [chrptr]
	inc	word [count]
	; 02/11/2022
	;dec	word [cs:chrptr]
	;inc	word [cs:count]

	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				; do nothing with this line.
	cmp     ah,CONFIG_REM ; '0'
	je	short donothing

%endif

; 07/04/2019 - Retro DOS v4.0

;-----------------------------------------------------------------------
; switches command
;-----------------------------------------------------------------------

;***********************************************************************
;								       *
; function: parse the option switches specified.		       *
; note - this command is intended for the future use also.	       *
; when we need to set system data flag,use this command.	       *
;								       *
; input :							       *
;	es:si -> parameters in command line.			       *
; output:							       *
;	p_swit_k set if /k option chosen.			       *
;								       *
; subroutines to be called:					       *
;	sysinit_parse						       *
; logic:							       *
; {								       *
;	set di points to swit_parms;  /*parse control definition*/     *
;	set dx,cx to 0; 					       *
;	while (end of command line)				       *
;	{ sysinit_parse;					       *
;	  if (no error) then					       *
;	       if (result_val._$P_synonym_ptr == swit_k) then	       *
;		    p_swit_k = 1				       *
;	       endif						       *
;	  else {show error message;error exit}			       *
;	};							       *
; };								       *
;								       *
;***********************************************************************

SUPPRESS_WINA20	EQU 00000010b	; M025 ; (DOSSYM.INC, MSDOS 6.0)

try1:
        cmp     ah,CONFIG_SWITCHES ; '1'
	je	short do_try1	; switches= command entered?
skip_it5:
	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2C8Ah)
	jmp	tryv
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	tryz

do_try1:

; 31/12/2022 - Retro DOS v4.2
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;ifdef	MULTI_CONFIG
	call	query_user      ; query the user if config_cmd
	jc	short skip_it5	; has the CONFIG_OPTION_QUERY bit set
;endif
;%endif ; 30/10/2022

	mov	di,swit_parms
	xor	cx,cx
	; 03/01/2023
	;mov	dx,cx
do110:
	call	sysinit_parse
	jnc	short if110	; parse error
	;call	badparm_p	;  and show messages and end the search loop.
	;jmp	short sr110
	; -----------------------
	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
badparm_p_coff:
	call	badparm_p
	jmp	coff
	;------------------------
if110:
	cmp	ax,_$P_RC_EOL	; end of line?
	je	short en110	; then jmp to $endloop for semantic check

	; 15/12/2022
	; ds = cs
	;;cmp	word [cs:result_val_swoff],swit_k
	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_k 
	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_k 
	jne	short if115	;				;M059
	; 15/12/2022
	mov	byte [p_swit_k],1
	;mov	byte [cs:p_swit_k],1	; set the flag
	jmp	short do110
if115:	
	; 15/12/2022							;M059
	;;cmp	word [cs:result_val_swoff],swit_t
	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_t	;M059
	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_t
	jne	short if116					;M059 M063
	; 15/12/2022
	mov	byte [p_swit_t],1
	;mov	byte [cs:p_swit_t],1				;M059
	jmp	short do110					;M059
if116:
	; 15/12/2022
	;;cmp	word [cs:result_val_swoff],swit_w
	;cmp	word [cs:result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_w	;M063
	cmp	word [result_val+_$P_Result_Blk.SYNONYM_Ptr],swit_w
	jne	short do110					;M063
	; 15/12/2022
	mov	byte [p_swit_w],1
	;mov	byte [cs:p_swit_w],1				;M063
	jmp	short do110					;M063
en110:
	; 15/12/2022
	; ds = cs
	cmp	byte [p_swit_k],1
	;cmp	byte [cs:p_swit_k],1	; if /k entered,
	push	ds
	;;mov	ax,Bios_Data
	;mov	ax,KERNEL_SEGMENT ; 0070h
	; 21/10/2022
	mov	ax,DOSBIODATASEG ; 0070h
	mov	ds,ax
	jne	short if117
	mov	byte [keyrd_func],0 ; 4E5h ; use the conventional keyboard functions
	mov	byte [keysts_func],1 ; 4E6h (for MSDOS 6.21 IO.SYS)
if117:
	; 15/12/2022
	; ds <> cs
	mov	al,[cs:p_swit_t]				;M059
	mov	[t_switch],al	; 4F2h (for MSDOS 6.21 IO.SYS)	;M059

	cmp	byte [cs:p_swit_w],0				;M063
	je	short skip_dos_flag				;M063
	push	es
	push	bx
	mov	ah,GET_IN_VARS ; 52h				;M063
	int	21h						;M063
			; DOS - 2+ internal - GET LIST OF LISTS
			; Return: ES:BX -> DOS list of lists
	;or	bytes [es:86h],2
	or	byte [es:DOS_FLAG_OFFSET],SUPPRESS_WINA20 ; 2	;M063
	pop	bx
	pop	es
skip_dos_flag:							;M063
	pop	ds
sr110:
	jmp	coff

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2D14h)
; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

tryv:

;ifdef	MULTI_CONFIG
;------------------------------------------------------------------------
; set command (as in "set var=value<cr/lf>")
;------------------------------------------------------------------------

	cmp	ah,CONFIG_SET  ; 'V'
	jne	short tryn
	call	query_user      ; query the user if config_cmd
	jc	short tryn 	; has the CONFIG_OPTION_QUERY bit set
	call	copy_envvar     ; copy var at ES:SI to "config_wrkseg"
	jnc	short sr110	; no error
err:    
	call	error_line      ; whoops, display error in line XXX
	jmp	short sr110     ; jump to coff (to skip to next line)

;------------------------------------------------------------------------
; numlock command (as in "numlock=on|off")
;------------------------------------------------------------------------
tryn:
	cmp	ah,CONFIG_NUMLOCK  ;'N'
	jne	short tryy            ;
	call	query_user      ; query thye user if config_cmd
	jc	short tryy	; has the CONFIG_OPTION_QUERY bit set
	call	set_numlock
	jc	short err
	jmp	short sr110	; all done

;endif	;MULTI_CONFIG

; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;-------------------------------------------------------------------------
; comment= do nothing. just decrese chrptr,and increase count for correct
;		line number
;-------------------------------------------------------------------------

	; 31/12/2022
tryy:
	cmp     ah,CONFIG_COMMENT ; 'Y'
	jne	short try0

donothing:
	; 15/12/2022
	; ds = cs
	dec	word [chrptr]
	inc	word [count]
	; 02/11/2022
	;dec	word [cs:chrptr]
	;inc	word [cs:count]

	jmp	coff

;------------------------------------------------------------------------
; rem command
;------------------------------------------------------------------------

try0:				; do nothing with this line.
	cmp     ah,CONFIG_REM ; '0'
	je	short donothing

;%endif	; 30/10/2022

; 30/10/2022
; (MSSOS 5.0 IO.SYS - SYSINIT:29D7h)

;------------------------------------------------------------------------
; bogus command
;------------------------------------------------------------------------

tryz:
        cmp     ah,0FFh		;null command? (BUGBUG - who sets FFh anyway?)
	; 31/12/2022
	je	short donothing
	; 02/11/2022
	;je	short tryz_donothing

	dec	word [chrptr]
	inc	word [count]
	jmp	short badop

; 31/12/2022
;	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
;tryz_donothing:
;	jmp	donothing

; 07/04/2019 - Retro DOS v4.0

;------------------------------------------------------------------------------

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2D5Dh)

; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;
;
;;***	CheckProtmanArena -- special hack for adjusting alloclim with Protman$
;;
;;	adjusts alloclim if Protman$ reduced our arena through a manual hack.
;
;CheckProtmanArena:
;	push	es
;	mov	ax,[cs:area]	; get our arena header
;	dec	ax
;	mov	es,ax
;	add	ax,[es:3]	; find end of arena
;	inc	ax
;	cmp	ax,[cs:ALLOCLIM] ; is it less than alloclim?
;	ja	short CheckProtmanDone
;
;	mov	[cs:ALLOCLIM],ax ; reduce alloclim then
;CheckProtmanDone:
;	pop	es
;	retn

;------------------------------------------------------------------------------

sysinit_parse:

;------------------------------------------------------------------------------
;set up registers for sysparse
;in)	es:si -> command line in confbot
;	di -> offset of the parse control definition.
;
;out)	calls sysparse.
;	carry will set if parse error.
;	*** the caller should check the eol condition by looking at ax
;	*** after each call.
;	*** if no parameters are found,then ax will contain a error code.
;	*** if the caller needs to look at the synomym@ of the result,
;	***  the caller should use cs:@ instead of es:@.
;	cx register should be set to 0 at the first time the caller calls this
;	 procedure.
;	ax - exit code
;	bl - terminated delimeter code
;	cx - new positional ordinal
;	si - set to pase scanned operand
;	dx - selected result buffer
;------------------------------------------------------------------------------

	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2D78h)

	; 24/10/2022
	push	es			;save es,ds
	push	ds

	push	es
	pop	ds			;now ds:si -> command line

	push	cs
	pop	es			;now es:di -> control definition

	mov	[cs:badparm_seg],ds	;save the pointer to the parm
	mov	[cs:badparm_off],si	;we are about to parse for badparm msg.
	;mov	dx,0
	; 03/01/2023
	sub	dx,dx ; 0
	call	SysParse
	cmp	ax,_$P_No_Error	; 0	;no error

;**cas note:  when zero true after cmp, carry clear

	;je	short ll4
	; 24/10/2022 (MSDOS 5.0 IO.SYS compatibility, SYSINIT:2A02h)
	; 12/12/2022
	je	short en4 ; cf=0
	cmp	ax,_$P_RC_EOL ; 0FFFFh	;or the end of line?
	;jne	short if4
	; 12/12/2022
	je	short en4 ; cf=0

; 12/12/2022
;ll4:
;	; 12/12/2022
;	; cf=0
;	;clc
;	jmp	short en4

if4:
	; 24/10/2022
	stc
en4:
	pop	ds
	pop	es
	retn

; 11/12/2022
%if 0

;----------------------------------------------------------------------------
;
; procedure : badop_p
;
;             same thing as badop,but will make sure to set ds register back
;             to sysinitseg and return back to the caller.
;
;----------------------------------------------------------------------------

badop_p:
	push	cs
	pop	ds		;set ds to configsys seg.
	mov	dx,badopm
	call	print
        ;call	error_line
	;retn
	; 11/12/2022
	jmp	error_line

%endif

;----------------------------------------------------------------------------
;
; label : badop
;
;----------------------------------------------------------------------------

badop:	
	mov	dx,badopm	;want to print command error "unrecognized command..."
	call	print
	call	error_line	;show "error in config.sys ..." .
	jmp	coff

;----------------------------------------------------------------------------
;
; procedure : badparm_p
;
;             show "bad command or parameters - xxxxxx"
;             in badparm_seg,badparm_off -> xxxxx
;
;----------------------------------------------------------------------------

	; 24/10/2022
badparm_p:
	; 11/12/2022
	; ds = cs
	; 11/12/2022
	;push	ds ; *
	push	dx
	push	si

	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds

	mov	dx,badparm
	call	print			; "bad command or parameters - "
	lds	si,[badparm_ptr]

;	print "xxxx" until cr.

do1:
	mov	dl,[si]			; get next character
	cmp	dl,cr ; 0Dh		; is a carriage return?
	je	short en1		; exit loop if so

	mov	ah,2 ; STD_CON_OUTPUT	; function 2
	int	21h			; display character
	inc	si			; next character
	jmp	short do1
en1:
	push	cs
	pop	ds

	mov	dx,crlfm
	call	print
	call	error_line

	pop	si
	pop	dx
	; 11/12/2022
	;pop	ds ; *
badparmp_ret:
	retn

;----------------------------------------------------------------------------
;
; procedure : getchr
;
;----------------------------------------------------------------------------

	; 24/10/2022
getchr:
	; 12/12/2022
	;push	cx
	;mov	cx,[count]
	;jcxz	nochar
	; 12/12/2022
	cmp	word [count],1 
	jb	short nochar ; cf=1 ([count] = 0)
	
	mov	si,[chrptr]
	mov	al,[es:si]
	dec	word [count]
	inc	word [chrptr]
	; 12/12/202
	; cf=0
	;clc
;get_ret:
	;pop	cx
	;retn
nochar: 
	; 12/12/2022
	; cf=1
	;stc
	;jmp	short get_ret
	
	retn

; 11/12/2022
%if 0

;----------------------------------------------------------------------------
;
; procedure : incorrect_order
;
;             show "incorrect order in config.sys ..." message.
;
;----------------------------------------------------------------------------

incorrect_order:
	mov	dx,badorder
	call	print
	call	showlinenum
	retn

%endif

;----------------------------------------------------------------------------
;
; procedure : error_line
;
;             show "error in config.sys ..." message.
;
;----------------------------------------------------------------------------

	; 11/12/2022
	; 24/10/2022
error_line:
	; 11/12/2022
	; ds = cs
	;push	cs
	;pop	ds

	mov	dx,errorcmd
	call	print
	;call	showlinenum
	;retn
	; 11/12/2022
	;jmp	short shortlinemum

;----------------------------------------------------------------------------
;
; procedure : showlinenum
;
; convert the binary linecount to decimal ascii string in showcount
; and display showcount at the current curser position.
; in.) linecount
;
; out) the number is printed.
;
;----------------------------------------------------------------------------

	; 11/12/2022
	; ds = cs
	; 24/10/2022
showlinenum:
	push	es
	; 11/12/2022
	;push	ds
	push	di

	push	cs
	pop	es		; es=cs

	; 11/12/2022
	;push	cs
	;pop	ds

	mov	di,showcount+4	; di -> the least significant decimal field.
	mov	cx,10		; decimal divide factor
	;mov	ax,[cs:linecount]
	; 11/12/2022
	mov	ax,[linecount]
sln_loop:
	; 11/12/2022
	cmp	ax,cx ; < 10 ?
	;cmp	ax,10		; < 10?
	jb	short sln_last

	xor	dx,dx
	div	cx	; cx = 10
	or	dl,30h		; add "0" (= 30h) to make it an ascii.
	mov	[di],dl
	dec	di
	jmp	short sln_loop

sln_last:
	or	al,30h	; "0"
	mov	[di],al
	mov	dx,di
	call	print		; show it.
	pop	di
	; 11/12/2022
	;pop	ds
	pop	es
	retn

; 07/04/2019 - Retro DOS v4.0
; (MSDOS 6.21 IO.SYS, SYSINIT:2E44h)

;----------------------------------------------------------------------------
;
; procedure : ProcDOS
;
;	Process the result of DOS= parsing
;
;	result_val._$P_item_tag	= 1 for DOS=HIGH
;				= 2 for DOS=LOW
;				= 3 for DOS=UMB
;				= 4 for DOS=NOUMB
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modififed MSDOS 5.0 IO.SYS)
	; (SYTSINIT:2AB5h)
ProcDOS:
	; 01/01/2023
	; ds = cs
	xor	ah,ah
	;;mov	al,[cs:result_val_itag]
	;mov	al,[cs:result_val+_$P_Result_Blk.Item_Tag]
	; 01/01/2023
	mov	al,[result_val+_$P_Result_Blk.Item_Tag]
	dec	ax
	jz	short pd_hi
	dec	ax
	jz	short pd_lo
	dec	ax
	jz	short pd_umb
	;;mov	byte [cs:DevUMB],0
	; 18/12/2022
	;mov	byte [cs:DevUMB],ah ; 0
	; 01/01/2023
	mov	byte [DevUMB],ah ; 0
	retn
pd_umb:
	; 01/01/2023
	mov	byte [DevUMB],0FFh
	;mov	byte [cs:DevUMB],0FFh
	retn
pd_lo:
	; 01/01/2023
	mov	[runhigh],al ; 0
	; 18/12/2022
	;mov	[cs:runhigh],al ; 0
	;;mov	byte [cs:runhigh],0
	retn
pd_hi:
	; 01/01/2023
	mov	byte [runhigh],0FFh
	;mov	byte [cs:runhigh],0FFh
limx:	; 11/12/2022
	retn

;----------------------------------------------------------------------------
;
; procedure : LieInt12Mem
;
;	Input : DevEntry points to Device Start address (offset == 0)
;		alloclim set to the limit of low memory.
;
;	Output : none
;
;	Changes the ROM BIOS variable which stores the total low memory
;	If a 3com device driver (any character device with name 'PROTMAN$')
;	is being loaded alloclim is converted into Ks and stored in 40:13h
;	Else if a device driver being loaded into UMB the DevLoadEnd is
;	converted into Ks and stored in 40:13h
;
;----------------------------------------------------------------------------

LieInt12Mem:
	; 11/12/2022
	; ds = cs
	mov	ax,[ALLOCLIM]
	;mov	ax,[cs:ALLOCLIM]	; lie INT 12 as alloclim
					; assuming that it is 3Com
	call	IsIt3Com		; Is it 3Com driver?
	jz	short lim_set		; yes, lie to him differently
	; 13/05/2019
	;cmp	byte [cs:DeviceHi],0	; Is the DD being loaded in UMB
	;je	short limx		; no, don't lie
	;mov	ax,[cs:DevLoadEnd]	; lie INT 12 as end of UMB
	; 11/12/2022
	; ds = cs
	cmp	byte [DeviceHi],0
	je	short limx
	mov	ax,[DevLoadEnd]
lim_set:
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
	;call	SetInt12Mem
;limx:
	;retn
	
	;jmp	short SetInt12Mem 

;----------------------------------------------------------------------------
;
; procedure : SetInt12Mem
;
;	Input : AX = Memory size to be set (in paras)
;	Output : none
;
;	Sets the variable 40:13 to the memory size passed in AX
;	It saves the old value in 40:13 in OldInt12Mem,
;	It also sets a flag Int12Lied to 0ffh, which is checked before
;	restoring the value of 40:13
;
;----------------------------------------------------------------------------

	; 01/11/2022
SetInt12Mem:
	push	ds
	mov	bx,40h
	mov	ds,bx			; ROM BIOS Data Segment
	mov	bx,[13h]		; INT 12 memory variable
	mov	[cs:OldInt12Mem],bx	; save it
	mov	cl,6
	shr	ax,cl			; convert paras into Ks
	mov	[13h],ax		; Lie
	mov	byte [cs:Int12Lied],0FFh ; mark that we are lying
	pop	ds
;limx:
	retn

;----------------------------------------------------------------------------
;
; procedure : TrueInt12Mem
;
;	Input : Int12Lied = 0 if we are not lying currently
;			  = 0ffh if we are lying
;		OldInt12Mem = Saved value of 40:13h
;
;	Output : none
;
;	Resets the INT 12 Memory variable if we were lying about int 12
;	and resets the flag which indicates that we were lying
;
;----------------------------------------------------------------------------

TrueInt12Mem:
	; 11/12/2022
	; ds = cs
	cmp	byte [Int12Lied],0
	;cmp	byte [cs:Int12Lied],0	; were we lying so far?
	; 01/11/2022 (MSDOS 5.0 IO.SYS, SYS.INIT:2B1Dh)
	;mov	byte [cs:Int12Lied],0	; reset it anyway
	je	short timx		; no, we weren't
	; 18/12/2022
	mov	ax,40h
	mov	[Int12Lied],ah ; 0
	;mov	byte [Int12Lied],0
	;mov	byte [cs:Int12Lied],0
	push	ds
	;mov	ax,40h
	mov	ds,ax
	mov	ax,[cs:OldInt12Mem]
	mov	[13h],ax		; restore INT 12 memory
	pop	ds
timx:
	retn

;----------------------------------------------------------------------------
;
; procedure : IsIt3Com?
;
;	Input : DevEntry = Seg:0 of device driver
;	Output : Zero flag set if device name is 'PROTMAN$'
;		 else Zero flag is reset
;
;----------------------------------------------------------------------------

IsIt3Com:
	; 11/12/2022
	; ds = cs
	push	ds
	push	es
	push	si
	; 11/12/2022
	lds	si,[DevEntry]
	;lds	si,[cs:DevEntry]	; ptr to device header
	add	si,SYSDEV.NAME ; 10 	; ptr device name
	push	cs
	pop	es
	mov	di,ThreeComName
	mov	cx,8			; name length
	rep	cmpsb
	pop	si
	pop	es
	pop	ds
	retn

;M020 : BEGIN
;----------------------------------------------------------------------------

UpdatePDB:
	push	ds
	mov	ah,62h
	int	21h	; DOS - 3+ - GET PSP ADDRESS
	mov	ds,bx
	mov	bx,[cs:ALLOCLIM]
	;mov	[2],bx
	mov	[PDB.BLOCK_LEN],bx
	pop	ds
	retn

; M020 : END

;----------------------------------------------------------------------------

; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2EEEh)

;include highload.inc	; Routines for devicehigh parsing, control of HIDDEN
;include highexit.inc	; umb's, etc

; ----------------------------------------------------------------------
; HIGHLOAD.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 07/04/2019 - Retro DOS v4.0

;******************************************************************************
;
; This file contains routines needed to parse and implement user-given
; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
; and Parsevar() are used to parse this data and place it in encoded form into
; the variables in highvar.inc, for use by the rest of the routines.
;
; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
;    DEVICEHIGH SIZE=hhhhhh module opts
; Or, DeviceHigh and LoadHigh accept any of the following:
;    DH/LH module opts
;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
; The initial UMB,SIZE pair designates the module's load address; the remainder
; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
; available during the load.
;
; When an actual load is ready to be performed, a call to HideUMBs() will
; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
; upper-memory block which was not specified by the user... in addition, if
; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
; elements in that umb SAVE the lower-half of the newly-shrunken one are also
; allocated. After the load, the function UnHideUMBs() (in highexit.inc) will
; free any UMBs so allocated.
;
; When a device driver loads, there is the additional problem of allocating its
; initial load site; this should be restricted to the first UMB specified on
; the command-line. The function FreezeUM temporarily allocates all remaining
; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
; UMB. Then the initial allocation may be made, and a call to UnFreeze will
; return any so-allocated memory elements to FREE, for the true load. Note
; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
;
;******************************************************************************

SWTCH	equ	'/'		; Switch character

DOS_CHECK_STRATEGY  equ	5800h	; Int 21h, Func 58h, Svc 0 = check alloc strat
DOS_SET_STRATEGY    equ	5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
DOS_CHECK_UMBLINK   equ	5802h	; Int 21h, Func 58h, Svc 2 = check link state
DOS_GET_UMBLINK	    equ 5802h ; 20/04/2019
DOS_SET_UMBLINK     equ	5803h	; Int 21h, Func 58h, Svc 3 = set link state
DOS_GET_DOS_LISTS   equ	  52h	; Int 21h, Func 52h = return list of lists
DOS_UMB_HEAD        equ	  8Ch	; Offset from ES (after func52h) to get UMBHead

CR	equ	0Dh		; Carriage Return
LF	equ	0Ah		; Line Feed
TAB	equ	09h		; Tab character (^I)

; -----------------------------------------------------------------------------
;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
; -----------------------------------------------------------------------------
; ENTRY:       None
; EXIT:        Variables listed in highvar.inc are initialized
; ERROR EXIT:  None
; USES:        Flags, variables in highvar.inc
; -----------------------------------------------------------------------------
; Note that element 0 references UMB 0 (conventional), not UMB 1. Its contents
; are largely ignored, but it is initialized nonetheless.
; -----------------------------------------------------------------------------

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:2EEEh)

InitVar:
	; 01/01/2023
	; ds = cs

	;pushreg <ax, cx, di, es>
	; 03/01/2023
	;push	ax
	;push	cx
	;push	di
	push	es

	;dataseg es			;Point ES into appropriate data segment
	push	cs
	pop	es

	xor	ax,ax
	;mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
	;mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
	;mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
	;mov	byte [es:UmbLoad],UNSPECIFIED ; 0FFh
	;				;Later is the # of the 1st spec'd UMB
	;mov	[es:fm_argc], al	;Start with zero args having been read

	; 01/01/2023
	; ds = cs
	mov	[fUmbTiny],al		;Shrink UMBs? (made 1 if /S given)
	mov	[fInHigh],al		;Set to 1 when DH/LH has been called
	mov	[SegLoad],ax		;Load Address (seg), used for DH only
	mov	byte [UmbLoad],UNSPECIFIED ; 0FFh
					;Later is the # of the 1st spec'd UMB
	mov	[fm_argc], al		;Start with zero args having been read

	cld

	mov	cx,MAXUMB ; 16		;For each entry
	mov	di,UmbUsed		;on the UmbUsed array,
	rep	stosb			;	Store 0

	;mov	cx,MAXUMB ; 16		;Okay... for each entry
	; 01/01/2033
	mov	cl,MAXUMB ; 16
	mov	di,UmbSize		;on the UmbSize array,
	rep	stosw			;	Store 0

	;normseg es			; Return ES

	;popreg	<es, di, cx, ax>
	pop	es
	; 03/01/2023
	;pop	di
	;pop	cx
	;pop	ax	 	

	retn

; -----------------------------------------------------------------------------
;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
; -----------------------------------------------------------------------------
; ENTRY   : None
; EXIT    : None
; ERROR   : None
; USES    : Flags, fm_umb, fm_strat
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2F22h)
FixMem:
	; 01/01/2023
	;push	ax
	;push	bx
	;push	cx
	;push	dx
	push	es

	call	fm_link		; Link in UMBs

	call	UmbHead		; Get first upper-memory MCB address (0x9FFF)
	jc	short fmX	; (if couldn't get it, leave now).

	mov	es,ax		; It returns in AX, so move it to ES.

; - Walk MCB Chain ------------------------------------------------------------

	xor	dx,dx		; We're keeping the address of the last MCB
	mov 	cx,dx		; in CX... and the last owner
	inc	dx		; in dx as we go through the loop:

; ------------------------------------------
; FM10--DX  = last MCB's owner's PSP address
;       CX  = last MCB's address (segment)
; ------------------------------------------

fm10:	mov	al,[es:ARENA.SIGNATURE] ; if 'Z', don't repeat loop
	mov	bx,[es:ARENA.OWNER]	; if not zero, do nothing
	or	bx,dx			; dx was owner of previous MCB
	jnz	short fm30		; If not both zero, don't cat.

	; - Coalesce memory blocks at ES:00 and CX:00 -------------------------

fm20:	mov	bx,[es:ARENA.SIZE]	; Grab this block's Size,
	mov	es,cx			; Go back to prev MCB's address
	mov	[es:ARENA.SIGNATURE],al ; & move the SECOND sig here

	add	bx,[es:ARENA.SIZE]	; Size += first MCB's size
	add	bx,1			; And add one for the header
	mov	[es:ARENA.SIZE],bx	; Write the size

	; ---------------------------------------------------------------------

fm30:	mov	cx,es			; Put this address on the stack
	mov	dx,[es:ARENA.OWNER]	; And remember its owner

	mov	bx,es			; Move to the next MCB
	add	bx,[es:ARENA.SIZE]
	inc	bx
	mov	es,bx

	;cmp	al,'Z'
	cmp	al,arena_signature_end
	jne	short fm10		; If signature != 'Z', there are more.
fmX:	
	call	fm_unlink		; Unlink UMBs

	pop	es
	; 01/01/2023
	;pop	dx
	;pop	cx
	;pop	bx
	;pop	ax

	retn

; -----------------------------------------------------------------------------
;*** fm_link - links UMBs not already linked in
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
; ERROR:    None
; USES:     AX, BX, fm_umb
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
fm_link:
	mov	ax,DOS_CHECK_UMBLINK ; 5802h
	int	21h			; Current link-state is now in al

	;putdata fm_umb,al		; So store it in fm_umb for later
	;
	;push	es
	;push	cs
	;pop	es
	;mov	[es:fm_umb],al
	;pop	es
	
	; 01/01/2023
	; ds = cs
	;mov	[cs:fm_umb],al
	mov	[fm_umb],al

	mov	ax,DOS_SET_UMBLINK ; 5803h
	mov	bx,1
	int	21h
	retn

; -----------------------------------------------------------------------------
;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
; -----------------------------------------------------------------------------
; ENTRY:    fm_umb == 1 : leave linked, else unlink
; EXIT:     None
; ERROR:    None
; USES:     AX, BX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
fm_unlink:
	xor	bx,bx
	
	;getdata bl,fm_umb		; fm_umb already has the old link-state
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	bl,[fm_umb]	
	;pop	ds
	
	; 01/01/2023
	; ds = cs
	;mov	bl,[cs:fm_umb]
	mov	bl,[fm_umb]

	mov	ax,DOS_SET_UMBLINK ; 5803h
	int	21h			; so just use that, and call int 21h
	retn

; 08/04/2019 - Retro DOS v4.0

; -----------------------------------------------------------------------------
;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
; laid out in highvar.inc
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
; EXIT:     ES:SI points to first character in child program name
; ERROR:    ES:SI points to character which caused error, carry set, AX == code
; USES:     ES:SI, AX, flags, variables in highvar.inc
; -----------------------------------------------------------------------------
; Error codes (in AX if carry set on return):
;
PV_InvArg	equ	1	; Invalid argument passed
PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
PV_InvSwt	equ	3	; Unrecognized switch passed
;
; This routine exects ES:SI to point to a string much like the following:
;    "/S/L:1,200;2 module options"
; Optionally, the string can begin with whitespace; neither /S nor /L is
; required, though that's what this routine is supposed to parse.
;
optS		equ	'S'	; /S
optL		equ	'L'	; /L:...
;
; -----------------------------------------------------------------------------
; LoadHigh has a list of arguments, returned by cparse, which is used to create
; a command-line for spawning a child process. For a typical LH command, say,
;     lh /l:1,1000;2 print/d:lpt2
; the arguments would look like (one per line):
;     lh
;     /l
;     1
;     1000
;     2
;     print
;     /d
;     :lpt2
; In short, if "print" were, say, "43", there'd be no way to determine which
; arg was the filename. So, inside this routine, we keep a running counter
; of the number of arguments LH will need to skip in order to get to the
; program name. The "lh" is implicit--it'll always have to skip that. So if
; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
; for:
;    Each /L
;    Each /S (there should be only one)
;    Each UMB number (they follow ":" or ";")
;    Each UMB size   (they follow ",")
; So, in the above example, fm_argc would be 4-- and LH would skip right to
; "print".  Note that InitVar initializes fm_argc to zero.
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:2F9Fh)

ParseVar:
	;pushreg <di, ds, es>
	; 01/01/2023
	;push	di ; * ; (not required) ; 01/01/2023
	push	ds
	push	es

	push	es		; Make DS:SI point to it, as well as ES:SI
	pop	ds		; (regardless if we're in devhigh or loadhigh)
	cld

; ------------------------------------------------
; PV10--ES:SI = any whitespace on the command-line
; ------------------------------------------------

pv10:	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
	call	isWhite
	jz	short pv10	;       ES:SI==" /L..."--keep eating.
	;cmp	al,'/'
	cmp	al,SWTCH
	je	short pv20	;       ES:SI=="/L..."--go process a switch

	dec	si		; Backup--it's now "odule options", and we need
	clc			; that "m" we just read (or whatever it is).
	jmp	short pvX	; Then return with carry clear == we're done.

pv20:	lodsb			; Just read 'S' or 'L', hopefully
	;toUpper al		; So we make it upper-case, and...
	and	al,0DFh
	;cmp	al,'S'
	cmp	al,optS		; just read 'S'?
	jne	short pv30

	;call	incArgc		; If it's /S, it's another arg for LH to skip.
	inc	byte [cs:fm_argc] ; 19/04/2019

	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
	;
	;push	es
	;push	cs
	;pop	es
	;mov	[es:fUmbTiny],1	
	;pop	es

	mov	byte [cs:fUmbTiny],1

	jmp	short pv10	; possibly even "/L...".

pv30:	;cmp	al,'L'
	cmp	al,optL		; If it's not 'L' either, then 'tis a bad
	jne	short pvE1		; switch!

	;call	incArgc		; If it's /L, it's another arg for LH to skip.
	inc	byte [cs:fm_argc] ; 19/04/2019

	call	parseL
	jnc	short pv10	; If no carry, go back and look for more

	dec	si		; Else, back up and exit.
	jmp	short pvErr	; AX has already been set by parseL

pvE1:	;mov	ax,3
	mov	ax,PV_InvSwt	; Unrecognized switch passed
pvErr:	dec	si
	dec	si
	stc
pvX:	;popreg	<es, ds, di>
	pop	es
	pop	ds
	; 01/01/2023
	;pop	di ; * ; (not required) ; 01/01/2023
	retn

; -----------------------------------------------------------------------------
;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to colon
; EXIT:     ES:SI points to first character not parsed
; ERROR:    Carry set; rewind three characters and return (see ParseVar)
; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
; -----------------------------------------------------------------------------
; If the string here is terminated with anything other than whitespace or a
; switchchar (perhaps it's /S or another /L:... ), then we return with carry
; set, indicating that they've screwed up the syntax.  The 3-character rewind
; makes sure the app /L: is reported as being the culprit.
; -----------------------------------------------------------------------------

parseL:
	lodsb
	cmp	al,':'		; Make sure they did /L:
	jne	short plE1	; If they didn't, return with carry set.

; ------------------------------------------
; PL10--ES:SI = a UMB number, after /L: or ;
; ------------------------------------------

pl10:	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
	jc	short plE2	; And error if it's a bad number.
	call	convUMB		; Convert any address to a UMB number

	mov	cl,al		; Remember the UMB number
	call	stowUMB		; Mark this UMB # as used;
	jc	short plE2	; If it was already marked, it'll error

	;call	incArgc		; Each UMB number is another arg for LH to skip
	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0

	lodsb
	cmp	al,';'		; Did "umb;" ?
	je	short pl10	; Yep: go back and get another UMB.

	call	isWhite		; Did "umb " ?
	jz	short plX	; Yep: return (it'll go back to whitespace)

	call	isEOL		; Did "umb" ?
	jz	short plSwX	; If so, backup and exit like everything's ok

	;cmp	al,'/'
	cmp	al,SWTCH 	; Did "umb/" ? (as in, "/L:1,100;2/S")
	je	short plSwX	; If so, back up ES:SI one character and return

	cmp	al,','		; Did "umb," ?
	jne	short plE1	; Just what the heck DID they do? Return error.

; --- Read a size -------------------------------------------------------------

	call	GetXNum		; Stop on "size;" or "size " or anything else
	jc	short plE1	; And error if it's a bad size.

	call	toPara		; Convert from bytes to paragraphs

	call	stowSiz		; CL still has the UMB number for this routine

	;call	incArgc		; Each UMB size is another arg for LH to skip
	inc	byte [cs:fm_argc] ; 08/04/2019 - Retro DOS v4.0

	lodsb
	cmp	al,';'		; They did "umb,size;", so get another UMB.
	je	short pl10	;

	call	isWhite		; Did it end with whitespace?
	jz	short plX	; If so, we're done here--go back.

	call	isEOL		; Did they do "umb,size" and end??? (stupid)
	jz	short plSwX	; If so, backup and exit like everything's ok

	;cmp	al,'/'
	cmp	al,SWTCH	; Did they do "umb,size/" ?
	je	short plSwX	; If so, again, we're done here.
plE1:	
	;mov	ax,1
	mov	ax,PV_InvArg	; If not, we don't know WHAT they did...
	dec	si
	stc
	retn

plE2:	;mov	ax,2
	mov	ax,PV_BadUMB	; In this case, they've specified a UMB twice
	; 12/12/2022
	; cf=1
	;stc
	retn
plSwX:	
	dec	si		; If we hit a '/' character, back up one char
				; so the whitespace checker will see it too.
plX:	; 12/12/2022
	; cf=0
	;clc			; Then just return with carry clear, so
	retn			; ParseVar will go about its business.

; -----------------------------------------------------------------------------
;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     None
; ERROR:    None
; USES:     fm_argc, flags
; -----------------------------------------------------------------------------

;incArgc:
	;push	ax

	;;getdata al, fm_argc	; Obtain previous value of fm_argc,

	;mov	al,[cs:fm_argc]

	;inc	al		; Increment it,

	;;putdata fm_argc, al	; And store it right back.

	;mov	[cs:fm_argc],al

	;pop	ax
	;retn

; -----------------------------------------------------------------------------
;*** isEOL - returns with ZF set if AL contains CR or LF, or 0
; -----------------------------------------------------------------------------
; ENTRY:    AL contains character to test
; EXIT:     ZF set iff AL contains CR or LF, or 0
; ERROR:    None
; USES:     ZF
; -----------------------------------------------------------------------------

isEOL:
	cmp	al,0		; Null-terminator
	je	short ieX
	cmp	al,CR ; 0Dh	; Carriage Return
	je	short ieX
	cmp	al,LF ; 0Ah	; LineFeed
ieX:	
	retn

; -----------------------------------------------------------------------------
;*** isWhite - returns with ZF set if AL contains whitespace (or "=")
; -----------------------------------------------------------------------------
; ENTRY:    AL contains character to test
; EXIT:     ZF set iff AL contains space, tab, or equals
; ERROR:    None
; USES:     ZF
; -----------------------------------------------------------------------------

isWhite:
	cmp	al,' '		; Space
	je	short iwX
	cmp	al,'='		; Equals (treat as whitespace)
	je	short iwX
	cmp	al,tab ; 9	; Tab
iwX:	
	retn

; -----------------------------------------------------------------------------
;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
; -----------------------------------------------------------------------------
; ENTRY:    AL contains UMB number
; EXIT:     None
; ERROR:    None
; USES:     Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

	; 02/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

unMarkUMB:
	; 02/01/2023
	;push	ax
	;push	bx
	;push	di
	;push	es
	;
	;push	cs
	;pop	es

	xor	ah,ah
	mov	bx,ax

	; 19/04/2019
	
	;;mov	byte [es:bx+UmbUsed],0
	;mov	[es:bx+UmbUsed],ah ; 0
	; 02/01/2023
	; ds= cs
	;mov	[cs:bx+UmbUsed],ah ; 0
	mov	[bx+UmbUsed],ah ; 0

	cmp	[UmbLoad],al
	;cmp	[cs:UmbLoad],al
	;;cmp	[es:UmbLoad],al
	jne	short umu10

	;;mov	[es:UmbLoad],0	; If unmarked the load UMB, load into convent.
	;mov	[es:UmbLoad],ah ; 0
	; 02/01/2023
	; ds = cs
	;mov	[cs:UmbLoad],ah ; 0
	mov	[UmbLoad],ah ; 0
umu10:	
	;pop	es
	;pop	di
	;pop	bx
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
; listed in the /L:... chain. If it's the first one specified, it sets UmbLoad
; to that UMB #... and in any case, it marks the UMB as specified.
; -----------------------------------------------------------------------------
; ENTRY:    AL contains UMB number, as specified by the user
; EXIT:     None
; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
; USES:     AX, Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
stowUMB:
	cmp	al,MAXUMB ; 16
	jb	short su10
	stc
	retn			; Ooops-- UMB>=MAXUMB
su10:	
	; 01/01/2023
	;push	bx
	;push	di
	;push	si
	;push	ds
	;push	es
	;push	cs
	;pop	es
	;push	cs
	;pop	ds

	; 01/01/2023
	; ds <> cs
	;cmp	byte [cs:UmbLoad],0FFh
	cmp	byte [cs:UmbLoad],UNSPECIFIED
				; If this, we haven't been here before
	jne	short su20
	mov	[cs:UmbLoad],al	; So remember this UMB as the load UMB slot.

	;;cmp	byte [UmbLoad],0FFh
	;cmp	byte [UmbLoad],UNSPECIFIED ; If this, we haven't been here before
	;jne	short su20
	;mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
su20:	
	or	al,al		; If they gave UMB 0, there's really nothing
	jz	short su30	; that we should do here.

	;mov	bl,al
	;xor	bh,bh
	;mov	ax,1		; Now, AX = 1, and BX = UMB Number
	; 01/01/2023
	xor	ah,ah
	mov	bx,ax
	mov	al,1

	;xchg	[es:bx+UmbUsed],al
	; 01/01/2023
	xchg	[cs:bx+UmbUsed],al

	;or	al,al		; If it was already 1, then al==1... and that
	;jz	short su30	; means an error.
	;
	;stc			; OOOPS!  This one's been used before.  :(
	
	; 01/01/2023
	cmp	al,1
	cmc 	; if al > 0 -> cf = 1
su30:	
	; 01/01/2023
	;pop	es
	;pop	ds
	;pop	si
	;pop	di
	;pop	bx
	retn

; -----------------------------------------------------------------------------
;*** stowSiz - marks a given UMB as having a given minimum size
; -----------------------------------------------------------------------------
; ENTRY:    CL contains UMB number, AX contains size
; EXIT:     None
; ERROR:    None
; USES:     AX, DX, Flags, variables in highvar.inc
; -----------------------------------------------------------------------------

; 13/05/2019

	; 01/01/2023 - Retro DOS v4.2
stowSiz:
	; 01/01/2023
	;push	bx
	;;push	di ; ?
	;push	es

	;push	cs
	;pop	es	

	mov	bl,cl			; Now bl==UMB number, AX==size
	mov	bh,0			;     bx==UMB number, AX==size
	shl	bl,1			;     bx==offset into array, AX=size
	;mov	[es:bx+UmbSize],ax	; Store the size
	; 01/01/2023
	mov	[cs:bx+UmbSize],ax	; Store the size

	; 01/01/2023
	;pop	es
	;;pop	di ; ?
	;pop	bx

	retn

; -----------------------------------------------------------------------------
;*** toDigit - converts a character-digit to its binary counterpart
;            -- verifies that CL contains a valid character-digit; if so, it
; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).
; A-F are considered valid iff gnradix is 16.
; -----------------------------------------------------------------------------
; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
; USES:     CL, Flags
; -----------------------------------------------------------------------------
; If the string is preceeded with "0x", the value is read as hexadecimal; else,
; as decimal. After a read, you may check the radix by examining gnradix--it
; will be 10 or 16.
; -----------------------------------------------------------------------------

gnradix:
	dw	0		; Must be a word--16x16 multiplication

toDigit:
	cmp	word [cs:gnradix],16
	jne	short td20	; Don't check hex digits if radix isn't 16

toDigit_hex:
	cmp	cl,'a'	; 61h
	jb	short td10
	cmp	cl,'f'	; 66h
	ja	short tdE	; Nothing valid above 'z' at all...
	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
	;clc			; <- CLC is implicit from last SUB
	retn
td10:	
	cmp	cl,'A'  ; 41h
	jb	short td20	; Below 'A'?  Not a letter...
	cmp	cl,'F'	; 46h
	ja	short tdE	; Above 'F'?  Not a digit.
	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
	;clc			; <- CLC is implicit from last SUB
	retn
toDigit_dec:
td20:	
	cmp	cl,'0'		; If less than zero,
	;jb	short tdE	; Done.
	jb	short tdEr ; 08/04/2019
	cmp	cl,'9'		; Or, if greater than nine,
	ja	short tdE	; Done.
	sub	cl,'0'	; 30h	; Okay--make '0'==0 and return.
	;clc			; <- CLC is implicit from last SUB
	retn
tdE:	
	stc
tdEr:		; 08/04/2019 - Retro DOS v4.0	
	retn

; -----------------------------------------------------------------------------
;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
; -----------------------------------------------------------------------------
; ENTRY:    ES:SI points to an ascii string to scan
; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
; USES:     ES:SI, DX, AX, Flags, gnradix
; -----------------------------------------------------------------------------
; If the string is preceeded with "0x", the value is read as hexadecimal; else,
; as decimal. After a read, you may check the radix by examining gnradix--it
; will be 10 or 16.
; -----------------------------------------------------------------------------

; 08/04/2019 - Retro DOS v4.0

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:3109h)

GetXNum:
	;pushreg <bx, cx, ds>
	; 01/01/2023
	;push	bx
	push	cx ; *
	;push	ds

	cld
	xor	ax,ax
	xor	bx,bx
	xor	cx,cx
	xor	dx,dx			; Start with 0 (makes sense)

	mov	word [cs:gnradix],10	; And default to a radix of 10 (dec)

	mov	cl,[es:si]		; Now AX=0, BX=0, CH=0/CL=char, DX=0
	;call	toDigit
	call	toDigit_dec
	;jc	short gxnE		; If it's not a digit, leave now.
	; 01/01/2023
	jc	short gxnX

	or	cl,cl
	jnz	short gxn20		; Doesn't have '0x'
	mov	cl,[es:si+1]
	cmp	cl,'x'			; Either 'x'...
	je	short gxn10
	cmp	cl,'X'			; ...or 'X' means it's hexadecimal
	jne	short gxn20

gxn10:	
	mov	word [cs:gnradix], 16
	inc	si			; Since we read "0x", march over it.
	inc	si

; ------------------------------------------------------
; GXN20--ES:SI = a digit in a number; if not, we're done
;        DX:AX = current total
;        BX    = 0
;        CH    = 0
; ------------------------------------------------------

gxn20:	
	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
	inc	si

	call	toDigit		; Accepts only valid digits, A-F -> 10-16
	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.

	call	mul32		; Multiply DX:AX by gnradix
	jc	short gxnX	; (if it's too big, error out)

	add	ax,cx		; Add the digit
	adc	dx,bx		; (BX is 0!)--Adds 1 iff last add wrapped
	;jc	short gxnX	; If _that_ wrapped, it's too big.
	;jmp	short gxn20
	jnc	short gxn20
gxnE:	
	;stc			; In this case, we need to set the carry
	jmp	short gxnX	; and leave--there were no digits given.
gxnQ:	
	dec	si		; Don't read in the offensive character.
	clc			; And clear carry, so they know it's okay.
gxnX:	
	; 01/01/2023
	;pop	ds
	pop	cx ; *
	;pop	bx
	retn

; -----------------------------------------------------------------------------
;*** mul32 - multiplies the number in DX:AX by gnradix
; -----------------------------------------------------------------------------
; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
; ERROR:   Carry set if number was too large
; USES:    Flags, AX, DX
; -----------------------------------------------------------------------------

mul32:
	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
	mul	word [cs:gnradix] ; DX=?, AX=new:hi, TOS=old:lo, BX=0
	jc	short m32E	; Too big?

	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig, BX=0

	xchg	dx,bx		; DX=0, AX=old:lo, TOS=orig, BX=new:hi
	mul	word [cs:gnradix] ; DX=carry,  AX=new:lo, TOS=orig, BX=new:hi
	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=carry
	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig, BX=0
	retn
m32E:	
	pop	ax
	retn

; -----------------------------------------------------------------------------
;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
; -----------------------------------------------------------------------------
; ENTRY:   DX:AX = the number to be divided
; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
; ERROR:   None
; USES:    Flags, AX, DX
; -----------------------------------------------------------------------------
; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
;       can't ensure a 386 host machine. Sorry.
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
toPara:
	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll

	mov	cl,4		;
	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
	mov	cl,12
	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
	or	ax,dx		;    AX=hhhh LLLL llll llll

	pop	cx
	retn

; -----------------------------------------------------------------------------
;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
; -----------------------------------------------------------------------------
; ENTRY:  Nothing
; EXIT:   AX contains 0x9FFF for most systems
; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
; USES:   Flags, AX
; -----------------------------------------------------------------------------
; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
; to be precise, before a UMB provider is around. In this event, the pointer
; is always set to 0xFFFF; it changes once a provider is around. On most
; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
UmbHead:
	; 13/05/2019 (because of callers, pushs & pops are not needed here)

	;push	si ; ?
	;push	ds ; ? 
	;push	es
	;push	bx ; *	

	; 09/04/2019
	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)

	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
	int	21h

	mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
	
	; 01/01/2023
	cmp	ax,0FFFFh
	cmc
	; if AX=0FFFFh -> CF=1
	retn

; 01/01/2023
;%if 0
;	cmp	ax,0FFFFh
;	je	short uhE		; If it's 0xFFFF, it's an error...
;
;	clc				; Else, it isn't (CLC done by prev cmp)
;	;jmp	short uhX
;	; 12/12/2022
;	retn
;uhE:	
;	stc
;uhX:	
;	;pop	bx ; *
;	;pop	es
;	;pop	ds ; ?
;	;pop	si ; ?
;	retn
;%endif

; -----------------------------------------------------------------------------
;*** isSysMCB - sets ZF if ES points to an MCB owned by "SC" + (8 or 9)
; -----------------------------------------------------------------------------
; ENTRY:  ES:0 should point to a valid MCB
; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
; USES:   Flags
; -----------------------------------------------------------------------------

isSysMCB:
	;push	ax

	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
	;je	short ism10
	;cmp	ax,JapanPSPOwner	; 9 (for Japan) is valid
	;;je	short ism10
	;;jmp	short ismX		; Anything else isn't.
	;jne	short ismX
	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; 8  ; 09/04/2019
	jne	short ismX 
ism10:	
	;mov	ax,[es:ARENA.NAME]	; Check the name...
	;cmp	ax,'SC' ; 4353h
	cmp	word [es:ARENA.NAME],'SC'
ismX:	
	;pop	ax
	retn

; 09/04/2019 - Retro DOS v4.0

; -----------------------------------------------------------------------------
;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
; -----------------------------------------------------------------------------
; ENTRY:  AX contains a segment address
; EXIT:   AX will contain the UMB number which contains the address (0==conv)
; ERROR:  If the address is above UM Range, AX will return as FFFF.
; USES:   Flags, AX
; -----------------------------------------------------------------------------
; An address in the following areas is treated as:
;    0      <-> umbhead (0x9FFF)          = Conventional memory
;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
;      ...
;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
AddrToUmb:
	; 01/01/2023
	;push	cx
	;push	dx
	push	es

	mov	dx,ax		; DX = address to search for

	call	UmbHead		; AX = first segment
	jc	short atuE	; If it couldn't get it, error out.

	mov	es,ax		; ES = first UMB segment
	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)

; ----------------------------------------
; ATU10--ES - Current MCB address
;        DX - Address given for conversion
;        CX - Current UMB #
; ----------------------------------------

atu10:	mov	ax,es
        cmp	ax,dx		; Present segment >= given segment?
	jae	short atuX	; Yep--done.

	call	isSysMCB	; Returns with ZF set if this is a system MCB
	jnz	short atu20

	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
atu20:	
	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end  ; 'Z'
	je	short atu30		; 'Z' means this was the last MCB... that's it.

	;NextMCB es, ax

	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax
	
	jmp	short atu10

; -----------------------------------------------------------------------------
; if we get to atu30, they specified a number that was past the last MCB.
; make sure it's not _inside_ that MCB before we return an error condition.
; -----------------------------------------------------------------------------

atu30:	
	mov	ax,es
	add	ax,[es:ARENA.SIZE]
	cmp	ax,dx		; Present >= given?
	jae	short atuX	; Yep! It _was_ inside.
atuE:	
	xor	cx,cx		; Else, fall through with UMB # == -1
	dec	cx		; (that makes it return 0xFFFF and sets CF)
atuX:	
	mov	ax,cx		; Return the UMB number in AX
	
	pop	es	
	; 01/01/2023
	;pop	dx
	;pop	cx
	retn

; -----------------------------------------------------------------------------
;*** convUMB - checks after GetXNum to convert an address to a UMB number
;            -- if GetXNum read a hex number, we interperete that as a segment
; address rather than a UMB number... and use that address to look up a UMB.
; This routine checks for that condition and calls AddrToUmb if necessary.
; -----------------------------------------------------------------------------
; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
; EXIT:   AX will contain a UMB number
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
convUMB:
	cmp	word [cs:gnradix],16
	jne	short cu10	; If it didn't read in hex, it's not an address
	call	AddrToUmb	; Else, convert the address to a UMB number
	;cmp	ax,0FFFFh
	;jne	short cu10
	;inc	ax		; If too high, ignore it (make it conventional)
	; 01/01/2023
	inc	ax
	jz	short cu10	; If too high, ignore it (make it conventional)
	dec	ax
cu10:	
	retn

; 01/01/2023 - Retro DOS v4.2
;%if 0
;
;; -----------------------------------------------------------------------------
;;*** setUMBs - links umbs and sets allocation strategy for a load
;;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
;; of the usual HIGH_FIRST. See the code.
;; -----------------------------------------------------------------------------
;; ENTRY:  None
;; EXIT:   None
;; ERROR:  None
;; USES:   Flags, fm_umb, fm_strat
;; -----------------------------------------------------------------------------
;
;setUMBs:
;	push	ax
;	push	bx
;	call	fm_link
;	pop	bx
;	pop	ax
;	retn
;
;%endif

; -----------------------------------------------------------------------------
;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
;         Carry set if UMB0 not specified (_NOT_ an error)
; ERROR:  None
; USES:   Flags, fm_strat, fm_umb
; -----------------------------------------------------------------------------
; We want to set the memory strategy to LOW_FIRST if the user specified a
; load UMB, and it is 0.  That 0 can be either from the user having _specified_
; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
; such that the load UMB is too small, and shouldn't be used.
; -----------------------------------------------------------------------------

loadLow:
	;push	ds
	;push	cs		; Point DS into appropriate data segment
	;pop	ds	

	;mov	al,[UmbLoad]
	mov	al,[cs:UmbLoad]
	cmp	al,UNSPECIFIED ; 0FFh, -1
	jne	short ll10

	stc
ll15:
	mov	al,1		; Return with AL==1 && STC if no UMBs specified
	;stc
	;jmp	short llX
	retn
ll10:	
	or	al,al		; AL=the load UMB: Is it == 0?
	;jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit

	jnz	short ll15	; 09/04/2019 - Retro DOS v4.0
	retn

	;mov	al,1
	;clc
;llX:
	;pop	ds		; Return DS to where it was
	;retn

; -----------------------------------------------------------------------------
;*** HideUMBs - links UMBs and hides upper-memory as appropriate
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   None
; ERROR:  None
; USES:   Flags, fm_strat, fm_umb
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:322Fh)
HideUMBs:
	; 01/01/2023
	;push	ax
	;push	cx
	;push	ds
	push	es

	; 01/01/2023
	; ds = cs

	call	UmbTest		; See if we REALLY linked in anything...
	jc	short husX	; ...if not, there's nothing for us to do.

	call	FixMem		; Concatenate adjacent free MCBs in upper mem
	
	;call	setUMBs		; Link UMBs and set memory-allocation strategy
	; 01/01/2023
	call	fm_link

	;putdata fInHigh,1	; Remember that we're now running high
	;mov	byte [cs:fInHigh],1
	; 01/01/2023
	mov	byte [fInHigh],1

	;call	GetLoadUMB	; See if they gave us a list to leave free
	;mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0
	; 01/01/2023
	mov	al,[UmbLoad]

	cmp	al,UNSPECIFIED	; If they didn't,
	je	short husX	; then we shouldn't do this loop:

	xor	cx,cx

; -----------------------------------------------
; HUS10-CX - UMB number (after inc, 1==first UMB)
; -----------------------------------------------

hus10:	inc	cx		; For each UMB:
	; 01/01/2023
	cmp	cl,MAXUMB
	;cmp	cx,MAXUMB ; 16
	jae	short hus20

	mov	al,cl		; (stopping as soon as we're outside of the
	push	es
	call	findUMB		; valid range of UMBs)
	pop	es		; push/pop: trash what findumb finds.  :-)
	jc	short hus20
	
	; 02/01/2023
	;push	cx ; *
	call	_hideUMB_	; hide what we need to hide.
	;pop	cx ; *

	jmp	short hus10
hus20:	
	;call	GetLoadUMB	; Now check if they offered /L:0
	; 01/01/2023
	; ds = cs
	;mov	al,[UmbLoad]
	;;mov	al,[cs:UmbLoad] ; 09/04/2019 - Retro DOS v4.0	
	or	byte [UmbLoad],0
	;or	al,al		; --Is the load UMB 0? (-1==unspecified)
	jnz	short husX	; If not, we're done.

	call	hl_unlink	; If so, however, fix UMBs and strategy.
husX:	
	pop	es
	; 01/01/2023
	;pop	ds
	;pop	cx
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AL == load UMB
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

;GetLoadUMB:
;	;getdata al, UmbLoad
;	push	ds
;	push	cs
;	pop	ds
;	mov	al,[UmLoad]
;	pop	ds
;	retn

; -----------------------------------------------------------------------------
;*** GetLoadSize - Returns the load UMB minimum size (0 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  None
; EXIT:   AX == load UMB minimum size
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
GetLoadSize:
	; 09/04/2019 - Retro DOS v4.0
	;mov	al,[cs:UmbLoad]
	; 01/01/2023
	; ds = cs
	mov	al,[UmbLoad] 
	;jmp	short GetSize

	;push	bx
	;;push	si
	;push	ds
	;push	cs
	;pop	ds

	;mov	al,[UmbLoad]

	;xor	ah,ah			;    ax==UMB
	;mov	bx,UmbSize		;    bx==array
	;shl	al,1	                ;    ax==offset
	;;add	ax,bx			;    ax==element index
	;;mov	si,ax			; ds:si==element index

	;;lodsw				;    ax==size

	;add	bx,ax
	;mov	ax,[bx]

	;pop	ds
	;;pop	si
	;pop	bx
	;retn

; -----------------------------------------------------------------------------
;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
; -----------------------------------------------------------------------------
; ENTRY:  AL == a UMB number
; EXIT:   AX == UMB minimum size, as specified by the user
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
GetSize:
	; 09/04/2019 - Retro DOS v4.0

	;push	bx ; 01/01/2023
	;push	si
	;push	ds
	;push	cs
	;pop	ds

	xor	ah,ah			;    ax==UMB
	mov	bx,UmbSize		;    bx==array
	shl	al,1	                ;    ax==offset
	;add	ax,bx			;    ax==element index
	;mov	si,ax			; ds:si==element index

	;lodsw				;    ax==size

	add	bx,ax
	; 01/01/2023
	; ds = cs
	mov	ax,[bx]
	;mov	ax,[cs:bx]

	;pop	ds
	;pop	si
	;pop	bx ; 01/01/2023
	retn

; -----------------------------------------------------------------------------
;*** StoLoadUMB - Overrides the load UMB number with what's in AL
; -----------------------------------------------------------------------------
; ENTRY:   AL == new load UMB
; EXIT:    None
; ERROR:   None
; USES:    Flags, AX
; -----------------------------------------------------------------------------
; CAUTION: Should only be used if /L:... was used.  Logically, that is the only
;          time you would ever need this, so that's okay.
; -----------------------------------------------------------------------------

;StoLoadUMB:
;	;putdata UmbLoad, al
;	push	es
;	push	cs
;	pop	es
;	mov	[es:UmbLoad],al
;	pop	es
;	retn

; -----------------------------------------------------------------------------
;*** StoLoadSize - Overrides the load UMB minimum size with what's in AX
; -----------------------------------------------------------------------------
; ENTRY:  AL == new load size
; EXIT:   None
; ERROR:  None
; USES:   Flags, AX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
StoLoadSize:
	; 01/01/2023
	;push	dx

	;getdata dl, UmbLoad		; Put UMB# in DL and size in AX
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	dl,[UmbLoad]
	;pop	ds	

	mov	dl,[cs:UmbLoad]

	cmp	dl,UNSPECIFIED ; 0FFh
	je	short sls10

	call	stowSiz			; We've got a function to do just this
sls10:	
	; 01/01/2023
	;pop	dx
	retn

; -----------------------------------------------------------------------------
;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
; -----------------------------------------------------------------------------
; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
; EXIT:     None; free elements in UMB marked as hidden
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
hideUMB:
	; 02/01/2023
	push	dx ; (*)
	; 01/01/2023
	;push	ax
	push	es

	call	findUMB	; (*)	; Returns with carry if err, else ES == MCB
	jc	short huX

; ------------------------------------------------
; HU10--ES - MCB inside UMB; if it's a system MCB,
;            we're not in the same UMB, so exit.
; ------------------------------------------------

hu10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jz	short huX	; If it is, we've finished the UMB.
	;call	isFreeMCB	; Returns with ZF set if owner is 0
	or	word [es:ARENA.OWNER],0
	jnz	short hu20

	call	hideMCB
hu20:	
	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end  ;'Z'
	jz	short huX	; 'Z' means this was the last MCB... that's it.

	;NextMCB es,ax		; Go on forward.
	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax

	jmp	short hu10
huX:	
	pop	es
	; 01/01/2023
	;pop	ax
	; 02/01/2023
	pop	dx ; (*)
	retn

; 02/01/2023
%if 0

; -----------------------------------------------------------------------------
;*** isTiny - returns with ZF set if user didn't specify /S
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     ZF set if user DIDN'T specify /S
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

	; 02/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
isTiny:
	; 02/01/2023
	;push	ax

	;getdata al,fUmbTiny
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	al,[fUmbTiny]
	;pop	ds

	mov	al,[cs:fUmbTiny]
	; 02/01/2023
	; ds = cs
	mov	al,[fUmbTiny]

	or	al,al
	; 02/01/2023
	;pop	ax
	retn

%endif

; -----------------------------------------------------------------------------
;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is free, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

;isFreeMCB:
;	or	word [es:ARENA.OWNER],0
;	retn

; -----------------------------------------------------------------------------
;*** hideMCB - marks as HIDDEN the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB marked as HIDDEN
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

hideMCB:
	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
	mov	word [es:ARENA.NAME+0], 'HI' ; 4948h
	mov	word [es:ARENA.NAME+2], 'DD' ; 4444h
	mov	word [es:ARENA.NAME+4], 'EN' ; 4E45h
	mov	word [es:ARENA.NAME+6], '  ' ; 2020h	
	retn

; -----------------------------------------------------------------------------
;*** unHideMCB - marks as FREE the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB marked as FREE
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

unHideMCB:
	; 03/01/2023
	;push	ax
	mov	word [es:ARENA.OWNER],FreePSPOwner ; 0
	mov	ax,'  ' ; 2020h
	mov	[es:ARENA.NAME+0],ax
	mov	[es:ARENA.NAME+2],ax
	mov	[es:ARENA.NAME+4],ax
	mov	[es:ARENA.NAME+6],ax
	; 03/01/2023
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
; ERROR:    Carry set if couldn't reach UMB (too high)
; USES:     Flags, ES
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3344h)
findUMB:
	; 01/01/2023
	;push	ax
	; 02/01/2023
	push	cx ; *
	;push	dx

	xor	ah,ah		; Zap ah, so al==ax

	mov	dx,ax		; Store the to-be-found UMB number in DX

	call	UmbHead		; Returns first UMB segment in AX
	mov	es,ax
	xor	cx,cx		; Pretend we're on UMB 0 for now...

; ---------------------------------------------
; FU10--CX - This UMB number; 0 == conventional
;       DX - The UMB number they're looking for
;       ES - The current MCB address
; ---------------------------------------------

fu10:	
	cmp	cx,dx		; If CX==DX, we've found the UMB we're
	je	short fuX	; searching for--so exit.

	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jnz	short fu20

	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
fu20:	
	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end ; 'Z'
	je	short fuE	; 'Z' means this was the last MCB... that's it.

	;NextMCB es,ax		; Go on forward.
	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax

	jmp	short fu10
fuE:	
	stc
fuX:
	; 01/01/2023
	;pop	dx
	; 02/01/2023
	pop	cx ; *
	;pop	ax		; The address is already in ES.
	retn

; -----------------------------------------------------------------------------
;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
; ERROR:    Carry set if couldn't reach UMB (0 or too high)
; USES:     Flags, ES
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
BigFree:
	; 01/01/2023
	;push	bx
	push	cx

	call	findUMB			; Returns with CF if err, else ES==MCB
	jc	short bfX		; (would be "jc bfE"; it just does stc)

	xor	bx,bx			; Segment address of largest free MCB
	xor	cx,cx			; Size of largest free MCB

; ---------------------------------------------
; BF10--ES - Current MCB address
;       BX - Address of largest free MCB so far
;       CX - Size of largest free MCB so far
; ---------------------------------------------

bf10:	
	call	isSysMCB		; If we've left the MCB, we're done.
	jz	short bf30

	;call	isFreeMCB		; Returns with ZF set if owner is 0
	or	word [es:ARENA.OWNER],0
	jnz	short bf20

	mov	ax,[es:ARENA.SIZE]
	;cmp	cx,[es:ARENA.SIZE]	; Compare sizes...
	cmp	cx,ax
	jg	short bf20		; Unless we're bigger,

	mov	bx,es			; Store this new element's address,
	;mov	cx,[es:ARENA.SIZE]	; and its size.
	mov	cx,ax

bf20:	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end	; 'Z'
	jz	short bf30		; 'Z' means this was the last MCB.

	;NextMCB es,ax		; Go on forward.
	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax

	jmp	short bf10

bf30:	mov	es,bx			; Return the address
	mov	ax,cx			; Return the size
	or	bx,bx
	jnz	short bfX		; (if size==0, there's nothing free)
bfE:	
	stc
bfX:
	pop	cx
	; 01/01/2023
	;pop	bx
	retn

; -----------------------------------------------------------------------------
;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
; -----------------------------------------------------------------------------
; ENTRY:    AL should be to a valid UMB number
; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

	; 02/01/2023 - Retro DOS v4.2

isSpecified:
	; 02/01/2023
	;push	ax

	xor	bh,bh
	mov	bl,al

	;getdata al,DS:UmbUsed[bx]
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	al,[bx+UmbUsed]
	;pop	ds
	
	;mov	al,[cs:bx+UmbUsed]
	; 02/01/2023
	; ds = cs
	mov	al,[bx+UmbUsed]

	or	al,al			; Sets ZF if al==0 (ie, if unspecified)

	; 02/01/2023
	pop	ax
	retn

; -----------------------------------------------------------------------------
;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
; -----------------------------------------------------------------------------
; ENTRY:    AX == new size, ES:0 == current MCB
; EXIT:     None; MCB broken if carry clear
; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
; USES:     Flags
; -----------------------------------------------------------------------------
; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
; the specified new size, the split is useless; if it's only 0x10 bytes, that
; 0x10 will be used to make a header that mentions a 0-byte free space, and
; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
; minimum for performing a split.
; -----------------------------------------------------------------------------

MIN_SPLIT_SIZE	equ	20h

	; 02/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

shrinkMCB:
	;pushreg <bx,cx,es>
	; 02/01/2023
	;push	bx
	push	cx
	push	es

	mov	bx,ax			; Move things around... and
	; 02/01/2023
	;mov	ax,es			; save this one for later.

	mov	cx,[es:ARENA.SIZE]
	; 02/01/2023
	mov	ax,cx 

	sub	ax,MIN_SPLIT_SIZE ; 32
	;sub	cx,MIN_SPLIT_SIZE ; 32
	;;cmp	bx,cx			; {New size} vs {Current Size-20h}
	;ja	short smE		; if wanted_size > cur-20h, abort.
	; 18/12/2022
	;cmp	cx,bx
	; 02/01/2023
	cmp	ax,bx
	jb	short smE ; (*)

	mov	dl,[es:ARENA.SIGNATURE]
	
	;mov	cx,[es:ARENA.SIZE]
	; 02/01/2023
	mov	ax,es

	mov	[es:ARENA.SIZE],bx
	mov	byte [es:ARENA.SIGNATURE],'M'

	add	ax,bx
	inc	ax
	mov	es,ax			; Move to new arena area

	mov	ax,cx
	sub	ax,bx
	; 12/12/2022
	; ax > 0
	dec	ax			; And prepare the new size

	; 18/12/2022
	mov	[es:ARENA.SIGNATURE],dl
	;mov	word [es:ARENA.OWNER],0 ; (**)
	mov	[es:ARENA.SIZE],ax
	;mov	ax,'  ' ; 2020h
	;mov	[es:ARENA.NAME+0],ax ; (**)
	;mov	[es:ARENA.NAME+2],ax ; (**)
	;mov	[es:ARENA.NAME+4],ax ; (**)
	;mov	[es:ARENA.NAME+6],ax ; (**)

	; 18/12/2022
	call	freeMCB	; (**)

	; 12/12/2022
	; cf=0
	;clc
	; 18/12/2022
	;jmp	short smX
smE:	
	; 18/12/2022
	; cf=1 (*)
	;stc
smX:	
	;popreg	<es,cx,bx>
	pop	es
	pop	cx
	; 02/01/2023
	;pop	bx
	retn

; -----------------------------------------------------------------------------
;*** hideUMB? - hides as appropriate the UMB in CL
; -----------------------------------------------------------------------------
; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
; EXIT:     None; UMB is hidden as necessary
; ERROR:    None
; USES:     Flags, AX, CX
; -----------------------------------------------------------------------------
; PRIMARY LOGIC:
;
; If the UMB is specified in the DH/LH statement, then:
;    If the largest free segment is too small (check specified size), then:
;       Pretend it wasn't ever specified, and fall out of this IF.
;    Else, if largest free segment is LARGER than specified size, then:
;       If /S was given on the command-line, then:
;          Break that element into two pieces
;          Set a flag that we're shrinking
;       Endif
;    Endif
; Endif
; If the UMB is NOT specified (or was removed by the above):
;    Hide all free elements in the UMB
;    If the flag that we're shrinking was set, then:
;       UN-hide the lower portion of the shrunken UMB
;    ENDIF
; ENDIF
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3426h)
_hideUMB_:
	; 02/01/2023
	; ds = cs

	; 01/01/2023
	;push	bx
	;push	dx
	push	es

	mov	al,cl
	call	isSpecified	; Returns ZF set if al's umb was NOT specified
	jz	short hu_20

	mov	al,cl		; Retrieve the size of the largest
	call	BigFree		; free element in AX; put its address in ES
	jc	short hu_20	; Oops. Errors mean skip this part.

	push	ax		; TOS==size of BigFree in UMB (popped as BX)
	mov	al,cl		; Retrieve the user's specified
	call	GetSize		; minimum size for this umb (into AX)
	pop	bx		; Now BX==BigFree, AX==Specified Size

	or	ax,ax		; If they didn't specify one,
	jz	short hu_20	; Skip over all this.

	cmp	ax,bx		; Ah... if (specified > max free)
	jbe	short hu_10

	mov	al,cl		;  Then mark that UMB as unused. Nya nya.
	call	unMarkUMB
	jmp	short hu_20
hu_10:	
	;call	isTiny		; Returns ZF clear if user specified /S
	;jz	short hu_20
	; 02/01/2023
;isTiny:
	;mov	al,[fUmbTiny] ; ds = cs
	;or	al,al
	or	byte [fUmbTiny],0
	jz	short hu_20

	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
	jc	short hu_20	; Ah... if didn't shrink after all, skip this:

	mov	dx,es
	jmp	short hu_30	; Skip the spec check.. we wanna hide this one.

hu_20:	mov	ax,cx
	call	isSpecified	; If they specified this UMB, we're done...
	jnz	short hu_X	; so leave.

	xor	dx,dx
hu_30:	
	mov	al,cl

	call	hideUMB		; Hides everything in UMB #al

	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
	jz	short hu_X	; So we should leave.

	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
	call	unHideMCB	; Un-hides the lower portion of that MCB.
hu_X:	
	pop	es
	; 01/01/2023
	;pop	dx
	;pop	bx
	retn

; -----------------------------------------------------------------------------
;*** UnFreeze - Marks FROZEN elements as FREE
; -----------------------------------------------------------------------------
; Entry:  None
; Exit:   None; all 8+FROZEN elements are marked as FREE, from any UMB.
; Error:  None
; Uses:   Flags
; -----------------------------------------------------------------------------

	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)

UnFreeze:
	; 03/01/2023
	;push	ax
	push	es

	call	UmbHead		; Returns with carry if err, else ES == MCB
	jc	short ufX

	mov	es,ax

; ------------------------------
; UF10--ES - Current MCB address
; ------------------------------

uf10:	call	isFrozMCB	; Returns with ZF set if MCB is FROZEN
	jnz	short uf20
	call	unHideMCB
uf20:	
	mov	al,[es:ARENA.SIGNATURE]

	cmp	al,arena_signature_end ; 'Z'
	jz	short ufX	; 'Z' means this was the last MCB... that's it.

	;NextMCB es,ax		; Go on forward.
	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax

	jmp	short uf10
ufX:	
	pop	es
	; 03/01/2023
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** isFrozMCB - returns with ZF set if current MCB (ES:0) is FROZEN
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is frozen, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isFrozMCB:
	;push	ax

	;mov	ax,[es:ARENA.OWNER]	; Check the owner...
	;cmp	ax,SystemPSPOwner	; 8 (for US OR Japan) is valid
	cmp	word [es:ARENA.OWNER],SystemPSPOwner
	jne	short ifmX

	;mov	ax,[es:ARENA.NAME+0]
	;cmp	ax,'FR' ; 5246h
	cmp	word [es:ARENA.NAME+0],'FR'
	jne	short ifmX
	;mov	ax,[es:ARENA.NAME+2]
	;cmp	ax,'OZ' ; 5A4Fh
	cmp	word [es:ARENA.NAME+2],'OZ'
	jne	short ifmX
	;mov	ax,[es:ARENA.NAME+4]
	;cmp	ax,'EN' ; 4E45h
	cmp	word [es:ARENA.NAME+4],'EN'
	jne	short ifmX
	;mov	ax,[es:ARENA.NAME+6]
	;cmp	ax,'  ' ; 2020h
	cmp	word [es:ARENA.NAME+6],'  '
ifmX:	
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** frezMCB - marks as 8+FROZEN the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB frozen
; ERROR:    None
; USES:     None
; -----------------------------------------------------------------------------

frezMCB:
	mov	word [es:ARENA.OWNER],SystemPSPOwner ; 8
	mov	word [es:ARENA.NAME+0],'FR'
	mov	word [es:ARENA.NAME+2],'OZ'
	mov	word [es:ARENA.NAME+4],'EN'
	mov	word [es:ARENA.NAME+6],'  '
	retn

; -----------------------------------------------------------------------------
;*** FreezeUM - Marks FROZEN all UM elements now FREE, save those in load UMB
; -----------------------------------------------------------------------------
; Entry:  None
; Exit:   None; all free elements not in load UMB marked as 8+FROZEN
; Error:  None
; Uses:   Flags
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2  
FreezeUM:
	; 01/01/2023
	;push	ax
	;push	cx
	;push	dx
	push	es

	;;call	GetLoadUMB
	; 01/01/2023
	; ds = cs
	;mov	al,[cs:UmbLoad] ; 19/04/2019 - Retro DOS v4.0
	mov	al,[UmbLoad] 	

	xor	ah,ah		; Zap ah, so al==ax
	mov	dx,ax		; Store the load UMB in DX, so we can skip it

	call	UmbHead		; Returns first UMB segment in AX
	mov	es,ax
	xor	cx,cx		; Pretend we're on UMB 0 for now...

; -----------------------------------------
; FUM10--ES - Current MCB address
;        CX - Current UMB number
;        DX - UMB number to skip (load UMB)
; -----------------------------------------

fum10:	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
	jnz	short fum20

	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
fum20:	
	cmp	cx,dx		; If this is the load UMB, we don't want to
	je	short fum30	; freeze anything... so skip that section.

	;call	isFreeMCB	; Oh. If it's not free, we can't freeze it
	or	word [es:ARENA.OWNER],0
	jnz	short fum30	; either.

	call	frezMCB
fum30:	
	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end ; 'Z'
	je	short fumX	; 'Z' means this was the last MCB... that's it.

	;NextMCB es, ax		; Go on forward.
	mov     ax,es
	;add	ax,[es:3]
	add     ax,[es:ARENA.SIZE]
	inc     ax
	mov     es,ax
	
	jmp	short fum10

fumX:	pop	es
	; 01/01/2023
	;pop	dx
	;pop	cx
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     Carry is clear if UMBs are available, or set if they are not
; ERROR:    None
; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
UmbTest:
	; 01/01/2023
	;push	ax
	push	bx ; *
	;push	ds
	push	es ; **

	; 01/01/2023
	; ds = cs

	call	fm_link			; Link in UMBs (if not already linked)
	call	WalkMem			; Check to see if they're really linked
	pushf				; And remember what we found out
	call	fm_unlink		; Unlink UMBs (if WE have linked 'em)
	popf				; And restore what we found out.

	pop	es ; **
	; 01/01/2023
	;pop	ds
	pop	bx ; *
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3541h)

WalkMem:
	;push	ax ; ?
	;push	bx ; ?
	;;push	ds ; ? ; 01/01/2023 (MSDOS 6.21 IO.SYS, SYSINIT:352Fh)
	;push	es ; ? no need to save contents of these registers ?
		   	
	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
	int	21h

	mov	ax,[es:bx-2]
	mov	es,ax

; ------------------------------
; UM10: ES = Current MCB pointer
; ------------------------------

um10:	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end ; 'Z'
	je	short um20		; If signature == 'Z', hay no more.

	;NextMCB es,bx			; Move to the next MCB

	mov     bx,es
	;add	bx,[es:3]
	add     bx,[es:ARENA.SIZE]
	inc     bx
	mov     es,bx
		
	jmp	short um10		; And restart the loop.
um20:	
	mov	ax,es

	cmp	ax,9FFFh		; This sets CF iff ax < 9FFF.

	;pop	es ; ?
	;;pop	ds ; ? ; 01/01/2023 (MSDOS 6.21 IO.SYS, SYSINIT:353Dh)
	;pop	bx ; ?
	;pop	ax ; ?
	
	retn

; -----------------------------------------------------------------------------
;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
; -----------------------------------------------------------------------------
; ENTRY:    fm_umb == 1 : leave linked, else unlink
; EXIT:     None
; ERROR:    None
; USES:     AX, BX
; -----------------------------------------------------------------------------

	; 01/01/2023 - Retro DOS v4.2
hl_unlink:
	xor	bh,bh

	;getdata bl,fm_umb		; Restore original link-state
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	bl,[fm_umb]
	;pop	ds

	; 01/01/2023
	; ds = cs
	;mov	bl,[cs:fm_umb]
	mov	bl,[fm_umb]

	mov	ax,DOS_SET_UMBLINK ; 5803h
	int	21h
	retn

; ----------------------------------------------------------------------
; HIGHEXIT.INC (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 09/04/2019 - Retro DOS v4.0

;   Module:   HIGHEXIT.INC - Code executed after LoadHigh or DeviceHigh
;   Date:     May 14, 1992

;   Modification log:
;
;     DATE    WHO      DESCRIPTION
;   --------  -------  --------------------------------------------------------
;   05/14/92  t-richj  Original
;   06/21/92  t-richj  Final revisions before check-in

UMB_HeadIdx	equ	8Ch	; Offset from ES (after func52h) to get UMBHead

; -----------------------------------------------------------------------------
;*** UnHideUMBs - Marks HIDDEN elements as FREE
; -----------------------------------------------------------------------------
; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
;               very little to do, as no elelments will be marked as HIDDEN.
; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
; ERROR:  None
; USES:   fInHigh (from highvar.inc), carry flag
; -----------------------------------------------------------------------------

	; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:357Bh)

UnHideUMBs:
	push	ax		; Save ax for what we're about to do

; -----------------------------------------------------------------------------
; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
;    length of time. Those six constitute a check of whether or not we should
;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
;    will destroy the current link-state and memory-allocation strategy after
;    every command execution.
; -----------------------------------------------------------------------------

	;getdata al,fInHigh	; Get InHigh from data segment
	;
	;push	ds
	;push	cs
	;pop	ds
	;mov	al,[fInHigh]
	;pop	ds	

	;mov	al,[cs:fInHigh]
	; 31/12/2022
	; ds = cs
	mov	al,[fInHigh]	

	or	al,al
	jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,

	pop	ax		; then there's nothing to do here... so
	stc			; restore everything and return. Just like
	retn			; that.
uhu10:	
	call	linkumb		; Make sure UMBs are linked in.
	call	FreeUMBs

	;putdata fInHigh,0	; We're leaving, so update fInHigh.
	;
	;push	es
	;push	cs
	;pop	es
	;mov	byte [es:fInHigh],0
	;pop	ds

	; 31/12/2022
	; ds = cs	
	;mov	byte [cs:fInHigh],0
	mov	byte [fInHigh],0

	;call	he_unlink	; Unlink UMBs
	; 31/12/2022
;;he_unlink:
	xor	bh,bh

	;getdata bl,fm_umb	; Restore original link-state
	;mov	bl,[cs:fm_umb]	
	mov	bl,[fm_umb]

	mov	ax,DOS_SET_UMBLINK ; 5803h
	int	21h
	;;retn

	pop	ax
	; 12/12/2022
	;clc	; 12/12/2022 (this clc may not be necessary!?)
	retn

; 31/12/2022
;%if 0
;
;; -----------------------------------------------------------------------------
;;*** he_unlink - unlinks UMBs if fm_umb is set to 0
;; -----------------------------------------------------------------------------
;; ENTRY:    fm_umb == 1 : leave linked, else unlink
;; EXIT:     None
;; ERROR:    None
;; USES:     AX, BX
;; -----------------------------------------------------------------------------
;
;he_unlink:
;	xor	bh, bh
;
;	;getdata bl, fm_umb	; Restore original link-state
;	mov	bl,[cs:fm_umb]	
;
;	mov	ax,DOS_SET_UMBLINK ; 5803h
;	int	21h
;	retn
;
;%endif

; -----------------------------------------------------------------------------
;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     None; HIDDEN memory elements returned to FREE
; ERROR:    None (ignore CF)
; USES:     Flags
; -----------------------------------------------------------------------------

FreeUMBs:
	push	ax
	push	es

	call	HeadUmb		; Returns with carry if err, else ES == MCB
	jc	short fusX

	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
fus10:	
	call	isHideMCB	; Returns with ZF set if owner is 0
	jnz	short fus20
	call	freeMCB
fus20:	   
	mov	al,[es:ARENA.SIGNATURE]
	cmp	al,arena_signature_end ; 'Z'
	jz	short fusX	; That means this was the last MCB--that's it.

	mov	ax,es
	add	ax,[es:ARENA.SIZE]
	inc	ax
	mov	es,ax		; Go on forward.

	jmp	short fus10
fusX:	
	pop	es
	pop	ax
	retn

; -----------------------------------------------------------------------------
;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     ZF set if MCB is hidden, else !ZF
; ERROR:    None
; USES:     Flags
; -----------------------------------------------------------------------------

isHideMCB:
	;push	ax

	cmp	word [es:ARENA.OWNER],SystemPSPOwner ; If the owner's SYSTEM
	jne	short ihm_x				; then check for HIDDEN

	;mov	ax,[es:ARENA.NAME]
	;cmp	ax,'HI' ; 4948h
	cmp	word [es:ARENA.NAME+0],'HI'
	jne	short ihm_x
	;mov	ax,[es:ARENA.NAME+2]
	;cmp	ax,'DD' ; 4444h
	cmp	word [es:ARENA.NAME+2],'DD'
	jne	short ihm_x
	;mov	ax,[es:ARENA.NAME+4]
	;cmp	ax,'EN' ; 4E45h
	cmp	word [es:ARENA.NAME+4],'EN'
	jne	short ihm_x
	;mov	ax,[es:ARENA.NAME+6]
	;cmp	ax,'  ' ; 2020h
	cmp	word [es:ARENA.NAME+6],'  '
ihm_x:	
	;pop	ax
	retn

; -----------------------------------------------------------------------------
;*** freeMCB - marks as free the MCB at ES:0
; -----------------------------------------------------------------------------
; ENTRY:    ES:0 should point to an MCB
; EXIT:     None; MCB free'd
; ERROR:    None
; USES:     AX
; -----------------------------------------------------------------------------

freeMCB:
	mov	word [es:ARENA.OWNER],0
	mov	ax,'  ' ; mov ax,2020h ; 31/12/2022
	mov	[es:ARENA.NAME+0],ax
	mov	[es:ARENA.NAME+2],ax
	mov	[es:ARENA.NAME+4],ax
	mov	[es:ARENA.NAME+6],ax
	retn

; -----------------------------------------------------------------------------
;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
; -----------------------------------------------------------------------------
; ENTRY:  Nothing
; EXIT:   AX contains 0x9FFF for most systems
; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
; USES:   Flags, AX
; -----------------------------------------------------------------------------

HeadUmb:
	; 13/05/2019

	;push	si ; ?
	;push	ds ; ?
	;push	es
	;push	bx ; *

	; 09/04/2019
	; !!! No need to save es,bx,ds,si above !!! (es,bx are changed here)

	mov	ah,GET_IN_VARS		; Call int 21h, function 52h...
	int	21h
			; DOS - 2+ internal - GET LIST OF LISTS
			; Return: ES:BX -> DOS list of lists
	;mov	ax,[es:8Ch]
	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008C
	cmp	ax,0FFFFh
	;je	short xhu_e		; If it's 0xFFFF, it's an error...

	;clc				; Else, it isn't.
	;jmp	short xhu_x
xhu_e:	
	;stc
	cmc	; 09/04/2019 - Retro DOS v4.0 ; *
xhu_x:	
	;pop	bx ; *
	;pop	es	
	;pop	ds ; ?
	;pop	si ; ?
	retn

; -----------------------------------------------------------------------------
;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
; -----------------------------------------------------------------------------
; ENTRY:    None
; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
; ERROR:    None
; USES:     AX, BX, fm_umb
; -----------------------------------------------------------------------------

linkumb:
	mov	ax,DOS_GET_UMBLINK ; 5802h
	int	21h			; Current link-state is now in al

	or	al,al			; BUGBUG: proper check?
	jnz	short lumbX		; Jumps if UMBs already linked in

	mov	ax,DOS_SET_UMBLINK ; 5803h
	mov	bx,1
	int	21h
lumbX:
	retn

;%endif

; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; (SYSINIT:2B5Fh)

; ----------------------------------------------------------------------
; SYSCONF.ASM (MSDOS 6.0 - 1991) 	
; ----------------------------------------------------------------------
; 09/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : InitDevLoad
;
;	Input : DeviceHi = 0 indicates load DD in low memory
;			 = 1 indicates load in UMB:
;		           ConvLoad = 0 indicates a new-style load (see below)
;		                    = 1 indicates a DOS 5-style load
;		DevSize  = Size of the device driver file in paras
;
;	Output : none
;
;	Initializes DevLoadAddr, DevLoadEnd & DevEntry.
;	Also sets up a header for the Device driver entry for mem utility
;
;----------------------------------------------------------------------------
; For a "new-style load", we break off the current DevEntry and link the umbs
; as we see fit, using HideUMBs (and UnHideUMBs at exit, though _it_ decides
; whether it's entitled to do anything). HideUMBs uses the chart built by
; ParseVar to determine which UMBs to leave FREE, and which not.
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:364Ah)
InitDevLoad:
	; 01/01/2023
	;push	es ; *

	; 11/12/2022
	; ds = cs
	cmp	byte [DeviceHi],0
	;cmp	byte [cs:DeviceHi],0	; Are we loading in UMB ?
	;je	short InitForLo		; no, init for lo mem
	je	short initforlo_x ; 09/04/2019

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
; %if 0
	; 01/01/2023
	cmp	byte [ConvLoad],1	; Are we loading as per DOS 5?
	;cmp	byte [cs:ConvLoad],1	; Are we loading as per DOS 5?
	je	short InitForConv

; There are two stages to preparing upper-memory; first, we mark as 8+HIDDEN
; any areas not specified on the /L:... chain. Second, we mark as 8+FROZEN
; any areas left in upper-memory, except for elements in the load UMB...
; we then malloc space as per Dos-5 style, and mark as free any spaces which
; are 8+FROZEN (but leave 8+HIDDEN still hidden). The load is performed,
; and UnHideUMBs later on marks all 8+HIDDEN as free.

	call	ShrinkUMB		; Stop using the old device arena

	call	HideUMBs		; Mark up the UM area as we see fit
	call	FreezeUM		; Hide everything BUT the load area
	call	GetUMBForDev		; And grab that load area as needed
	pushf
	call	UnFreeze		; Then unhide everything frozen
	popf

	jc	short InitForLo		; (if carry, it's loading low)

	jmp	short InitForHi

;%endif ; 01/11/2022

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2B67h)
InitForConv:
	; 11/12/2022
	; ds = cs
	call	SpaceInUMB		; Do we have space left in the
					;  current UMB ?
	jnc	short InitForHi		; yes, we have
	call	ShrinkUMB		; shrink the current UMB in use
	call	GetUMBForDev		; else try to allocate new UMB
	jc	short InitForLo		; we didn't succeed, so load
					;  in low memory
InitForHi:
	; 11/12/2022
	; ds = cs
	;mov	ax,[cs:DevUMBFree]	; get Para addr of free mem
	;mov	dx,[cs:DevUMBAddr]	; UMB start addr
	;add	dx,[cs:DevUMBSize]	; DX = UMB End addr
	mov	ax,[DevUMBFree]
	mov	dx,[DevUMBAddr]
	add	dx,[DevUMBSize]
	jmp	short idl1

InitForLo:
	; 11/12/2022
	; ds = cs
	;mov	byte [cs:DeviceHi],0	; in case we failed to load
	mov	byte [DeviceHi],0
initforlo_x:
	; 11/12/2022
	; ds = cs
					;  into UMB indicate that
					;  we are loading low
	;mov	ax,[cs:memhi]		; AX = start of Low memory
	;mov	dx,[cs:ALLOCLIM]	; DX = End of Low memory
	mov	ax,[memhi]
	mov	dx,[ALLOCLIM]
idl1:
	call	DevSetMark		; setup a sub-arena for DD
	; 11/12/2022
	; ds = cs
	;mov	[cs:DevLoadAddr],ax	; init the Device load address
	;mov	[cs:DevLoadEnd],dx	; init the limit of the block
	;mov	word [cs:DevEntry],0	; init Entry point to DD
	;mov	[cs:DevEntry+2],ax
	mov	[DevLoadAddr],ax
	mov	[DevLoadEnd],dx
	mov	word [DevEntry],0
	mov	[DevEntry+2],ax
	; 01/01/2023
	;pop	es ; *
	retn

;----------------------------------------------------------------------------
;
; procedure : SpaceInUMB?
;
;	Input : DevUMBAddr, DevUMBSize, DevUMBFree & DevSize
;	Output : Carry set if no space in UMB
;		 Carry clear if Space is available for the device in
;		   current UMB
;
;----------------------------------------------------------------------------

SpaceInUMB:
	; 11/12/2022
	; ds = cs
	;mov	ax,[cs:DevUMBSize]
	;add	ax,[cs:DevUMBAddr]	; End of UMB
	;sub	ax,[cs:DevUMBFree]	; - Free = Remaining space
	mov	ax,[DevUMBSize]
	add	ax,[DevUMBAddr]		; End of UMB
	sub	ax,[DevUMBFree]		; - Free = Remaining space
	; 11/12/2022
	;or	ax,ax			; Nospace ?
	;jnz	short spcinumb1
	;stc
	;retn
	; 11/12/2022
	cmp	ax,1
	jb	short spcinumb2	; cf=1
spcinumb1:
	dec	ax			; space for sub-arena
	; 11/12/2022
	; ds = cs
	cmp	ax,[DevSize]
	;cmp	ax,[cs:DevSize]		; do we have space ?
spcinumb2:
	retn

;----------------------------------------------------------------------------
;
; procedure : PrepareMark
;
;	Input : AX==Address of MCB (not addr of free space), BX==Size
;	Output : None; MCB marked appropriately and DevUMB* set as needed.
;
;----------------------------------------------------------------------------

;	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;
;PrepareMark:
;	push	ds
;	mov	ds,ax
;	mov	word [ARENA.OWNER],8
;	mov	word [ARENA.NAME],'SD' ; 4453h
;	pop	ds
;
;	inc	ax
;	mov	[cs:DevUMBAddr],ax
;	mov	[cs:DevUMBFree],ax
;	mov	[cs:DevUMBSize],bx	; update the UMB Variables
;	retn

;----------------------------------------------------------------------------
;
; procedure : GetUMBForDev
;
;	Input : DevSize
;	Output : Carry set if couldn't allocate a UMB to fit the
;		 the device.
;		 If success carry clear
;
;	Allocates the biggest UMB for loading devices and updates
;	DevUMBSize, DevUMBAddr & DevUMBFree if it succeeded in allocating
;	UMB.
;
;	This routine relies on the fact that all of the low memory
;	is allocated, and any DOS alloc calls should return memory
;	from the UMB pool.
;
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2BC6h)

GetUMBForDev:
	; 11/12/2022
	; ds = cs
	mov	bx,0FFFFh
	mov	ax,4800h
	int	21h
		; DOS - 2+ - ALLOCATE MEMORY
		; BX = number of 16-byte paragraphs desired

	or	bx,bx
	jz	short gufd_err

	dec	bx
	; 11/12/2022
	; ds = cs
	cmp	[DevSize],bx
	;cmp	[cs:DevSize],bx
	ja	short gufd_err
	inc	bx

	mov	ax,4800h
	int	21h
	jc	short gufd_err

	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;dec	ax
	;call	PrepareMark
	;
PrepareMark:
	push	ds
	dec	ax
	mov	ds,ax
	mov	word [ARENA.OWNER],8
	mov	word [ARENA.NAME],'SD' ; 4453h
	inc	ax
	pop	ds
	; 11/12/2022
	; ds = cs
	;mov	[cs:DevUMBSize],bx	; update the UMB Variables
	;mov	[cs:DevUMBAddr],ax
	;mov	[cs:DevUMBFree],ax
	mov	[DevUMBSize],bx		; update the UMB Variables
	mov	[DevUMBAddr],ax
	mov	[DevUMBFree],ax
	;
	; 11/12/2022
	; cf=0
	;clc				; mark no error
	retn
gufd_err:
	xor	ax,ax ; 0
	; 11/12/2022
	; ds = cs
	;mov	[cs:DevUMBSize],ax	; erase the previous values
	;mov	[cs:DevUMBAddr],ax
	;mov	[cs:DevUMBFree],ax
	mov	[DevUMBSize],ax		; erase the previous values
	mov	[DevUMBAddr],ax
	mov	[DevUMBFree],ax
	stc
	retn

;----------------------------------------------------------------------------
;
; procedure : DevSetMark
;
;	Input : AX - Free segment were device is going to be loaded
;	Output : AX - Segment at which device can be loaded (AX=AX+1)
;
;	Creates a sub-arena for the device driver
;	puts 'D' marker in the sub-arena
;	Put the owner of the sub-arena as (AX+1)
;	Copies the file name into sub-arena name field
;
;	Size field of the sub-arena will be set only at succesful
;	completion of Device load.
;
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2C13h)

DevSetMark:
	push	es
	; 03/01/2023
	;push	di
	push	ds
	push	si
	mov	es,ax
	mov	byte [es:devmark.id],devmark_device ; 'D'
	inc	ax
	mov	[es:devmark.seg],ax

;-------------- Copy file name

	push	ax			; save load addr
	lds	si,[cs:bpb_addr]	; command line is still there

	mov	di,si
	cld
dsm_again:
	lodsb
	cmp	al,':'
	jne	short isit_slash
	mov	di,si
	jmp	short dsm_again
isit_slash:
	cmp	al, '\'
	jne	short isit_null
	mov	di,si
	jmp	short dsm_again
isit_null:
	or	al,al
	jnz	short dsm_again
	mov	si,di

	mov	di,devmark.filename ; 8
	mov	cx,8			; maximum 8 characters
dsm_next_char:
	lodsb
	or	al, al
	jz	short blankout
	cmp	al, '.'
	je	short blankout
	stosb
	loop	dsm_next_char
blankout:
	jcxz	dsm_exit
	mov	al, ' '
	rep	stosb			; blank out the rest
dsm_exit:
	pop	ax			; restore load addr
	pop	si
	pop	ds
	; 03/01/2023
	;pop	di
	pop	es
	retn

;----------------------------------------------------------------------------
;
; procedure : SizeDevice
;
;	Input : ES:SI - points to device file to be sized
;
;	Output : Carry set if file cannot be opened or if it is an OS2EXE file
;
;	Calculates the size of the device file in paras and stores it
;	in DevSize
;
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
SizeDevice:
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022 ; *
	push	ds ; *
	push	es
	pop	ds
	mov	dx,si			; ds:dx -> file name
	mov	ax,3D00h		; open
	int	21h
	jc	short sd_err		; open failed

	mov	bx,ax			; BX - file handle
	mov	ax,4202h		; seek
	xor	cx,cx
	mov	dx,cx			; to end of file
	int	21h
	jc	short sd_close		; did seek fail (impossible)
	add	ax,15			; para convert
	adc	dx,0
	test	dx,0FFF0h		; size > 0ffff paras ?
	jz	short szdev1		; no
	mov	word [cs:DevSize],0FFFFh ; invalid device size
					; assuming that we fail later
	jmp	short sd_close
szdev1:
	mov	cl,4			; convert it to paras
	shr	ax,cl
	mov	cl,12
	shl	dx,cl
	or	ax,dx
	;
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	cmp     ax,[cs:DevSizeOption]
	ja      short szdev2
	mov     ax,[cs:DevSizeOption]
	; 12/12/2022
	clc
szdev2:
	mov	[cs:DevSize],ax		; save file size

	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0
	;clc
sd_close:
	pushf				; let close not spoil our
					;  carry flag
	mov	ax,3E00h		; close
	int	21h			; we are not checking for err
	popf
sd_err:
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022 ; *
	pop     ds ; *
	retn

;----------------------------------------------------------------------------
;
; procedure : ExecDev
;
;	Input : ds:dx -> device to be executed
;		DevLoadAddr - contains where device has to be loaded
;
;	Output : Carry if error
;		 Carry clear if no error
;
;	Loads a device driver using the 4b03h function call
;
;----------------------------------------------------------------------------

	; 01/11/2022
ExecDev:
	mov	bx,[cs:DevLoadAddr]
	mov	[cs:DevExecAddr],bx	; Load the parameter block
					;  block for exec with
					;  Load address
	mov	[cs:DevExecReloc],bx
	mov	bx,cs
	mov	es,bx
	mov	bx,DevExecAddr		;es:bx points to parameters
	mov	al,3	; (load program only)
	mov	ah,EXEC ; 4Bh
	int	21h			;load in the device driver
 		; DOS - 2+ - LOAD OR EXECUTE (EXEC)
		; DS:DX -> ASCIZ filename
		; ES:BX -> parameter block
		; AL = subfunction 
	retn

;----------------------------------------------------------------------------
;
; procedure : RetFromUM
;
;	Input : None
;	Output : ConvLoad set if didn't previously call HideUMBs
;		 ConvLoad clear if did.
;
;	Prepares memory for more devices after returning from loading one
;	using the DOS 6 options (/L:... etc).
;
;----------------------------------------------------------------------------

; 31/12/2022 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
;  (SYSINIT:37D1h)

; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
RetFromUM:
	; 31/12/2022
	; ds = cs
	pushf
	;mov	byte [cs:ConvLoad],1
	mov	byte [ConvLoad],1
	call	UnHideUMBs
	jc	short rfUM1		; Skip this if didn't HideUMBs
	; 31/12/2022
	; ds = cs
	;mov	byte [cs:ConvLoad],0
	mov	byte [ConvLoad],0
rfUM1:	
	popf
	retn

;%endif ; 01/11/2022

;----------------------------------------------------------------------------
;
; procedure : RemoveNull
;
;	Input : ES:SI points to a null terminated string
;
;	Output : none
;
;	Replaces the null at the end of a string with blank
;
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2CCEh)
RemoveNull:
	; 11/12/2022
	; ds = cs
rn_next:
	mov	bl,[es:si]
	or	bl,bl			; null ?
	jz	short rn_gotnull
	inc	si			; advance the pointer
	jmp	short rn_next
rn_gotnull:
	; 11/12/2022
	mov	bl,[DevSavedDelim]
	;mov	bl,[cs:DevSavedDelim]
	mov	[es:si],bl		; replace null with blank
	; 02/11/2022
; 11/12/2022
rba_ok:		; 10/04/2019
	retn

;----------------------------------------------------------------------------
;
; procedure : RoundBreakAddr
;
;	Input : DevBrkAddr
;	Output : DevBrkAddr
;
;	Rounds DevBrkAddr to a para address so that it is of the form xxxx:0
;
;----------------------------------------------------------------------------

RoundBreakAddr:
	mov	ax,[cs:DevBrkAddr]
	call	ParaRound
	add	[cs:DevBrkAddr+2],ax
	mov	word [cs:DevBrkAddr],0
	mov	ax,[cs:DevLoadEnd]
	cmp	[cs:DevBrkAddr+2],ax
	jbe	short rba_ok
	jmp	mem_err
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
;rba_ok:
;	retn

;----------------------------------------------------------------------------
;
; procedure : DevSetBreak
;
;	Input : DevBrkAddr
;	Output : Carry set if Device returned Init failed
;		 Else carry clear
;
;----------------------------------------------------------------------------

DevSetBreak:
	push	ax

	mov	ax,[cs:DevBrkAddr+2]	 ;remove the init code
	cmp	byte [cs:multdeviceflag],0
	jne	short set_break_continue ;do not check it.
	cmp	ax,[cs:DevLoadAddr]
	jne	short set_break_continue ;if not same, then o.k.

	;cmp	word [cs:DevBrkAddr],0
	;je	short break_failed	;[DevBrkAddr+2]=[memhi] & [DevBrkAddr]=0
	; 12/12/2022
	cmp	word [cs:DevBrkAddr],1
	jb	short break_failed

set_break_continue:
	call	RoundBreakAddr
	; 12/12/2022
	clc
break_failed:
	pop	ax
	;clc
	retn

	; 12/12/2022
;break_failed:
	;pop	ax
	;stc
	;retn

;----------------------------------------------------------------------------
;
; procedure : DevBreak
;
;	Input : DevLoadAddr & DevBrkAddr
;	Output : none
;
;	Marks a succesful install of a device driver
;	Sets device size field in sub-arena &
;	Updates Free ptr in UMB or adjusts memhi
;
;----------------------------------------------------------------------------

	; 11/12/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
DevBreak:
	;push	ds ; 11/12/2022

	; 11/12/2022
	push	cs
	pop	ds
	;mov	ax,[cs:DevLoadAddr]
	;mov	bx,[cs:DevBrkAddr+2]
	mov	ax,[DevLoadAddr]
	mov	bx,[DevBrkAddr+2]
	; 11/12/2022
	push	ds

	dec	ax			; seg of sub-arena
	mov	ds,ax
	inc	ax			; Back to Device segment
	sub	ax,bx
	neg	ax			; size of device in paras
	mov	[devmark.size],ax	; store it in sub-arena
	
	; 11/12/2022
	pop	ds
	; ds = cs
 	
	cmp	byte [DeviceHi],0
	;cmp	byte [cs:DeviceHi],0
	je	short db_lo
	;mov	[cs:DevUMBFree],bx	; update Free ptr in UMB
	;jmp	short db_exit
	; 11/12/2022
	mov	[DevUMBFree],bx
	retn	
db_lo:
	; 11/12/2022
	; ds = cs
	;mov	[cs:memhi],bx
	;mov	word [cs:memlo],0
	mov	[memhi],bx
	mov	word [memlo],0 ; 18/12/2022
db_exit:
	;pop	ds ; 11/12/2022
	retn

; 10/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : ParseSize
;
;	Parses the command line for SIZE= command
;
;	ES:SI = command line to parsed
;
;	returns ptr to command line after SIZE= option in ES:SI
;	updates the DevSizeOption variable with value supplied
;	in SIZE=option
;	Returns carry if the SIZE option was invalid
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2D5Ah)
ParseSize:
	;push	bx
	;mov	bx,si

	; 11/12/2022
	; ds = cs
	;mov	word [cs:DevSizeOption],0 ; init the value
	;mov	[cs:DevCmdLine],si
	;mov	[cs:DevCmdLine+2],es
	mov	word [DevSizeOption],0 ; init the value
	mov	[DevCmdLine],si
	mov	[DevCmdLine+2],es	
	call	SkipDelim
	cmp	word [es:si],'SI' ; 4953h
	jne	short ps_no_size
	cmp	word [es:si+2],'ZE' ; 455Ah
	jne	short ps_no_size
	mov	al,[es:si+4]
	call	delim
	jne	short ps_no_size
	add	si,5
	call	GetHexNum
	jc	short ps_err
	; 11/12/2022
	; ds = cs
	;mov	[cs:DevSizeOption],ax
	mov	[DevSizeOption],ax
	call	SkipDelim
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	bx,si
ps_no_size:	
	;mov	si,bx
	;pop	bx
	clc	; cf=0
	;retn
	; 11/12/2022
ps_err:		; cf=1
sd_ret:		; cf=?
	retn
;ps_err:
	; 02/11/2022
	;pop	bx
	;stc
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
	; cf=1
	;stc
	; 11/12/2022
;sd_ret: 
	; 12/04/2019
	retn

; 12/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : SkipDelim
;
;	Skips delimiters in the string pointed to by ES:SI
;	Returns ptr to first non-delimiter character in ES:SI
;
;----------------------------------------------------------------------------
	
	; 01/11/2022
SkipDelim:
sd_next_char:
	mov	al,[es:si]
	call	delim
	jnz	short sd_ret
	inc	si
	jmp	short sd_next_char ; 01/11/2022
	; 11/12/2022
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;sd_ret:
	;retn

;----------------------------------------------------------------------------
;
; procedure : GetHexNum
;
;	Converts an ascii string terminated by a delimiter into binary.
;	Assumes that the ES:SI points to a Hexadecimal string
;
;	Returns in AX the number number of paras equivalent to the
;	hex number of bytes specified by the hexadecimal string.
;
;	Returns carry in case it encountered a non-hex character or
;	if it encountered crlf
;
;----------------------------------------------------------------------------

; 13/05/2019

	; 036/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:38C5h)

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2DA5h)
GetHexNum:
	xor	ax,ax
	xor	dx,dx
ghn_next:
	mov	bl,[es:si]
	cmp	bl,cr  ; 0Dh
	je	short ghn_err
	cmp	bl,lf  ; 0Ah
	je	short ghn_err
	push	ax
	mov	al,bl
	call	delim
	pop	ax
	; 03/01/2023
	mov	cx, 4
	jz	short ghn_into_paras
	call	GetNibble
	;jc	short ghn_err
	; 11/12/2022
	jc	short ghn_ret ; cf=1
	; 03/01/2023
	;mov	cx,4
ghn_shift1:
	shl	ax,1
	rcl	dx,1
	loop	ghn_shift1
	or	al,bl
	inc	si
	jmp	short ghn_next
ghn_into_paras:
	add	ax,15
	adc	dx,0
	test	dx,0FFF0h
	jnz	short ghn_err
	; 03/01/2023
	;mov	cx,4
ghn_shift2:
	clc
	rcr	dx,1
	rcr	ax,1
	loop	ghn_shift2
	clc
	retn
	; 11/12/2022
ghn_err:
gnib_err:
	stc
ghn_ret:
gnib_ret:
	retn

;----------------------------------------------------------------------------
;
; procedure : GetNibble
;
;	Convert one nibble (hex digit) in BL into binary
;
;	Returns binary value in BL
;
;	Returns carry if BL contains non-hex digit
;
;----------------------------------------------------------------------------

GetNibble:
	cmp	bl,'0'
	;jb	short gnib_err
	; 11/12/2022
	jb	short gnib_ret ; cf=1
	cmp	bl,'9'
	ja	short is_it_hex
	sub	bl,'0'		; clc
	retn
is_it_hex:
	cmp	bl,'A'
	;jb	short gnib_err
	; 11/12/2022
	jb	short gnib_ret ; cf=1
	cmp	bl,'F'
	ja	short gnib_err ; 11/12/2022
	sub	bl,'A'- 10	; clc
	retn
	; 11/12/2022
;gnib_err:
;	stc
;gnib_ret:
;	retn

;============================================================================

; 12/04/2019 - Retro DOS v4.0

; umb.inc (MSDOS 6.0, 1991)
DOS_ARENA	equ 24h		; offset of arena_head var in DOS data segm.
UMB_ARENA	equ 8Ch		; offset of umb_head in DOS data

XMM_REQUEST_UMB	equ 10h
XMM_RELEASE_UMB	equ 11h

;----------------------------------------------------------------------------
;
; procedure : AllocUMB
;
;	Allocate all UMBs and link it to DOS arena chain
;
;----------------------------------------------------------------------------

AllocUMB:
	; 31/12/2022
	; ds = cs
	call	InitAllocUMB		; link in the first UMB
	jc	short au_exit		; quit on error
au_next:
	call	umb_allocate		; allocate
	jc	short au_coalesce
	call	umb_insert		; & insert till no UMBs
	jmp	short au_next
au_coalesce:
	call	umb_coalesce		; coalesce all UMBs
au_exit:
	; 31/12/2022
	; ds = cs
	retn

;----------------------------------------------------------------------------
;
; procedure : InitAllocUMB
;
;----------------------------------------------------------------------------

InitAllocUMB:
	; 31/12/2022
	; ds = cs
	call	IsXMSLoaded
	jnz	short iau_err		; quit on no XMS driver
	mov	ah,52h
	int	21h			; get DOS DATA seg
	; 31/12/2022
	; ds = cs
	;mov	[cs:DevDOSData],es	; & save it for later
	mov	[DevDOSData],es		; & save it for later
	mov	ax,4310h
	int	2Fh
	;mov	[cs:DevXMSAddr],bx	; get XMS driver address
	;mov	[cs:DevXMSAddr+2],es
	mov	[DevXMSAddr],bx		; get XMS driver address
	mov	[DevXMSAddr+2],es	
	; 31/12/2022
	cmp	byte [FirstUMBLinked],0 
	;cmp	byte [cs:FirstUMBLinked],0 ; have we already linked a UMB?
	;jne	short ia_1		; quit if we already did it
	; 12/12/2022
	ja	short ia_1 ; cf=0
	call	LinkFirstUMB		; else link the first UMB
	;jc	short iau_err
	; 12/12/2022
	jc	short iau_err2  ; cf=1
	; 31/12/2022
	; ds = cs
	mov	byte [FirstUMBLinked],0FFh ; mark that 1st UMB linked
	;mov	byte [cs:FirstUMBLinked],0FFh ; mark that 1st UMB linked
ia_1:
	; 12/12/2022
	; cf=0
	;clc
	retn
iau_err:
	stc
iau_err2:
	retn

;-------------------------------------------------------------------------
;
; Procedure Name	: umb_allocate
;
; Inputs		: DS = data
;
; Outputs		: if UMB available
;				Allocates the largest available UMB and 
;			  	BX = segment of allocated block
;				DX = size of allocated block
;				NC
;			  else 
;				CY
;
; Uses			: BX, DX
;
;-------------------------------------------------------------------------

umb_allocate:
	; 31/12/2022
	; ds = cs
	push	ax
	mov	ah,XMM_REQUEST_UMB ; 16
	mov	dx,0FFFFh		; try to allocate largest
					;   possible
	; 31/12/2022
	call	far [DevXMSAddr]
	;call	far [cs:DevXMSAddr]
					; dx now contains the size of
					; the largest UMB
	or	dx,dx
	jz	short ua_err
	
	mov	ah,XMM_REQUEST_UMB ; 16

	; 31/12/2022
	call	far [DevXMSAddr]
	;call	far [cs:DevXMSAddr]

	cmp	ax,1			; Q: was the reqst successful
	jne	short ua_err		; N: error
	;clc
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0
	;clc 
ua_done:
	pop	ax
	retn
ua_err:
	stc
	jmp	short ua_done

;---------------------------------------------------------------------------
;
; Procedure Name	: umb_insert
;
; Inputs		: DOSDATA:UMB_HEAD = start of umb chain
;			: BX = seg address of UMB to be linked in
;			: DX = size of UMB to be linked in paras
;			; DS = data
;
; Outputs		: links the UMB into the arena chain
;
; Uses			: AX, CX, ES, DX, BX
;
;---------------------------------------------------------------------------

umb_insert:
	push	ds

	; 31/12/2022
	; ds = cs

	;mov	ds,[cs:DevDOSData]
	mov	ds,[DevDOSData] ; 31/12/2022 
	;mov	ds,[8Ch]
	mov	ds,[UMB_ARENA]		; es = UMB_HEAD
	mov	ax,ds
	mov	es,ax
ui_next:
	cmp	ax,bx			; Q: is current block above
					;    new block
	ja	short ui_insert		; Y: insert it
					; Q: is current block the
					;    last
	cmp	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
	je	short ui_append		; Y: append new block to chain
					; N: get next block
	mov	ds,ax			; M005
	;call	get_next		; ax = es = next block
	call	_get_next_ ; 13/04/2019 - Retro DOS v4.0
	jmp	short ui_next

ui_insert:
	mov	cx,ds			; ds = previous arena
	inc	cx			; top of previous block

	sub	cx,bx
	neg	cx			; cx = size of used block
	;mov	byte [0],'M'
	mov	byte [ARENA.SIGNATURE],arena_signature_normal ; 'M'
	;mov	word [1],8
	mov	word [ARENA.OWNER],8	; mark as system owned
	;mov	[3],cx
	mov	[ARENA.SIZE],cx	
	;mov	word [8],4353h ; 'SC'
	mov	word [ARENA.NAME],'SC' ; 4353h

; prepare the arena at start of new block

	mov	es,bx
	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
	mov	word [es:ARENA.OWNER],arena_owner_system ; 0
					; mark as free
	sub	dx,2			; make room for arena at
					; start & end of new block
	mov	[es:ARENA.SIZE],dx

; prepare arena at end of new block
	
	add	bx,dx
	inc	bx
	mov	es,bx			; es=arena at top of new block
	inc	bx			; bx=top of new block

					; ax contains arena just above
					; this block
	sub	ax,bx			; ax = size of used block
	
	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
	mov	word [es:ARENA.OWNER],8	; mark as system owned
	mov	[es:ARENA.SIZE],ax	
	mov	word [es:ARENA.NAME],'SC' ; 4353h

	jmp	short ui_done

ui_append:
					; es = arena of last block	
	add	ax,[es:ARENA.SIZE]	; ax=top of last block-1 para
	sub	word [es:ARENA.SIZE],1	; reflect the space we are
					; going to rsrv on top of this 
					; block for the next arena.
	; 13/05/2019
	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal

	mov	cx,ax			; cx=top of prev block-1
	inc	ax
	sub	ax,bx			; ax=top of prev block - 
					;    seg. address of new block
	neg	ax

	mov	es,cx			; ds = arena of unused block

	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal
	mov	word [es:ARENA.OWNER],8	; mark as system owned
	mov	[es:ARENA.SIZE],ax	
	mov	word [es:ARENA.NAME],'SC'

; prepare the arena at start of new block
	mov	es,bx
	mov	byte [es:ARENA.SIGNATURE],arena_signature_end
	mov	word [es:ARENA.OWNER],arena_owner_system
					; mark as free
	dec	dx			; make room for arena
	mov	[es:ARENA.SIZE],dx	
ui_done:
uc_done: ; 31/12/2022 ; *!
	pop	ds
	; ds = cs ; 31/12/2022
;uc_done:	; 18/12/2022
	retn

; 13/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
;**	umb_coalesce - Combine free blocks ahead with current block
;
;	Coalesce adds the block following the argument to the argument block,
;	iff it's free.  Coalesce is usually used to join free blocks, but
;	some callers (such as $setblock) use it to join a free block to it's
;	preceeding allocated block.
;
;	EXIT	'C' clear if OK
;		  (ds) unchanged, this block updated
;		  (ax) = address of next block, IFF not at end
;		'C' set if arena trashed
;	USES	cx, di, ds, es
;
;----------------------------------------------------------------------------

umb_coalesce:
	; 31/12/2022
	; ds = cs
	push	ds ; *!

	xor	di, di

	;mov	es,[cs:DevDOSData]
	; 31/12/2022
	mov	es,[DevDOSData]
	mov	es,[es:UMB_ARENA]	; es = UMB_HEAD
uc_nextfree:
	mov	ax,es
	mov	ds,ax
	;cmp	[es:1],di
	cmp	[es:ARENA.OWNER],di	; Q: is current arena free
	je	short uc_again		; Y: try to coalesce with next block
					; N: get next arena
	call	get_next		; es, ax = next arena
	jc	short uc_done	; *!
	jmp	short uc_nextfree
uc_again:
	call	get_next		; ES, AX <- next block
	jc	short uc_done	; *!
uc_check:
	cmp     [es:ARENA.OWNER],di	; Q: is arena free
	jne	short uc_nextfree	; N: get next free arena
					; Y: coalesce
	mov     cx,[es:ARENA.SIZE]      ; cx <- next block size
	inc     cx                      ; cx <- cx + 1 (for header size)
	;add	[3],cx
	add     [ARENA.SIZE],cx		; current size <- current size + cx
	mov     cl,[es:di]              ; move up signature
	mov     [di],cl
	jmp     short uc_again		; try again

	; 18/12/2022
;uc_done:
	;retn

;----------------------------------------------------------------------------
;
;**	get_next - Find Next item in Arena
;
;	ENTRY	dS - pointer to block head
;	EXIT	AX,ES - pointers to next head
;		'C' set if arena damaged
;
;----------------------------------------------------------------------------

	; 01/11/2022
get_next:
	cmp	byte [0],arena_signature_end ; 'Z'
	je	short gn_err
_get_next_:
	mov     ax,ds                   ; ax=current block
	add     ax,[ARENA.SIZE]		; ax=ax + current block length
	inc     ax                      ; remember that header!
	mov	es,ax
	;clc
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
	; cf=0
	;clc
	retn
gn_err:
	stc
	; 11/12/2022	
lfu_err:	 ; cf=1
	retn

;----------------------------------------------------------------------------
;
; procedure : LinkFirstUMB
;
;----------------------------------------------------------------------------

	; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:2F81h)
LinkFirstUMB:
	; 31/12/2022
	; ds = cs
	call	umb_allocate
	jc	short lfu_err  ; ds = cs ; 31/12/2022

; bx = segment of allocated UMB
; dx = size of UMB

	; 31/12/2022
	; ds = cs

	int	12h			; ax = size of memory
	mov	cl,6
	shl	ax,cl			; ax = size in paragraphs

	mov	cx,ax			; cx = size in paras
	sub	ax,bx			; ax = - size of unused block

	neg	ax

	sub	cx,1			; cx = first umb_arena
	mov	es,cx			; es = first umb_arena
	
	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
	mov	word [es:ARENA.OWNER],8	; mark as system owned
					
	mov	[es:ARENA.SIZE],ax	
	mov	word [es:ARENA.NAME],'SC' ; 4353h

; put in the arena for the first UMB

	mov	es,bx			; es has first free umb seg
	mov	byte [es:ARENA.SIGNATURE],arena_signature_end ; 'Z'
	mov	word [es:ARENA.OWNER],arena_owner_system ; 0	
					; mark as free 
	dec	dx			; make room for arena
	mov	[es:ARENA.SIZE],dx	

	;mov	es,[cs:DevDOSData]
	; 31/12/2022
	mov	es,[DevDOSData] ; ds = cs
	mov	di,UMB_ARENA ; 8Ch
	mov	[es:di],cx		; initialize umb_head in DOS
					;  data segment with the arena
					;  just below Top of Mem

; we must now scan the arena chain and update the size of the last arena

	mov	di,DOS_ARENA ; 24h
	mov	es,[es:di]		; es = start arena
	xor	di,di
;scan_next
; 09/12/2022
scannext:
	cmp	byte [es:di],arena_signature_end  ; 'Z'
	je	short got_last
	
	mov	ax,es
	add	ax,[es:ARENA.SIZE]
	inc	ax
	mov	es,ax
	;jmp	short scan_next
	; 09/12/2022
	jmp	short scannext
got_last:
	sub	word [es:ARENA.SIZE],1
	mov	byte [es:ARENA.SIGNATURE],arena_signature_normal ; 'M'
	;clc
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 11/12/2022
	; cf=0
	;clc
	retn

; 11/12/2022
;;lfu_err:
;	;stc
;	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;	; 11/12/2022
;	; cf=1
;	;stc
;	retn

;----------------------------------------------------------------------------
;
; procedure : ShrinkUMB
;
;	Shrinks the current UMB in use, so that the unused portions
;	of the UMB is given back to the DOS free mem pool
;
;----------------------------------------------------------------------------

ShrinkUMB:
	; 12/12/2022
	; ds = cs
	cmp	word [DevUMBAddr],0
	;cmp	word [cs:DevUMBAddr],0
	je	short su_exit
	push	es
	; 01/01/2023
	;push	bx
	; 12/12/2022
	;mov	bx,[cs:DevUMBFree]
	;sub	bx,[cs:DevUMBAddr]
	;mov	es,[cs:DevUMBAddr]
	mov	bx,[DevUMBFree]
	sub	bx,[DevUMBAddr]
	mov	es,[DevUMBAddr]
	
	mov	ax,4A00h
	int	21h
		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
		; ES = segment address of block to change
		; BX = new size in paragraphs
	mov	ax,es
	dec	ax
	mov	es,ax
	mov	word [es:ARENA.OWNER],8
	; 01/01/2023
	;pop	bx
	pop	es
su_exit:
	retn

;----------------------------------------------------------------------------
;
; procedure : UnlinkUMB
;
;	Unlinks the UMBs from the DOS arena chain
;
;----------------------------------------------------------------------------

UnlinkUMB:
	; 12/12/2022
	; ds = cs
	push	ds
	push	es
	; 12/12/2022
	cmp	byte [FirstUMBLinked],0
	;cmp	byte [cs:FirstUMBLinked],0
	je	short ulu_x		; nothing to unlink
	; 12/12/2022
	mov	es,[DevDOSData]
	;mov	es,[cs:DevDOSData]	; get DOS data seg
	mov	ds,[es:DOS_ARENA]
	mov	di,[es:UMB_ARENA]
ulu_next:
	call	get_next
	jc	short ulu_x
	cmp	di,ax			; is the next one UMB ?
	je	short ulu_found
	mov	ds,ax
	jmp	short ulu_next
ulu_found:
	;mov	byte [0],'Z'
	mov     byte [ARENA.SIGNATURE],arena_signature_end ; 'Z'
ulu_x:
	pop	es
	pop	ds
	retn

; ----------------------------------------------------------------------
; SYSINIT2.ASM - MSDOS 6.0 - 1991
; ----------------------------------------------------------------------
; 14/04/2019 - Retro DOS v4.0

; Multiple configuration block support  Created 16-Mar-1992 by JeffPar
;
; Summary:
;
;   The procedure "organize" crunches the in-memory copy of config.sys
;   into lines delimited by CR/LF (sometimes no CR, but *always* an LF)
;   with the leading "keyword=" replaced by single character codes (eg, B
;   for BUFFERS, D for DEVICE, Z for any unrecognized keyword); see comtab
;   and/or config.inc for the full list.
;
;   [blockname] and INCLUDE are the major syntactical additions for multi-
;   configuration support. blockname is either MENU, which contains one
;   or more MENUITEM lines, an optional MENUDEFAULT (which includes optional
;   time-out), or any user-defined keyword, such as NETWORK, CD-ROM, etc.
;   INCLUDE allows the current block to name another block for inclusion
;   during the processing phase of CONFIG.SYS. An INCLUDE is only honored
;   once, precluding nasty infinite-loop scenarios. If blocks are present
;   without a MENU block, then only lines inside COMMON blocks are processed.
;
; Example:
;
;   [menu]
;   menuitem=misc,Miscellaneous
;   menuitem=network,Network Configuration
;   menudefault=network,15
;
;   [network]
;   include misc
;   device=foo
;
;   [misc]
;   device=bar
;   include alternate
;
;   [alternate]
;   device=tar
;
;
;   When the menu is displayed
;
;    1. Miscellaneous
;    2. Network Configuration
;
;   #2 is highlighted as the default option, and will be automatically
;   selected after 15 seconds. It will invoke the following lines in the
;   following order:
;
;       DEVICE=BAR
;       DEVICE=TAR
;       DEVICE=FOO
;

;MULTI_CONFIG equ 1

; the following depend on the positions of the various letters in switchlist

switchnum	equ 11111000b ; 0F8h	; which switches require number

flagec35	equ 00000100b ; 4	; electrically compatible 3.5 inch disk drive
flagdrive	equ 00001000b ; 8 
flagcyln	equ 00010000b ; 16
flagseclim	equ 00100000b ; 32
flagheads	equ 01000000b ; 64
flagff		equ 10000000b ; 128

;----------------------------------------------------------------------------
; 19/04/2019 - Retro DOS v4.0

; MSDOS 6.21 IO.SYS - SYSINIT:3E78h

; 01/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; MSDOS 5.0 IO.SYS - SYSINIT:3054h

insert_blank:	db 	0

;----------------------------------------------------------------------------
;
; procedure : setparms
;
; the following set of routines is used to parse the drivparm = command in
; the config.sys file to change the default drive parameters.
;
;----------------------------------------------------------------------------

setparms:
	push	ds
	push	ax
	push	bx
	push	cx
	push	dx

	push	cs
	pop	ds

	xor	bx,bx
	mov	bl,[drive]
	; 18/12/2022
	inc	bx
	;inc	bl			; get it correct for ioctl call
					; (1=a,2=b...)
	mov	dx,deviceparameters
	mov	ah,IOCTL ; 44h
	mov	al,GENERIC_IOCTL ; 0Dh
	mov	ch,RAWIO ; 8
	mov	cl,SET_DEVICE_PARAMETERS ; 40h
	int	21h

; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;
;	;;mov	ax,Bios_Data		; get Bios_Data segment
;	;mov	ax,KERNEL_SEGMENT ; 70h
;	; 21/10/2022
;	mov	ax,DOSBIODATASEG ; 0070h	
;	mov	ds,ax			; set Bios_Data segment
;
;	test	word [cs:switches],flagec35 ; 4
;	jz	short not_ec35

	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;test	word [switches],flagec35 ; 4
	; 12/12/2022
	test	byte [switches],flagec35 ; 4
	jz	short eot_ok

	;mov	cl,[cs:drive]		; which drive was this for?
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	mov	cl,[drive]
	mov	ax,DOSBIODATASEG ; 0070h	
	mov	ds,ax	

	mov	al,1			; assume drive 0
	shl	al,cl			; set proper bit depending on drive
	;or	[531h],al ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EACh)
	or	[ec35_flag],al		; set the bit in the permanent flags

; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;
;not_ec35:
;;	Now adjust the BIOS's EOT variable if our new drive has more
;;	sectors per track than any old ones.
;
;	;mov	al,[cs:deviceparameters+20]
;	mov	al,[cs:deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
;	;cmp	al,[12Ch] ; (MSDOS 6.21 IO.SYS Offset SYINIT:3EB4h)
;	cmp	al,[EOT]
;	jbe	short eot_ok
;	mov	[EOT],al

eot_ok:
	pop	dx			; fix up all the registers
	pop	cx
	pop	bx
	pop	ax
	pop	ds ; 13/05/2019
	retn

;----------------------------------------------------------------------------
;
; procedure : diddleback
;
; replace default values for further drivparm commands
;
;----------------------------------------------------------------------------

diddleback:
	push	ds
	push	cs
	pop	ds
	;mov	word [deviceparameters+4],80
	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
	;mov	byte [deviceparameters+1],2
	mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_3INCH720KB ; 2
	;mov	word [deviceparameters+2],0
	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],0
	mov	word [switches],0	    ; zero all switches
	pop	ds
	retn


; 03/01/2023
%if 0

; 15/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : parseline
;
; entry point is parseline. al contains the first character in command line.
;
;----------------------------------------------------------------------------

	; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3EDFh)

	; 01/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:30ACh)
parseline:
	; 03/01/2023
	; ds = cs ; *

	;push	ds ; *

	;push	cs ; *
	;pop	ds ; *

nextswtch:
	cmp	al,cr			; carriage return?
	je	short done_line
	cmp	al,lf			; linefeed?
	je	short put_back		; put it back and done

; anything less or equal to a space is ignored.

	cmp	al,' '                  ; space?
	jbe	short getnext		; skip over space
	cmp	al,'/'
	je	short getparm
	stc				; mark error invalid-character-in-input
	;jmp	short exitpl
	; 03/01/2023
swterr:
	retn

getparm:
	call	check_switch
	mov	[switches],bx		; save switches read so far
	jc	short swterr
getnext:
	call	getchr
	;jc	short done_line
	;jmp	short nextswtch
	; 03/01/2023
	jnc	short nextswtch
;swterr:
	;jmp	short exitpl		; exit if error

done_line:
	; 12/12/2022
	test	byte [switches],flagdrive ; 8
	;test	word [switches],flagdrive ; 8 ; see if drive specified
	jnz	short okay
	stc				; mark error no-drive-specified
	;jmp	short exitpl
	; 03/01/2023
	retn

okay:
	mov	ax,[switches]
	and	ax,0003h	    ; get flag bits for changeline and non-rem
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
	;clc			    ; everything is fine
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0
	;clc
	;call	setdeviceparameters
	; 03/01/2023
	jmp	setdeviceparameters
;exitpl:
	; 03/01/2023
	; ds = cs
	;pop	ds ; *
	retn
put_back:
	inc	word [count]		; one more char to scan
	dec	word [chrptr]		; back up over linefeed
	jmp	short done_line

%endif

;----------------------------------------------------------------------------
;
; procedure : check_switch
;
; processes a switch in the input. it ensures that the switch is valid, and
; gets the number, if any required, following the switch. the switch and the
; number *must* be separated by a colon. carry is set if there is any kind of
; error.
;
;----------------------------------------------------------------------------

check_switch:
	call	getchr
	;jc	short err_check
	jc	short err_chk
        and     al,0DFh                 ; convert it to upper case
	cmp	al,'A'
	;jb	short err_check
	jb	short err_chk ; 15/04/2019 - Retro DOS v4.0
	cmp	al,'Z'
	ja	short err_check

	push	es

	push	cs
	pop	es

	mov	cl,[switchlist]		; get number of valid switches
	mov	ch,0
	mov	di,1+switchlist		; point to string of valid switches
	repne	scasb

	pop	es
	jnz	short err_check

	mov	ax,1
	shl	ax,cl			; set bit to indicate switch
	mov	bx,[switches]		; get switches so far
	or	bx,ax			; save this with other switches
	mov	cx,ax
	; 12/12/2022
	test	al,switchnum ; 0F8h
	;test	ax,switchnum ; 0F8h	; test against switches that require number to follow
	jz	short done_swtch

	call	getchr
	jc	short err_swtch

	cmp	al,':'
	jne	short err_swtch

	call	getchr
	push	bx			; preserve switches
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	byte [cs:sepchr],' '	; allow space separators
	; 12/12/2022
	; ds = cs
	mov	byte [sepchr],' '
	call	getnum
	;mov	byte [cs:sepchr],0
	; 12/12/2022
	mov	byte [sepchr],0
	pop	bx			; restore switches

; because getnum does not consider carriage-return or line-feed as ok, we do
; not check for carry set here. if there is an error, it will be detected
; further on (hopefully).

	call	process_num

done_swtch:
	;clc
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0
	;clc
	retn

err_swtch:
	xor	bx,cx			; remove this switch from the records
err_check:
	stc
err_chk:
	retn

;----------------------------------------------------------------------------
;
; procedure : process_num
;
; this routine takes the switch just input, and the number following (if any),
; and sets the value in the appropriate variable. if the number input is zero
; then it does nothing - it assumes the default value that is present in the
; variable at the beginning. zero is ok for form factor and drive, however.
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:3156h)
process_num:
	test	[switches],cx		; if this switch has been done before,
	jnz	short done_ret		; ignore this one.
	; 12/12/2022
	test	cl,flagdrive ; 8
	;test	cx,flagdrive ; 8
	jz	short try_f
	mov	byte [drive],al
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short done_ret
	; 12/12/2022
	; cf=0
	retn	; 13/05/2019
try_f:
	; 12/12/2022
	test	cl,flagff ; 80h
	;test	cx,flagff ; 80h
	jz	short try_t

; ensure that we do not get bogus form factors that are not supported

	;mov	[deviceparameters+1],al
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],al
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short done_ret
	; 12/12/2022
	; cf=0
	retn	; 13/05/2019
try_t:
	or	ax,ax
	jz	short done_ret		; if number entered was 0, assume default value
	; 12/12/2022
	test	cl,flagcyln ; 10h
	;test	cx,flagcyln ; 10h
	jz	short try_s

	;mov	[deviceparameters+4],ax
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],ax
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short done_ret
	; 12/12/2022
	; cf=0
	retn	; 13/05/2019
try_s:
	; 12/12/2022
	test	cl,flagseclim ; 20h
	;test	cx,flagseclim ; 20h
	jz	short try_h
	mov	[slim],ax
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;jmp	short done_ret
	; 12/12/2022
	; cf=0
	retn	; 13/05/2019

; must be for number of heads

try_h:
	mov	[hlim],ax
done_ret:
	;clc
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0 (test instruction resets cf)
	;clc
	retn


; 03/01/2023 - Retro DOS v4.2
%if 1

; 15/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : parseline
;
; entry point is parseline. al contains the first character in command line.
;
;----------------------------------------------------------------------------

	; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3EDFh)

	; 01/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:30ACh)
parseline:
	; 03/01/2023
	; ds = cs ; *

	;push	ds ; *

	;push	cs ; *
	;pop	ds ; *

nextswtch:
	cmp	al,cr			; carriage return?
	je	short done_line
	cmp	al,lf			; linefeed?
	je	short put_back		; put it back and done

; anything less or equal to a space is ignored.

	cmp	al,' '                  ; space?
	jbe	short getnext		; skip over space
	cmp	al,'/'
	je	short getparm
	stc				; mark error invalid-character-in-input
	;jmp	short exitpl
	; 03/01/2023
swterr:
	retn

getparm:
	call	check_switch
	mov	[switches],bx		; save switches read so far
	jc	short swterr
getnext:
	call	getchr
	;jc	short done_line
	;jmp	short nextswtch
	; 03/01/2023
	jnc	short nextswtch
;swterr:
	;jmp	short exitpl		; exit if error

done_line:
	; 12/12/2022
	test	byte [switches],flagdrive ; 8
	;test	word [switches],flagdrive ; 8 ; see if drive specified
	jnz	short okay
	stc				; mark error no-drive-specified
	;jmp	short exitpl
	; 03/01/2023
	retn

;exitpl:
	; 03/01/2023
	; ds = cs
	;;pop	ds ; *
	;retn

put_back:
	inc	word [count]		; one more char to scan
	dec	word [chrptr]		; back up over linefeed
	jmp	short done_line

okay:
	mov	ax,[switches]
	and	ax,0003h	    ; get flag bits for changeline and non-rem
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES],ax
	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_TRACKTABLEENTRIES],0
	;clc			    ; everything is fine
	; 01/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 12/12/2022
	; cf=0
	;clc
	;call	setdeviceparameters
	; 03/01/2023
	;jmp	short setdeviceparameters

%endif

;	M047 -- Begin modifications (too numerous to mark specifically)

;----------------------------------------------------------------------------
;
; procedure : setdeviceparameters
;
; setdeviceparameters sets up the recommended bpb in each bds in the
; system based on the form factor. it is assumed that the bpbs for the
; various form factors are present in the bpbtable. for hard files,
; the recommended bpb is the same as the bpb on the drive.
; no attempt is made to preserve registers since we are going to jump to
; sysinit straight after this routine.
;
;	if we return carry, the DRIVPARM will be aborted, but presently
;	  we always return no carry
;
;	note:  there is a routine by the same name in msdioctl.asm
;
;----------------------------------------------------------------------------

; 15/04/2019 - Retro DOS v4.0

	; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)

	; 03/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:3FC4h)

setdeviceparameters:
	; 03/01/2023
	; ds = cs

	push	es

	push	cs
	pop	es

	xor	bx,bx
	mov	bl,[deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE]
	cmp	bl,DEV_5INCH ; 0
	jne	short got_80

	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
							; 48 tpi=40 cyl
got_80:
	shl	bx,1			; get index into bpb table
	mov	si,[bpbtable+bx]	; get address of bpb

	;mov	di,deviceparameters+7	
	; 02/11/2022
	mov	di,deviceparameters+A_DEVICEPARAMETERS.DP_BPB ; es:di -> bpb
	mov	cx,A_BPB.size ; 31
	cld
	;repe	movsb
	; 02/11/2022
	rep	movsb

	pop	es

	; 12/12/2022
	test	byte [switches],flagseclim ; 20h
	;test	word [switches],flagseclim ; 20h
	jz	short see_heads

	mov	ax,[slim]
	;mov	[deviceparameters+20],ax
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],ax

see_heads:
	; 12/12/2022
	test	byte [switches],flagheads ; 40h
	;test	word [switches],flagheads ; 40h
	jz	short heads_not_altered

	mov	ax,[hlim]
	;mov	[deviceparameters+22],ax	
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax

heads_not_altered:

; set up correct media descriptor byte and sectors/cluster
;   sectors/cluster is always 2 except for any one sided disk or 1.44M

	;mov	byte [deviceparameters+9],2
	; 02/11/2022
	;mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],2
	; 03/01/2023
	mov	ax,2	
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al ; 2

	mov	bl,0F0h			; get default mediabyte

;	preload the mediadescriptor from the bpb into bh for convenient access

	;mov	bh,[deviceparameters+17]
	; 02/11/2022
	mov	bh,[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR]
	
	; 03/01/2023
	; ax = 2
	cmp	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],ax ; >2 heads?
	;cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS],2 ; >2 heads?
	ja	short got_correct_mediad ; just use default if heads>2

	jne	short only_one_head	; one head, do one head stuff

;	two head drives will use the mediadescriptor from the bpb

	mov	bl,bh			; get mediadescriptor from bpb

;	two sided drives have two special cases to look for. One is
;	   a 320K diskette (40 tracks, 8 secs per track). It uses
;	   a mediaid of 0fch. The other is 1.44M, which uses only
;	   one sector/cluster.

;	any drive with 18secs/trk, 2 heads, 80 tracks, will be assumed
;	   to be a 1.44M and use only 1 sector per cluster. Any other
;	   type of 2 headed drive is all set.

	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],18
	jne	short not_144m
	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],80
	jne	short not_144m

;	We've got cyl=80, heads=2, secpertrack=18. Set cluster size to 1.

	jmp	short got_one_secperclus_drive

;	check for 320K

not_144m:
	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS],40
	jne	short got_correct_mediad
	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
	jne	short got_correct_mediad

	mov	bl,0FCh
	jmp	short got_correct_mediad

only_one_head:

;	if we don't have a 360K drive, then just go use 0f0h as media descr.

	cmp	byte [deviceparameters+A_DEVICEPARAMETERS.DP_DEVICETYPE],DEV_5INCH ; 0
	je	short got_one_secperclus_drive

;	single sided 360K drive uses either 0fch or 0feh, depending on
;	  whether sectorspertrack is 8 or 9. For our purposes, anything
;	  besides 8 will be considered 0fch

	mov	bl,0FCh			; single sided 9 sector media id
	cmp	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK],8
	; 12/12/2022
	jne	short got_one_secperclus_drive ; okay if anything besides 8

	mov	bl,0FEh			; 160K mediaid

;	we've either got a one sided drive, or a 1.44M drive
;	  either case we'll use 1 sector per cluster instead of 2

got_one_secperclus_drive:
	; 03/01/2023
	; ax = 2
	dec	ax  ; ax = 1
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],al ; 1
	;mov	byte [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERCLUSTER],1

got_correct_mediad:
	mov	[deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_MEDIADESCRIPTOR],bl

;	 Calculate the correct number of Total Sectors on medium

	mov	ax,[deviceparameters+A_DEVICEPARAMETERS.DP_CYLINDERS]
	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_HEADS]
	mul	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_SECTORSPERTRACK]
	mov	word [deviceparameters+A_DEVICEPARAMETERS.DP_BPB+A_BPB.BPB_TOTALSECTORS],ax
	clc				; we currently return no errors

	retn

;	M047 -- end rewritten routine

;----------------------------------------------------------------------------
;
; procedure : organize
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:3234h)

	; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4067h)

organize:
	; 03/01/2023
	; ds = cs
	mov	cx,[count]
	;mov	cx,[cs:count]
	jcxz	nochar1

;ifndef	MULTI_CONFIG
;
;;   In MULTI_CONFIG, we map to upper case on a line-by-line basis,
;;   because we the case of values in SET commands preserved
;
;	call	mapcase
;endif
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 03/01/2023 - Retro DOS v4.2
	;call	mapcase

	xor	si,si
	mov	di,si
	xor	ax,ax
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)	
	;;mov	byte [cs:com_level],0
	; 12/12/2022
	;mov	[cs:com_level],al ; 0
	; 03/01/2023
	; ds = cs
	mov	[com_level],al ; 0
org1:
	call	skip_comment
	jz	short end_commd_line	; found a comment string and skipped.
	call	get2			; not a comment string. then get a char.
	cmp	al,lf ; 0Ah
	je	short end_commd_line	; starts with a blank line.
	cmp	al,' ' ; 20h
	jbe	short org1		; skip leading control characters
	jmp	short findit

end_commd_line:
	stosb				; store line feed char in buffer for the linecount.
	;mov	byte [cs:com_level],0	; reset the command level.
	; 03/01/2023
	; ds = cs
	mov	byte [com_level],0
	jmp	short org1

nochar1:
	stc
	retn

findit:
	push	cx
	push	si
	push	di
	mov	bp,si
	dec	bp
        mov     si,comtab		; prepare to search command table
	mov	ch,0
findcom:
	mov	di,bp
	mov	cl,[si]
	inc	si
	jcxz	nocom

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)

;ifdef	MULTI_CONFIG

;   Simplify future parsing by collapsing ";" onto "REM", and at the same
;   time skip the upcoming delimiter test (since ";" need not be followed by
;   anything in particular)

	cmp	byte [es:di],CONFIG_SEMICOLON  ; ';'
	je	short semicolon
loopcom:
	mov	al,[es:di]
	inc	di
	and	al,~20h ; 0DFh		; force upper case
	inc	si                      ; compare to byte @es:di
	cmp	al,[si-1]
	loope	loopcom
;else
;	repe	cmpsb
;endif
	; 02/11/2022
	; 03/01/2023 - Retro DOS v4.2
	;repe	cmpsb

	lahf
        add     si,cx                   ; bump to next position without affecting flags
	sahf
        lodsb                           ; get indicator letter
	jnz	short findcom
        cmp     byte [es:di],cr		; the next char might be cr,lf
	je	short gotcom0 		; such as in "rem",cr,lf case.
	cmp	byte [es:di],lf
	je	short gotcom0

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)

;ifdef	MULTI_CONFIG

;   Skip the delimiter test for the BEGIN identifier (it doesn't have one).

	cmp	al,CONFIG_BEGIN  ; '['
	je	short gotcom0
;endif
	push	ax
	mov	al,[es:di]		; now the next char. should be a delim.

;ifdef	MULTI_CONFIG

;   If keyword is *immediately* followed by a question mark (?), then
;   set the high bit of the ASCII command code (CONFIG_OPTION_QUERY) that is
;   stored in the CONFIG.SYS memory image.

	cmp	al,'?'                  ; explicit interactive command?
	jne	short no_query		; no
	pop	ax                      ; yes, so retrieve the original code
	;or	al,80h ; 03/01/2023
	or	al,CONFIG_OPTION_QUERY  ; and set the QUERY bit
	jmp	short gotcom0           ;
semicolon:
	mov	al,CONFIG_REM ; 0
	jmp	short gotcom0
no_query:
;endif  ;MULTI_CONFIG

	; 02/11/2022
	; 03/01/2023 - Retro DOS v4.2
	;push	ax
	;mov	al,[es:di]		; now the next char. should be a delim.

	call	delim
no_delim:
	pop	ax
	jnz	short findcom
gotcom0:
	pop	di
	pop	si
	pop	cx
	jmp	short gotcom
nocom:
	pop	di
	pop	si
	pop	cx
        mov     al,CONFIG_UNKNOWN  ; 'Z'
	stosb				; save indicator char.
_skipline:
	call	get2
	cmp	al,lf ; 0Ah		; skip this bad command line
        jne     short _skipline
	jmp	short end_commd_line	; handle next command line
gotcom:
        stosb                           ; save indicator char in buffer

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)

;ifdef	MULTI_CONFIG

;   Don't pollute "cmd_indicator" with the CONFIG_OPTION_QUERY bit though;
;   it screws up the direct comparisons below.

	and	al,~CONFIG_OPTION_QUERY ; 7Fh
;endif
	;mov	[cs:cmd_indicator],al	; save it for the future use.
	; 03/01/2023
	; ds = cs
	mov	[cmd_indicator],al	; save it for the future use.	

;ifdef	MULTI_CONFIG

;   There is no whitespace/delimiter between the "begin block" character
;   ([) and the name of block (eg, [menu]), therefore skip this delimiter
;   skipping code

	cmp	al,CONFIG_BEGIN
	je	short org31
	cmp	al,CONFIG_SUBMENU ; 'O'
	je	short no_mapcase
	cmp	al,CONFIG_MENUITEM ; 'E'
	je	short no_mapcase
	cmp	al,CONFIG_MENUDEFAULT ; 'A'
	je	short no_mapcase
	cmp	al,CONFIG_INCLUDE ; 'J'
	je	short no_mapcase
	call	mapcase			; map case of rest of line to UPPER
no_mapcase:
;endif
	;; 02/11/2022
	;;mov	[cs:cmd_indicator],al	; save it for the future use.
	;; 03/01/2023
	;; ds = cs
	;mov	[cmd_indicator],al
org2:	
	call    get2                    ; skip the command name until delimiter
        cmp     al,lf 	    ; 0Ah
	je	short org21
	cmp	al,cr 	    ; 0Dh	
	je	short org21
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 03/01/2023 - Retro DOS v4.2
	cmp	al, '/'			; T-RICHJ: Added to allow DEVHIGH/L:...
	je	short org21		; T-RICHJ: to be parsed properly.

	call	delim
        jnz	short org2
	jmp	short org3
org21:					;if cr or lf then
	dec	si			; undo si, cx register
	inc	cx			;  and continue
org3:	
	;cmp	byte [cs:cmd_indicator],CONFIG_COMMENT ; 'Y'
	;je	short get_cmt_token
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 03/01/2023 - Retro DOS v4.2	
	;cmp	byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
	;je	short org_file
	;cmp	byte [cs:cmd_indicator],CONFIG_INSTALL ; 'I'
	;je	short org_file
	;cmp	byte [cs:cmd_indicator],CONFIG_INSTALLHIGH ; 'W'
	;je	short org_file
	; 02/11/2022
	; 03/01/2023 - Retro DOS v4.2
	;;cmp	byte [cs:cmd_indicator],CONFIG_DEVICE ; 'D'
	;;je	short org_file
	;cmp	byte [cs:cmd_indicator],CONFIG_SHELL ; 'S'
	;je	short org_file
        ;cmp	byte [cs:cmd_indicator],CONFIG_SWITCHES ; '1'
	;je	short org_switch

	; 03/01/2023
	; ds = cs

	cmp	byte [cmd_indicator],CONFIG_COMMENT ; 'Y'
	je	short get_cmt_token
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; 03/01/2023 - Retro DOS v4.2	
	cmp	byte [cmd_indicator],CONFIG_DEVICE ; 'D'
	je	short org_file
	cmp	byte [cmd_indicator],CONFIG_INSTALL ; 'I'
	je	short org_file
	cmp	byte [cmd_indicator],CONFIG_INSTALLHIGH ; 'W'
	je	short org_file
	; 02/11/2022
	; 03/01/2023 - Retro DOS v4.2
	;cmp	byte [cmd_indicator],CONFIG_DEVICE ; 'D'
	;je	short org_file
        cmp	byte [cmd_indicator],CONFIG_SHELL ; 'S'
	je	short org_file
        cmp	byte [cmd_indicator],CONFIG_SWITCHES ; '1'
	je	short org_switch
	
org31:
	jmp	org4

org_switch:
	call	skip_comment
	jz	short end_commd_line_brdg

	call	get2
	call	org_delim
	jz	short org_switch

	stosb
	jmp	org5

org_file:			; get the filename and put 0 at end
	call	skip_comment
	jz	short org_put_zero

	call	get2		; not a comment
	call	delim
	jz	short org_file	; skip the possible delimiters

	stosb			; copy the first non delim char found in buffer

org_copy_file:
	call	skip_comment	; comment char in the filename?
	jz	short org_put_zero ; then stop copying filename at that point

	call	get2
	cmp	al,'/'		; a switch char? (device=filename/xxx)
	je	short end_file_slash ; this will be the special case.

	stosb			; save the char. in buffer
	call	delim
	jz	short end_copy_file

	cmp	al, ' '
	ja	short org_copy_file ; keep copying
	jmp	short end_copy_file ; otherwise, assume end of the filename.

get_cmt_token:			; get the token. just max. 2 char.
	call	get2
	cmp	al,' '		; skip white spaces or "=" char.
	je	short get_cmt_token ; (we are allowing the other special
	cmp	al,tab ; 9 	;  characters can used for comment id.
	je	short get_cmt_token ;  character.)
	cmp	al,'='		; = is special in this case.
	je	short get_cmt_token
	cmp	al,cr
	je	short get_cmt_end ; cannot accept the carriage return
	cmp	al,lf
	je	short get_cmt_end

	; 03/01/2023
	; ds = cs
	;mov	[cs:cmmt1],al	; store it
	;mov	byte [cs:cmmt],1 ; 1 char. so far.
	mov	[cmmt1],al	; store it
	mov	byte [cmmt],1	; 1 char. so far.
	call	get2
	cmp	al,' ' ; 20h
	je	short get_cmt_end
	cmp	al,tab ; 9
	je	short get_cmt_end
	cmp	al,cr  ; 0Dh
	je	short get_cmt_end
	cmp	al,lf  ; 0Ah
	je	short end_commd_line_brdg

	;mov	[cs:cmmt2],al
	;inc	byte [cs:cmmt]
	; 03/01/2023
	mov	[cmmt2],al
	inc	byte [cmmt]

get_cmt_end:
	call	get2
	cmp	al,lf
	jne	short get_cmt_end	; skip it.
end_commd_line_brdg: 
	jmp	end_commd_line		; else jmp to end_commd_line

org_put_zero:				; make the filename in front of
	mov	byte [es:di],0		;  the comment string to be an asciiz.
	inc	di
	jmp	end_commd_line		;  (maybe null if device=/*)

end_file_slash: 			; al = "/" option char.
	mov	byte [es:di],0		; make a filename an asciiz
	inc	di			; and
	stosb				; store "/" after that.
	jmp	short org5		; continue with the rest of the line

end_copy_file:
	mov	byte [es:di-1],0	; make it an asciiz and handle the next char.
	cmp	al,lf
	je	short end_commd_line_brdg
	jmp	short org5

org4:					; org4 skips all delimiters after the command name except for '/'
	call	skip_comment
	jz	short end_commd_line_brdg

	call	get2
	call	org_delim		; skip delimiters except '/' (mrw 4/88)
	jz	short org4
	jmp	short org51

org5:					; rest of the line
	call	skip_comment		; comment?
	jz	short end_commd_line_brdg
	call	get2			; not a comment.

org51:
	stosb				; copy the character
	cmp	al,'"' 	; 22h		; a quote ?
	je	short at_quote
	cmp	al,' '  ; 20h
	ja	short org5
					; M051 - Start
	; 03/01/2023
	; ds = cs
        cmp	byte [cmd_indicator],CONFIG_DEVICEHIGH
	;cmp	byte [cs:cmd_indicator],CONFIG_DEVICEHIGH ; Q: is this devicehigh
	jne	short not_dh		; N: 
	cmp	al,lf			; Q: is this line feed
	je	short org_dhlf		; Y: stuff a blank before the lf
	cmp	al,cr			; Q: is this a cr
	jne	short org5		; N: 
	mov	byte [es:di-1],' '	; overwrite cr with blank
	stosb				; put cr after blank
	inc	byte [insert_blank]
	;inc	byte [cs:insert_blank]	; indicate that blank has been 
					; inserted
	jmp	short org5
not_dh:					; M051 - End

	cmp	al,lf			; line feed?
	je	short org1_brdg		; handles the next command line.
	jmp	short org5		; handles next char in this line.

org_dhlf:				; M051 - Start
	; 03/01/2023
	; ds = cs
	cmp	byte [insert_blank],1
	;cmp	byte [cs:insert_blank],1 ; Q:has a blank already been inserted
	je	short org1_brdg		; Y:
	mov	byte [es:di-1],' '	; overwrite lf with blank
	stosb				; put lf after blank
					; M051 - End
org1_brdg:
	mov	byte [insert_blank],0 
	;mov	byte [cs:insert_blank],0 ; M051: clear blank indicator for 
					; M051: devicehigh
	jmp	org1

at_quote:
	cmp	byte [com_level],0
	;cmp	byte [cs:com_level],0
	je	short up_level
	;mov	byte [cs:com_level],0	; reset it.
	mov	byte [com_level],0
	jmp	short org5

up_level:
	;inc	byte [cs:com_level]	; set it.
	inc	byte [com_level]
	jmp	short org5

;----------------------------------------------------------------------------
;
; procedure : get2
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:33FAh)

	; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4270h)
get2:
	jcxz	noget
	;
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;;lods	byte ptr es:[si]
	; 12/12/2022
	es	
	lodsb
	;mov	al, [es:si]
	;inc	si
	;
	dec	cx
	retn
noget:
	pop	cx
	; 03/01/2023
	; ds = cs
	;mov	[cs:count],di ; 13/05/2019
	;mov	[cs:org_count],di
	mov	[count],di
	mov	[org_count],di
	xor	si,si
	;mov	[cs:chrptr],si
	mov	[chrptr],si

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)

;ifndef MULTI_CONFIG
;	retn
;else

;   This was the rather kludgy way out of procedure "organize", but instead
;   of returning to doconf, we now want to check config.sys BEGIN/END blocks
;   and the new boot menu stuff...

	mov     cx,di
	jmp     menu_check

;endif
	; 02/11/2022
	; 03/01/2023 - Retro DOS v4.2
	;retn

;----------------------------------------------------------------------------
;
; procedure : skip_comment
;
;skip the commented string until lf, if current es:si-> a comment string.
;in) es:si-> string
;	 cx -> length.
;out) zero flag not set if not found a comment string.
;	  zero flag set if found a comment string and skipped it. al will contain
;	  the line feed character at this moment when return.
;	  ax register destroyed.
;	  if found, si, cx register adjusted accordingly.
;
;----------------------------------------------------------------------------

	; 03/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:428Dh)

skip_comment:
	jcxz	noget		; get out of the organize routine.

	; 03/01/2023
	; ds = cs	

	cmp	byte [com_level],0
	;cmp	byte [cs:com_level],0 ; only check it if parameter level is 0.
	jne	short no_commt	 ; (not inside quotations)

	cmp	byte [cmmt],1
	;cmp	byte [cs:cmmt],1
	jb	short no_commt

	mov	al,[es:si]
	
	cmp	[cmmt1],al
	;cmp	[cs:cmmt1],al
	jne	short no_commt

	cmp	byte [cmmt],2
	;cmp	byte [cs:cmmt],2
	jne	short skip_cmmt

	mov	al,[es:si+1]
	
	cmp	[cmmt2],al
	;cmp	[cs:cmmt2],al
	jne	short no_commt
skip_cmmt:
	jcxz	noget		; get out of organize routine.
	mov	al,[es:si]
	inc	si
	dec	cx
	cmp	al,lf		; line feed?
	jne	short skip_cmmt
no_commt:
	retn

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:42C8h)

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

;ifdef	MULTI_CONFIG

;----------------------------------------------------------------------------
;
;   kbd_read: wait for keystroke
;
;   INPUT
;       DS == CS == sysinitseg
;
;   OUTPUT
;       Carry SET to clean boot, CLEAR otherwise
;
;   OTHER REGS USED
;       All
;
;   HISTORY
;       Created 16-Nov-1992 by JeffPar
;
;----------------------------------------------------------------------------

kbd_read:
        test    byte [bDisableUI],2
        jnz     short kbd_nodelay

        push    ds              ; the bios timer tick count is incremented
        sub     ax,ax           ; 18.2 times per second;
        mov     ds,ax           ; watch the timer tick count for 37 transitions
	;mov	dx,[046Ch]	; get initial value
kbd_loop:
        mov     ah,1            ;
        int     16h             ; peek the keyboard
        jnz	short kbd_loopdone ; something's there, get out
        mov     ah,2            ; peek the shift states
        int     16h             ;
        test    al,03h          ; either right or left shift key bits set?
        jnz	short kbd_loopdone ; yes
        mov     ax,[046Ch]	;
	;sub	ax,dx           ; get difference
	; 15/04/2019 - Retro DOS v4.0
	sub	ax,[cs:_timer_lw_] ; MSDOS 6.21 IO.SYS - SYSINIT:42E5h        

	cmp     al,37           ; reached limit?  ; (2 seconds)
        jb	short kbd_loop	; not yet
kbd_loopdone:
        pop     ds              ; delay complete!
kbd_nodelay:
        sub     bx,bx           ; assume clean boot
        mov     ah,2            ; peek the shift states
        int     16h             ;
        test    al,03h          ; either right or left shift key bits set?
        jz      short kbd_notshift ; no
        inc     bx              ; yes
        inc     bx
	; MSDOS 6.21 IO.SYS - SYSINIT:4301h
	or	byte [bQueryOpt],4
kbd_notshift:                   ;
        mov     ah,1            ; peek the keyboard
        int     16h             ;
        jz	short kbd_test	; no key present
        or      al,al           ; is it a function key?
        jnz	short kbd_test	; no

	; MSDOS 6.21 IO.SYS - SYSINIT:430Bh
        cmp     ah,62h          ; CTRL F5
        je	short kbd_cfg_bypass
	
        cmp     ah,3Fh          ; F5 function key?
        jne	short kbd_notf5	; no
kbd_cfg_bypass:
        mov     dx,_$CleanMsg
        call    print
	; MSDOS 6.21 IO.SYS - SYSINIT:431Bh
	or	byte [bQueryOpt],4 
        jmp     short kbd_eat   ; yes, clean boot selected
kbd_notf5:
	; MSDOS 6.21 IO.SYS - SYSINIT:4322h
        cmp     ah,65h          ; CTRL F8
        je	short kbd_cfg_confirm

        cmp     ah,42h          ; F8 function key?
        jne	short kbd_exit	; no
kbd_cfg_confirm:
        mov     dx,_$InterMsg
        call    print           ;
        mov     bl,1            ; yes, interactive-boot option enabled
        mov     [bQueryOpt],bl  ; change default setting
kbd_eat:                        ;
        mov     ah,0            ;
        int     16h             ; eat the key we assumed was a signal
        mov	byte [secElapsed],-1
        or      bx,bx           ;
        jz	short kbd_clean	;
kbd_test:                       ;
        cmp     bl,2            ;
        jb	short kbd_exit	;
kbd_clean:                      ;
        call    disable_autoexec; yes, tell COMMAND to skip autoexec.bat
        stc                     ; set carry to indicate abort
        retn			;
kbd_exit:                       ;
        clc                     ; clear carry to indicate success
        retn			;

;----------------------------------------------------------------------------
;
;   set_numlock: set numlock LED
;
;   INPUT
;       ES:SI -> numlock setting (ie, "ON" or "OFF")
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   HISTORY
;       Created 16-Nov-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 04/01/2023 - Retro DOS v4.2

set_numlock:
        ; 04/01/2023
	;push	ax
        push    ds
        sub     ax,ax
        mov     ds,ax
        mov     ax,[es:si]      ; get 1st 2 bytes of value (ON or OF)
        cmp     ax,[cs:OnOff+2]	; should we turn it off?
        jne	short not_off	; no
        and     byte [0417h],~20h ; 0DFh
        jmp     short set_done
not_off:
        cmp     ax,[cs:OnOff]	; should we turn it on?
        stc
        jne	short set_done	; no
        or      byte [0417h],20h
set_done:
        pop     ds
	; 04/01/2023
	;pop	ax
        retn

; 16/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
;   menu_check:  check for presence of menu (and other) configuration blocks
;
;   INPUT
;       CX == "organized" config.sys memory image length
;    ES:SI -> "organized" config.sys memory image
;       DS == CS == sysinitseg
;
;   OUTPUT
;       Same as above; the idea is that menu_check simply transforms
;       a block-structured config.sys image into a conventional image,
;       based on the user's block selection and any other boot-time options
;       the user may have employed...
;
;   OTHER REGS USED
;       All
;
;   NOTES
;       [count] and [org_count] are set to the new config.sys image length
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4378h)

menu_check:

;   Search for SWITCHES, determine if /N or /F are present; if so, then
;   disable clean/interactive boot options

        push    cx              ;
        push    si              ;
        sub     bx,bx           ; remains ZERO until first block
swchk_loop:                     ;
        call    get_char        ; get first char of current line
        jc	short swchk_end	; hit eof
        cmp     al,CONFIG_BEGIN ; '['
        jne	short swchk_next1 ;
        inc     bx              ; remember that we've seen a block
        jmp     short swchk_nextline
swchk_next1:                    ;
        cmp     al,CONFIG_NUMLOCK
        jne	short swchk_next2 ;
        or      bx,bx           ; only do NUMLOCK commands that exist
        jnz	short swchk_nextline ; before the first block
        call    set_numlock     ; REM it out so we don't act on it later, too
        mov     byte [es:si-1],CONFIG_REM
        jmp     short swchk_nextline
swchk_next2:                    ;
        cmp     al,CONFIG_SWITCHES
        jne	short swchk_nextline ; this line ain't it
swchk_scan:                     ;
        call    get_char        ; look for /N or /F
swchk_scan1:                    ;
        cmp     al,LF           ; end of line?
        je	short swchk_nextline ; yes
        cmp     al,'/'          ; switch-char?
        jne	short swchk_scan ; no
        call    get_char        ;
        and     al,~20h ; 0DFh	; convert to upper case
        cmp     al,[swit_n+1]
        jne	short swchk_scan2 ; no
        or      byte [bDisableUI],1
        jmp	short swchk_scan ; continue looking for switches of interest
swchk_scan2:                    ;
        cmp     al,[swit_f+1]
        jne	short swchk_scan1 ; no
        or      byte [bDisableUI],2
        jmp     short swchk_scan ; continue looking for switches of interest
swchk_nextline:                 ;
        call    skip_opt_line   ;
        jmp     short swchk_loop ;
swchk_end:                      ;
        pop     si              ;
        pop     cx              ;

;   Do the keyboard tests for clean/interactive boot now, but only if
;   the DisableUI flag is still clear

        test    byte [bDisableUI],1
        jnz	short menu_search
;
;   Wait for 2 seconds first, UNLESS the /F bit was set in bDisableUI, or
;   there is anything at all in the keyboard buffer
;
        call    kbd_read
        jnc	short menu_search
        jmp	menu_abort

;   Search for MENU block; it is allowed to be anywhere in config.sys

menu_search:
        sub     bx,bx           ; if no MENU, default to zero for no_selection
        mov     di,szMenu	;
        call    find_block      ; find the MENU block
        jnc	short menu_found ;
        mov     byte [szBoot],0
        jmp	no_selection ; not found

;   Process the requested menu color(s)

menu_color:
        push    cx              ;
        push    dx              ;
        mov     dx,0007h        ; default color setting
        call    get_number	; get first number
        and     bl,0Fh		; first # is foreground color (for low nibble)
        mov     ch,bl           ; save it in CH
        and     dl,0F0h         ;
        or      dl,bl           ;
        call    delim           ; did we hit a delimiter
        jne	short check_color ; no, all done
        call    get_number	; get next number
        and     bl,0Fh		; second # is background color (for high nibble)
        mov     dh,bl           ; save it in DH
        and     dl,0Fh		;
        mov     cl,4            ;
        shl     bl,cl           ;
        or      dl,bl           ;
check_color:                    ;
        cmp     ch,dh           ; are foreground/background the same?
        jne	short set_color	; no
        xor     dl,08h          ; yes, so modify the fgnd intensity
set_color:
        mov     [bMenuColor],dl ;
        pop     dx              ;
        pop     cx              ;
        jmp	menu_nextitem

;   Back to our regularly scheduled program (the COLOR and other goop
;   above is there simply to alleviate short jump problems)

menu_found:
        mov     byte [bDefBlock],1
        mov     word [offDefBlock],0
        mov     byte [secTimeOut],-1
        and     byte [bQueryOpt],~2 ; 0FDh

        call    skip_opt_line   ; skip to next line
        sub     dx,dx           ; initialize total block count (0 => none yet)

;   Process the menu block now

menu_process:
        call    get_char        ; get first char of current line
        jc	short to_menu_getdefault ; could happen if menu block at end (rare)
        and     al,~CONFIG_OPTION_QUERY ; 7Fh
        cmp     al,CONFIG_BEGIN ; BEGIN implies END
        je	short to_menu_getdefault
        cmp     al,CONFIG_SUBMENU
        je	short menu_item	; go process sub-menu
        cmp     al,CONFIG_MENUITEM
        je	short menu_item	; go process menu item
        cmp     al,CONFIG_MENUDEFAULT
        je	short menu_default ; go process menu default
        cmp     al,CONFIG_MENUCOLOR
        je	short menu_color ; go process menu color
        cmp     al,CONFIG_NUMLOCK
        je	short menu_numlock ;
        cmp     al,CONFIG_REM   ; allow remarks in menu block
        je	short menu_nextitem ;
        call    any_delim       ; allow blank lines and such
        je	short menu_nextitem ;
        stc                     ;
        call    print_error     ; non-MENU command!
        jmp     short menu_nextitem
menu_numlock:
        call    set_numlock
        jmp     short menu_nextitem
to_menu_getdefault:
        jmp     short menu_getdefault

;   Save the offset of the default block name, we'll need it later

menu_default:
        mov     [offDefBlock],si; save address of default block name
        cmp     byte [secElapsed],0
        jne	short timeout_skip ; secElapsed is only zero for the FIRST menu,
        call    skip_token      ; and for subsequent menus IF nothing was typed;
        jc	short menu_nextitem ; secElapsed becomes -1 forever as soon as
        call    skip_delim      ; something is typed
        jc	short menu_nextitem ;
        mov     si,bx           ;
        call    get_number      ; get number (of seconds for timeout)
        cmp     bl,90           ; limit it to a reasonable number
        jb	short timeout_ok ; (besides, 99 is the largest # my simple
        mov     bl,90           ;  display function can handle)
timeout_ok:                     ;
        mov     [secTimeOut],bl ;
timeout_skip:
        jmp     short menu_nextitem

;   Verify that this is a valid menu item by searching for the named block

menu_item:
	;cmp	dl,9	; 04/01/2023
        cmp     dl,MAX_MULTI_CONFIG ; have we reached the max # of items yet?
        jae	short menu_nextitem ;
        mov     di,si           ; DS:DI -> block name to search for
        call    srch_block      ;
        je	short menu_itemfound ;
        stc                     ;
        call    print_error     ; print error and pause
        jmp     short menu_nextitem ; if not found, ignore this menu item

;   srch_block, having succeeded, returns DI -> past the token that it
;   just matched, which in this case should be a descriptive string; ES:SI
;   and CX are unmodified

menu_itemfound:
        inc     dx              ; otherwise, increment total block count
        mov     bx,dx           ; and use it to index the arrays of offsets
        mov	[abBlockType+bx],al
        add     bx,bx           ; of recorded block names and descriptions

;   There should be a description immediately following the block name on
;   MENUITEM line; failing that, we'll just use the block name as the
;   description...

        mov     [aoffBlockName+bx],si
        mov     [aoffBlockDesc+bx],si
        mov     di,bx           ; skip_delim modifies BX, so stash it in DI
        call    skip_token      ;
        jc	short menu_nextitem ; hit eol/eof
        call    skip_delim      ;
        jc	short menu_nextitem ; hit eol/eof
        xchg    bx,di           ;
        mov     [aoffBlockDesc+bx],di

menu_nextitem:
        call    skip_opt_line   ;
        jmp     menu_process    ; go back for more lines

;   Display menu items now, after determining which one is default

menu_getdefault:
        or      dl,dl           ; where there any valid blocks at all?
        jnz	short menu_valid ; yes
        sub     bx,bx           ; no, so force autoselect of 0
        jmp     menu_autoselect ; (meaning: process common blocks only)
menu_valid:
        sub     bx,bx           ;
        mov     [bMaxBlock],dl  ; first, record how many blocks we found
        mov     di,[offDefBlock];
        or      di,di           ; does a default block exist?
        jz	short menu_nodefault ; no
        inc     bx              ; yes, walk name table, looking for default
menu_chkdefault:
        push    bx              ;
        add     bx,bx           ;
        mov     si,[aoffBlockName+bx]
        mov     cx,128          ; arbitrary maximum length of a name
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    comp_names      ; is this block the same as the default?
        pop     ds              ;
        pop     bx              ;
        je	short menu_setdefault ; yes
        inc     bx              ;
        cmp     bl,[bMaxBlock]  ; all done searching?
        jbe	short menu_chkdefault ; not yet
menu_nodefault:
        mov     bl,1            ; if no default, force default to #1
menu_setdefault:
        mov     [bDefBlock],bl  ; yes, this will be the initial current block

;   If the timeout was explicitly set to 0 (or technically, anything that
;   failed to resolve to a number, like "NONE" or "EAT POTATOES"), then we're
;   supposed to skip menu display and run with the specified default block;
;   however, if the user hit Enter prior to boot, thereby requesting fully
;   INTERACTIVE boot, then we shall display the menu block anyway (though still
;   with no timeout)

        cmp     byte [secTimeOut],0 ; is timeout zero? (ie, assume default)
        jne	short menu_display ; no
        test    byte [bQueryOpt],1 ; yes, but was INTERACTIVE requested?
        jnz	short menu_display ; yes, so *don't* assume default after all
        jmp     not_topmenu	;

;   Reset the mode, so that we know screen is clean and cursor is home

menu_display:
        mov     ah,0Fh          ; get current video mode
        int     10h             ;
        mov     ah,00h          ; just re-select that mode
        int     10h             ;
        push    es              ;
        mov     ax,40h          ; reach down into the ROM BIOS data area
        mov     es,ax           ; and save the current (default) video page
        mov     ax,[es:004Eh]   ; start address and page #, in case the
        mov     [wCRTStart],ax  ; undocumented QUIET option was enabled
        mov     al,[es:0062h]   ;
        mov     [bCRTPage],al   ;
        mov     ax,[bMenuPage]	; select new page for menu
        int     10h             ;
        mov     ax,0600h        ; clear entire screen
        mov     bh,[bMenuColor] ; using this color
        sub     cx,cx           ; upper left row/col
        ;mov	dl,[es:CRT_Cols] 
        mov	dl,[es:4Ah]
	dec     dl              ;
        ;mov	dh,[es:CRT_Rows];
        mov	dh,[es:84h]
	or      dh,dh           ; # of rows valid?
        jnz	short menu_clear ; hopefully
        mov     dh,[bLastRow]   ; no, use a default
menu_clear:
        int     10h             ; clear the screen using the req. attribute
        pop     es              ;
        mov     [bLastRow],dh   ; save DH
        mov     dx,_$MenuHeader
        call    print           ; cursor now on row 3 (numbered from 0)

        test    byte [bDisableUI],1
        jnz     short menu_nostatus
        mov     bh,[bMenuPage]  ;
        mov     dh,[bLastRow]   ; restore DH
        mov     dl,0            ; print the status line on row DH, col 0,
        mov     ah,02h          ; now that we can trash the cursor position
        int     10h             ;
        mov     dx,_$StatusLine
        call    print           ;
        mov     ah,3            ; get cursor position
        int     10h             ;
        sub     dl,2            ;
        mov     [bLastCol],dl   ; save column where status char will go

menu_nostatus:
        mov     bx,1            ; now prepare to display all the menu items
menu_disploop:
        call    print_item	; print item #BL
        inc     bx              ; why "inc bx"?  because it's a 1-byte opcode
        cmp     bl,[bMaxBlock]  ; all done?
        jbe	short menu_disploop ; not yet

;   Set cursor position to just below the menu items

        mov     dl,0            ; select column
        mov     dh,bl           ;
        add     dh,4            ; select row below menu
        mov     bh,[bMenuPage]  ;
        mov     ah,02h          ; set cursor position beneath the block list
        int     10h             ;

        mov     dx,_$MenuPrmpt
        call    print           ;
        call    select_item     ; make a selection, return # in BX
        mov     dx,crlfm	
        call    print           ;
        push    word [bDisableUI]
        or      byte [bDisableUI],1
        call    show_status     ; clear the status line now
        pop     word [bDisableUI]

;   Now begins the "re-organization" process...

menu_autoselect:
        cmp     bx,-1           ; clean boot requested?
        jne	short normal_boot ; no
        call    disable_autoexec; basically, add a /D to the command.com line
menu_abort:
        sub     cx,cx           ; then immediately exit with 0 config.sys image
        jmp	menu_exit	;

normal_boot:
        cmp     bx,-2           ; back to top-level menu?
        jne	short not_topmenu ; no
        mov     cx,[count]      ; yes, start all over
        sub     si,si           ;
        jmp     menu_search

not_topmenu:
        cmp     byte [abBlockType+bx],CONFIG_SUBMENU
        jne	short not_submenu
        add     bx,bx           ;
        mov     di,[aoffBlockName+bx]
        call    srch_block      ; THIS CANNOT FAIL!
        mov     si,di           ;
        mov     cx,bx           ; ES:SI and CX are ready for another round
        jmp     menu_found

not_submenu:
        add     bx,bx           ; get BX -> name of selected block
        mov     bx,[aoffBlockName+bx]

;   BX should now either be ZERO (meaning no block has been selected) or
;   the offset relative to ES of the block name to be processed (along with
;   all the "common" lines of course)

no_selection:
        mov     [offDefBlock],bx; save selection
        mov     cx,[count]      ; reset ES:SI and CX for reprocessing
        sub     si,si           ;
        push    ds              ;
        mov     ds,[config_wrkseg]; this is where we'll store new config.sys image
        sub     di,di           ;

;   ES:SI-> config.sys, DS:DI -> new config.sys workspace
;
;   Work our way through the config.sys image again, this time copying
;   all lines that are (A) "common" lines outside any block or (B) lines
;   within the requested block. Lines inside INCLUDEd blocks are transparently
;   copied by copy_block in a recursive fashion; the amount of recursion is
;   limited by the fact INCLUDE statements are REMed by copy_block as they are
;   processed and by the number of unique INCLUDE stmts in config.sys...
;
;   BUGBUG 20-Mar-1992 JeffPar: If we can figure out the lower bound of the
;   stack we're running on, then we should check it inside copy_block

copyblock_loop:
        push    bx              ; save selected block name
        call    copy_block      ; process (named or common) block
        pop     bx              ;
        jc	short move_config ; hit eof

;   copy_block can only return for two reasons: it hit eof or a new block

copyblock_begin:
        push    ax              ;
        push    cx              ;
        push    si              ;
        push    di              ; always do "common" blocks
        mov     di,szCommon
        push    ds              ;
        push    cs              ;
        pop     ds              ;
        call    comp_names      ;
        pop     ds              ;
        pop     di              ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
        je	short copyblock_check
        or      bx,bx           ; is there a block name to check?
        jz	short copyblock_skip ; no
        push    di              ;
        mov     di,bx           ; check block against given block name
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    comp_names      ; is this the block we really want to do?
        pop     ds              ;
        pop     di              ;
copyblock_check:
        jc	short move_config ; hit eof
        jne	short copyblock_skip  ;
        call    skip_opt_line   ;
        jmp	short copyblock_loop 

copyblock_skip:                 ;
        call    skip_opt_line   ; this ain't the block we wanted, so skip it
        call    get_char        ;
        jc	short move_config ; hit eof
        and     al,~CONFIG_OPTION_QUERY ; 7Fh
        cmp     al,CONFIG_BEGIN ;
        je	short copyblock_begin
        jmp     short copyblock_skip ; anything else is just skipped
;
;   To create as little risk to the rest of SysInit as little as possible,
;   and to free the workspace at "config_wrkseg" for creating an environment,
;   copy the new config.sys image to "confbot"
;
move_config:
        mov     cx,di           ; now copy workspace at DS:DI to "confbot"
        push    cx              ;
;
;   But first, copy the CONFIG=<configuration><0> string to the workspace,
;   since the configuration name only currently exists in the "confbot" area
;
 	;mov	cx,7
	mov     cx,szMenu-szBoot-1
        mov     si,szBoot	; first copy the CONFIG= part
        inc     di              ; skip a byte, in case absolutely nothing
                                ; was copied to the workspace, because we always
                                ; zero the first byte of the workspace (below)
copy_boot: 
	;lods    byte ptr cs:[si];
        cs
	lodsb
	mov     [di],al         ;
        inc     di              ;
        loop    copy_boot       ;

        push    es              ; then copy the configuration name
        ;mov	cx,128-7	; put an upper limit on the name, to be safe
	; 04/01/2023
	mov	cl,128-7
	mov     si,[cs:offDefBlock]; ES:SI -> default block name
        or      si,si           ; valid?
        jnz	short l1	; yes
        push    cs              ;
        pop     es              ;
        mov     si,szCommon
l1:     mov     al,[es:si]      ;
        call    any_delim       ;
        je	short l2	;
        mov     [di],al         ;
        inc     si              ;
        inc     di              ;
        loop    l1              ;
l2:     mov     byte [di],lf	; terminate the configuration string
        pop     es              ;

;   Now we can copy "config_wrkseg" (DS) to "confbot" (ES)

        sub     di,di           ;
        mov     [cs:config_envlen],di
        sub     si,si           ;
        pop     cx              ; recover the size of "config_wrkseg"

        push    cx              ;
        rep     movsb           ; moved!
        pop     cx              ;
        mov     ax,ds           ;
        pop     ds              ;

;   Now that the config_wrkseg is available once again, we shall
;   use it to create an environment. The first thing to go in will be
;   the "CONFIG=configuration" thing. It is also important to zero
;   the first byte of the workspace, so that copy_envvar knows the buffer
;   is empty.

        push    es              ;
        mov     es,ax           ;
        inc     si              ; ES:SI -> "CONFIG=configuration"
        mov     byte [es:0],0	;empty the environment block
        call    copy_envvar     ; copy envvar at ES:SI to "config_wrkseg"
        pop     es

;   Before returning, restore the default video page setting but do NOT
;   do it using INT 10h's Set Active Page function, because if the menu was
;   displayed on a different page, then it's because we don't want to see
;   all the device driver/TSR goop (which goes to the default page)

menu_done:
        cmp     byte [bMenuPage],0
        je	short menu_exit	;
        push    es              ;
        mov     ax,40h          ;
        mov     es,ax           ;
        mov     ax,[wCRTStart]  ;
        mov     [es:004Eh],ax   ;
        mov     al,[bCRTPage]   ;
        mov     [es:0062h],al   ;
        pop     es              ;
menu_exit:
        mov     [count],cx      ; set new counts
        mov     [org_count],cx  ;
        sub     si,si           ; always return ES:SI pointing to config.sys
        retn

;----------------------------------------------------------------------------
;
;   copy_envvar:  copy the envvar at ES:SI to "config_wrkseg"
;
;   INPUT
;    ES:SI -> environment variable (in the form "var=string<cr/lf>")
;
;   OUTPUT
;       config_envlen (ie, where to put next envvar) updated appropriately
;       carry set if error (eg, missing =); clear otherwise
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 29-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:46D4h)

copy_envvar:
        push    cx              ;
        push    si              ;
        push    ds              ;
        push    es              ;
        push    es              ;
        mov     es,[config_wrkseg] ; ES:DI to point to next available byte
        pop     ds                 ; DS:SI to point to envvar

;   Have to calculate the length of the variable name (and if we hit
;   the end of the line before we hit '=', then it's curtains for this
;   config.sys line)
;
;   The check for NULL is important because copy_envvar is also used to copy
;   the initial CONFIG= setting, which will have been zapped by a NULL if no
;   menu block existed (in order to prevent the creation of an environment)

        sub     cx,cx           ;
copy_varlen:                    ;
        lodsb                   ;
        or      al,al           ; NULL?
        stc                     ;
        jz	short copy_envexit ; yes, abort
        cmp     al,cr          ;
        stc                     ;
        je	short copy_envexit
        cmp     al,lf          ;
        stc                     ;
        je	short copy_envexit
        inc     cx              ;
        cmp     al,'='          ;
        jne	short copy_varlen
        mov     al,0            ;
        mov     ah,[si]         ; save char after '='
        sub     si,cx           ; back up to given varname
        dec     cx              ; CX == # of bytes in varname
        sub     di,di           ; start looking for DS:SI at ES:0
copy_varsrch:
        cmp     byte [es:di],al
        je	short copy_envprep ; search failed, just copy var
        mov     bx,di           ; ES:BX -> start of this varname
        push    cx              ;
        push    si              ;
        repe    cmpsb           ;
        pop     si              ;
        pop     cx              ;
        jne	short copy_varnext ; no match, skip to next varname
        cmp     byte [es:di],'='
        jne     short copy_varnext ; no match, there's more characters

;   Previous occurrence of variable has been found; determine the
;   entire length and then destroy it

        mov     cx,-1           ;
        repne   scasb           ; guaranteed to get null (since we put it there)
        push    si              ;
        mov     si,di           ;
        mov     di,bx           ;
        mov     cx,[cs:config_envlen]
        sub     cx,si           ; destroy variable now
	;rep movs byte ptr es:[di],byte ptr es:[si]
	;;db 0F3h,26h,0A4h ; MSDOS 6.21 IO:SYS - SYSINIT:4724h

	rep	; 0F3h
	es	; 26h
	movsb	; 0A4h

	pop     si
copy_envprep:
        cmp     ah,cr          ; if there is nothing after the '='
        je	short copy_envdel ; then just exit with variable deleted
        cmp     ah,lf           ;
        je	short copy_envdel
        ;jmp	short copy_envloop
	; 04/01/2023
copy_envloop:                  ;
	lodsb                   ;
	cmp	al,cr           ;
	je	short copy_envdone
	cmp	al,lf           ;
	je	short copy_envdone
	stosb                   ;
	jmp	short copy_envloop

copy_varnext:                   ;
        push    cx              ;
        mov     cx,-1           ;
        repne   scasb           ;
        pop     cx              ;
        jmp	short copy_varsrch

	; 04/01/2023
;copy_envloop:                  ;
;	lodsb                   ;
;	cmp	al,cr           ;
;	je	short copy_envdone
;	cmp	al,lf           ;
;	je	short copy_envdone
;	stosb                   ;
;	jmp	short copy_envloop

copy_envdone:                   ;
        sub     al,al           ; do SUB to clear carry as well
        stosb                   ; always null-terminate these puppies
copy_envdel:                    ;
        mov     [es:di],al      ; and stick another null to terminate the env.
        mov     [cs:config_envlen],di

copy_envexit:                   ;
        pop     es              ;
        pop     ds              ;
        pop     si              ;
        pop     cx              ;

copy_done:	; 18/12/2022
        retn

;----------------------------------------------------------------------------
;
;   copy_block:  copy the current block to the new config.sys workspace
;
;   INPUT
;       CX == remaining bytes in "organized" config.sys memory image
;    ES:SI -> remaining bytes in "organized" config.sys memory image
;    DS:DI -> new config.sys workspace (equal in size to the original
;             config.sys image) where the current block is to be copied
;
;   OUTPUT
;       Same as above
;       AL also equals the last character read from the organized image
;
;   OTHER REGS USED
;       All
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4759h)

copy_block:
        call    get_char        ; check for include
        jc	short copy_done	;
	and     al,~CONFIG_OPTION_QUERY ; 7Fh
	cmp     al,CONFIG_BEGIN ; another BEGIN implies END as well
        je	short copy_done ;

        cmp     al,CONFIG_INCLUDE ; 'J'
        mov     al,ah           ; AL == the original line code
        jne	short copy_line	; not an "include" line

;   We have hit an "INCLUDE" line; first, REM out the line so that we
;   never try to include the block again (no infinite include loops please),
;   then search for the named block and call copy_block again.

        mov     byte [es:si-1],CONFIG_REM ; '0'
        push    di              ;

        mov     di,szMenu
        call    comp_names_safe ; don't allow INCLUDE MENU
        je	short copy_skip	;

        mov     di,szCommon
        call    comp_names_safe ; don't allow INCLUDE COMMON
        je	short copy_skip	;

        mov     di,si           ; try to find the block
        call    srch_block      ;
        mov     dx,di           ;
        pop     di              ;
        jne	short copy_error ; no such block
        push    cx              ;
        mov     cx,bx           ;
        push    si              ;
        dec     dx              ;
        mov     si,dx           ;
        call    skip_line       ; skip the rest of the "block name" line
        call    copy_block      ; and copy in the rest of that block
        pop     si              ;
        pop     cx              ;
        sub     al,al           ; force skip_opt_line to skip...
        jmp     short copy_nextline

copy_skip:
        pop     di
copy_error:
        clc                     ;
        call    print_error     ; note that carry is clear, no pause
        jmp     short copy_nextline

;   Copy the line at ES:SI to the current location at DS:DI

copy_line:
        mov     [di],al         ;
        inc     di              ;
        cmp     al,' '          ; is this is a "real" line with a "real" code?
        jb	short copy_nextline ; no
        cmp     byte [cs:config_multi],0
        je	short copy_loop	; not a multi-config config.sys, don't embed #s
        call    get_linenum	; BX == line # of line @ES:SI
        mov     [di],bx         ; stash it immediately following the line code
        inc     di              ;
        inc     di              ;
        jmp     short copy_next ;
copy_loop:                      ;
        call    get_char        ;
        jc	short copy_done ; end of file
        mov     [di],al         ;
        inc     di              ;
copy_next:
        cmp     al,lf ; 0Ah	; done with line?
        jne	short copy_loop	; nope

copy_nextline:
        call    skip_opt_line   ;
        jmp     short copy_block

	; 18/12/2022
;copy_done:
        ;retn

;----------------------------------------------------------------------------
;
;   get_linenum:  return line # (in BX) of current line (@ES:SI)
;
;   INPUT
;    ES:SI -> some line in the config.sys memory image
;
;   OUTPUT
;       BX == line # (relative to 1)
;
;   OTHER REGS USED
;       DX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

get_linenum:
        push    ax              ;
        sub     bx,bx           ; BX == line # (to be returned)
        push    cx              ;
        mov     dx,si           ; DX == the offset we're looking for
        push    si              ;
        mov     cx,[cs:count]   ;
        sub     si,si           ; prepare to scan entire file
get_linenum_loop:               ;
        call    skip_line       ;
        jc	short get_linenum_done
        inc     bx              ;
        cmp     si,dx           ; have we exceeded the desired offset yet?
        jb	short get_linenum_loop ; no
get_linenum_done:               ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
        retn

;----------------------------------------------------------------------------
;
;   srch_block:  searches entire config.sys for block name @ES:DI
;
;   INPUT
;       ES -> config.sys image
;    ES:DI -> block name to find
;
;   OUTPUT
;       ZF flag set, if found
;    ES:DI -> just past the name in the block heading, if found
;       BX == # bytes remaining from that point, if found
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This differs from "find_block" in that it searches the ENTIRE
;       config.sys image, not merely the remaining portion, and that it
;       takes a pointer to block name that is *elsewhere* in the image
;       (ie, ES) as opposed to some string constant in our own segment (DS).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

srch_block:	          ; returns BX -> named block in CONFIG.SYS
        push    ax              ;
        push    cx              ;
        mov     cx,[cs:count]   ;
        push    si              ;
        sub     si,si           ;
        push    ds              ;
        push    es              ;
        pop     ds              ;
        call    find_block      ;
        mov     di,si           ;
        mov     bx,cx           ;
        pop     ds              ;
        pop     si              ;
        pop     cx              ;
        pop     ax              ;
find_exit: ; 16/04/2019
        retn			;

;----------------------------------------------------------------------------
;
;   find_block:  searches rest of config.sys for block name @DS:DI
;
;   INPUT
;    DS:DI -> block name to find
;    ES:SI -> remainder of config.sys image
;       CX == remaining size of config.sys image
;
;   OUTPUT
;       ZF flag set, if found (also, CF set if EOF)
;    ES:SI -> where the search stopped (at end of block name or EOF)
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       This differs from "srch_block" in that it searches only the
;       remaining portion of the config.sys image and leaves SI and CX
;       pointing to where the search left off, and that it takes a pointer
;       to search string in our own segment (DS:DI instead of ES:DI).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

find_block:
        call    get_char        ; get line code
        jc	short find_exit	; end of file
        and     al,~CONFIG_OPTION_QUERY
        cmp     al,CONFIG_BEGIN ; beginning of a block?
        je	short check_line ; no
        cmp     al,CONFIG_INCLUDE
        jne	short next_line	;
        or	byte [cs:config_multi],1
        jmp     short next_line ;
check_line:
        or      byte [cs:config_multi],1
        call    comp_names      ; compare block names
        jbe	short find_exit	; end of file, or names matched
next_line:
        call    skip_opt_line   ; no, so skip to next line
        jmp	short find_block  ;
;find_exit:
;	retn

;----------------------------------------------------------------------------
;
;   comp_names:  compares keyword @DS:DI to position in config.sys @ES:SI
;
;   INPUT
;    DS:DI -> keyword to compare
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       ZF flag set, if match (also, CF set if EOF)
;    ES:SI -> where the comparison stopped (at end of block name or EOF)
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

comp_names:
        push    di              ;
comp_loop:                      ;
        call    get_char        ;
        jc	short comp_exit	;
        call    any_delim       ; is next character a delimiter?
        mov     ah,[di]         ; (get next character we're supposed to match)
        je	short comp_almost ; yes, it *could* be a match
        inc     di              ;
        and     ax,~2020h ; 0DFDFh 
				; BUGBUG -- assumes both names are alphanumeric -JTP
        cmp     al,ah           ; match?
        je	short comp_loop ; yes, keep looking at the characters
        clc                     ; prevent erroneous eof indication: clear carry
comp_exit:                      ;
        pop     di              ;
        retn			;
comp_almost:                    ;
        xchg    al,ah           ; we don't know for sure if it's a match
        call    any_delim       ; until we verify that the second string has
        xchg    al,ah           ; been exhausted also...
        jmp     short comp_exit ; if we are, this call to any_delim will tell...

;----------------------------------------------------------------------------

comp_names_safe:
        push    ax
        push    cx
        push	si
        push    ds
        push    cs
        pop     ds
        call    comp_names
        pop     ds
	pop	si
        pop     cx
        pop     ax
        retn

;----------------------------------------------------------------------------
;
;   print_item:  display menu item #BL
;
;   INPUT
;       BL == menu item # to display
;
;   OUTPUT
;       Menu item displayed, with appropriate highlighting if BL == bDefBlock
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This function saves/restores the current cursor position, so you
;       needn't worry about it.
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 04/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:485Ah)

print_item:		; prints menu item #BL (1 to N)
        push    ax              ;
        push    bx              ;
        push    cx              ;
        push    dx              ;
        push    si              ;
        mov     ah,03h          ; get cursor position
        mov     bh,[bMenuPage]  ; always page zero
        int     10h             ; DH/DL = row/column
        push    dx              ; save it
        mov     ah,02h          ; set cursor position
        mov     dh,bl           ;
        add     dh,3            ;
        mov     dl,5            ;
        int     10h             ; set cursor position for correct row/col
        mov     al,bl           ;
        add     al,'0'          ; convert menu item # to ASCII digit
        mov     ah,[bMenuColor] ; normal attribute
        cmp     bl,[bDefBlock]  ; are we printing the current block?
        jne	short print_other ; no
        or      ah,70h          ; yes, set bgnd color to white
        mov     ch,ah           ;
        mov     cl,4            ;
        rol     ch,cl           ;
        cmp     ch,ah           ; are fgnd/bgnd the same?
        jne	short print_other ; no
        xor     ah,08h          ; yes, so modify the fgnd intensity
print_other:                    ;
        mov     bh,0            ;
        add     bx,bx           ;
        mov     di,[aoffBlockDesc+bx]
        mov     bl,ah           ; put the attribute in the correct register now
        mov     bh,[bMenuPage]  ; get correct video page #
        mov     ah,09h          ; write char/attr
        mov     cx,1            ;
        int     10h             ;
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        ;mov	ax,0900h+'.'    ;
        mov	ax,092Eh
	int     10h             ; display '.'
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        ;mov	ax,0900h+' '    ;
        mov	ax,0920h
	int     10h             ; display ' '
        inc     dl              ; increment column
        mov     ah,02h          ;
        int     10h             ;
        push    es              ;
print_loop:                     ;
        mov     al,[es:di]	; get a character of the description
        inc     di              ;
        cmp     al,TAB ; 9	; substitute spaces for tabs
        jne	short print_nontab ;
        mov     al,' '          ;
print_nontab:                   ;
        cmp     al,' '          ;
        jb	short print_done ; stop at the 1st character < space
        cmp     al,'$'          ;
        je	short print_done ; also stop on $
        mov     ah,09h          ; display function #
        int     10h             ;
        inc     dl              ; increment column
        cmp     dl,78           ; far enough?
        jae	short print_done ; yes
        mov     ah,02h          ;
        int     10h             ;
        jmp	short  print_loop
print_done:                     ;
        pop     es              ;
        pop     dx              ;
        mov     ah,02h          ;
        int     10h             ; restore previous row/col
        pop     si              ;
        pop     dx              ;
        pop     cx              ;
        pop     bx              ;
        pop     ax              ;
        retn			;

;----------------------------------------------------------------------------
;
;   select_item:  wait for user to select menu item, with time-out
;
;   INPUT
;       None
;
;   OUTPUT
;       BX == menu item # (1-N), or -1 for clean boot
;       Selected menu item highlighted
;       Cursor positioned beneath menu, ready for tty-style output now
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

select_item:		; returns digit value in BX (trashes AX/CX/DX)
        mov     bl,[bDefBlock]  ; BL will be the default block #
        mov     al,bl           ;
        call    disp_num        ;
        call    show_status     ; display current interactive status
        cmp     byte [secTimeOut],-1
        je	short input_key	; no time-out, just go to input
        mov     ah,GET_TIME ; 2Ch
        int     21h             ;
        mov     bh,dh           ; BH = initial # of seconds
check_time:
        mov     al,[secTimeOut] ;
        sub     al,[secElapsed] ;
        jae	short show_time	;
        or      byte [bQueryOpt],2  ; disable all further prompting
        mov     byte [secElapsed],0
        jmp	select_done	; time's up!
show_time:
        push    bx              ;
        mov     bl,al           ; save # in BL
        mov     bh,[bMenuPage]  ;
        mov     ah,03h          ; get cursor position
        int     10h             ;
        push    dx              ;
	add	dl,8		; move cursor to the right
        mov     ah,02h          ; set cursor position
        int     10h             ;
        mov     dx,_$TimeOut
        call    print           ; print the "Time remaining: " prompt
        mov     al,bl           ; recover # from BL
        cbw                     ; this works because AL is always <= 90
        mov     cl,10           ;
        div     cl              ; AL = tens digit, AH = ones digit
        mov     cl,ah           ;
        add     al,'0'          ;
        mov     ah,0Eh          ;
        int     10h             ; write TTY tens digit
        mov     al,cl           ;
        add     al,'0'          ;
        mov     ah,0Eh          ;
        int     10h             ; write TTY ones digit
        pop     dx
        mov     ah,02h          ; set cursor position back to where it was
        int     10h             ;
        pop     bx              ;
input_key:
        mov     ah,RAW_CON_IO ; 6
        mov     dl,0FFh         ; input request
        int     21h             ;
        jnz	short got_key	;
        cmp     byte [secTimeOut],-1; is there a time-out?
        je	short input_key	; no, just go back to input
        mov     ah,GET_TIME     ;
        int     21h             ; DH = seconds
        mov     ah,dh           ;
        sub     dh,bh           ; should generally be zero or one
        mov     bh,ah           ;
        jnc	short got_time	;
        mov     dh,1            ; it wrapped back to zero, so assume one
got_time:
        or      dh,dh           ; any change?
        jz	short input_key	; no
        add     [secElapsed],dh ;
        jmp	short check_time ;
got_key:
        push    ax              ;
        mov     ax,-1           ; zap both secTimeOut and secElapsed
        xchg    [secTimeOut],ax
        cmp     al,-1           ; was time-out already disabled?
        je	short timeout_disabled ; yes
        push    bx              ; let's disable # seconds display
        mov     ax,0A20h        ; write multiple spaces
        mov     bx,[bMenuColor]
        mov     cx,80           ; 80 of them, to be safe
        int     10h             ; to completely obliterate # seconds display
        pop     bx   		;

timeout_disabled:
        pop     ax              ;
        or      al,al           ; extended key pressed?
        jnz	short normal_key ; no
        int     21h             ; get the next part of the key then
        jz	short input_key	; hmmm, what happened to the second part?

        cmp     al,48h          ; up arrow?
        jne	short not_up	; no
        cmp     bl,1            ; are we as up as up can get?
        jbe	short input_key	; yes, ignore it
        dec     byte [bDefBlock] ;
        call    print_item      ; re-print the current item
        dec     bl              ; and then print the new current item
        jmp     short print1
not_up:
        cmp     al,50h          ; down arrow?
        jne	short not_down	; no
        cmp     bl,[bMaxBlock]  ; are we as down as down can get?
        jae	short to_input_key ; yes, ignore it
        inc     byte [bDefBlock] ;
        call    print_item      ; re-print the current item
        inc     bx              ; and then print the new current item
print1: 
	mov     al,bl           ;
print2: 
	call    print_item      ;
        call    disp_num        ;
to_input_key:
        jmp     input_key       ;
not_down:
        test    byte [bDisableUI],1
        jnz	short to_input_key ; don't allow F8 or F5
        cmp     al,42h          ; F8 function key?
        jne	short not_f8	; no
        xor     byte [bQueryOpt],1
        call    show_status     ;
        jmp     input_key	;
not_f8:
        cmp     al,3Fh          ; F5 function key?
        jne	short to_input_key ; no
        mov     bx,-1           ; special return code (-1) indicating clean boot
        mov     al,' '          ; don't want to display anything really;
        jmp     short disp_input; just want to display the cr/lf sequence...

normal_key:
        cmp     al,0Dh          ; Enter?
        je	short select_done ; yes
        cmp     al,08h          ; backspace?
        jne	short not_backspace ; no
        mov     bx,-2 ; 0FFFEh	; yes, special return code
        retn			;
not_backspace:
        sub     al,'0'          ; is greater than '0'?
        jbe	short to_input_key ; no
        cmp     al,[bMaxBlock]  ; is less than or equal to the maximum digit?
        ja	short to_input_key ; no
        mov	[bDefBlock],al  ;
        call    print_item      ; redisplay the current selection
        mov     bl,al           ; set new selection
        jmp	short print2

select_done:
        mov     bh,0            ; return a full 16-bit value (for indexing)
        mov     al,bl           ;
        add     al,'0'          ; convert it into a digit, then display it

	; fall into disp_input

; 16/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
;   disp_input:  display a single character + cr/lf
;
;   INPUT
;       AL == character to display
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       This function is used not only for the menu input selection but
;       also for the interactive line prompting (the y/n/a thing).
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

disp_input:
        push    ax
        cmp     al,' '
        jae	short disp_ok
        mov     al,' '
disp_ok:
        mov     dl,al
        mov     ah,STD_CON_OUTPUT ; 2
        int     21h
        mov     dx,crlfm
        call    print
        pop     ax
        retn

;----------------------------------------------------------------------------

disp_num:
        push    bx
        add     al,'0'
        mov     ah,0Ah
        mov     bx,[bMenuColor]
        mov     cx,1
        int     10h
        pop     bx
        retn

;----------------------------------------------------------------------------
;
;   show_status:  display current interactive mode setting (on/off/none)
;
;   INPUT
;       None
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

show_status:
        push    bx              ; BL = video page #
        mov     bx,[bMenuColor]
        mov     ah,03h          ; get cursor position
        int     10h             ;
        push    dx              ; save it
        mov     ah,02h          ; set cursor position
        mov     dx,[bLastCol]   ; set correct row/col
        test    byte [bDisableUI],1
        jz	short show_onoff ; just show on/off
        mov     dl,0            ;
        int     10h             ;
        mov     ax,0A20h        ; write multiple spaces
        mov     cx,80           ; 80 of them, to be exact
        int     10h             ; to obliterate the status line
        jmp     short show_done ;
show_onoff: 
        int     10h
		; - VIDEO - WRITE CHARACTERS ONLY AT CURSOR POSITION
		; AL = character, BH = display page - alpha mode
		; BL = color of character (graphics mode, PCjr only)
		; CX = number of times to write character

        mov     al,[_$NO]	; assume OFF
        cmp     byte [bQueryOpt],1 ; is interactive mode on?
        jne	short show_noton ; no
        mov     al,[_$YES]	; yes
show_noton:                     ;
        mov     ah,0Eh          ; write TTY
        int     10h             ;
show_done:                      ;
        pop     dx              ;
        mov     ah,02h          ;
        int     10h             ; restore original cursor position
        pop     bx              ;
        retn			;

; 16/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
;   skip_token: advances ES:SI/CX past the current token
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOL/EOF hit
;       AL == 1st char of delimiter
;    ES:SI -> just past the delimiter
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

skip_token:
        call    get_char
        jc	short skip_token_done
        call    any_delim
        jne	short skip_token
skip_check_eol:
        cmp     al,cr ; 0Dh
        je	short skip_token_eol
        cmp     al,lf ; 0Ah
        je	short skip_token_eol
        clc
        ;jmp	short skip_token_done
	retn
skip_token_eol:
        stc
skip_token_done:
        retn

;----------------------------------------------------------------------------
;
;   skip_delim: advances ES:SI/CX past the current delimiter
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;       AL == 1st char of token
;    ES:SI -> just past the token
;       CX == # bytes remaining from that point
;    ES:BX -> new token (since ES:SI is already pointing 1 byte past token)
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

skip_delim:	; returns carry set if eol/eof
        call    get_char        ;
        lea     bx,[si-1]       ; also returns BX -> next token
        jc	short skip_token_done ;
        call    delim           ;
        je	short skip_delim ;
        jmp	short skip_check_eol  ; 13/05/2019

;----------------------------------------------------------------------------
;
;   skip_opt_line: same as skip_line provided AL != LF
;
;   INPUT
;       AL == last character read
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;       AL == 1st char of new line
;    ES:SI -> just past 1st char of new line
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       In other words, the purpose here is to skip to the next line,
;       unless ES:SI is already sitting at the front of the next line (which
;       it would be if the last character fetched -- AL -- was a linefeed)
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

skip_opt_line:
        cmp     al,lf ; 0Ah
        je	short skip_line_done
     
	; fall into skip_line

;----------------------------------------------------------------------------
;
;   skip_line: skip to the next line
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       CF set if EOF hit
;    ES:SI -> just past 1st char of new line
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

skip_line:
        call    get_char
        jc	short skip_line_done
        cmp     al,lf ; 0Ah
        jne	short skip_line
skip_line_done:
num_done:	; 18/12/2022
        retn

;----------------------------------------------------------------------------
;
;   get_number: return binary equivalent of numeric string
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       AL == non-digit encountered
;       BX == binary #
;    ES:SI -> just past 1st non-digit
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

; 13/05/2019

get_number:
        sub     bx,bx           ; BX = result
num_loop:
        call    get_char        ;
        jc	short num_done	;
        cmp     al,'0'          ; convert to value
        jb	short num_done	; no more number
        cmp     al,'9'          ;
        ja	short num_done	;
        push    ax              ;
        mov     ax,10           ;
        push    dx              ;
        mul     bx              ;
        pop     dx              ;
        mov     bx,ax           ;
        pop     ax              ;
        sub     al,'0'          ;
        cbw                     ;
        add     bx,ax           ;
        jmp	short num_loop	;

	; 18/12/2022
;num_done:
        ;retn

;----------------------------------------------------------------------------
;
;   get_char:  return next character, advance ES:SI, and decrement CX
;
;   INPUT
;    ES:SI -> position in config.sys
;       CX == remaining bytes in config.sys
;
;   OUTPUT
;       AL == next character
;    ES:SI -> just past next character
;       CX == # bytes remaining from that point
;
;   OTHER REGS USED
;       AX
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

get_char:
        sub     cx,1            ; use SUB to set carry,zero
        jb	short get_fail	; out of data
        ;lods	byte ptr es:[si] ;
	es	
	lodsb
        mov     ah,al           ;
        retn			;
get_fail:                       ; restore CX to zero
        mov     cx,0            ; leave carry set, zero not set
nearby_ret:
        retn

;----------------------------------------------------------------------------
;
;   query_user: ask user whether to execute current config.sys command
;
;   INPUT
;       AL == current command code
;    ES:SI -> current command line in config.sys
;    config_cmd == current command code, but with QUERY bit intact
;                  (00h used to generate "Process AUTOEXEC.BAT" prompt)
;
;   OUTPUT
;       CF set if command should be ignored (it is also REM'ed out)
;
;   OTHER REGS USED
;       BX, CX, DX, DI
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

	; 31/12/2022 - Retro UNIX 386 v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4AE5h)

	; 12/12/2022
query_user:
        test    byte [bQueryOpt],4	; answer no to everything?
	; 01/01/2023
	jz	short qu_1		;
	jmp	skip_all
	; 12/12/2022
	;;jmp	short skip_all		;
	;jnz	short skip_all
qu_1:
	test    byte [bQueryOpt],2	; answer yes to everything?
        jnz	short nearby_ret	; yes (and return carry clear!)
        push    ax                      ;
        mov     al,[config_cmd]         ;
        test    byte [bQueryOpt],1	; query every command?
        jnz	short query_all		; yes
        test    al,CONFIG_OPTION_QUERY  ;
	; 01/01/2023
	jnz	short query_all		;
	; 12/12/2022
	;;jmp	short do_cmd		;
	;jz	short do_cmd ; cf=0

	; 01/01/2023
	pop	ax
	retn

query_all:

;   Search for the command code (AL) in "comtab", and then print
;   out the corresponding keyword, followed by the rest of the actual
;   line pointed to by ES:SI

        push    si                      ; save pointer to rest of CONFIG.SYS line
        mov     dx,_$AutoPrmpt    	;
        and     al,~CONFIG_OPTION_QUERY ; 7Fh
        jz	short generic_prompt	; config_cmd must have been 0

        mov     dh,al                   ; save config_cmd in DH
        sub     bx,bx                   ;
        mov     di,comtab		;
find_match:                             ;
        mov     bl,[di]                 ; get size of current keyword
        or      bl,bl                   ;
        jz	short line_print	; end of table
        inc     di                      ;
        cmp     al,[di+bx]              ; match?
        je	short cmd_match		; yes
        lea     di,[di+bx+1]            ; otherwise, skip this command code
	; 13/05/2019	
        jmp	short find_match	; loop
cmd_match:                              ;
        mov     cl,[di-1]               ;
        mov	ch,0                    ;
        mov     ah,STD_CON_OUTPUT ; 2
cmd_print:                              ;
        mov     al,[di]                 ;
        inc     di                      ;
        mov     dl,al                   ;
        int     21h                     ;
        loop    cmd_print               ;
        mov     dl,'='                  ;
        cmp     dh,CONFIG_SET  ; 'V'    ; for SET commands, don't display a '='
        jne	short cmd_notset	;
        mov     dl,' '                  ;
cmd_notset:
        int     21h                     ; '=' looks funny on SET commands
line_print:                             ;
	;lods	byte ptr es:[si]        ;
        es
	lodsb
	or      al,al                   ;
        jnz	short non_null		;
        mov     al,' '                  ;
non_null:                               ;
        cmp     al,' '                  ; control code?
        jb	short prompt_user	; yes, assume end of line
        jne	short non_space		;
        cmp     byte [es:si],' '	;
        jb	short prompt_user	;
non_space:                              ;
        mov     dl,al                   ;
        mov     ah,STD_CON_OUTPUT ; 2	;
        int     21h                     ;
        jmp	short line_print	;
prompt_user:                            ;
        mov     dx,_$InterPrmpt		;

generic_prompt:
        call    print                   ;
input_loop:                             ;
        mov     ah,0                    ; read a key
        int     16h                     ;
        or      al,al                   ; is it a function key?
        jnz	short not_func		; no
        cmp     ah,3Fh                  ; F5 function key?
        jne	short input_loop	; no
        mov     al,[_$NO]                  ;
        or      byte [bQueryOpt],4	; no more queries
        jmp     short legal_char        ;
not_func:
        and     al,~20h ; 0DFh		; converting to upper case
        cmp     al,[_$NO]		; verify character is legal
        je	short legal_char	;
        cmp     al,[_$YES]		;
        je	short legal_char	;
        cmp     byte [config_cmd],0	;
        je	short input_loop	; don't allow Esc on this query
        cmp     al,1Bh                  ; Esc?
        jne	short input_loop	;
        or      byte [bQueryOpt],2	; no more interactive boot prompts
        mov     al,[_$YES]
legal_char:                             ;
        call    disp_input              ;
        pop     si                      ; restore pointer to rest of CONFIG.SYS line

        cmp     al,[_$NO]		; process line?
        je	short skip_cmd		; no
	; 12/12/2022
	clc
do_cmd:
	pop     ax			;
	; 12/12/2022
	; cf=0
	;clc				; just do the command
	retn

skip_cmd:
	pop     ax			;
skip_all:
	mov     ah,CONFIG_REM ; '0'	; fake out the rest of sysinit's processing
	stc
	retn

;----------------------------------------------------------------------------
;
;   print_error: displays multi-config error conditions
;
;   INPUT
;    Carry set to pause, clear to not
;    ES:SI -> current command line in config.sys
;
;   OUTPUT
;       None
;
;   OTHER REGS USED
;       None
;
;   NOTES
;       None
;
;   HISTORY
;       Created 16-Mar-1992 by JeffPar
;
;----------------------------------------------------------------------------

print_error:
        push    ax
        push    bx
        push    cx
        push    dx
        push    ds
        push    cs
        pop     ds
        pushf
        call    get_linenum
        mov     [linecount],bx
        call    error_line
        popf
        jnc	short pe_ret
        mov     dx,_$PauseMsg
        call    print
        mov     ax,0C07h		; flush input buffer, then wait for key
        int     21h			; wait for a key
        or      al,al			; extended key?
        jnz	short pe_1		; no
        mov     ah,07h			; yes
        int     21h			; eat it too
pe_1:     
	mov     dx,crlfm
        call    print
pe_ret: 
	pop     ds
        pop     dx
        pop     cx
        pop     bx
        pop     ax
	retn

;----------------------------------------------------------------------------

;   This function is very simple: it merely prepends a "/D" to the
;   command-line for the shell; this (undocumented) switch disables
;   AUTOEXEC.BAT processing and the date/time prompt that is usually
;   displayed when there's no AUTOEXEC.BAT.

disable_autoexec:
	; MSDOS 6.21 IO.SYS -  SYSINIT:4BE2h
	; 17/04/2019 - Retro DOS v4.0

	test	byte [bQueryOpt],4
	jz	short disable_exit
	test	byte [dae_flag],1
	jnz	short disable_exit
	or	byte [dae_flag],1
        ;or	byte [bQueryOpt],2 ; MSDOS 6.0 
	or      word [bQueryOpt],102h	; [bDefBlock] = 1
	mov     dx,'D ' ; 2044h
dae_1:
        ;mov	al,[def_swchr]
	mov     al,[command_line-1]     ; get default switchchar
        or      al,al                   ; anything there?
        jz	short disable_exit	; no, disable_autoexec already called
        mov     bl,[command_line]       ;
        mov     bh,0                    ; BX == command-line length
        mov     cx,bx                   ;
        add     bl,3                    ;
        cmp     bl,126                  ;
        ja	short disable_exit	;
        mov     [command_line],bl       ; update length
        add     bx,command_line+1	; make sure we move the NULL too
        inc     cx                      ; (just for consistency sake)
disable_loop:                           ;
        mov     ah,[bx-3]               ;
        mov     [bx],ah                 ;
        dec     bx                      ;
        loop    disable_loop            ;
        mov     [bx-2],al               ;
	;mov	word [bx-1],'D ' ; 2044h ; /D is stuffed into place now
	mov	[bx-1],dx  ; MSDOS 6.21 IO.SYS - SYSINIT:4C29h		
        ;mov	byte [command_line-1],0 ;
disable_exit:                           ;
        retn

CheckQueryOpt:	; MSDOS 6.21 IO.YSYS - SYSINIT:4C2Dh
	cmp     byte [bQueryOpt],1
	jnz     short disable_exit
	test	byte [dae_flag],2
	jnz     short disable_exit
	or      byte [dae_flag],2
	mov     dx,' Y'
	jmp     short dae_1

;endif  ;MULTI_CONFIG

;%endif	; 02/11/2022


; 19/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
;
; procedure : delim
;
;----------------------------------------------------------------------------

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:4C45h)

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0
;;ifdef	MULTI_CONFIG
;
any_delim:
	cmp	al,cr
	je	short delim_ret
	cmp	al,lf
	je	short delim_ret
	cmp	al,'['
	je	short delim_ret
	cmp	al,']'
	je	short delim_ret
;
;;endif ;MULTI_CONFIG
;%endif ; 02/11/2022

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:3450h)	
delim:
	cmp	al,'/'		; ibm will assume "/" as an delimeter.
	je	short delim_ret

	cmp	al,0		; special case for sysinit!!!
	je	short delim_ret

org_delim:			; used by organize routine except for getting
	cmp	al,' '          ; the filename.
	je	short delim_ret
        cmp     al,tab ; 9
	je	short delim_ret
	cmp	al,'='
	je	short delim_ret
	cmp	al,','
	je	short delim_ret
	cmp	al,';'

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 04/01/2023 - Retro DOS v4.2
;ifdef	MULTI_CONFIG
;   Make sure there's no chance of a false EOF indication
	clc
;endif
	; 02/11/2022
delim_ret:
	; 04/01/2023
	; cf = 0
	retn

;----------------------------------------------------------------------------
;
; procedure : newline
;
;  newline returns with first character of next line
;
;----------------------------------------------------------------------------

newline:
	call	getchr			;skip non-control characters
	jc	short nl_ret
	cmp	al,lf			;look for line feed
	jne	short newline
	call	getchr
nl_ret:
	retn

;----------------------------------------------------------------------------
; 
; procedure : mapcase
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retro DOS 4.0 (Modified MSDOS 5.0 IO.SYS)

	; 04/01/2023 - Retro DOS 4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4C7Eh)
mapcase:
	push	cx
	push	si
	push	ds

	push	es
	pop	ds

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 04/01/2023 - Retro DOS 4.2

;ifdef	MULTI_CONFIG
	mov	bl,al			; same cmd code this line
;else
;	xor	si,si
;endif
	; 02/11/2022
	; 04/01/2023 - Retro DOS 4.2
	;xor	si, si

convloop:
	lodsb
	cmp	al,'a'
	jb	short noconv
	cmp	al,'z'
	ja	short noconv
	sub	al,20h
	mov	[si-1],al
noconv:

	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)

; 04/01/2023 - Retro DOS 4.2
;ifdef	MULTI_CONFIG

;   When MULTI_CONFIG enabled, "mapcase" is used to map everything to
;   upper-case a line at a time, after we've been able to figure out whether
;   the line is a SET command or not (since we don't want to upper-case
;   anything after the "=" in a SET)
;
	cmp	bl,CONFIG_SET  ; 'V'	; preserve case for part of the line?
	jne	short check_eol		; no, just check for end-of-line
	cmp	al,'='                  ; separator between SET var and value?
	je	short convdone		; yes
check_eol:
	cmp	al,cr
	je	short convdone
	cmp	al,lf
	je	short convdone
;endif
	; 02/11/2022
	loop	convloop
convdone:
	pop	ds
	pop	si
	pop	cx
	retn

;----------------------------------------------------------------------------
;
; procedure : round
;
; round the values in memlo and memhi to paragraph boundary.
; perform bounds check.
;
;----------------------------------------------------------------------------

round:
	push	ax
	mov	ax,[cs:memlo]

	call	ParaRound		; para round up

	add	[cs:memhi],ax
	mov	word [cs:memlo],0
	mov	ax,[cs:memhi]		; ax = new memhi
	cmp	ax,[cs:ALLOCLIM]	; if new memhi >= alloclim, error
	jae	short mem_err
	test	byte [cs:setdevmarkflag],for_devmark ; 2
	jz	short skip_set_devmarksize
	push	es
	push	si
	mov	si,[cs:devmark_addr]
	mov	es,si
	sub	ax,si
	dec	ax
	;mov	[es:3],ax
	mov	[es:devmark.size],ax	; paragraph
	and	byte [cs:setdevmarkflag],not_for_devmark ; 0FDh
	pop	si
	pop	es
skip_set_devmarksize:
	pop	ax
	; 11/12/2022
	; cf = 0
	; 02/11/2022
	;clc	; ? (not needed here)	; clear carry
	retn

;----------------------------------------------------------------------------

mem_err:
	; 11/12/2022
	push	cs
	pop	ds
mem_err2:
	mov	dx,badmem
	;push	cs
	;pop	ds
	call	print
	jmp	stall

;----------------------------------------------------------------------------
;
; procedure : calldev
;
;----------------------------------------------------------------------------

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:34E0h)
calldev:
	mov	ds,[cs:DevEntry+2]
	add	bx,[cs:DevEntry]	; do a little relocation
	mov	ax,[bx]

	push	word [cs:DevEntry]
	mov	word [cs:DevEntry],ax
	mov	bx,packet
	call	far [cs:DevEntry]
	pop	word [cs:DevEntry]
	retn

;----------------------------------------------------------------------------
;
; procedure : todigit
;
;----------------------------------------------------------------------------

todigit:
	sub	al,'0'
	;jb	short notdig  ; 02/11/2022
	; 12/12/2022
	jb	short notdig2
	;cmp	al,9
	;ja	short notdig
	;clc
	;retn
	; 12/12/2022
	cmp	al,10
	cmc
notdig:
	;stc
notdig2:
	retn

;----------------------------------------------------------------------------
;
; procedure : getnum
;
; getnum parses a decimal number.
; returns it in ax, sets zero flag if ax = 0 (may be considered an
; error), if number is bad carry is set, zero is set, ax=0.
;
;----------------------------------------------------------------------------

getnum:
	push	bx
	xor	bx,bx			; running count is zero
b2:
	call	todigit 		; do we have a digit ?
	jc	short badnum		; no, bomb

	xchg	ax,bx			; put total in ax
	push	bx			; save digit (0 to 9)
	;mov	bx,10			; base of arithmetic
	; 12/12/2022
	mov	bl,10
	mul	bx			; shift by one decimal digit
	pop	bx			; get back digit (0 to 9)
	add	al,bl			; get total
	adc	ah,0			; make that 16 bits
	jc	short badnum		; too big a number

	xchg	ax,bx			; stash total

	call	getchr			;get next digit
	jc	short b1		; no more characters
	cmp	al,' ' 			; space?
	je	short b15		; then end of digits
	cmp	al,',' 			; ',' is a seperator!!!
	je	short b15		; then end of digits.
	cmp	al, tab ; 9		; tab
	je	short b15
	cmp	al,[cs:sepchr]		; allow 0 or special separators
	je	short b15
	cmp	al,'/'			; see if another switch follows
	; 12/12/2022
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;nop				; cas - remnant of old bad code
	;nop
	je	short b15
	cmp	al,lf			; line-feed?
	je	short b15
	cmp	al,cr			; carriage return?
	je	short b15
	or	al,al			; end of line separator?
	jnz	short b2		; no, try as a valid char...
b15:
	inc	word [cs:count]		; one more character to s...
	dec	word [cs:chrptr]	; back up over separator
b1:
	mov	ax,bx			; get proper count
	or	ax,ax			; clears carry, sets zero accordingly
	pop	bx
	retn
badnum:
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;mov	byte [cs:sepchr],0
	xor	ax,ax			; set zero flag, and ax = 0
	; 12 /12/2022
	mov	[cs:sepchr],al ; 0
	pop	bx
	stc				; and carry set
	retn

;****************************************************************************

setdoscountryinfo:

;----------------------------------------------------------------------------
;input: es:di -> pointer to dos_country_cdpg_info
;	ds:0  -> buffer.
;	si = 0
;	ax = country id
;	dx = code page id. (if 0, then use ccsyscodepage as a default.)
;	bx = file handle
;	this routine can handle maximum 438 country_data entries.
;
;output: dos_country_cdpg_info set.
;	 carry set if any file read failure or wrong information in the file.
;	 carry set and cx = -1 if cannot find the matching country_id, 
;	 codepage_id in the file.
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4D83h)

	push	di
	push	ax
	push	dx

	xor	cx,cx
	xor	dx,dx
	mov	ax,512			;read 512 bytes
	call	readincontrolbuffer	;read the file header
	jc	short setdosdata_fail

	push	es
	push	si

	push	cs
	pop	es

	mov	di,country_file_signature ; db 0FFh,'COUNTRY'
	mov	cx,8			;length of the signature
	repz	cmpsb

	pop	si
	pop	es
	jnz	short setdosdata_fail 	;signature mismatch

	add	si,18			;si -> county info type
	cmp	byte [si],1		;only accept type 1 (currently only 1 header type)
	jne	short setdosdata_fail 	;cannot proceed. error return

	inc	si			;si -> file offset
	mov	dx,[si]			;get the info file offset.
	mov	cx,[si+2]
	mov	ax,6144			;read 6144 bytes.
	call	readincontrolbuffer	;read info
	jc	short setdosdata_fail

	mov	cx,[si]			;get the # of country, codepage combination entries
	cmp	cx, 438			;cannot handle more than 438 entries.
	ja	short setdosdata_fail

	inc	si
	inc	si			;si -> entry information packet
	pop	dx			;restore code page id
	pop	ax			;restore country id
	pop	di

setdoscntry_find:			;search for desired country_id,codepage_id.
	cmp	ax,[si+2]		;compare country_id
	jne	short setdoscntry_next

	cmp	dx,0			;no user specified code page ?
	je	short setdoscntry_any_codepage ;then no need to match code page id.
	cmp	dx,[si+4]		;compare code page id
	je	short setdoscntry_got_it

setdoscntry_next:
	add	si,[si]			;next entry
	inc	si
	inc	si			;take a word for size of entry itself
	loop	setdoscntry_find

	mov	cx,-1			;signals that bad country id entered.
setdoscntry_fail:
	stc
	retn

setdosdata_fail:
	pop	si
	pop	cx
	pop	di
	jmp	short setdoscntry_fail

setdoscntry_any_codepage:		;use the code_page_id of the country_id found.
	mov	dx,[si+4]

setdoscntry_got_it:			;found the matching entry
	mov	[cs:cntrycodepage_id],dx ;save code page id for this country.
	mov	dx,[si+10]		;get the file offset of country data
	mov	cx,[si+12]
	mov	ax,512 			;read 512 bytes
	call	readincontrolbuffer
	jc	short setdoscntry_fail

	mov	cx,[si]			;get the number of entries to handle.
	inc	si
	inc	si			;si -> first entry

setdoscntry_data:
	push	di			;es:di -> dos_country_cdpg_info
	push	cx			;save # of entry left
	push	si			;si -> current entry in control buffer

	mov	al,[si+2]		;get data entry id
	call	getcountrydestination	;get the address of destination in es:di
	jc	short setdoscntry_data_next ;no matching data entry id in dos

	mov	dx,[si+4]		;get offset of data
	mov	cx,[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer
	jc	short setdosdata_fail

	mov	dx,512			;start of data buffer
	mov	cx,20			;read 20 bytes only. we only need to
	mov	ah,3Fh			;look at the length of the data in the file.
	stc
	int	21h			;read the country.sys data
	jc	short setdosdata_fail 	;read failure

	cmp	ax,cx
	jne	short setdosdata_fail ; 13/05/2019

	mov	dx,[si+4]		;get offset of data again.
	mov	cx,[si+6]
	mov	ax,4200h
	stc
	int	21h			;move pointer back again
	jc	short setdosdata_fail

	push	si
	mov	si,(512+8)		;get length of the data from the file
	mov	cx,[si]
	pop	si
	mov	dx,512			;start of data buffer
	add	cx,10			;signature + a word for the length itself
	mov	ah,3Fh			;read the data from the file.
	stc
	int	21h
	jc	short setdosdata_fail

	cmp	ax,cx
	jne	short setdosdata_fail

	mov	al,[si+2]		;save data id for future use.
	mov	si,(512+8)		;si-> data buffer + id tag field
	mov	cx,[si]			;get the length of the file
	inc	cx			;take care of a word for lenght of tab
	inc	cx			;itself.
	cmp	cx,(2048-512-8)	; 1528	;fit into the buffer?
	ja	short setdosdata_fail

	;if	bugfix
	call	setdbcs_before_copy
	;endif

	cmp	al,SetCountryInfo ; 1	;is the data for setcountryinfo table?
	jne	short setdoscntry_mov 	;no, don't worry

	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen]  
	;push	word [es:di+24]		;cannot destroy ccmono_ptr address. save them.
	push	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2] 
	;push	word [es:di+26]		;at this time di -> cccountryinfolen
	
	push	di			;save di

	push	ax
	mov	ax,[cs:cntrycodepage_id] ;do not use the code page info in country_info
	mov	[si+4],ax		;use the saved one for this !!!!
	pop	ax

setdoscntry_mov:
	rep	movsb			;copy the table into dos
	cmp	al,SetCountryInfo	;was the ccmono_ptr saved?
	jne	short setdoscntry_data_next

	pop	di			;restore di
	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen+2]
	;pop	word [es:di+26]		;restore
	pop	word [es:di+country_cdpg_info.ccMono_Ptr-country_cdpg_info.ccCountryInfoLen] 
	;pop	word [es:di+24]

setdoscntry_data_next:
	pop	si			;restore control buffer pointer
	pop	cx			;restore # of entries left
	pop	di			;restore pointer to dso_country_cdpg
	add	si,[si]			;try to get the next entry
	inc	si
	inc	si			;take a word of entry length itself
	dec	cx
	cmp	cx,0
	je	short setdoscntry_ok
	jmp	setdoscntry_data

	; 18/12/2022
;setdoscntry_ok:
	;retn

;----------------------------------------------------------------------------

	;if	bugfix

setdbcs_before_copy:
	cmp	al,SetDBCS ; 7		; dbcs vector set?
	jne	short sdbcsbc		; jump if not
	cmp	word [es:di],0		; zero byte data block?
	je	short sdbcsbc		; jump if so

	push	di
	push	ax
	push	cx
	mov	cx,[es:di]		; load block length
	add	di,2			; points actual data
	xor	al,al			; fill bytes
	rep	stosb			; clear data block
	pop	cx
	pop	ax
	pop	di
sdbcsbc:
setdoscntry_ok:	; 18/12/2022	
	retn

	;endif

;----------------------------------------------------------------------------

getcountrydestination:

;----------------------------------------------------------------------------
;get the destination address in the dos country info table.
;
;input: al - data id
;	es:di -> dos_country_cdpg_info
;on return:
;	es:di -> destination address of the matching data id
;	carry set if no matching data id found in dos.
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4EB2h)

	push	cx
	;add	di,74
	add	di,country_cdpg_info.ccNumber_of_entries	
					;skip the reserved area, syscodepage etc.
	mov	cx,[es:di]		;get the number of entries
	inc	di
	inc	di			;si -> the first start entry id

getcntrydest:
	cmp	byte [es:di],al
	je	short getcntrydest_ok
	cmp	byte [es:di],SetCountryInfo ;was it setcountryinfo entry?
	je	short getcntrydest_1

	add	di,5			;next data id
	jmp	short getcntrydest_loop

getcntrydest_1:
	;add	di,41
	add	di,NEW_COUNTRY_SIZE+3	;next data id
getcntrydest_loop:
	loop	getcntrydest
	stc
	jmp	short getcntrydest_exit

getcntrydest_ok:
	cmp	al,SetCountryInfo ; 1	;select country info?
	jne	short getcntrydest_ok1

	inc	di			;now di -> cccountryinfolen
	jmp	short getcntrydest_exit

getcntrydest_ok1:
	les	di,[es:di+1]		;get the destination in es:di

getcntrydest_exit:
	pop	cx
	retn

;----------------------------------------------------------------------------

readincontrolbuffer:

;----------------------------------------------------------------------------
;move file pointer to cx:dx
;read ax bytes into the control buffer. (should be less than 2 kb)
;si will be set to 0 hence ds:si points to the control buffer.
;
;entry:  cx,dx offset from the start of the file where the read/write pointer
;	 be moved.
;	 ax - # of bytes to read
;	 bx - file handle
;	 ds - buffer seg.
;return: the control data information is read into ds:0 - ds:0200.
;	 cx,dx value destroyed.
;	 carry set if error in reading file.
;----------------------------------------------------------------------------

	push	ax			;# of bytes to read
	mov	ax,4200h
	stc
	int	21h			;move pointer
	pop	cx			;# of bytes to read
	jc	short ricb_exit

	xor	dx,dx			;ds:dx -> control buffer
	xor	si,si
	mov	ah,3Fh			;read into the buffer
	stc
	int	21h			;should be less than 1024 bytes.
ricb_exit:
	retn

;----------------------------------------------------------------------------

set_country_path:

;----------------------------------------------------------------------------
;in:  ds - sysinitseg, es - confbot, si -> start of the asciiz path string
;     dosinfo_ext, cntry_drv, cntry_root, cntry_path
;     assumes current directory is the root directory.
;out: ds:di -> full path (cntry_drv).
;     set the cntry_drv string from the country=,,path command.
;     ds, es, si value saved.
;----------------------------------------------------------------------------

	; 04/01/2023 - Retrodos v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:4EF4h)

	push	si

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;now ds -> confbot, es -> sysinitseg

	call	chk_drive_letter	;current ds:[si] is a drive letter?
	jc	short scp_default_drv 	;no, use current default drive.

	mov	al,[si]
	inc	si
	inc	si			;si -> next char after ":"
	jmp	short scp_setdrv

scp_default_drv:
	mov	ah,19h
	int	21h
	add	al,"A"			;convert it to a character.

scp_setdrv:
	mov	[cs:cntry_drv],al	;set the drive letter.
	mov	di,cntry_path
	mov	al,[si]
	cmp	al, "\"
	je	short scp_root_dir

	cmp	al,"/"			;let's accept "/" as an directory delim
	;je	short scp_root_dir
	;jmp	short scp_path
	; 04/01/2023
	jne	short scp_path

scp_root_dir:
	dec	di			;di -> cntry_root
scp_path:
	call	move_asciiz		;copy it

	mov	di,cntry_drv
scpath_exit:

	push	ds			;switch ds, es
	push	es
	pop	ds
	pop	es			;ds, es value restored

	pop	si
	retn

;----------------------------------------------------------------------------

chk_drive_letter:

;check if ds:[si] is a drive letter followed by ":".
;assume that every alpha character is already converted to upper case.
;carry set if not.

	; 04/01/2023 - Retrodos v4.2

	push	ax
	cmp	byte [si],"A"
	;jb	short cdletter_no
	jb	short cdletter_exit
	cmp	byte [si],"Z"
	ja	short cdletter_no
	cmp	byte [si+1],":"
	;jne	short cdletter_no
	;jmp	short cdletter_exit
	; 04/01/2023
	je	short cdletter_exit

cdletter_no:
	stc
cdletter_exit:
	pop	ax
	retn

;----------------------------------------------------------------------------

move_asciiz:

;in: ds:si -> source es:di -> target
;out: copy the string until 0.
;assumes there exists a 0.

masciiz_loop:
	movsb
	cmp	byte [si-1],0	; was it 0?
	jne	short masciiz_loop
	retn

;----------------------------------------------------------------------------

;	ds:dx points to string to output (asciz)
;
;	prints <badld_pre> <string> <badld_post>

badfil:
	push	cs
	pop	es

	mov	si,dx
badload:
	mov	dx,badld_pre	; want to print config error
	mov	bx,crlfm
prnerr:
	push	cs
	pop	ds ; *
	call	print
prn1:
	mov	dl,[es:si]
	or	dl,dl
	jz	short prn2
	mov	ah,STD_CON_OUTPUT ; 2 
	int	21h
	inc	si
	jmp	short prn1
prn2:
	mov	dx,bx
	call	print
	; 11/12/2022
	; ds = cs ; *
	cmp	byte [donotshownum],1
				; suppress line number when handling command.com
	;cmp	byte [cs:donotshownum],1 
	je	short prnexit
	
	; 18/12/2022
	;call	error_line
	jmp	error_line
;prnexit:
	;retn

;----------------------------------------------------------------------------

print:
	mov	ah,STD_CON_STRING_OUTPUT ; 9
	int	21h
prnexit:	; 18/12/2022
	retn

;----------------------------------------------------------------------------

;  open device pointed to by dx, al has access code
;   if unable to open do a device open null device instead

	; 02/11/2022 - Retrodos v4.0 (Modified MSDOS 5.0 IO.SYS)
	; (SYSINIT:3764h)
open_dev:
	call	open_file
	jnc	short open_dev3

open_dev1:
	mov	dx,nuldev
	; 18/12/2022
	;call	open_file
;of_retn:
	;retn
	; 18/12/2022
	;jmp	short open_file
open_file:
	mov	ah,OPEN	; 3Dh
	stc
	int	21h
of_retn:	; 18/12/2022
	retn

open_dev3:
	mov	bx,ax			; handle from open to bx
	;;xor	ax,ax			; get device info
	;;mov	ah,IOCTL ; 44h
	;mov	ax,(IOCTL<<8) ; 13/05/2019
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	;xor	ax,ax
	;mov	ah,44h	; IOCTL
	; 11/12/2022
	mov	ax,4400h ; IOCTL<<8 

	int	21h

	test	dl,10000000b ; 80h
	jnz	short of_retn

	mov	ah,CLOSE ; 3Eh
	int	21h
	jmp	short open_dev1

;----------------------------------------------------------------------------

; 18/12/2022
%if 0
open_file:
	mov	ah,OPEN	; 3Dh
	stc
	int	21h
	retn
%endif

;----------------------------------------------------------------------------

; test int24. return back to dos with the fake user response of "fail"

int24:
	mov	al,3			; fail the system call
	iret				; return back to dos.

; 19/04/2019 - Retro DOS v4.0

;----------------------------------------------------------------------------
; DATA
;----------------------------------------------------------------------------

;include copyrigh.inc			; copyright statement

; MSDOS 6.21 IO.SYS - SYSINIT:4FA3h

;MsDosVersion6Copyr:
;	db	'MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp '
;	db	'Licensed Material - Property of Microsoft All rights reserved '

; 22/10/2022
; MSDOS 5.0 IO.SYS - SYSINIT:378Ch

; 28/12/2022
%if 0
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
MsDosVersion5Copyr:
	db	'MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp '
	db	'Licensed Material - Property of Microsoft All rights reserved '
%endif

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
; 22/10/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; 20/04/2019 - Retro DOS v4.0
;BOOTMES:
;	db      13
;	db      10
;	db      "MS-DOS version "
;	db      MAJOR_VERSION + "0"
;	db      "."
;	db      (MINOR_VERSION / 10) + "0"
;	db      (MINOR_VERSION % 10) + "0"
;	db      13,10
;	;db	"Copyright 1981-1993 Microsoft Corp.",13,10,"$"
;	; 22/10/2022
;	db	"Copyright 1981-1991 Microsoft Corp.",13,10,"$"
;	;
;	db	0

	; 01/01/2023 - Retro DOS v4.2

	; 28/12/2022 - Retro DOS v4.1
;MsDosVersion5Copyr:
;  	db	13,10,"MS DOS Version 5.0"
;	db	13,10,"Copyright 1981-1991 Microsoft Corp.",13,10,"$",0	

	; 12/12/2022
	db	0
; 12/12/2022
BOOTMES:
	db	13,10
	;;db 	"Retro DOS v4.0 (Modified MSDOS 5.0) "
	; 28/12/2022
	;db 	"Retro DOS v4.1 (Modified MSDOS 5.0) "
	; 01/01/2023
	db 	"Retro DOS v4.2 (Modified MSDOS 6.22) "
	
	db	13,10
	db	"by Erdogan Tan [2023] "
	db	13,10
	db	13,10,"$",0

nuldev:	db	"NUL",0
condev:	db	"CON",0
auxdev:	db	"AUX",0
prndev:	db	"PRN",0

;IFDEF	CONFIGPROC
config:	db	"\CONFIG.SYS",0

cntry_drv:  db	"A:"
cntry_root: db	"\"
cntry_path: db	"COUNTRY.SYS",0
	    ;db	52 dup (0)
	    times 52 db 0	

country_file_signature:
	db	0FFh,'COUNTRY'

cntrycodepage_id: 
	dw	0 	

;ENDIF ; CONFIGPROC

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:5081h)

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;ifdef	MULTI_CONFIG
newcmd:  db	0			; non-zero if non-std shell specified
tmplate: db	64                      ; must precede commnd
;endif

;ifdef ROMEXEC
;	db      7                       ; size of commnd line (excl. null)
;commnd: db	"COMMAND",0
;	db	56 dup (0)
;else
	; 02/11/2022
	db	12                      ; size of commnd line (excl. null)
commnd:	db	"\COMMAND.COM",0
	;db	51 dup (0)
	times	51 db 0
;endif

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;ifdef	MULTI_CONFIG
commnd2: db 	"\COMMAND.COM",0	; alternate commands to exec,
	 db	2,"/P",0 		; followed by their respective alternate
commnd3: db	"\MSDOS\COMMAND.COM",0	; command lines
	 db	11,"A:\MSDOS /P",0 	;(the drive letter are dynamically replaced)
commnd4: db	"\DOS\COMMAND.COM",0 	;
	 db	9,"A:\DOS /P",0		;
def_swchr:	
	 db	0			; default switchchar (referenced as command_line-1)
;endif
	; 30/10/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
command_line:
	db	2,"/P"			; default command.com args
	;db	125 dup (0)
	times	125 db 0

pathstring:
	;db	64 dup (0)
	times	64 db 0


; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:51D3h)
; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

dae_flag:
	db	0 ; MSDOS 6.21 IO.SYS - SYSINIT:51D2h 	

;ifdef	MULTI_CONFIG

; 04/03/2022- Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS, SYSINIT)
MAX_MULTI_CONFIG equ 9	; max # of multi-config menu items supported

;   Beware of byte pairs accessed as words (see all "KEEP AFTER" notes below)

bMenuColor:	db      07h ; 1Fh       ; default fgnd/bgnd color
bMenuPage:	db      0               ; menu video page (KEEP AFTER bMenuColor)
		db      5               ; video page function # (KEEP AFTER bMenuPage)
bLastCol:	db      0               ; ending column on status line
bLastRow:	db      24              ; row # of status line (KEEP AFTER bLastCol)
bDisableUI:	db      0               ; 1=disable clean/interactive
                                        ; 2=disable default 2-second delay
bCRTPage:	db      0               ; value saved from BIOS data area
wCRTStart:	dw      0               ; value saved from BIOS data area
bQueryOpt:	db      0               ; 0=off, 1=prompt all, 2=prompt none, 4=skip all
bDefBlock:	db      1               ; default block #
bMaxBlock:	db      0               ; maxmimum block #
offDefBlock:	dw      0               ; offset of name of default block (if any)
secTimeOut:	db      -1 ; 0FFh       ; # of seconds for timeout (-1 == indefinite)
secElapsed:	db      0               ; # of seconds elapsed so far (KEEP AFTER secTimeOut)
abBlockType:	times MAX_MULTI_CONFIG+1 db 0 ; array of block types
aoffBlockName:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block names
aoffBlockDesc:	times MAX_MULTI_CONFIG+1 dw 0 ; array of offsets of block descriptions

szBoot:		db      "CONFIG=",0
szMenu:		db      "MENU",0
szCommon:	db      "COMMON",0

;endif	;MULTI_CONFIG

comtab:	 ; label byte

;            cmd len    command         cmd code
;            -------    -------         --------

;ifdef MULTI_CONFIG
        db      1,      "[",            CONFIG_BEGIN
;endif
        db      5,      "BREAK",        CONFIG_BREAK
        db      7,      "BUFFERS",      CONFIG_BUFFERS
        db      7,      "COMMENT",      CONFIG_COMMENT
        db      7,      "COUNTRY",      CONFIG_COUNTRY
        db      6,      "DEVICE",       CONFIG_DEVICE
        db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
        db      3,      "DOS",          CONFIG_DOS
        db      8,      "DRIVPARM",     CONFIG_DRIVPARM
        db      4,      "FCBS",         CONFIG_FCBS
        db      5,      "FILES",        CONFIG_FILES
;ifdef MULTI_CONFIG
        db      7,      "INCLUDE",      CONFIG_INCLUDE
;endif
        db      7,      "INSTALL",      CONFIG_INSTALL
        db      11,     "INSTALLHIGH",  CONFIG_INSTALLHIGH
        db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
;ifdef MULTI_CONFIG
        db      7,      "SUBMENU",      CONFIG_SUBMENU
        db      9,      "MENUCOLOR",    CONFIG_MENUCOLOR
        db      11,     "MENUDEFAULT",  CONFIG_MENUDEFAULT
        db      8,      "MENUITEM",     CONFIG_MENUITEM
;endif
        db      10,     "MULTITRACK",   CONFIG_MULTITRACK
;ifdef MULTI_CONFIG
        db      7,      "NUMLOCK",      CONFIG_NUMLOCK
;endif
        db      3,      "REM",          CONFIG_REM
;ifdef MULTI_CONFIG
        db      3,      "SET",          CONFIG_SET
;endif
        db      5,      "SHELL",        CONFIG_SHELL
;if    STACKSW
        db      6,      "STACKS",       CONFIG_STACKS
;endif
        db      8,      "SWITCHES",     CONFIG_SWITCHES
	db	0

;%endif ; 02/11/2022

; 01/01/2023 - Retro DOS v4.2
%if 0

comtab:
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
	; (SYSINIT:38EDh)
	db      7,      "BUFFERS",      CONFIG_BUFFERS
	db      5,      "BREAK",        CONFIG_BREAK
	db      6,      "DEVICE",       CONFIG_DEVICE
	db      10,     "DEVICEHIGH",   CONFIG_DEVICEHIGH
	db      5,      "FILES",        CONFIG_FILES
	db      4,      "FCBS",         CONFIG_FCBS
	db      9,      "LASTDRIVE",    CONFIG_LASTDRIVE
	db      10,     "MULTITRACK",   CONFIG_MULTITRACK
	db      8,      "DRIVPARM",     CONFIG_DRIVPARM
	db      6,      "STACKS",       CONFIG_STACKS
	db      7,      "COUNTRY",      CONFIG_COUNTRY
	db      5,      "SHELL",        CONFIG_SHELL
	db      7,      "INSTALL",      CONFIG_INSTALL
	db      7,      "COMMENT",      CONFIG_COMMENT
	db      3,      "REM",          CONFIG_REM
	db      8,      "SWITCHES",     CONFIG_SWITCHES
	db      3,      "DOS",          CONFIG_DOS
	db	0

%endif

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:530Ch)

deviceparameters:	
	; A_DEVICEPARAMETERS <0,dev_3inch720kb,0,80>
devp.specialfunc:	; deviceparameters +
	db	0	; A_DEVICEPARAMETERS.DP_SPECIALFUNCTIONS
devp.devtype:
	db	2	; A_DEVICEPARAMETERS.DP_DEVICETYPE
devp.devattr:
	dw	0	; A_DEVICEPARAMETERS.DP_DEVICEATTRIBUTES
devp.cylinders:
	dw	80	; A_DEVICEPARAMETERS.DP_CYLINDERS

	times	286	db 0

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:5430h)
	
hlim:	dw	2
slim:	dw	9

drive:	db	0

switches:
	dw	0

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:5437h)

; the following are the recommended bpbs for the media that
; we know of so far.

; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; MSDOS 5.0 IO.SYS - SYSINIT:3AA9h

; 48 tpi diskettes

bpb48t	dw	512
	db	2
	dw	1
	db	2
	dw	112
	dw	2*9*40 ; 720
	db	0FDh
	dw	2
	dw	9
	dw	2
	dd	0
        dd      0

; 96tpi diskettes

bpb96t:	dw	512
	db	1
	dw	1
	db	2
	dw	224
	dw	2*15*80 ; 2400
	db	0F9h
	dw	7
	dw	15
	dw	2
	dd	0
        dd      0

; 3 1/2 inch diskette bpb

bpb35:	dw	512
	db	2
	dw	1
	db	2
	dw	112
	dw	2*9*80 ; 1440
	db	0F9h
	dw	3
	dw	9
	dw	2
	dd	0
        dd      0
      
bpb35h:	dw	512
	db	1
	dw	1
	db	2
	dw	224
	dw	2*18*80 ; 2880
	db	0F0h
	dw	9
	dw	18
	dw	2
	dd	0
        dd      0

; m037 - BEGIN

bpb288:	dw	512
	db	2
	dw	1
	db	2
	dw	240
	dw	2*36*80 ; 5760
	db	0F0h
	dw	9
	dw	36
	dw	2
	dd	0
        dd      0

; m037 - END

; 12/05/2019

align 2

; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; MSDOS 5.0 IO.SYS - SYSINIT:3B26h

bpbtable:   dw	    bpb48t		; 48tpi drives
	    dw	    bpb96t		; 96tpi drives
	    dw	    bpb35		; 3.5" drives
; the following are not supported, so default to 3.5" media layout
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - 8" drives
	    dw	    bpb35		; not used - hard files
	    dw	    bpb35		; not used - tape drives
	    dw	    bpb35h		; 3-1/2" 1.44mb drive
	    dw	    bpb35		; ERIMO				m037
	    dw	    bpb288		; 2.88 MB diskette drives	m037

switchlist: 
	db	8,"FHSTDICN"	     ; preserve the positions of n and c.

;----------------------------------------------------------------------------
; Messages
;----------------------------------------------------------------------------

; 19/04/2019 - Retro DOS v4.0

; MSDOS 6.21 IO.SYS - SYSINIT:54D1h

	db 	0

; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; MSDOS 5.0 IO.SYS - SYSINIT:3B44h

badopm:
	db	0Dh,0Ah 
	db	'Unrecognized command in CONFIG.SYS'
crlfm:
	db	0Dh,0Ah,'$'
badparm:
	db	0Dh,0Ah
	db	'Bad command or parameters - $'
badsiz_pre:
	db	0Dh,0Ah
	db	'Sector size too large in file $'
badld_pre:
	db	0Dh,0Ah
	db	'Bad or missing $'
badcom:
	db	'Command Interpreter',0
badcountry:
	db	0Dh,0Ah
	db	'Invalid country code or code page',0Dh,0Ah,'$'
badcountrycom:
	db	0Dh,0Ah
	db	'Error in COUNTRY command',0Dh,0Ah,'$'
insufmemory:
	db	0Dh,0Ah
	db	'Insufficient memory for COUNTRY.SYS file',0Dh,0Ah,'$'
badmem:
	db	0Dh,0Ah
	db	'Configuration too large for memory',0Dh,0Ah,'$'
badblock:
	db	0Dh,0Ah
	db	'Too many block devices',0Dh,0Ah,'$'
badstack:
	db	0Dh,0Ah
	db	'Invalid STACK parameters',0Dh,0Ah,'$'
	; 18/12/2022
;badorder:
	;db	0Dh,0Ah
	;db	'Incorrect order in CONFIG.SYS line $'
errorcmd:
	db	'Error in CONFIG.SYS line $'

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:566Eh)

; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;%if 0

OnOff:	db	'ON'
OnOff2:	db	'OFF'

	; 04/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
	; (SYSINIT:5673h)
;StartMsg:
;	db	'Starting MS-DOS...',0Dh,0Ah
;	db	0Ah,0

_$PauseMsg:
	db	'Press any key to continue . . .',0Dh,0Ah,'$'
_$CleanMsg:
	db	'MS-DOS is bypassing your CONFIG.SYS and AUTOEXEC.BAT files.',0Dh,0Ah,'$'
_$InterMsg:
	db	'MS-DOS will prompt you to confirm each CONFIG.SYS command.',0Dh,0Ah,'$'
_$MenuHeader:
	db	0Dh,0Ah
	db	'  MS-DOS 6.2 Startup Menu',0Dh,0Ah
	db	'  =======================',0Dh,0Ah,'$'
_$MenuPrmpt:
	db	'  Enter a choice: $'
_$StatusLine:
	db	'F5=Bypass startup files F8=Confirm each line of CONFIG.SYS '
	db	'and AUTOEXEC.BAT [ ]$'
_$InterPrmpt:
	db	' [Y,N]?$'
_$YES:	db	'YES$'
_$NO:	db	'NO $'
_$TimeOut:
	db	'Time remaining: $'
badcomprmpt:
	db	'Enter correct name of Command Interpreter (eg, C:\COMMAND.COM)'
	db	0Dh,0Ah,'$'
_$AutoPrmpt:
	db	'Process AUTOEXEC.BAT [Y,N]?$'

;%endif ; 02/11/2022

; 01/01/2023 - Retro DOS v4.2 (Modified MSDOS 6.21 IO.SYS)
; (SYSINIT:5840h)

; 02/11/2022 - Retro DOS v4.0 (Modified MSDOS 5.0 IO.SYS)
; MSDOS 5.0 IO.SYS - SYSINIT:3CE0h

TooManyDrivesMsg:
	db	'WARNING! Logical drives past Z: exist and will be ignored',0Dh,0Ah,'$'

;MSDOS 6.21 IO.SYS - SYSINIT:587Ch
	;db	'Wrong DBLSPACE.BIN version',0Dh,0Ah,'$'
	;db	7 dup(0)

	;times	7 db 0
	; 02/11/2022 (MSDOS 5.0 IO.SYS SYSINIT compatibility)
;MSDOS 5.0 IO.SYS - SYSINIT:3D1Ch
	; 09/12/2022
	;times 4 db 0

;----------------------------------------------------------------------------
		; 09/12/2022
		;db 0

number3div	equ ($-SYSINIT$)
number3mod	equ (number3div % 16)

%if number3mod>0 & number3mod<16
		times (16-number3mod) db 0
%endif

;---------------------------------------------------------------------------- 
; 09/12/2022 - MSDOS 5.0 IO.SYS:3D20h ;;; SI_end = 3D20h for MSDOS 5.0 IO.SYS 
;---------------------------------------------------------------------------- 

;MSDOS 6.21 IO.SYS - SYSINIT:5899h

;----------------------------------------------------------------------------
; 20/04/2019 - Retro DOS v4.0

; 09/12/2022
;
;bss_start:
;
;ABSOLUTE bss_start
;
;alignb 16

SI_end:  ; SI_end equ $

;----------------------------------------------------------------------------

;sysinitseg	ends

; ***************************************************************************

; 04/01/2023 - MSDOS 6.21 SYSINIT:SI_end = SYSINIT:58A0h (IOSYS:9F46h)
; 09/12/2022 - MSDOS 5.0 SYSINIT:SI_end = SYSINIT:3D20h

SYSINITSIZE	equ SI_end - SYSINIT$
DOSLOADSEG	equ SYSINITSEG+((SYSINITSIZE+15)/16)

;----------------------------------------------------------------------------
; End of Retro DOS v4.2 IO.SYS source by Erdogan Tan - 04/01/2023 -
;----------------------------------------------------------------------------
