     1                                  ; ****************************************************************************
     2                                  ; RD4LOAD.S (Retro DOS v4 KERNEL LOADER) -IO.SYS- by ERDOGAN TAN - 22/12/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 24/12/2022 (Modified IO.SYS loader) 
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 22/12/2022 (Retro DOS 4.0 Kernel Loader, Fake IO.SYS)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm rd4load.s -l rd4load.txt -o IO.SYS -Z error.txt)) 
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from disassembled MSLOAD code of MSDOS 5.0 IO.SYS by Erdogan Tan 
    13                                  ; (Disassembly: 18/09/2022, NASM source: 21/10/2022, Last update: 22/12/2022) 
    14                                  ; ----------------------------------------------------------------------------
    15                                  
    16                                  ; +-------------------------------------------------------------------------+
    17                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
    18                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
    19                                  ; |			 Licensed to: Freeware version			    |
    20                                  ; +-------------------------------------------------------------------------+
    21                                  ;
    22                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
    23                                  ; Input	CRC32 :	20FC79BF
    24                                  
    25                                  ; ---------------------------------------------------------------------------
    26                                  ; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
    27                                  ; Format      :	Binary file
    28                                  ; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h
    29                                  
    30                                  ;		.386
    31                                  ;		.model flat
    32                                  
    33                                  ; ===========================================================================
    34                                  
    35                                  ; 09/12/2022
    36                                  ; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output
    37                                  
    38                                  ; ===========================================================================
    39                                  ;	NOTE: The boot loader should be verifying that the first
    40                                  ;	  block of io.sys is, in fact, at cluster 2. This would be saving
    41                                  ;	  a whole lot of time during system debugging.
    42                                  ;
    43                                  ;============================================================================
    44                                  ;
    45                                  ;     for dos 4.00, msload program has been changed to allow:
    46                                  ;	  1. 32 bit calculation,
    47                                  ;	  2. reading a fat sector when needed, instead of reading the whole
    48                                  ;	     fat sectors at once. this will make the boot time faster,
    49                                  ;	     and eliminate the memory size limitation problem,
    50                                  ;	  3. solving the limitation of the file size (29 kb) of io.sys,
    51                                  ;	  4. adding the boot error message. show the same boot error message
    52                                  ;	     and do the same behavior when the read operation of io.sys
    53                                  ;	     fails as the msboot program, since msload program is the
    54                                  ;	     extention of msboot program.
    55                                  ;
    56                                  ; ===========================================================================
    57                                  
    58                                  ;----------------------------------------------------------------------------
    59                                  		[ORG 0]			; segment 0x0070h
    60                                  ;----------------------------------------------------------------------------
    61                                  
    62                                  START$:
    63 00000000 EB2E                    		jmp	short SaveInputValues
    64                                  
    65                                  ; 24/12/2022
    66                                  ; 23/12/2022
    67                                  ; 20/12/2022
    68                                  ; 09/12/2022
    69                                  ; ---------------------------------------------------------------------------
    70 00000002 0500                    SysVersion:	dw 5			; expected_version	
    71 00000004 0000                    ClusterSize:	dw 0
    72 00000006 0000                    StartSecL:	dw 0
    73 00000008 0000                    StartSecH:	dw 0
    74 0000000A 0000                    TempH:		dw 0			; for 32 bit calculation
    75                                  ;TempCluster:	dw 0
    76                                  ;HiddenSectorsL: dw 0
    77                                  ;HiddenSectorsH: dw 0
    78                                  ;ReservSectors:	dw 0
    79 0000000C FFFF                    LastFatSector:	dw 0FFFFh		; fat sec # start from 1st FAT entry
    80 0000000E 0000                    SectorCount:	dw 0
    81 00000010 0000                    CurrentCluster:	dw 0	; *!*
    82 00000012 0000                    BytesPerSec:	dw 0
    83 00000014 0000                    SecPerCluster:	dw 0
    84                                  ;RootDirEntries: dw 0
    85 00000016 0000                    SecPerFat:	dw 0
    86 00000018 0000                    SecPerTrack:	dw 0
    87 0000001A 0000                    NumHeads:	dw 0
    88 0000001C 0000                    TotalSectorsL:	dw 0			; max. number of sectors
    89 0000001E 0000                    TotalSectorsH:	dw 0
    90 00000020 0000                    FirstSectorL:	dw 0
    91 00000022 0000                    FirstSectorH:	dw 0
    92 00000024 00                      BootDrive:	db 0
    93 00000025 00                      Fatsize:	db 0
    94 00000026 00                      MediaByte:	db 0
    95 00000027 00                      EndOfFile:	db 0
    96 00000028 00000000                OrgDasdPtr:	dd 0
    97                                  ;FatSegment:	dw 0
    98 0000002C 0000                    FatStartSecL:	dw 0
    99 0000002E 0000                    FatStartSecH:	dw 0
   100                                  
   101                                  ; ---------------------------------------------------------------------------
   102                                  
   103                                  ; SaveInputValuess
   104                                  ; ---------------------------------------------------------------------------
   105                                  ; INPUT:     none
   106                                  ;
   107                                  ;   dl = int 13 drive number we booted from
   108                                  ;   ch = media byte
   109                                  ;   bx = first data sector (low) on disk (0-based)
   110                                  ;   ds:si = original rom bios diskette parameter table.
   111                                  ;
   112                                  ; if an extended boot record, then ax will be the first data sector
   113                                  ; high word. save ax and set FirstSectorH according to ax if it is an
   114                                  ; extended boot record.
   115                                  ;
   116                                  ;   ax = first data sector (high) on disk ;
   117                                  ; OUTPUT:
   118                                  ;
   119                                  ;   bx = first data sector on disk
   120                                  ;
   121                                  ;   MediaByte = input ch
   122                                  ;   BootDrive = input dl
   123                                  ;   FirstSectorL = input bx
   124                                  ;   FirstSectorH = input AX, if an extended boot record.;j.k.
   125                                  ;   TotalSectorsL = maximum sector number in this media ;j.k.
   126                                  ;   TotalSectorsH = high word of the above
   127                                  ;   HiddenSectorsL = hidden secotrs
   128                                  ;   HiddenSectorsH
   129                                  ;   ReservSectors = reserved sectors
   130                                  ;   SecPerTrack = sectors/track
   131                                  ;   NumHeads = heads/cylinder
   132                                  ;
   133                                  ;   ds = 0
   134                                  ;   AX,DX,SI destroyed
   135                                  ;
   136                                  ; calls:     none
   137                                  ; ---------------------------------------------------------------------------
   138                                  ;FUNCTION:
   139                                  ; save input information and bpb informations from the boot record.
   140                                  ; ---------------------------------------------------------------------------
   141                                  
   142                                  Sec9 equ 522h
   143                                  ; 20/12/2022	
   144                                  DskAddr	equ 1Eh*4 ; 7Eh
   145                                  ; 22/12/2022
   146                                  ;StackPtr equ MyStacks+(NumHeads-MyStacks)
   147                                  
   148                                  ; 24/12/2022
   149                                  ; 22/12/2022
   150                                  KernelFirstClustr equ 53Ah	; The 1st cluster address of 'MSDOS.SYS' file
   151                                  				; in the root directory entry.
   152                                  
   153                                  ; ---------------------------------------------------------------------------
   154                                  
   155                                  		; 23/12/2022
   156                                  		; (registers from MSDOS 5.0 boot sector)
   157                                  		; ss = 0
   158                                  		; sp = 7C00h
   159                                  		; ds = 0
   160                                  		; es = 0
   161                                  		; ax:bx = absolute disk address for cluster 2 (data start)
   162                                  		; dl = [BootDrv] = [7C24h]
   163                                  		; ch = [MediaByte] = [7C15h]
   164                                  		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
   165                                  		; 0:500h = root dir buffer (1st sector of the root dir)
   166                                  
   167                                  SaveInputValues:
   168                                  		; 24/12/2022
   169 00000030 1E                      		push	ds
   170 00000031 0E                      		push	cs
   171 00000032 1F                      		pop	ds 
   172                                  		;mov	[cs:FirstSectorL], bx ; first data sector (low word)
   173                                  		;mov	[cs:MediaByte], ch
   174                                  		;mov	[cs:BootDrive], dl
   175                                  		;mov	[cs:OrgDasdPtr], si
   176                                  		;push	ds
   177                                  		;pop	word [cs:OrgDasdPtr+2]
   178 00000033 891E[2000]              		mov	[FirstSectorL], bx
   179 00000037 891E[0600]              		mov	[StartSecL], bx ; **!**
   180 0000003B 882E[2600]              		mov	[MediaByte], ch
   181 0000003F 8816[2400]              		mov	[BootDrive], dl
   182 00000043 8936[2800]              		mov	[OrgDasdPtr], si
   183 00000047 8F06[2A00]              		pop	word [OrgDasdPtr+2]
   184                                  	
   185 0000004B 31C9                    		xor	cx, cx		; segment 0 (obviously)
   186 0000004D 8ED9                    		mov	ds, cx		; ZERO
   187                                  		; 23/12/2022
   188                                  		; es = 0 (just before jumping to start of IO.SYS) 
   189                                  		;push	es ; !
   190                                  		;mov	es, cx
   191                                  		; es = 0
   192                                  		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
   193                                  		;mov	ds, [DskAddr+2]	; DS:SI -> current table
   194                                  		; 20/12/2022
   195 0000004F BE2205                  		mov	si, Sec9
   196 00000052 89F7                    		mov	di, si
   197 00000054 87367800                		xchg	si, [DskAddr]
   198 00000058 870E7A00                		xchg	cx, [DskAddr+2]
   199 0000005C 8ED9                    		mov	ds, cx
   200                                  		;mov	di, Sec9	; 522h  ; ES:DI -> new table
   201 0000005E B90B00                  		mov	cx, 11			; taken from ibmboot.asm
   202 00000061 FC                      		cld
   203 00000062 F3A4                    		rep movsb		; copy table
   204                                  		;push	es
   205                                  		;pop	ds		; ds = 0
   206                                  		; 20/12/2022
   207 00000064 8ED9                    		mov	ds, cx ; 0
   208                                  		;mov	word [DskAddr], Sec9 ; 522h
   209                                  		;mov	[DskAddr+2], ds	; point disk parm vector to new table
   210                                  		; 23/12/2022
   211                                  		;pop	es ; !
   212                                  		; es = 0
   213                                  		; ds = 0
   214                                  		; ss = 0
   215                                  ; 24/12/2022
   216                                  %if 0
   217                                  		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
   218                                  		mov	[cs:BytesPerSec], cx
   219                                  		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
   220                                  		mov	[cs:SecPerCluster], cl
   221                                  		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
   222                                  		mov	[cs:SecPerTrack], cx
   223                                  		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
   224                                  		mov	[cs:NumHeads], cx
   225                                  		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
   226                                  		mov	[cs:SecPerFat], cx
   227                                  		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
   228                                  		mov	[cs:ReservSectors], cx
   229                                  		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
   230                                  		mov	[cs:HiddenSectorsL], cx
   231                                  		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
   232                                  		mov	[cs:TotalSectorsL], cx
   233                                  
   234                                  		; First of all, check if it the boot record is an extended one.
   235                                  		; This is just a safe guard in case some user just "copy" the
   236                                  		; 4.00 iosys.com to a media with a conventional boot record.
   237                                  
   238                                  		; 22/12/2022
   239                                  		cmp	byte [7C26h], 29h ; ext_boot_signature
   240                                  		jne	short relocate
   241                                  		mov	[cs:FirstSectorH], ax ; first data sector (high word)
   242                                  		mov	ax, [7C1Eh]
   243                                  		mov	[cs:HiddenSectorsH], ax
   244                                  		; 10/12/2022
   245                                  		or	cx, cx
   246                                  		;cmp	cx, 0		; cx set already before (=totalsectors)
   247                                  		; 22/12/2022
   248                                  		jnz	short relocate
   249                                  		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
   250                                  		mov	[cs:TotalSectorsL], ax
   251                                  		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
   252                                  		mov	[cs:TotalSectorsH], ax
   253                                  %endif
   254                                  		; 24/12/2022
   255 00000066 50                      		push	ax  ; * ; first data sector (high word)
   256                                  		
   257 00000067 0E                      		push	cs
   258 00000068 07                      		pop	es
   259                                  
   260                                  		; get the 1st cluster of MSDOS.SYS 
   261 00000069 A13A05                  		mov	ax, [KernelFirstClustr] ; [053Ah]
   262 0000006C BF[1000]                		mov	di, CurrentCluster  
   263 0000006F AB                      		stosw	 ; *!* ; Initialize CurrentCluster to this cluster
   264                                  		; di = offset BytesPerSec 
   265                                  		
   266 00000070 BE0B7C                  		mov	si, 07C0Bh	; boot sector's bpb, BytesPerSector
   267                                  		;mov	di, BytesPerSec
   268 00000073 A5                      		movsw	; BytesPerSec
   269 00000074 A4                      		movsb	; SecPerCluster
   270 00000075 47                      		inc	di ; skip high byte of SecPerCluster word (it is 0)
   271 00000076 AD                      		lodsw	; ReservSectors
   272 00000077 89C3                    		mov	bx, ax ; save ReservSectors in bx
   273 00000079 AC                      		lodsb	; skip NumFats
   274                                  		;movsw	; RootDirEntries ; !
   275 0000007A AD                      		lodsw	; skip NUmDirEntries ; !
   276 0000007B AD                      		lodsw	; TotalSectorsL
   277 0000007C 89C1                    		mov	cx, ax ; save TotalSectorsL in cx
   278 0000007E AC                      		lodsb	; skip MediaByte
   279 0000007F A5                      		movsw	; SecPerFat
   280 00000080 A5                      		movsw 	; SecPerTrack
   281 00000081 A5                      		movsw	; NumHeads
   282 00000082 AD                      		lodsw	; HiddenSectorsL
   283 00000083 50                      		push 	ax ; **	; HiddenSectorsL
   284 00000084 AD                      		lodsw	; HiddenSectorsH
   285 00000085 89C2                    		mov	dx, ax	; save HiddenSectorsH in dx
   286 00000087 AD                      		lodsw	
   287 00000088 50                      		push	ax ; *** ; BigTotalSecs lw
   288 00000089 AD                      		lodsw
   289 0000008A 50                      		push	ax ; **** ; BigTotalSecs hw
   290 0000008B AD                      		lodsw	; skip BootDrv and CurrentHead
   291                                  
   292 0000008C 89C8                    		mov	ax, cx ; TotalSectorsL
   293                                  
   294 0000008E 89F5                    		mov	bp, si		
   295                                   
   296 00000090 59                      		pop	cx ; **** ; BigTotalSecs hw
   297                                  
   298 00000091 5E                      		pop	si ; *** ; BigTotalSecs lw
   299                                  
   300 00000092 0E                      		push	cs
   301 00000093 1F                      		pop	ds
   302                                  		
   303                                  		; ss = 0
   304                                  		; bp = 7C26h
   305                                  		
   306 00000094 807E0029                		cmp	byte [bp], 29h  ; ext_boot_signature
   307 00000098 7407                    		je	short ext_boot_sec_1
   308                                  
   309 0000009A AB                      		stosw	; TotalSectorsL
   310                                  
   311                                  		;pop	ax ; *** ; discard BigTotalSecs lw
   312 0000009B 58                      		pop	ax ; ** ; HiddenSectorsL
   313 0000009C 5A                      		pop	dx ; * ; discard 1st data sector hw
   314 0000009D 31D2                    		xor	dx, dx ; 0
   315 0000009F EB14                    		jmp	short set_fat_start
   316                                  ext_boot_sec_1:
   317                                  		; 24/12/2022
   318                                  		;pop	si ; *** ; BigTotalSecs lw
   319 000000A1 09C0                    		or	ax, ax  ; TotalSectorsL (16 bit total sectors)
   320 000000A3 7505                    		jnz	short ext_boot_sec_2 ; (*)
   321                                  
   322                                  		; (32 bit total sectors)
   323 000000A5 89F0                    		mov	ax, si ; BigTotalSecs lw 
   324 000000A7 AB                      		stosw	; TotalSectorsL	
   325 000000A8 89C8                    		mov	ax, cx ; BigTotalSecs hw
   326                                  ext_boot_sec_2:
   327 000000AA AB                      		stosw	; TotalSectorsH or TotalSectorsL (*)
   328 000000AB 58                      		pop	ax ; ** ; HiddenSectorsL
   329                                  		;pop	word [FirstSectorH] ; * ; 1st data sector hw
   330 000000AC 59                      		pop	cx ; * ; [FirstSectorH] ; 1st data sector hw
   331 000000AD 890E[2200]              		mov	[FirstSectorH], cx
   332 000000B1 890E[0800]              		mov	[StartSecH], cx ; **!**	
   333                                  
   334                                  		; here, DI points to FatStartSecL
   335                                  set_fat_start:
   336                                  		; 24/12/2022
   337                                  		; dx:ax = HiddenSectors
   338                                  		; bx = ReservSectors
   339                                  
   340 000000B5 01D8                    		add 	ax, bx
   341 000000B7 83D200                  		adc	dx, 0
   342                                  
   343                                  		;mov	[FatStartSecL], ax
   344                                  		;mov	[FatStartSecH], dx		
   345                                  
   346 000000BA BF[2C00]                		mov	di, FatStartSecL
   347 000000BD AB                      		stosw
   348 000000BE 89D0                    		mov	ax, dx
   349 000000C0 AB                      		stosw		
   350                                  		
   351                                  ; --------------------------------------------------------------------------- 
   352                                  
   353                                  relocate:
   354                                  		; 23/12/2022
   355                                  		; (set fat buffer segment at the end of loader)
   356                                  
   357                                  		FATBUFSEGM equ 70h+(((EndOfLoader-START$)+15)>>4)
   358                                  						 ; paragraph alignment
   359                                  		
   360                                  		; 24/12/2022
   361                                  		;mov	word [cs:FatSegment], FATBUFSEGM
   362                                  		FATSEGMENT equ FATBUFSEGM
   363                                  
   364                                  		; 24/12/2022
   365                                  		; ds = cs
   366                                  
   367                                  ; ---------------------------------------------------------------------------
   368                                  SetupStack:	
   369                                  		; 22/12/2022
   370                                  		;cli
   371                                  		;xor	ax, ax
   372                                  		;mov	ss, ax
   373                                  		;mov	sp, 700h
   374                                  		;sti
   375                                  
   376                                  ; ---------------------------------------------------------------------------
   377                                  ; 23/12/2022
   378                                  ; Write loading message
   379                                  		
   380                                  		; 24/12/2022	
   381                                  		;push	cs
   382                                  		;pop	ds
   383 000000C1 BE[1F03]                		mov	si, loading_msg
   384 000000C4 E8FF01                  		call	WriteTTY
   385                                  
   386                                  ; FindClusterSize
   387                                  ; ---------------------------------------------------------------------------
   388                                  ;
   389                                  ; INPUT:     bpb information in loaded boot record at 0:7c00h
   390                                  ;
   391                                  ; OUTPUT:
   392                                  ;
   393                                  ;	ds = 0
   394                                  ;	ax = bytes/cluster
   395                                  ;	bx = sectors/cluster
   396                                  ;	si destroyed
   397                                  ; calls:     none
   398                                  ;----------------------------------------------------------------------------
   399                                  ;
   400                                  ; get bytes/sector from bpb
   401                                  ;
   402                                  ; get sectors/cluster from bpb
   403                                  ;
   404                                  ; bytes/cluster = bytes/sector * sector/cluster
   405                                  ; ---------------------------------------------------------------------------
   406                                  
   407                                  FindClusterSize:
   408                                  
   409                                  ;for the time being just ASSUME the boot record is valid and the bpb is there.
   410                                  
   411                                  		; 24/12/2022
   412                                  		; ds = cs
   413                                  		;xor	ax, ax
   414                                  		;mov	ds, ax
   415                                  		;mov	ax, [7C0Bh]	; get bpb bytes/sector
   416                                  		; 24/12/2022
   417 000000C7 A1[1200]                		mov	ax, [BytesPerSec]
   418                                  		;xor	bx, bx
   419                                  		;mov	bl, [7C0Dh]	; get sectors/cluster
   420                                  		;mul	bx
   421 000000CA F726[1400]              		mul	word [SecPerCluster]
   422                                  		;mov	[cs:ClusterSize], ax
   423                                  		; 24/12/2022
   424 000000CE A3[0400]                		mov	[ClusterSize], ax
   425                                  
   426                                  ; CalcFatSize
   427                                  ; ---------------------------------------------------------------------------
   428                                  ;
   429                                  ; NOTES:
   430                                  ;
   431                                  ;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
   432                                  ;   to find out what system id byte is.
   433                                  ;
   434                                  ; INPUT:
   435                                  ;
   436                                  ; OUTPUT:
   437                                  ;
   438                                  ;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
   439                                  ;   all other registers destroyed
   440                                  ;
   441                                  ; ---------------------------------------------------------------------------
   442                                  
   443                                  CalcFatSize:
   444                                  		; 24/12/2022
   445                                  		; ds = cs
   446 000000D1 C606[2500]01            		mov	byte [Fatsize], 1
   447                                  		;mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
   448                                  		;mov	dx, [cs:TotalSectorsH]
   449                                  		;mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
   450 000000D6 8B16[1E00]              		mov	dx, [TotalSectorsH]
   451 000000DA A1[1C00]                		mov	ax, [TotalSectorsL] ; DX:AX = total disk sectors
   452                                  		;;;		
   453                                  ; 24/12/2202
   454                                  %if 0
   455                                  		sub	ax, [ReservSectors]
   456                                  		;sub	ax, [cs:ReservSectors]
   457                                  		sbb	dx, 0		; DX:AX	= Total	avail sectors
   458                                  		;mov	bx, [cs:SecPerFat]
   459                                  		mov	bx, [SecPerFat]
   460                                  		shl	bx, 1		; (Assume 2 FATs)
   461                                  		sub	ax, bx
   462                                  		sbb	dx, 0
   463                                  		;mov	bx, [7C11h]	; Root directory entry count
   464                                  		mov	bx, [RootDirEntries]
   465                                  		mov	cl, 4
   466                                  		shr	bx, cl		; BX = Total directory sectors
   467                                  		sub	ax, bx
   468                                  		sbb	dx, 0		; DX:AX	= Sectors in data area
   469                                  %endif
   470                                  		; 24/12/2022
   471 000000DD 2B06[2000]              		sub	ax, [FirstSectorL] ; total sectors - start of data
   472 000000E1 1B16[2200]              		sbb	dx, [FirstSectorH]
   473                                  				; DX:AX	= Sectors in data area
   474                                  		;;;
   475                                  		;xor	cx, cx
   476                                  		;mov	cl, [7C0Dh]	; Sectors per cluster
   477 000000E5 8B0E[1400]              		mov	cx, [SecPerCluster] ; *#*
   478 000000E9 50                      		push	ax
   479 000000EA 89D0                    		mov	ax, dx
   480 000000EC 31D2                    		xor	dx, dx
   481 000000EE F7F1                    		div	cx  ; *#*
   482                                  		; 24/12/2022
   483                                  		;;mov	[cs:TempH], ax	; AX = Total number of clusters
   484                                  		;mov	[TempH], ax
   485 000000F0 58                      		pop	ax
   486 000000F1 F7F1                    		div	cx  ; *#*
   487 000000F3 3DF60F                  		cmp	ax, 4086	; 4096-10
   488 000000F6 7205                    		jb	short ReadInFirstClusters ; 12 bit FAT
   489                                  		;mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
   490 000000F8 C606[2500]04            		mov	byte [Fatsize], 4 ; FAT_16_BIT
   491                                  
   492                                  ; 22/12/2022
   493                                  ;----------------------------------------------------------------------------
   494                                  ; HERE IS DIFFERENT THAN IO.SYS LOADER (MSLOAD)
   495                                  ; FOLLOWING CODE HAS BEEN MODIFIED FOR LOADING RETRO DOS KERNEL (MSDOS.SYS)
   496                                  ;----------------------------------------------------------------------------
   497                                  
   498                                  ; 22/12/2022
   499                                  
   500                                  KernelInitSegment equ 1000h	; Address where the kernel will be loaded
   501                                  
   502                                  ; ---------------------------------------------------------------------------
   503                                  
   504                                  		; 23/12/2022	
   505                                  		; 22/12/2022	
   506                                  ReadInFirstClusters:
   507                                  		; 24/12/2022
   508                                  		;;mov	ax, [53Ah]
   509                                  		;mov	ax, [ss:KernelFirstClustr] ; [ss:053Ah] 
   510                                  		;; 23/12/2022
   511                                  		;;mov	[cs:CurrentCluster], ax ; Initialize to this cluster
   512                                  		; 24/12/2022
   513                                  		; ds = cs
   514                                  		;mov	[CurrentCluster], ax
   515                                  
   516                                  		; 24/12/2022
   517                                  		; [currentCluster] = the 1st cluster of MSDOS.SYS ; *!*
   518 000000FD A1[1000]                		mov	ax, [CurrentCluster]
   519                                  					; MSDOS.SYS First Cluster
   520 00000100 48                      		dec	ax		; Root dir buffer at 500h (segment=0)
   521                                  					; MSDOS.SYS first cluster ptr at 53Ah
   522 00000101 48                      		dec	ax		; AX = word [53Ah] - 2
   523                                  
   524                                  ; 24/12/2022
   525                                  %if 0
   526                                  		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
   527                                  		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
   528                                  		mov	cx, [cs:FirstSectorH]
   529                                  		mov	[cs:StartSecH], cx
   530                                  		xor	cx, cx
   531                                  		mov	cl, [cs:SecPerCluster]
   532                                  		mul	cx		; DX:AX = logical start sector
   533                                  		add	[cs:StartSecL], ax
   534                                  		adc	[cs:StartSecH], dx
   535                                  					; abs start sector for next read of
   536                                  					; the rest of the last loader cluster
   537                                  %endif
   538                                  		; 24/12/2022
   539                                  		; ds = cs
   540                                  		;mov	cx, [FirstSectorL] ; Put starting sector of disk data
   541                                  		;mov	[StartSecL], cx	   ; area in StartSecH:StartSecL
   542                                  		;mov	cx, [FirstSectorH]
   543                                  		;mov	[StartSecH], cx
   544                                  		; [StartSecL] = [FirstSectorL] ; **!**
   545                                  		; [StartSecH] = [FirstSectorH] ; **!**
   546                                  
   547                                  		; ax = cluster index (cluster number - 2)
   548                                  
   549                                  		;;xor	cx, cx
   550                                  		;;mov	cl, [SecPerCluster]
   551                                  		;mov	cx, [SecPerCluster] ; ch = 0
   552                                  		; cx = [SecPerCluster]  ; *#* ; 24/12/2022
   553 00000102 F7E1                    		mul	cx		; DX:AX = logical start sector
   554                                  		; 24/12/2022
   555 00000104 0106[0600]              		add	[StartSecL], ax
   556 00000108 1116[0800]              		adc	[StartSecH], dx
   557                                  					; abs start sector for next read of
   558                                  					; the rest of the last loader cluster
   559                                  		; 22/12/2022
   560 0000010C BF0010                  		mov	di, KernelInitSegment
   561                                  		;mov	di, 1000h	; MSDOS.SYS initial (loading) segment
   562 0000010F 8EC7                    		mov	es, di
   563 00000111 31FF                    		xor	di, di		; 1000h:0000h
   564                                  		; 24/12/2022
   565                                  		; cx = [SecPerCluster]
   566                                  		;mov	ax, [SecPerCluster]
   567                                  		;;sub	ax, ax
   568                                  		;;mov	al, [SecPerCluster]
   569 00000113 89C8                    		mov	ax, cx
   570                                  					; Read in the entire last cluster
   571 00000115 A3[0E00]                		mov	[SectorCount], ax ; ah = 0
   572                                  
   573 00000118 E84800                  		call	ReadSectors
   574                                  
   575                                  		; 22/12/2022
   576                                  		;mov	[cs:NextBioLocation], di
   577                                  
   578                                  ; GetContigClusters
   579                                  ; ---------------------------------------------------------------------------
   580                                  ;
   581                                  ; NOTES: go find clusters as long as they are contiguous
   582                                  ;
   583                                  ;
   584                                  ; INPUT:
   585                                  ;   CS:NextBioLocation
   586                                  ;   CS:
   587                                  ;
   588                                  ; OUTPUT:
   589                                  ;
   590                                  ; calls: GetNextFatEntry
   591                                  ; ---------------------------------------------------------------------------
   592                                  ;
   593                                  ;Set CS:SectorCount to sectors per cluster
   594                                  ;
   595                                  ;Call GetNextFatEntry to get next cluster in file
   596                                  ;
   597                                  ;Call check_for_eof
   598                                  ;
   599                                  ;if (nc returned)
   600                                  ;
   601                                  ;   {call GetNextFatEntry
   602                                  ;
   603                                  ;    if (new cluster is contig to old cluster)
   604                                  ;	{add sectors per cluster to CS:SectorCount
   605                                  ;
   606                                  ;	 call check_for_eof
   607                                  ;
   608                                  ;	 if (nc returned)
   609                                  ;
   610                                  ; ---------------------------------------------------------------------------
   611                                  
   612                                  ; 09/12/2022
   613                                  ; END_OF_FILE equ 0FFh
   614                                  ; DosLoadSeg equ 70h
   615                                  
   616                                  		; 24/12/2022
   617                                  GetContigClusters:
   618                                  
   619                                  ; 24/12/2022
   620                                  %if 0			
   621                                  		xor	ah, ah
   622                                  		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
   623                                  		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
   624                                  		push	word [cs:SectorCount]
   625                                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   626                                  		pop	word [cs:SectorCount]
   627                                  		mov	[cs:CurrentCluster], ax ; Update the last one found
   628                                  		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
   629                                  		je	short GoToBioInit ; 23/12/2022
   630                                  		; 22/12/2022
   631                                  		;xor	dx, dx ; * (not required)
   632                                  		; 10/12/2022
   633                                  		;sub	ax, 2			; Zero base the cluster
   634                                  		dec	ax
   635                                  		dec	ax
   636                                  		xor	ch, ch
   637                                  		mov	cl, [cs:SecPerCluster]
   638                                  		mul	cx ; *			; How many sectors (before next cluster) 
   639                                  		add	ax, [cs:FirstSectorL]	; See where the data sector starts
   640                                  		adc	dx, [cs:FirstSectorH]
   641                                  		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
   642                                  		mov	[cs:StartSecH], dx
   643                                  		; 22/12/2022
   644                                  		;mov	di, [cs:NextBioLocation] ; Get where to put code
   645                                  		;push	word [cs:SectorCount]	; Save how many sectors
   646                                  		call	ReadSectors
   647                                  		;pop	ax			; Get back total sectors read in
   648                                  		;mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
   649                                  		;add	[cs:NextBioLocation], ax ; Point to where to load next	
   650                                  		jmp	short GetContigClusters
   651                                  
   652                                  %endif
   653                                  		; 24/12/2022
   654                                  		; ds = cs
   655                                  
   656 0000011B A1[1400]                		mov	ax, [SecPerCluster]	; Assume we will get one cluster
   657 0000011E A3[0E00]                		mov	[SectorCount], ax	; Sector count = sectors in 1 cluster
   658                                  		;push	word [SectorCount]
   659 00000121 50                      		push	ax
   660 00000122 E8E300                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   661 00000125 8F06[0E00]              		pop	word [SectorCount]
   662 00000129 A3[1000]                		mov	[CurrentCluster], ax	; Update the last one found
   663                                  
   664 0000012C 803E[2700]FF            		cmp	byte [EndOfFile], 0FFh	; END_OF_FILE
   665 00000131 741A                    		je	short GoToBioInit ; 23/12/2022
   666                                  		; 22/12/2022
   667                                  		;xor	dx, dx ; * (not required)
   668                                  		; 10/12/2022
   669                                  		;sub	ax, 2			; Zero base the cluster
   670 00000133 48                      		dec	ax
   671 00000134 48                      		dec	ax
   672                                  		; 24/12/2022
   673                                  		; ax = cluster index
   674                                  		;mov	cx, [SecPerCluster]
   675                                  		;mul	cx ; *			; How many sectors (before next cluster) 
   676 00000135 F726[1400]              		mul	word [SecPerCluster]
   677 00000139 0306[2000]              		add	ax, [FirstSectorL]	; See where the data sector starts
   678 0000013D 1316[2200]              		adc	dx, [FirstSectorH]
   679 00000141 A3[0600]                		mov	[StartSecL], ax		; Save it (used by ReadSectors)
   680 00000144 8916[0800]              		mov	[StartSecH], dx
   681                                  			
   682 00000148 E81800                  		call	ReadSectors
   683                                  				; ES:DI = (the next) buffer address for next read
   684                                  		
   685 0000014B EBCE                    		jmp	short GetContigClusters
   686                                  
   687                                  ; ---------------------------------------------------------------------------
   688                                  
   689                                  ; GoToBioInit
   690                                  ; ---------------------------------------------------------------------------
   691                                  ;
   692                                  ; NOTES:
   693                                  ;
   694                                  ;  Set up required registers for iosys, then jump to it (70:0)
   695                                  ;
   696                                  ; INPUT:     none
   697                                  ;
   698                                  ;   CS:MediaByte = media byte
   699                                  ;   CS:BootDrive = int 13 drive number we booted from
   700                                  ;   CS:FirstSectorL = first data sector on disk (low) (0-based)
   701                                  ;   CS:FirstSectorH = first data sector on disk (high)
   702                                  ;
   703                                  ; OUTPUT:
   704                                  ;
   705                                  ;   required by msinit
   706                                  ;   DL = int 13 drive number we booted from
   707                                  ;   CH = media byte
   708                                  ;   BX = first data sector on disk (0-based)
   709                                  ;   AX = first data sector on disk (high)
   710                                  ;   DI = sectors/fat for the boot media.
   711                                  ;
   712                                  ; calls:     none
   713                                  ; ---------------------------------------------------------------------------
   714                                  ;
   715                                  ; set up registers for msinit then do far jmp
   716                                  ;
   717                                  ; ---------------------------------------------------------------------------
   718                                  
   719                                  GoToBioInit:
   720                                  		; 22/12/2022
   721                                  		; Set registers just as Retro DOS v2/v3 boot sector sets them
   722                                  		
   723                                  		; these are not necessary
   724                                  		;xor	ax, ax
   725                                  		;mov	ds, ax
   726                                  		;mov	bp, 7C00h
   727                                  		;cli
   728                                  		;mov	ss, ax
   729                                  		;mov	sp, bp
   730                                  		;sti
   731                                  	
   732                                  		; 23/12/2022
   733                                  		;push	cs
   734                                  		;pop	ds
   735                                  		;mov	si, crlf
   736                                  		; 24/12/2022
   737                                  		; ds = cs
   738 0000014D BE[3F03]                		mov	si, ok_msg
   739 00000150 E87301                  		call	WriteTTY
   740                                  		
   741 00000153 8A36[2600]              		mov	dh, [MediaByte] ; Restore regs required for msint
   742 00000157 8A16[2400]              		mov	dl, [BootDrive] ; Physical drv number we booted from.
   743 0000015B A1[1C00]                		mov	ax, [TotalSectorsL]
   744                                  
   745                                  		; 22/12/2022
   746                                  		; (far jump to Retro DOS kernel start address)
   747 0000015E EA00000010              		jmp	1000h:0	; Far jump to MSDOS.SYS address	(KERNEL)
   748                                  
   749                                  ; =============== S U B	R O U T	I N E =======================================
   750                                  
   751                                  ; ReadSectors
   752                                  ; ---------------------------------------------------------------------------
   753                                  ; notES:
   754                                  ;
   755                                  ;  read in the CS:SectorCount number of sectors at ES:di
   756                                  ;
   757                                  ;
   758                                  ; INPUT:
   759                                  ;
   760                                  ;   DI = OFFSET of start of read
   761                                  ;   ES = segment of read
   762                                  ;   CS:SectorCount = number of sectors to read
   763                                  ;   CS:StartSecL = starting sector (low)
   764                                  ;   CS:StartSecH = starting sector (high)
   765                                  ;   following is bpb info that must be setup prior to call
   766                                  ;   CS:NumHeads
   767                                  ;   CS:number_of_sectors
   768                                  ;   CS:BootDrive
   769                                  ;   CS:SecPerTrack
   770                                  ;
   771                                  ; OUTPUT:
   772                                  ;
   773                                  ;   AX,BX,CX,DX,SI,DI destroyed
   774                                  ; ---------------------------------------------------------------------------
   775                                  ; divide start sector by sectors per track
   776                                  ; the remainder is the actual sector number, 0 based
   777                                  ;
   778                                  ; increment actual sector number to get 1 based
   779                                  ;
   780                                  ; the quotient is the number of tracks - divide by heads to get the cyl
   781                                  ;
   782                                  ; the remainder is actual head, the quotient is cylinder
   783                                  ;
   784                                  ; figure the number of sectors in that track, set al to this
   785                                  ;
   786                                  ; do the read
   787                                  ;
   788                                  ; if error, do reset, then redo the int 13h
   789                                  ;
   790                                  ; if successful read, subtract # sectors read from SectorCount, add to logical
   791                                  ; sector, add #sectors read * BytesPerSec to bx;
   792                                  ;
   793                                  ; if SectorCount <> 0 do next read
   794                                  ; ---------------------------------------------------------------------------
   795                                  
   796                                  		; 24/12/2022
   797                                  		; 22/12/2022
   798                                  ReadSectors:
   799 00000163 B90500                  		mov	cx, 5			; 5 retries
   800                                  
   801                                  		; Convert a logical sector into track/sector/head. AX has the
   802                                  		; logical sector number
   803                                  TryRead:
   804                                  		; 24/12/2022
   805                                  		; ds = cs
   806 00000166 51                      		push	cx
   807                                  		;mov	ax, [cs:StartSecL]	; Get starting sector
   808                                  		;mov	dx, [cs:StartSecH]
   809 00000167 A1[0600]                		mov	ax, [StartSecL]		; Get starting sector
   810 0000016A 8B16[0800]              		mov	dx, [StartSecH]
   811 0000016E 50                      		push	ax
   812 0000016F 89D0                    		mov	ax, dx
   813 00000171 31D2                    		xor	dx, dx
   814                                  		;;div	word [cs:SecPerTrack]
   815                                  		;div	word [SecPerTrack]	
   816                                  		; 24/12/2022
   817 00000173 8B1E[1800]              		mov	bx, [SecPerTrack]
   818 00000177 F7F3                    		div	bx
   819 00000179 A3[0A00]                		mov	[TempH], ax
   820                                  		;mov	[cs:TempH], ax
   821 0000017C 58                      		pop	ax
   822 0000017D F7F3                    		div	bx
   823                                  		;div	word [SecPerTrack]
   824                                  		;;div	word [cs:SecPerTrack]	; [TempH]:ax = track,
   825                                  						; dx = sector number
   826                                  
   827                                  		;mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
   828                                  						; read in this track
   829 0000017F 29D3                    		sub	bx, dx
   830                                  		;mov	si, bx
   831 00000181 8B36[0E00]              		mov	si, [SectorCount]
   832                                  
   833 00000185 39DE                    		cmp	si, bx
   834 00000187 7602                    		jna	short GotLength
   835                                  		;cmp	[SectorCount], si
   836                                  		;;cmp	[cs:SectorCount], si	; Is possible sectors in track more
   837                                  		;jnb	short GotLength		; than what we need to read?
   838 00000189 89DE                    		mov	si, bx
   839                                  		;mov	si, [SectorCount]
   840                                  		;;mov	si, [cs:SectorCount]	; Yes, only read what we need to
   841                                  GotLength:
   842                                  		; 23/12/2022
   843                                  		; dma boundary check for >64KB reads
   844                                  		; 24/12/2022
   845                                  		; Also, Segment Override risk !
   846 0000018B 09FF                    		or	di, di
   847 0000018D 741A                    		jz	short dma_boundary_ok ; no problem for the 1st read
   848                                  		; 24/12/2022
   849                                  		;cmp	byte [BootDrive], 80h
   850                                  		;;cmp	byte [cs:BootDrive], 80h
   851                                  		;jnb	short dma_boundary_ok ; no problem for hard disks
   852                                  dma_boundary_chk:
   853                                  		; 24/12/2022
   854 0000018F 83FE01                  		cmp	si, 1
   855 00000192 7615                    		jna	short dma_boundary_ok 
   856                                  				; 1 sector read will not cause a boundary error			
   857 00000194 52                      		push	dx
   858 00000195 50                      		push	ax
   859 00000196 89F0                    		mov	ax, si
   860 00000198 29D2                    		sub	dx, dx
   861                                  		; 24/12/2022
   862 0000019A F726[1200]              		mul	word [BytesPerSec]
   863                                  		;mul	word [cs:BytesPerSec]
   864                                  		; 23/12/2022
   865                                  		; If di > 0 -> es = 1000h (or 2000h)
   866                                  		;mov	bx, es
   867                                  		;mov	cl, 4
   868                                  		;shl	bx, cl ; convert paragraphs to bytes
   869                                  		;; bx = segment start position (for 64K memory sections)
   870                                  		;add	bx, ax ; byte count to read
   871 0000019E 89C3                    		mov	bx, ax ; byte count to read
   872 000001A0 58                      		pop	ax
   873 000001A1 5A                      		pop	dx
   874 000001A2 01FB                    		add	bx, di ; add current buffer offset to byte count
   875 000001A4 7303                    		jnc	short dma_boundary_ok
   876                                  		; Sector count must be decreased to prevent
   877                                  		; DMA boundary error or segment override risk!
   878 000001A6 4E                      		dec	si
   879 000001A7 EBE6                    		jmp	short dma_boundary_chk
   880                                  dma_boundary_ok:				
   881                                  		;inc	dl			; Sector numbers are 1-based
   882                                  		; 18/12/2022
   883 000001A9 42                      		inc	dx
   884 000001AA 88D3                    		mov	bl, dl			; Start sector in BL
   885                                  		; 24/12/2022
   886 000001AC 8B16[0A00]              		mov	dx, [TempH]		; DX:AX = Track
   887                                  		;mov	dx, [cs:TempH]		; DX:AX = Track
   888 000001B0 50                      		push	ax
   889 000001B1 89D0                    		mov	ax, dx
   890 000001B3 31D2                    		xor	dx, dx
   891                                  		; 24/12/2022
   892 000001B5 F736[1A00]              		div	word [NumHeads]
   893                                  		;div	word [cs:NumHeads]	; Start cyl in AX, head in dl
   894                                  		;mov	[TempH], ax
   895                                  		;;mov	[cs:TempH], ax
   896 000001B9 58                      		pop	ax
   897 000001BA F736[1A00]              		div	word [NumHeads]
   898                                  		;div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head
   899                                  
   900                                  			; At this moment, we assume that TempH = 0,
   901                                  			; ax <= 1024, dx <= 255
   902                                  
   903 000001BE 88D6                    		mov	dh, dl
   904                                  		
   905 000001C0 B106                    		mov	cl, 6
   906 000001C2 D2E4                    		shl	ah, cl			; Shift cyl high bits up
   907 000001C4 08DC                    		or	ah, bl			; Mix in with sector bits
   908 000001C6 88C5                    		mov	ch, al			; Setup cyl low
   909 000001C8 88E1                    		mov	cl, ah			; Setup cyl/high - sector
   910 000001CA 89FB                    		mov	bx, di			; Get back OFFSET
   911                                  		; 24/12/2022
   912 000001CC 8A16[2400]              		mov	dl, [BootDrive]		; Get drive
   913                                  		;mov	dl, [cs:BootDrive]	; Get drive
   914 000001D0 89F0                    		mov	ax, si			; Get number of sectors to read (al)
   915 000001D2 B402                    		mov	ah, 2			; Read sectors
   916                                  		; 23/12/2022
   917                                  		;push	ax
   918                                  		;push	di
   919                                  
   920                                  			; Issue one read request. ES:BX have the transfer address,
   921                                  			; AL is the number of sectors.	
   922                                  
   923 000001D4 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
   924                                  					; AL = number of sectors to read, CH = track, CL = sector
   925                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
   926                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
   927                                  		; 23/12/2022
   928                                  		;pop	di
   929                                  		;pop	ax
   930                                  
   931                                  		; 23/12/2022
   932 000001D6 B400                    		mov	ah, 0
   933                                  		
   934 000001D8 59                      		pop	cx		; Get retry count back
   935 000001D9 730A                    		jnc	short ReadOk	; 23/12/2022
   936                                  		
   937                                  		; 23/12/2022
   938                                  		;mov	bx, di		; Get offset
   939                                  		; ah = 0
   940                                  		;xor	ah, ah
   941                                  		; 23/12/2022
   942                                  		;push	cx
   943                                  		; 24/12/2022
   944                                  		;mov	dl, [BootDrive]
   945                                  		;;mov	dl, [cs:BootDrive]
   946                                  		; 23/12/2022
   947                                  		;push	di
   948 000001DB CD13                    		int	13h		; DISK - RESET DISK SYSTEM
   949                                  					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
   950                                  		; 23/12/2022
   951                                  		;pop	di
   952                                  		;pop	cx
   953 000001DD 49                      		dec	cx
   954 000001DE 7402                    		jz	short ReadError
   955 000001E0 EB84                    		jmp	TryRead
   956                                  ; ---------------------------------------------------------------------------
   957                                  
   958                                  ReadError:				
   959 000001E2 E9C700                  		jmp	ErrorOut
   960                                  ; ---------------------------------------------------------------------------
   961                                  
   962                                  ReadOk:
   963                                  		; 23/12/2022			
   964                                  		; ah = 0
   965                                  		; 22/12/2022
   966                                  		;xor	ah, ah		; Mask out read command, just get # read
   967                                  		; ch = 0
   968 000001E5 88C1                    		mov	cl, al
   969                                  
   970                                  		; 22/12/2022
   971                                  		; cx = ax = read (sector) count	
   972                                  		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
   973                                  		;mul	bx			; Get total bytes read	
   974                                  		; 24/12/2022
   975                                  		; ds = cs
   976 000001E7 F726[1200]              		mul	word [BytesPerSec]
   977                                  		;mul	word [cs:BytesPerSec]
   978 000001EB 01C7                    		add	di, ax			; Add it to OFFSET
   979 000001ED 7307                    		jnc	short read_next_sector
   980 000001EF 8CC3                    		mov	bx, es
   981                                  		;add	bx, 1000h
   982 000001F1 80C710                  		add	bh, 10h
   983 000001F4 8EC3                    		mov	es, bx
   984                                  read_next_sector:
   985                                  		; 24/12/2022
   986                                  		; ds = cs
   987                                  		; 22/12/2022
   988 000001F6 290E[0E00]              		sub	[SectorCount], cx
   989                                  		;sub	[cs:SectorCount], cx
   990                                  		;;sub	[cs:SectorCount], ax	; Bump number down
   991 000001FA 7472                    		jz	short EndRead
   992 000001FC 010E[0600]              		add	[StartSecL], cx
   993                                  		;add	[cs:StartSecL], cx
   994                                  		;;add	[cs:StartSecL], ax	; Where to start next time
   995 00000200 8316[0800]00            		adc	word [StartSecH], 0
   996                                  		;adc	word [cs:StartSecH], 0
   997 00000205 E95BFF                  		jmp	ReadSectors
   998                                  ; ---------------------------------------------------------------------------
   999                                  		
  1000                                  		; 24/12/2022
  1001                                  ;EndRead:				
  1002                                  		;retn
  1003                                  
  1004                                  ; =============== S U B	R O U T	I N E =======================================
  1005                                  
  1006                                  ; GetNextFatEntry
  1007                                  ; ---------------------------------------------------------------------------
  1008                                  ;
  1009                                  ; NOTES:
  1010                                  ;
  1011                                  ;   given the last cluster found, this will return the next cluster of
  1012                                  ;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
  1013                                  ;   of iosys has been loaded, and control is passed to goto_iosys
  1014                                  ;   msload can handle maximum fat area size of 128 kb.
  1015                                  ;
  1016                                  ; INPUT:
  1017                                  ;
  1018                                  ;    CS:CurrentCluster
  1019                                  ;    CS:FatSize
  1020                                  ;
  1021                                  ; OUTPUT:
  1022                                  ;
  1023                                  ;   CS:CurrentCluster (updated)
  1024                                  ;
  1025                                  ; calls:  GetFatSector
  1026                                  ; ---------------------------------------------------------------------------
  1027                                  ; get CurrentCluster
  1028                                  ;
  1029                                  ; if (16 bit fat)
  1030                                  ;    {if (CurrentCluster = fff8 - ffff)
  1031                                  ;	 {jmp goto_iosys}
  1032                                  ;     else
  1033                                  ;	{get OFFSET by multiply cluster by 2}
  1034                                  ;
  1035                                  ; else
  1036                                  ;    {if (CurrentCluster = ff8 - fff)
  1037                                  ;	 {jmp goto_iosys}
  1038                                  ;     else
  1039                                  ;	{get OFFSET by	- multiply cluster by 3
  1040                                  ;
  1041                                  ;	 rotate right to divide by 2
  1042                                  ;
  1043                                  ;	 if (cy set - means odd number)
  1044                                  ;	    {shr 4 times to keep high twelve bits}
  1045                                  ;
  1046                                  ;	 else
  1047                                  ;	    {and with 0fffh to keep low 12 bits}
  1048                                  ;	}
  1049                                  ;    }
  1050                                  ;
  1051                                  ; ---------------------------------------------------------------------------
  1052                                  
  1053                                  ; 09/12/2022
  1054                                  ; FAT_12_BIT equ 1
  1055                                  ; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh
  1056                                  
  1057                                  GetNextFatEntry:			
  1058 00000208 06                      		push	es
  1059                                  		; 24/12/2022
  1060 00000209 B8D000                  		mov	ax, FATSEGMENT	; FATBUFSEGM
  1061                                  		;mov	ax, [cs:FatSegment]
  1062 0000020C 8EC0                    		mov	es, ax		; ES-> FAT area segment
  1063                                  		; 09/12/2022
  1064                                  		;;mov	byte [cs:EndOfFile], END_OF_FILE
  1065                                  		;mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
  1066                                  		;mov	ax, [cs:CurrentCluster] ; Get last cluster
  1067                                  		; 24/12/2022
  1068                                  		; ds = cs
  1069 0000020E C606[2700]FF            		mov	byte [EndOfFile], 0FFh ; Assume last cluster
  1070 00000213 A1[1000]                		mov	ax, [CurrentCluster] ; Get last cluster
  1071 00000216 803E[2500]01            		cmp	byte [Fatsize], 1
  1072                                  		;;cmp	byte [cs:FatSize], FAT_12_BIT
  1073                                  		;cmp	byte [cs:Fatsize], 1
  1074 0000021B 7537                    		jne	short Got16Bit	; 23/12/2022
  1075 0000021D 89C6                    		mov	si, ax
  1076 0000021F D1E8                    		shr	ax, 1
  1077 00000221 01C6                    		add	si, ax		; SI = AX * 1.5 = AX + AX/2
  1078                                  		; 23/12/2022
  1079                                  		;push	dx
  1080                                  		;xor	dx, dx
  1081 00000223 29D2                    		sub	dx, dx ; 23/12/2022
  1082 00000225 E84700                  		call	GetFatSector
  1083                                  		; 23/12/2022
  1084                                  		;pop	dx
  1085 00000228 7510                    		jnz	short ClusterOk
  1086 0000022A 268A07                  		mov	al, [es:bx]
  1087                                  		; 22/12/2022
  1088                                  		;mov	[cs:TempCluster], al
  1089                                  		;push	ax ; (*)
  1090 0000022D 46                      		inc	si
  1091                                  		; 23/12/2022
  1092                                  		;push	dx
  1093 0000022E 31D2                    		xor	dx, dx
  1094 00000230 E83C00                  		call	GetFatSector	; Read next fat sector
  1095                                  		; 23/12/2022
  1096                                  		;pop	dx
  1097                                  		; 22/12/2022
  1098                                  		;mov	al, [es:0]
  1099                                  		;mov	[cs:TempCluster+1], al
  1100                                  		;mov	ax, [cs:TempCluster]
  1101                                  		; 22/12/2022
  1102                                  		;pop	ax ; (*) 
  1103 00000233 268A260000              		mov	ah, [es:0]
  1104 00000238 EB03                    		jmp	short EvenOdd
  1105                                  ; ---------------------------------------------------------------------------
  1106                                  
  1107                                  ClusterOk:				
  1108 0000023A 268B07                  		mov	ax, [es:bx]
  1109                                  EvenOdd:	
  1110                                  		; 24/12/2022
  1111                                  		; ds = cs
  1112 0000023D F606[1000]01            		test	byte [CurrentCluster], 1
  1113                                  		; 10/12/2022		
  1114                                  		;test	byte [cs:CurrentCluster], 1 ; 09/12/2022
  1115                                  		;;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
  1116 00000242 7505                    		jnz	short OddResult		; If not zero it was odd
  1117 00000244 25FF0F                  		and	ax, 0FFFh		; Keep low 12 bits
  1118 00000247 EB04                    		jmp	short TestEOF
  1119                                  ; ---------------------------------------------------------------------------
  1120                                  
  1121                                  OddResult:				
  1122 00000249 B104                    		mov	cl, 4			; Keep high 12 bits for odd
  1123 0000024B D3E8                    		shr	ax, cl
  1124                                  TestEOF:				
  1125 0000024D 3DF80F                  		cmp	ax, 0FF8h		; Is it last cluster?
  1126 00000250 731B                    		jnb	short GotClusterDone	; Yep, all done here
  1127 00000252 EB14                    		jmp	short NotLastCluster
  1128                                  ; ---------------------------------------------------------------------------
  1129                                  
  1130                                  Got16Bit:
  1131                                  		; 23/12/2022				
  1132                                  		;push	dx
  1133                                  		;xor	dx, dx
  1134 00000254 29D2                    		sub	dx, dx ; 23/12/2022
  1135 00000256 D1E0                    		shl	ax, 1			; Multiply cluster by 2
  1136 00000258 83D200                  		adc	dx, 0
  1137 0000025B 89C6                    		mov	si, ax			; Get the final buffer OFFSET
  1138 0000025D E80F00                  		call	GetFatSector
  1139                                  		; 23/12/2022
  1140                                  		;pop	dx
  1141 00000260 268B07                  		mov	ax, [es:bx]
  1142 00000263 83F8F8                  		cmp	ax, 0FFF8h
  1143 00000266 7305                    		jnb	short GotClusterDone
  1144                                  NotLastCluster:	
  1145                                  		; 24/12/2022
  1146                                  		; ds = cs			
  1147                                  		;;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
  1148                                  		;mov	byte [cs:EndOfFile], 0	; Assume not last cluster
  1149 00000268 C606[2700]00            		mov	byte [EndOfFile], 0	; Assume not last cluster
  1150                                  GotClusterDone:				
  1151 0000026D 07                      		pop	es
  1152                                  		; 24/12/2022
  1153                                  EndRead:
  1154 0000026E C3                      		retn
  1155                                  
  1156                                  ; =============== S U B	R O U T	I N E =======================================
  1157                                  
  1158                                  ; GetFatSector
  1159                                  ; ---------------------------------------------------------------------------
  1160                                  ;function: find and read the corresponding fat sector into ES:0
  1161                                  ;
  1162                                  ;in). SI = offset value (starting from fat entry 0) of fat entry to find.
  1163                                  ;     ES = fat sector segment
  1164                                  ;     CS:BytesPerSec
  1165                                  ;
  1166                                  ;out). corresponding fat sector read in.
  1167                                  ;      BX = offset value of the corresponding fat entry in the fat sector.
  1168                                  ;      CX destroyed.
  1169                                  ;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
  1170                                  ;      starts at the last byte of the fat sector. in this case, the caller
  1171                                  ;      should save this byte, and read the next fat sector to get the rest
  1172                                  ;      of the fat entry value. (this will only happen with the 12 bit fat).
  1173                                  ;
  1174                                  ; ---------------------------------------------------------------------------
  1175                                  
  1176                                  		; 24/12/2022
  1177                                  		; 22/12/2022
  1178                                  GetFatSector:				
  1179 0000026F 50                      		push	ax
  1180 00000270 56                      		push	si
  1181 00000271 57                      		push	di
  1182 00000272 89F0                    		mov	ax, si
  1183                                  		; 24/12/2022
  1184                                  		; ds = cs
  1185                                  		;mov	cx, [cs:BytesPerSec]
  1186                                  		;div	cx			; AX = Sector number, DX = Offset
  1187 00000274 F736[1200]              		div	word [BytesPerSec]
  1188 00000278 3B06[0C00]              		cmp	ax, [LastFatSector]
  1189                                  		;cmp	ax, [cs:LastFatSector]	; The same fat sector?
  1190 0000027C 7421                    		je	short SplitChk		; Don't need to read it again.
  1191 0000027E A3[0C00]                		mov	[LastFatSector], ax
  1192                                  		;mov	[cs:LastFatSector], ax
  1193 00000281 52                      		push	dx
  1194                                  		; 24/12/2022
  1195 00000282 31D2                    		xor	dx, dx
  1196                                  		;add	ax, [cs:HiddenSectorsL]
  1197                                  		;adc	dx, [cs:HiddenSectorsH]
  1198                                  		;add	ax, [cs:ReservSectors]
  1199                                  		;adc	dx, 0
  1200                                  		; 24/12/2022
  1201                                  		; ds = cs
  1202 00000284 0306[2C00]              		add	ax, [FatStartSecL]
  1203 00000288 1316[2E00]              		adc	dx, [FatStartSecH]
  1204 0000028C A3[0600]                		mov	[StartSecL], ax
  1205 0000028F 8916[0800]              		mov	[StartSecH], dx		; Set up for ReadSectors
  1206                                  		;mov	[cs:StartSecL], ax
  1207                                  		;mov	[cs:StartSecH], dx	; Set up for ReadSectors
  1208                                  		
  1209 00000293 C706[0E00]0100          		mov	word [SectorCount], 1 ; 1 sector			
  1210                                  		;mov	word [cs:SectorCount], 1 ; 1 sector
  1211 00000299 31FF                    		xor	di, di ; 0
  1212                                  		; es:di = FATSEGMENT:0000h
  1213 0000029B E8C5FE                  		call	ReadSectors
  1214 0000029E 5A                      		pop	dx
  1215                                  		; 24/12/2022
  1216                                  		;mov	cx, [cs:BytesPerSec]
  1217                                  SplitChk:
  1218                                  		; 24/12/2022
  1219 0000029F 8B0E[1200]              		mov	cx, [BytesPerSec]				
  1220 000002A3 49                      		dec	cx			; CX = SECTOR SIZE - 1
  1221 000002A4 39CA                    		cmp	dx, cx			; If last byte of sector, splitted entry.
  1222 000002A6 89D3                    		mov	bx, dx			; set bx to dx
  1223 000002A8 5F                      		pop	di
  1224 000002A9 5E                      		pop	si
  1225 000002AA 58                      		pop	ax
  1226                                  EndWrite:		; 10/12/2022
  1227 000002AB C3                      		retn
  1228                                  
  1229                                  ; ---------------------------------------------------------------------------
  1230                                  
  1231                                  ErrorOut:	
  1232                                  		; 24/12/2022
  1233                                  		; ds = cs		
  1234                                  		;push	cs
  1235                                  		;pop	ds
  1236 000002AC BE[D402]                		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
  1237 000002AF E81400                  		call	WriteTTY
  1238                                  
  1239                                  		; Wait for a keypress on the keyboard.
  1240                                  		; Use the bios keyboard interrupt.
  1241                                  
  1242 000002B2 30E4                    		xor	ah, ah
  1243 000002B4 CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
  1244                                  					; Return: AH = scan code, AL = character
  1245                                  
  1246                                  		; We have to restore the address of the original rom disk
  1247                                  		; parameter table to the location at [0:DskAddr]. The address
  1248                                  		; of this original table has been saved previously in
  1249                                  		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
  1250                                  		; has been restored we can reboot by invoking the bootstrap
  1251                                  		; loader bios interrupt.
  1252                                  
  1253                                  		; 23/12/2022
  1254                                  		;xor	bx, bx
  1255                                  		;mov	ds, bx
  1256                                  		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
  1257                                  					 ; (Erdogan Tan, 23/12/2022)
  1258 000002B6 C41E[2800]              		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
  1259                                  		
  1260                                  		; 23/12/2022
  1261 000002BA 16                      		push	ss ; 0
  1262 000002BB 1F                      		pop	ds
  1263                                  		; ds = 0		
  1264                                  
  1265 000002BC BE7800                  		mov	si, DskAddr	; (Int 1Eh)
  1266 000002BF 891C                    		mov	[si], bx	; restore offset		
  1267 000002C1 8C4402                  		mov	[si+2], es	; restore segment
  1268                                  
  1269 000002C4 CD19                    		int	19h		; reboot
  1270                                  
  1271                                  ; =============== S U B	R O U T	I N E =======================================
  1272                                  
  1273                                  ; WriteTTY
  1274                                  ; ---------------------------------------------------------------------------
  1275                                  ; in) DS:si -> asciiz string.
  1276                                  ;
  1277                                  ; WriteTTY the character in al to the screen.
  1278                                  ; use video service 'write teletype to active page' (ROM_TTY)
  1279                                  ; use normal character attribute
  1280                                  ; ---------------------------------------------------------------------------
  1281                                  
  1282                                  WriteTTY:				
  1283 000002C6 AC                      		lodsb
  1284 000002C7 08C0                    		or	al, al
  1285 000002C9 74E0                    		jz	short EndWrite
  1286                                  		;mov	AH, ROM_TTY	; 09/12/2022
  1287 000002CB B40E                    		mov	ah, 0Eh
  1288 000002CD B307                    		mov	bl, 7		; "normal" attribute
  1289 000002CF CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
  1290                                  					; AL = character, BH = display page (alpha modes)
  1291                                  					; BL = foreground color	(graphics modes)
  1292 000002D1 EBF3                    		jmp	short WriteTTY
  1293                                  ; ---------------------------------------------------------------------------
  1294                                  
  1295                                  ; 10/12/2022	
  1296                                  ;EndWrite:				
  1297                                  ;		retn
  1298                                  
  1299                                  ; ---------------------------------------------------------------------------
  1300                                  
  1301                                  ; 09/12/2022
  1302                                  ;include msbio.cl1
  1303                                  
  1304                                  		; 22/12/2022
  1305                                  		; 20/12/2022
  1306                                  		; 18/12/2022
  1307 000002D3 00                      		db 0	; (word alignment)
  1308                                  NonSystemDiskMsg:
  1309 000002D4 0D0A                    		db 0Dh,0Ah
  1310 000002D6 4E6F6E2D5379737465-     		db 'Non-System disk or disk error',0Dh,0Ah
  1310 000002DF 6D206469736B206F72-
  1310 000002E8 206469736B20657272-
  1310 000002F1 6F720D0A           
  1311 000002F5 5265706C6163652061-     		db 'Replace and press any key when ready',0Dh,0Ah,0
  1311 000002FE 6E6420707265737320-
  1311 00000307 616E79206B65792077-
  1311 00000310 68656E207265616479-
  1311 00000319 0D0A00             
  1312                                  ;EndOfLoader:
  1313                                  		; 22/12/2022
  1314 0000031C A101                    		dw 01A1h	; 10/12/2022
  1315                                  
  1316                                  ; ---------------------------------------------------------------------------
  1317                                  
  1318                                  ; 23/12/2022
  1319 0000031E 00                      		db 0
  1320 0000031F 0D0A                    loading_msg:	db 0Dh, 0Ah
  1321 00000321 4C6F6164696E67204B-     		db 'Loading Kernel MSDOS.SYS ... '
  1321 0000032A 65726E656C204D5344-
  1321 00000333 4F532E535953202E2E-
  1321 0000033C 2E20               
  1322                                  ; 24/12/2022
  1323 0000033E 00                      		db 0
  1324 0000033F 4F4B2E20                ok_msg:		db 'OK. '
  1325                                  crlf:
  1326 00000343 0D0A00                  		db 0Dh, 0Ah, 0
  1327                                  
  1328                                  ; ---------------------------------------------------------------------------
  1329                                  
  1330                                  ; 22/12/2022
  1331                                  ; (set file size to 1536 bytes)
  1332                                  
  1333                                  SignatureSize equ EndOfLoader - signature
  1334                                  
  1335                                  FillingSpace equ ($-START$)+SignatureSize
  1336                                  
  1337 00000346 FF<rep 274h>            times		1536-FillingSpace db 0FFh ; db 90h
  1338                                  
  1339 000005BA 00                      signature:	db 0
  1340 000005BB 0D0A                    		db 0Dh, 0Ah
  1341 000005BD 526574726F20444F53-     		db 'Retro DOS v4 Kernel Loader (Fake IO.SYS) '
  1341 000005C6 207634204B65726E65-
  1341 000005CF 6C204C6F6164657220-
  1341 000005D8 2846616B6520494F2E-
  1341 000005E1 5359532920         
  1342 000005E6 0D0A                    		db 0Dh,0Ah
  1343 000005E8 6279204572646F6761-     		db 'by Erdogan Tan [2022]'
  1343 000005F1 6E2054616E205B3230-
  1343 000005FA 32325D             
  1344 000005FD 0D0A00                  		db  0Dh, 0Ah, 0
  1345                                  EndOfLoader:
