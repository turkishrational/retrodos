     1                                  ; ****************************************************************************
     2                                  ; RD4LOAD.S (Retro DOS v4 KERNEL LOADER) -IO.SYS- by ERDOGAN TAN - 22/12/2022
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 23/12/2022 (Modified IO.SYS loader) 
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 22/12/2022 (Retro DOS 4.0 Kernel Loader, Fake IO.SYS)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	   ((nasm rd4load.s -l rd4load.txt -o IO.SYS -Z error.txt)) 
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from disassembled MSLOAD code of MSDOS 5.0 IO.SYS by Erdogan Tan 
    13                                  ; (Disassembly: 18/09/2022, NASM source: 21/10/2022, Last update: 22/12/2022) 
    14                                  ; ----------------------------------------------------------------------------
    15                                  
    16                                  ; +-------------------------------------------------------------------------+
    17                                  ; |   This file	has been generated by The Interactive Disassembler (IDA)    |
    18                                  ; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
    19                                  ; |			 Licensed to: Freeware version			    |
    20                                  ; +-------------------------------------------------------------------------+
    21                                  ;
    22                                  ; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
    23                                  ; Input	CRC32 :	20FC79BF
    24                                  
    25                                  ; ---------------------------------------------------------------------------
    26                                  ; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
    27                                  ; Format      :	Binary file
    28                                  ; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h
    29                                  
    30                                  ;		.386
    31                                  ;		.model flat
    32                                  
    33                                  ; ===========================================================================
    34                                  
    35                                  ; 09/12/2022
    36                                  ; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output
    37                                  
    38                                  ; ===========================================================================
    39                                  ;	NOTE: The boot loader should be verifying that the first
    40                                  ;	  block of io.sys is, in fact, at cluster 2. This would be saving
    41                                  ;	  a whole lot of time during system debugging.
    42                                  ;
    43                                  ;============================================================================
    44                                  ;
    45                                  ;     for dos 4.00, msload program has been changed to allow:
    46                                  ;	  1. 32 bit calculation,
    47                                  ;	  2. reading a fat sector when needed, instead of reading the whole
    48                                  ;	     fat sectors at once. this will make the boot time faster,
    49                                  ;	     and eliminate the memory size limitation problem,
    50                                  ;	  3. solving the limitation of the file size (29 kb) of io.sys,
    51                                  ;	  4. adding the boot error message. show the same boot error message
    52                                  ;	     and do the same behavior when the read operation of io.sys
    53                                  ;	     fails as the msboot program, since msload program is the
    54                                  ;	     extention of msboot program.
    55                                  ;
    56                                  ; ===========================================================================
    57                                  
    58                                  ;
    59                                  ;----------------------------------------------------------------------------
    60                                  ;
    61                                  ; M056 : Added RPL support, so that RPL's fake INT 13 code can be safe from
    62                                  ;		SYSINIT & transient portion of COMMAND.COM
    63                                  ;
    64                                  ;----------------------------------------------------------------------------
    65                                  		
    66                                  		[ORG 0]			; segment 0x0070h
    67                                  
    68                                  START$:
    69 00000000 EB31                    		jmp	short SaveInputValues
    70                                  ; 20/12/2022
    71                                  ; 09/12/2022
    72                                  ; ---------------------------------------------------------------------------
    73 00000002 0500                    SysVersion:	dw 5			; expected_version	
    74                                  ;MyStacks:	db 256 dup(0)		; local stack
    75                                  ; 22/12/2022
    76                                  ; 20/12/2022
    77                                  ;MyStacks:	dw 102 dup(0)		; local stack
    78 00000004 0000                    NumHeads:	dw 0			
    79 00000006 0000                    ClusterSize:	db 2 dup(0)	
    80 00000008 0000                    StartSecL:	dw 0			
    81 0000000A 0000                    StartSecH:	dw 0			
    82 0000000C 0000                    TempH:		dw 0			; for 32 bit calculation
    83                                  ; 23/12/2022
    84                                  ;TempCluster:	db 2 dup(0)		; temporary place for cluster number
    85 0000000E FFFF                    LastFatSector:	db 2 dup(0FFh)		; fat sec # start from 1st FAT entry
    86 00000010 0000                    SectorCount:	dw 0			
    87 00000012 0000                    SecPerFat:	dw 0			
    88 00000014 0000                    HiddenSectorsL:	dw 0			
    89 00000016 0000                    HiddenSectorsH:	dw 0			
    90 00000018 0000                    BytesPerSec:	dw 0			
    91 0000001A 0000                    ReservSectors:	db 2 dup(0)		
    92 0000001C 0000                    CurrentCluster:	db 2 dup(0)		
    93                                  ; 23/12/2022
    94                                  ;NextBioLocation: db 2 dup(0)		
    95 0000001E 0000                    FirstSectorL:	dw 0			
    96 00000020 0000                    FirstSectorH:	dw 0			
    97 00000022 0000                    TotalSectorsL:	dw 0			; max. number of sectors
    98 00000024 0000                    TotalSectorsH:	dw 0			
    99 00000026 0000                    SecPerTrack:	db 2 dup(0)		
   100 00000028 00                      BootDrive:	db 0			
   101 00000029 00                      Fatsize:	db 0			
   102 0000002A 00                      MediaByte:	db 0			
   103 0000002B 00                      EndOfFile:	db 0			
   104 0000002C 00000000                OrgDasdPtr:	db 4 dup(0)		
   105 00000030 0000                    FatSegment:	db 2 dup(0)		
   106 00000032 00                      SecPerCluster:	db 0			
   107                                  ; ---------------------------------------------------------------------------
   108                                  
   109                                  ; SaveInputValuess
   110                                  ; ---------------------------------------------------------------------------
   111                                  ; INPUT:     none
   112                                  ;
   113                                  ;   dl = int 13 drive number we booted from
   114                                  ;   ch = media byte
   115                                  ;   bx = first data sector (low) on disk (0-based)
   116                                  ;   ds:si = original rom bios diskette parameter table.
   117                                  ;
   118                                  ; if an extended boot record, then ax will be the first data sector
   119                                  ; high word. save ax and set FirstSectorH according to ax if it is an
   120                                  ; extended boot record.
   121                                  ;
   122                                  ;   ax = first data sector (high) on disk ;
   123                                  ; OUTPUT:
   124                                  ;
   125                                  ;   bx = first data sector on disk
   126                                  ;
   127                                  ;   MediaByte = input ch
   128                                  ;   BootDrive = input dl
   129                                  ;   FirstSectorL = input bx
   130                                  ;   FirstSectorH = input AX, if an extended boot record.;j.k.
   131                                  ;   TotalSectorsL = maximum sector number in this media ;j.k.
   132                                  ;   TotalSectorsH = high word of the above
   133                                  ;   HiddenSectorsL = hidden secotrs
   134                                  ;   HiddenSectorsH
   135                                  ;   ReservSectors = reserved sectors
   136                                  ;   SecPerTrack = sectors/track
   137                                  ;   NumHeads = heads/cylinder
   138                                  ;
   139                                  ;   ds = 0
   140                                  ;   AX,DX,SI destroyed
   141                                  ;
   142                                  ; calls:     none
   143                                  ; ---------------------------------------------------------------------------
   144                                  ;FUNCTION:
   145                                  ; save input information and bpb informations from the boot record.
   146                                  ; ---------------------------------------------------------------------------
   147                                  
   148                                  Sec9 equ 522h
   149                                  ; 20/12/2022	
   150                                  DskAddr	equ 1Eh*4 ; 7Eh
   151                                  ; 22/12/2022
   152                                  ;StackPtr equ MyStacks+(NumHeads-MyStacks)
   153                                  
   154                                  ; ---------------------------------------------------------------------------
   155                                  
   156                                  		; 23/12/2022
   157                                  		; (registers from MSDOS 5.0 boot sector)
   158                                  		; ss = 0
   159                                  		; sp = 7C00h
   160                                  		; ds = 0
   161                                  		; es = 0
   162                                  		; ax:bx = absolute disk address for cluster 2 (data start)
   163                                  		; dl = [BootDrv] = [7C24h]
   164                                  		; ch = [MediaByte] = [7C15h]
   165                                  		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
   166                                  		; 0:500h = root dir buffer (1st sector of the root dir)
   167                                  
   168                                  SaveInputValues:
   169 00000033 2E891E[1E00]            		mov	[cs:FirstSectorL], bx ; physical disk address (lw)
   170                                  					; includes hidden secs and reservd secs	
   171 00000038 2E882E[2A00]            		mov	[cs:MediaByte], ch
   172 0000003D 2E8816[2800]            		mov	[cs:BootDrive], dl
   173 00000042 2E8936[2C00]            		mov	[cs:OrgDasdPtr], si
   174 00000047 1E                      		push	ds
   175 00000048 2E8F06[2E00]            		pop	word [cs:OrgDasdPtr+2]
   176 0000004D 31C9                    		xor	cx, cx		; segment 0 (obviously)
   177 0000004F 8ED9                    		mov	ds, cx		; ZERO
   178                                  		; 13/12/2022
   179                                  		; es = 0 (just before jumping to start of IO.SYS) 
   180                                  		;push	es ; !
   181                                  		;mov	es, cx
   182                                  		; es = 0
   183                                  		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
   184                                  		;mov	ds, [DskAddr+2]	; DS:SI -> current table
   185                                  		; 20/12/2022
   186 00000051 BE2205                  		mov	si, Sec9
   187 00000054 89F7                    		mov	di, si
   188 00000056 87367800                		xchg	si, [DskAddr]
   189 0000005A 870E7A00                		xchg	cx, [DskAddr+2]
   190 0000005E 8ED9                    		mov	ds, cx
   191                                  		;mov	di, Sec9	; 522h  ; ES:DI -> new table
   192 00000060 B90B00                  		mov	cx, 11			; taken from ibmboot.asm
   193 00000063 FC                      		cld
   194 00000064 F3A4                    		rep movsb		; copy table
   195                                  		;push	es
   196                                  		;pop	ds		; ds = 0
   197                                  		; 20/12/2022
   198 00000066 8ED9                    		mov	ds, cx ; 0
   199                                  		;mov	word [DskAddr], Sec9 ; 522h
   200                                  		;mov	[DskAddr+2], ds	; point disk parm vector to new table
   201                                  		; 23/12/2022
   202                                  		;pop	es ; !
   203                                  		; es = 0
   204                                  		; ds = 0
   205                                  		; ss = 0
   206 00000068 8B0E0B7C                		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
   207 0000006C 2E890E[1800]            		mov	[cs:BytesPerSec], cx
   208 00000071 8A0E0D7C                		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
   209 00000075 2E880E[3200]            		mov	[cs:SecPerCluster], cl
   210 0000007A 8B0E187C                		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
   211 0000007E 2E890E[2600]            		mov	[cs:SecPerTrack], cx
   212 00000083 8B0E1A7C                		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
   213 00000087 2E890E[0400]            		mov	[cs:NumHeads], cx
   214 0000008C 8B0E167C                		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
   215 00000090 2E890E[1200]            		mov	[cs:SecPerFat], cx
   216 00000095 8B0E0E7C                		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
   217 00000099 2E890E[1A00]            		mov	[cs:ReservSectors], cx
   218 0000009E 8B0E1C7C                		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
   219 000000A2 2E890E[1400]            		mov	[cs:HiddenSectorsL], cx
   220 000000A7 8B0E137C                		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
   221 000000AB 2E890E[2200]            		mov	[cs:TotalSectorsL], cx
   222                                  
   223                                  		; First of all, check if it the boot record is an extended one.
   224                                  		; This is just a safe guard in case some user just "copy" the
   225                                  		; 4.00 iosys.com to a media with a conventional boot record.
   226                                  
   227                                  		; 22/12/2022
   228 000000B0 803E267C29              		cmp	byte [7C26h], 29h ; ext_boot_signature
   229 000000B5 751D                    		jne	short relocate
   230 000000B7 2EA3[2000]              		mov	[cs:FirstSectorH], ax ; ax = first data sector (high) on disk
   231                                  					; physical disk address (hw)
   232                                  					; includes hidden secs and reservd secs	
   233 000000BB A11E7C                  		mov	ax, [7C1Eh]
   234 000000BE 2EA3[1600]              		mov	[cs:HiddenSectorsH], ax
   235                                  		; 10/12/2022
   236 000000C2 09C9                    		or	cx, cx
   237                                  		;cmp	cx, 0		; cx set already before (=totalsectors)
   238                                  		; 22/12/2022
   239 000000C4 750E                    		jnz	short relocate
   240 000000C6 A1207C                  		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
   241 000000C9 2EA3[2200]              		mov	[cs:TotalSectorsL], ax
   242 000000CD A1227C                  		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
   243 000000D0 2EA3[2400]              		mov	[cs:TotalSectorsH], ax
   244                                  
   245                                  ; ---------------------------------------------------------------------------
   246                                  		
   247                                  relocate:
   248                                  		; 23/12/2022
   249                                  		; (set fat buffer segment at the end of loader)
   250                                  
   251                                  		FATBUFSEGM equ 70h+(((EndOfLoader-START$)+15)>>4)
   252                                  						 ; paragraph alignment
   253                                  		
   254 000000D4 2EC706[3000]D000        		mov	word [cs:FatSegment], FATBUFSEGM
   255                                  
   256                                  ; ---------------------------------------------------------------------------
   257                                  SetupStack:	
   258                                  		; 22/12/2022
   259                                  		;cli
   260                                  		;xor	ax, ax
   261                                  		;mov	ss, ax
   262                                  		;mov	sp, 700h
   263                                  		;sti
   264                                  
   265                                  ; ---------------------------------------------------------------------------
   266                                  ; 23/12/2022
   267                                  ; Write loading message
   268                                  			
   269 000000DB 0E                      		push	cs
   270 000000DC 1F                      		pop	ds
   271 000000DD BE[E803]                		mov	si, loading_msg
   272 000000E0 E8AC02                  		call	WriteTTY
   273                                  
   274                                  ; FindClusterSize
   275                                  ; ---------------------------------------------------------------------------
   276                                  ;
   277                                  ; INPUT:     bpb information in loaded boot record at 0:7c00h
   278                                  ;
   279                                  ; OUTPUT:
   280                                  ;
   281                                  ;	ds = 0
   282                                  ;	ax = bytes/cluster
   283                                  ;	bx = sectors/cluster
   284                                  ;	si destroyed
   285                                  ; calls:     none
   286                                  ;----------------------------------------------------------------------------
   287                                  ;
   288                                  ; get bytes/sector from bpb
   289                                  ;
   290                                  ; get sectors/cluster from bpb
   291                                  ;
   292                                  ; bytes/cluster = bytes/sector * sector/cluster
   293                                  ; ---------------------------------------------------------------------------
   294                                  
   295                                  FindClusterSize:
   296                                  
   297                                  ;for the time being just ASSUME the boot record is valid and the bpb is there.
   298                                  
   299 000000E3 31C0                    		xor	ax, ax
   300 000000E5 8ED8                    		mov	ds, ax
   301 000000E7 A10B7C                  		mov	ax, [7C0Bh]	; get bpb bytes/sector
   302 000000EA 31DB                    		xor	bx, bx
   303 000000EC 8A1E0D7C                		mov	bl, [7C0Dh]	; get sectors/cluster
   304 000000F0 F7E3                    		mul	bx
   305 000000F2 2EA3[0600]              		mov	[cs:ClusterSize], ax
   306                                  
   307                                  ; CalcFatSize
   308                                  ; ---------------------------------------------------------------------------
   309                                  ;
   310                                  ; NOTES:
   311                                  ;
   312                                  ;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
   313                                  ;   to find out what system id byte is.
   314                                  ;
   315                                  ; INPUT:
   316                                  ;
   317                                  ; OUTPUT:
   318                                  ;
   319                                  ;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
   320                                  ;   all other registers destroyed
   321                                  ;
   322                                  ; ---------------------------------------------------------------------------
   323                                  
   324                                  CalcFatSize:
   325 000000F6 2EC606[2900]01          		mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
   326 000000FC 2E8B16[2400]            		mov	dx, [cs:TotalSectorsH]
   327 00000101 2EA1[2200]              		mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
   328 00000105 2E2B06[1A00]            		sub	ax, [cs:ReservSectors]
   329 0000010A 83DA00                  		sbb	dx, 0		; DX:AX	= Total	avail sectors
   330 0000010D 2E8B1E[1200]            		mov	bx, [cs:SecPerFat]
   331 00000112 D1E3                    		shl	bx, 1		; (Assume 2 FATs)
   332 00000114 29D8                    		sub	ax, bx
   333 00000116 83DA00                  		sbb	dx, 0
   334 00000119 8B1E117C                		mov	bx, [7C11h]	; Root directory entry count
   335 0000011D B104                    		mov	cl, 4
   336 0000011F D3EB                    		shr	bx, cl		; BX = Total directory sectors
   337 00000121 29D8                    		sub	ax, bx
   338 00000123 83DA00                  		sbb	dx, 0		; DX:AX	= Sectors in data area
   339 00000126 31C9                    		xor	cx, cx
   340 00000128 8A0E0D7C                		mov	cl, [7C0Dh]	; Sectors per cluster
   341 0000012C 50                      		push	ax
   342 0000012D 89D0                    		mov	ax, dx
   343 0000012F 31D2                    		xor	dx, dx
   344 00000131 F7F1                    		div	cx
   345 00000133 2EA3[0C00]              		mov	[cs:TempH], ax	; AX = Total number of clusters
   346 00000137 58                      		pop	ax
   347 00000138 F7F1                    		div	cx
   348 0000013A 3DF60F                  		cmp	ax, 4086	; 4096-10
   349 0000013D 7206                    		jb	short ReadInFirstClusters ; 12 bit FAT
   350 0000013F 2EC606[2900]04          		mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
   351                                  
   352                                  ; 22/12/2022
   353                                  ;----------------------------------------------------------------------------
   354                                  ; HERE IS DIFFERENT THAN IO.SYS LOADER (MSLOAD)
   355                                  ; FOLLOWING CODE HAS BEEN MODIFIED FOR LOADING RETRO DOS KERNEL (MSDOS.SYS)
   356                                  ;----------------------------------------------------------------------------
   357                                  
   358                                  ; 22/12/2022
   359                                  KernelFirstClustr equ 53Ah	; The 1st cluster address of 'MSDOS.SYS' file
   360                                  				; in the root directory entry.
   361                                  
   362                                  KernelInitSegment equ 1000h	; Address where the kernel will be loaded
   363                                  
   364                                  ; ---------------------------------------------------------------------------
   365                                  
   366                                  		; 23/12/2022	
   367                                  		; 22/12/2022	
   368                                  ReadInFirstClusters:
   369                                  		;mov	ax, [53Ah]
   370 00000145 A13A05                  		mov	ax, [KernelFirstClustr]
   371                                  		; 23/12/2022
   372 00000148 2EA3[1C00]              		mov	[cs:CurrentCluster], ax ; Initialize to this cluster
   373                                  
   374                                  					; MSDOS.SYS First Cluster
   375 0000014C 48                      		dec	ax		; Root dir buffer at 500h (segment=0)
   376                                  					; MSDOS.SYS first cluster ptr at 53Ah
   377 0000014D 48                      		dec	ax		; AX = word [53Ah] - 2
   378                                  
   379 0000014E 2E8B0E[1E00]            		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
   380 00000153 2E890E[0800]            		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
   381 00000158 2E8B0E[2000]            		mov	cx, [cs:FirstSectorH]
   382 0000015D 2E890E[0A00]            		mov	[cs:StartSecH], cx
   383 00000162 31C9                    		xor	cx, cx
   384 00000164 2E8A0E[3200]            		mov	cl, [cs:SecPerCluster]
   385 00000169 F7E1                    		mul	cx		; DX:AX = logical start sector
   386 0000016B 2E0106[0800]            		add	[cs:StartSecL], ax
   387 00000170 2E1116[0A00]            		adc	[cs:StartSecH], dx
   388                                  					; abs start sector for next read of
   389                                  					; the rest of the last loader cluster
   390                                  		; 22/12/2022
   391 00000175 BF0010                  		mov	di, KernelInitSegment
   392                                  		;mov	di, 1000h	; MSDOS.SYS initial (loading) segment
   393 00000178 8EC7                    		mov	es, di
   394 0000017A 31FF                    		xor	di, di		; 1000h:0000h
   395 0000017C 29C0                    		sub	ax, ax
   396 0000017E 2EA0[3200]              		mov	al, [cs:SecPerCluster]
   397                                  					; Read in the entire last cluster
   398 00000182 2EA3[1000]              		mov	[cs:SectorCount], ax
   399                                  
   400 00000186 E85E00                  		call	ReadSectors
   401                                  
   402                                  		; 22/12/2022
   403                                  		;mov	[cs:NextBioLocation], di
   404                                  
   405                                  ; GetContigClusters
   406                                  ; ---------------------------------------------------------------------------
   407                                  ;
   408                                  ; NOTES: go find clusters as long as they are contiguous
   409                                  ;
   410                                  ;
   411                                  ; INPUT:
   412                                  ;   CS:NextBioLocation
   413                                  ;   CS:
   414                                  ;
   415                                  ; OUTPUT:
   416                                  ;
   417                                  ; calls: GetNextFatEntry
   418                                  ; ---------------------------------------------------------------------------
   419                                  ;
   420                                  ;Set CS:SectorCount to sectors per cluster
   421                                  ;
   422                                  ;Call GetNextFatEntry to get next cluster in file
   423                                  ;
   424                                  ;Call check_for_eof
   425                                  ;
   426                                  ;if (nc returned)
   427                                  ;
   428                                  ;   {call GetNextFatEntry
   429                                  ;
   430                                  ;    if (new cluster is contig to old cluster)
   431                                  ;	{add sectors per cluster to CS:SectorCount
   432                                  ;
   433                                  ;	 call check_for_eof
   434                                  ;
   435                                  ;	 if (nc returned)
   436                                  ;
   437                                  ; ---------------------------------------------------------------------------
   438                                  
   439                                  ; 09/12/2022
   440                                  ; END_OF_FILE equ 0FFh
   441                                  ; DosLoadSeg equ 70h
   442                                  
   443                                  GetContigClusters:			
   444 00000189 30E4                    		xor	ah, ah
   445 0000018B 2EA0[3200]              		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
   446 0000018F 2EA3[1000]              		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
   447 00000193 2EFF36[1000]            		push	word [cs:SectorCount]
   448 00000198 E81B01                  		call	GetNextFatEntry		; Returns next cluster to read in AX	
   449 0000019B 2E8F06[1000]            		pop	word [cs:SectorCount]
   450 000001A0 2EA3[1C00]              		mov	[cs:CurrentCluster], ax ; Update the last one found
   451 000001A4 2E803E[2B00]FF          		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
   452 000001AA 7423                    		je	short GoToBioInit ; 23/12/2022
   453                                  		; 22/12/2022
   454                                  		;xor	dx, dx ; * (not required)
   455                                  		; 10/12/2022
   456                                  		;sub	ax, 2			; Zero base the cluster
   457 000001AC 48                      		dec	ax
   458 000001AD 48                      		dec	ax
   459 000001AE 30ED                    		xor	ch, ch
   460 000001B0 2E8A0E[3200]            		mov	cl, [cs:SecPerCluster]
   461 000001B5 F7E1                    		mul	cx ; *			; How many sectors (before next cluster) 
   462 000001B7 2E0306[1E00]            		add	ax, [cs:FirstSectorL]	; See where the data sector starts
   463 000001BC 2E1316[2000]            		adc	dx, [cs:FirstSectorH]
   464 000001C1 2EA3[0800]              		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
   465 000001C5 2E8916[0A00]            		mov	[cs:StartSecH], dx
   466                                  		; 22/12/2022
   467                                  		;mov	di, [cs:NextBioLocation] ; Get where to put code
   468                                  		;push	word [cs:SectorCount]	; Save how many sectors
   469 000001CA E81A00                  		call	ReadSectors
   470                                  		;pop	ax			; Get back total sectors read in
   471                                  		;mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
   472                                  		;add	[cs:NextBioLocation], ax ; Point to where to load next	
   473 000001CD EBBA                    		jmp	short GetContigClusters
   474                                  ; ---------------------------------------------------------------------------
   475                                  
   476                                  ; GoToBioInit
   477                                  ; ---------------------------------------------------------------------------
   478                                  ;
   479                                  ; NOTES:
   480                                  ;
   481                                  ;  Set up required registers for iosys, then jump to it (70:0)
   482                                  ;
   483                                  ; INPUT:     none
   484                                  ;
   485                                  ;   CS:MediaByte = media byte
   486                                  ;   CS:BootDrive = int 13 drive number we booted from
   487                                  ;   CS:FirstSectorL = first data sector on disk (low) (0-based)
   488                                  ;   CS:FirstSectorH = first data sector on disk (high)
   489                                  ;
   490                                  ; OUTPUT:
   491                                  ;
   492                                  ;   required by msinit
   493                                  ;   DL = int 13 drive number we booted from
   494                                  ;   CH = media byte
   495                                  ;   BX = first data sector on disk (0-based)
   496                                  ;   AX = first data sector on disk (high)
   497                                  ;   DI = sectors/fat for the boot media.
   498                                  ;
   499                                  ; calls:     none
   500                                  ; ---------------------------------------------------------------------------
   501                                  ;
   502                                  ; set up registers for msinit then do far jmp
   503                                  ;
   504                                  ; ---------------------------------------------------------------------------
   505                                  
   506                                  GoToBioInit:
   507                                  		; 22/12/2022
   508                                  		; Set registers just as Retro DOS v2/v3 boot sector sets them
   509                                  		
   510                                  		; these are not necessary
   511                                  		;xor	ax, ax
   512                                  		;mov	ds, ax
   513                                  		;mov	bp, 7C00h
   514                                  		;cli
   515                                  		;mov	ss, ax
   516                                  		;mov	sp, bp
   517                                  		;sti
   518                                  	
   519                                  		; 23/12/2022
   520 000001CF 0E                      		push	cs
   521 000001D0 1F                      		pop	ds
   522 000001D1 BE[0704]                		mov	si, crlf
   523 000001D4 E8B801                  		call	WriteTTY
   524                                  		
   525 000001D7 8A36[2A00]              		mov	dh, [MediaByte] ; Restore regs required for msint
   526 000001DB 8A16[2800]              		mov	dl, [BootDrive] ; Physical drv number we booted from.
   527 000001DF A1[2200]                		mov	ax, [TotalSectorsL]
   528                                  
   529                                  		; 22/12/2022
   530                                  		; (far jump to Retro DOS kernel start address)
   531 000001E2 EA00000010              		jmp	1000h:0	; Far jump to MSDOS.SYS address	(KERNEL)
   532                                  
   533                                  ; =============== S U B	R O U T	I N E =======================================
   534                                  
   535                                  ; ReadSectors
   536                                  ; ---------------------------------------------------------------------------
   537                                  ; notES:
   538                                  ;
   539                                  ;  read in the CS:SectorCount number of sectors at ES:di
   540                                  ;
   541                                  ;
   542                                  ; INPUT:
   543                                  ;
   544                                  ;   DI = OFFSET of start of read
   545                                  ;   ES = segment of read
   546                                  ;   CS:SectorCount = number of sectors to read
   547                                  ;   CS:StartSecL = starting sector (low)
   548                                  ;   CS:StartSecH = starting sector (high)
   549                                  ;   following is bpb info that must be setup prior to call
   550                                  ;   CS:NumHeads
   551                                  ;   CS:number_of_sectors
   552                                  ;   CS:BootDrive
   553                                  ;   CS:SecPerTrack
   554                                  ;
   555                                  ; OUTPUT:
   556                                  ;
   557                                  ;   AX,BX,CX,DX,SI,DI destroyed
   558                                  ; ---------------------------------------------------------------------------
   559                                  ; divide start sector by sectors per track
   560                                  ; the remainder is the actual sector number, 0 based
   561                                  ;
   562                                  ; increment actual sector number to get 1 based
   563                                  ;
   564                                  ; the quotient is the number of tracks - divide by heads to get the cyl
   565                                  ;
   566                                  ; the remainder is actual head, the quotient is cylinder
   567                                  ;
   568                                  ; figure the number of sectors in that track, set al to this
   569                                  ;
   570                                  ; do the read
   571                                  ;
   572                                  ; if error, do reset, then redo the int 13h
   573                                  ;
   574                                  ; if successful read, subtract # sectors read from SectorCount, add to logical
   575                                  ; sector, add #sectors read * BytesPerSec to bx;
   576                                  ;
   577                                  ; if SectorCount <> 0 do next read
   578                                  ; ---------------------------------------------------------------------------
   579                                  
   580                                  		; 22/12/2022
   581                                  ReadSectors:
   582 000001E7 B90500                  		mov	cx, 5			; 5 retries
   583                                  
   584                                  		; Convert a logical sector into track/sector/head. AX has the
   585                                  		; logical sector number
   586                                  TryRead:
   587 000001EA 51                      		push	cx
   588 000001EB 2EA1[0800]              		mov	ax, [cs:StartSecL]	; Get starting sector
   589 000001EF 2E8B16[0A00]            		mov	dx, [cs:StartSecH]
   590 000001F4 50                      		push	ax
   591 000001F5 89D0                    		mov	ax, dx
   592 000001F7 31D2                    		xor	dx, dx
   593 000001F9 2EF736[2600]            		div	word [cs:SecPerTrack]	
   594 000001FE 2EA3[0C00]              		mov	[cs:TempH], ax
   595 00000202 58                      		pop	ax
   596 00000203 2EF736[2600]            		div	word [cs:SecPerTrack]	; [TempH]:ax = track,
   597                                  						; dx = sector number
   598                                  
   599 00000208 2E8B1E[2600]            		mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
   600                                  						; read in this track
   601 0000020D 29D3                    		sub	bx, dx
   602 0000020F 89DE                    		mov	si, bx
   603                                  
   604 00000211 2E3936[1000]            		cmp	[cs:SectorCount], si	; Is possible sectors in track more
   605 00000216 7305                    		jnb	short GotLength		; than what we need to read?
   606 00000218 2E8B36[1000]            		mov	si, [cs:SectorCount]	; Yes, only read what we need to
   607                                  GotLength:
   608                                  		; 23/12/2022
   609                                  		; dma boundary check for >64K reads
   610 0000021D 09FF                    		or	di, di
   611 0000021F 7423                    		jz	short dma_boundary_ok ; no problem for the 1st read
   612 00000221 2E803E[2800]80          		cmp	byte [cs:BootDrive], 80h
   613 00000227 731B                    		jnb	short dma_boundary_ok ; no problem for hard disks
   614 00000229 83FE01                  		cmp	si, 1
   615 0000022C 7616                    		jna	short dma_boundary_ok ; 1 sector read will not cause to
   616                                  					      ; boundary error	
   617                                  dma_boundary_chk:
   618 0000022E 52                      		push	dx
   619 0000022F 50                      		push	ax
   620 00000230 89F0                    		mov	ax, si
   621 00000232 29D2                    		sub	dx, dx
   622 00000234 2EF726[1800]            		mul	word [cs:BytesPerSec]
   623                                  		; 23/12/2022
   624                                  		; If di> 0 -> es = 1000h
   625                                  		;mov	bx, es
   626                                  		;mov	cl, 4
   627                                  		;shl	bx, cl ; convert paragraphs to bytes
   628                                  		;; bx = segment start position (for 64K memory sections)
   629                                  		;add	bx, ax ; byte count to read
   630 00000239 89C3                    		mov	bx, ax ; byte count to read
   631 0000023B 58                      		pop	ax
   632 0000023C 5A                      		pop	dx
   633 0000023D 01FB                    		add	bx, di ; add current buffer offset to byte count
   634 0000023F 7303                    		jnc	short dma_boundary_ok
   635                                  		; Sector count must be decreased to prevent DMA boundary error!
   636 00000241 4E                      		dec	si
   637 00000242 EBEA                    		jmp	short dma_boundary_chk
   638                                  dma_boundary_ok:				
   639                                  		;inc	dl			; Sector numbers are 1-based
   640                                  		; 18/12/2022
   641 00000244 42                      		inc	dx
   642 00000245 88D3                    		mov	bl, dl			; Start sector in BL
   643 00000247 2E8B16[0C00]            		mov	dx, [cs:TempH]		; DX:AX = Track
   644 0000024C 50                      		push	ax
   645 0000024D 89D0                    		mov	ax, dx
   646 0000024F 31D2                    		xor	dx, dx
   647 00000251 2EF736[0400]            		div	word [cs:NumHeads]	; Start cyl in AX, head in dl
   648 00000256 2EA3[0C00]              		mov	[cs:TempH], ax
   649 0000025A 58                      		pop	ax
   650 0000025B 2EF736[0400]            		div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head
   651                                  
   652                                  			; At this moment, we assume that TempH = 0,
   653                                  			; ax <= 1024, dx <= 255
   654                                  
   655 00000260 88D6                    		mov	dh, dl
   656                                  		
   657 00000262 B106                    		mov	cl, 6
   658 00000264 D2E4                    		shl	ah, cl			; Shift cyl high bits up
   659 00000266 08DC                    		or	ah, bl			; Mix in with sector bits
   660 00000268 88C5                    		mov	ch, al			; Setup cyl low
   661 0000026A 88E1                    		mov	cl, ah			; Setup cyl/high - sector
   662 0000026C 89FB                    		mov	bx, di			; Get back OFFSET
   663 0000026E 2E8A16[2800]            		mov	dl, [cs:BootDrive]	; Get drive
   664 00000273 89F0                    		mov	ax, si			; Get number of sectors to read (al)
   665 00000275 B402                    		mov	ah, 2			; Read sectors
   666                                  		; 23/12/2022
   667                                  		;push	ax
   668                                  		;push	di
   669                                  
   670                                  			; Issue one read request. ES:BX have the transfer address,
   671                                  			; AL is the number of sectors.	
   672                                  
   673 00000277 CD13                    		int	13h		; DISK - READ SECTORS INTO MEMORY
   674                                  					; AL = number of sectors to read, CH = track, CL = sector
   675                                  					; DH = head, DL	= drive, ES:BX -> buffer to fill
   676                                  					; Return: CF set on error, AH =	status,	AL = number of sectors read
   677                                  		; 23/12/2022
   678                                  		;pop	di
   679                                  		;pop	ax
   680                                  
   681                                  		; 23/12/2022
   682 00000279 B400                    		mov	ah, 0
   683                                  		
   684 0000027B 59                      		pop	cx		; Get retry count back
   685 0000027C 7310                    		jnc	short ReadOk	; 23/12/2022
   686                                  		; 23/12/2022
   687                                  		;mov	bx, di		; Get offset
   688                                  		; ah = 0
   689                                  		;xor	ah, ah
   690                                  		; 23/12/2022
   691                                  		;push	cx
   692 0000027E 2E8A16[2800]            		mov	dl, [cs:BootDrive]
   693                                  		; 23/12/2022
   694                                  		;push	di
   695 00000283 CD13                    		int	13h		; DISK - RESET DISK SYSTEM
   696                                  					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
   697                                  		; 23/12/2022
   698                                  		;pop	di
   699                                  		;pop	cx
   700 00000285 49                      		dec	cx
   701 00000286 7403                    		jz	short ReadError
   702 00000288 E95FFF                  		jmp	TryRead
   703                                  ; ---------------------------------------------------------------------------
   704                                  
   705                                  ReadError:				
   706 0000028B E9E500                  		jmp	ErrorOut
   707                                  ; ---------------------------------------------------------------------------
   708                                  
   709                                  ReadOk:
   710                                  		; 23/12/2022			
   711                                  		; ah = 0
   712                                  		; 22/12/2022
   713                                  		;xor	ah, ah		; Mask out read command, just get # read
   714                                  		; ch = 0
   715 0000028E 88C1                    		mov	cl, al
   716                                  
   717                                  		; 22/12/2022
   718                                  		; cx = ax = read (sector) count	
   719                                  		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
   720                                  		;mul	bx			; Get total bytes read	
   721 00000290 2EF726[1800]            		mul	word [cs:BytesPerSec]
   722 00000295 01C7                    		add	di, ax			; Add it to OFFSET
   723 00000297 7307                    		jnc	short read_next_sector
   724 00000299 8CC3                    		mov	bx, es
   725                                  		;add	bx, 1000h
   726 0000029B 80C710                  		add	bh, 10h
   727 0000029E 8EC3                    		mov	es, bx
   728                                  read_next_sector:
   729                                  		; 22/12/2022
   730 000002A0 2E290E[1000]            		sub	[cs:SectorCount], cx
   731                                  		;sub	[cs:SectorCount], ax ; Bump number down
   732 000002A5 740E                    		jz	short EndRead
   733 000002A7 2E010E[0800]            		add	[cs:StartSecL], cx
   734                                  		;add	[cs:StartSecL], ax	; Where to start next time
   735 000002AC 2E8316[0A00]00          		adc	word [cs:StartSecH], 0
   736 000002B2 E932FF                  		jmp	ReadSectors
   737                                  ; ---------------------------------------------------------------------------
   738                                  	
   739                                  EndRead:				
   740 000002B5 C3                      		retn
   741                                  
   742                                  ; =============== S U B	R O U T	I N E =======================================
   743                                  
   744                                  ; GetNextFatEntry
   745                                  ; ---------------------------------------------------------------------------
   746                                  ;
   747                                  ; NOTES:
   748                                  ;
   749                                  ;   given the last cluster found, this will return the next cluster of
   750                                  ;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
   751                                  ;   of iosys has been loaded, and control is passed to goto_iosys
   752                                  ;   msload can handle maximum fat area size of 128 kb.
   753                                  ;
   754                                  ; INPUT:
   755                                  ;
   756                                  ;    CS:CurrentCluster
   757                                  ;    CS:FatSize
   758                                  ;
   759                                  ; OUTPUT:
   760                                  ;
   761                                  ;   CS:CurrentCluster (updated)
   762                                  ;
   763                                  ; calls:  GetFatSector
   764                                  ; ---------------------------------------------------------------------------
   765                                  ; get CurrentCluster
   766                                  ;
   767                                  ; if (16 bit fat)
   768                                  ;    {if (CurrentCluster = fff8 - ffff)
   769                                  ;	 {jmp goto_iosys}
   770                                  ;     else
   771                                  ;	{get OFFSET by multiply cluster by 2}
   772                                  ;
   773                                  ; else
   774                                  ;    {if (CurrentCluster = ff8 - fff)
   775                                  ;	 {jmp goto_iosys}
   776                                  ;     else
   777                                  ;	{get OFFSET by	- multiply cluster by 3
   778                                  ;
   779                                  ;	 rotate right to divide by 2
   780                                  ;
   781                                  ;	 if (cy set - means odd number)
   782                                  ;	    {shr 4 times to keep high twelve bits}
   783                                  ;
   784                                  ;	 else
   785                                  ;	    {and with 0fffh to keep low 12 bits}
   786                                  ;	}
   787                                  ;    }
   788                                  ;
   789                                  ; ---------------------------------------------------------------------------
   790                                  
   791                                  ; 09/12/2022
   792                                  ; FAT_12_BIT equ 1
   793                                  ; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh
   794                                  
   795                                  GetNextFatEntry:			
   796 000002B6 06                      		push	es
   797 000002B7 2EA1[3000]              		mov	ax, [cs:FatSegment]
   798 000002BB 8EC0                    		mov	es, ax		; ES-> FAT area segment
   799                                  		; 09/12/2022
   800                                  		;mov	byte [cs:EndOfFile], END_OF_FILE
   801 000002BD 2EC606[2B00]FF          		mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
   802 000002C3 2EA1[1C00]              		mov	ax, [cs:CurrentCluster] ; Get last cluster
   803                                  		;cmp	byte [cs:FatSize], FAT_12_BIT
   804 000002C7 2E803E[2900]01          		cmp	byte [cs:Fatsize], 1
   805 000002CD 7538                    		jne	short Got16Bit	; 23/12/2022
   806 000002CF 89C6                    		mov	si, ax
   807 000002D1 D1E8                    		shr	ax, 1
   808 000002D3 01C6                    		add	si, ax		; SI = AX * 1.5 = AX + AX/2
   809                                  		; 23/12/2022
   810                                  		;push	dx
   811                                  		;xor	dx, dx
   812 000002D5 29D2                    		sub	dx, dx ; 23/12/2022
   813 000002D7 E84900                  		call	GetFatSector
   814                                  		; 23/12/2022
   815                                  		;pop	dx
   816 000002DA 7510                    		jnz	short ClusterOk
   817 000002DC 268A07                  		mov	al, [es:bx]
   818                                  		; 22/12/2022
   819                                  		;mov	[cs:TempCluster], al
   820                                  		;push	ax ; (*)
   821 000002DF 46                      		inc	si
   822                                  		; 23/12/2022
   823                                  		;push	dx
   824 000002E0 31D2                    		xor	dx, dx
   825 000002E2 E83E00                  		call	GetFatSector	; Read next fat sector
   826                                  		; 23/12/2022
   827                                  		;pop	dx
   828                                  		; 22/12/2022
   829                                  		;mov	al, [es:0]
   830                                  		;mov	[cs:TempCluster+1], al
   831                                  		;mov	ax, [cs:TempCluster]
   832                                  		; 22/12/2022
   833                                  		;pop	ax ; (*) 
   834 000002E5 268A260000              		mov	ah, [es:0]
   835 000002EA EB03                    		jmp	short EvenOdd
   836                                  ; ---------------------------------------------------------------------------
   837                                  
   838                                  ClusterOk:				
   839 000002EC 268B07                  		mov	ax, [es:bx]
   840                                  EvenOdd:	
   841                                  		; 10/12/2022		
   842 000002EF 2EF606[1C00]01          		test	byte [cs:CurrentCluster], 1 ; 09/12/2022
   843                                  		;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
   844 000002F5 7505                    		jnz	short OddResult		; If not zero it was odd
   845 000002F7 25FF0F                  		and	ax, 0FFFh		; Keep low 12 bits
   846 000002FA EB04                    		jmp	short TestEOF
   847                                  ; ---------------------------------------------------------------------------
   848                                  
   849                                  OddResult:				
   850 000002FC B104                    		mov	cl, 4			; Keep high 12 bits for odd
   851 000002FE D3E8                    		shr	ax, cl
   852                                  TestEOF:				
   853 00000300 3DF80F                  		cmp	ax, 0FF8h		; Is it last cluster?
   854 00000303 731C                    		jnb	short GotClusterDone	; Yep, all done here
   855 00000305 EB14                    		jmp	short NotLastCluster
   856                                  ; ---------------------------------------------------------------------------
   857                                  
   858                                  Got16Bit:
   859                                  		; 23/12/2022				
   860                                  		;push	dx
   861                                  		;xor	dx, dx
   862 00000307 29D2                    		sub	dx, dx ; 23/12/2022
   863 00000309 D1E0                    		shl	ax, 1			; Multiply cluster by 2
   864 0000030B 83D200                  		adc	dx, 0
   865 0000030E 89C6                    		mov	si, ax			; Get the final buffer OFFSET
   866 00000310 E81000                  		call	GetFatSector
   867                                  		; 23/12/2022
   868                                  		;pop	dx
   869 00000313 268B07                  		mov	ax, [es:bx]
   870 00000316 83F8F8                  		cmp	ax, 0FFF8h
   871 00000319 7306                    		jnb	short GotClusterDone
   872                                  NotLastCluster:				
   873                                  		;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
   874 0000031B 2EC606[2B00]00          		mov	byte [cs:EndOfFile], 0	; Assume not last cluster
   875                                  GotClusterDone:				
   876 00000321 07                      		pop	es
   877 00000322 C3                      		retn
   878                                  
   879                                  ; =============== S U B	R O U T	I N E =======================================
   880                                  
   881                                  ; GetFatSector
   882                                  ; ---------------------------------------------------------------------------
   883                                  ;function: find and read the corresponding fat sector into ES:0
   884                                  ;
   885                                  ;in). SI = offset value (starting from fat entry 0) of fat entry to find.
   886                                  ;     ES = fat sector segment
   887                                  ;     CS:BytesPerSec
   888                                  ;
   889                                  ;out). corresponding fat sector read in.
   890                                  ;      BX = offset value of the corresponding fat entry in the fat sector.
   891                                  ;      CX destroyed.
   892                                  ;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
   893                                  ;      starts at the last byte of the fat sector. in this case, the caller
   894                                  ;      should save this byte, and read the next fat sector to get the rest
   895                                  ;      of the fat entry value. (this will only happen with the 12 bit fat).
   896                                  ;
   897                                  ; ---------------------------------------------------------------------------
   898                                  
   899                                  		; 22/12/2022
   900                                  GetFatSector:				
   901 00000323 50                      		push	ax
   902 00000324 56                      		push	si
   903 00000325 57                      		push	di
   904 00000326 89F0                    		mov	ax, si
   905 00000328 2E8B0E[1800]            		mov	cx, [cs:BytesPerSec]
   906 0000032D F7F1                    		div	cx			; AX = Sector number, DX = Offset
   907 0000032F 2E3B06[0E00]            		cmp	ax, [cs:LastFatSector]	; The same fat sector?
   908 00000334 7434                    		je	short SplitChk		; Don't need to read it again.
   909 00000336 2EA3[0E00]              		mov	[cs:LastFatSector], ax
   910 0000033A 52                      		push	dx
   911 0000033B 31D2                    		xor	dx, dx
   912 0000033D 2E0306[1400]            		add	ax, [cs:HiddenSectorsL]
   913 00000342 2E1316[1600]            		adc	dx, [cs:HiddenSectorsH]
   914 00000347 2E0306[1A00]            		add	ax, [cs:ReservSectors]
   915 0000034C 83D200                  		adc	dx, 0
   916 0000034F 2EA3[0800]              		mov	[cs:StartSecL], ax
   917 00000353 2E8916[0A00]            		mov	[cs:StartSecH], dx	; Set up for ReadSectors
   918                                  					
   919 00000358 2EC706[1000]0100        		mov	word [cs:SectorCount], 1 ; 1 sector
   920 0000035F 31FF                    		xor	di, di
   921 00000361 E883FE                  		call	ReadSectors
   922 00000364 5A                      		pop	dx
   923 00000365 2E8B0E[1800]            		mov	cx, [cs:BytesPerSec]
   924                                  SplitChk:				
   925 0000036A 49                      		dec	cx			; CX = SECTOR SIZE - 1
   926 0000036B 39CA                    		cmp	dx, cx			; If last byte of sector, splitted entry.
   927 0000036D 89D3                    		mov	bx, dx			; set bx to dx
   928 0000036F 5F                      		pop	di
   929 00000370 5E                      		pop	si
   930 00000371 58                      		pop	ax
   931                                  EndWrite:		; 10/12/2022
   932 00000372 C3                      		retn
   933                                  
   934                                  ; ---------------------------------------------------------------------------
   935                                  
   936                                  ErrorOut:				
   937 00000373 0E                      		push	cs
   938 00000374 1F                      		pop	ds
   939 00000375 BE[9D03]                		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
   940 00000378 E81400                  		call	WriteTTY
   941                                  
   942                                  		; Wait for a keypress on the keyboard.
   943                                  		; Use the bios keyboard interrupt.
   944                                  
   945 0000037B 30E4                    		xor	ah, ah
   946 0000037D CD16                    		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
   947                                  					; Return: AH = scan code, AL = character
   948                                  
   949                                  		; We have to restore the address of the original rom disk
   950                                  		; parameter table to the location at [0:DskAddr]. The address
   951                                  		; of this original table has been saved previously in
   952                                  		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
   953                                  		; has been restored we can reboot by invoking the bootstrap
   954                                  		; loader bios interrupt.
   955                                  
   956                                  		; 23/12/2022
   957                                  		;xor	bx, bx
   958                                  		;mov	ds, bx
   959                                  		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
   960                                  					 ; (Erdogan Tan, 23/12/2022)
   961 0000037F C41E[2C00]              		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
   962                                  		
   963                                  		; 23/12/2022
   964 00000383 16                      		push	ss ; 0
   965 00000384 1F                      		pop	ds
   966                                  		; ds = 0		
   967                                  
   968 00000385 BE7800                  		mov	si, DskAddr	; (Int 1Eh)
   969 00000388 891C                    		mov	[si], bx	; restore offset		
   970 0000038A 8C4402                  		mov	[si+2], es	; restore segment
   971                                  
   972 0000038D CD19                    		int	19h		; reboot
   973                                  
   974                                  ; =============== S U B	R O U T	I N E =======================================
   975                                  
   976                                  ; WriteTTY
   977                                  ; ---------------------------------------------------------------------------
   978                                  ; in) DS:si -> asciiz string.
   979                                  ;
   980                                  ; WriteTTY the character in al to the screen.
   981                                  ; use video service 'write teletype to active page' (ROM_TTY)
   982                                  ; use normal character attribute
   983                                  ; ---------------------------------------------------------------------------
   984                                  
   985                                  WriteTTY:				
   986 0000038F AC                      		lodsb
   987 00000390 08C0                    		or	al, al
   988 00000392 74DE                    		jz	short EndWrite
   989                                  		;mov	AH, ROM_TTY	; 09/12/2022
   990 00000394 B40E                    		mov	ah, 0Eh
   991 00000396 B307                    		mov	bl, 7		; "normal" attribute
   992 00000398 CD10                    		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
   993                                  					; AL = character, BH = display page (alpha modes)
   994                                  					; BL = foreground color	(graphics modes)
   995 0000039A EBF3                    		jmp	short WriteTTY
   996                                  ; ---------------------------------------------------------------------------
   997                                  
   998                                  ; 10/12/2022	
   999                                  ;EndWrite:				
  1000                                  ;		retn
  1001                                  
  1002                                  ; ---------------------------------------------------------------------------
  1003                                  
  1004                                  ; 09/12/2022
  1005                                  ;include msbio.cl1
  1006                                  
  1007                                  		; 22/12/2022
  1008                                  		; 20/12/2022
  1009                                  		; 18/12/2022
  1010 0000039C 00                      		db 0	; (word alignment)
  1011                                  NonSystemDiskMsg:
  1012 0000039D 0D0A                    		db 0Dh,0Ah
  1013 0000039F 4E6F6E2D5379737465-     		db 'Non-System disk or disk error',0Dh,0Ah
  1013 000003A8 6D206469736B206F72-
  1013 000003B1 206469736B20657272-
  1013 000003BA 6F720D0A           
  1014 000003BE 5265706C6163652061-     		db 'Replace and press any key when ready',0Dh,0Ah,0
  1014 000003C7 6E6420707265737320-
  1014 000003D0 616E79206B65792077-
  1014 000003D9 68656E207265616479-
  1014 000003E2 0D0A00             
  1015                                  ;EndOfLoader:
  1016                                  		; 22/12/2022
  1017 000003E5 A101                    		dw 01A1h	; 10/12/2022
  1018                                  
  1019                                  ; ---------------------------------------------------------------------------
  1020                                  
  1021                                  ; 23/12/2022
  1022 000003E7 00                      		db 0
  1023 000003E8 0D0A                    loading_msg:	db 0Dh, 0Ah
  1024 000003EA 4C6F6164696E67204B-     		db 'Loading Kernel MSDOS.SYS ... '
  1024 000003F3 65726E656C204D5344-
  1024 000003FC 4F532E535953202E2E-
  1024 00000405 2E20               
  1025                                  crlf:
  1026 00000407 0D0A00                  		db 0Dh, 0Ah, 0
  1027                                  
  1028                                  ; ---------------------------------------------------------------------------
  1029                                  
  1030                                  ; 22/12/2022
  1031                                  ; (set file size to 1536 bytes)
  1032                                  
  1033                                  SignatureSize equ EndOfLoader - signature
  1034                                  
  1035                                  FillingSpace equ ($-START$)+SignatureSize
  1036                                  
  1037 0000040A FF<rep 1B0h>            times		1536-FillingSpace db 0FFh ; db 90h
  1038                                  
  1039 000005BA 00                      signature:	db 0
  1040 000005BB 0D0A                    		db 0Dh, 0Ah
  1041 000005BD 526574726F20444F53-     		db 'Retro DOS v4 Kernel Loader (Fake IO.SYS) '
  1041 000005C6 207634204B65726E65-
  1041 000005CF 6C204C6F6164657220-
  1041 000005D8 2846616B6520494F2E-
  1041 000005E1 5359532920         
  1042 000005E6 0D0A                    		db 0Dh,0Ah
  1043 000005E8 6279204572646F6761-     		db 'by Erdogan Tan [2022]'
  1043 000005F1 6E2054616E205B3230-
  1043 000005FA 32325D             
  1044 000005FD 0D0A00                  		db  0Dh, 0Ah, 0
  1045                                  EndOfLoader:
