; ****************************************************************************
; RD4LOAD.S (Retro DOS v4 KERNEL LOADER) -IO.SYS- by ERDOGAN TAN - 22/12/2022
; ----------------------------------------------------------------------------
; Last Update: 24/12/2022 (Modified IO.SYS loader) 
; ----------------------------------------------------------------------------
; Beginning: 22/12/2022 (Retro DOS 4.0 Kernel Loader, Fake IO.SYS)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15
; ----------------------------------------------------------------------------
;	   ((nasm rd4load.s -l rd4load.txt -o IO.SYS -Z error.txt)) 
; ----------------------------------------------------------------------------
; Derived from disassembled MSLOAD code of MSDOS 5.0 IO.SYS by Erdogan Tan 
; (Disassembly: 18/09/2022, NASM source: 21/10/2022, Last update: 22/12/2022) 
; ----------------------------------------------------------------------------

; +-------------------------------------------------------------------------+
; |   This file	has been generated by The Interactive Disassembler (IDA)    |
; |	      Copyright	(c) 2013 Hex-Rays, <support@hex-rays.com>	    |
; |			 Licensed to: Freeware version			    |
; +-------------------------------------------------------------------------+
;
; Input	MD5   :	B2FA03653E5C5D545327EE28B8A24356
; Input	CRC32 :	20FC79BF

; ---------------------------------------------------------------------------
; File Name   :	C:\Users\Erdoðan\Desktop\IO.SYS
; Format      :	Binary file
; Base Address:	0000h Range: 0000h - 8296h Loaded length: 00008296h

;		.386
;		.model flat

; ===========================================================================

; 09/12/2022
; Comments are from MSDOS 6.0 MSLOAD.ASM (1991) & HEX-RAYS IDA disasm output

; ===========================================================================
;	NOTE: The boot loader should be verifying that the first
;	  block of io.sys is, in fact, at cluster 2. This would be saving
;	  a whole lot of time during system debugging.
;
;============================================================================
;
;     for dos 4.00, msload program has been changed to allow:
;	  1. 32 bit calculation,
;	  2. reading a fat sector when needed, instead of reading the whole
;	     fat sectors at once. this will make the boot time faster,
;	     and eliminate the memory size limitation problem,
;	  3. solving the limitation of the file size (29 kb) of io.sys,
;	  4. adding the boot error message. show the same boot error message
;	     and do the same behavior when the read operation of io.sys
;	     fails as the msboot program, since msload program is the
;	     extention of msboot program.
;
; ===========================================================================

;----------------------------------------------------------------------------
		[ORG 0]			; segment 0x0070h
;----------------------------------------------------------------------------

START$:
		jmp	short SaveInputValues

; 24/12/2022
; 23/12/2022
; 20/12/2022
; 09/12/2022
; ---------------------------------------------------------------------------
SysVersion:	dw 5			; expected_version	
ClusterSize:	dw 0
StartSecL:	dw 0
StartSecH:	dw 0
TempH:		dw 0			; for 32 bit calculation
;TempCluster:	dw 0
;HiddenSectorsL: dw 0
;HiddenSectorsH: dw 0
;ReservSectors:	dw 0
LastFatSector:	dw 0FFFFh		; fat sec # start from 1st FAT entry
SectorCount:	dw 0
CurrentCluster:	dw 0	; *!*
BytesPerSec:	dw 0
SecPerCluster:	dw 0
;RootDirEntries: dw 0
SecPerFat:	dw 0
SecPerTrack:	dw 0
NumHeads:	dw 0
TotalSectorsL:	dw 0			; max. number of sectors
TotalSectorsH:	dw 0
FirstSectorL:	dw 0
FirstSectorH:	dw 0
BootDrive:	db 0
Fatsize:	db 0
MediaByte:	db 0
EndOfFile:	db 0
OrgDasdPtr:	dd 0
;FatSegment:	dw 0
FatStartSecL:	dw 0
FatStartSecH:	dw 0

; ---------------------------------------------------------------------------

; SaveInputValuess
; ---------------------------------------------------------------------------
; INPUT:     none
;
;   dl = int 13 drive number we booted from
;   ch = media byte
;   bx = first data sector (low) on disk (0-based)
;   ds:si = original rom bios diskette parameter table.
;
; if an extended boot record, then ax will be the first data sector
; high word. save ax and set FirstSectorH according to ax if it is an
; extended boot record.
;
;   ax = first data sector (high) on disk ;
; OUTPUT:
;
;   bx = first data sector on disk
;
;   MediaByte = input ch
;   BootDrive = input dl
;   FirstSectorL = input bx
;   FirstSectorH = input AX, if an extended boot record.;j.k.
;   TotalSectorsL = maximum sector number in this media ;j.k.
;   TotalSectorsH = high word of the above
;   HiddenSectorsL = hidden secotrs
;   HiddenSectorsH
;   ReservSectors = reserved sectors
;   SecPerTrack = sectors/track
;   NumHeads = heads/cylinder
;
;   ds = 0
;   AX,DX,SI destroyed
;
; calls:     none
; ---------------------------------------------------------------------------
;FUNCTION:
; save input information and bpb informations from the boot record.
; ---------------------------------------------------------------------------

Sec9 equ 522h
; 20/12/2022	
DskAddr	equ 1Eh*4 ; 7Eh
; 22/12/2022
;StackPtr equ MyStacks+(NumHeads-MyStacks)

; 24/12/2022
; 22/12/2022
KernelFirstClustr equ 53Ah	; The 1st cluster address of 'MSDOS.SYS' file
				; in the root directory entry.

; ---------------------------------------------------------------------------

		; 23/12/2022
		; (registers from MSDOS 5.0 boot sector)
		; ss = 0
		; sp = 7C00h
		; ds = 0
		; es = 0
		; ax:bx = absolute disk address for cluster 2 (data start)
		; dl = [BootDrv] = [7C24h]
		; ch = [MediaByte] = [7C15h]
		; ds:si = rom bios disk(ette) params table address (INT 1Eh)
		; 0:500h = root dir buffer (1st sector of the root dir)

SaveInputValues:
		; 24/12/2022
		push	ds
		push	cs
		pop	ds 
		;mov	[cs:FirstSectorL], bx ; first data sector (low word)
		;mov	[cs:MediaByte], ch
		;mov	[cs:BootDrive], dl
		;mov	[cs:OrgDasdPtr], si
		;push	ds
		;pop	word [cs:OrgDasdPtr+2]
		mov	[FirstSectorL], bx
		mov	[StartSecL], bx ; **!**
		mov	[MediaByte], ch
		mov	[BootDrive], dl
		mov	[OrgDasdPtr], si
		pop	word [OrgDasdPtr+2]
	
		xor	cx, cx		; segment 0 (obviously)
		mov	ds, cx		; ZERO
		; 23/12/2022
		; es = 0 (just before jumping to start of IO.SYS) 
		;push	es ; !
		;mov	es, cx
		; es = 0
		;mov	si, [DskAddr]	; 0000h:0078h (Int 1Eh)
		;mov	ds, [DskAddr+2]	; DS:SI -> current table
		; 20/12/2022
		mov	si, Sec9
		mov	di, si
		xchg	si, [DskAddr]
		xchg	cx, [DskAddr+2]
		mov	ds, cx
		;mov	di, Sec9	; 522h  ; ES:DI -> new table
		mov	cx, 11			; taken from ibmboot.asm
		cld
		rep movsb		; copy table
		;push	es
		;pop	ds		; ds = 0
		; 20/12/2022
		mov	ds, cx ; 0
		;mov	word [DskAddr], Sec9 ; 522h
		;mov	[DskAddr+2], ds	; point disk parm vector to new table
		; 23/12/2022
		;pop	es ; !
		; es = 0
		; ds = 0
		; ss = 0
; 24/12/2022
%if 0
		mov	cx, [7C0Bh] 	; BootSector.ext_boot_bpb.BPB_bytespersector
		mov	[cs:BytesPerSec], cx
		mov	cl, [7C0Dh]	; BootSector.ext_boot_bpb.BPB_sectorspercluster
		mov	[cs:SecPerCluster], cl
		mov	cx, [7C18h]	; BootSector.ext_boot_bpb.BPB_sectorspertrack	
		mov	[cs:SecPerTrack], cx
		mov	cx, [7C1Ah]	; BootSector.ext_boot_bpb.BPB_heads
		mov	[cs:NumHeads], cx
		mov	cx, [7C16h]	; BootSector.ext_boot_bpb.BPB_sectorsperfat
		mov	[cs:SecPerFat], cx
		mov	cx, [7C0Eh]	; BootSector.ext_boot_bpb.BPB_reservedsectors	
		mov	[cs:ReservSectors], cx
		mov	cx, [7C1Ch]	; BootSector.ext_boot_bpb.BPB_hiddensectors
		mov	[cs:HiddenSectorsL], cx
		mov	cx, [7C13h]	; BootSector.ext_boot_bpb.BPB_totalsectors
		mov	[cs:TotalSectorsL], cx

		; First of all, check if it the boot record is an extended one.
		; This is just a safe guard in case some user just "copy" the
		; 4.00 iosys.com to a media with a conventional boot record.

		; 22/12/2022
		cmp	byte [7C26h], 29h ; ext_boot_signature
		jne	short relocate
		mov	[cs:FirstSectorH], ax ; first data sector (high word)
		mov	ax, [7C1Eh]
		mov	[cs:HiddenSectorsH], ax
		; 10/12/2022
		or	cx, cx
		;cmp	cx, 0		; cx set already before (=totalsectors)
		; 22/12/2022
		jnz	short relocate
		mov	ax, [7C20h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors
		mov	[cs:TotalSectorsL], ax
		mov	ax, [7C22h]	; BootSector.ext_boot_bpb.BPB_bigtotalsectors+2
		mov	[cs:TotalSectorsH], ax
%endif
		; 24/12/2022
		push	ax  ; * ; first data sector (high word)
		
		push	cs
		pop	es

		; get the 1st cluster of MSDOS.SYS 
		mov	ax, [KernelFirstClustr] ; [053Ah]
		mov	di, CurrentCluster  
		stosw	 ; *!* ; Initialize CurrentCluster to this cluster
		; di = offset BytesPerSec 
		
		mov	si, 07C0Bh	; boot sector's bpb, BytesPerSector
		;mov	di, BytesPerSec
		movsw	; BytesPerSec
		movsb	; SecPerCluster
		inc	di ; skip high byte of SecPerCluster word (it is 0)
		lodsw	; ReservSectors
		mov	bx, ax ; save ReservSectors in bx
		lodsb	; skip NumFats
		;movsw	; RootDirEntries ; !
		lodsw	; skip NUmDirEntries ; !
		lodsw	; TotalSectorsL
		mov	cx, ax ; save TotalSectorsL in cx
		lodsb	; skip MediaByte
		movsw	; SecPerFat
		movsw 	; SecPerTrack
		movsw	; NumHeads
		lodsw	; HiddenSectorsL
		push 	ax ; **	; HiddenSectorsL
		lodsw	; HiddenSectorsH
		mov	dx, ax	; save HiddenSectorsH in dx
		lodsw	
		push	ax ; *** ; BigTotalSecs lw
		lodsw
		push	ax ; **** ; BigTotalSecs hw
		lodsw	; skip BootDrv and CurrentHead

		mov	ax, cx ; TotalSectorsL

		mov	bp, si		
 
		pop	cx ; **** ; BigTotalSecs hw

		pop	si ; *** ; BigTotalSecs lw

		push	cs
		pop	ds
		
		; ss = 0
		; bp = 7C26h
		
		cmp	byte [bp], 29h  ; ext_boot_signature
		je	short ext_boot_sec_1

		stosw	; TotalSectorsL

		;pop	ax ; *** ; discard BigTotalSecs lw
		pop	ax ; ** ; HiddenSectorsL
		pop	dx ; * ; discard 1st data sector hw
		xor	dx, dx ; 0
		jmp	short set_fat_start
ext_boot_sec_1:
		; 24/12/2022
		;pop	si ; *** ; BigTotalSecs lw
		or	ax, ax  ; TotalSectorsL (16 bit total sectors)
		jnz	short ext_boot_sec_2 ; (*)

		; (32 bit total sectors)
		mov	ax, si ; BigTotalSecs lw 
		stosw	; TotalSectorsL	
		mov	ax, cx ; BigTotalSecs hw
ext_boot_sec_2:
		stosw	; TotalSectorsH or TotalSectorsL (*)
		pop	ax ; ** ; HiddenSectorsL
		;pop	word [FirstSectorH] ; * ; 1st data sector hw
		pop	cx ; * ; [FirstSectorH] ; 1st data sector hw
		mov	[FirstSectorH], cx
		mov	[StartSecH], cx ; **!**	

		; here, DI points to FatStartSecL
set_fat_start:
		; 24/12/2022
		; dx:ax = HiddenSectors
		; bx = ReservSectors

		add 	ax, bx
		adc	dx, 0

		;mov	[FatStartSecL], ax
		;mov	[FatStartSecH], dx		

		mov	di, FatStartSecL
		stosw
		mov	ax, dx
		stosw		
		
; --------------------------------------------------------------------------- 

relocate:
		; 23/12/2022
		; (set fat buffer segment at the end of loader)

		FATBUFSEGM equ 70h+(((EndOfLoader-START$)+15)>>4)
						 ; paragraph alignment
		
		; 24/12/2022
		;mov	word [cs:FatSegment], FATBUFSEGM
		FATSEGMENT equ FATBUFSEGM

		; 24/12/2022
		; ds = cs

; ---------------------------------------------------------------------------
SetupStack:	
		; 22/12/2022
		;cli
		;xor	ax, ax
		;mov	ss, ax
		;mov	sp, 700h
		;sti

; ---------------------------------------------------------------------------
; 23/12/2022
; Write loading message
		
		; 24/12/2022	
		;push	cs
		;pop	ds
		mov	si, loading_msg
		call	WriteTTY

; FindClusterSize
; ---------------------------------------------------------------------------
;
; INPUT:     bpb information in loaded boot record at 0:7c00h
;
; OUTPUT:
;
;	ds = 0
;	ax = bytes/cluster
;	bx = sectors/cluster
;	si destroyed
; calls:     none
;----------------------------------------------------------------------------
;
; get bytes/sector from bpb
;
; get sectors/cluster from bpb
;
; bytes/cluster = bytes/sector * sector/cluster
; ---------------------------------------------------------------------------

FindClusterSize:

;for the time being just ASSUME the boot record is valid and the bpb is there.

		; 24/12/2022
		; ds = cs
		;xor	ax, ax
		;mov	ds, ax
		;mov	ax, [7C0Bh]	; get bpb bytes/sector
		; 24/12/2022
		mov	ax, [BytesPerSec]
		;xor	bx, bx
		;mov	bl, [7C0Dh]	; get sectors/cluster
		;mul	bx
		mul	word [SecPerCluster]
		;mov	[cs:ClusterSize], ax
		; 24/12/2022
		mov	[ClusterSize], ax

; CalcFatSize
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   Determine if fat is 12 or 16 bit fat. 12 bit fat if floppy, read mbr
;   to find out what system id byte is.
;
; INPUT:
;
; OUTPUT:
;
;   CS:FatSize = FAT_12_BIT or FAT_16_BIT
;   all other registers destroyed
;
; ---------------------------------------------------------------------------

CalcFatSize:
		; 24/12/2022
		; ds = cs
		mov	byte [Fatsize], 1
		;mov	byte [cs:Fatsize], 1 ; FAT_12_BIT (assume)
		;mov	dx, [cs:TotalSectorsH]
		;mov	ax, [cs:TotalSectorsL] ; DX:AX = total disk sectors
		mov	dx, [TotalSectorsH]
		mov	ax, [TotalSectorsL] ; DX:AX = total disk sectors
		;;;		
; 24/12/2202
%if 0
		sub	ax, [ReservSectors]
		;sub	ax, [cs:ReservSectors]
		sbb	dx, 0		; DX:AX	= Total	avail sectors
		;mov	bx, [cs:SecPerFat]
		mov	bx, [SecPerFat]
		shl	bx, 1		; (Assume 2 FATs)
		sub	ax, bx
		sbb	dx, 0
		;mov	bx, [7C11h]	; Root directory entry count
		mov	bx, [RootDirEntries]
		mov	cl, 4
		shr	bx, cl		; BX = Total directory sectors
		sub	ax, bx
		sbb	dx, 0		; DX:AX	= Sectors in data area
%endif
		; 24/12/2022
		sub	ax, [FirstSectorL] ; total sectors - start of data
		sbb	dx, [FirstSectorH]
				; DX:AX	= Sectors in data area
		;;;
		;xor	cx, cx
		;mov	cl, [7C0Dh]	; Sectors per cluster
		mov	cx, [SecPerCluster] ; *#*
		push	ax
		mov	ax, dx
		xor	dx, dx
		div	cx  ; *#*
		; 24/12/2022
		;;mov	[cs:TempH], ax	; AX = Total number of clusters
		;mov	[TempH], ax
		pop	ax
		div	cx  ; *#*
		cmp	ax, 4086	; 4096-10
		jb	short ReadInFirstClusters ; 12 bit FAT
		;mov	byte [cs:Fatsize], 4 ; FAT_16_BIT
		mov	byte [Fatsize], 4 ; FAT_16_BIT

; 22/12/2022
;----------------------------------------------------------------------------
; HERE IS DIFFERENT THAN IO.SYS LOADER (MSLOAD)
; FOLLOWING CODE HAS BEEN MODIFIED FOR LOADING RETRO DOS KERNEL (MSDOS.SYS)
;----------------------------------------------------------------------------

; 22/12/2022

KernelInitSegment equ 1000h	; Address where the kernel will be loaded

; ---------------------------------------------------------------------------

		; 23/12/2022	
		; 22/12/2022	
ReadInFirstClusters:
		; 24/12/2022
		;;mov	ax, [53Ah]
		;mov	ax, [ss:KernelFirstClustr] ; [ss:053Ah] 
		;; 23/12/2022
		;;mov	[cs:CurrentCluster], ax ; Initialize to this cluster
		; 24/12/2022
		; ds = cs
		;mov	[CurrentCluster], ax

		; 24/12/2022
		; [currentCluster] = the 1st cluster of MSDOS.SYS ; *!*
		mov	ax, [CurrentCluster]
					; MSDOS.SYS First Cluster
		dec	ax		; Root dir buffer at 500h (segment=0)
					; MSDOS.SYS first cluster ptr at 53Ah
		dec	ax		; AX = word [53Ah] - 2

; 24/12/2022
%if 0
		mov	cx, [cs:FirstSectorL] ;	Put starting sector of disk data
		mov	[cs:StartSecL], cx    ; area in StartSecH:StartSecL
		mov	cx, [cs:FirstSectorH]
		mov	[cs:StartSecH], cx
		xor	cx, cx
		mov	cl, [cs:SecPerCluster]
		mul	cx		; DX:AX = logical start sector
		add	[cs:StartSecL], ax
		adc	[cs:StartSecH], dx
					; abs start sector for next read of
					; the rest of the last loader cluster
%endif
		; 24/12/2022
		; ds = cs
		;mov	cx, [FirstSectorL] ; Put starting sector of disk data
		;mov	[StartSecL], cx	   ; area in StartSecH:StartSecL
		;mov	cx, [FirstSectorH]
		;mov	[StartSecH], cx
		; [StartSecL] = [FirstSectorL] ; **!**
		; [StartSecH] = [FirstSectorH] ; **!**

		; ax = cluster index (cluster number - 2)

		;;xor	cx, cx
		;;mov	cl, [SecPerCluster]
		;mov	cx, [SecPerCluster] ; ch = 0
		; cx = [SecPerCluster]  ; *#* ; 24/12/2022
		mul	cx		; DX:AX = logical start sector
		; 24/12/2022
		add	[StartSecL], ax
		adc	[StartSecH], dx
					; abs start sector for next read of
					; the rest of the last loader cluster
		; 22/12/2022
		mov	di, KernelInitSegment
		;mov	di, 1000h	; MSDOS.SYS initial (loading) segment
		mov	es, di
		xor	di, di		; 1000h:0000h
		; 24/12/2022
		; cx = [SecPerCluster]
		;mov	ax, [SecPerCluster]
		;;sub	ax, ax
		;;mov	al, [SecPerCluster]
		mov	ax, cx
					; Read in the entire last cluster
		mov	[SectorCount], ax ; ah = 0

		call	ReadSectors

		; 22/12/2022
		;mov	[cs:NextBioLocation], di

; GetContigClusters
; ---------------------------------------------------------------------------
;
; NOTES: go find clusters as long as they are contiguous
;
;
; INPUT:
;   CS:NextBioLocation
;   CS:
;
; OUTPUT:
;
; calls: GetNextFatEntry
; ---------------------------------------------------------------------------
;
;Set CS:SectorCount to sectors per cluster
;
;Call GetNextFatEntry to get next cluster in file
;
;Call check_for_eof
;
;if (nc returned)
;
;   {call GetNextFatEntry
;
;    if (new cluster is contig to old cluster)
;	{add sectors per cluster to CS:SectorCount
;
;	 call check_for_eof
;
;	 if (nc returned)
;
; ---------------------------------------------------------------------------

; 09/12/2022
; END_OF_FILE equ 0FFh
; DosLoadSeg equ 70h

		; 24/12/2022
GetContigClusters:

; 24/12/2022
%if 0			
		xor	ah, ah
		mov	al, [cs:SecPerCluster]	; Assume we will get one cluster
		mov	[cs:SectorCount], ax	; Sector count = sectors in 1 cluster
		push	word [cs:SectorCount]
		call	GetNextFatEntry		; Returns next cluster to read in AX	
		pop	word [cs:SectorCount]
		mov	[cs:CurrentCluster], ax ; Update the last one found
		cmp	byte [cs:EndOfFile], 0FFh ; END_OF_FILE
		je	short GoToBioInit ; 23/12/2022
		; 22/12/2022
		;xor	dx, dx ; * (not required)
		; 10/12/2022
		;sub	ax, 2			; Zero base the cluster
		dec	ax
		dec	ax
		xor	ch, ch
		mov	cl, [cs:SecPerCluster]
		mul	cx ; *			; How many sectors (before next cluster) 
		add	ax, [cs:FirstSectorL]	; See where the data sector starts
		adc	dx, [cs:FirstSectorH]
		mov	[cs:StartSecL], ax	; Save it (used by ReadSectors)
		mov	[cs:StartSecH], dx
		; 22/12/2022
		;mov	di, [cs:NextBioLocation] ; Get where to put code
		;push	word [cs:SectorCount]	; Save how many sectors
		call	ReadSectors
		;pop	ax			; Get back total sectors read in
		;mul	word [cs:BytesPerSec]	; Get number of bytes we loaded
		;add	[cs:NextBioLocation], ax ; Point to where to load next	
		jmp	short GetContigClusters

%endif
		; 24/12/2022
		; ds = cs

		mov	ax, [SecPerCluster]	; Assume we will get one cluster
		mov	[SectorCount], ax	; Sector count = sectors in 1 cluster
		;push	word [SectorCount]
		push	ax
		call	GetNextFatEntry		; Returns next cluster to read in AX	
		pop	word [SectorCount]
		mov	[CurrentCluster], ax	; Update the last one found

		cmp	byte [EndOfFile], 0FFh	; END_OF_FILE
		je	short GoToBioInit ; 23/12/2022
		; 22/12/2022
		;xor	dx, dx ; * (not required)
		; 10/12/2022
		;sub	ax, 2			; Zero base the cluster
		dec	ax
		dec	ax
		; 24/12/2022
		; ax = cluster index
		;mov	cx, [SecPerCluster]
		;mul	cx ; *			; How many sectors (before next cluster) 
		mul	word [SecPerCluster]
		add	ax, [FirstSectorL]	; See where the data sector starts
		adc	dx, [FirstSectorH]
		mov	[StartSecL], ax		; Save it (used by ReadSectors)
		mov	[StartSecH], dx
			
		call	ReadSectors
				; ES:DI = (the next) buffer address for next read
		
		jmp	short GetContigClusters

; ---------------------------------------------------------------------------

; GoToBioInit
; ---------------------------------------------------------------------------
;
; NOTES:
;
;  Set up required registers for iosys, then jump to it (70:0)
;
; INPUT:     none
;
;   CS:MediaByte = media byte
;   CS:BootDrive = int 13 drive number we booted from
;   CS:FirstSectorL = first data sector on disk (low) (0-based)
;   CS:FirstSectorH = first data sector on disk (high)
;
; OUTPUT:
;
;   required by msinit
;   DL = int 13 drive number we booted from
;   CH = media byte
;   BX = first data sector on disk (0-based)
;   AX = first data sector on disk (high)
;   DI = sectors/fat for the boot media.
;
; calls:     none
; ---------------------------------------------------------------------------
;
; set up registers for msinit then do far jmp
;
; ---------------------------------------------------------------------------

GoToBioInit:
		; 22/12/2022
		; Set registers just as Retro DOS v2/v3 boot sector sets them
		
		; these are not necessary
		;xor	ax, ax
		;mov	ds, ax
		;mov	bp, 7C00h
		;cli
		;mov	ss, ax
		;mov	sp, bp
		;sti
	
		; 23/12/2022
		;push	cs
		;pop	ds
		;mov	si, crlf
		; 24/12/2022
		; ds = cs
		mov	si, ok_msg
		call	WriteTTY
		
		mov	dh, [MediaByte] ; Restore regs required for msint
		mov	dl, [BootDrive] ; Physical drv number we booted from.
		mov	ax, [TotalSectorsL]

		; 22/12/2022
		; (far jump to Retro DOS kernel start address)
		jmp	1000h:0	; Far jump to MSDOS.SYS address	(KERNEL)

; =============== S U B	R O U T	I N E =======================================

; ReadSectors
; ---------------------------------------------------------------------------
; notES:
;
;  read in the CS:SectorCount number of sectors at ES:di
;
;
; INPUT:
;
;   DI = OFFSET of start of read
;   ES = segment of read
;   CS:SectorCount = number of sectors to read
;   CS:StartSecL = starting sector (low)
;   CS:StartSecH = starting sector (high)
;   following is bpb info that must be setup prior to call
;   CS:NumHeads
;   CS:number_of_sectors
;   CS:BootDrive
;   CS:SecPerTrack
;
; OUTPUT:
;
;   AX,BX,CX,DX,SI,DI destroyed
; ---------------------------------------------------------------------------
; divide start sector by sectors per track
; the remainder is the actual sector number, 0 based
;
; increment actual sector number to get 1 based
;
; the quotient is the number of tracks - divide by heads to get the cyl
;
; the remainder is actual head, the quotient is cylinder
;
; figure the number of sectors in that track, set al to this
;
; do the read
;
; if error, do reset, then redo the int 13h
;
; if successful read, subtract # sectors read from SectorCount, add to logical
; sector, add #sectors read * BytesPerSec to bx;
;
; if SectorCount <> 0 do next read
; ---------------------------------------------------------------------------

		; 24/12/2022
		; 22/12/2022
ReadSectors:
		mov	cx, 5			; 5 retries

		; Convert a logical sector into track/sector/head. AX has the
		; logical sector number
TryRead:
		; 24/12/2022
		; ds = cs
		push	cx
		;mov	ax, [cs:StartSecL]	; Get starting sector
		;mov	dx, [cs:StartSecH]
		mov	ax, [StartSecL]		; Get starting sector
		mov	dx, [StartSecH]
		push	ax
		mov	ax, dx
		xor	dx, dx
		;;div	word [cs:SecPerTrack]
		;div	word [SecPerTrack]	
		; 24/12/2022
		mov	bx, [SecPerTrack]
		div	bx
		mov	[TempH], ax
		;mov	[cs:TempH], ax
		pop	ax
		div	bx
		;div	word [SecPerTrack]
		;;div	word [cs:SecPerTrack]	; [TempH]:ax = track,
						; dx = sector number

		;mov	bx, [cs:SecPerTrack]	; Get number of sectors we can
						; read in this track
		sub	bx, dx
		;mov	si, bx
		mov	si, [SectorCount]

		cmp	si, bx
		jna	short GotLength
		;cmp	[SectorCount], si
		;;cmp	[cs:SectorCount], si	; Is possible sectors in track more
		;jnb	short GotLength		; than what we need to read?
		mov	si, bx
		;mov	si, [SectorCount]
		;;mov	si, [cs:SectorCount]	; Yes, only read what we need to
GotLength:
		; 23/12/2022
		; dma boundary check for >64KB reads
		; 24/12/2022
		; Also, Segment Override risk !
		or	di, di
		jz	short dma_boundary_ok ; no problem for the 1st read
		; 24/12/2022
		;cmp	byte [BootDrive], 80h
		;;cmp	byte [cs:BootDrive], 80h
		;jnb	short dma_boundary_ok ; no problem for hard disks
dma_boundary_chk:
		; 24/12/2022
		cmp	si, 1
		jna	short dma_boundary_ok 
				; 1 sector read will not cause a boundary error			
		push	dx
		push	ax
		mov	ax, si
		sub	dx, dx
		; 24/12/2022
		mul	word [BytesPerSec]
		;mul	word [cs:BytesPerSec]
		; 23/12/2022
		; If di > 0 -> es = 1000h (or 2000h)
		;mov	bx, es
		;mov	cl, 4
		;shl	bx, cl ; convert paragraphs to bytes
		;; bx = segment start position (for 64K memory sections)
		;add	bx, ax ; byte count to read
		mov	bx, ax ; byte count to read
		pop	ax
		pop	dx
		add	bx, di ; add current buffer offset to byte count
		jnc	short dma_boundary_ok
		; Sector count must be decreased to prevent
		; DMA boundary error or segment override risk!
		dec	si
		jmp	short dma_boundary_chk
dma_boundary_ok:				
		;inc	dl			; Sector numbers are 1-based
		; 18/12/2022
		inc	dx
		mov	bl, dl			; Start sector in BL
		; 24/12/2022
		mov	dx, [TempH]		; DX:AX = Track
		;mov	dx, [cs:TempH]		; DX:AX = Track
		push	ax
		mov	ax, dx
		xor	dx, dx
		; 24/12/2022
		div	word [NumHeads]
		;div	word [cs:NumHeads]	; Start cyl in AX, head in dl
		;mov	[TempH], ax
		;;mov	[cs:TempH], ax
		pop	ax
		div	word [NumHeads]
		;div	word [cs:NumHeads]	; [TempH]:AX = Cylinder, DX = Head

			; At this moment, we assume that TempH = 0,
			; ax <= 1024, dx <= 255

		mov	dh, dl
		
		mov	cl, 6
		shl	ah, cl			; Shift cyl high bits up
		or	ah, bl			; Mix in with sector bits
		mov	ch, al			; Setup cyl low
		mov	cl, ah			; Setup cyl/high - sector
		mov	bx, di			; Get back OFFSET
		; 24/12/2022
		mov	dl, [BootDrive]		; Get drive
		;mov	dl, [cs:BootDrive]	; Get drive
		mov	ax, si			; Get number of sectors to read (al)
		mov	ah, 2			; Read sectors
		; 23/12/2022
		;push	ax
		;push	di

			; Issue one read request. ES:BX have the transfer address,
			; AL is the number of sectors.	

		int	13h		; DISK - READ SECTORS INTO MEMORY
					; AL = number of sectors to read, CH = track, CL = sector
					; DH = head, DL	= drive, ES:BX -> buffer to fill
					; Return: CF set on error, AH =	status,	AL = number of sectors read
		; 23/12/2022
		;pop	di
		;pop	ax

		; 23/12/2022
		mov	ah, 0
		
		pop	cx		; Get retry count back
		jnc	short ReadOk	; 23/12/2022
		
		; 23/12/2022
		;mov	bx, di		; Get offset
		; ah = 0
		;xor	ah, ah
		; 23/12/2022
		;push	cx
		; 24/12/2022
		;mov	dl, [BootDrive]
		;;mov	dl, [cs:BootDrive]
		; 23/12/2022
		;push	di
		int	13h		; DISK - RESET DISK SYSTEM
					; DL = drive (if bit 7 is set both hard	disks and floppy disks reset)
		; 23/12/2022
		;pop	di
		;pop	cx
		dec	cx
		jz	short ReadError
		jmp	TryRead
; ---------------------------------------------------------------------------

ReadError:				
		jmp	ErrorOut
; ---------------------------------------------------------------------------

ReadOk:
		; 23/12/2022			
		; ah = 0
		; 22/12/2022
		;xor	ah, ah		; Mask out read command, just get # read
		; ch = 0
		mov	cl, al

		; 22/12/2022
		; cx = ax = read (sector) count	
		;mov	bx, [cs:BytesPerSec]	; Bytes per sector
		;mul	bx			; Get total bytes read	
		; 24/12/2022
		; ds = cs
		mul	word [BytesPerSec]
		;mul	word [cs:BytesPerSec]
		add	di, ax			; Add it to OFFSET
		jnc	short read_next_sector
		mov	bx, es
		;add	bx, 1000h
		add	bh, 10h
		mov	es, bx
read_next_sector:
		; 24/12/2022
		; ds = cs
		; 22/12/2022
		sub	[SectorCount], cx
		;sub	[cs:SectorCount], cx
		;;sub	[cs:SectorCount], ax	; Bump number down
		jz	short EndRead
		add	[StartSecL], cx
		;add	[cs:StartSecL], cx
		;;add	[cs:StartSecL], ax	; Where to start next time
		adc	word [StartSecH], 0
		;adc	word [cs:StartSecH], 0
		jmp	ReadSectors
; ---------------------------------------------------------------------------
		
		; 24/12/2022
;EndRead:				
		;retn

; =============== S U B	R O U T	I N E =======================================

; GetNextFatEntry
; ---------------------------------------------------------------------------
;
; NOTES:
;
;   given the last cluster found, this will return the next cluster of
;   iosys. if the last cluster is (f)ff8 - (f)fff, then the final cluster
;   of iosys has been loaded, and control is passed to goto_iosys
;   msload can handle maximum fat area size of 128 kb.
;
; INPUT:
;
;    CS:CurrentCluster
;    CS:FatSize
;
; OUTPUT:
;
;   CS:CurrentCluster (updated)
;
; calls:  GetFatSector
; ---------------------------------------------------------------------------
; get CurrentCluster
;
; if (16 bit fat)
;    {if (CurrentCluster = fff8 - ffff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by multiply cluster by 2}
;
; else
;    {if (CurrentCluster = ff8 - fff)
;	 {jmp goto_iosys}
;     else
;	{get OFFSET by	- multiply cluster by 3
;
;	 rotate right to divide by 2
;
;	 if (cy set - means odd number)
;	    {shr 4 times to keep high twelve bits}
;
;	 else
;	    {and with 0fffh to keep low 12 bits}
;	}
;    }
;
; ---------------------------------------------------------------------------

; 09/12/2022
; FAT_12_BIT equ 1
; NOT_END_OF_FILE equ 0  ; ~END_OF_FILE ; END_OF_FILE equ 0FFh

GetNextFatEntry:			
		push	es
		; 24/12/2022
		mov	ax, FATSEGMENT	; FATBUFSEGM
		;mov	ax, [cs:FatSegment]
		mov	es, ax		; ES-> FAT area segment
		; 09/12/2022
		;;mov	byte [cs:EndOfFile], END_OF_FILE
		;mov	byte [cs:EndOfFile], 0FFh ; Assume last cluster
		;mov	ax, [cs:CurrentCluster] ; Get last cluster
		; 24/12/2022
		; ds = cs
		mov	byte [EndOfFile], 0FFh ; Assume last cluster
		mov	ax, [CurrentCluster] ; Get last cluster
		cmp	byte [Fatsize], 1
		;;cmp	byte [cs:FatSize], FAT_12_BIT
		;cmp	byte [cs:Fatsize], 1
		jne	short Got16Bit	; 23/12/2022
		mov	si, ax
		shr	ax, 1
		add	si, ax		; SI = AX * 1.5 = AX + AX/2
		; 23/12/2022
		;push	dx
		;xor	dx, dx
		sub	dx, dx ; 23/12/2022
		call	GetFatSector
		; 23/12/2022
		;pop	dx
		jnz	short ClusterOk
		mov	al, [es:bx]
		; 22/12/2022
		;mov	[cs:TempCluster], al
		;push	ax ; (*)
		inc	si
		; 23/12/2022
		;push	dx
		xor	dx, dx
		call	GetFatSector	; Read next fat sector
		; 23/12/2022
		;pop	dx
		; 22/12/2022
		;mov	al, [es:0]
		;mov	[cs:TempCluster+1], al
		;mov	ax, [cs:TempCluster]
		; 22/12/2022
		;pop	ax ; (*) 
		mov	ah, [es:0]
		jmp	short EvenOdd
; ---------------------------------------------------------------------------

ClusterOk:				
		mov	ax, [es:bx]
EvenOdd:	
		; 24/12/2022
		; ds = cs
		test	byte [CurrentCluster], 1
		; 10/12/2022		
		;test	byte [cs:CurrentCluster], 1 ; 09/12/2022
		;;test	word [cs:CurrentCluster], 1 ; Was last cluster odd?
		jnz	short OddResult		; If not zero it was odd
		and	ax, 0FFFh		; Keep low 12 bits
		jmp	short TestEOF
; ---------------------------------------------------------------------------

OddResult:				
		mov	cl, 4			; Keep high 12 bits for odd
		shr	ax, cl
TestEOF:				
		cmp	ax, 0FF8h		; Is it last cluster?
		jnb	short GotClusterDone	; Yep, all done here
		jmp	short NotLastCluster
; ---------------------------------------------------------------------------

Got16Bit:
		; 23/12/2022				
		;push	dx
		;xor	dx, dx
		sub	dx, dx ; 23/12/2022
		shl	ax, 1			; Multiply cluster by 2
		adc	dx, 0
		mov	si, ax			; Get the final buffer OFFSET
		call	GetFatSector
		; 23/12/2022
		;pop	dx
		mov	ax, [es:bx]
		cmp	ax, 0FFF8h
		jnb	short GotClusterDone
NotLastCluster:	
		; 24/12/2022
		; ds = cs			
		;;mov	byte [cs:EndOfFile], NOT_END_OF_FILE ; ~END_OF_FILE
		;mov	byte [cs:EndOfFile], 0	; Assume not last cluster
		mov	byte [EndOfFile], 0	; Assume not last cluster
GotClusterDone:				
		pop	es
		; 24/12/2022
EndRead:
		retn

; =============== S U B	R O U T	I N E =======================================

; GetFatSector
; ---------------------------------------------------------------------------
;function: find and read the corresponding fat sector into ES:0
;
;in). SI = offset value (starting from fat entry 0) of fat entry to find.
;     ES = fat sector segment
;     CS:BytesPerSec
;
;out). corresponding fat sector read in.
;      BX = offset value of the corresponding fat entry in the fat sector.
;      CX destroyed.
;      zero flag set if the fat entry is splitted, i.e. when 12 bit fat entry
;      starts at the last byte of the fat sector. in this case, the caller
;      should save this byte, and read the next fat sector to get the rest
;      of the fat entry value. (this will only happen with the 12 bit fat).
;
; ---------------------------------------------------------------------------

		; 24/12/2022
		; 22/12/2022
GetFatSector:				
		push	ax
		push	si
		push	di
		mov	ax, si
		; 24/12/2022
		; ds = cs
		;mov	cx, [cs:BytesPerSec]
		;div	cx			; AX = Sector number, DX = Offset
		div	word [BytesPerSec]
		cmp	ax, [LastFatSector]
		;cmp	ax, [cs:LastFatSector]	; The same fat sector?
		je	short SplitChk		; Don't need to read it again.
		mov	[LastFatSector], ax
		;mov	[cs:LastFatSector], ax
		push	dx
		; 24/12/2022
		xor	dx, dx
		;add	ax, [cs:HiddenSectorsL]
		;adc	dx, [cs:HiddenSectorsH]
		;add	ax, [cs:ReservSectors]
		;adc	dx, 0
		; 24/12/2022
		; ds = cs
		add	ax, [FatStartSecL]
		adc	dx, [FatStartSecH]
		mov	[StartSecL], ax
		mov	[StartSecH], dx		; Set up for ReadSectors
		;mov	[cs:StartSecL], ax
		;mov	[cs:StartSecH], dx	; Set up for ReadSectors
		
		mov	word [SectorCount], 1 ; 1 sector			
		;mov	word [cs:SectorCount], 1 ; 1 sector
		xor	di, di ; 0
		; es:di = FATSEGMENT:0000h
		call	ReadSectors
		pop	dx
		; 24/12/2022
		;mov	cx, [cs:BytesPerSec]
SplitChk:
		; 24/12/2022
		mov	cx, [BytesPerSec]				
		dec	cx			; CX = SECTOR SIZE - 1
		cmp	dx, cx			; If last byte of sector, splitted entry.
		mov	bx, dx			; set bx to dx
		pop	di
		pop	si
		pop	ax
EndWrite:		; 10/12/2022
		retn

; ---------------------------------------------------------------------------

ErrorOut:	
		; 24/12/2022
		; ds = cs		
		;push	cs
		;pop	ds
		mov	si, NonSystemDiskMsg ; "\r\nNon-System disk or disk error\r\nRe"...
		call	WriteTTY

		; Wait for a keypress on the keyboard.
		; Use the bios keyboard interrupt.

		xor	ah, ah
		int	16h		; KEYBOARD - READ CHAR FROM BUFFER, WAIT IF EMPTY
					; Return: AH = scan code, AL = character

		; We have to restore the address of the original rom disk
		; parameter table to the location at [0:DskAddr]. The address
		; of this original table has been saved previously in
		; 0:OrgDasdPtr and 0:OrgDasdPtr+2. After this table address
		; has been restored we can reboot by invoking the bootstrap
		; loader bios interrupt.

		; 23/12/2022
		;xor	bx, bx
		;mov	ds, bx
		;les	bx, [OrgDasdPtr] ; Wrong DS segment !
					 ; (Erdogan Tan, 23/12/2022)
		les	bx, [OrgDasdPtr] ; Correct DS segment = CS
		
		; 23/12/2022
		push	ss ; 0
		pop	ds
		; ds = 0		

		mov	si, DskAddr	; (Int 1Eh)
		mov	[si], bx	; restore offset		
		mov	[si+2], es	; restore segment

		int	19h		; reboot

; =============== S U B	R O U T	I N E =======================================

; WriteTTY
; ---------------------------------------------------------------------------
; in) DS:si -> asciiz string.
;
; WriteTTY the character in al to the screen.
; use video service 'write teletype to active page' (ROM_TTY)
; use normal character attribute
; ---------------------------------------------------------------------------

WriteTTY:				
		lodsb
		or	al, al
		jz	short EndWrite
		;mov	AH, ROM_TTY	; 09/12/2022
		mov	ah, 0Eh
		mov	bl, 7		; "normal" attribute
		int	10h		; - VIDEO - WRITE CHARACTER AND	ADVANCE	CURSOR (TTY WRITE)
					; AL = character, BH = display page (alpha modes)
					; BL = foreground color	(graphics modes)
		jmp	short WriteTTY
; ---------------------------------------------------------------------------

; 10/12/2022	
;EndWrite:				
;		retn

; ---------------------------------------------------------------------------

; 09/12/2022
;include msbio.cl1

		; 22/12/2022
		; 20/12/2022
		; 18/12/2022
		db 0	; (word alignment)
NonSystemDiskMsg:
		db 0Dh,0Ah
		db 'Non-System disk or disk error',0Dh,0Ah
		db 'Replace and press any key when ready',0Dh,0Ah,0
;EndOfLoader:
		; 22/12/2022
		dw 01A1h	; 10/12/2022

; ---------------------------------------------------------------------------

; 23/12/2022
		db 0
loading_msg:	db 0Dh, 0Ah
		db 'Loading Kernel MSDOS.SYS ... '
; 24/12/2022
		db 0
ok_msg:		db 'OK. '
crlf:
		db 0Dh, 0Ah, 0

; ---------------------------------------------------------------------------

; 22/12/2022
; (set file size to 1536 bytes)

SignatureSize equ EndOfLoader - signature

FillingSpace equ ($-START$)+SignatureSize

times		1536-FillingSpace db 0FFh ; db 90h

signature:	db 0
		db 0Dh, 0Ah
		db 'Retro DOS v4 Kernel Loader (Fake IO.SYS) '
		db 0Dh,0Ah
		db 'by Erdogan Tan [2022]'
		db  0Dh, 0Ah, 0
EndOfLoader: