     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update:  06/08/2024 (v5.0 - 2024 optimization)
     5                                  ;		15/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.15 (2.11)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    18                                  ; ----------------------------------------------------------------------------
    19                                  ;; 11/09/2018 - Erdogan Tan
    20                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    21                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    22                                  ; ----------------------------------------------------------------------------
    23                                  ; MSDOS 6.0 source files:
    24                                  ;;============================================================================
    25                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    26                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    27                                  ;;============================================================================
    28                                  ;
    29                                  ; COMMAND.COM v6.0 source files:
    30                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    31                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    32                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    33                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    34                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    35                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    36                                  ;
    37                                  ; COMMAND.COM v2.11 source files:
    38                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    39                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    40                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    41                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    42                                  ;
    43                                  ; ----------------------------------------------------------------------------
    44                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    45                                  
    46                                  ;============================================================================
    47                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    48                                  ;============================================================================
    49                                  ; 21/09/2018 - Retro DOS v3.0
    50                                  
    51                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    52                                  ;BREAK <system call definitions>
    53                                  
    54                                  ;
    55                                  ;	Microsoft Confidential
    56                                  ;	Copyright (C) Microsoft Corporation 1991
    57                                  ;	All Rights Reserved.
    58                                  ;
    59                                  
    60                                  ;SUBTTL	system call definitions
    61                                  ;PAGE
    62                                  
    63                                  Abort				EQU 0	;  0	  0
    64                                  STD_CON_INPUT			EQU 1	;  1	  1
    65                                  Std_Con_Output			EQU 2	;  2	  2
    66                                  Std_Aux_Input			EQU 3	;  3	  3
    67                                  Std_Aux_Output			EQU 4	;  4	  4
    68                                  Std_Printer_Output		EQU 5	;  5	  5
    69                                  Raw_Con_IO			EQU 6	;  6	  6
    70                                  RAW_CON_INPUT			EQU 7	;  7	  7
    71                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    72                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    73                                  Std_Con_String_Input		EQU 10	; 10	  A
    74                                  Std_Con_Input_Status		EQU 11	; 11	  B
    75                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    76                                  DISK_RESET			EQU 13	; 13	  D
    77                                  Set_Default_Drive		EQU 14	; 14	  E
    78                                  FCB_Open			EQU 15	; 15	  F
    79                                  FCB_Close			EQU 16	; 16	 10
    80                                  Dir_Search_First		EQU 17	; 17	 11
    81                                  Dir_Search_Next 		EQU 18	; 18	 12
    82                                  FCB_Delete			EQU 19	; 19	 13
    83                                  FCB_Seq_Read			EQU 20	; 20	 14
    84                                  FCB_Seq_Write			EQU 21	; 21	 15
    85                                  FCB_Create			EQU 22	; 22	 16
    86                                  FCB_Rename			EQU 23	; 23	 17
    87                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    88                                  Set_DMA 			EQU 26	; 26	 1A
    89                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    90                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    91                                  ;									   ;
    92                                  Get_Default_DPB 		EQU 31	; 31	 1F
    93                                  ;									   ;
    94                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    95                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    96                                  FCB_Random_Read 		EQU 33	; 33	 21
    97                                  FCB_Random_Write		EQU 34	; 34	 22
    98                                  Get_FCB_File_Length		EQU 35	; 35	 23
    99                                  Get_FCB_Position		EQU 36	; 36	 24
   100                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   101                                  Create_Process_Data_Block	EQU 38	; 38	 26
   102                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   103                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   104                                  Parse_File_Descriptor		EQU 41	; 41	 29
   105                                  Get_Date			EQU 42	; 42	 2A
   106                                  Set_Date			EQU 43	; 43	 2B
   107                                  Get_Time			EQU 44	; 44	 2C
   108                                  Set_Time			EQU 45	; 45	 2D
   109                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   110                                  ; Extended functionality group
   111                                  Get_DMA 			EQU 47	; 47	 2F
   112                                  GET_VERSION			EQU 48	; 48	 30
   113                                  Keep_Process			EQU 49	; 49	 31
   114                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   115                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   116                                  ;									   ;
   117                                  Get_DPB 			EQU 50	; 50	 32
   118                                  ;									   ;
   119                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   120                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   121                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   122                                  Get_InDOS_Flag			EQU 52	; 52	 34
   123                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   124                                  Get_Drive_Freespace		EQU 54	; 54	 36
   125                                  CHAR_OPER			EQU 55	; 55	 37
   126                                  International			EQU 56	; 56	 38
   127                                  ;   Directory Group
   128                                  MKDir				EQU 57	; 57	 39
   129                                  RMDir				EQU 58	; 58	 3A
   130                                  CHDir				EQU 59	; 59	 3B
   131                                  ;   File Group
   132                                  Creat				EQU 60	; 60	 3C
   133                                  OPEN				EQU 61	; 61	 3D
   134                                  CLOSE				EQU 62	; 62	 3E
   135                                  READ				EQU 63	; 63	 3F
   136                                  Write				EQU 64	; 64	 40
   137                                  Unlink				EQU 65	; 65	 41
   138                                  LSEEK				EQU 66	; 66	 42
   139                                  CHMod				EQU 67	; 67	 43
   140                                  IOCTL				EQU 68	; 68	 44
   141                                  XDUP				EQU 69	; 69	 45
   142                                  XDup2				EQU 70	; 70	 46
   143                                  Current_Dir			EQU 71	; 71	 47
   144                                  ;    Memory Group
   145                                  ALLOC				EQU 72	; 72	 48
   146                                  DEALLOC				EQU 73	; 73	 49
   147                                  SETBLOCK			EQU 74	; 74	 4A
   148                                  ;    Process Group
   149                                  Exec				EQU 75	; 75	 4B
   150                                  EXIT				EQU 76	; 76	 4C
   151                                  WAITPROCESS			EQU 77	; 77	 4D
   152                                  Find_First			EQU 78	; 78	 4E
   153                                  ;   Special Group
   154                                  Find_Next			EQU 79	; 79	 4F
   155                                  ; SPECIAL SYSTEM GROUP
   156                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   157                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   158                                  ;									   ;
   159                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   160                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   161                                  Get_In_Vars			EQU 82	; 82	 52
   162                                  SetDPB				EQU 83	; 83	 53
   163                                  ;									   ;
   164                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   165                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   166                                  Get_Verify_On_Write		EQU 84	; 84	 54
   167                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   168                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   169                                  ;									   ;
   170                                  Dup_PDB 			EQU 85	; 85	 55
   171                                  ;									   ;
   172                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   173                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   174                                  Rename				EQU 86	; 86	 56
   175                                  File_Times			EQU 87	; 87	 57
   176                                  AllocOper			EQU 88	; 88	 58
   177                                  ; Network extention system calls
   178                                  GetExtendedError		EQU 89	; 89	 59
   179                                  CreateTempFile			EQU 90	; 90	 5A
   180                                  CreateNewFile			EQU 91	; 91	 5B
   181                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   182                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   183                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   184                                  ;									   ;
   185                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   186                                  					;	    CloseByName, CloseUser,
   187                                  					;	    CloseUserProcess,
   188                                  					;	    GetOpenFileList
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  UserOper			EQU 94	; 94	 5E Get and Set
   193                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   194                                  xNameTrans			EQU 96	; 96	 60
   195                                  PathParse			EQU 97	; 97	 61
   196                                  GetCurrentPSP			EQU 98	; 98	 62
   197                                  Hongeul 			EQU 99	; 99	 63
   198                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   199                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   200                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   201                                  ;									   ;
   202                                  Set_Printer_Flag		EQU 100 ; 100	 64
   203                                  ;									   ;
   204                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   205                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   206                                  GetExtCntry			EQU 101 ; 101	 65
   207                                  GetSetCdPg			EQU 102 ; 102	 66
   208                                  ExtHandle			EQU 103 ; 103	 67
   209                                  Commit				EQU 104 ; 104	 68
   210                                  GetSetMediaID			EQU 105 ; 105	 69
   211                                  IFS_IOCTL			EQU 107 ; 107	 6B
   212                                  ExtOpen 			EQU 108 ; 108	 6C
   213                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   214                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   215                                  ;                                                                          ;
   216                                  ;ifdef ROMEXEC
   217                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   218                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   219                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   220                                  ;endif
   221                                  ;                                                                          ;
   222                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  ;
   225                                  ;
   226                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   227                                  OEM_C1				EQU 249 ; 249	 F9
   228                                  OEM_C2				EQU 250 ; 250	 FA
   229                                  OEM_C3				EQU 251 ; 251	 FB
   230                                  OEM_C4				EQU 252 ; 252	 FC
   231                                  OEM_C5				EQU 253 ; 253	 FD
   232                                  OEM_C6				EQU 254 ; 254	 FE
   233                                  OEM_C7				EQU 255 ; 255	 FF
   234                                  
   235                                  ;============================================================================
   236                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   237                                  ;============================================================================
   238                                  ; 21/09/2018 - Retro DOS v3.0
   239                                  
   240                                  ;BREAK <Control character definitions>
   241                                  
   242                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   243                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   244                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   245                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   246                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   247                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   248                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   249                                  c_HT	    EQU     09h 	; ^I ASCII tab
   250                                  
   251                                  ;============================================================================
   252                                  ; DIRENT.INC, MSDOS 6.0, 1991
   253                                  ;============================================================================
   254                                  ; 21/09/2018 - Retro DOS v3.0
   255                                  
   256                                  ;Break <Directory entry>
   257                                  
   258                                  ;	NOTE:  These offsets are also used in the DTA for
   259                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   260                                  ;	with the FCB filename field, and the rest of the
   261                                  ;	DIR_ENTRY fields follow. -DavidOls
   262                                  
   263                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   264                                  ;
   265                                  ;	+---------------------------+
   266                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   267                                  ;	+---------------------------+
   268                                  ;	|     (BYTE) attributes     |	    11	    B
   269                                  ;	+---------------------------+
   270                                  ;	|    (10 BYTE) reserved     |	    12	    C
   271                                  ;	+---------------------------+
   272                                  ;	| (WORD) time of last write |	    22	    16
   273                                  ;	+---------------------------+
   274                                  ;	| (WORD) date of last write |	    24	    18
   275                                  ;	+---------------------------+
   276                                  ;	|   (WORD) First cluster    |	    26	    1A
   277                                  ;	+---------------------------+
   278                                  ;	|     (DWORD) file size     |	    28	    1C
   279                                  ;	+---------------------------+
   280                                  ;
   281                                  ;   First byte of filename  = E5 -> free directory entry
   282                                  ;			    = 00 -> end of allocated directory
   283                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   284                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   285                                  ;
   286                                  
   287                                  STRUC DIR_ENTRY
   288 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   289 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   290 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   291 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   292 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   293 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   294 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   295 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   296 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   297 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   298 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   299                                  .size:
   300                                  
   301                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   302                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   303                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   304                                  ;	    this field is zero for subdirectory files.
   305                                  
   306                                  ENDSTRUC
   307                                  
   308                                  ATTR_READ_ONLY	equ	 1h
   309                                  ATTR_HIDDEN	equ	 2h
   310                                  ATTR_SYSTEM	equ	 4h
   311                                  ATTR_VOLUME_ID	equ	 8h
   312                                  ATTR_DIRECTORY	equ	10h
   313                                  ATTR_ARCHIVE	equ	20h
   314                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   315                                  				;   NO directory entry on a disk EVER
   316                                  				;   has this bit set. It is set non-zero
   317                                  				;   when a device is found by GETPATH
   318                                  
   319                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   320                                  				; OR of hard attributes for FINDENTRY
   321                                  
   322                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   323                                  				; ignore this(ese) attribute(s) during
   324                                  				; search first/next
   325                                  
   326                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   327                                  				; changeable via CHMOD
   328                                  
   329                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   330                                  
   331                                  ;============================================================================
   332                                  ; ERROR.INC, MSDOS 6.0, 1991
   333                                  ;============================================================================
   334                                  ; 21/09/2018 - Retro DOS v3.0
   335                                  
   336                                  ;**	ERROR.INC - DOS Error Codes
   337                                  ;
   338                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   339                                  ;    return error codes through AX.	If an error occurred then
   340                                  ;    the carry bit will be set and the error code is in AX.	If no error
   341                                  ;    occurred then the carry bit is reset and AX contains returned info.
   342                                  ;
   343                                  ;    Since the set of error codes is being extended as we extend the operating
   344                                  ;    system, we have provided a means for applications to ask the system for a
   345                                  ;    recommended course of action when they receive an error.
   346                                  ;
   347                                  ;    The GetExtendedError system call returns a universal error, an error
   348                                  ;    location and a recommended course of action.	The universal error code is
   349                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   350                                  ;    is issued.
   351                                  
   352                                  
   353                                  ;	2.0 error codes
   354                                  
   355                                  error_invalid_function		EQU	1
   356                                  ERROR_FILE_NOT_FOUND		EQU	2
   357                                  ERROR_PATH_NOT_FOUND		EQU	3
   358                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   359                                  ERROR_ACCESS_DENIED		EQU	5
   360                                  error_invalid_handle		EQU	6
   361                                  error_arena_trashed		EQU	7
   362                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   363                                  error_invalid_block		EQU	9
   364                                  error_bad_environment		EQU	10
   365                                  ERROR_BAD_FORMAT		EQU	11
   366                                  error_invalid_access		EQU	12
   367                                  ERROR_INVALID_DATA		EQU	13
   368                                  ;**** reserved			EQU	14	; *****
   369                                  error_invalid_drive		EQU	15
   370                                  error_current_directory 	EQU	16
   371                                  error_not_same_device		EQU	17
   372                                  ERROR_NO_MORE_FILES		EQU	18
   373                                  
   374                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   375                                  
   376                                  ERROR_WRITE_PROTECT		EQU	19
   377                                  error_bad_unit			EQU	20
   378                                  error_not_ready 		EQU	21
   379                                  error_bad_command		EQU	22
   380                                  error_CRC			EQU	23
   381                                  error_bad_length		EQU	24
   382                                  error_Seek			EQU	25
   383                                  error_not_DOS_disk		EQU	26
   384                                  error_sector_not_found		EQU	27
   385                                  error_out_of_paper		EQU	28
   386                                  error_write_fault		EQU	29
   387                                  error_read_fault		EQU	30
   388                                  ERROR_GEN_FAILURE		EQU	31
   389                                  
   390                                  ;	the new 3.0 error codes reported through INT 24
   391                                  
   392                                  error_sharing_violation 	EQU	32
   393                                  error_lock_violation		EQU	33
   394                                  error_wrong_disk		EQU	34
   395                                  ERROR_FCB_UNAVAILABLE		EQU	35
   396                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   397                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   398                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   399                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   400                                  
   401                                  ;	New OEM network-related errors are 50-79
   402                                  
   403                                  error_not_supported		EQU	50
   404                                  
   405                                  error_net_access_denied		EQU	65	;M028
   406                                  
   407                                  ;	End of INT 24 reportable errors
   408                                  
   409                                  error_file_exists		EQU	80
   410                                  error_DUP_FCB			EQU	81	; *****
   411                                  error_cannot_make		EQU	82
   412                                  error_FAIL_I24			EQU	83
   413                                  
   414                                  ;	New 3.0 network related error codes
   415                                  
   416                                  error_out_of_structures 	EQU	84
   417                                  error_Already_assigned		EQU	85
   418                                  error_invalid_password		EQU	86
   419                                  error_invalid_parameter 	EQU	87
   420                                  error_NET_write_fault		EQU	88
   421                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   422                                  
   423                                  ;============================================================================
   424                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   425                                  ;============================================================================
   426                                  ; 22/09/2018 - Retro DOS v3.0
   427                                  
   428                                  ;**	DevSym.inc - Device Symbols
   429                                  
   430                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   431                                  
   432                                  STRUC SYSDEV
   433 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   434 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   435 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   436 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   437 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   438                                  .size:
   439                                  ENDSTRUC
   440                                  
   441                                  ; 24/09/2018
   442                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   443                                  
   444                                  ;============================================================================
   445                                  ; CURDIR.INC, MSDOS 6.0, 1991
   446                                  ;============================================================================
   447                                  ; 21/09/2018 - Retro DOS v3.0
   448                                  
   449                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   450                                  
   451                                  ;============================================================================
   452                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   453                                  ;============================================================================
   454                                  ; 21/09/2018 - Retro DOS v3.0
   455                                  
   456                                  ;/*
   457                                  ; *                      Microsoft Confidential
   458                                  ; *                      Copyright (C) Microsoft Corporation 1991
   459                                  ; *                      All Rights Reserved.
   460                                  ; */
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   463                                  ;*************************************
   464                                  ; COMMAND EQUs which are not switch dependant
   465                                  
   466                                  ;		include	curdir.inc	; to get DIRSTRLEN
   467                                  ;		Note dossym.inc must already have been included!
   468                                  
   469                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   470                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   471                                  
   472                                  SYM		EQU	">"
   473                                  
   474                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   475                                  
   476                                  NORMPERLIN	EQU	1
   477                                  WIDEPERLIN	EQU	5
   478                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   479                                  BatLen		EQU	32		; buffer for batch files
   480                                  YES_ECHO	EQU	1		; echo line
   481                                  NO_ECHO 	EQU	0		; don't echo line
   482                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   483                                  call_in_progress EQU	1		; indicate we're in the CALL command
   484                                  length_call	EQU	4		; length of CALL
   485                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   486                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   487                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   488                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   489                                  nullcommand	EQU     1		; no command on command line
   490                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   491                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   492                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   493                                  result_number	EQU	1		;AN000; number returned from parser
   494                                  result_string	EQU	3		;AN000; string returned from parser
   495                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   496                                  result_drive	EQU	6		;AN000; drive returned from parser
   497                                  result_date	EQU	7		;AN000; date returned from parser
   498                                  result_time	EQU	8		;AN000; time returned from parser
   499                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   500                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   501                                  util_msg_class	EQU	-1		;AN000; message class for utility
   502                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   503                                  parse_msg_class EQU	2		;AN000; message class for parse error
   504                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   505                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   506                                  colon_char	EQU	":"             ;AN000; colon character
   507                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   508                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   509                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   510                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   511                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   512                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   513                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   514                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   515                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   516                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   517                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   518                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   519                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   520                                  parm_block_size equ	11		;AN000; size of message subst block
   521                                  blank		equ	" "             ;AN000; blank character
   522                                  no_subst	equ	0		;AN000; no substitutions for messages
   523                                  one_subst	equ	1		;AN000; one substitution for messages
   524                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   525                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   526                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   527                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   528                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   529                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   530                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   531                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   532                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   533                                  capital_A	equ	'A'             ;AC000;
   534                                  vbar		equ	'|'             ;AC000;
   535                                  labracket	equ	'<'             ;AC000;
   536                                  rabracket	equ	'>'             ;AC000;
   537                                  dollar		equ	'$'             ;AC000;
   538                                  lparen		equ	'('             ;AC000;
   539                                  rparen		equ	')'             ;AC000;
   540                                  nullrparen	equ	29h		;AC000;
   541                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   542                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   543                                  star		equ	'*'             ;AC000;
   544                                  plus_chr	equ	'+'             ;AC000;
   545                                  small_a 	equ	'a'             ;AC000;
   546                                  small_z 	equ	'z'             ;AC000;
   547                                  dot_chr 	equ	'.'             ;AC000;
   548                                  tab_chr 	equ	9		;AN032;
   549                                  equal_chr	equ	'='             ;AN032;
   550                                  semicolon	equ	';'             ;AN049;
   551                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   552                                  dot_colon	equ	2e3ah		;AC000; '.:'
   553                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   554                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   555                                  AppendInstall	equ	0B700H		;AN020; append install check
   556                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   557                                  AppendGetState	equ	0B706H		;AN020; append get current state
   558                                  AppendSetState	equ	0B707H		;AN020; append set current state
   559                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   560                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   561                                  
   562                                  ;*************************************
   563                                  ;* PARSE ERROR MESSAGES
   564                                  ;*************************************
   565                                  
   566                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   567                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   568                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   569                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   570                                  
   571                                  ;*************************************
   572                                  ;* EQUATES FOR MESSAGE RETRIEVER
   573                                  ;*************************************
   574                                  
   575                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   576                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   577                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   578                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   579                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   580                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   581                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   582                                  
   583                                  ;*********************************
   584                                  ;* EQUATES FOR INT 10H
   585                                  ;*********************************
   586                                  
   587                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   588                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   589                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   590                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   591                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   592                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   593                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   594                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   595                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   596                                  
   597                                  AltPipeChr	equ	"|"             ; alternate pipe character
   598                                  
   599                                  FCB		equ	5Ch
   600                                  
   601                                  STRUC VARSTRUC
   602 00000000 ??                      .ISDIR:		RESB	1
   603 00000001 ??                      .SIZ:		RESB	1
   604 00000002 ????                    .TTAIL:		RESW	1
   605 00000004 ??                      .INFO:		RESB	1
   606 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   607                                  .size:
   608                                  ENDSTRUC
   609                                  ;
   610                                  ; Flags for internal command parsing
   611                                  ;
   612                                  fCheckDrive	equ	00000001b	; validate drive letter
   613                                  fSwitchAllowed	equ	00000010b	; switches allowed
   614                                  fLimitHelp	equ	00000100b	; /? must appear alone
   615                                  
   616                                  ;
   617                                  ; Test switches
   618                                  ;
   619                                  fParse		EQU	0001h		; display results of parseline
   620                                  
   621                                  ;
   622                                  ; Batch segment structure
   623                                  ;
   624                                  ;   BYTE    type of segment
   625                                  ;   BYTE    echo state of parent on entry to batch file
   626                                  ;   WORD    segment of last batch file
   627                                  ;   WORD    segment for FOR command
   628                                  ;   BYTE    FOR flag state on entry to batch file
   629                                  ;   DWORD   offset for next line
   630                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   631                                  ;   ASCIZ   file name (with . and ..)
   632                                  ;   BYTES   CR-terminated parameters
   633                                  ;   BYTE    0 flag to indicate end of parameters
   634                                  ;
   635                                  
   636                                  BATCHTYPE   equ 0
   637                                  
   638                                  STRUC BATCHSEGMENT
   639 00000000 ??                      .BatType:	RESB	1		; signature
   640 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   641                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   642 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   643 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   644 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   645 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   646 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   647 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   648 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   649                                  .SIZE:
   650                                  ENDSTRUC
   651                                  
   652                                  ANULL		equ	0		; terminates an argv string
   653                                  ARGMAX		equ	64		; max args on a command line
   654                                  ;ARGBLEN 	equ	2*128		; 1char each plus term NUL
   655                                  ; 27/07/2024 - PCDOS 7.1 COMMAND.COM ;*
   656                                  ARGBLEN 	equ	2*64
   657                                  tplen		equ	64		; max size of one argument
   658                                  arg_cnt_error	equ	1		; number of args > MAXARG
   659                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   660                                  
   661                                  STRUC ARGV_ELE				; elements in the argv array
   662 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   663 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   664 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   665 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   666 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   667 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   668                                  .SIZE:	; 11 ; 27/07/2024
   669                                  ENDSTRUC
   670                                  
   671                                  STRUC ARG_UNIT
   672 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   673 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   674 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   675 000002C4 <res 100h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   676 000003C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   677                                  .SIZE:	; 1092 ; 27/07/2024 ; (it was 1348 in MSDOS 5.0-6.22 COMMAND.COM) ;*
   678                                  ENDSTRUC
   679                                  
   680                                  ; Equates for initialization
   681                                  ;
   682                                  INITINIT	equ	01h		; initialization in progress
   683                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   684                                  INITCTRLC	equ	04h		; already in ^C handler
   685                                  
   686                                  ;============================================================================
   687                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   688                                  ;============================================================================
   689                                  ; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   690                                  
   691                                  ; Current structure of the data returned by the international call
   692                                  
   693                                  struc INTERNAT_BLOCK
   694 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   695 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   696 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   697 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   698 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   699 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   700 0000000F ??                      .bit_field:	resb 1			; Bit values
   701                                  					;   Bit 0 = 0 if currency symbol first
   702                                  					;	  = 1 if currency symbol last
   703                                  					;   Bit 1 = 0 if No space after currency symbol
   704                                  					;	  = 1 if space after currency symbol
   705                                  .currency_cents:
   706 00000010 ??                      		resb 1			; Number of places after currency dec point
   707 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   708 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   709                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   710                                  					;  in pieces.
   711 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   712 00000017 ??                      		resb 1
   713                                  endstruc
   714                                  
   715                                  ; Max size of the block returned by the INTERNATIONAL call
   716                                  
   717                                  internat_block_max equ 32
   718                                  
   719                                  ;============================================================================
   720                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   721                                  ;============================================================================
   722                                  ; 13/10/2018 - Retro DOS v3.0
   723                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   724                                  
   725                                  ;Break	<find first/next buffer>
   726                                  
   727                                  	; MSDOS 3.3 & MSDOS 6.0
   728                                  
   729                                  struc FIND_BUF
   730 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   731 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   732 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   733 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   734 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   735 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   736 00000015 ??                      .ATTR:	    resb 1	; attribute found
   737 00000016 ????                    .TIMR:	    resw 1	; time
   738 00000018 ????                    .DATE:	    resw 1	; date
   739 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   740 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   741 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   742                                  .size:
   743                                  endstruc
   744                                  
   745                                  ;=============================================================================
   746                                  ; PDB.INC, MSDOS 6.0, 1991
   747                                  ;=============================================================================
   748                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   749                                  
   750                                  ;**	Process data block (otherwise known as program header)
   751                                  
   752                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   753                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   754                                  ;	for use.
   755                                  
   756                                  FILPERPROC	EQU     20
   757                                  
   758                                  struc PDB	; Process_data_block
   759 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   760 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   761 00000004 ??                                      resb 1
   762 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   763 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   764 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   765 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   766 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   767 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   768 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   769 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   770 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   771 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   772 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   773 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   774 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   775 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   776 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   777 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   778 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   779 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   780                                  				;  an extended FCB
   781                                  ;endstruc 	; MSDOS 3.3
   782                                  	  	; MSDOS 6.0
   783 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   784 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   785 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   786 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   787                                  endstruc
   788                                  
   789                                  ;=============================================================================
   790                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   791                                  ;=============================================================================
   792                                  ; 24/09/2018 - Retro DOS v3.0
   793                                  
   794                                  ;major_version	equ 6		; Major DOS version
   795                                  ;minor_version	equ 0		; Minor DOS Version
   796                                  
   797                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   798                                  
   799                                  ; MSDOS 3.3 COMMAND.COM
   800                                  ;MAJOR_VERSION	EQU 3
   801                                  ;MINOR_VERSION	EQU 30
   802                                  
   803                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   804                                  MAJOR_VERSION	EQU 5		; Major DOS version
   805                                  MINOR_VERSION	EQU 0		; Minor DOS version
   806                                  
   807                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   808                                  
   809                                  ;-----------------------------------------------------------------------------
   810                                  ; 21/09/2018
   811                                  ;-----------------------------------------------------------------------------
   812                                  ; Retro DOS v3.0 NOTE:  
   813                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   814                                  ;	with minor modifications which are done by me (Erdogan Tan).
   815                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   816                                  ;	source code files (written by using MASM syntax).
   817                                  ;-----------------------------------------------------------------------------
   818                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   819                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   820                                  ;----------------------------------------------------------------------------- 	
   821                                  
   822                                  ;=============================================================================
   823                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   824                                  ;=============================================================================
   825                                  ; 21/09/2018 - Retro DOS v3.0
   826                                  
   827                                  ;	page ,132
   828                                  ;	title	COMMAND - resident code for COMMAND.COM
   829                                  ;	name	COMMAND
   830                                  
   831                                  ;/*
   832                                  ; *                      Microsoft Confidential
   833                                  ; *                      Copyright (C) Microsoft Corporation 1991
   834                                  ; *                      All Rights Reserved.
   835                                  ; */
   836                                  
   837                                  ;*****************************************************************************
   838                                  ;
   839                                  ; MODULE:	       COMMAND.COM
   840                                  ;
   841                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   842                                  ;
   843                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   844                                  ;		       parts.  First is the resident portion, which includes
   845                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   846                                  ;		       error), and 2EH (command line execute); it also has
   847                                  ;		       code to test and, if necessary, reload the transient
   848                                  ;		       portion. Following the resident is the init code, which
   849                                  ;		       is overwritten after use.  Then comes the transient
   850                                  ;		       portion, which includes all command processing (whether
   851                                  ;		       internal or external).  The transient portion loads at
   852                                  ;		       the end of physical memory, and it may be overlayed by
   853                                  ;		       programs that need as much memory as possible. When the
   854                                  ;		       resident portion of command regains control from a user
   855                                  ;		       program, a check sum is performed on the transient
   856                                  ;		       portion to see if it must be reloaded.  Thus programs
   857                                  ;		       which do not need maximum memory will save the time
   858                                  ;		       required to reload COMMAND when they terminate.
   859                                  ;
   860                                  ; ENTRY POINT:	       PROGSTART
   861                                  ;
   862                                  ; INPUT:	       command line at offset 81H
   863                                  ;
   864                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   865                                  ;		       from a secondary command processor via the EXIT
   866                                  ;		       internal command.
   867                                  ;
   868                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   869                                  ;		       hang the system.
   870                                  ;
   871                                  ; INTERNAL REFERENCES:
   872                                  ;
   873                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   877                                  ;		       (COMMAND.DOC)
   878                                  ;
   879                                  ; EXTERNAL REFERENCES:
   880                                  ;
   881                                  ;      ROUTINES:       none
   882                                  ;
   883                                  ;      DATA AREAS:     none
   884                                  ;
   885                                  ;*****************************************************************************
   886                                  ;
   887                                  ;			      REVISION HISTORY
   888                                  ;			      ----------------
   889                                  ;
   890                                  ; DOS 1.00 to DOS 3.30
   891                                  ; --------------------------
   892                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   893                                  ;
   894                                  ; REV 1.17
   895                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   896                                  ;	       resident since the EXELOAD may have overwritten the transient.
   897                                  ;
   898                                  ; REV 1.18
   899                                  ;    05/21/82  IBM version always looks on drive A
   900                                  ;	       MSVER always looks on default drive
   901                                  ;
   902                                  ; REV 1.19
   903                                  ;    06/03/82  Drive spec now entered in command line
   904                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   905                                  ;	       (print volume label)
   906                                  ;
   907                                  ; REV 1.20
   908                                  ;    06/09/82  Prints "directory" after directories
   909                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   910                                  ;
   911                                  ; REV 1.50
   912                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   913                                  ;	       do it right.
   914                                  ;
   915                                  ; REV 1.70
   916                                  ;	       EXEC used to fork off new processes
   917                                  ;
   918                                  ; REV 1.80
   919                                  ;	       C switch for single command execution
   920                                  ;
   921                                  ; REV 1.90
   922                                  ;	       Batch uses XENIX
   923                                  ;
   924                                  ; Rev 2.00
   925                                  ;	       Lots of neato stuff
   926                                  ;	       IBM 2.00 level
   927                                  ;
   928                                  ; Rev 2.01
   929                                  ;	       'D' switch for date time suppression
   930                                  ;
   931                                  ; Rev 2.02
   932                                  ;	       Default userpath is NUL rather than BIN
   933                                  ;		       same as IBM
   934                                  ;	       COMMAND split into pieces
   935                                  ;
   936                                  ; Rev 2.10
   937                                  ;	       INTERNATIONAL SUPPORT
   938                                  ;
   939                                  ; Rev 2.50
   940                                  ;	       all the 2.x new stuff -MU
   941                                  ;
   942                                  ; Rev 3.30     (Ellen G)
   943                                  ;	       CALL internal command (TBATCH2.ASM)
   944                                  ;	       CHCP internal command (TCMD2B.ASM)
   945                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   946                                  ;	       @ sign suppression of batch file line
   947                                  ;	       Replaceable environment value support in batch files
   948                                  ;	       INT 2FH calls for APPEND
   949                                  ;	       Lots of PTR fixes!
   950                                  ;
   951                                  ; Beyond 3.30 to forever  (Ellen G)
   952                                  ; ----------------------
   953                                  ;
   954                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   955                                  ;			Use Message Retriever services
   956                                  ;			/MSG switch for resident extended error msg
   957                                  ;			Convert to new capitalization support
   958                                  ;			Better error recovery on CHCP command
   959                                  ;			Code page file tag support
   960                                  ;			TRUENAME internal command
   961                                  ;			Extended screen line support
   962                                  ;			/P switch on DEL/ERASE command
   963                                  ;			Improved file redirection error recovery
   964                                  ;	(removed)	Improved batch file performance
   965                                  ;			Unconditional DBCS support
   966                                  ;			Volume serial number support
   967                                  ;	(removed)	COMMENT=?? support
   968                                  ;
   969                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   970                                  ;
   971                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   972                                  ;			require delimiters.
   973                                  ;
   974                                  ; A003	PTM P5,P9,P111	Included in A000 development
   975                                  ;
   976                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   977                                  ;			executing
   978                                  ;
   979                                  ; A005	DCR D17 	If user specifies an extension on the command
   980                                  ;			line search for that extension only.
   981                                  ;
   982                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   983                                  ;			exists"
   984                                  ;
   985                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   986                                  ;
   987                                  ; A008	PTM P182	Change COPY to set default if invalid function
   988                                  ;			returned from code page call.
   989                                  ;
   990                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   991                                  ;
   992                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   993                                  ;			transient COMMAND.
   994                                  ;
   995                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   996                                  ;			before appending to a file.
   997                                  ;
   998                                  ; A012	PTM P189	Fix redirection error recovery.
   999                                  ;
  1000                                  ; A013	PTM P330	Change date format
  1001                                  ;
  1002                                  ; A014	PTM P455	Fix echo parsing
  1003                                  ;
  1004                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1005                                  ;
  1006                                  ; A016	PTM P354	Fix extended error message addressing
  1007                                  ;
  1008                                  ; A017	PTM P448	Fix appending to 0 length files
  1009                                  ;
  1010                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1011                                  ;			the parser fails on. Fail on duplicate switches.
  1012                                  ;
  1013                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1014                                  ;			critical error
  1015                                  ;
  1016                                  ; A020	DCR D43 	Set append state off while in DIR
  1017                                  ;
  1018                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1019                                  ;
  1020                                  ; A022	DCR D209	Enhanced error recovery
  1021                                  ;
  1022                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1023                                  ;
  1024                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1025                                  ;
  1026                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1027                                  ;
  1028                                  ; A026	DCR D191	Change redirection error recovery support.
  1029                                  ;
  1030                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1031                                  ;			with a carriage return.
  1032                                  ;
  1033                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1034                                  ;			date and invalid time messages.
  1035                                  ;
  1036                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1037                                  ;			and TIME.
  1038                                  ;
  1039                                  ; A030	DCR D201	New extended attribute format.
  1040                                  ;
  1041                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1042                                  ;
  1043                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1044                                  ;
  1045                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1046                                  ;
  1047                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1048                                  ;
  1049                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1050                                  ;			do a read to determine eof.
  1051                                  ;
  1052                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1053                                  ;			so that ASSIGN works correctly.
  1054                                  ;
  1055                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1056                                  ;
  1057                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1058                                  ;
  1059                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1060                                  ;
  1061                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1062                                  ;			specified.
  1063                                  ;
  1064                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1065                                  ;			executes.
  1066                                  ;
  1067                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1068                                  ;			files causing loss of batch file.
  1069                                  ;
  1070                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1071                                  ;			CALL'ed batch files.
  1072                                  ;
  1073                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1074                                  ;			as an end of line character
  1075                                  ;
  1076                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1077                                  ;			and extended message pointers when we EXIT if
  1078                                  ;			COMMAND /P is the top level process.
  1079                                  ;
  1080                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1081                                  ;			"File not found - fn"
  1082                                  ;
  1083                                  ; A047	PTM P2819	Fix transient reload prompt message
  1084                                  ;
  1085                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1086                                  ;			when DBCS code was added.
  1087                                  ;
  1088                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1089                                  ;			on line.
  1090                                  ;
  1091                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1092                                  ;
  1093                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1094                                  ;
  1095                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1096                                  ;
  1097                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1098                                  ;
  1099                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1100                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1101                                  ;
  1102                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1103                                  ;			problems with breaking out of INT 24h
  1104                                  ;
  1105                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1106                                  ;
  1107                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1108                                  ;			before the "string".  EX: COMMAND /CDIR
  1109                                  ;
  1110                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1111                                  ;			DBCS switch.
  1112                                  ;
  1113                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1114                                  ;			the time.
  1115                                  ;
  1116                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1117                                  ;			messages to be disk based.  Only keep them if /MSG
  1118                                  ;			is used.
  1119                                  ;
  1120                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1121                                  ;			out of internal commands, due to substitution blocks
  1122                                  ;			not being reset.
  1123                                  ;
  1124                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1125                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1126                                  ;			secondary copy of environment.	Change default slash in
  1127                                  ;			default comspec string to backslash.
  1128                                  ;
  1129                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1130                                  ;			text for critical error messages.
  1131                                  ;
  1132                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1133                                  ;	5/20/88 	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1136                                  ;	 5/20/88	with Microsoft product already shipped.
  1137                                  ;
  1138                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1139                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1140                                  ;			header and space remaining.
  1141                                  ;
  1142                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1143                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1144                                  ;			environment was putting a "Z block" marker in the old
  1145                                  ;			environment.  The fix is to move to the old environment
  1146                                  ;			to the new environment before doing the SETBLOCK.
  1147                                  ;
  1148                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1149                                  ;        09/19/88       because the check for APPEND needed to be performed
  1150                                  ;                       before the DIR's findfirst.
  1151                                  ;
  1152                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1153                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1154                                  ;                       loading trans w/new comspec with no user change comspec.
  1155                                  ;
  1156                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1157                                  ;        11/05/88       Expansion of environment variables into batch line of
  1158                                  ;                       128 chars was not being counted and "%" which should be
  1159                                  ;                       ignored were being counted.
  1160                                  ;
  1161                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1162                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1163                                  ;                       ing included in checksum and was being overwritten by
  1164                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1165                                  ;                       Also removed fix A069 (because flag now protected).
  1166                                  ;
  1167                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1168                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1169                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1170                                  ;
  1171                                  ;***********************************************************************************
  1172                                  
  1173                                  ;
  1174                                  ;	Revision History
  1175                                  ;	================
  1176                                  ;
  1177                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1178                                  ;					at init time (date/time prompt)
  1179                                  ;
  1180                                  
  1181                                  ;
  1182                                  ;.xcref
  1183                                  ;.xlist
  1184                                  ;	include dossym.inc		; basic DOS symbol set
  1185                                  ;	include syscall.inc		; DOS function names
  1186                                  ;	include comsw.asm		; build version info
  1187                                  ;	include comequ.asm		; common command.com symbols
  1188                                  ;	include resmsg.equ		; resident message names
  1189                                  ;
  1190                                  ;	include comseg.asm		;segment ordering
  1191                                  ;.list
  1192                                  ;.cref
  1193                                  
  1194                                  ;CODERES segment public byte
  1195                                  ;CODERES ends
  1196                                  ;
  1197                                  ;DATARES 	segment public byte
  1198                                  ;		extrn	AccDen:byte
  1199                                  ;		extrn	Batch:word
  1200                                  ;		extrn	EchoFlag:byte
  1201                                  ;		extrn	ExeBad:byte
  1202                                  ;		extrn	ExecEMes:byte
  1203                                  ;		extrn	ExecErrSubst:byte
  1204                                  ;		extrn	ExtCom:byte
  1205                                  ;		extrn	ForFlag:byte
  1206                                  ;		extrn	IfFlag:byte
  1207                                  ;		extrn	InitFlag:BYTE
  1208                                  ;		extrn	Nest:word
  1209                                  ;		extrn	PipeFlag:byte
  1210                                  ;		extrn	RBadNam:byte
  1211                                  ;		extrn	RetCode:word
  1212                                  ;		extrn	SingleCom:word
  1213                                  ;		extrn	TooBig:byte
  1214                                  ;
  1215                                  ;		extrn	OldDS:word
  1216                                  ;
  1217                                  ;DATARES 	ends
  1218                                  ;
  1219                                  ;
  1220                                  ;INIT		segment public para
  1221                                  ;		extrn	ConProc:near
  1222                                  ;		extrn	Init_Contc_SpecialCase:near
  1223                                  ;INIT		ends
  1224                                  
  1225                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1226                                  ; --------------------------------------
  1227                                  ; 'command5.s' source code reference(s):
  1228                                  
  1229                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1230                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1231                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1232                                  ; ----------------------------------------------------------------------				 	 	
  1233                                  
  1234                                  ; ----------------------------------------------------------------------------
  1235                                  ; START OF RESIDENT PORTION
  1236                                  ; ----------------------------------------------------------------------------
  1237                                  ; SEGMENT - DATARES
  1238                                  ; ----------------------------------------------------------------------------
  1239                                  
  1240                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1241                                  
  1242                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1243                                  
  1244                                  ; ----------------------------------------------------------------------------
  1245                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1246                                  ; ----------------------------------------------------------------------------
  1247                                  
  1248                                  ;This file contains the low memory stub for command.com which hooks all the
  1249                                  ;entry points into the resident command.com and directs the calls to the
  1250                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1251                                  ;
  1252                                  ;The stub has been made part of the resident data and will always
  1253                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1254                                  ;that actually hook the interrupt vectors belong to either the first 
  1255                                  ;command.com or to any other command.com executed with the /p switch. 
  1256                                  ;
  1257                                  ;The stub also keeps track of the current active data segment. The 
  1258                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1259                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1260                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1261                                  ;the exit code picks up the previous data segment pointer from the current
  1262                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1263                                  ;
  1264                                  ;Right now the stub does not bother about A20 switching. We assume
  1265                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1266                                  ;value of the current data segment in one of the registers. A20 toggle 
  1267                                  ;support maybe added as a future enhancement, if the need is felt.
  1268                                  
  1269                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1270                                  
  1271                                  	[ORG 100H]
  1272                                  
  1273                                  	; 21/09/2018 - Retro DOS v3.0
  1274                                  StartCode:
  1275 00000000 E9FD13                  	jmp	ConProc	; 10/01/2023 
  1276                                  
  1277                                  	; 09/01/2023
  1278                                  
  1279                                  ; Make following table word-aligned, and at the same time, provide a
  1280                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1281                                  
  1282                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1283 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1284                                  
  1285                                  ;All the entry points declared below are patched in at INIT time with the
  1286                                  ;proper segment and offset values after the resident code segment has been
  1287                                  ;moved to its final location
  1288                                  
  1289                                  ;!!!WARNING!!!
  1290                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1291                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1292                                  ;in the correct segments and offsets
  1293                                  
  1294                                  Int2f_Entry:
  1295 00000004 [1713]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1296 00000006 0000                    	dw	0
  1297                                  Int2e_Entry:
  1298 00000008 [730D]                  	dw	Int_2e			; Address of int 2eh handler
  1299 0000000A 0000                    	dw	0
  1300                                  Ctrlc_Entry:
  1301 0000000C [330C]                  	dw	ContC			; Address of Ctrl-C handler
  1302 0000000E 0000                    	dw	0
  1303                                  CritErr_Entry:
  1304 00000010 [3410]                  	dw	DSKERR			; Address of critical error handler
  1305 00000012 0000                    	dw	0
  1306                                  
  1307                                  Exec_Entry:
  1308 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1309                                  RemCheck_Entry:
  1310 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1311                                  TrnLodCom1_Entry:
  1312 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1313                                  LodCom_Entry:
  1314 00000020 00000000                	dd	0			; Entry after exit from command.com
  1315                                  MsgRetrv_Entry:
  1316 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1317                                  HeadFix_Entry:
  1318 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1319                                  UMBOff_Entry:
  1320 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1321                                  XMMCallAddr:
  1322 00000030 00000000                	dd	0			; Call address for XMM functions
  1323                                  ComInHMA:
  1324 00000034 00                      	db	0			; Flags if command.com in HMA
  1325                                  
  1326                                  Int2f_Trap:
  1327                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1328 00000035 E86400                  	call	CheckA20
  1329 00000038 1E                      	push	ds			; push current ds value
  1330 00000039 0E                      	push	cs			; push resident data segment value
  1331                                  	;jmp	cs:Int2f_Entry
  1332 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1333                                  
  1334                                  Int2e_Trap:
  1335 0000003F FB                      	sti
  1336 00000040 E85900                  	call	CheckA20
  1337 00000043 1E                      	push	ds			; push current ds value
  1338 00000044 0E                      	push	cs			; push resident data segment value
  1339                                  	;jmp	cs:Int2e_Entry
  1340 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1341                                  
  1342                                  Ctrlc_Trap:
  1343 0000004A FB                      	sti
  1344 0000004B E84E00                  	call	CheckA20
  1345 0000004E 1E                      	push	ds			; push current ds value
  1346 0000004F 0E                      	push	cs			; push resident data segment value
  1347                                  	;jmp	cs:Ctrlc_Entry
  1348 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1349                                  
  1350                                  CritErr_Trap:
  1351 00000055 FB                      	sti
  1352 00000056 E84300                  	call	CheckA20
  1353 00000059 1E                      	push	ds			; push current ds value
  1354 0000005A 0E                      	push	cs			; push resident data segment value
  1355                                  	;jmp	cs:CritErr_Entry
  1356 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1357                                  
  1358                                  Exec_Trap:
  1359 00000060 E83900                  	call	CheckA20
  1360 00000063 1E                      	push	ds			; push current ds value
  1361 00000064 0E                      	push	cs			; push resident data segment value
  1362                                  	;jmp	cs:Exec_Entry
  1363 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1364                                  
  1365                                  RemCheck_Trap:
  1366 0000006A E82F00                  	call	CheckA20
  1367 0000006D 1E                      	push	ds			; push current ds value
  1368 0000006E 0E                      	push	cs			; push resident data segment value
  1369                                  	;jmp	cs:RemCheck_Entry
  1370 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1371                                  
  1372                                  TrnLodCom1_Trap:
  1373 00000074 E82500                  	call	CheckA20
  1374 00000077 1E                      	push	ds			; push current ds value
  1375 00000078 0E                      	push	cs			; push resident data segment value
  1376                                  	;jmp	cs:TrnLodCom1_Entry
  1377 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1378                                  
  1379                                  LodCom_Trap:
  1380 0000007E E81B00                  	call	CheckA20
  1381 00000081 1E                      	push	ds			; push current ds value
  1382 00000082 0E                      	push	cs			; push resident data segment value
  1383                                  	;jmp	cs:LodCom_Entry
  1384 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1385                                  
  1386                                  MsgRetrv_Trap:
  1387 00000088 E81100                  	call	CheckA20
  1388 0000008B 1E                      	push	ds			; push current ds value
  1389 0000008C 0E                      	push	cs			; push resident data segment value
  1390                                  	;jmp	cs:MsgRetrv_Entry
  1391 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1392                                  
  1393                                  HeadFix_Trap:
  1394 00000092 E80700                  	call	CheckA20
  1395 00000095 1E                      	push	ds			; push current ds value
  1396 00000096 0E                      	push	cs			; push resident data segment value
  1397                                  	;jmp	cs:HeadFix_Entry
  1398 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1399                                  
  1400                                  ; ----------------------------------------------------------------------------
  1401                                  
  1402                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1403                                  %if 0
  1404                                  	; 09/01/2023
  1405                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1406                                  
  1407                                  	; 05/06/2023
  1408                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1409                                  CheckA20:
  1410                                  	pushf				; save current flags
  1411                                  	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1412                                  	jz	short A20_on		; no, jump to resident
  1413                                  
  1414                                  	call	QueryA20
  1415                                  	jnc	short A20_on		; A20 is on, jump to resident
  1416                                  
  1417                                  	call	EnableA20		; turn A20 on
  1418                                  A20_on:
  1419                                  	popf				; flags have to be unchanged
  1420                                  	retn
  1421                                  %else
  1422                                  	; 18/07/2024
  1423                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1424                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1425                                  	; PCDOS 7.1 COMMAND.COM - RESGROUP:01FFh
  1426                                  CheckA20:
  1427 0000009C 9C                      	pushf				; save current flags
  1428 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1429 000000A3 741A                    	jz	short A20_on		; no, jump to resident
  1430                                  	; 18/07/2024
  1431 000000A5 50                      	push	ax
  1432 000000A6 53                      	push	bx
  1433                                  QueryA20:
  1434                                  	;mov	ah,7
  1435 000000A7 B407                    	mov	ah,XMM_QUERY_A20
  1436                                  	;call	cs:XMMCallAddr
  1437 000000A9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1438 000000AE 09C0                    	or	ax,ax
  1439                                  	; 16/04/2023
  1440 000000B0 750B                    	jnz	short QA20_ON		; A20 is on, jump to resident
  1441                                  	; 18/07/2024
  1442                                  EnableA20:
  1443                                  	;mov	ah,5
  1444 000000B2 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20	; turn A20 on
  1445                                  	;call	cs:XMMCallAddr
  1446 000000B4 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1447 000000B9 09C0                    	or	ax,ax
  1448 000000BB 7404                    	jz	short XMMerror		; AX = 0 fatal error
  1449                                  QA20_ON:
  1450 000000BD 5B                      	pop	bx
  1451 000000BE 58                      	pop	ax
  1452                                  A20_on:
  1453 000000BF 9D                      	popf				; flags have to be unchanged
  1454 000000C0 C3                      	retn
  1455                                  ;If we get an error, we just loop forever
  1456                                  XMMerror:
  1457 000000C1 EBFE                    	jmp	short XMMerror
  1458                                  %endif
  1459                                  
  1460                                  ; ----------------------------------------------------------------------------
  1461                                  
  1462                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1463                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1464                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1465                                  ; M005; pointers because our cs is going to be different. The segment to
  1466                                  ; M005; jump to is patched in at init time. (in init.asm)
  1467                                  
  1468                                  Carousel_i2f_Hook:			; M005
  1469 000000C3 EA                      	db	0EAh			; far jump opcode; M005
  1470 000000C4 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1471 000000C6 0000                    	dw	0			; int 2fh segment; M005
  1472                                  
  1473                                  ; ----------------------------------------------------------------------------
  1474                                  
  1475                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1476                                  %if 0
  1477                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1478                                  QueryA20:
  1479                                  	push	bx
  1480                                  	push	ax
  1481                                  	;mov	ah,7
  1482                                  	mov	ah,XMM_QUERY_A20
  1483                                  	;call	cs:XMMCallAddr
  1484                                  	call	far [cs:XMMCallAddr]
  1485                                  	or	ax,ax
  1486                                  	pop	ax
  1487                                  	pop	bx
  1488                                  	; 16/04/2023
  1489                                  	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1490                                  	stc					; OFF
  1491                                  	;retn
  1492                                  QA20_ON:
  1493                                  	;clc					; ON
  1494                                  	retn
  1495                                  %endif
  1496                                  
  1497                                  ; ----------------------------------------------------------------------------
  1498                                  
  1499                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1500                                  %if 0
  1501                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1502                                  EnableA20:
  1503                                  	push	bx
  1504                                  	push	ax
  1505                                  	;mov	ah,5
  1506                                  	mov	ah,XMM_LOCAL_ENABLE_A20
  1507                                  	;call	cs:XMMCallAddr
  1508                                  	call	far [cs:XMMCallAddr]
  1509                                  	or	ax,ax
  1510                                  	jz	short XMMerror			; AX = 0 fatal error
  1511                                  	pop	ax
  1512                                  	pop	bx
  1513                                  	retn
  1514                                  ;If we get an error, we just loop forever
  1515                                  XMMerror:
  1516                                  	jmp	short XMMerror
  1517                                  %endif
  1518                                  
  1519                                  ; -----------------------------------------------------------------------------
  1520                                  
  1521                                  HV_Extern   equ	1
  1522                                  HV_LoadHigh equ	1
  1523                                  HV_Stub	    equ	1
  1524                                  
  1525                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1526                                  
  1527                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1528                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1529                                  ;returns with all registers preserved and so all our segment registers are
  1530                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1531                                  ;comes back here. In this case the segment registers and the stack are
  1532                                  ;not set up and random things can happen. The only way to setup all the 
  1533                                  ;registers is to use the cs value and this can only be done when we are in
  1534                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1535                                  ;the code segment to the data segment.
  1536                                  
  1537                                  Issue_Exec_Call:
  1538 000000C8 CD21                    	int 	21h
  1539                                  
  1540                                  ;We disable interrupts while changing the stack because there is a bug in 
  1541                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1542                                  ;are being changed.
  1543                                  
  1544 000000CA FA                      	cli
  1545 000000CB 0E                      	push	cs
  1546 000000CC 17                      	pop	ss
  1547                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1548                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1549 000000CD BC[2004]                	mov	sp,RStack		; stack is set up
  1550                                  	
  1551                                  	; 20/04/2023
  1552                                  	;sti
  1553                                  	;push	cs
  1554                                  	;pop	ds			; ds = DATARES
  1555                                  
  1556                                  ; M009; Restore UMB state to that before Exec
  1557                                  
  1558                                  	;pushf				;    This call frees HIDDEN umb's,
  1559                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1560                                  	;popf				;    strategy and link state, as app.
  1561                                  
  1562                                  	; 09/01/2023 - Retro DOS v4.0
  1563                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1564                                  	; ----------------------
  1565 000000D0 FB                      	sti
  1566                                  	
  1567 000000D1 0E                      	push    cs
  1568 000000D2 1F                      	pop     ds
  1569 000000D3 9C                      	pushf
  1570                                  	;mov	al,[cs:fInHigh]
  1571                                  	; 18/04/2023
  1572 000000D4 A0[2204]                	mov	al,[fInHigh]
  1573 000000D7 A880                    	test	al,80h
  1574 000000D9 7406                    	jz      short uhu10
  1575 000000DB 247F                    	and     al,7Fh
  1576                                  	;;call	cs:UMBOff_Entry
  1577                                  	;call	far [cs:UMBOff_Entry]
  1578 000000DD FF1E[2C00]              	call	far [UMBOff_Entry]
  1579                                  uhu10:
  1580                                  	;and	byte [cs:fInHigh],7Fh
  1581                                  	; 18/04/2023
  1582 000000E1 8026[2204]7F            	and	byte [fInHigh],7Fh
  1583 000000E6 9D                      	popf
  1584                                  	; ----------------------
  1585                                  
  1586                                  ;We now jump to the stub trap which returns us to the resident code. All
  1587                                  ;flags are preserved by the stub code.
  1588                                  
  1589 000000E7 E976FF                  	jmp	Exec_Trap
  1590                                  
  1591                                  ; ----------------------------------------------------------------------------
  1592                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1593                                  ; ----------------------------------------------------------------------------
  1594                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1595                                  
  1596                                  ;***	Message substitution blocks
  1597                                  
  1598                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1599                                  
  1600                                  ;BlkDevErrSubst	label	byte
  1601                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1602                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1603                                  
  1604 000000EA 02                      BlkDevErrSubst: db	2
  1605 000000EB 0000                    BlkDevErrRw:	dw	0
  1606 000000ED 01                      		db	1
  1607 000000EE [F000]                  		dw	DrvLet
  1608                                  
  1609 000000F0 41                      DrvLet:		db	'A'			; drive letter
  1610                                  
  1611                                  
  1612                                  ;CharDevErrSubst label	byte
  1613                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1614                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1615                                  
  1616 000000F1 02                      CharDevErrSubst: db	2
  1617 000000F2 0000                    CharDevErrRw:	dw	0
  1618 000000F4 02                      		db	2
  1619 000000F5 [0301]                  		dw	DevName
  1620                                  
  1621                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0318h
  1622                                  ;DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1623                                  ;		db	0
  1624                                  
  1625                                  ;NeedVolSubst	label	byte
  1626                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1627                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1628                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1629                                  
  1630 000000F7 02                      NeedVolSubst:	db	2
  1631 000000F8 [0001]                  		dw	VolName
  1632 000000FA 03                      		db	3
  1633 000000FB [0E01]                  		dw	VolSer+2
  1634 000000FD 03                      		db	3
  1635 000000FE [0C01]                  		dw	VolSer
  1636                                  
  1637                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0321h
  1638                                  	; NOTE:	VolName and VolSer must be adjacent
  1639                                  ;VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1640                                  		; 18/07/2024
  1641 00000100 000000                  VolName:	db	3 dup(0)
  1642 00000103 0000000000000000        DevName:	db	8 dup(0)
  1643                                  	
  1644 0000010B 00                      		db	0
  1645 0000010C 00000000                VolSer:		dd	0			; volume serial #
  1646                                  
  1647 00000110 00                      CDevAt:		db	0
  1648                                  
  1649                                  ;BadFatSubst	label	byte
  1650                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1651                                  
  1652 00000111 01                      BadFatSubst:	db	1
  1653 00000112 [F000]                  		dw	DrvLet
  1654                                  
  1655                                  ;PutBackSubst	label	byte
  1656                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1657                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1658                                  
  1659 00000114 02                      PutBackSubst:	db	2
  1660 00000115 0000                    PutBackComSpec:	dw	0
  1661 00000117 01                      		db	1
  1662 00000118 [1A01]                  		dw	PutBackDrv
  1663                                  
  1664 0000011A 20                      PutBackDrv:	db	' '			; drive letter
  1665                                  
  1666                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1667                                  
  1668 0000011B 02                      ExecErrSubst:	db	2
  1669 0000011C [4B03]                  		dw	SafePathBuffer
  1670                                  
  1671 0000011E 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1672 00000122 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1673                                  
  1674 00000123 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1675 00000127 0000                    Save_Pdb:	dw	0
  1676 00000129 0000                    Parent:		dw	0
  1677 0000012B 00000000                OldTerm:	dd	0
  1678 0000012F 0000                    ErrCd_24:	dw	0
  1679 00000131 0000                    Handle01:	dw	0
  1680 00000133 00                      Loading:	db	0
  1681 00000134 0000                    Batch:		dw	0	; assume no batch mode initially
  1682                                  
  1683                                  ;;;;SR;
  1684                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1685                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1686                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1687                                  ;;;;
  1688                                  ;;;BatchEOF:	db	0
  1689                                  
  1690                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1691                                  	; What's this comspec_end about?
  1692 00000136 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1693 00000176 0000                    ComSpec_End:	dw	0
  1694                                  
  1695                                  ;Trans		label	dword
  1696                                  ;		dw	TRANGROUP:Command
  1697                                  
  1698                                  Trans:		;dw	12Ch
  1699                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1700 00000178 [2C01]                  		dw	COMMAND ; 16/04/2023
  1701 0000017A 0000                    TrnSeg:		dw	0
  1702                                  
  1703 0000017C 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1704                                  
  1705 0000017D 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1706 0000017E 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1707                                  
  1708 0000017F 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1709 00000180 0000                    MemSiz:		dw	0
  1710 00000182 0000                    Sum:		dw	0
  1711 00000184 01                      ExtCom:		db	1	; for init, pretend just did an external
  1712 00000185 0000                    RetCode: 	dw	0
  1713 00000187 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1714                                  
  1715                                  
  1716                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1717                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1718                                  
  1719 00000188 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1720 00000189 01                      Suppress:	db	1	; used for echo, 1=echo line
  1721 0000018A 0000                    Io_Save: 	dw	0
  1722 0000018C 00                      RestDir: 	db	0
  1723 0000018D 00                      PermCom: 	db	0	; true => permanent command
  1724                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1725                                  				; true => semi-permanent command (/K)
  1726 0000018E 0000                    SingleCom:	dw	0	; true => single command version
  1727 00000190 FFFF                    VerVal:		dw	-1
  1728 00000192 00                      fFail:		db	0	; true => fail all int 24s
  1729 00000193 00                      IfFlag:		db	0	; true => IF statement in progress
  1730                                  
  1731 00000194 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1732 00000195 0000                    ForPtr:		dw	0
  1733                                  
  1734 00000197 0000                    Nest:		dw	0	; nested batch file counter
  1735 00000199 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1736 0000019A 00                      Call_Batch_Flag: db	0
  1737 0000019B 0000                    Next_Batch:	dw	0	; address of next batch segment
  1738 0000019D 00                      NullFlag:	db	0	; flag if no command on command line
  1739 0000019E 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1740                                  				; buffer for file ucase address
  1741                                  ; Bugbug: don't need crit_msg_ anymore?
  1742                                  
  1743 000001A3 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1744 000001A5 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1745 000001A7 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1746 000001A9 0000                    		 dw	0	; DBCS vector segment
  1747 000001AB 0000                    Append_State:	dw	0	; current state of append
  1748                                  				;  (if Append_Flag is set)
  1749 000001AD 00                      Append_Flag:	db	0	; set if append state is valid
  1750 000001AE 00                      Re_Out_App:	db	0
  1751 000001AF 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1752                                  
  1753                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1754                                  ; various times. Here is the breakdown:
  1755                                  ;
  1756                                  ;   INITINIT	We are in the init code.
  1757                                  ;   INITSPECIAL We are in the date/time prompt
  1758                                  ;   INITCTRLC	We are handling a ^C already.
  1759                                  ;
  1760                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1761                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1762                                  ;
  1763                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1764                                  ; input buffer with a CR to pretend an empty response.
  1765                                  ;
  1766                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1767                                  ; (ourselves). We can then detect the carry set and properly retry the
  1768                                  ; operation.
  1769                                  
  1770                                  InitFlag:	;db	1
  1771 000001FF 01                      		db	INITINIT
  1772                                  
  1773                                  ; Note: these two bytes are referenced as a word
  1774 00000200 00                      PipeFlag:	db	0
  1775 00000201 00                      PipeFiles:	db	0
  1776                                  
  1777                                  ; (rdata.asm, msdos 6.0, 1992)
  1778                                  ; ----------------------------------------------------------------------------
  1779                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1780                                  
  1781                                  
  1782                                  ;;SR
  1783                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1784                                  ;;
  1785                                  ;
  1786                                  ;; Bugbug: can we find any way around maintaining these
  1787                                  ;; large buffers?
  1788                                  ;
  1789                                  ;Pipe1		db	67+12 dup (?)
  1790                                  ;Pipe2		db	67+12 dup (?)
  1791                                  ;
  1792                                  ;PipePtr 	dw	?
  1793                                  ;
  1794                                  ;PipeStr 	db	129 dup (?)
  1795                                  ;
  1796                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1797                                  ;
  1798                                  ;;SR;
  1799                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1800                                  ;;automatically be discarded after init.
  1801                                  ;;
  1802                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1803                                  ;; M004; the origin.
  1804                                  ;;
  1805                                  ;	ORG	Pipe1	; M004
  1806                                  ;
  1807                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1808                                  ;; what it expects, what it does.
  1809                                  ;
  1810                                  
  1811                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1812                                  
  1813                                  Pipe1	equ	EndInit
  1814                                  Pipe2	equ	Pipe1+67+12
  1815                                  PipePtr	equ	Pipe2+67+12
  1816                                  PipeStr	equ	PipePtr+2
  1817                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1818                                  
  1819                                  ; Bugbug: really need a procedure header for EndInit, describing
  1820                                  ; what it expects, what it does.
  1821                                  
  1822                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1823                                  
  1824                                  EndInit:
  1825 00000202 1E                      	push	ds
  1826 00000203 06                      	push	es		; save segments
  1827 00000204 0E                      	push	cs
  1828 00000205 1F                      	pop	ds		
  1829                                  	;assume	ds:RESGROUP
  1830                                  
  1831                                  ; M004; Save size of transient here before INIT segment is deallocated
  1832                                  
  1833 00000206 8B16[7E1C]              	mov	dx,[TrnSize]		; M004
  1834                                  ;M027
  1835                                  ; These variables are also defined in the INIT segment and need to be saved
  1836                                  ;before we resize
  1837                                  ;
  1838 0000020A A1[721C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1839 0000020D 8B1E[6E1C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1840 00000211 8B0E[741C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1841 00000215 50                      	push	ax		; Save all these values ;M027
  1842 00000216 53                      	push	bx		; M027
  1843 00000217 51                      	push	cx		; M027
  1844                                  
  1845                                  
  1846                                  ; Bugbug: push ds, pop es here.
  1847                                  	;mov	bx,ds
  1848                                  	;mov	es,bx		; es = RESGROUP
  1849                                  	; 09/01/2023
  1850 00000218 1E                      	push	ds
  1851 00000219 07                      	pop	es
  1852                                  
  1853                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1854                                  ; code + data for low COMMAND
  1855                                  
  1856 0000021A 8B1E[A103]              	mov	bx,[ResSize]	; Total size of resident
  1857 0000021E B44A                    	mov	ah,4Ah
  1858                                  	;mov	ah,SETBLOCK
  1859 00000220 CD21                    	int	21h		; Set block to resident size
  1860                                  
  1861                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1862                                  		; ES = segment address of block to change
  1863                                  		; BX = new size in paragraphs
  1864                                  
  1865                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1866                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1867                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1868                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1869                                  ;
  1870                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1871                                  	
  1872 00000222 803E[8D01]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1873 00000227 7530                    	jne	short adjust_env ; no, do not free batchseg
  1874                                  
  1875 00000229 833E[3401]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1876 0000022E 7429                    	je	short adjust_env ; no, dont juggle
  1877                                  
  1878                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  1879                                  	; 21/01/2023
  1880 00000230 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1881                                  	;mov	bx,4	; 09/01/2023
  1882                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1883 00000233 B448                    	mov	ah,48h
  1884                                  	;mov	ah,ALLOC
  1885 00000235 CD21                    	int	21h
  1886                                  
  1887                                  		; DOS - 2+ - ALLOCATE MEMORY
  1888                                  		; BX = number of 16-byte paragraphs desired
  1889                                  
  1890                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1891                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1892                                  ; could be making it worse! We're second-guessing where memory
  1893                                  ; allocations go, which might not be such a great idea. Is there
  1894                                  ; a strategy, short of doing something even worse like diddling
  1895                                  ; arena headers, where we can minimize the possibility of fragmentation
  1896                                  ; under all cases? Hmm..
  1897                                  	
  1898 00000237 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1899                                  
  1900 00000239 8EC0                    	mov	es,ax		 ; es = New batch segment
  1901 0000023B 31FF                    	xor	di,di
  1902 0000023D 31F6                    	xor	si,si
  1903                                  
  1904 0000023F 1E                      	push	ds
  1905 00000240 8E1E[3401]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1906                                  	;assume	ds:nothing
  1907                                  	;mov	cx,SIZE BatchSegment
  1908                                  	; 23/01/2023
  1909                                  	;mov	cx,BATCHSEGMENT.SIZE
  1910                                  	;;mov	cx,33	; 09/01/2023
  1911                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1912                                  	;
  1913                                  	;add	cx,16		 ; for the filename
  1914                                  	; 20/04/2023
  1915 00000244 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16
  1916                                  
  1917                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1918                                  	; It's sure be bad if we copied more bytes than the batch segment
  1919                                  	; holds!
  1920                                  	
  1921 00000247 FC                      	cld
  1922 00000248 F3A4                    	rep	movsb
  1923 0000024A 1F                      	pop	ds
  1924                                  	;assume	ds:RESGROUP
  1925                                  
  1926 0000024B 8CC1                    	mov	cx,es		; save new batch segment 
  1927 0000024D 8E06[3401]              	mov	es,[Batch]
  1928 00000251 B449                    	mov	ah,49h
  1929                                  	;mov	ah,DEALLOC
  1930 00000253 CD21                    	int	21h		; free the old batch segment
  1931                                  
  1932                                  	; Bugbug: should we check for error?
  1933                                  
  1934 00000255 890E[3401]              	mov	[Batch],cx	; store new batch segment address
  1935                                  
  1936                                  adjust_env:
  1937 00000259 59                      	pop	cx		; cx = size of old env ;M027
  1938 0000025A 5B                      	pop	bx		; bx = size of new env needed ;M027
  1939 0000025B 5D                      	pop	bp		; bp = old env seg ;M027
  1940                                  
  1941                                  ;Allocate the correct size for the environment
  1942                                  
  1943 0000025C B448                    	mov	ah,48h
  1944                                  	;mov	ah,ALLOC
  1945 0000025E CD21                    	int	21h		; get memory
  1946 00000260 7264                    	jc	short nomem_err	; out of memory,signal error
  1947                                  	
  1948                                  	; Bugbug: why not continue, leaving environment where it is?
  1949                                  
  1950 00000262 A3[2703]                	mov	[EnvirSeg],ax	; Store new environment segment
  1951                                  	;;mov	[ds:2Ch],ax
  1952                                  	;mov	[2Ch],ax
  1953                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1954 00000265 A32C00                  	mov	[PDB.ENVIRON],ax
  1955 00000268 8EC0                    	mov	es,ax		; es = address of allocated memory
  1956                                  	;assume	es:nothing
  1957                                  
  1958                                  ;Copy the environment to the newly allocated segment
  1959                                  
  1960 0000026A 1E                      	push	ds
  1961 0000026B 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1962                                  	;assume	ds:nothing
  1963                                  
  1964 0000026D 31F6                    	xor	si,si
  1965 0000026F 89F7                    	mov	di,si		; Start transfer from 0
  1966                                  
  1967 00000271 FC                      	cld
  1968 00000272 F3A4                    	rep	movsb		; Do the copy
  1969                                  
  1970 00000274 1F                      	pop	ds		; ds = RESGROUP
  1971                                  	;assume	ds:RESGROUP
  1972                                  
  1973                                  ; We have to free the old environment block if it was allocated by INIT
  1974                                  
  1975                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1976                                  ; or does it also apply to passed environments?
  1977                                  
  1978                                  ;M036
  1979                                  ; Free up old env segment always because this is a copy passed by Exec and
  1980                                  ; takes up memory that is never used
  1981                                  
  1982                                  ;M044
  1983                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1984                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1985                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1986                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1987                                  ; in
  1988                                  
  1989                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1990                                          ;je	short no_free	    ; no, do not free it
  1991                                  	; 21/01/2023
  1992                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1993 00000275 803E[521C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment
  1994 0000027A 7506                    	jne	short no_free 
  1995                                  
  1996 0000027C 8EC5                    	mov	es,bp
  1997 0000027E B449                    	mov	ah,49h
  1998                                  	;mov	ah,DEALLOC
  1999 00000280 CD21                    	int	21h		    ; Free it
  2000                                  no_free:
  2001                                  
  2002                                  ; M004; Start of changes
  2003                                  
  2004                                  ; Move the transient now. We will allocate the biggest block available
  2005                                  ; now and move the transient to the top of the block. We will then
  2006                                  ; deallocate this block. When the resident starts executing, it will
  2007                                  ; hopefully allocate this block again and find the transient intact.
  2008                                  
  2009 00000282 C606[7C01]01            	mov	byte [TrnMvFlg],1 ; Indicate that transient has been moved
  2010 00000287 06                      	push	es
  2011                                  	;;mov	si,offset ResGroup:TranStart
  2012                                  	; 09/01/2023
  2013                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2014 00000288 BE0022                  	mov	si,TRANSTART	; (End of the resident portion)
  2015                                  	;mov	di,0
  2016 0000028B 31FF                    	xor	di,di ; 0
  2017                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2018                                  	;mov	cx,98C5h
  2019 0000028D B99495                  	mov	cx,TRANSPACEEND
  2020                                  	
  2021                                  ; Find the largest block available
  2022                                  
  2023 00000290 BBFFFF                  	mov	bx,0FFFFh
  2024 00000293 B448                    	mov	ah,48h
  2025                                  	;mov	ah,ALLOC
  2026 00000295 CD21                    	int	21h
  2027                                  
  2028                                  ; dx = size of transient saved previously 
  2029                                  
  2030 00000297 39D3                    	cmp	bx,dx		; enough memory?
  2031 00000299 722B                    	jb	short nomem_err	; not enough memory for transient
  2032                                  
  2033 0000029B B448                    	mov	ah,48h
  2034                                  	;mov	ah,ALLOC
  2035 0000029D CD21                    	int	21h		; get the largest block
  2036 0000029F 7225                    	jc	short nomem_err	; something is really screwed up
  2037                                  
  2038 000002A1 50                      	push	ax		; save memory address
  2039 000002A2 01D8                    	add	ax,bx		; ax = top of my memory block
  2040 000002A4 29D0                    	sub	ax,dx		; less size of transient
  2041 000002A6 A3[7A01]                	mov	[TrnSeg],ax	; save transient segment
  2042 000002A9 8EC0                    	mov	es,ax		;
  2043 000002AB 58                      	pop	ax		; restore our seg addr
  2044                                  
  2045                                  ; Everything is set for a move. We need to move in the reverse direction to
  2046                                  ; make sure we dont overwrite ourselves while copying
  2047                                  
  2048 000002AC 01CE                    	add	si,cx
  2049 000002AE 4E                      	dec	si
  2050 000002AF 01CF                    	add	di,cx
  2051 000002B1 4F                      	dec	di
  2052 000002B2 FD                      	std
  2053 000002B3 F3A4                    	rep	movsb
  2054 000002B5 FC                      	cld
  2055                                  
  2056                                  ; Now we have to free up this block so that resident can get hold of it
  2057                                  
  2058 000002B6 8EC0                    	mov	es,ax
  2059 000002B8 B449                    	mov	ah,49h
  2060                                  	;mov	ah,DEALLOC
  2061 000002BA CD21                    	int	21h		; release the memory block
  2062                                  
  2063                                  ; M004; End of changes
  2064                                  
  2065                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2066                                  	; 09/01/2023
  2067 000002BC C606[FF01]00            	mov	byte [InitFlag],0	
  2068                                  
  2069 000002C1 07                      	pop	es
  2070 000002C2 1F                      	pop	ds
  2071                                  	;assume	ds:nothing
  2072                                  	
  2073                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2074                                  	
  2075 000002C3 E9B8FD                  	jmp	LodCom_Trap	; allocate transient
  2076                                  
  2077                                  nomem_err:
  2078                                  
  2079                                  ;We call the error routine which will never return. It will either exit
  2080                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2081                                  ;message ( if first COMMAND )
  2082                                  
  2083 000002C6 E9F518                  	jmp	Alloc_error
  2084                                  
  2085                                  ;EndCodeInit:	; label	byte		; M004
  2086                                  
  2087                                  	; 16/04/2023
  2088                                  	EndCodeInit equ $
  2089                                  
  2090                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2091                                  ;; M004; If not, we signal an assembly error
  2092                                  ;
  2093                                  ;IF2
  2094                                  ;	IF ($ GT EndPipe)
  2095                                  ;		.err
  2096                                  ;		%out	"ENDINIT CODE TOO BIG"
  2097                                  ;	ENDIF
  2098                                  ;ENDIF
  2099                                  
  2100                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2101                                  ;;
  2102                                  ;		ORG	EndPipe		; M004
  2103                                  
  2104                                  ; 09/01/2023
  2105                                  
  2106                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2107                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2108                                  
  2109                                  ; 16/04/2023
  2110                                  	FillBytes equ EndPipe - EndCodeInit
  2111                                  
  2112                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2113                                  ; 16/04/2023
  2114                                  %if FillBytes>0
  2115                                  	;times EndPipe - EndCodeInit db 0
  2116 000002C9 00<rep 5Ah>             	times FillBytes db 0
  2117                                  %endif
  2118                                  
  2119                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2120                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289
  2121                                  
  2122                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h
  2123                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2124                                  
  2125 00000323 [0202]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2126 00000325 [5102]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2127                                  
  2128                                  Exec_Block:	; label	byte	; the data block for exec calls
  2129 00000327 0000                    EnvirSeg:	dw	0
  2130                                  Com_Ptr:	; label	dword
  2131 00000329 8000                    		dw	80h	; point at unformatted parameters
  2132 0000032B 0000                    		dw	0
  2133                                  Com_Fcb1:	; label	dword
  2134 0000032D 5C00                    		dw	5Ch
  2135 0000032F 0000                    		dw	0
  2136                                  Com_Fcb2:	; label	dword
  2137 00000331 6C00                    		dw	6Ch
  2138 00000333 0000                    		dw	0
  2139                                  
  2140                                  ; variables passed to transient
  2141                                  TranVars:	; label	byte
  2142                                  		;dw	offset DATARES:HeadFix_Trap
  2143 00000335 [9200]                  		dw	HeadFix_Trap
  2144 00000337 0000                    MySeg:		dw	0	; put our own segment here
  2145 00000339 0000                    LTpa:		dw	0	; will store tpa segment here
  2146 0000033B 2F                      RSwitChar:	db	"/"
  2147 0000033C 5C                      RDirChar:	db	"\"
  2148                                  		;dw	offset DATARES:Issue_Exec_Call
  2149 0000033D [C800]                  		dw	Issue_Exec_Call
  2150 0000033F 0000                    MySeg1:		dw	0
  2151                                  		;dw	offset DATARES:RemCheck_Trap
  2152 00000341 [6A00]                  		dw	RemCheck_Trap
  2153 00000343 0000                    MySeg2:		dw	0
  2154 00000345 0000                    ResTest: 	dw	0
  2155 00000347 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2156                                  TranVarEnd:	; label	byte
  2157                                  
  2158 00000349 0000                    OldErrNo:	dw	0
  2159                                  
  2160                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2161                                  ;  MsgBuffer is only used while a command is being executed.
  2162                                  ;  SafePathBuffer is no longer needed, since it is used for
  2163                                  ;  unsuccessful program launches.
  2164                                  
  2165                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2166                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2167                                  	;Bugbug: Why so big a buffer?
  2168                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2169 0000034B 00<rep 50h>             		times	64+3+13 db 0		
  2170                                  
  2171                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2172                                  
  2173 0000039B 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2174 0000039F 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2175                                  
  2176                                  ;SR;
  2177                                  ; The three vars below have been added for a pure COMMAND.COM
  2178                                  
  2179 000003A1 0000                    ResSize:	dw	0
  2180                                  
  2181                                  ;SR;
  2182                                  ; Moved the stack here from the code segment
  2183                                  ;
  2184                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2185                                  	
  2186                                  		;db	(80h - 3) dup (?)
  2187 000003A3 90                      align 2
  2188 000003A4 00<rep 7Ch>             		times	124 db 0		
  2189                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2190                                  RStack:		; label	word
  2191 00000420 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2192                                  				; resident code segments
  2193                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2194                                  
  2195                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2196                                  ; -------------------------------
  2197                                  
  2198                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2199                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2200                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2201                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2202                                  ;            given a command-line like "/L:3,500;4"
  2203                                  ; UmbUsed  - An array of characters, each of which is 1 if the UMB
  2204                                  ;            matching its index number was specified on the command-line;
  2205                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2206                                  ;            will be set to 1. All others will be set to 0.
  2207                                  ; UmbSize  - An array of words, each of which is interpreted as a size
  2208                                  ;            specified by the user for a UMB (in the above example, all
  2209                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2210                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2211                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2212                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2213                                  ;            for details).
  2214                                  
  2215                                  ; - MSDOS 6.0 COMMAND.COM -
  2216                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2217                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2218                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2219                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2220                                  ;; space problem (it's just such a nice round number, eh?).
  2221                                  
  2222                                  ;MAXUMB	equ	16
  2223                                  
  2224                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2225                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2226                                  
  2227 00000422 00                      fInHigh:	db	0
  2228                                  
  2229                                  ; MSDOS 6.0 COMMAND.COM
  2230                                  ;fUmbTiny:	db	0
  2231                                  ;SegLoad:	dw	0
  2232                                  ;UmbLoad:	db	0
  2233                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2234                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2235                                  ;fm_umb:	db	0
  2236                                  ;fm_strat:	db	0
  2237                                  ;fm_argc:	db	0
  2238                                  
  2239                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2240                                  ; UmbLoad is set to the UMB number given.
  2241                                  
  2242                                  ;*** MESSAGES
  2243                                  ;    and other translatable text
  2244                                  
  2245                                  ; include comrmsg.inc	; M00
  2246                                  ; ------------------------------
  2247                                  
  2248                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2249                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2250                                  
  2251 00000423 41                      ABORT_CHAR:	db 'A'
  2252 00000424 52                      RETRY_CHAR:	db 'R'
  2253 00000425 49                      IGNORE_CHAR:	db 'I'
  2254 00000426 46                      FAIL_CHAR:	db 'F'
  2255 00000427 59                      YES_CHAR:	db 'Y'
  2256 00000428 4E                      NO_CHAR:	db 'N'
  2257 00000429 05                      REQ_ABORT:	db 5
  2258 0000042A 41626F7274              		db 'Abort'
  2259 0000042F 07                      REQ_RETRY:	db 7
  2260 00000430 2C205265747279          		db ', Retry'
  2261 00000437 08                      REQ_IGNORE:	db 8
  2262 00000438 2C2049676E6F7265        		db ', Ignore'
  2263 00000440 06                      REQ_FAIL:	db 6
  2264 00000441 2C204661696C            		db ', Fail'
  2265 00000447 01                      REQ_END:	db 1
  2266 00000448 3F                      		db '?'
  2267 00000449 08                      MREAD:		db 8
  2268 0000044A 72656164696E6700        		db 'reading', 0
  2269 00000452 08                      MWRITE:		db 8
  2270 00000453 77726974696E6700        		db 'writing', 0
  2271 0000045B 0E                      MDRIVE:		db 14
  2272 0000045C 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2272 00000465 2025320D0A         
  2273 0000046A 0F                      MDEVICE:	db 15
  2274 0000046B 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2274 00000474 652025320D0A       
  2275 0000047A 26                      MVOLSERIAL:	db 38
  2276 0000047B 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2276 00000484 7365727420766F6C75-
  2276 0000048D 6D6520253120736572-
  2276 00000496 69616C2025322D2533-
  2276 0000049F 0D0A               
  2277 000004A1 25                      BADFATMSG:	db 37
  2278 000004A2 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2278 000004AB 636174696F6E207461-
  2278 000004B4 626C65206261642C20-
  2278 000004BD 64726976652025310D-
  2278 000004C6 0A                 
  2279 000004C7 15                      COMBAD:		db 21
  2280 000004C8 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2280 000004D1 4F4D4D414E442E434F-
  2280 000004DA 4D0D0A             
  2281 000004DD 21                      PUTBACKMSG:	db 33
  2282 000004DE 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2282 000004E7 736B20776974682025-
  2282 000004F0 3120696E2064726976-
  2282 000004F9 652025320D0A       
  2283 000004FF 21                      PROMPT:		db 33
  2284 00000500 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2284 00000509 206B657920746F2063-
  2284 00000512 6F6E74696E7565202E-
  2284 0000051B 202E202E0D0A       
  2285 00000521 1C                      ENDBATMES:	db 28
  2286 00000522 0D0A                    		db 0Dh,0Ah
  2287 00000524 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2287 0000052D 206261746368206A6F-
  2287 00000536 622028592F4E293F   
  2288 0000053E 13                      EXECEMES:	db 19
  2289 0000053F 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2289 00000548 65637574652025310D-
  2289 00000551 0A                 
  2290 00000552 13                      EXEBAD:		db 19
  2291 00000553 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2291 0000055C 4558452066696C650D-
  2291 00000565 0A                 
  2292 00000566 22                      TOOBIG:		db 34
  2293 00000567 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2293 00000570 6F6F2062696720746F-
  2293 00000579 2066697420696E206D-
  2293 00000582 656D6F72790D0A     
  2294 00000589 16                      NOHANDMES:	db 22
  2295 0000058A 0D0A                    		db 0Dh,0Ah
  2296 0000058C 4E6F20667265652066-     		db 'No free file handles'
  2296 00000595 696C652068616E646C-
  2296 0000059E 6573               
  2297 000005A0 1A                      RBADNAM:	db 26
  2298 000005A1 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2298 000005AA 6E64206F722066696C-
  2298 000005B3 65206E616D650D0A   
  2299                                  ACCDENIED:	; 14/01/2023
  2300                                  		; 10/01/2023
  2301                                  ACCDEN:		;db 14
  2302                                  		;db 'Access denied '
  2303                                  		; 19/07/2024 - PCDOS 7.1
  2304 000005BB 0D                      		db 13
  2305 000005BC 416363657373206465-     		db 'Access denied'
  2305 000005C5 6E696564           
  2306 000005C9 19                      BMEMMES:	db 25
  2307 000005CA 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2307 000005D3 616C6C6F636174696F-
  2307 000005DC 6E206572726F72     
  2308 000005E3 26                      HALTMES:	db 38
  2309 000005E4 0D0A                    		db 0Dh,0Ah
  2310 000005E6 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2310 000005EF 616420434F4D4D414E-
  2310 000005F8 442C2073797374656D-
  2310 00000601 2068616C7465640D0A 
  2311 0000060A 21                      FRETMES:	db 33
  2312 0000060B 0D0A                    		db 0Dh,0Ah,
  2313 0000060D 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2313 00000616 61727420434F4D4D41-
  2313 0000061F 4E442C206578697469-
  2313 00000628 6E670D0A           
  2314 0000062C 2E                      PATRICIDE:	db 46
  2315 0000062D 0D0A                    		db 0Dh,0Ah
  2316 0000062F 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2316 00000638 2070726F6365737320-
  2316 00000641 61626F727465642C20-
  2316 0000064A 63616E6E6F7420636F-
  2316 00000653 6E74696E7565       
  2317 00000659 0D0A                    		db 0Dh,0Ah
  2318 0000065B 02                      NEWLINE:	db 2
  2319 0000065C 0D0A                    		db 0Dh, 0Ah
  2320                                  
  2321                                  ; 10/01/2023
  2322                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2323                                  
  2324 0000065E [420B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2325 00000660 0100                    		dw 1
  2326 00000662 [FD08]                  		dw PARSMSGPTRS		; parse	error messages
  2327 00000664 0100                    		dw 1
  2328 00000666 [420B]                  		dw EXTMSGPTRS		; critical error messages
  2329 00000668 0100                    		dw 1
  2330 0000066A 0000                    		dw 0			; File system error messages
  2331 0000066C 0000                    		dw 0			; are not supported.
  2332 0000066E [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2333 00000670 0000                    MySeg3:		dw 0			; segment of retriever routine
  2334                                  
  2335                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2336                                  
  2337 00000672 13                      CRMSG0:		db 19
  2338 00000673 57726974652070726F-     		db 'Write protect error'
  2338 0000067C 74656374206572726F-
  2338 00000685 72                 
  2339 00000686 0C                      CRMSG1:		db 12
  2340 00000687 496E76616C69642075-     		db 'Invalid unit'
  2340 00000690 6E6974             
  2341 00000693 09                      CRMSG2:		db 9
  2342 00000694 4E6F74207265616479      		db 'Not ready'
  2343 0000069D 16                      CRMSG3:		db 22
  2344 0000069E 496E76616C69642064-     		db 'Invalid device request'
  2344 000006A7 657669636520726571-
  2344 000006B0 75657374           
  2345 000006B4 0A                      CRMSG4:		db 10
  2346 000006B5 44617461206572726F-     		db 'Data error'
  2346 000006BE 72                 
  2347 000006BF 21                      CRMSG5:		db 33
  2348 000006C0 496E76616C69642064-     		db 'Invalid device request parameters'
  2348 000006C9 657669636520726571-
  2348 000006D2 756573742070617261-
  2348 000006DB 6D6574657273       
  2349 000006E1 0A                      CRMSG6:		db 10
  2350 000006E2 5365656B206572726F-     		db 'Seek error'
  2350 000006EB 72                 
  2351 000006EC 12                      CRMSG7:		db 18
  2352 000006ED 496E76616C6964206D-     		db 'Invalid media type'
  2352 000006F6 656469612074797065 
  2353 000006FF 10                      CRMSG8:		db 16
  2354 00000700 536563746F72206E6F-     		db 'Sector not found'
  2354 00000709 7420666F756E64     
  2355 00000710 1A                      CRMSG9:		db 26
  2356 00000711 5072696E746572206F-     		db 'Printer out of paper error'
  2356 0000071A 7574206F6620706170-
  2356 00000723 6572206572726F72   
  2357 0000072B 11                      CRMSG10:	db 17
  2358 0000072C 577269746520666175-     		db 'Write fault error'
  2358 00000735 6C74206572726F72   
  2359 0000073D 10                      CRMSG11:	db 16
  2360 0000073E 52656164206661756C-     		db 'Read fault error'
  2360 00000747 74206572726F72     
  2361 0000074E 0F                      CRMSG12:	db 15
  2362 0000074F 47656E6572616C2066-     		db 'General failure'
  2362 00000758 61696C757265       
  2363 0000075E 11                      CRMSG13:	db 17
  2364 0000075F 53686172696E672076-     		db 'Sharing violation'
  2364 00000768 696F6C6174696F6E   
  2365 00000770 0E                      CRMSG14:	db 14
  2366 00000771 4C6F636B2076696F6C-     		db 'Lock violation'
  2366 0000077A 6174696F6E         
  2367 0000077F 13                      CRMSG15:	db 19
  2368 00000780 496E76616C69642064-     		db 'Invalid disk change'
  2368 00000789 69736B206368616E67-
  2368 00000792 65                 
  2369 00000793 0F                      CRMSG16:	db 15
  2370 00000794 46434220756E617661-     		db 'FCB unavailable'
  2370 0000079D 696C61626C65       
  2371 000007A3 19                      CRMSG17:	db 25
  2372 000007A4 53797374656D207265-     		db 'System resource exhausted'
  2372 000007AD 736F75726365206578-
  2372 000007B6 68617573746564     
  2373 000007BD 12                      CRMSG18:	db 18
  2374 000007BE 436F64652070616765-     		db 'Code page mismatch'
  2374 000007C7 206D69736D61746368 
  2375 000007D0 0C                      CRMSG19:	db 12
  2376 000007D1 4F7574206F6620696E-     		db 'Out of input'
  2376 000007DA 707574             
  2377 000007DD 17                      CRMSG20:	db 23
  2378 000007DE 496E73756666696369-     		db 'Insufficient disk space'
  2378 000007E7 656E74206469736B20-
  2378 000007F0 7370616365         
  2379                                  
  2380                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2381                                  
  2382 000007F5 [7206]                  CRITMSGPTRS:	dw CRMSG0
  2383 000007F7 [8606]                  		dw CRMSG1
  2384 000007F9 [9306]                  		dw CRMSG2
  2385 000007FB [9D06]                  		dw CRMSG3
  2386 000007FD [B406]                  		dw CRMSG4
  2387 000007FF [BF06]                  		dw CRMSG5
  2388 00000801 [E106]                  		dw CRMSG6
  2389 00000803 [EC06]                  		dw CRMSG7
  2390 00000805 [FF06]                  		dw CRMSG8
  2391 00000807 [1007]                  		dw CRMSG9
  2392 00000809 [2B07]                  		dw CRMSG10
  2393 0000080B [3D07]                  		dw CRMSG11
  2394 0000080D [4E07]                  		dw CRMSG12
  2395 0000080F [5E07]                  		dw CRMSG13
  2396 00000811 [7007]                  		dw CRMSG14
  2397 00000813 [7F07]                  		dw CRMSG15
  2398 00000815 [9307]                  		dw CRMSG16
  2399 00000817 [A307]                  		dw CRMSG17
  2400 00000819 [BD07]                  		dw CRMSG18
  2401 0000081B [D007]                  		dw CRMSG19
  2402 0000081D [DD07]                  		dw CRMSG20
  2403                                  
  2404                                  		; 14/01/2023
  2405                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2406                                  
  2407 0000081F 13                      PAERRMSG0:	db 19
  2408 00000820 546F6F206D616E7920-     		db 'Too many parameters'
  2408 00000829 706172616D65746572-
  2408 00000832 73                 
  2409 00000833 1A                      PAERRMSG1:	db 26
  2410 00000834 526571756972656420-     		db 'Required parameter missing'
  2410 0000083D 706172616D65746572-
  2410 00000846 206D697373696E67   
  2411 0000084E 0E                      PAERRMSG2:	db 14
  2412 0000084F 496E76616C69642073-     		db 'Invalid switch'
  2412 00000858 7769746368         
  2413 0000085D 0F                      PAERRMSG3:	db 15
  2414 0000085E 496E76616C6964206B-     		db 'Invalid keyword'
  2414 00000867 6579776F7264       
  2415 0000086D 01                      PAERRMSG4:	db 1
  2416 0000086E 20                      		db 20h
  2417 0000086F 24                      PAERRMSG5:	db 36
  2418 00000870 506172616D65746572-     		db 'Parameter value not in allowed range'
  2418 00000879 2076616C7565206E6F-
  2418 00000882 7420696E20616C6C6F-
  2418 0000088B 7765642072616E6765 
  2419                                  PAERRMSG6:	; 10/01/2023
  2420 00000894 1B                      PAERRMSG7:	db 27
  2421 00000895 506172616D65746572-     		db 'Parameter value not allowed'
  2421 0000089E 2076616C7565206E6F-
  2421 000008A7 7420616C6C6F776564 
  2422                                  ;PAERRMSG7:	db 27
  2423                                  ;		db 'Parameter value not allowed'
  2424 000008B0 1C                      PAERRMSG8:	db 28
  2425 000008B1 506172616D65746572-     		db 'Parameter format not correct'
  2425 000008BA 20666F726D6174206E-
  2425 000008C3 6F7420636F72726563-
  2425 000008CC 74                 
  2426 000008CD 11                      PAERRMSG9:	db 17
  2427 000008CE 496E76616C69642070-     		db 'Invalid parameter'
  2427 000008D7 6172616D65746572   
  2428 000008DF 1D                      PAERRMSG10:	db 29
  2429 000008E0 496E76616C69642070-     		db 'Invalid parameter combination'
  2429 000008E9 6172616D6574657220-
  2429 000008F2 636F6D62696E617469-
  2429 000008FB 6F6E               
  2430                                  
  2431                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2432                                  
  2433 000008FD [1F08]                  PARSMSGPTRS:	dw PAERRMSG0
  2434 000008FF [3308]                  		dw PAERRMSG1
  2435 00000901 [4E08]                  		dw PAERRMSG2
  2436 00000903 [5D08]                  		dw PAERRMSG3
  2437 00000905 [6D08]                  		dw PAERRMSG4
  2438 00000907 [6F08]                  		dw PAERRMSG5
  2439 00000909 [9408]                  		dw PAERRMSG6
  2440 0000090B [9408]                  		dw PAERRMSG7
  2441 0000090D [B008]                  		dw PAERRMSG8
  2442 0000090F [CD08]                  		dw PAERRMSG9
  2443 00000911 [DF08]                  		dw PAERRMSG10
  2444                                  ; 21/04/2023
  2445                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2446                                  
  2447 00000913 10                      INVLFUNCT:	db 16
  2448 00000914 496E76616C69642066-     		db 'Invalid function'
  2448 0000091D 756E6374696F6E     
  2449 00000924 0E                      FNOTFOUND:	db 14
  2450 00000925 46696C65206E6F7420-     		db 'File not found'
  2450 0000092E 666F756E64         
  2451 00000933 0E                      PNOTFOUND:	db 14
  2452 00000934 50617468206E6F7420-     		db 'Path not found'
  2452 0000093D 666F756E64         
  2453 00000942 13                      TOOMANYOF:	db 19
  2454 00000943 546F6F206D616E7920-     		db 'Too many open files'
  2454 0000094C 6F70656E2066696C65-
  2454 00000955 73                 
  2455                                  ; 14/01/2023
  2456                                  ;ACCDEN:	; 10/01/2023
  2457                                  ;ACCDENIED:	db 14
  2458                                  ;		db 'Access denied '
  2459 00000956 0E                      INVHANDLE:	db 14
  2460 00000957 496E76616C69642068-     		db 'Invalid handle'
  2460 00000960 616E646C65         
  2461 00000965 1F                      MEMCBDEST:	db 31
  2462 00000966 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2462 0000096F 6E74726F6C20626C6F-
  2462 00000978 636B73206465737472-
  2462 00000981 6F796564           
  2463 00000985 13                      INSUFFMEM:	db 19
  2464 00000986 496E73756666696369-     		db 'Insufficient memory'
  2464 0000098F 656E74206D656D6F72-
  2464 00000998 79                 
  2465 00000999 1C                      INVMEMBLA:	db 28
  2466 0000099A 496E76616C6964206D-     		db 'Invalid memory block address'
  2466 000009A3 656D6F727920626C6F-
  2466 000009AC 636B20616464726573-
  2466 000009B5 73                 
  2467 000009B6 13                      INVENVIRO:	db 19
  2468 000009B7 496E76616C69642045-     		db 'Invalid Environment'
  2468 000009C0 6E7669726F6E6D656E-
  2468 000009C9 74                 
  2469 000009CA 0E                      INVFORMAT:	db 14
  2470 000009CB 496E76616C69642066-     		db 'Invalid format'
  2470 000009D4 6F726D6174         
  2471 000009D9 1A                      INVFNPARM:	db 26
  2472 000009DA 496E76616C69642066-     		db 'Invalid function parameter'
  2472 000009E3 756E6374696F6E2070-
  2472 000009EC 6172616D65746572   
  2473 000009F4 0C                      INVLDDATA:	db 12
  2474 000009F5 496E76616C69642064-     		db 'Invalid data'
  2474 000009FE 617461             
  2475 00000A01 1B                      INVDRVSPC:	db 27
  2476 00000A02 496E76616C69642064-     		db 'Invalid drive specification'
  2476 00000A0B 726976652073706563-
  2476 00000A14 696669636174696F6E 
  2477 00000A1D 23                      ATRCURDIR:	db 35
  2478 00000A1E 417474656D70742074-     		db 'Attempt to remove current directory'
  2478 00000A27 6F2072656D6F766520-
  2478 00000A30 63757272656E742064-
  2478 00000A39 69726563746F7279   
  2479 00000A41 0F                      NOTSAMDEV:	db 15
  2480 00000A42 4E6F742073616D6520-     		db 'Not same device'
  2480 00000A4B 646576696365       
  2481 00000A51 0D                      NOMOREFIL:	db 13
  2482 00000A52 4E6F206D6F72652066-     		db 'No more files'
  2482 00000A5B 696C6573           
  2483 00000A5F 0B                      FILEXISTS:	db 11
  2484 00000A60 46696C652065786973-     		db 'File exists'
  2484 00000A69 7473               
  2485 00000A6B 1B                      CANTMKDIR:	db 27
  2486 00000A6C 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2486 00000A75 6B6520646972656374-
  2486 00000A7E 6F727920656E747279 
  2487 00000A87 0E                      FAILINT24:	db 14
  2488 00000A88 4661696C206F6E2049-     		db 'Fail on INT 24'
  2488 00000A91 4E54203234         
  2489 00000A96 15                      TOOMANYRD:	db 21
  2490 00000A97 546F6F206D616E7920-     		db 'Too many redirections'
  2490 00000AA0 726564697265637469-
  2490 00000AA9 6F6E73             
  2491 00000AAC 15                      DUPLREDIR:	db 21
  2492 00000AAD 4475706C6963617465-     		db 'Duplicate redirection'
  2492 00000AB6 207265646972656374-
  2492 00000ABF 696F6E             
  2493 00000AC2 10                      INVPASSWD:	db 16
  2494 00000AC3 496E76616C69642070-     		db 'Invalid password'
  2494 00000ACC 617373776F7264     
  2495 00000AD3 11                      INVLDPARM:	db 17
  2496 00000AD4 496E76616C69642070-     		db 'Invalid parameter'
  2496 00000ADD 6172616D65746572   
  2497 00000AE5 12                      NETDATFAU:	db 18
  2498 00000AE6 4E6574776F726B2064-     		db 'Network data fault'
  2498 00000AEF 617461206661756C74 
  2499 00000AF8 21                      FNOSUPNET:	db 33
  2500 00000AF9 46756E6374696F6E20-     		db 'Function not supported by network'
  2500 00000B02 6E6F7420737570706F-
  2500 00000B0B 72746564206279206E-
  2500 00000B14 6574776F726B       
  2501 00000B1A 27                      RSCNOTINS:	db 39
  2502 00000B1B 526571756972656420-     		db 'Required system component not installed'
  2502 00000B24 73797374656D20636F-
  2502 00000B2D 6D706F6E656E74206E-
  2502 00000B36 6F7420696E7374616C-
  2502 00000B3F 6C6564             
  2503                                  
  2504                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2505                                  
  2506 00000B42 [1309]                  EXTMSGPTRS:	dw INVLFUNCT
  2507 00000B44 [2409]                  		dw FNOTFOUND
  2508 00000B46 [3309]                  		dw PNOTFOUND
  2509 00000B48 [4209]                  		dw TOOMANYOF
  2510 00000B4A [BB05]                  		dw ACCDENIED
  2511 00000B4C [5609]                  		dw INVHANDLE
  2512 00000B4E [6509]                  		dw MEMCBDEST
  2513 00000B50 [8509]                  		dw INSUFFMEM
  2514 00000B52 [9909]                  		dw INVMEMBLA
  2515 00000B54 [B609]                  		dw INVENVIRO
  2516 00000B56 [CA09]                  		dw INVFORMAT
  2517 00000B58 [D909]                  		dw INVFNPARM
  2518 00000B5A [F409]                  		dw INVLDDATA
  2519 00000B5C 0000                    		dw 0
  2520 00000B5E [010A]                  		dw INVDRVSPC
  2521 00000B60 [1D0A]                  		dw ATRCURDIR
  2522 00000B62 [410A]                  		dw NOTSAMDEV
  2523 00000B64 [510A]                  		dw NOMOREFIL
  2524 00000B66 [7206]                  		dw CRMSG0
  2525 00000B68 [8606]                  		dw CRMSG1
  2526 00000B6A [9306]                  		dw CRMSG2
  2527 00000B6C [9D06]                  		dw CRMSG3
  2528 00000B6E [B406]                  		dw CRMSG4
  2529 00000B70 [BF06]                  		dw CRMSG5
  2530 00000B72 [E106]                  		dw CRMSG6
  2531 00000B74 [EC06]                  		dw CRMSG7
  2532 00000B76 [FF06]                  		dw CRMSG8
  2533 00000B78 [1007]                  		dw CRMSG9
  2534 00000B7A [2B07]                  		dw CRMSG10
  2535 00000B7C [3D07]                  		dw CRMSG11
  2536 00000B7E [4E07]                  		dw CRMSG12
  2537 00000B80 [5E07]                  		dw CRMSG13
  2538 00000B82 [7007]                  		dw CRMSG14
  2539 00000B84 [7F07]                  		dw CRMSG15
  2540 00000B86 [9307]                  		dw CRMSG16
  2541 00000B88 [A307]                  		dw CRMSG17
  2542 00000B8A [BD07]                  		dw CRMSG18
  2543 00000B8C [D007]                  		dw CRMSG19
  2544 00000B8E [DD07]                  		dw CRMSG20
  2545 00000B90 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2546 00000BE0 [5F0A]                  		dw FILEXISTS
  2547 00000BE2 0000                    		dw 0
  2548 00000BE4 [6B0A]                  		dw CANTMKDIR
  2549 00000BE6 [870A]                  		dw FAILINT24
  2550 00000BE8 [960A]                  		dw TOOMANYRD
  2551 00000BEA [AC0A]                  		dw DUPLREDIR
  2552 00000BEC [C20A]                  		dw INVPASSWD
  2553 00000BEE [D30A]                  		dw INVLDPARM
  2554 00000BF0 [E50A]                  		dw NETDATFAU
  2555 00000BF2 [F80A]                  		dw FNOSUPNET
  2556 00000BF4 [1A0B]                  		dw RSCNOTINS
  2557                                  ; ----------------------------------------------------------------------------
  2558                                  	; 17/04/2023
  2559                                  ExtMsgEnd:
  2560                                  
  2561                                  ; 21/04/2023
  2562                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2563                                  
  2564                                  ; ----------------------------------------------------------------------------
  2565                                  
  2566                                  ; 20/04/2023
  2567                                  
  2568 00000BF6 90<rep Ah>              align 16
  2569                                  
  2570                                  ; ----------------------------------------------------------------------------
  2571                                  
  2572                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2573                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2574                                  
  2575                                  ; ----------------------------------------------------------------------------
  2576                                  ; SEGMENT - CODERES
  2577                                  ; ----------------------------------------------------------------------------
  2578                                  
  2579                                  ; 11/01/2023
  2580                                  RCODE_START:	
  2581                                  
  2582                                  ; ----------------------------------------------------------------------------
  2583                                  ;***	EXEC error handling
  2584                                  ;
  2585                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2586                                  ;	We examine the error code and select an appropriate message.
  2587                                  ; --------------------------
  2588                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2589                                  ;	Condense the error scan?
  2590                                  ;	RBADNAM is checked by transient, no need here?
  2591                                  ;	Move below Ext_Exec.
  2592                                  ; ----------------------------------------------------------------------------
  2593                                  
  2594                                  Exec_Err:
  2595                                  ;SR;
  2596                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2597                                  ; in order here
  2598                                  
  2599                                  ;	Bugbug:	can we use byte compares here?
  2600                                  ;	Might be able to use byte msg#s, too.
  2601                                  
  2602                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2603                                  ;	Speed not high priority here.
  2604                                  
  2605                                  ;	Move this to transient.
  2606                                  
  2607                                  	; 10/01/2023
  2608                                  
  2609                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2610 00000C00 BA[A005]                	mov	dx,RBADNAM
  2611 00000C03 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2612 00000C05 741B                    	je	short GotExecEMes		; bad command
  2613                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2614 00000C07 BA[6605]                	mov	dx,TOOBIG
  2615 00000C0A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2616 00000C0C 7414                    	je	short GotExecEMes		; file not found
  2617                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2618 00000C0E BA[5205]                	mov	dx,EXEBAD
  2619 00000C11 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2620 00000C13 740D                    	je	short GotExecEMes		; bad exe file
  2621                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2622 00000C15 BA[BB05]                	mov	dx,ACCDEN
  2623 00000C18 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2624 00000C1A 7406                    	je	short GotExecEMes		; access denied
  2625                                  
  2626                                  Default_Message:
  2627                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2628 00000C1C BA[3E05]                	mov	dx,EXECEMES
  2629                                  						; default message
  2630 00000C1F BE[1B01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2631                                  						; get address of subst block
  2632                                  GotExecEMes:
  2633                                  	;mov	dx,bx				; DX = ptr to msg
  2634 00000C22 E85006                  	call	RPrint ; invoke	RPrint
  2635 00000C25 EB09                    	jmp	short NoExec
  2636                                  
  2637                                  ; ----------------------------------------------------------------------------
  2638                                  ;***	EXEC call
  2639                                  ;
  2640                                  ;	The transient has set up everything for an EXEC system call.
  2641                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2642                                  ;	so that we may be able to recover cleanly upon success.
  2643                                  ;
  2644                                  ;	CS,DS,ES,SS = DATARES seg addr
  2645                                  ; ----------------------------------------------------------------------------
  2646                                  
  2647                                  Ext_Exec:
  2648                                  ;SR;
  2649                                  ; The words put on the stack by the stub will be popped off when we finally
  2650                                  ;jump to LodCom (by LodCom).
  2651                                  
  2652                                  	; 10/01/2023
  2653                                  	;int	21h			; do the exec
  2654                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2655                                  Exec_Ret:
  2656 00000C27 72D7                    	jc	short Exec_Err		; exec failed
  2657                                  
  2658                                  ;	The exec has completed. Retrieve the exit code.
  2659                                  
  2660                                  Exec_Wait:
  2661 00000C29 B44D                    	mov	ah,4Dh
  2662                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2663 00000C2B CD21                    	int	21h			; get the return code
  2664                                  	;mov	[cs:RetCode],ax
  2665                                  	; 11/01/2023
  2666 00000C2D A3[8501]                	mov	[RetCode],ax
  2667                                  
  2668                                  ;	See if we can reload the transient. The external command
  2669                                  ;	may have overwritten part of the transient.
  2670                                  
  2671                                  NoExec:
  2672                                  ;SR;
  2673                                  ; ds = es = ss = DATARES when we jump to LodCom
  2674                                  ;
  2675 00000C30 E97701                  	jmp	LodCom
  2676                                  
  2677                                  ; ----------------------------------------------------------------------------
  2678                                  ;***	Int 23 (ctrl-c) handler
  2679                                  ;
  2680                                  ;	This is the default system INT 23 handler. All processes
  2681                                  ;	(including COMMAND) get it by default. There are some
  2682                                  ;	games that are played: We ignore ^C during most of the
  2683                                  ;	INIT code. This is because we may perform an ALLOC and
  2684                                  ;	diddle the header! Also, if we are prompting for date/time
  2685                                  ;	in the init code, we are to treat ^C as empty responses.
  2686                                  ; ---------------------------
  2687                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2688                                  ; ----------------------------------------------------------------------------
  2689                                  
  2690                                  ;SR;
  2691                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2692                                  ;both these values off the stack now
  2693                                  ;
  2694                                  ;ContC	proc	far
  2695                                  
  2696                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2697                                  
  2698                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2699                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2700                                  ContC:
  2701 00000C33 1F                      	pop	ds			; ds = DATARES
  2702                                  ;	assume	ds:DATARES
  2703                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2704                                  
  2705 00000C34 F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1
  2706                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2707 00000C39 740D                    	jz	short NotAtInit		; no
  2708 00000C3B F606[FF01]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2709                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2710 00000C40 7404                    	jz	short CmdIret		; no, ignore ^C
  2711 00000C42 1F                      	pop	ds			; restore before jumping; M021
  2712                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2713 00000C43 E9E80D                  	jmp	init_contc_specialcase
  2714                                  CmdIret:
  2715                                  ;SR;
  2716                                  ; Restore ds to its previous value
  2717                                  ;
  2718                                  
  2719                                  ;;	mov	ds,[OLdDS]		;
  2720 00000C46 1F                      	pop	ds
  2721 00000C47 CF                      	iret				; yes, ignore the ^C
  2722                                  
  2723                                  NotAtInit:
  2724 00000C48 F606[FF01]04            	test	byte [InitFlag],INITCTRLC ; 4
  2725                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2726 00000C4D 7411                    	jz	short NotInit 		; nope too.
  2727                                  
  2728                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2729                                  ;	to set carry and return to the user sans flags only if the
  2730                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2731                                  
  2732                                  	;cmp	ah,1
  2733                                  	;jb	short CmdIret
  2734                                  	; 19/07/2024
  2735 00000C4F 84E4                    	test	ah,ah
  2736 00000C51 74F3                    	jz	short CmdIret
  2737                                  
  2738 00000C53 80FC0C                  	cmp	ah,12
  2739 00000C56 77EE                    	ja	short CmdIret
  2740                                  
  2741 00000C58 1F                      	pop	ds			;restore ds to old value
  2742 00000C59 83C406                  	add	sp,6			; remove int frame
  2743 00000C5C F9                      	stc
  2744                                  
  2745                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2746 00000C5D CA0200                  	retf	2			; remove those flags...
  2747                                  
  2748                                  NotInit:
  2749                                  
  2750                                  ;*	We have now received a ^C for some process (maybe ourselves
  2751                                  ;	but not at INIT).
  2752                                  ;	
  2753                                  ;	Note that we are running on the user's stack!!! Bad news if
  2754                                  ;	any of the system calls below go and issue another INT
  2755                                  ;	24... Massive stack overflow! Another bad point is that
  2756                                  ;	SavHand will save an already saved handle, thus losing a
  2757                                  ;	possible redirection...
  2758                                  ;	
  2759                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2760                                  ;	The above code will correctly flag the ^C diring the
  2761                                  ;	message output and prompting while ignoring the ^C the rest
  2762                                  ;	of the time.
  2763                                  ;	
  2764                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2765                                  ;	file, we ask if he wants to terminate it. If he does, then
  2766                                  ;	we turn off all internal flags and let the DOS abort.
  2767                                  
  2768 00000C60 800E[FF01]04            	or	byte [InitFlag],INITCTRLC ; 4
  2769                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2770 00000C65 FB                      	sti
  2771                                  
  2772                                  ;	push	cs			; el yucko! change the user's ds!!
  2773                                  ;	pop	ds
  2774                                  
  2775                                  ;	assume	ds:RESGROUP
  2776                                  
  2777 00000C66 58                      	pop	ax			; discard the old ds value
  2778                                  
  2779 00000C67 A1[8E01]                	mov	ax,[SingleCom]
  2780 00000C6A 09C0                    	or	ax,ax
  2781 00000C6C 7506                    	jnz	short NoReset
  2782 00000C6E 50                      	push	ax
  2783 00000C6F B40D                    	mov	ah,DISK_RESET ; 0Dh
  2784 00000C71 CD21                    	int	21h			; reset disks in case files were open
  2785 00000C73 58                      	pop	ax
  2786                                  
  2787                                  NoReset:
  2788                                  
  2789                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2790                                  ;	walk the entire active list and free each segment. Here,
  2791                                  ;	we just free the single batch segment.
  2792                                  
  2793 00000C74 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2794 00000C7A 7451                    	jz	short ContCTerm
  2795 00000C7C 09C0                    	or	ax,ax
  2796 00000C7E 754D                    	jnz	short ContCTerm
  2797 00000C80 E88402                  	call	SavHand
  2798 00000C83 E89203                  	call	AskEnd			; ask if user wants to end batch
  2799                                  
  2800                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2801                                  
  2802 00000C86 733F                    	jnc	short ContBatch
  2803 00000C88 8A0E[8801]              	mov	cl,[EchoFlag]		; get current echo flag
  2804 00000C8C 53                      	push	bx
  2805                                  
  2806                                  ClearBatch:
  2807 00000C8D 8E06[3401]              	mov	es,[Batch]		; get batch segment
  2808                                  	;mov	di,20h
  2809                                  	; 06/06/2023 (BugFix)
  2810 00000C91 BF2000                  	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
  2811                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2812                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2813 00000C94 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2814                                  	; MSDOS 3.3 ([ES:4])
  2815                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2816                                  	;
  2817                                  	; 19/07/2024
  2818                                  	;cmp	bx,0			; is a FOR in progress
  2819                                  	;je	short No_Bat_For	; no - don't deallocate
  2820 00000C99 85DB                    	test	bx,bx
  2821 00000C9B 7408                    	jz	short No_Bat_For
  2822                                  
  2823 00000C9D 06                      	push	es			;
  2824 00000C9E 8EC3                    	mov	es,bx			; yes - free it up...
  2825 00000CA0 B449                    	mov	ah,49h
  2826                                  	;mov	ah,DEALLOC ; 49h	;
  2827 00000CA2 CD21                    	int	21h			;
  2828 00000CA4 07                      	pop	es			; restore to batch segment
  2829                                  
  2830                                  No_Bat_For:
  2831                                  	;mov	cl,[es:1]
  2832 00000CA5 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2833                                  	;mov	bx,[es:3]
  2834 00000CAA 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2835 00000CAF B449                    	mov	ah,49h
  2836                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2837 00000CB1 CD21                    	int	21h
  2838 00000CB3 891E[3401]              	mov	[Batch],bx		; get ready to deallocate next batch
  2839 00000CB7 FF0E[9701]              	dec	word [Nest]		; is there another batch file?
  2840 00000CBB 75D0                    	jnz	short ClearBatch	; keep going until no batch file
  2841                                  
  2842                                  ;	We are terminating a batch file; restore the echo status
  2843                                  
  2844                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2845 00000CBD 5B                      	pop	bx
  2846 00000CBE 880E[8801]              	mov	[EchoFlag],cl		; reset echo status
  2847                                  	; 29/05/2018
  2848 00000CC2 C606[0002]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2849                                  
  2850                                  ContBatch:
  2851 00000CC7 E8A805                  	call	crlf			; print out crlf before returning
  2852 00000CCA E86302                  	call	RestHand
  2853                                  
  2854                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2855                                  
  2856                                  ContCTerm:
  2857 00000CCD 31C0                    	xor	ax,ax			; indicate no read
  2858 00000CCF 89C5                    	mov	bp,ax
  2859                                  
  2860                                  ;	The following resetting of the state flags is good for the
  2861                                  ;	generalized batch processing.
  2862                                  
  2863 00000CD1 A2[9301]                	mov	[IfFlag],al		; turn off iffing
  2864 00000CD4 A2[9401]                	mov	[ForFlag],al		; turn off for processing
  2865 00000CD7 E81C00                  	call	ResPipeOff
  2866 00000CDA 3906[8E01]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2867 00000CDE 7406                    	jz	short NoSetSing
  2868 00000CE0 C706[8E01]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2869                                  					;  pipe, batch, for
  2870                                  NoSetSing:
  2871                                  
  2872                                  ;	If we are doing an internal command, go through the reload process.
  2873                                  ;	If we are doing an external, let DOS abort the process.
  2874                                  ;	In both cases, we are now done with the ^C processing.
  2875                                  
  2876 00000CE6 8026[FF01]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2877 00000CEB 3806[8401]              	cmp	[ExtCom],al
  2878 00000CEF 7503                    	jnz	short DoDAb		; internal ^c
  2879 00000CF1 E94501                  	jmp	LodCom1
  2880                                  DoDAb:
  2881 00000CF4 F9                      	stc				; tell dos to abort
  2882                                  
  2883                                  ;SR;
  2884                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2885                                  ;by setting carry and leaving flags on the stack
  2886                                  
  2887 00000CF5 CB                      	retf				; Leave flags on stack
  2888                                  
  2889                                  ;ContC	endp
  2890                                  
  2891                                  ;SR;
  2892                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2893                                  ;both have ds = DATARES
  2894                                  
  2895                                  	; 11/01/2023
  2896                                  ResPipeOff:
  2897 00000CF6 50                      	push	ax
  2898 00000CF7 31C0                    	xor	ax,ax
  2899                                  	;xchg	al,[cs:PIPEFLAG]
  2900 00000CF9 8606[0002]              	xchg	al,[PipeFlag]
  2901 00000CFD 08C0                    	or	al,al
  2902 00000CFF 7404                    	jz	short NoPipePop
  2903                                  	;shr	byte [cs:ECHOFLAG],1
  2904 00000D01 D02E[8801]              	shr	byte [EchoFlag],1
  2905                                  NoPipePop:
  2906 00000D05 58                      	pop	ax
  2907 00000D06 C3                      	retn
  2908                                  
  2909                                  ;CODERES ends
  2910                                  
  2911                                  ;=============================================================================
  2912                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2913                                  ;=============================================================================
  2914                                  ; 21/09/2018 - Retro DOS v3.0
  2915                                  
  2916                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2917                                  ;	name	COMMAND2
  2918                                  
  2919                                  ;/*
  2920                                  ; *                      Microsoft Confidential
  2921                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2922                                  ; *                      All Rights Reserved.
  2923                                  ; */
  2924                                  
  2925                                  ;
  2926                                  ;	Revision History
  2927                                  ;	================
  2928                                  ;
  2929                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2930                                  ;			reserve memory by changing int 12h and then give it
  2931                                  ;			back to DOS by changing arenas in autoexec.bat.
  2932                                  ;			This makes command.com reload transient and this
  2933                                  ;			cannot be done at this stage.
  2934                                  ;
  2935                                  
  2936                                  ;CODERES segment public byte
  2937                                  
  2938                                  ;*	If we cannot allocate enough memory for the transient or there
  2939                                  ;	was some other allocation error, we display a message and
  2940                                  ;	then die.
  2941                                  
  2942                                  ;SR;
  2943                                  ; We will have to make sure that at this entry point and at FatalC, 
  2944                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2945                                  ;and so we should be able to do this
  2946                                  
  2947                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2948                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2949                                  
  2950                                  	;assume	ds:DATARES
  2951                                  BadMemErr:
  2952 00000D07 BA[C905]                	mov	dx,BMEMMES			; DX = ptr to msg
  2953                                  FatalC:
  2954                                  	; 12/01/2023
  2955                                  ;;	push	cs
  2956                                  ;;	pop	ds
  2957                                  ;;	assume	ds:ResGroup
  2958                                  ;	invoke	RPrint
  2959                                  
  2960                                  	; 12/01/2023
  2961                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2962 00000D0A E86805                  	call	RPrint
  2963                                  
  2964                                  	; MSDOS 3.3
  2965                                  	;call	RDISPMSG
  2966                                  
  2967                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2968                                  ;	we can't do anything else!
  2969                                  
  2970 00000D0D 803E[8D01]00            	cmp	byte [PermCom],0
  2971 00000D12 7410                    	je	short FatalRet
  2972                                  
  2973                                  ;	We are a permanent command. If we are in the process of the
  2974                                  ;	magic interrupt (Singlecom) then exit too.
  2975                                  
  2976 00000D14 833E[8E01]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2977 00000D19 7509                    	jne	short FatalRet			; must take int_2e exit
  2978                                  
  2979                                  ;	Permanent command. We can't do ANYthing except halt.
  2980                                  
  2981 00000D1B BA[E305]                	mov	dx,HALTMES			; DX = ptr to msg
  2982                                  	;invoke	RPrint
  2983                                  	; 12/01/2023	
  2984                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2985 00000D1E E85405                  	call	RPrint	
  2986                                  	; MSDOS 3.3
  2987                                  	;call	RDISPMSG
  2988 00000D21 FB                      	sti
  2989                                  Stall:
  2990 00000D22 EBFE                    	jmp	short Stall			; crash the system nicely
  2991                                  
  2992                                  FatalRet:
  2993 00000D24 BA[0A06]                	mov	dx,FRETMES			; DX = ptr to msg
  2994                                  	;call	RDISPMSG
  2995                                  	; 12/01/2023	
  2996 00000D27 E84B05                  	call	RPrint	
  2997                                  FatalRet2:
  2998 00000D2A 803E[8D01]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  2999 00000D2F 7517                    	jne	short Ret_2e			; must be int_2e
  3000                                  
  3001                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3002                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3003                                  ;	case we decide to do that.)
  3004                                  
  3005 00000D31 A1[2901]                	mov	ax,[Parent]
  3006                                  	;mov	[16h],ax
  3007 00000D34 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3008 00000D37 A1[2B01]                	mov	ax,[OldTerm]
  3009                                  	;mov	[0Ah],ax
  3010 00000D3A A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3011 00000D3D A1[2D01]                	mov	ax,[OldTerm+2]
  3012                                  	;mov	[0Ch],ax
  3013 00000D40 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3014 00000D43 B8004C                  	mov	ax,4C00h
  3015                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3016 00000D46 CD21                    	int	21h
  3017                                  Ret_2e:
  3018                                  ;SR;
  3019                                  ; We will ensure that ds = DATARES for all entries to this place
  3020                                  ;
  3021                                  
  3022                                  ;;	push	cs
  3023                                  ;;	pop	ds
  3024                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3025                                    	
  3026                                  ;	assume	ds:DATARES
  3027                                  
  3028                                  	;PUSH	CS
  3029                                  	;POP	DS
  3030                                  
  3031 00000D48 C706[8E01]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3032 00000D4E 8E06[4703]              	mov	es,[Res_Tpa]
  3033                                  	;mov	ah,49h	; 12/01/2023
  3034 00000D52 B449                    	mov	ah,DEALLOC
  3035 00000D54 CD21                    	int	21h			; free up space used by transient
  3036 00000D56 8B1E[2701]              	mov	bx,[Save_Pdb]
  3037 00000D5A B450                    	mov	ah,50h
  3038                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3039 00000D5C CD21                    	int	21h			; current process is user
  3040 00000D5E A1[8501]                	mov	ax,[RetCode]
  3041 00000D61 803E[8401]00            	cmp	byte [ExtCom],0
  3042 00000D66 7502                    	jne	short GotECode
  3043 00000D68 31C0                    	xor	ax,ax			; internals always return 0
  3044                                  GotECode:
  3045 00000D6A C606[8401]01            	mov	byte [ExtCom],1		; force external
  3046                                  
  3047                                  ;SR; This is actually returning to the caller. However, the old code had
  3048                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3049                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3050                                  
  3051                                  	; 12/01/2023
  3052 00000D6F FF2E[2301]              	jmp	far [Int_2e_Ret]	; "iret"
  3053                                  
  3054                                  ;***	Int_2e, magic command executer
  3055                                  
  3056                                  Int_2e:
  3057                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3058                                  ;SR;
  3059                                  ;We are going to come here from the stub with the old ds and DATARES value
  3060                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3061                                  
  3062                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3063                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3064                                  
  3065 00000D73 1F                      	pop	ds			; ds = DATARES
  3066                                  	;assume	ds:DATARES
  3067 00000D74 58                      	pop	ax
  3068                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3069                                  
  3070                                  	;pop	word [cs:Int_2e_Ret]
  3071                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3072                                  	;pop	ax			; chuck flags
  3073 00000D75 8F06[2301]              	pop	word [Int_2e_Ret]
  3074 00000D79 8F06[2501]              	pop	word [Int_2e_Ret+2]
  3075                                  	
  3076 00000D7D 83C402                  	add	sp,2
  3077                                  
  3078                                  ;;	push	cs
  3079                                  ;;	pop	es
  3080                                  
  3081 00000D80 1E                      	push	ds
  3082 00000D81 07                      	pop	es			; es = DATARES
  3083                                  ;	;mov	ds,OldDS
  3084 00000D82 8ED8                    	mov	ds,ax
  3085                                  	;assume	ds:nothing		; ds = old value
  3086                                  
  3087 00000D84 BF8000                  	mov	di,80h
  3088 00000D87 B94000                  	mov	cx,64
  3089                                  ;	Bugbug:	cld
  3090 00000D8A F3A5                    	rep	movsw
  3091 00000D8C B451                    	mov	ah,51h
  3092                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3093 00000D8E CD21                    	int	21h			; get user's header
  3094                                  	; 12/01/2023
  3095 00000D90 26891E[2701]            	mov	[es:Save_Pdb],bx
  3096                                  	;mov	[cs:Save_Pdb],bx
  3097 00000D95 B450                    	mov	ah,50h
  3098                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3099                                  
  3100                                  ;;	mov	bx,cs
  3101                                  ;SR;
  3102                                  ;Set ds = DATARES because BadMemErr expects this
  3103                                  
  3104                                  	; 12/01/2023
  3105 00000D97 06                      	push	es
  3106 00000D98 1F                      	pop	ds
  3107                                  	;assume	ds:DATARES
  3108                                  
  3109 00000D99 8CDB                    	mov	bx,ds			; es = our PSP now
  3110                                  	;mov	bx,cs
  3111                                  
  3112 00000D9B CD21                    	int	21h			; current process is me
  3113                                  	;mov	word [cs:SingleCom],81h
  3114                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3115                                  	; 12/01/2023
  3116 00000D9D C706[8E01]8100          	mov	word [SingleCom],81h
  3117 00000DA3 C606[8401]01            	mov	byte [ExtCom],1		; make sure this case forced
  3118                                  
  3119                                  ;SR;
  3120                                  ;We can enter LodCom directly after a command shell is terminated or we
  3121                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3122                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3123                                  ;be properly set. To fake this, we push dummy values here.
  3124                                  
  3125                                  	; 12/01/2023
  3126 00000DA8 1E                      	push	ds			; old value of ds
  3127 00000DA9 1E                      	push	ds			; data seg value, ds = DATARES
  3128                                  LodCom: 				; termination handler
  3129 00000DAA 1F                      	pop	ds			; ds = DATARES
  3130                                  	;assume	ds:DATARES
  3131 00000DAB 83C402                  	add	sp,2
  3132                                  ;	;pop	OldDS			; store old ds
  3133                                  	;cmp	ExtCom,0
  3134 00000DAE 803E[8401]00            	cmp	byte [ExtCom],0
  3135                                  	;cmp	byte [cs:ExtCom],0
  3136                                  	;jne	short @f	 	; internal cmd - memory allocated
  3137                                  	; 16/04/2023
  3138 00000DB3 7503                    	jne	short LodCom0 ; 24/09/2018
  3139 00000DB5 E98100                  	jmp	LodCom1
  3140                                  	;je	short LodCom1 ; 25/09/2018	
  3141                                  ;@@:
  3142                                  LodCom0: ; 24/09/2018
  3143 00000DB8 BBFFFF                  	mov	bx,0FFFFh
  3144 00000DBB B448                    	mov	ah,48h	; 12/01/2023
  3145                                  	;mov	ah,ALLOC ; 48h	
  3146 00000DBD CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3147                                  				; BX = number of 16-byte paragraphs desired
  3148 00000DBF E80A00                  	call	SetSize
  3149 00000DC2 83C020                  	add	ax,20h
  3150 00000DC5 39C3                    	cmp	bx,ax
  3151 00000DC7 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3152                                  BadMemErrJ:
  3153 00000DC9 E93BFF                  	jmp	BadMemErr		; not enough memory
  3154                                  
  3155                                  ;***	SetSize - get transient size in paragraphs
  3156                                  
  3157                                  SetSize:
  3158                                  	; 12/01/2023
  3159                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3160                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3161 00000DCC B8A395                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3162 00000DCF B104                    	mov	cl,4
  3163 00000DD1 D3E8                    	shr	ax,cl
  3164 00000DD3 C3                      	retn
  3165                                  
  3166                                  MemOk:
  3167                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3168                                  
  3169 00000DD4 B448                    	mov	ah,48h
  3170                                  	;mov	ah,ALLOC  ; 48h
  3171 00000DD6 CD21                    	int	21h
  3172 00000DD8 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3173                                  	;mov	byte [cs:ExtCom],0
  3174                                  	;mov	[cs:Res_Tpa],ax
  3175                                  	; 12/01/2023
  3176 00000DDA C606[8401]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3177 00000DDF A3[4703]                	mov	[Res_Tpa],ax		; save current tpa segment
  3178                                  
  3179 00000DE2 2500F0                  	and	ax,0F000h
  3180 00000DE5 050010                  	add	ax,1000h		; round up to next 64k boundary
  3181 00000DE8 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3182                                  
  3183                                  ;	Make sure that new boundary is within allocated range
  3184                                  
  3185                                  	;mov	dx,[cs:Res_Tpa]
  3186                                  	; 12/01/2023
  3187 00000DEA 8B16[4703]              	mov	dx,[Res_Tpa]
  3188 00000DEE 01DA                    	add	dx,bx			; compute maximum address
  3189 00000DF0 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3190 00000DF2 7608                    	jbe	short Bad_Tpa
  3191                                  
  3192                                  ;	Must have 64K of usable space.
  3193                                  
  3194 00000DF4 29C2                    	sub	dx,ax			; compute the usable space
  3195 00000DF6 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3196 00000DFA 7303                    	jae	short LTpaSet
  3197                                  Bad_Tpa:
  3198                                  	;mov	ax,[cs:Res_Tpa]
  3199                                  	; 12/01/2023
  3200 00000DFC A1[4703]                	mov	ax,[Res_Tpa]
  3201                                  LTpaSet:
  3202                                  	;mov	[cs:LTPA],ax
  3203                                  	;mov	ax,[cs:Res_Tpa]
  3204                                  	; 12/01/2023
  3205 00000DFF A3[3903]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3206 00000E02 A1[4703]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3207 00000E05 01C3                    	add	bx,ax
  3208                                  	;mov	[cs:MemSiz],bx
  3209 00000E07 891E[8001]              	mov	[MemSiz],bx
  3210 00000E0B E8BEFF                  	call	SetSize
  3211 00000E0E 29C3                    	sub	bx,ax
  3212                                  
  3213                                  	; MSDOS 6.0
  3214                                  
  3215                                  ;M038; Start of changes
  3216                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3217                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3218                                  ;running a program that changes arenas. This changes the largest block that
  3219                                  ;command.com gets and so changes the transient segment. So, command.com does
  3220                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3221                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3222                                  ;reload fails, hanging the system. To get around this we just copy the
  3223                                  ;transient from the previous address to the new address(if changed) and
  3224                                  ;then let command.com do the checksum. So, if the transient area is not
  3225                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3226                                  ;is not really corrupted and so this should work.
  3227                                  
  3228                                  	; 12/01/2023
  3229                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3230                                  
  3231 00000E10 3B1E[7A01]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3232 00000E14 7423                    	je	short LodCom1		; yes, dont copy
  3233                                  
  3234                                  ;Check if the new segment is above or below the current move. If the new
  3235                                  ;segment is above (i.e new block is larger than previous block), then we
  3236                                  ;have to move in the reverse direction
  3237                                  
  3238                                  	;mov	cx,98C5h
  3239 00000E16 B99495                  	mov	cx,TRANSPACEEND		; cx = length to move
  3240 00000E19 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3241 00000E1B 31F6                    	xor	si,si			; normal move
  3242 00000E1D 89F7                    	mov	di,si
  3243 00000E1F FC                      	cld
  3244 00000E20 EB06                    	jmp	short copy_trans
  3245                                  mov_down:
  3246 00000E22 89CE                    	mov	si,cx			; reverse move, start from end
  3247 00000E24 4E                      	dec	si
  3248 00000E25 89F7                    	mov	di,si
  3249 00000E27 FD                      	std
  3250                                  copy_trans:
  3251 00000E28 1E                      	push	ds
  3252 00000E29 06                      	push	es
  3253 00000E2A 8EC3                    	mov	es,bx			; dest segment
  3254 00000E2C 8E1E[7A01]              	mov	ds,[TrnSeg]		; source segment
  3255                                  	;assume	ds:nothing
  3256                                  
  3257 00000E30 F3A4                    	rep	movsb			; copy transient
  3258 00000E32 FC                      	cld
  3259 00000E33 07                      	pop	es
  3260 00000E34 1F                      	pop	ds
  3261                                  	;assume	ds:DATARES
  3262                                  
  3263                                  ;M038; End of changes
  3264                                  
  3265                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3266                                  	; 12/01/2023
  3267 00000E35 891E[7A01]              	mov	[TrnSeg],bx
  3268                                  
  3269                                  LodCom1:
  3270                                  ;;	mov	ax,cs
  3271                                  ;;	mov	ss,ax
  3272                                  ;SR; At this point ds = DATARES which is where the stack is located
  3273                                  
  3274                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3275                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3276 00000E39 8CD8                    	mov	ax,ds
  3277 00000E3B 8ED0                    	mov	ss,ax
  3278                                  	;assume	ss:DATARES
  3279                                  	;;mov	sp,offset DATARES:RStack
  3280                                  	;mov	sp,53Eh
  3281 00000E3D BC[2004]                	mov	sp,RStack
  3282                                  
  3283                                  ;;	mov	ds,ax
  3284                                  
  3285                                  	;assume	ds:DATARES
  3286                                  	
  3287                                  	; MSDOS 3.3
  3288                                  	;mov	ax,cs
  3289                                  	;mov	ss,ax
  3290                                  	;mov	sp,RSTACK
  3291                                  	;mov	ds,ax
  3292                                  
  3293 00000E40 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3294 00000E43 31ED                    	xor	bp,bp			; flag command ok
  3295 00000E45 B8FFFF                  	mov	ax,-1
  3296 00000E48 8706[9001]              	xchg	ax,[VerVal]
  3297 00000E4C 83F8FF                  	cmp	ax,-1
  3298 00000E4F 7404                    	je	short NoSetVer
  3299 00000E51 B42E                    	mov	ah,2Eh
  3300                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3301 00000E53 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3302                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3303                                  NoSetVer:
  3304 00000E55 833E[8E01]FF            	cmp	word [SingleCom],-1
  3305 00000E5A 7503                    	jne	short NoSng
  3306 00000E5C E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3307                                  NoSng:
  3308 00000E5F E87201                  	call	ChkSum			; check the transient
  3309                                  	;cmp	dx,[Sum]
  3310                                  	;je	short HavCom		; transient ok
  3311                                  	; 12/01/2023
  3312 00000E62 7412                    	jz	short HavCom
  3313                                  Bogus_Com:
  3314 00000E64 C606[3301]01            	mov	byte [Loading],1	; flag DskErr routine
  3315 00000E69 E81E01                  	call	LoadCom
  3316                                  ChkSame:
  3317 00000E6C E86501                  	call	ChkSum
  3318                                  	;cmp	dx,[Sum]
  3319                                  	;je	short HavCom		; same command
  3320                                  	; 12/01/2023
  3321 00000E6F 7405                    	jz	short HavCom
  3322                                  Also_Bogus:
  3323 00000E71 E85801                  	call	WrongCom
  3324 00000E74 EBF6                    	jmp	short ChkSame
  3325                                  
  3326                                  	; 12/01/2023
  3327                                  ;HavCom:
  3328                                  ;	; 25/09/2018
  3329                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3330                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3331                                  ;			; Return: AL = FFh unsupported subfunction
  3332                                  ;			; DL = current switch character
  3333                                  ;	mov     [RSWITCHAR],dl
  3334                                  ;	cmp     dl,'/'
  3335                                  ;	jnz     short USESLASH
  3336                                  ;	;mov	cl,'\'
  3337                                  ;	;mov	[RDIRCHAR],cl
  3338                                  ;	mov	byte [RDIRCHAR],'\'
  3339                                  ;USESLASH:
  3340                                  
  3341                                  HavCom:
  3342                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3343 00000E76 C606[3301]00            	mov	byte [Loading],0		; flag to DskErr
  3344                                  	;;mov	si,offset DATARES:TranVars
  3345                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3346 00000E7B BE[3503]                	mov	si,TranVars
  3347                                  	;;mov	di,offset TRANGROUP:HeadCall
  3348                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3349 00000E7E BF[C38A]                	mov	di,HEADCALL
  3350 00000E81 8E06[7A01]              	mov	es,[TrnSeg]
  3351 00000E85 FC                      	cld
  3352                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3353 00000E86 B9[4903]                	mov	cx,TranVarEnd
  3354 00000E89 29F1                    	sub	cx,si
  3355 00000E8B F3A4                    	rep	movsb			; transfer info to transient
  3356 00000E8D A1[8001]                	mov	ax,[MemSiz]
  3357 00000E90 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3358                                  
  3359                                  ;***	TJmp - jump-off to transient
  3360                                  ;
  3361                                  ;	Public label so debugger can find this spot.
  3362                                  
  3363                                  TJmp:	; 12/01/2023
  3364 00000E93 FF2E[7801]              	jmp	far [Trans]		; jmp dword ptr Trans
  3365                                  
  3366                                  ;***	TRemCheck - far version of RemCheck for transient
  3367                                  
  3368                                  TRemCheck:
  3369                                  	; 12/01/2023
  3370 00000E97 1F                      	pop	ds			; ds = DATARES
  3371 00000E98 83C402                  	add	sp,2			; discard old value of ds
  3372                                  
  3373 00000E9B E80100                  	call	RemCheck
  3374 00000E9E CB                      	retf
  3375                                  
  3376                                  ;***	RemCheck
  3377                                  ;
  3378                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3379                                  ;
  3380                                  ;	EXIT	ZR set if removeable media
  3381                                  ;		ZR clear if fixed media
  3382                                  ;
  3383                                  ;	USED	none
  3384                                  
  3385                                  	; 12/01/2023
  3386                                  RemCheck:
  3387 00000E9F 50                      	push	ax
  3388 00000EA0 53                      	push	bx
  3389 00000EA1 89C3                    	mov	bx,ax
  3390 00000EA3 B80844                  	mov	ax,4408h
  3391                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3392 00000EA6 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3393 00000EA8 7304                    	jnc	short rcCont		
  3394                                  
  3395                                  ;	If an error occurred, assume the media is non-removable.
  3396                                  ;	AX contains the non-zero error code from the int 21, so
  3397                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3398                                  ;	appear to be non-removable.				
  3399                                  					
  3400 00000EAA 09C0                    	or	ax,ax			
  3401 00000EAC EB05                    	jmp	short ResRegs
  3402                                  rcCont:
  3403 00000EAE 83E001                  	and	ax,1
  3404 00000EB1 F7D0                    	not	ax
  3405                                  ResRegs:
  3406 00000EB3 5B                      	pop	bx
  3407 00000EB4 58                      	pop	ax
  3408 00000EB5 C3                      	retn
  3409                                  
  3410                                  ;***	THeadFix
  3411                                  ;
  3412                                  ;	Far version of HeadFix, called from transient.
  3413                                  
  3414                                  THeadFix:
  3415                                  	; 12/01/2023
  3416 00000EB6 1F                      	pop	ds			; ds = DATARES
  3417 00000EB7 83C402                  	add	sp,2			; discard old ds value on stack
  3418                                  
  3419 00000EBA E80100                  	call	HeadFix
  3420 00000EBD CB                      	retf
  3421                                  
  3422                                  ;***	HeadFix
  3423                                  
  3424                                  	; 12/01/2023
  3425                                  HeadFix:
  3426 00000EBE E83101                  	call	SetVect			; set vectors to our values
  3427                                  
  3428                                  ;	Clean up header
  3429                                  
  3430                                  ;	Bugbug:	optimize:
  3431                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3432                                  
  3433 00000EC1 31DB                    	xor	bx,bx			; BX = handle = 0
  3434 00000EC3 8B0E[8A01]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3435                                  	;mov	dx,[18h] 
  3436 00000EC7 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3437 00000ECB 38D1                    	cmp	cl,dl
  3438 00000ECD 7408                    	je	short Chk1		; stdin matches
  3439 00000ECF B43E                    	mov	ah,3Eh
  3440                                  	;mov	ah,CLOSE  ; 3Eh
  3441 00000ED1 CD21                    	int	21h			; close stdin
  3442                                  	;mov	[18h],cl
  3443 00000ED3 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3444                                  Chk1:
  3445 00000ED7 43                      	inc	bx			; BX = handle = 1
  3446 00000ED8 38F5                    	cmp	ch,dh			
  3447 00000EDA 7408                    	je	short ChkOtherHand	; stdout matches
  3448 00000EDC B43E                    	mov	ah,3Eh
  3449                                  	;mov	ah,CLOSE
  3450 00000EDE CD21                    	int	21h			; close stdout
  3451                                  	;mov	[19h],ch
  3452 00000EE0 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3453                                  ChkOtherHand:
  3454 00000EE4 83C304                  	add	bx,4			; skip handles 2,3,4
  3455 00000EE7 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3456                                  					; (handles 0-4 already done)
  3457                                  CloseLoop:
  3458 00000EEA B43E                    	mov	ah,3Eh
  3459                                  	;mov	ah,CLOSE ; 3Eh
  3460 00000EEC CD21                    	int	21h			; close each handle
  3461 00000EEE 43                      	inc	bx			; BX = next handle
  3462 00000EEF E2F9                    	loop	CloseLoop
  3463                                  
  3464                                  	; MSDOS 6.0
  3465                                  ;	Bugbug:	since this is for transient code, move it there
  3466                                  	
  3467                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3468                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3469                                  
  3470                                  ;	M012: remove this CS -> DS. Must've been missed during
  3471                                  ;	purification.
  3472                                  ;;	push	ds			; save data segment
  3473                                  ;;	push	cs			; get local segment into DS
  3474                                  ;;	pop	ds			;
  3475 00000EF1 803E[AD01]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3476 00000EF6 750E                    	jne	short Append_Fix_End	; no - just exit
  3477 00000EF8 B807B7                  	mov	ax,0B707h
  3478                                  	;mov	ax,AppendSetState	; set the state of Append
  3479 00000EFB 8B1E[AB01]              	mov	bx,[Append_State] 	; back to the original state
  3480 00000EFF CD2F                    	int	2Fh			;
  3481 00000F01 C606[AD01]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3482                                  Append_Fix_End: 			;
  3483                                  ;;	pop	ds			; get data segment back
  3484 00000F06 C3                      	retn
  3485                                  
  3486                                  	; MSDOS 3.3
  3487                                  	;retn
  3488                                  
  3489                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3490                                  ;
  3491                                  ;	ENTRY	nothing
  3492                                  ;
  3493                                  ;	EXIT	nothing
  3494                                  ;
  3495                                  ;	USED	flags
  3496                                  ;
  3497                                  ;	EFFECTS
  3498                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3499                                  ;	  current program's stdin,stdout set to our stderr
  3500                                  ;
  3501                                  
  3502                                  ;SR;
  3503                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3504                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3505                                  
  3506                                  SavHand:
  3507                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3508                                  
  3509                                  	; 12/01/2023
  3510                                  	;push	ds ; MSDOS 3.3
  3511                                  
  3512 00000F07 53                      	push	bx			;preserve registers
  3513 00000F08 50                      	push	ax
  3514                                  	; 12/01/2023
  3515 00000F09 06                      	push	es
  3516 00000F0A 1E                      	push	ds			; save DATARES value
  3517                                  
  3518 00000F0B B451                    	mov	ah,51h
  3519                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3520 00000F0D CD21                    	int	21h			; BX = user's header seg addr
  3521 00000F0F 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3522                                  	;lds	bx,[34h]	
  3523 00000F11 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3524 00000F15 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3525                                  	; 12/01/2023
  3526 00000F17 07                      	pop	es			; es = DATARES
  3527 00000F18 06                      	push	es			; save it back on stack
  3528 00000F19 26A3[3101]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3529                                  	;mov	[cs:HANDLE01],ax
  3530                                  
  3531                                  ;SR;
  3532                                  ; Use es to address Handle01 & our JFN_Table
  3533                                  
  3534                                  	; 12/01/2023
  3535                                  	;mov	al,[es:1Ah]
  3536 00000F1D 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3537                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3538 00000F21 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3539 00000F23 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3540                                  	; 12/01/2023
  3541 00000F25 1F                      	pop	ds			; restore registers
  3542 00000F26 07                      	pop	es
  3543 00000F27 58                      	pop	ax
  3544 00000F28 5B                      	pop	bx
  3545                                  	;pop	ds ; MSDOS 3.3
  3546 00000F29 C3                      	retn
  3547                                  
  3548                                  	;assume	ds:DATARES
  3549                                  GetComDsk2:
  3550 00000F2A E81F00                  	call	GetComDsk
  3551 00000F2D E909FF                  	jmp	LodCom1			; memory already allocated
  3552                                  
  3553                                  RestHand:
  3554 00000F30 1E                      	push	ds
  3555 00000F31 53                      	push	bx			; restore stdin, stdout to user
  3556 00000F32 50                      	push	ax
  3557                                  	; 12/01/2023
  3558 00000F33 B451                    	mov	ah,51h
  3559                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3560 00000F35 CD21                    	int	21h			; point to user's header
  3561 00000F37 A1[3101]                	mov	ax,[Handle01]
  3562 00000F3A 8EDB                    	mov	ds,bx
  3563                                  	;assume ds:NOTHING
  3564                                  	;lds	bx,[34h] 
  3565 00000F3C C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3566 00000F40 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3567 00000F42 58                      	pop	ax
  3568 00000F43 5B                      	pop	bx
  3569 00000F44 1F                      	pop	ds
  3570 00000F45 C3                      	retn
  3571                                  
  3572                                  	;assume ds:DATARES,ss:DATARES
  3573                                  Hopeless:
  3574 00000F46 BA[C704]                	mov	dx,COMBAD
  3575 00000F49 E9BEFD                  	jmp	FatalC
  3576                                  
  3577                                  GetComDsk:
  3578 00000F4C A0[7F01]                	mov	al,[ComDrv]
  3579 00000F4F E84DFF                  	call	RemCheck
  3580 00000F52 75F2                    	jnz	short Hopeless		; non-removable media
  3581                                  GetComDsk3:
  3582 00000F54 81FA[C704]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3583 00000F58 7503                    	jne	short GetComDsk4
  3584                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3585                                  	; 12/01/2023
  3586                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3587                                  	;invoke	RPrint			; say COMMAND is invalid
  3588 00000F5A E81803                  	call	RPrint
  3589                                  	;call	RDISPMSG
  3590                                  
  3591                                  GetComDsk4:
  3592                                  
  3593                                  ;	Bugbug:	there's always a drive here? No need to check?
  3594                                  
  3595 00000F5D 803E[1A01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3596 00000F62 7509                    	jne	short Users_Drive	; yes - use it
  3597 00000F64 B419                    	mov	ah,19h
  3598                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3599 00000F66 CD21                    	int	21h
  3600 00000F68 0441                    	add	al,"A"                  ; convert to ascii
  3601 00000F6A A2[1A01]                	mov	[PutBackDrv],al		; put in message to print out
  3602                                  
  3603                                  Users_Drive:
  3604                                  	; 12/01/2023
  3605                                  	; MSDOS 6.0
  3606 00000F6D BA[DD04]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3607                                  	;mov	si,offset DATARES:PutBackSubst
  3608                                  	;invoke	RPrint
  3609 00000F70 BE[1401]                	mov	si,PutBackSubst		; containing COMMAND
  3610 00000F73 E8FF02                  	call	RPrint
  3611                                  	;mov	dx,offset DATARES:Prompt
  3612                                  	;invoke	RPrint
  3613 00000F76 BA[FF04]                	mov	dx,PROMPT		; "Press any key"
  3614 00000F79 E8F902                  	call	RPrint
  3615                                  
  3616                                  	; MSDOS 3.3
  3617                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3618                                  	;call	RDISPMSG
  3619                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3620                                  	;mov	si,[COMSPEC_END]
  3621                                  	;mov	byte [si+1],'$'
  3622                                  	;call	RDISPMSG
  3623                                  	;mov	byte [si+1],0
  3624                                  	;mov	dx,PROMPT
  3625                                  	;call	RDISPMSG
  3626                                  
  3627                                  	;call	GetRawFlushedByte
  3628                                  	;retn
  3629                                  	; 12/01/2023
  3630                                  	;jmp	short GetRawFlushedByte
  3631                                  
  3632                                  ;***	GetRawFlushedByte - flush world and get raw input
  3633                                  
  3634                                  GetRawFlushedByte:
  3635                                  	; 12/01/2023
  3636 00000F7C B8070C                  	mov	ax,0C07h
  3637                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3638 00000F7F CD21                    	int	21h			; get char without testing or echo
  3639 00000F81 B8000C                  	mov	ax,0C00h
  3640                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3641 00000F84 CD21                    	int	21h
  3642                                  
  3643                                  ;	Bugbug:	get rid of this return and the following retz.
  3644                                  
  3645                                  LoadCom_retn:
  3646 00000F86 C3                      	retn
  3647                                  
  3648                                  	; 21/04/2023
  3649                                  TryDoOpen:
  3650 00000F87 E8C2FF                  	call	GetComDsk
  3651                                  	;jmp	short LoadCom
  3652                                  
  3653                                  ;***	LoadCom - load in transient
  3654                                  
  3655                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3656                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3657                                  
  3658                                  LoadCom:
  3659                                  	;assume	ds:DATARES
  3660                                  	
  3661 00000F8A 45                      	inc	bp				; flag command read
  3662                                  
  3663 00000F8B BA[3601]                	mov	dx,ComSpec
  3664 00000F8E B8003D                  	mov	ax,3D00h
  3665                                  	;mov	ax,OPEN<<8	; 3D00h
  3666 00000F91 CD21                    	int	21h				; open command.com
  3667 00000F93 730B                    	jnc	short ReadCom
  3668                                  	;cmp	ax,4
  3669 00000F95 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3670 00000F98 75ED                    	jnz	short TryDoOpen
  3671 00000F9A BA[8905]                	mov	dx,NOHANDMES
  3672 00000F9D E96AFD                  	jmp	FatalC				; will never find a handle
  3673                                  
  3674                                  	; 21/04/2023
  3675                                  ;TryDoOpen:
  3676                                  	;call	GetComDsk
  3677                                  	;jmp	short LoadCom
  3678                                  
  3679                                  ReadCom:
  3680 00000FA0 89C3                    	mov	bx,ax				; BX = handle
  3681                                  	;mov	dx,offset RESGROUP:TranStart
  3682 00000FA2 BA0022                  	mov	dx,TRANSTART
  3683 00000FA5 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3684 00000FA7 B80042                  	mov	ax,4200h
  3685                                  	;mov	ax,LSEEK<<8	; 4200h
  3686 00000FAA CD21                    	int	21h
  3687 00000FAC 7210                    	jc	short WrongCom1
  3688                                  	; 12/01/2023
  3689                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3690                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3691 00000FAE B99494                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3692 00000FB1 1E                      	push	ds
  3693 00000FB2 8E1E[7A01]              	mov	ds,[TrnSeg]
  3694                                  	;assume	ds:NOTHING
  3695 00000FB6 BA0001                  	mov	dx,100h
  3696 00000FB9 B43F                    	mov	ah,3Fh
  3697                                  	;mov	ah,READ	; 3Fh	
  3698 00000FBB CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3699                                  			; BX = file handle, CX = number of bytes to read
  3700                                  			; DS:DX -> buffer
  3701 00000FBD 1F                      	pop	ds
  3702                                  	;assume	ds:DATARES
  3703                                  WrongCom1:
  3704 00000FBE 9C                      	pushf
  3705 00000FBF 50                      	push	ax
  3706 00000FC0 B43E                    	mov	ah,3Eh
  3707                                  	;mov	ah,CLOSE ; 3Eh
  3708 00000FC2 CD21                    	int	21h			; close command.com
  3709 00000FC4 58                      	pop	ax
  3710 00000FC5 9D                      	popf
  3711 00000FC6 7204                    	jc	short WrongCom		; error on read
  3712 00000FC8 39C8                    	cmp	ax,cx
  3713                                  	;retz				; size matched
  3714 00000FCA 74BA                    	jz	short LoadCom_retn
  3715                                  WrongCom:
  3716 00000FCC BA[C704]                	mov	dx,COMBAD
  3717 00000FCF E87AFF                  	call	GetComDsk
  3718 00000FD2 EBB6                    	jmp	short LoadCom		; try again
  3719                                  
  3720                                  ;***	ChkSum - compute transient checksum
  3721                                  
  3722                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3723                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3724                                  ChkSum:
  3725 00000FD4 1E                      	push	ds
  3726 00000FD5 8E1E[7A01]              	mov	ds,[TrnSeg]
  3727 00000FD9 BE0001                  	mov	si,100h
  3728                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3729                                  	;mov	cx,87C2h
  3730 00000FDC B9[1085]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3731                                  Check_Sum:
  3732 00000FDF FC                      	cld
  3733 00000FE0 D1E9                    	shr	cx,1
  3734 00000FE2 31D2                    	xor	dx,dx
  3735                                  Chk:
  3736 00000FE4 AD                      	lodsw
  3737 00000FE5 01C2                    	add	dx,ax
  3738 00000FE7 83D200                  	adc	dx,0
  3739 00000FEA E2F8                    	loop	Chk
  3740                                  
  3741                                  	; 04/05/2023
  3742 00000FEC 1F                      	pop	ds
  3743                                  
  3744                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3745 00000FED 3B16[8201]              	cmp	dx,[Sum]
  3746                                  
  3747                                  	;pop	ds ; 04/05/2023
  3748 00000FF1 C3                      	retn
  3749                                  
  3750                                  ;***	SetVect - set interrupt vectors
  3751                                  
  3752                                  SetVect:
  3753                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3754                                  	; 12/01/2023
  3755 00000FF2 BA[7E00]                	mov	dx,LodCom_Trap
  3756                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3757 00000FF5 B82225                  	mov	ax,2522h
  3758                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3759 00000FF8 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3760 00000FFC 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3761 00001000 CD21                    	int	21h
  3762                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3763 00001002 BA[4A00]                	mov	dx,Ctrlc_Trap
  3764                                  	;mov	dx,CONTC ; MSDOS 3.3
  3765 00001005 FEC0                    	inc	al	; 23h
  3766 00001007 CD21                    	int	21h
  3767                                  	;mov	dx,offset DATARES:CritErr_Trap
  3768 00001009 BA[5500]                	mov	dx,CritErr_Trap
  3769                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3770 0000100C FEC0                    	inc	al	; 24h
  3771 0000100E CD21                    	int	21h
  3772 00001010 C3                      	retn
  3773                                  
  3774                                  	; MSDOS 6.0
  3775                                  ;;SR;
  3776                                  ;We have this to take care of the extra values pushed on the stack by
  3777                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3778                                  ;Lodcom1
  3779                                  
  3780                                  ;public	TrnLodCom1
  3781                                  	; 12/01/2023
  3782                                  TrnLodCom1:
  3783 00001011 1F                      	pop	ds			; ds = DATARES
  3784 00001012 83C402                  	add	sp,2
  3785                                  ;	pop	ds:OldDS
  3786 00001015 E921FE                  	jmp	LodCom1
  3787                                  
  3788                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3789                                  
  3790                                  %if 0
  3791                                  
  3792                                  ;***	EndInit - end up initialization sequence
  3793                                  ;
  3794                                  ;	Move the environment to a newly allocated segment.
  3795                                  
  3796                                  	; MSDOS 3.3
  3797                                  ENDINIT:
  3798                                  	push	ds			; save segments
  3799                                  	push	es			;
  3800                                  	push	cs			; get resident segment to DS
  3801                                  	pop	ds			;
  3802                                  	;assume	ds:RESGROUP
  3803                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3804                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3805                                  	;assume	es:NOTHING
  3806                                  
  3807                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3808                                  	jne	short NO_RESET 		; no - we already did it
  3809                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3810                                  	push	es			; save environment - just to be sure
  3811                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3812                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3813                                  				; ES = segment address of block to change
  3814                                  				; BX = new size in paragraphs
  3815                                  	pop	es
  3816                                  
  3817                                  NO_RESET:
  3818                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3819                                  	mov	ds,[OLDENV]		; source environment segment
  3820                                  	;assume	ds:NOTHING
  3821                                  	xor	si,si			; set up offsets to start of segments
  3822                                  	xor	di,di
  3823                                  	cld
  3824                                  	rep	movsb			; move it
  3825                                  	xor	ax,ax
  3826                                  	stosb				; make sure it ends with double-null
  3827                                  
  3828                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3829                                  	pop	es
  3830                                  	pop	ds
  3831                                  	jmp	LODCOM			; allocate transient
  3832                                  
  3833                                  	; MSDOS 6.0
  3834                                  
  3835                                  ;The init code has been changed to take care of the new way in which the
  3836                                  ;environment segment is allocated.
  3837                                  ;NB: We can use all the init variables at this point because they are all in
  3838                                  ;RESGROUP
  3839                                  ;Bugbug: The above approach will not work for ROMDOS
  3840                                  
  3841                                  ;IF 0
  3842                                  ;
  3843                                  ;EndInit:
  3844                                  ;	push	ds
  3845                                  ;	push	es			;save segments
  3846                                  ;	push	cs
  3847                                  ;	pop	ds		
  3848                                  ;	assume	ds:RESGROUP
  3849                                  ;;
  3850                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3851                                  ;;
  3852                                  ;	mov	bx,ds
  3853                                  ;	mov	es,bx			;es = RESGROUP
  3854                                  ;;
  3855                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3856                                  ;; code + data for low COMMAND
  3857                                  ;;
  3858                                  ;	mov	bx,ResSize		;Total size of resident
  3859                                  ;	mov	ah,SETBLOCK
  3860                                  ;	int	21h			;Set block to resident size
  3861                                  ;;
  3862                                  ;;Allocate the correct size for the environment
  3863                                  ;;
  3864                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3865                                  ;	mov	ah,ALLOC
  3866                                  ;	int	21h			;get memory
  3867                                  ;	jc	nomem_err		;out of memory,signal error
  3868                                  ;
  3869                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3870                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3871                                  ;	mov	es,ax			;es = address of allocated memory
  3872                                  ;	assume	es:nothing
  3873                                  ;
  3874                                  ;;
  3875                                  ;;Copy the environment to the newly allocated segment
  3876                                  ;;
  3877                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3878                                  ;
  3879                                  ;	push	ds
  3880                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3881                                  ;	assume	ds:nothing
  3882                                  ;
  3883                                  ;	xor	si,si
  3884                                  ;	mov	di,si			;Start transfer from 0
  3885                                  ;
  3886                                  ;	cld
  3887                                  ;	rep	movsb			;Do the copy
  3888                                  ;
  3889                                  ;	xor	ax,ax			
  3890                                  ;	stosb				;Make it end with double-null
  3891                                  ;
  3892                                  ;	pop	ds			;ds = RESGROUP
  3893                                  ;	assume	ds:RESGROUP
  3894                                  ;;
  3895                                  ;;We have to free the old environment block if it was allocated by INIT
  3896                                  ;;
  3897                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3898                                  ;	je      no_free                 ;no, do not free it
  3899                                  ;
  3900                                  ;	mov	ax,OldEnv		;Get old environment
  3901                                  ;	mov	es,ax
  3902                                  ;	mov	ah,DEALLOC	
  3903                                  ;	int	21h			;Free it
  3904                                  ;no_free:
  3905                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3906                                  ;	
  3907                                  ;	pop	es
  3908                                  ;	pop	ds
  3909                                  ;	assume	ds:nothing
  3910                                  ;	
  3911                                  ;	jmp	LodCom			;allocate transient
  3912                                  ;
  3913                                  ;nomem_err:
  3914                                  ;;
  3915                                  ;;We call the error routine which will never return. It will either exit
  3916                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3917                                  ;;message ( if first COMMAND )
  3918                                  ;;
  3919                                  ;
  3920                                  ;	call	Alloc_error
  3921                                  ;ENDIF
  3922                                  ;
  3923                                  ;CODERES ends
  3924                                  
  3925                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3926                                  ;	the resident group which is the location where the transient
  3927                                  ;	segments will be loaded initial.
  3928                                  
  3929                                  ;TAIL		segment public para
  3930                                  ;
  3931                                  ;		org	0
  3932                                  ;TranStart	label	word
  3933                                  ;		public	TranStart
  3934                                  ;
  3935                                  ;TAIL		ends
  3936                                  ;
  3937                                  
  3938                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3939                                  ;	the transient group which is the location where the exec
  3940                                  ;	segments will be loaded initial.
  3941                                  ;
  3942                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3943                                  
  3944                                  ;TRANTAIL	segment public para
  3945                                  ;
  3946                                  ;		org	0
  3947                                  ;ExecStart   	label   word
  3948                                  ;
  3949                                  ;TRANTAIL    	ends
  3950                                  
  3951                                  %endif ; 12/01/2023
  3952                                  
  3953                                  ;=============================================================================
  3954                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3955                                  ;=============================================================================
  3956                                  ; 22/09/2018 - Retro DOS v3.0
  3957                                  
  3958                                  ;	title	Localizable code for resident COMMAND
  3959                                  
  3960                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3961                                  
  3962                                  ; ----------------------------------------------------------------------------
  3963                                  ;***	AskEnd - ask user to confirm batch file termination
  3964                                  ;
  3965                                  ;	Confirm with user before freeing batch ...
  3966                                  ;
  3967                                  ;	ENTRY	nothing
  3968                                  ;
  3969                                  ;	EXIT	CY = set if batch termination is confirmed
  3970                                  ;
  3971                                  ;		CY = clear if batch should continue
  3972                                  ;
  3973                                  ;	USED	AX,DX,...
  3974                                  ;
  3975                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3976                                  ;	Bugbug:	or move it to command1 1st.
  3977                                  ;
  3978                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3979                                  ; ----------------------------------------------------------------------------
  3980                                  
  3981                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3982                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3983                                  
  3984                                  AskEnd:
  3985                                  	;assume	ds:DATARES
  3986                                  
  3987 00001018 BA[2105]                	mov	dx,ENDBATMES			; DX = message #
  3988 0000101B E85702                  	call	RPrint
  3989                                  	;call	RDISPMSG  ; MSDOS 3.3
  3990 0000101E B8010C                  	mov	ax,0C01h
  3991                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3992 00001021 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3993                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  3994 00001023 E8E802                  	call	CharToUpper			; change to upper case
  3995 00001026 3A06[2804]              	cmp	al,[NO_CHAR]
  3996 0000102A 7407                    	je	short aeRet			; answer is no (CY is clear)
  3997 0000102C 3A06[2704]              	cmp	al,[YES_CHAR]
  3998 00001030 75E6                    	jne	short AskEnd			; invalid response, try again
  3999 00001032 F9                      	stc					; answer is yes
  4000                                  aeRet:	
  4001 00001033 C3                      	retn
  4002                                  
  4003                                  ; ----------------------------------------------------------------------------
  4004                                  ;***	DskErr - critical error handler
  4005                                  ;
  4006                                  ;	Default critical error handler unless user intercepts int 24h.
  4007                                  ;
  4008                                  ;	ENTRY	int 24h
  4009                                  ;
  4010                                  ;	EXIT
  4011                                  ;
  4012                                  ;	USED
  4013                                  ;
  4014                                  ;	EFFECTS
  4015                                  ; ----------------------------------------------------------------------------
  4016                                  
  4017                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4018                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4019                                  
  4020                                  ;SR; 
  4021                                  ;The stub is going to push the old ds value and the resident data segment
  4022                                  ;onto the stack in that order. Get it off the stack
  4023                                  
  4024                                  ;DskErr	proc	far
  4025                                  DSKERR:
  4026                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4027                                  	; 12/01/2023
  4028 00001034 1F                      	pop	ds			; ds = DATARES
  4029                                  	;assume ds:DATARES
  4030 00001035 8F06[2004]              	pop	word [OldDS]		; save old ds value
  4031                                  
  4032                                  ;CRITERR: ; MSDOS 3.3
  4033 00001039 FB                      	sti
  4034                                  	; 12/01/2023
  4035                                  	;push	ds ; 25/09/2018
  4036 0000103A 06                      	push	es
  4037 0000103B 56                      	push	si
  4038 0000103C 51                      	push	cx
  4039 0000103D 57                      	push	di
  4040 0000103E 51                      	push	cx
  4041 0000103F 50                      	push	ax
  4042                                  
  4043 00001040 1E                      	push	ds			;save our data segment
  4044                                  	;push	cs ; 25/09/2018
  4045 00001041 07                      	pop	es			;es = DATARES
  4046                                  
  4047 00001042 8EDD                    	mov	ds,bp
  4048                                  	;assume	ds:nothing
  4049                                  
  4050                                  	;mov	ax,[si].SDEVATT
  4051 00001044 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4052 00001047 268826[1001]            	mov	[es:CDevAt],ah
  4053                                  
  4054                                  	;push	cs
  4055                                  	;pop	es
  4056                                  
  4057 0000104C BF[0301]                	mov	di,DevName
  4058 0000104F B90800                  	mov	cx,8
  4059                                  	;add	si,SDEVNAME  ; add si,10
  4060 00001052 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4061                                  				
  4062 00001055 FC                      	cld
  4063 00001056 F3A4                    	rep	movsb
  4064 00001058 58                      	pop	ax
  4065 00001059 59                      	pop	cx
  4066 0000105A 5F                      	pop	di
  4067                                  
  4068                                  ;	Stack still contains DS and ES.
  4069                                  
  4070                                  ;SR;
  4071                                  ;We need ds = DATARES for SavHand
  4072                                  
  4073                                  	 ;12/01/2023
  4074 0000105B 06                      	push	es
  4075 0000105C 1F                      	pop	ds
  4076                                  	;assume	ds:DATARES
  4077                                  
  4078                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4079 0000105D E8A7FE                  	call	SavHand
  4080                                  
  4081                                  	; 12/01/2023
  4082                                  	; 25/09/2018
  4083                                  	;;push	cs
  4084                                  	;push	es
  4085                                  	;pop	ds		; set up local data segment
  4086                                  	;assume	ds:resgroup
  4087                                  
  4088 00001060 52                      	push	dx
  4089 00001061 E80E02                  	call	crlf
  4090 00001064 5A                      	pop	dx
  4091                                  
  4092                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4093                                  
  4094 00001065 8826[8701]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4095                                  
  4096                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4097                                  
  4098 00001069 0441                    	add	al,'A'
  4099 0000106B A2[F000]                	mov	[DrvLet],al
  4100                                  
  4101                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4102                                  
  4103 0000106E F6C480                  	test	ah,80h
  4104 00001071 740A                    	jz	short NoHardE		; it's a disk-device error
  4105 00001073 F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4106 00001078 7503                    	jnz	short NoHardE		; it's a character device
  4107 0000107A E9E801                  	jmp	FatErr			; it's a FAT error
  4108                                  
  4109                                  NoHardE:
  4110 0000107D BE[4904]                	mov	si,MREAD		; SI = "read" msg #
  4111 00001080 F6C401                  	test	ah,1
  4112 00001083 7403                    	jz	short SavMes		; it's a read error
  4113 00001085 BE[5204]                	mov	si,MWRITE		; SI = "write" msg #
  4114                                  SavMes:
  4115 00001088 893E[4903]              	mov	[OldErrNo],di		; save critical error code
  4116                                  
  4117                                  ;	Bugbug:	don't need to save/restore all here?
  4118                                  
  4119 0000108C 06                      	push	es
  4120                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4121                                  	;push	ds			; GetExtendedError likes to STOMP
  4122                                  	; 12/01/2023
  4123                                  	; (all registers are changed -in dos service- except bp) *
  4124                                  	;push	bp
  4125                                  	; 19/07/2024
  4126                                  	;push	si
  4127                                  	;push	dx
  4128 0000108D 51                      	push	cx
  4129 0000108E 53                      	push	bx
  4130                                  	; 05/06/2023
  4131 0000108F B459                    	mov	ah,59h ; *
  4132                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4133 00001091 CD21                    	int	21h
  4134 00001093 5B                      	pop	bx
  4135 00001094 59                      	pop	cx
  4136                                  	; 19/07/2024
  4137                                  	;pop	dx
  4138                                  	;pop	si
  4139                                  	; 12/01/2023
  4140                                  	;pop	bp
  4141                                  	; 19/07/2024
  4142                                  	;pop	ds
  4143 00001095 893E[1E01]              	mov	[NeedVol],di		; save possible ptr to volume label
  4144 00001099 8C06[2001]              	mov	[NeedVol+2],es
  4145 0000109D 07                      	pop	es
  4146                                  
  4147                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4148                                  
  4149                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4150                                  	;xor	ah,ah
  4151 0000109E 89C7                    	mov	di,ax			; DI = error code
  4152                                  
  4153                                  ; Bugbug: somewhat obsolete documentation?
  4154                                  ;
  4155                                  ; DI is now the correct error code. Classify things to see what we are
  4156                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4157                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4158                                  ; the like) are contiguous.
  4159                                  
  4160                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4161                                  ;	Check use of ErrCd_24, though.
  4162                                  
  4163 000010A0 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4164 000010A3 7303                    	jae	short HavCod
  4165                                  
  4166                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4167                                  ;	even though it's not a critical error?
  4168                                  
  4169 000010A5 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4170                                  
  4171                                  ; DI now has the mapped error code. Old style errors are:
  4172                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4173                                  ; New style errors are:
  4174                                  ;   FOOBAR
  4175                                  ; We need to figure out which the particular error belongs to.
  4176                                  
  4177                                  HavCod:
  4178 000010A8 C606[2201]00            	mov	byte [ErrType],0	; assume old style
  4179 000010AD 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4180 000010B0 7405                    	je	short SetStyle
  4181 000010B2 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4182 000010B5 7504                    	jne	short GotStyle
  4183                                  
  4184                                  SetStyle:
  4185                                  ;	Bugbug:	use INC
  4186                                  	;mov	byte [ErrType],1		; must be new type
  4187 000010B7 FE06[2201]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4188                                  
  4189                                  GotStyle:
  4190 000010BB 893E[2F01]              	mov	[ErrCd_24],di
  4191                                  	; 12/01/2023
  4192                                  	; 25/09/2018
  4193                                  	; MSDOS 6.0
  4194 000010BF 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4195                                  	; MSDOS 3.3
  4196                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4197                                  
  4198                                  						; If the error message is unknown
  4199 000010C2 7641                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4200                                  
  4201                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4202                                  ; how to handle things
  4203                                  
  4204                                  ;input to IFSFUNC:    AL=1
  4205                                  ;		      BX=extended error number
  4206                                  ;
  4207                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4208                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4209                                  ;			   Abort, Retry, Ignore
  4210                                  ;			 1=<message>
  4211                                  ;			   Abort, Retry, Ignore
  4212                                  ;		      ES:DI=pointer to message text
  4213                                  ;		      carry set=>no message
  4214                                  
  4215 000010C4 89C7                    	mov	di,ax			; retrieve correct extended error...
  4216 000010C6 B80005                  	mov	ax,0500h		; is the redir there?
  4217 000010C9 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4218                                  			; Return: AL = 00h not installed, OK to install
  4219                                  			; 01h not installed, can't install
  4220                                  			; FFh installed
  4221 000010CB 3CFF                    	cmp	al,0FFh
  4222 000010CD 7529                    	jne	short NoHandler		; no, go to NoHandler
  4223                                  
  4224                                  	; 12/01/2023
  4225                                  	; MSDOS 6.0
  4226 000010CF 53                      	push	bx
  4227 000010D0 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4228 000010D2 B80105                  	mov	ax,0501h
  4229 000010D5 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4230 000010D7 5B                      	pop	bx 
  4231 000010D8 721E                    	jc	short NoHandler
  4232                                  	
  4233                                  	; MSDOS 3.3
  4234                                  	;mov     ax,di
  4235                                  	;mov     ah,5
  4236                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4237                                  	;jc      short NOHANDLER
  4238                                  
  4239                                  ;	Bugbug:	need to record error type?
  4240                                  
  4241 000010DA A2[2201]                	mov	[ErrType],al
  4242                                  
  4243 000010DD 1E                      	push	ds
  4244 000010DE 06                      	push	es
  4245 000010DF 1F                      	pop	ds
  4246 000010E0 89FA                    	mov	dx,di
  4247 000010E2 B9FFFF                  	mov	cx,-1			; find end of msg
  4248 000010E5 30C0                    	xor	al,al
  4249                                  
  4250 000010E7 FC                      	cld
  4251 000010E8 F2AE                    	repnz	scasb
  4252                                  
  4253                                  ;	Bugbug:	we can do better than this.
  4254                                  
  4255                                  	;mov	byte [di-1],'$'
  4256                                  	; 19/07/2024
  4257 000010EA 4F                      	dec	di
  4258 000010EB C60524                  	mov	byte [di],'$'
  4259                                  	
  4260                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4261                                  	
  4262 000010EE B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4263 000010F0 CD21                    	int	21h
  4264                                  
  4265                                  	;mov	byte [di-1],0			; restore terminal byte
  4266                                  	; 19/07/2024
  4267 000010F2 C60500                  	mov	byte [di],0
  4268                                  
  4269 000010F5 1F                      	pop	ds				; clean up and continue
  4270 000010F6 EB15                    	jmp	short CheckErrType
  4271                                  
  4272                                  ;*	Redir isn't available or doesn't recognize the error.
  4273                                  ;	Restore regs to unextended error.
  4274                                  
  4275                                  NoHandler:
  4276 000010F8 C606[2201]00            	mov	byte [ErrType],0
  4277                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4278 000010FD 8B3E[4903]              	mov	di,[OldErrNo]
  4279 00001101 893E[2F01]              	mov	[ErrCd_24],di
  4280                                  
  4281                                  NormalError:
  4282                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4283                                  	; MSDOS 6.0
  4284 00001105 83C713                  	add	di,ERROR_WRITE_PROTECT
  4285 00001108 87FA                    	xchg	di,dx			; may need dx later
  4286 0000110A E88101                  	call	RPrintCrit		; print error type
  4287                                  
  4288                                  	; MSDOS 3.3
  4289                                  	;shl     di,1
  4290                                  	;mov     di,[CRMSGTBL+di]
  4291                                  	;xchg    di,dx
  4292                                  	;call    RDISPMSG
  4293                                  
  4294                                  CheckErrType:
  4295 0000110D 803E[2201]00            	cmp	byte [ErrType],0	; Check error style...
  4296 00001112 7405                    	je	short ContOld
  4297 00001114 E85B01                  	call	crlf			; if new style then done printing
  4298 00001117 EB31                    	jmp	short Ask
  4299                                  
  4300                                  ContOld:
  4301                                  	; 12/01/2023
  4302                                  	; MSDOS 6.0
  4303 00001119 46                      	inc	si			; DS:SI = ptr to asciiz string
  4304                                  
  4305                                  ;	Bugbug:	combine some of the following two sections?
  4306                                  
  4307                                  	; 12/01/2023
  4308 0000111A F606[1001]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4309                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4310 0000111F 740F                    	jz	short BlkErr
  4311                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4312                                  	;mov	dx,ChardevErr
  4313 00001121 BA[6A04]                	mov	dx,MDEVICE
  4314                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4315 00001124 8936[F200]              	mov	[CharDevErrRw],si
  4316                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4317 00001128 BE[F100]                	mov	si,CharDevErrSubst
  4318                                  
  4319 0000112B E84701                  	call	RPrint				; print the message
  4320 0000112E EB1A                    	jmp	short Ask			; don't ralph on command
  4321                                  
  4322                                  	; 12/01/2023
  4323                                  	; MSDOS 3.3
  4324                                  	;mov	dx,ERRMES
  4325                                  	;call	RDISPMSG
  4326                                  	;mov	dx,si
  4327                                  	;call	RDISPMSG
  4328                                  	;
  4329                                  	;test	byte [CDevAt],80h
  4330                                  	;jz	short BLKERR
  4331                                  	;mov	dx,CHARDEVERR	; " device "
  4332                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4333                                  	;int	21h		; DOS - PRINT STRING
  4334                                  	;			; DS:DX -> string terminated by "$"
  4335                                  	;jmp	short ASK
  4336                                  
  4337                                  BlkErr:
  4338                                  	; 12/01/2023
  4339                                  	; MSDOS 6.0
  4340                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4341                                  	;mov	dx,BlkDevErr
  4342 00001130 BA[5B04]                	mov	dx,MDRIVE
  4343                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4344 00001133 8936[EB00]              	mov	[BlkDevErrRw],si
  4345                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4346 00001137 BE[EA00]                	mov	si,BlkDevErrSubst
  4347 0000113A E83801                  	call	RPrint
  4348                                  
  4349                                  	; MSDOS 3.3
  4350                                  	;mov	dx,BLKDEVERR
  4351                                  	;call	RDISPMSG
  4352                                  
  4353 0000113D 803E[3301]00            	cmp	byte [Loading],0
  4354 00001142 7406                    	jz	short Ask
  4355 00001144 E8E9FD                  	call	RestHand
  4356 00001147 E9E0FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4357                                  Ask:
  4358 0000114A 833E[2F01]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4359 0000114F 751E                    	jne	short Not15		; not error 15
  4360                                  
  4361                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4362                                  
  4363 00001151 51                      	push	cx
  4364                                  
  4365                                  ;	Bugbug:	does this push/pop need to be done?
  4366                                  
  4367 00001152 1E                      	push	ds
  4368 00001153 07                      	pop	es
  4369 00001154 C536[1E01]              	lds	si,[NeedVol]
  4370                                  	;assume	ds:NOTHING
  4371 00001158 57                      	push	di
  4372 00001159 BF[0001]                	mov	di,VolName
  4373                                  	; 12/01/2023
  4374                                  	; MSDOS 6.0
  4375 0000115C B91000                  	mov	cx,16			; copy volume name & serial #
  4376                                  	; MSDOS 3.3
  4377                                  	;mov	cx,11			; copy volume name
  4378 0000115F FC                      	cld
  4379 00001160 F3A4                    	rep	movsb
  4380 00001162 5F                      	pop	di
  4381 00001163 06                      	push	es
  4382 00001164 1F                      	pop	ds
  4383 00001165 59                      	pop	cx
  4384                                  	;assume	ds:DATARES
  4385                                  	; 12/01/2023
  4386                                  	; MSDOS 6.0
  4387                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4388                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4389                                  	;mov	dx,NeedVolMsg
  4390 00001166 BA[7A04]                	mov	dx,MVOLSERIAL
  4391 00001169 BE[F700]                	mov	si,NeedVolSubst
  4392 0000116C E80601                  	call	RPrint
  4393                                  
  4394                                  	; MSDOS 3.3
  4395                                  	;mov	dx,NEEDVOLMSG
  4396                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4397                                  	;int	21h		; DOS - PRINT STRING
  4398                                  	;			; DS:DX -> string terminated by "$"
  4399                                  Not15:
  4400                                  ;*	Print abort, retry, ignore, fail message.
  4401                                  ;	Print only options that are valid.
  4402                                  
  4403                                  ;	Bugbug:	sizzle this.
  4404                                  
  4405                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4406 0000116F BA[2904]                	mov	dx,REQ_ABORT
  4407 00001172 E80001                  	call	RPrint
  4408                                  	;call	RDISPMSG
  4409 00001175 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4410 0000117A 7406                    	jz	short Try_Ignore
  4411 0000117C BA[2F04]                	mov	dx,REQ_RETRY
  4412 0000117F E8F300                  	call	RPrint
  4413                                  	;call	RDISPMSG
  4414                                  Try_Ignore:
  4415 00001182 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4416 00001187 7406                    	jz	short Try_Fail
  4417 00001189 BA[3704]                	mov	dx,REQ_IGNORE
  4418 0000118C E8E600                  	call	RPrint
  4419                                  	;call	RDISPMSG
  4420                                  Try_Fail:
  4421 0000118F F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4422 00001194 7406                    	jz	short Term_Question
  4423 00001196 BA[4004]                	mov	dx,REQ_FAIL
  4424 00001199 E8D900                  	call	RPrint
  4425                                  	;call	RDISPMSG
  4426                                  Term_Question:
  4427 0000119C BA[4704]                	mov	dx,REQ_END
  4428 0000119F E8D300                  	call	RPrint
  4429                                  	;call	RDISPMSG
  4430                                  
  4431                                  ;	If the /f switch was given, we fail all requests.
  4432                                  
  4433 000011A2 F606[9201]FF            	test	byte [fFail],-1
  4434 000011A7 741B                    	jz	short DoPrompt
  4435 000011A9 B403                    	mov	ah,3				; signal fail
  4436 000011AB E9A800                  	jmp	EExit
  4437                                  
  4438                                  	; 16/04/2023
  4439                                  Abort_Process:
  4440 000011AE F606[FF01]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4441 000011B3 745D                    	jz	short AbortCont			; no, handle it normally
  4442 000011B5 803E[8D01]00            	cmp	byte [PermCom],0		; are we top level process?
  4443 000011BA 744B                    	jz	short JustExit			; yes, just exit
  4444                                  
  4445 000011BC BA[2C06]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4446                                  	; 12/01/2023
  4447 000011BF E8B300                  	call	RPrint				; print it
  4448                                  	;call	RDISPMSG
  4449                                  DeadInTheWater:
  4450 000011C2 EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4451                                  
  4452                                  DoPrompt:
  4453                                  	; 12/01/2023
  4454 000011C4 B8010C                  	mov	ax,0C01h
  4455                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4456 000011C7 CD21                    	int	21h				; get response
  4457                                  
  4458 000011C9 E8A600                  	call	crlf
  4459 000011CC E83F01                  	call	CharToUpper			; convert to upper case
  4460 000011CF B400                    	mov	ah,0				; return code for ignore
  4461 000011D1 F606[8701]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4462 000011D6 7406                    	jz	short User_Retry
  4463 000011D8 3A06[2504]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4464                                  	;jz	short EExitJ
  4465                                  	; 16/04/2023
  4466 000011DC 7478                    	jz	short EExit
  4467                                  
  4468                                  ;	Bugbug:	optimize following code.
  4469                                  
  4470                                  User_Retry:
  4471 000011DE FEC4                    	inc	ah				; return code for retry
  4472 000011E0 F606[8701]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4473 000011E5 7406                    	jz	short User_Abort
  4474 000011E7 3A06[2404]              	cmp	al,[RETRY_CHAR]			; retry?
  4475                                  	;jz	short EExitJ
  4476                                  	; 16/04/2023
  4477 000011EB 7469                    	jz	short EExit
  4478                                  User_Abort:
  4479 000011ED FEC4                    	inc	ah				; return code for abort
  4480                                  						;  (abort always allowed)
  4481 000011EF 3A06[2304]              	cmp	al,[ABORT_CHAR]			; abort?
  4482 000011F3 74B9                    	jz	short Abort_Process		; exit user program
  4483 000011F5 FEC4                    	inc	ah				; return code for fail
  4484 000011F7 F606[8701]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4485 000011FC 7406                    	jz	short AskJ
  4486 000011FE 3A06[2604]              	cmp	al,[FAIL_CHAR]			; fail?
  4487                                  	;jz	short EExitJ
  4488                                  	; 16/04/2023
  4489 00001202 7452                    	jz	short EExit
  4490                                  AskJ:
  4491 00001204 E943FF                  	jmp	Ask
  4492                                  
  4493                                  	; 12/01/2023
  4494                                  ;EExitJ:
  4495                                  	;jmp	short EExit
  4496                                  
  4497                                  JustExit:
  4498                                  	;assume	ds:DATARES
  4499                                  	; 12/01/2023
  4500 00001207 A1[2901]                	mov	ax,[Parent]			; load real parent pid
  4501                                  	;mov	[16h],ax
  4502 0000120A A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4503 0000120D B8FF4C                  	mov	ax,4CFFh
  4504                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4505 00001210 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4506                                  				; AL = exit code
  4507                                  AbortCont:
  4508 00001212 F606[7D01]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4509 00001217 7405                    	jz	short Not_Batch_Abort
  4510 00001219 C606[7E01]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4511                                  
  4512                                  Not_Batch_Abort:
  4513 0000121E 8A16[0002]              	mov	dl,[PipeFlag]
  4514 00001222 E8D1FA                  	call	ResPipeOff
  4515 00001225 08D2                    	or	dl,dl
  4516 00001227 740D                    	je	short CheckForA
  4517 00001229 833E[8E01]00            	cmp	word [SingleCom],0
  4518 0000122E 7406                    	je	short CheckForA
  4519 00001230 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4520                                  
  4521                                  CheckForA:
  4522 00001236 833E[2F01]00            	cmp	word [ErrCd_24],0		; write protect?
  4523 0000123B 7407                    	je	short abortfor
  4524 0000123D 833E[2F01]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4525 00001242 7512                    	jne	short EExit			; don't abort the FOR
  4526                                  
  4527                                  abortfor:
  4528 00001244 C606[9401]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4529 00001249 833E[8E01]00            	cmp	word [SingleCom],0
  4530 0000124E 7406                    	je	short EExit
  4531 00001250 C706[8E01]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4532                                  
  4533                                  EExit:
  4534 00001256 88E0                    	mov	al,ah
  4535 00001258 89FA                    	mov	dx,di
  4536                                  RestHd:
  4537 0000125A E8D3FC                  	call    RestHand
  4538 0000125D 59                      	pop	cx
  4539 0000125E 5E                      	pop	si				; restore registers
  4540 0000125F 07                      	pop	es
  4541                                  
  4542                                  	; 12/01/2023	
  4543                                  	; MSDOS 6.0
  4544                                  ;;	pop	ds
  4545                                  ;SR;
  4546                                  ;ds has to be got from the variable we saved it in
  4547                                  
  4548 00001260 8E1E[2004]               	mov	ds,[OldDS]			; restore old value of ds
  4549                                  
  4550                                  ;	pop	ds
  4551                                  ;	assume	ds:nothing
  4552                                  
  4553                                  	; MSDOS 3.3
  4554                                  	;pop	ds
  4555                                  
  4556 00001264 CF                      	iret
  4557                                  
  4558                                  FatErr:
  4559                                  	; 12/01/2023
  4560                                  	; MSDOS 6.0
  4561                                  	;mov	dx,offset DATARES:BadFatMsg
  4562                                  	;mov	si,offset DATARES:BadFatSubst
  4563 00001265 BA[A104]                	mov	dx,BADFATMSG
  4564 00001268 BE[1101]                	mov	si,BadFatSubst
  4565 0000126B E80700                  	call	RPrint
  4566                                  
  4567                                  	; MSDOS 3.3
  4568                                  	;mov	dx,BADFATMSG
  4569                                  	;call	RDISPMSG
  4570                                  	;mov	dx,BLKDEVERR
  4571                                  	;call	RDISPMSG
  4572                                  
  4573 0000126E B002                    	mov	al,2				; abort
  4574 00001270 EBE8                    	jmp	short RestHd
  4575                                  
  4576                                  ;DskErr	endp
  4577                                  
  4578                                  	; MSDOS 6.0
  4579                                  ; ----------------------------------------------------------------------------
  4580                                  ;***	RPrint - print message
  4581                                  ;***	Crlf - display cr/lf
  4582                                  ;
  4583                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4584                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4585                                  ;		variable fields related to substitution blocks are set
  4586                                  ;
  4587                                  ;	EXIT	nothing
  4588                                  ;
  4589                                  ;	USED	flags
  4590                                  ;
  4591                                  ;	EFFECTS
  4592                                  ;	  Message is displayed on stdout.
  4593                                  ;
  4594                                  ;	NOTE
  4595                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4596                                  ;	  be greater than number of substition blocks present.
  4597                                  ; ----------------------------------------------------------------------------
  4598                                  
  4599                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4600                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4601                                  
  4602                                  crlf: 
  4603                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4604                                  	; 14/01/2023
  4605 00001272 BA[5B06]                	mov	dx,NEWLINE
  4606                                  
  4607                                  ;RPrint	proc
  4608                                  ;
  4609                                  ;	assume	ds:DATARES,ss:DATARES
  4610                                  ;
  4611                                  	; 14/01/2023
  4612                                  RPrint:
  4613                                  
  4614                                  ;	Bugbug:	do we need to save all reg's?
  4615                                  
  4616 00001275 56                      	push	si			; preserve registers
  4617 00001276 50                      	push	ax
  4618 00001277 53                      	push	bx
  4619 00001278 51                      	push	cx
  4620 00001279 52                      	push	dx
  4621                                  
  4622 0000127A 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4623 0000127C 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4624 0000127E AC                      	lodsb				; AL = message length
  4625                                  					; DS:SI = ptr to message text
  4626 0000127F 31C9                    	xor	cx,cx
  4627 00001281 88C1                    	mov	cl,al			; CX = message length
  4628 00001283 E303                    	jcxz	rpRet
  4629                                  
  4630 00001285 E81900                  	call	RDispMsg
  4631                                  
  4632 00001288 5A                      rpRet:	pop	dx
  4633 00001289 59                      	pop	cx
  4634 0000128A 5B                      	pop	bx
  4635 0000128B 58                      	pop	ax
  4636 0000128C 5E                      	pop	si
  4637 0000128D C3                      	retn
  4638                                  
  4639                                  ;RPrint	endp
  4640                                  
  4641                                  	; 14/01/2023
  4642                                  ;	; MSDOS 3.3
  4643                                  ;CRLF:
  4644                                  ;	mov     dx,NEWLIN
  4645                                  ;
  4646                                  ;RDISPMSG: ; Display message/text
  4647                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4648                                  ;	push    ax
  4649                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4650                                  ;	clc
  4651                                  ;	int     21h             ; DOS - PRINT STRING
  4652                                  ;				; DS:DX -> string terminated by "$"
  4653                                  ;	pop     ax
  4654                                  ;	retn
  4655                                  
  4656                                  
  4657                                  	; MSDOS 6.0
  4658                                  ; ----------------------------------------------------------------------------
  4659                                  ;***	RPrintCrit - print critical error message
  4660                                  ;
  4661                                  ;	ENTRY	DX = extended error # (19-39)
  4662                                  ;
  4663                                  ;	EXIT	nothing
  4664                                  ;
  4665                                  ;	USED	flags
  4666                                  ;
  4667                                  ;	EFFECTS
  4668                                  ;	  Message is displayed on stdout
  4669                                  ; ----------------------------------------------------------------------------
  4670                                  
  4671                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4672                                  
  4673                                  ;RPrintCrit	proc
  4674                                  ;	assume	ds:DATARES,ss:DATARES
  4675                                  
  4676                                  	; 14/01/2023
  4677                                  RPrintCrit:
  4678 0000128E 52                      	push	dx			; preserve DX
  4679 0000128F 87DA                    	xchg	bx,dx			; BX = extended error #
  4680                                  					; DX = saved BX
  4681 00001291 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4682 00001294 D1E3                    	shl	bx,1			; BX = offset in word table
  4683 00001296 8B9F[F507]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4684 0000129A 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4685                                  					; BX = restored
  4686 0000129C E8D6FF                  	call	RPrint			; print the message
  4687 0000129F 5A                      	pop	dx			; restore DX
  4688 000012A0 C3                      	retn
  4689                                  
  4690                                  ;RPrintCrit	endp
  4691                                  
  4692                                  ; ----------------------------------------------------------------------------
  4693                                  ;***	RDispMsg - display message
  4694                                  ;
  4695                                  ;	Display message, with substitutions, for RPrint.
  4696                                  ;
  4697                                  ;	ENTRY	DS:SI = ptr to message text
  4698                                  ;		CX = message length
  4699                                  ;		DS:BX = ptr to substitution block, if any
  4700                                  ;
  4701                                  ;	EXIT	nothing
  4702                                  ;
  4703                                  ;	USED	AX,CX,DX,SI
  4704                                  ; ----------------------------------------------------------------------------
  4705                                  
  4706                                  ;RDispMsg	proc
  4707                                  ;	assume	ds:DATARES,ss:DATARES
  4708                                  
  4709                                  RDispMsg:
  4710                                  	; 14/01/2023
  4711                                  rdNextChar:
  4712 000012A1 AC                      	lodsb				; AL = next char
  4713 000012A2 3C25                    	cmp	al,'%'
  4714 000012A4 7511                    	jne	short rdOutChar		; not a substitution
  4715 000012A6 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4716 000012A8 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4717 000012AB 80FA09                  	cmp	dl,9
  4718 000012AE 7307                    	jae	short rdOutChar		; not a substitution
  4719                                  
  4720                                  ;*	A substitution code %1 - %9 has been encountered.
  4721                                  ;	DL = 0-8, indicating %1-%9
  4722                                  ;	DS:BX = ptr to substitution block
  4723                                  
  4724 000012B0 E80D00                  	call	SubstMsg		; display the substitution
  4725 000012B3 46                      	inc	si			; SI = ptr past %n
  4726 000012B4 49                      	dec	cx			; count extra character in %n
  4727 000012B5 EB06                    	jmp	short rdCharDone
  4728                                  
  4729                                  ;*	Normal character output.
  4730                                  
  4731                                  rdOutChar:
  4732 000012B7 88C2                    	mov	dl,al			; DL = char
  4733 000012B9 B402                    	mov	ah,2			; AH = DOS Character Output code
  4734 000012BB CD21                    	int	21h			; call DOS
  4735                                  rdCharDone:
  4736 000012BD E2E2                    	loop	rdNextChar
  4737 000012BF C3                      	retn
  4738                                  
  4739                                  ;RDispMsg	endp
  4740                                  
  4741                                  ; ----------------------------------------------------------------------------
  4742                                  ;***	SubstMsg - display message substitution
  4743                                  ;
  4744                                  ;	Display a substitution string within a message.
  4745                                  ;	Substitution can be a char, an ASCIIZ string, or
  4746                                  ;	a word to be displayed as hex digits.
  4747                                  ;
  4748                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4749                                  ;		DS:BX = ptr to substitution block
  4750                                  ;
  4751                                  ;	EXIT	nothing
  4752                                  ;
  4753                                  ;	USED	AX,DX
  4754                                  ; ----------------------------------------------------------------------------
  4755                                  
  4756                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4757                                  
  4758                                  ;SubstMsg	proc
  4759                                  ;	assume	ds:DATARES,ss:DATARES
  4760                                  	
  4761                                  	; 14/01/2023
  4762                                  SubstMsg:
  4763 000012C0 53                      	push	bx			; preserve BX
  4764 000012C1 51                      	push	cx			; preserve CX
  4765                                  
  4766                                  	;mov	al,size SUBST		; AL = size of substitution block
  4767 000012C2 B003                    	mov	al,3
  4768 000012C4 F6E2                    	mul	dl			; AX = offset of desired subst block
  4769 000012C6 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4770                                  
  4771                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4772 000012C8 8A07                    	mov	al,[bx]
  4773                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4774 000012CA 8B5F01                  	mov	bx,[bx+1]
  4775                                  
  4776                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4777                                  
  4778 000012CD FEC8                    	dec	al
  4779 000012CF 7428                    	jz	short smChar
  4780 000012D1 FEC8                    	dec	al
  4781 000012D3 742C                    	jz	short smStr
  4782                                  
  4783                                  ;*	Hex number substitution.
  4784                                  
  4785                                  	;mov	ax,ds:[bx]		; AX = word value
  4786 000012D5 8B07                    	mov	ax,[bx]
  4787 000012D7 B90400                  	mov	cx,4			; CX = # digits to display
  4788                                  smDigit:
  4789 000012DA D1C0                    	rol	ax,1
  4790 000012DC D1C0                    	rol	ax,1
  4791 000012DE D1C0                    	rol	ax,1
  4792 000012E0 D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4793                                  
  4794 000012E2 50                      	push	ax			; save other digits
  4795 000012E3 240F                    	and	al,0Fh			; AL = binary digit
  4796 000012E5 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4797 000012E7 3C39                    	cmp	al,'9'
  4798 000012E9 7602                    	jbe	short smDigit09		; it's 0-9
  4799                                  	;add	al,7
  4800 000012EB 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4801                                  smDigit09:
  4802 000012ED 88C2                    	mov	dl,al			; DL = ascii digit
  4803 000012EF B402                    	mov	ah,2
  4804 000012F1 CD21                    	int	21h			; output the ascii digit
  4805 000012F3 58                      	pop	ax			; restore all digits
  4806                                  
  4807 000012F4 E2E4                    	loop	smDigit
  4808                                  	;jmp	short smRet
  4809                                  	; 14/01/2023
  4810                                  smRet:	
  4811 000012F6 59                      	pop	cx
  4812 000012F7 5B                      	pop	bx
  4813 000012F8 C3                      	retn
  4814                                  
  4815                                  ;*	Char substitution.
  4816                                  
  4817                                  smChar:
  4818                                  	;mov	dl,ds:[bx]		; DL = char to output
  4819 000012F9 8A17                    	mov	dl,[bx]
  4820 000012FB B402                    	mov	ah,2
  4821 000012FD CD21                    	int	21h
  4822 000012FF EBF5                    	jmp	short smRet
  4823                                  
  4824                                  ;*	String substitution.
  4825                                  
  4826                                  smStr:
  4827                                  	;mov	dl,ds:[bx]		; DL = next char
  4828 00001301 8A17                    	mov	dl,[bx]
  4829 00001303 08D2                    	or	dl,dl
  4830 00001305 74EF                    	jz	short smRet		; null char - we're done
  4831 00001307 B402                    	mov	ah,2
  4832 00001309 CD21                    	int	21h			; display char
  4833 0000130B 43                      	inc	bx			; DS:BX = ptr to next char
  4834 0000130C EBF3                    	jmp	short smStr
  4835                                  
  4836                                  ;smRet:	pop	cx
  4837                                  ;	pop	bx
  4838                                  ;	retn
  4839                                  
  4840                                  ;SubstMsg	endp
  4841                                  
  4842                                  	; MSDOS 6.0
  4843                                  ; ----------------------------------------------------------------------------
  4844                                  ;***	CharToUpper - convert character to uppercase
  4845                                  ;
  4846                                  ;	ENTRY	AL = char
  4847                                  ;
  4848                                  ;	EXIT	AL = uppercase char
  4849                                  ;
  4850                                  ;	USED	AX
  4851                                  ; ----------------------------------------------------------------------------
  4852                                  
  4853                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4854                                  
  4855                                  ;CharToUpper	proc
  4856                                  ;	assume	ds:DATARES
  4857                                  CharToUpper:
  4858 0000130E 50                      	push	ax		; put char on stack as arg to int 2F
  4859 0000130F B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4860 00001312 CD2F                    	int	2Fh
  4861 00001314 44                      	inc	sp		; throw away old char on stack
  4862 00001315 44                      	inc	sp
  4863 00001316 C3                      	retn
  4864                                  
  4865                                  ;CharToUpper	endp
  4866                                  
  4867                                  	; 14/01/2023
  4868                                  ;	; MSDOS 3.3
  4869                                  ;CHARTOUPPER:
  4870                                  ;	cmp	al,80h
  4871                                  ;	jb	short CHARTOUPPER1
  4872                                  ;	sub	al,80h
  4873                                  ;	push	ds
  4874                                  ;	push	bx
  4875                                  ;	lds	bx,[UPPERCASETBL]
  4876                                  ;	add	bx,2
  4877                                  ;	xlat
  4878                                  ;	pop	bx
  4879                                  ;	pop	ds
  4880                                  ;	jmp	short CHARTOUPPER_RETN
  4881                                  ;CHARTOUPPER1:
  4882                                  ;	cmp	al,'a'
  4883                                  ;	jb	short CHARTOUPPER_RETN
  4884                                  ;	cmp	al,'z'
  4885                                  ;	ja	short CHARTOUPPER_RETN
  4886                                  ;	sub	al,20h
  4887                                  ;CHARTOUPPER_RETN:
  4888                                  ;	retn
  4889                                  
  4890                                  ;public	EndCode
  4891                                  ;EndCode label byte
  4892                                  
  4893                                  	; MSDOS 6.0
  4894                                  ; ----------------------------------------------------------------------------
  4895                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4896                                  ;
  4897                                  ;	ENTRY	If we handle it -
  4898                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4899                                  ;		  DL = operation =
  4900                                  ;		     0 = get extended error messages
  4901                                  ;		     1 = set extended error messages
  4902                                  ;		     2 = get parse error messages
  4903                                  ;		     3 = set parse error messages
  4904                                  ;		     4 = get critical error messages
  4905                                  ;		     5 = set critical error messages
  4906                                  ;		     6 = get file system error messages
  4907                                  ;		     7 = set file system error messages
  4908                                  ;		     8 = get disk retriever routine
  4909                                  ;		     9 = set disk retriever routine
  4910                                  ;		  ES:DI = address for 'set' operations
  4911                                  ;
  4912                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4913                                  ;
  4914                                  ;	NOTE
  4915                                  ;	  This handler replaces the one that used to reside in DOS.
  4916                                  ;	  'Set' operations are ignored.
  4917                                  ;	  'File system error messages' are not supported.
  4918                                  ; ----------------------------------------------------------------------------
  4919                                  
  4920                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4921                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4922                                  ;SR;
  4923                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4924                                  ;segment address. Get them off the stack
  4925                                  
  4926                                  ;MsgInt2fHandler proc	far
  4927                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4928                                  
  4929                                  	; 14/01/2023
  4930                                  MsgInt2fHandler:
  4931 00001317 1F                      	pop	ds			; ds = DATARES
  4932                                  	;assume	ds:DATARES
  4933                                  ;	pop	word [OldDS]		; save old value of ds
  4934                                  
  4935 00001318 3D2E12                  	cmp	ax,122Eh
  4936                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4937                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4938 0000131B 742A                    	je	short miOurs		; it's ours
  4939                                  
  4940                                  ;ifndef ROMDOS
  4941                                  	;cmp	ax,5500h
  4942 0000131D 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4943                                  ;else
  4944                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4945                                  ;endif	;ROMDOS
  4946 00001320 741C                    	je	short fcOurs
  4947                                  
  4948                                  ;SR;
  4949                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4950                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4951                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4952                                  ;current value of ds as it points at the data segment. So we do some kinky
  4953                                  ;stack manipulations.
  4954                                  
  4955 00001322 50                      	push	ax
  4956 00001323 50                      	push	ax			; create 2 words on stack for retf
  4957                                  
  4958 00001324 55                      	push	bp
  4959 00001325 50                      	push	ax
  4960                                  
  4961 00001326 89E5                    	mov	bp,sp			; bp can be used to address stack
  4962                                  
  4963                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4964                                  ;do a 'pop ds' at the end to restore our ds
  4965                                  
  4966 00001328 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4967 0000132B 894604                  	mov	[bp+4],ax
  4968                                  	
  4969                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4970 0000132E A1[9D03]                	mov	ax,[Int2fHandler+2]
  4971 00001331 894608                  	mov	[bp+8],ax		; put segment address
  4972                                  	;mov	ax,word ptr ds:Int2fHandler
  4973 00001334 A1[9B03]                	mov	ax,[Int2fHandler]
  4974 00001337 894606                  	mov	[bp+6],ax		; put offset address
  4975                                  
  4976 0000133A 58                      	pop	ax
  4977 0000133B 5D                      	pop	bp
  4978 0000133C 1F                      	pop	ds
  4979                                  
  4980 0000133D CB                      	retf				; chain on to next handler
  4981                                  
  4982                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4983                                  
  4984                                  fcOurs:
  4985                                  
  4986                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4987                                  
  4988 0000133E 58                      	pop	ax			; discard ds currently on stack
  4989 0000133F 1E                      	push	ds			; store our data segment
  4990                                  
  4991                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4992 00001340 BE[0400]                	mov	si,Int2f_Entry
  4993                                  
  4994 00001343 31C0                    	xor	ax,ax			; indicate COMMAND present
  4995 00001345 EB11                    	jmp	short miRet		; return to caller
  4996                                  
  4997                                  miOurs:
  4998 00001347 F6C201                  	test	dl,1
  4999 0000134A 750C                    	jnz	short miRet		; ignore 'set' operations
  5000                                  
  5001 0000134C 53                      	push	bx			; preserve BX
  5002 0000134D 89D3                    	mov	bx,dx
  5003 0000134F 30FF                    	xor	bh,bh			; BX = index in word table
  5004 00001351 D1E3                    	shl	bx,1			; BX = index in dword table
  5005                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5006 00001353 C4BF[5E06]              	les	di,[bx+MsgPtrLists]
  5007 00001357 5B                      	pop	bx			; restore BX
  5008                                  miRet:
  5009                                  ;	mov	ds,[OldDS]		; restore ds
  5010 00001358 1F                      	pop	ds
  5011                                  	;assume	ds:nothing
  5012                                  
  5013 00001359 CF                      	iret
  5014                                  
  5015                                  ;MsgInt2fHandler endp
  5016                                  
  5017                                  	; MSDOS 6.0
  5018                                  ; ----------------------------------------------------------------------------
  5019                                  ;***	MsgRetriever - message retrieval routine for utilities
  5020                                  ;
  5021                                  ;	Address of this routine is passed to utility programs via 
  5022                                  ;	message services int 2f. We try to find the desired message
  5023                                  ;	in memory or in our disk image.
  5024                                  ;
  5025                                  ;	ENTRY	AX = message #
  5026                                  ;		DI = offset in RESGROUP of msg ptr list
  5027                                  ;		ComSpec = asciiz pathname to our disk image
  5028                                  ;
  5029                                  ;	EXIT	CY clear for success
  5030                                  ;		ES:DI = ptr to count byte, followed by message text
  5031                                  ;
  5032                                  ;		CY set for failure
  5033                                  ;		ES,DI undefined
  5034                                  ;
  5035                                  ;	USED	flags
  5036                                  ;
  5037                                  ;	NOTE
  5038                                  ;	  The message # in AX is used to compute an offset into
  5039                                  ;	  the message ptr list pointed to by DI. The lists must
  5040                                  ;	  start with message # 1 and proceed through consecutive
  5041                                  ;	  message #'s.  
  5042                                  ;
  5043                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5044                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5045                                  ;	  valid message #.  ;M033
  5046                                  ;
  5047                                  ;	  List positions with no corresponding message text are
  5048                                  ;	  indicated by null pointers, which this routine detects.
  5049                                  ; ----------------------------------------------------------------------------
  5050                                  
  5051                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5052                                  
  5053                                  ;SR; This routine will be called directly by the utilities. So, we have
  5054                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5055                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5056                                  
  5057                                  ;MsgRetriever	proc	far
  5058                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5059                                  
  5060                                  	; 14/01/2023
  5061                                  MsgRetriever:
  5062 0000135A 1F                      	pop	ds			; ds = DATARES
  5063                                  	;assume	ds:DATARES
  5064                                  ;	pop	word [OldDS]		; save old ds
  5065                                  
  5066 0000135B 50                      	push	ax			; preserve registers
  5067 0000135C 53                      	push	bx
  5068 0000135D 51                      	push	cx
  5069 0000135E 52                      	push	dx
  5070 0000135F 56                      	push	si
  5071                                  
  5072                                  ;;	push	ds
  5073                                  ;;	push	cs
  5074                                  ;;	pop	ds			; DS = DATARES seg addr
  5075                                  ;;	assume	ds:RESGROUP
  5076                                  ;;	push	cs
  5077                                  
  5078 00001360 1E                      	push	ds			; get es from ds
  5079 00001361 07                      	pop	es			; ES = DATARES seg addr
  5080                                  
  5081                                  ;	Begin modification M033.
  5082                                  
  5083                                  ;	Make sure msg # is valid.
  5084                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5085                                  
  5086                                  	;mov	bx,11
  5087 00001362 BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5088                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5089 00001365 81FF[FD08]              	cmp	di,PARSMSGPTRS
  5090 00001369 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5091                                  	;mov	bx,90
  5092 0000136B BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5093                                  chkmsgnum:
  5094 0000136E 39C3                    	cmp	bx,ax
  5095 00001370 725A                    	jc	short mrRet		; msg # too high, return carry
  5096                                  
  5097                                  ;	Msg # is valid.
  5098                                  
  5099                                  ;	End modification M033.
  5100                                  
  5101 00001372 48                      	dec	ax
  5102 00001373 D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5103 00001375 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5104                                  
  5105 00001377 81FF[9F03]              	cmp	di,ResMsgEnd
  5106 0000137B 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5107                                  
  5108                                  ;*	Retrieve message from disk (or ROM) image.
  5109                                  ;	Read once to get the ptr to the message, then again for the message.
  5110                                  
  5111                                  ;ifndef	ROMDOS
  5112                                  	; 14/01/2023
  5113                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5114 0000137D BE[3601]                	mov	si,ComSpec
  5115 00001380 BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5116 00001383 BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5117 00001386 B8006C                  	mov	ax,6C00h
  5118                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5119 00001389 CD21                    	int	21h				; call DOS
  5120 0000138B 723F                    	jc	short mrRet			; return failure
  5121                                  
  5122 0000138D 89C3                    	mov	bx,ax				; BX = file handle
  5123 0000138F 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5124 00001391 31F6                    	xor	si,si				; SI = read count
  5125                                  mrRead:
  5126 00001393 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5127 00001397 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5128 00001399 B80042                  	mov	ax,4200h
  5129                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5130 0000139C CD21                    	int	21h				; call DOS
  5131 0000139E 721A                    	jc	short mrCloseFile		; handle error
  5132                                  
  5133                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5134 000013A0 BA[4B03]                	mov	dx,MsgBuffer
  5135 000013A3 B94000                  	mov	cx,64				; CX = # bytes to read
  5136 000013A6 B43F                    	mov	ah,3Fh
  5137                                  	;mov	ah,READ				; AH = 'Read File'
  5138 000013A8 CD21                    	int	21h				; call DOS
  5139 000013AA 720E                    	jc	short mrCloseFile		; handle error
  5140                                  
  5141 000013AC 09F6                    	or	si,si				; (CY cleared)
  5142 000013AE 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5143 000013B0 46                      	inc	si				; mark one read done
  5144 000013B1 8B16[4B03]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5145 000013B5 09D2                    	or	dx,dx
  5146 000013B7 75DA                    	jnz	short mrRead			; go read the message
  5147 000013B9 F9                      	stc					; null ptr found- no msg
  5148                                  
  5149                                  mrCloseFile:
  5150 000013BA 9C                      	pushf				; save success/failure (CY)
  5151 000013BB B43E                    	mov	ah,3Eh
  5152                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5153 000013BD CD21                    	int	21h			; call DOS
  5154                                  ;	Bugbug: should we avoid this popf?
  5155 000013BF 9D                      	popf				; CY = success/failure
  5156 000013C0 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5157 000013C2 EB08                    	jmp	short mrRet		; we're done
  5158                                  
  5159                                  ;else	;ROMDOS
  5160                                  ;
  5161                                  ;;	DI = ptr to msg ptr
  5162                                  ;
  5163                                  ;	mov	si,di			; SI = ptr to msg ptr
  5164                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5165                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5166                                  ;
  5167                                  ;;	ASSUME ES:NOTHING is still in effect.
  5168                                  ;
  5169                                  ;	push	ds
  5170                                  ;	pop	es				; ES = DATARES seg addr
  5171                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5172                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5173                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5174                                  ;	or	si,si
  5175                                  ;	jz	mrNoMsg			; null ptr- no message text
  5176                                  ;
  5177                                  ;	sub	si,100h			; SI = offset into image of msg
  5178                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5179                                  ;	mov	di,offset DATARES:MsgBuffer
  5180                                  ;	invoke	LoadFromROM
  5181                                  ;	clc					; success
  5182                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5183                                  ;	jmp	short mrRet
  5184                                  ;
  5185                                  ;mrNoMsg:
  5186                                  ;	stc
  5187                                  ;	jmp	short mrRet
  5188                                  ;
  5189                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5190                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5191                                  ;	assume	es:NOTHING
  5192                                  ;
  5193                                  ;endif	;ROMDOS
  5194                                  
  5195                                  ;*	Message ptr is in memory.
  5196                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5197                                  
  5198                                  mrInMem:
  5199                                  	; 14/01/2023
  5200 000013C4 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5201 000013C7 09FF                    	or	di,di			; (CY cleared)
  5202 000013C9 7501                    	jnz	short mrRet		; found message
  5203 000013CB F9                      	stc				; null ptr found - no message
  5204                                  mrRet:	
  5205 000013CC 5E                      	pop	si			; restore all registers
  5206 000013CD 5A                      	pop	dx
  5207 000013CE 59                      	pop	cx
  5208 000013CF 5B                      	pop	bx
  5209 000013D0 58                      	pop	ax
  5210                                  
  5211                                  ;	mov	ds,[OldDS]		; restore ds
  5212 000013D1 1F                      	pop	ds
  5213                                  	;assume	ds:nothing
  5214                                  
  5215 000013D2 CB                      	retf	; 21/04/2023
  5216                                  
  5217                                  ;MsgRetriever endp
  5218                                  
  5219                                  ; M003; Start of changes for UMB support
  5220                                  
  5221                                  ; ----------------------------------------------------------------------------
  5222                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5223                                  ;
  5224                                  ;	ENTRY	al = Saved alloc strat and link state
  5225                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5226                                  ;			b1 = 1 if link state to restore is Linked
  5227                                  ;
  5228                                  ;	EXIT	None
  5229                                  ;
  5230                                  ;	USED	ax, bx, cx
  5231                                  ; ----------------------------------------------------------------------------
  5232                                  
  5233                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5234                                  
  5235                                  ;public	Lh_OffUnlink
  5236                                  Lh_OffUnlink:	; proc	far
  5237                                  	; 14/01/2023
  5238 000013D3 88C5                    	mov	ch,al
  5239 000013D5 88C1                    	mov	cl,al
  5240                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5241                                  	;mov	ax,(ALLOCOPER<<8)
  5242 000013D7 B80058                  	mov	ax,5800h
  5243 000013DA CD21                    	int	21h
  5244 000013DC 89C3                    	mov	bx,ax
  5245 000013DE D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5246 000013E0 80E180                  	and	cl,80h				; mask off b6-b0
  5247 000013E3 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5248 000013E6 08CB                    	or	bl,cl				; set HighFirst bit state
  5249                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5250                                  	;mov	ax,(ALLOCOPER<<8)|1
  5251 000013E8 B80158                  	mov	ax,5801h
  5252 000013EB CD21                    	int	21h				; set alloc strat
  5253                                  
  5254 000013ED 88EB                    	mov	bl,ch
  5255 000013EF D0EB                    	shr	bl,1
  5256 000013F1 30FF                    	xor	bh,bh				; bx = linkstate
  5257                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5258                                  	;mov	ax,(ALLOCOPER<<8)|3
  5259 000013F3 B80358                  	mov	ax,5803h
  5260 000013F6 CD21                    	int	21h				; set linkstate
  5261                                  
  5262 000013F8 CB                      	retf
  5263                                  
  5264                                  ;Lh_OffUnlink endp
  5265                                  
  5266                                  ; M003; End of changes for UMB support
  5267                                  
  5268                                  ;public	EndCode
  5269                                  ; 14/01/2023
  5270                                  ;EndCode: ; label byte
  5271                                  ; 06/06/2023
  5272                                  ; 16/04/2023
  5273                                  EndCode equ ($-StartCode)+100h
  5274                                  ; 06/06/2023
  5275                                  ;EndCode equ $-StartCode	
  5276                                  
  5277                                  ;CODERES ends
  5278                                  ;	end
  5279                                  
  5280                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5281                                  
  5282 000013F9 00<rep 7h>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5283                                  
  5284                                  ;align 16
  5285                                  
  5286                                  ;=============================================================================
  5287                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5288                                  ;=============================================================================
  5289                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5290                                  
  5291                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5292                                  
  5293                                  ;TITLE   COMMAND Initialization
  5294                                  
  5295                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5296                                  ;ENVIRONSIZ2 EQU 092H
  5297                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5298                                  
  5299                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5300                                  ; 23/09/2018
  5301                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5302                                  ; 14/01/2023
  5303                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5304                                  
  5305                                  ; ----------------------------------------------------------------------------
  5306                                  
  5307                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5308                                  
  5309                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5310                                  ENVIRONSIZ equ 160
  5311                                  ENVSML	equ 256	; minimum environment size
  5312                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5313                                  MAX_COMSPEC equ 146
  5314                                  ECOMSPEC equ 14
  5315                                  
  5316                                  ; 14/01/2023
  5317                                  TAB_CHAR equ 09h
  5318                                  SPACE_CHAR equ 20h	
  5319                                  
  5320                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5321                                  ;ENVIRONSIZ equ 180	; SIZE Environment 
  5322                                  
  5323                                  ;----------------------------------------------------
  5324                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5325                                  ;----------------------------------------------------
  5326                                  ;Environment Struc	; Default COMMAND environment
  5327                                  ;
  5328                                  ;Env_PathString  db	"path="
  5329                                  ;Env_PathSpec	 db	"c:\msdos"
  5330                                  ;                db	0
  5331                                  ;Env_PrmptString db	"prompt="
  5332                                  ;Env_PrmptSpec   db	"$p$g"
  5333                                  ;                db	0
  5334                                  ;Env_ComString   db	"comspec="
  5335                                  ;Env_ComSpec     db	"\command.com"
  5336                                  ;		 db	134 dup (0)
  5337                                  ;
  5338                                  ;Environment ends
  5339                                  ;----------------------------------------------------
  5340                                  
  5341                                  ;-----------------------------------------------------------------------------
  5342                                  
  5343                                  ;-----------------------------------------------------------------------------
  5344                                  ; START OF INIT PORTION
  5345                                  ; This code is deallocated after initialization.
  5346                                  ;-----------------------------------------------------------------------------
  5347                                  
  5348                                  ;INIT	SEGMENT PUBLIC PARA
  5349                                  
  5350                                  ; 	EXTRN   HEADER:BYTE
  5351                                  ;	EXTRN   BADCOMLKMES:BYTE
  5352                                  
  5353                                  ;	PUBLIC  CONPROC
  5354                                  
  5355                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5356                                  
  5357                                          ;ORG 0
  5358                                  ;ZERO = $
  5359                                  	; 23/09/2018
  5360                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5361                                  
  5362                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5363                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5364                                  ConProc:
  5365                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5366 00001400 BC[2004]                	mov	sp,RStack
  5367                                  
  5368                                  ; We need to set the PSP to us right at start because Carousel needs
  5369                                  ; to be lied to and it does not set PSP when it transfers control to
  5370                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5371                                  ; command.com is also not lied to.
  5372                                  
  5373                                  	; 14/01/2023
  5374                                  	; MSDOS 6.0
  5375 00001403 B450                            mov	ah,50h
  5376                                  	;mov	ah,SET_CURRENT_PDB
  5377 00001405 8CC3                            mov	bx,es
  5378 00001407 CD21                            int	21h
  5379                                  
  5380                                  	; 14/01/2023
  5381 00001409 B430                    	mov	ah,30h 
  5382                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5383                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5384                                  	;mov	ax,3000h
  5385 0000140B CD21                    	int	21h
  5386                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5387                                  	;cmp	ax,5
  5388 0000140D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5389 00001410 7411                    	je	short okdos			; DOS version is ok
  5390                                  
  5391 00001412 BA[181D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5392 00001415 E85DFE                  	call	RPrint
  5393                                  
  5394                                  	; MSDOS 3.3
  5395                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5396                                  	;int	21h             ; DOS - PRINT STRING
  5397                                  				; DS:DX -> string terminated by "$"
  5398 00001418 8CC0                    	mov	ax,es
  5399 0000141A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5400                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5401                                  Here:	
  5402 0000141F 74FE                    	jz	short Here			;  loop forever
  5403                                  	
  5404 00001421 CD20                    	int	20h				; otherwise, exit
  5405                                  okdos:
  5406                                  	; 23/09/2018
  5407                                  
  5408                                  ;  Calculate and save the end of the INIT segment (which is also
  5409                                  ;  the beginning of TRANGROUP).
  5410                                  
  5411                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5412                                  	; MSDOS 3.3
  5413                                  	;mov	ah,65h
  5414                                  	;mov	al,2
  5415                                  	;mov	dx,-1
  5416                                  	;mov	bx,-1
  5417                                  	;mov	cx,5
  5418                                  	;mov	di,UCASE_ADDR
  5419                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5420                                  	;		; AL = 02h : Get pointer to character translation table
  5421                                  	;		; BX = code page (-1 = current global code page)
  5422                                  	;		; DX = country ID (-1 = current country)
  5423                                  	;		; CX = amount of data to return
  5424                                  	;; ES:DI = pointer to output buffer
  5425                                  	;; Buffer offset :
  5426                                  	;;	00h -  byte,  country Id
  5427                                  	;;  	01h -  dword, pointer to uppercase table	
  5428                                  
  5429                                  	; 14/01/2023
  5430                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5431                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5432 00001423 BA0F22                  	mov	dx,TRANSTART+15			; get end of init code
  5433                                  	; 27/09/2018
  5434                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5435 00001426 B104                    	mov	cl,4				; change to paragraphs
  5436 00001428 D3EA                            shr	dx,cl				;
  5437 0000142A 8CC8                            mov     ax,cs                           ; get current segment
  5438 0000142C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5439 0000142E A3[7C1C]                        mov     [initend],ax			; save this
  5440                                  
  5441                                  	; 14/01/2023
  5442                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5443                                  
  5444                                  ;  Check for /? on the command line. If found, display help text and exit.
  5445                                  ;  NOTE: this routine may terminate the program, never returning.
  5446                                  
  5447 00001431 E86A06                  	call	CheckHelp
  5448                                  
  5449                                  ; We have to patch the segment values for the various interrupt entry points.
  5450                                  ; This is because we need to have the default addresses of the handlers in our
  5451                                  ; stub before the relocation is done. These values will then be changed once
  5452                                  ; the resident is relocated
  5453                                  
  5454 00001434 E8A507                  	call	patch_segs
  5455                                  
  5456                                  ;  Turn APPEND off during initialization processing
  5457                                  
  5458                                  	; 14/01/2023
  5459 00001437 B800B7                  	mov     ax,0B700h
  5460                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5461 0000143A CD2F                    	int	2Fh				;
  5462                                  	;cmp	al,0				; append installed?
  5463 0000143C 08C0                    	or	al,al
  5464 0000143E 7418                    	jz	short set_msg_addr		; no - continue
  5465                                  	
  5466 00001440 B802B7                  	mov	ax,0B702h
  5467                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5468 00001443 CD2F                    	int	2Fh				;
  5469                                  	;cmp	ax,-1				; append version correct?
  5470                                  	;jne	short set_msg_addr		; no - continue
  5471 00001445 40                      	inc	ax ; -1 -> 0
  5472 00001446 7510                    	jnz	short set_msg_addr        
  5473                                  	
  5474 00001448 B806B7                  	mov     ax,0B706h
  5475                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5476 0000144B CD2F                    	int	2Fh				;
  5477 0000144D 891E[AB01]                      mov     [Append_State],bx		; save append state
  5478                                         
  5479 00001451 31DB                    	xor	bx,bx                           ; clear out state
  5480 00001453 B807B7                  	mov	ax,0B707h
  5481                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5482 00001456 CD2F                    	int	2Fh				; set everything off
  5483                                  
  5484                                  set_msg_addr:
  5485                                  	; 14/01/2023
  5486                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5487                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5488                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5489 00001458 BF[1F08]                	mov	di,DataresEnd
  5490 0000145B 893E[9F03]              	mov	[ResMsgEnd],di			; save it
  5491                                  
  5492 0000145F E88C07                          call    get_XMMAddr                     ; get XMM call address
  5493                                  
  5494                                  ; Check if this is the first instance of command.com. If not, we just exit
  5495                                  ; this routine without moving any code.
  5496                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5497                                  ; stub. We just have to copy this over
  5498                                  	
  5499                                  ;ifndef ROMDOS
  5500 00001462 B80055                  	mov	ax,5500h
  5501                                  	;mov	ax,GET_COMMAND_STATE	
  5502                                  ;else
  5503                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5504                                  ;endif ; ROMDOS
  5505                                  
  5506 00001465 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5507                                  	;assume	ds:nothing
  5508                                  
  5509                                  	; 03/05/2023
  5510                                  	; Return:
  5511                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5512                                  	;   DS:SI -> entry point table
  5513                                  
  5514                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5515                                  
  5516 00001467 09C0                    	or	ax,ax
  5517 00001469 750C                    	jnz	short first_com			; this is the first instance
  5518                                  
  5519                                  	; 14/01/2023
  5520 0000146B 268936[BC20]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5521 00001470 268C1E[BE20]            	mov	[es:ResJmpTable+2],ds
  5522 00001475 EB06                    	jmp	short init_cntry
  5523                                  
  5524                                  first_com:
  5525 00001477 26C606[C020]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5526                                  
  5527                                  init_cntry:
  5528                                  	; 14/01/2023
  5529 0000147D 06                      	push	es
  5530 0000147E 1F                      	pop	ds
  5531                                  	;assume	ds:RESGROUP
  5532                                  
  5533 0000147F B465                    	mov	ah,65h
  5534                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5535 00001481 B004                    	mov	al,4				; get file ucase table
  5536 00001483 BAFFFF                  	mov	dx,-1				;
  5537                                  	;mov	bx,-1				;
  5538 00001486 89D3                    	mov	bx,dx
  5539 00001488 B90500                  	mov	cx,5				; number of bytes we want
  5540                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5541 0000148B BF[9E01]                	mov	di,FUCase_Addr
  5542 0000148E CD21                    	int	21h
  5543                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5544                                  		; AL = function -
  5545                                  
  5546                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5547                                  
  5548 00001490 1E                      	push	ds				;
  5549 00001491 B80063                  	mov	ax,6300h
  5550                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5551 00001494 CD21                    	int	21h				;
  5552                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5553                                  			
  5554 00001496 8CDB                    	mov	bx,ds				; get segment to bx
  5555 00001498 1F                      	pop	ds				;
  5556 00001499 8936[A701]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5557 0000149D 891E[A901]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5558                                  
  5559                                  	;mov	ax,[16h]
  5560 000014A1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5561                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5562 000014A4 A3[2901]                	mov	[Parent],ax			;  correctly.
  5563 000014A7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5564 000014AA A3[2B01]                	mov	[OldTerm],ax
  5565 000014AD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5566 000014B0 A3[2D01]                	mov	[OldTerm+2],ax
  5567                                  
  5568                                  	; 14/01/2023
  5569                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5570                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5571                                  	;mov	ax,EndCode+15
  5572                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5573                                  	; 14/01/2023
  5574                                  	;mov	cl,4				; ax = size of resident part of
  5575                                  	;shr	ax,cl				;  command in paragraphs. Add
  5576                                  	;mov	cx,cs				;  this to CS and you get the
  5577                                  	;add	ax,cx				;  segment of the TPA.
  5578                                  
  5579 000014B3 8CC8                    	mov	ax,cs
  5580 000014B5 055001                  	add	ax,(EndCode+15)>>4
  5581                                  	
  5582 000014B8 A3[4703]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5583 000014BB 2500F0                  	and     ax,0F000h
  5584 000014BE 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5585 000014C1 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5586 000014C3 A1[4703]                	mov     ax,[Res_Tpa]
  5587                                  TpaSet:
  5588 000014C6 A3[3903]                	mov	[LTpa],ax			; Good enough for the moment
  5589                                  	;mov	ax,[2]
  5590 000014C9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5591                                  
  5592 000014CC 8C1E[3F03]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5593 000014D0 8C1E[4303]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5594 000014D4 8C1E[3703]              	mov	[MySeg],ds			;  use to call resident routines.
  5595                                  	; 19/04/2023
  5596                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5597 000014D8 8C1E[7006]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5598                                  
  5599 000014DC A3[8001]                	mov	[MemSiz],ax			; Needed for execing other programs
  5600                                  
  5601                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5602                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5603                                  
  5604                                  ; First reallocate the COMMAND size to its memory image
  5605                                  	
  5606 000014DF 50                      	push	ax    
  5607                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5608                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5609                                  	;mov	bx,TRANSTART
  5610                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5611                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5612                                  	;add	bx,15 ; *			; round up the size
  5613                                  
  5614                                  	; 03/05/2023
  5615                                  	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5616                                  	;;add	bx,TRANSPACEEND
  5617                                  	; 06/06/2023
  5618                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5619                                          ;mov	cl,4				;
  5620                                          ;shr	bx,cl				; size of command.com
  5621 000014E0 BB7A0B                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
  5622                                  	
  5623 000014E3 B44A                    	mov	ah,4Ah
  5624                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5625 000014E5 CD21                            int     21h				;
  5626 000014E7 58                              pop     ax				;
  5627                                  	
  5628                                  ; Compute maximum size of environment
  5629                                  
  5630                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5631                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5632                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5633                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5634                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5635 000014E8 C706[701C]4C00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5636                                  ;
  5637                                  ; Compute minimum size of environment
  5638                                  ;
  5639                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5640                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5641 000014EE C706[6E1C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5642                                  
  5643                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5644                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5645                                  	; 06/06/2023
  5646                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5647                                  	;mov	cl,4				;  in paragraphs.
  5648                                  	;shr	dx,cl
  5649 000014F4 BA5A09                  	mov	dx,(TRANSPACEEND+15)>>4
  5650 000014F7 8916[7E1C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5651                                  
  5652 000014FB 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5653 000014FD A3[7A01]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5654                                  	;mov	ax,[2Ch]
  5655 00001500 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5656                                  
  5657                                  	; 14/01/2023
  5658                                          ; MSDOS 6.0
  5659                                  	;mov	[EnvirSeg],ax
  5660                                          
  5661                                  	; 21/01/2023
  5662 00001503 09C0                    	or	ax,ax				; if there is no environment segment,
  5663 00001505 7406                    	jz	short buildenv			; make one
  5664                                    
  5665                                  	; 21/01/2023
  5666                                  	; MSDOS 3.3 & MSDOS 5.0
  5667                                  	;inc	byte [CHUCKENV]
  5668 00001507 FE06[521C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5669                                  	
  5670                                  	; MSDOS 3.3 & MSDOS 5.0
  5671 0000150B EB03                    	jmp	short environpassed
  5672                                  	; MSDOS 6.0
  5673                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5674                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5675                                  
  5676                                  	; MSDOS 6.0
  5677                                  
  5678                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5679                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5680                                  ; size and free this buffer. We need this buffer because we no longer have an
  5681                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5682                                  ; given on the command line before we know the environment size. This routine
  5683                                  ; will not return in case of an allocation error. It will either exit or hang
  5684                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5685                                  
  5686                                  	; 14/01/2023
  5687                                  buildenv:
  5688 0000150D E87206                  	call	alloc_env                       ; try to allocate buffer
  5689                                  environpassed:
  5690                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5691 00001510 A3[2703]                	mov	[EnvirSeg],ax
  5692                                  	;
  5693 00001513 8EC0                    	mov	es,ax                           ; and it load into es.
  5694                                  	;assume	es:nothing
  5695                                  
  5696                                  gottheenvir:
  5697                                  
  5698                                  ; Initialize the command drive
  5699                                  
  5700                                  ; 14/01/2023
  5701                                  %if 0
  5702                                  	; MSDOS 3.3
  5703                                  BUILDENV:
  5704                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5705                                  	mov	ax,PATHSTRING ; "PATH="
  5706                                  	mov	cl,4
  5707                                  	shr	ax,cl
  5708                                  	mov	dx,ds
  5709                                  	add	ax,dx
  5710                                  ENVIRONPASSED:
  5711                                          mov	[ENVIRSEG],ax
  5712                                          MOV     es,ax
  5713                                  
  5714                                          ;mov	ax,CHAR_OPER<<8
  5715                                          mov	ax,CHAR_OPER*256 ; 3700h
  5716                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5717                                  			; Return: AL = FFh unsupported subfunction
  5718                                  			; DL = current switch character
  5719                                          mov	[RSWITCHAR],dl
  5720                                  
  5721                                          ;CMP	dl,'/'
  5722                                  	cmp	dl,[slash_chr]
  5723                                          jnz	short IUSESLASH
  5724                                  
  5725                                  	;mov	al,'\'
  5726                                   	mov	al,[bslash_chr]
  5727                                  	mov	[COMSPECT],al
  5728                                  
  5729                                  	cmp	byte [CHUCKENV],0
  5730                                  	jnz	short IUSESLASH
  5731                                  
  5732                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5733                                  	; 30/04/2018
  5734                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5735                                  	; 23/09/2018
  5736                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5737                                  gottheenvir:
  5738                                  IUSESLASH:
  5739                                  
  5740                                  ; Initialize the command drive
  5741                                  
  5742                                  %endif
  5743                                  	; 14/01/2023
  5744                                  	; MSDOS 3.3 & MSDOS 6.0
  5745 00001515 B419                    	mov	ah,19h
  5746                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5747 00001517 CD21                    	int	21h
  5748 00001519 FEC0                    	inc	al
  5749 0000151B A2[7F01]                	mov	[ComDrv],al
  5750                                  
  5751                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5752 0000151E A05C00                          mov	al,[FCB]
  5753 00001521 08C0                    	or	al,al
  5754 00001523 7426                    	jz	short nocomdrv		; no drive specified
  5755                                  
  5756 00001525 B43A                    	mov	ah,':'
  5757 00001527 A2[7F01]                	mov	[ComDrv],al
  5758 0000152A 0440                    	add	al,40h			; convert number to uppercase character
  5759                                  
  5760 0000152C FD                      	std
  5761                                  
  5762                                  	; MSDOS 6.0
  5763                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5764                                  	;je	short notwidenv		;  move the default comspec string in it
  5765                                  	; 14/01/2023
  5766                                  	; MSDOS 5.0 COMMAND.COM
  5767                                  	;mov	di,[ComspOffset]
  5768                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5769                                          ;je	short notwidenv		; yes, must have been inherited that way
  5770                                  
  5771                                  	; MSDOS 3.3
  5772                                  	;cmp	byte [CHUCKENV],0
  5773                                  	;jne	short NOTWIDENV
  5774                                  	; 21/01/2021
  5775                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5776 0000152D 803E[521C]00             	cmp	byte [AllocedEnv],0
  5777 00001532 7713                    	ja	short notwidenv
  5778                                  
  5779 00001534 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5780 00001535 06                      	push	es			;  the drivespec is in ax and is copied
  5781 00001536 1F                      	pop	ds			;  on to the front of the string.
  5782                                  
  5783                                  	; MSDOS 6.0
  5784                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5785                                          ;lea	di,[di+MAX_COMSPEC-1]
  5786                                  
  5787                                  	; 21/01/2023
  5788                                  	; 14/01/2023
  5789                                  	; MSDOS 5.0 COMMAND.COM
  5790                                  	; MSDOS 3.3
  5791                                  	; 23/09/2018
  5792                                  	; 30/04/2018
  5793                                  	;mov	di,159
  5794                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5795                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5796 00001537 BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5797                                  	;mov	si,157
  5798                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5799                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5800 0000153A BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5801                                  	;mov	cx,144
  5802                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5803 0000153D B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5804                                  
  5805 00001540 F3A4                    	rep	movsb
  5806 00001542 1F                      	pop	ds
  5807                                  
  5808                                  	; MSDOS 6.0
  5809                                  	;mov	word ptr es:[di-1],ax
  5810                                  
  5811                                  	; MSDOS 3.3
  5812                                  	;mov	[es:0Eh],ax
  5813                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5814                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5815                                  	; 14/01/2023
  5816 00001543 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5817                                  
  5818                                  	; MSDOS 3.3 & MSDOS 6.0
  5819                                  notwidenv:
  5820 00001547 FC                      	cld
  5821 00001548 A3[341C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5822                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5823                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5824                                  	;mov	[KAUTOBAT],ax
  5825                                  nocomdrv:
  5826 0000154B E8A4FA                  	call	SetVect        ; Set the vectors
  5827                                  
  5828                                  ; parsing starts here
  5829                                  
  5830                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5831                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5832                                  	; MSDOS 6.0
  5833 0000154E 0E                      	push	cs
  5834 0000154F 0E                      	push	cs
  5835 00001550 1F                      	pop	ds
  5836 00001551 07                      	pop	es
  5837                                  	;assume ds:ResGroup,es:ResGroup
  5838                                  
  5839                                  ; 14/01/2023
  5840                                  %if 0	
  5841                                  	; MSDOS 3.3
  5842                                  	mov	si,80h		; get command line
  5843                                  	lodsb			; get length of line
  5844                                  	mov	cl,al
  5845                                  	xor	ch,ch		; cx = length of command line
  5846                                  
  5847                                  ; insure that the command line correctly ends with a cr
  5848                                  
  5849                                  	add	si,cx		; go to end of command line	
  5850                                  	mov	byte [si], 0Dh	; insert a carriage return
  5851                                  
  5852                                  	mov	si,81h		; Start of parms
  5853                                  CHKARG:
  5854                                          jcxz	COMRETURNSJ     ; No parameters
  5855                                          dec	cx
  5856                                  	lodsb
  5857                                  CHECKSWITCHCHR:
  5858                                  	;cmp	al,' '
  5859                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5860                                  	jz	short CHKARG
  5861                                  	cmp	al,9		; Skip TAB characters
  5862                                  	jz	short CHKARG
  5863                                  	cmp	al,[RSWITCHAR]	; Switch?
  5864                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5865                                  	jmp	CHKOTHERARGS	; No
  5866                                  
  5867                                  %endif
  5868                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5869                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5870                                  	; MSDOS 6.0
  5871                                  
  5872 00001552 BE8000                  	mov	si,80h				; get command line
  5873 00001555 AC                      	lodsb					; get length of line
  5874 00001556 89F7                    	mov	di,si				; get line position in di
  5875 00001558 30E4                    	xor	ah,ah				; ax = length of command line
  5876                                  
  5877                                  ; insure that the command line correctly ends with a cr
  5878                                  
  5879 0000155A 01C7                    	add	di,ax				; go to end of command line
  5880 0000155C C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5881 0000155F 31C9                    	xor	cx,cx				; clear cx
  5882 00001561 890E[141D]                      mov	[num_positionals],cx		; initialize positionals
  5883                                  
  5884                                  ; Scan the command line looking for the parameters
  5885                                  
  5886                                  Parse_command_line:
  5887                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5888 00001565 BF[861C]                	mov	di,PARSE_COMMAND
  5889 00001568 8B0E[141D]              	mov	cx,[num_positionals]		; Get number of positionals
  5890 0000156C 31D2                    	xor	dx,dx				; clear dx
  5891 0000156E 8936[161D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5892                                  	;call	dword ptr Init_Parse
  5893 00001572 FF1E[7A1C]              	call	far [Init_Parse]		; call parser
  5894 00001576 890E[141D]                      mov     [num_positionals],cx		; Save number of positionals
  5895                                  	; 29/01/2023
  5896                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5897                                          ;cmp	ax,-1
  5898                                  	;jne	short t1
  5899                                  	; 10/06/2023
  5900 0000157A 40                      	inc	ax	 ; cmp ax,-1
  5901 0000157B 7503                    	jnz	short t1 ; 0FFFFh -> 0
  5902                                  	; ax = 0
  5903 0000157D E9FB01                  	jmp     ArgsDone                        ; yes - exit
  5904                                  t1:	
  5905                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5906                                  	;;cmp	ax,0
  5907                                  	;and	ax,ax
  5908                                  	; 10/06/2023
  5909 00001580 48                      	dec	ax  ; cmp ax,0
  5910 00001581 7447                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  5911                                  
  5912                                  ; Before issuing error message - make sure switch is not /C
  5913                                  
  5914                                  parse_line_error:
  5915                                  	; 14/01/2023
  5916                                  	;push	si				; save line position
  5917                                  	;push	ax				; save error number
  5918                                  	;cmp	ax,3
  5919 00001583 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5920                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5921 00001586 752A                    	jne	short parse_line_error_disp2
  5922 00001588 56                      	push	si ; **				; save line position
  5923 00001589 50                      	push	ax ; *				; save error number
  5924 0000158A 89F7                    	mov	di,si				; Get terminating pointer in DI
  5925 0000158C 8B36[161D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5926                                  
  5927                                  init_chk_delim:
  5928 00001590 39FE                    	cmp	si,di				; at end of parsed parameter?
  5929 00001592 741C                            je	short parse_line_error_disp	; Yes - just display message
  5930 00001594 AC                      	lodsb					;
  5931 00001595 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5932                                  	;cmp	al,space_chr ; 14/01/2023
  5933                                  	;;cmp	al,[space]			; Skip blank spaces
  5934 00001597 74F7                    	je	short init_chk_delim		;
  5935                                  	;cmp	al,9
  5936 00001599 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5937 0000159B 74F3                    	je	short init_chk_delim		;
  5938                                  
  5939 0000159D 3A06[3B03]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5940 000015A1 750D                            jne	short parse_line_error_disp	; No - just issue message
  5941 000015A3 AC                      	lodsb					; Get the char after the switch
  5942                                  
  5943 000015A4 E86804                  	call	iupconv 			; upper case it
  5944                                  
  5945                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5946                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5947                                  	;16/04/2023
  5948 000015A7 3C43                    	cmp	al,'C' ; scswitch
  5949 000015A9 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5950 000015AB 5A                      	pop	dx ; *				; even up stack
  5951 000015AC 5A                      	pop	dx ; **				; even up stack
  5952 000015AD E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5953                                  
  5954                                  	; MSDOS 6.0
  5955                                  ;check_k_too:
  5956                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  5957                                          ;jne	short parse_line_error_disp	;
  5958                                  	;pop	dx ; *				; even up stack
  5959                                  	;pop	dx ; **				; even up stack
  5960                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5961                                  
  5962                                  parse_line_error_disp:
  5963                                  	; 14/01/2023
  5964 000015B0 58                      	pop	ax ; *				; restore error number
  5965 000015B1 5E                      	pop	si ; **				; restore line position
  5966                                  parse_line_error_disp2:
  5967 000015B2 89C2                    	mov	dx,ax				; get message number
  5968 000015B4 E8FC03                  	call	RPrintParse
  5969 000015B7 E8B8FC                  	call	crlf
  5970 000015BA EBA9                            jmp     short Parse_command_line        ; continue parsing
  5971                                  
  5972                                  ; 16/04/2023
  5973                                  %if 1
  5974                                  SetMSwitch:
  5975                                          ;cmp	byte [ext_msg],1
  5976 000015BC 803E[811C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5977                                  	; 16/04/2023
  5978                                  	;jnz	short setMswitchok		; no - set it
  5979                                  	;;mov	ax,1
  5980                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5981                                  	;jmp	parse_line_error                ; go issue error message
  5982                                  	; 16/04/2023
  5983 000015C1 744F                    	je	short parse_line_error_j
  5984                                  setMswitchok:
  5985                                          ;mov	byte [ext_msg],1
  5986 000015C3 C606[811C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  5987                                  	; 06/06/2023
  5988 000015C8 EB9B                    	jmp	short Parse_command_line	; keep parsing
  5989                                  %endif
  5990                                  
  5991                                  parse_cont:
  5992                                  
  5993                                  ; 15/01/2023
  5994                                  %if 0
  5995                                  	; MSDOS 3.3
  5996                                  
  5997                                  ; See if a switch was entered
  5998                                  
  5999                                  	jcxz	COMRETURNSJ
  6000                                  	dec	cx
  6001                                  	lodsb
  6002                                  	or	al,20h		; Lower case
  6003                                  	cmp	al,'f'		; FAIL switch
  6004                                  	jnz     short CHECKPSWITCH
  6005                                  %endif
  6006                                  
  6007                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6008                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6009                                  	; MSDOS 6.0
  6010                                  
  6011                                  ; See if a switch was entered
  6012                                  ;
  6013                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6014                                  
  6015 000015CA 813E[0D1D][BD1C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6016 000015D0 742A                    	je	short SetFSwitch		; yes go set fail switch
  6017 000015D2 813E[0D1D][B11C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6018 000015D8 7431                    	je	short SetPSwitch		; yes go set up PERMCOM
  6019 000015DA 813E[0D1D][C91C]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6020 000015E0 7453                    	je	short SetDSwitch		; yes go set date switch
  6021 000015E2 813E[0D1D][EE1C]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6022 000015E8 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6023                                  	; MSDOS 6.0 only!
  6024                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6025                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  6026 000015EA 813E[0D1D][D51C]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6027 000015F0 7467                    	je	short SetESwitch		; yes go set up environment
  6028 000015F2 813E[0D1D][FA1C]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6029                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6030                                  	; 15/01/2023
  6031 000015F8 74C2                    	je	short SetMSwitch 
  6032 000015FA EB7B                    	jmp	ChkOtherArgs		; Must be something else
  6033                                  
  6034                                  	; MSDOS 6.0
  6035                                  ;SetMSwitchjmp:
  6036                                  	;jmp	SetMSwitch
  6037                                  	
  6038                                  	; MSDOS 6.0
  6039                                  SetFSwitch:
  6040 000015FC 803E[9201]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6041                                  	; 16/04/2023
  6042                                  	;jne	short failok		; no - set it
  6043                                  	;;mov	ax,1
  6044                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6045                                          ;jmp	parse_line_error        ; go issue error 
  6046                                  	; 16/04/2023
  6047 00001601 740F                    	je	short parse_line_error_j
  6048                                  
  6049                                  	; MSDOS 3.3 & MSDOS 6.0
  6050                                  failok:
  6051 00001603 C606[9201]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6052                                  	; MSDOS 3.3
  6053                                  	;jmp	short CHKARG
  6054                                  	; MSDOS 6.0
  6055 00001608 E95AFF                  	jmp	Parse_command_line
  6056                                  
  6057                                  ;CHECKPSWITCH:
  6058                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6059                                  	;cmp	al,[letter_p]
  6060                                          ;jnz	short CHECKDSWITCH
  6061                                  
  6062                                  SetPSwitch:
  6063                                  
  6064                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6065                                  ; termination address.
  6066                                  
  6067                                  	; MSDOS 6.0
  6068 0000160B 803E[8D01]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6069 00001610 7406                    	jz	short permcomok		; no - set it
  6070                                  	; 16/04/2023
  6071                                  parse_line_error_j:
  6072                                          ;mov	ax,1
  6073 00001612 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6074 00001615 E96BFF                          jmp	parse_line_error	; go issue error 
  6075                                  
  6076                                  permcomok:
  6077                                  	; MSDOS 3.3 & MSDOS 6.0
  6078 00001618 FE06[8D01]              	inc	byte [PermCom]
  6079                                  	;mov	word [OLDTERM],LODCOM
  6080 0000161C C706[2B01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6081                                  	;mov	[OLDTERM+2],ds
  6082 00001622 8C1E[2D01]              	mov	[OldTerm+2],ds
  6083                                  
  6084                                  ; make sure that we display the date and time. if the flag was not
  6085                                  ; initialized, set it to indicate yes, do prompt.
  6086                                  
  6087                                  	; MSDOS 3.3
  6088                                  	;cmp	byte [PRDATTM],-1
  6089                                  	;jnz	short CHKARG
  6090                                  	;mov	byte [PRDATTM],0
  6091                                  	;jmp	short CHKARG
  6092                                  
  6093                                  	; MSDOS 6.0
  6094 00001626 803E[451C]FF            	cmp	byte [PRDATTM],-1
  6095 0000162B 7505                    	jne	short Parse_command_line_jmp
  6096 0000162D C606[451C]00            	mov	byte [PRDATTM],0
  6097                                  Parse_command_line_jmp:
  6098 00001632 E930FF                  	jmp     Parse_command_line	; keep parsing
  6099                                  
  6100                                  ;COMRETURNSJ:
  6101                                  ;	; MSDOS 3.3
  6102                                  ;	JMP	ARGSDONE
  6103                                  
  6104                                  ;CHECKDSWITCH:
  6105                                  	;;cmp	al,'d'
  6106                                          ;cmp	al,[letter_d]
  6107                                  	;jnz	short CHECKCSWITCH
  6108                                  
  6109                                  SetDSwitch:
  6110                                  
  6111                                  ; Flag no date/time prompting.
  6112                                  
  6113                                  	; MSDOS 6.0
  6114 00001635 803E[831C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6115                                  	; 16/04/2023
  6116                                  	;jz	short setdateok		; no - set it
  6117                                          ;;mov	ax,1
  6118                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6119                                          ;jmp	parse_line_error	; go issue error message
  6120                                  	; 16/04/2023
  6121 0000163A 75D6                    	jnz	short parse_line_error_j
  6122                                  setdateok:
  6123 0000163C FE06[831C]              	inc	byte  [dswitch]		; indicate /D entered
  6124                                  
  6125                                  	; MSDOS 3.3 & MSDOS 6.0
  6126 00001640 C606[451C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6127                                  	; MSDOS 3.3
  6128                                  	;jmp	short CHKARG
  6129                                  	; MSDOS 6.0
  6130 00001645 E91DFF                  	jmp     Parse_command_line	; continue parsing
  6131                                  
  6132                                  	; 15/01/2023
  6133                                  	; MSDOS 6.0 
  6134                                  ;SetKSwitch:
  6135                                  	;mov	byte [SemiPermCom],0
  6136                                  	;jmp	short SetSorKSwitch
  6137                                  
  6138                                  ;CHECKCSWITCH:
  6139                                  	;;cmp	al,'c'
  6140                                  	;cmp	al,[letter_c]
  6141                                          ;jnz	short CHECKESWITCH
  6142                                  
  6143                                  SetSSwitch:
  6144                                  ;SETCSWITCH:
  6145                                  
  6146                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6147                                  
  6148 00001648 C606[8D01]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6149                                  ;SetSorKSwitch:
  6150 0000164D 8936[8E01]              	mov	[SingleCom],si		; Point to the rest of the command line
  6151 00001651 C606[451C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6152                                  ;COMRETURNSJ: ; 24/09/2018
  6153 00001656 E92201                  	jmp     ArgsDone
  6154                                  
  6155                                  ;CHECKESWITCH:
  6156                                  	;cmp	al,'e'
  6157                                  	;jnz	short CHKARG
  6158                                  
  6159                                  ; Look for environment-size setting switch
  6160                                  
  6161                                  ; The environment size is represented in decimal bytes and is
  6162                                  ; converted into paragraphs (rounded up to the next paragraph).
  6163                                  
  6164                                  SetESwitch:
  6165                                  	; MSDOS 6.0
  6166 00001659 803E[821C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6167                                  	; 16/04/2023
  6168                                  	;jz	short eswitchok		; no - set it
  6169                                  	;;mov	ax,1
  6170                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6171                                          ;jmp	parse_line_error	; go issue error message
  6172                                  	; 16/04/2023
  6173 0000165E 75B2                    	jnz	short parse_line_error_j
  6174                                  eswitchok:
  6175 00001660 FE06[821C]              	inc	byte [eswitch]		; indicate /E entered
  6176                                  
  6177                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6178                                  %if 0
  6179                                  	; 23/09/2018 - Retro DOS v3.0
  6180                                  
  6181                                  	; MSDOS 3.3
  6182                                  	; (COMMAND.COM offset 0FC5h)
  6183                                  ESWITCHOK:
  6184                                  	jcxz    CHKARG
  6185                                  	dec     cx
  6186                                  	lodsb
  6187                                  	cmp     al,':'
  6188                                  	jnz     short CHECKSWITCHCHR
  6189                                  	xor     bx,bx
  6190                                  	mov     ax,bx
  6191                                  GETENVSIZE:
  6192                                  	jcxz    SETENVSIZE
  6193                                  	dec     cx
  6194                                  	lodsb
  6195                                  	cmp     al,'0'
  6196                                  	jb      short NOTDECIMALCHR
  6197                                  	cmp     al,'9'
  6198                                  	ja      short NOTDECIMALCHR
  6199                                  	sub     al,'0'
  6200                                  	mov     dx,bx
  6201                                  	shl     dx,1
  6202                                  	shl     dx,1   ; dx = 4*bx
  6203                                  	add     bx,dx  ; bx = 5*bx
  6204                                  	shl     bx,1   ; bx = 10*bx
  6205                                  	add     bx,ax
  6206                                  	jmp     short GETENVSIZE
  6207                                  
  6208                                  NOTDECIMALCHR:
  6209                                  	;cmp	al,' '
  6210                                  	cmp	al,[SPACE_CHAR]
  6211                                  	jz      short CHECKENVSIZE
  6212                                  	;cmp	al,'/'
  6213                                  	cmp     al,[RSWITCHAR]
  6214                                  	jz      short CHECKENVSIZE
  6215                                  
  6216                                  CHECKNEXTECHR:
  6217                                  	jcxz    INVENVSIZE
  6218                                  	dec     cx
  6219                                  	lodsb
  6220                                  	;cmp	al,' '
  6221                                  	cmp     al,[SPACE_CHR]
  6222                                  	jz      short ENVSIZESPC
  6223                                  	;cmp	al,'/'
  6224                                  	cmp     al,[RSWITCHAR]
  6225                                  	jnz     short CHECKNEXTECHR
  6226                                  
  6227                                  ENVSIZESPC:
  6228                                  	dec     si
  6229                                  	inc     cx
  6230                                  	jmp     short INVENVSIZE
  6231                                  	
  6232                                  	;nop
  6233                                  
  6234                                  CHECKENVSIZE: 
  6235                                  	dec     si
  6236                                  	inc     cx
  6237                                  
  6238                                  SETENVSIZE:
  6239                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6240                                  	mov	word [ENVSIZ],ENVBIG/16
  6241                                  	cmp     bx,32768
  6242                                  	ja      short INVENVSIZE
  6243                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6244                                  	mov	word [ENVSIZ],ENVSML/16
  6245                                  	cmp     bx,160
  6246                                  	jb      short INVENVSIZE
  6247                                  	add     bx,15
  6248                                  	shr     bx,1
  6249                                  	shr     bx,1
  6250                                  	shr     bx,1
  6251                                  	shr     bx,1
  6252                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6253                                  	jmp     short NEXTCH2
  6254                                  
  6255                                  	;nop
  6256                                  
  6257                                  INVENVSIZE:
  6258                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6259                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6260                                  	int     21h             ; DOS - PRINT STRING
  6261                                  				; DS:DX -> string terminated by "$"
  6262                                  NEXTCH2:
  6263                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6264                                  	jmp     CHKARG
  6265                                  
  6266                                  	;jmp	ARGSDONE
  6267                                  
  6268                                  %endif
  6269                                  	; 15/01/2023
  6270                                  	; MSDOS 6.0
  6271                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6272 00001664 BF[0F1D]                        mov	di,COMND1_ADDR
  6273 00001667 8B1D                    	mov     bx,[di]				; into bx
  6274                                  
  6275 00001669 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6276 0000166C B104                    	mov	cl,4				; convert to pargraphs
  6277 0000166E D3EB                    	shr	bx,cl				; by right 4
  6278                                  
  6279 00001670 891E[6E1C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6280 00001674 E9EEFE                  	jmp	Parse_command_line		; continue parsing command line
  6281                                  
  6282                                  ; 16/04/2023
  6283                                  %if 0
  6284                                  SetMSwitch:
  6285                                          ;cmp	byte [ext_msg],1
  6286                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6287                                  	jnz	short setMswitchok		; no - set it
  6288                                  	;mov	ax,1
  6289                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6290                                  	jmp	parse_line_error                ; go issue error message
  6291                                  setMswitchok:
  6292                                          ;mov	byte [ext_msg],1
  6293                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6294                                  	jmp	Parse_command_line              ; keep parsing
  6295                                  %endif
  6296                                  
  6297                                  ;ArgsDoneJ:
  6298                                  	;jmp	ArgsDone
  6299                                  
  6300                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6301                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6302                                  	
  6303                                  ChkOtherArgs:
  6304                                  
  6305                                  ; We have a non-switch character here.
  6306                                  
  6307                                  	; MSDOS 6.0
  6308 00001677 1E                      	push	ds ; ****			;
  6309 00001678 56                      	push	si ; *** 			; save place in command line
  6310 00001679 C536[0F1D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6311                                  	;assume	ds:nothing			;
  6312                                  
  6313 0000167D 89F2                    	mov	dx,si				; put in dx also
  6314 0000167F B8023D                  	mov	ax,3D02h
  6315                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6316 00001682 CD21                    	int	21h
  6317 00001684 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6318 00001686 89C3                    	mov	bx,ax
  6319 00001688 B80044                  	mov	ax,4400h
  6320                                  	;mov	ax,IOCTL shl 8
  6321 0000168B CD21                    	int	21h
  6322 0000168D F6C280                  	test	dl,80h
  6323 00001690 7506                    	jnz	short IsaDevice
  6324                                  BadSetCon:
  6325 00001692 B43E                    	mov	ah,3Eh
  6326                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6327 00001694 CD21                    	int	21h
  6328 00001696 EB4E                    	jmp	short ChkSrchSpec
  6329                                  
  6330                                  ; 15/01/2023
  6331                                  %if 0
  6332                                  	; MSDOS 3.3
  6333                                  	; (COMMAND.COM offset 1047h)
  6334                                          dec	si
  6335                                  	inc	cx
  6336                                  	mov	dx,si
  6337                                  	push	cx ; **
  6338                                  	push	si ; *
  6339                                  CONTRLOOP:
  6340                                  	lodsb
  6341                                  	dec	cx
  6342                                  	;cmp	al,' '
  6343                                  	cmp	al,[SPACE_CHR]
  6344                                  	jz	short SETCDEV
  6345                                  	cmp	al,9
  6346                                  	jz	short SETCDEV
  6347                                  	jcxz	SETCDEVA
  6348                                  	jmp	short CONTRLOOP
  6349                                  
  6350                                  SETCDEVA:
  6351                                          inc	si
  6352                                  SETCDEV:
  6353                                  	mov	byte [SI-1],0
  6354                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6355                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6356                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6357                                  			; DS:DX -> ASCIZ filename
  6358                                  			; AL = access mode
  6359                                  			; 2 - read & write
  6360                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6361                                          mov	bx,ax
  6362                                          ;mov	ax,IOCTL shl 8
  6363                                          mov     ax,IOCTL*256 ; 4400h
  6364                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6365                                  			; BX = file or device handle
  6366                                          test	dl,80H
  6367                                  	jnz	short ISADEVICE
  6368                                  BADSETCON: ; MSDOS 6.0
  6369                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6370                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6371                                  			; BX = file handle
  6372                                          JMP     short CHKSRCHSPEC
  6373                                  %endif
  6374                                  	;nop
  6375                                  
  6376                                  	; 15/01/2023
  6377                                  IsaDevice:
  6378                                  	; MSDOS 3.3 & MSDOS 6.0
  6379 00001698 30F6                    	xor	dh,dh
  6380 0000169A 80CA03                  	or	dl,3				; Make sure has CON attributes
  6381                                  	;mov	ax,(IOCTL shl 8) or 1
  6382 0000169D B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6383 000016A0 CD21                    	int	21h
  6384                                  	;
  6385                                  	; 15/01/2023
  6386 000016A2 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6387                                  	; 25/09/2018
  6388                                  	;pop	dx ; *
  6389                                  	;pop	dx ; **
  6390                                  	;
  6391                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6392                                  	
  6393 000016A4 89DA                    	mov	dx,bx				; Save new handle
  6394                                  
  6395                                  	; MSDOS 6.0
  6396 000016A6 26803E[C120]01          	cmp	byte [es:DevFlag],1
  6397 000016AC 742A                    	jz	short DevErr
  6398                                  
  6399                                  	; MSDOS 3.3
  6400                                          ;pop	bx ; *				; Throw away saved SI
  6401                                          ;pop	bx ; **				; Throw away saved CX
  6402                                  
  6403                                  	; MSDOS 3.3 & MSDOS 6.0
  6404 000016AE 51                      	push	cx ; **
  6405 000016AF B90300                  	mov	cx,3
  6406 000016B2 31DB                    	xor	bx,bx
  6407                                  
  6408                                  	; 15/01/2023
  6409                                  rcclloop:
  6410 000016B4 B43E                    	mov	ah,3Eh
  6411                                  	;mov	ah,CLOSE ; 3Eh
  6412 000016B6 CD21                    	int	21h
  6413 000016B8 43                      	inc	bx
  6414 000016B9 E2F9                    	loop	rcclloop
  6415                                  
  6416 000016BB 89D3                    	mov	bx,dx				; New device handle
  6417 000016BD B445                    	mov	ah,45h
  6418                                  	;mov	ah,XDUP ; 45h
  6419 000016BF CD21                    	int	21h				; Dup to 0
  6420 000016C1 B445                    	mov	ah,45h
  6421                                  	;mov	ah,XDUP
  6422 000016C3 CD21                    	int	21h				; Dup to 1
  6423 000016C5 B445                    	mov	ah,45h
  6424                                  	;mov	ah,XDUP
  6425 000016C7 CD21                    	int	21h				; Dup to 2
  6426 000016C9 B43E                    	mov	ah,3Eh
  6427                                  	;mov	ah,CLOSE
  6428 000016CB CD21                    	int	21h				; Close initial handle
  6429                                  	
  6430 000016CD 59                      	pop	cx ; **
  6431                                  	
  6432                                  	; MSDOS 6.0
  6433 000016CE 5E                      	pop	si ; ***			; restore position of command line
  6434 000016CF 1F                      	pop	ds ; ****			;
  6435                                  
  6436                                  ; Register the fact that we already have redirected the output
  6437                                  ; and can not do it again
  6438                                  
  6439 000016D0 26FE06[C120]            	inc	byte [es:DevFlag]		
  6440 000016D5 E98DFE                  	jmp	Parse_command_line		; continue parsing
  6441                                  
  6442                                  	; MSDOS 3.3
  6443                                  	;jcxz	ARGSDONEJ2
  6444                                  	;jmp	CHKARG
  6445                                  
  6446                                  	; MSDOS 6.0
  6447                                  DevErr:
  6448 000016D8 5E                      	pop	si ; ***
  6449 000016D9 1F                      	pop	ds ; ****
  6450 000016DA BA0100                  	mov	dx,1
  6451 000016DD E8D302                          call	RPrintParse                     ; "Too many parameters"
  6452 000016E0 E88FFB                          call	crlf
  6453 000016E3 E97FFE                  	jmp	Parse_command_line
  6454                                  
  6455                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6456                                  	; MSDOS 6.0
  6457 000016E6 26803E[C220]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6458 000016EC 74EA                            jz	short DevErr			; yes, error
  6459                                  	
  6460 000016EE 26FE06[C220]                    inc	byte [es:PathFlag]		; mark that we have a path
  6461                                  
  6462                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6463                                  ; This buffer will later be replaced by a proper environment
  6464                                  
  6465                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6466                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6467 000016F3 36A1[2703]              	mov	ax,[ss:EnvirSeg]
  6468                                  	
  6469                                  	; MSDOS 6.0
  6470                                  	;call	alloc_env                       ; environment buffer
  6471                                  
  6472                                  	; 15/01/2023
  6473                                  	; MSDOS 5.0
  6474 000016F7 36803E[521C]01          	cmp	byte [ss:AllocedEnv],1
  6475 000016FD 36C606[521C]00          	mov	byte [ss:AllocedEnv],0
  6476 00001703 7507                    	jne     short env_alloced
  6477 00001705 E87A04                  	call	alloc_env
  6478 00001708 36A3[2703]              	mov	[ss:EnvirSeg],ax
  6479                                  
  6480                                  env_alloced:
  6481                                  	; MSDOS 5.0 & MSDOS 6.0
  6482 0000170C 8EC0                    	mov	es,ax
  6483                                  	;assume	es:nothing
  6484 0000170E 56                      	push	si ; **				; remember location of file
  6485 0000170F 31C9                    	xor	cx,cx				; clear cx for counting
  6486                                  	
  6487                                  	; 15/01/2023
  6488                                  countloop:
  6489 00001711 AC                      	lodsb					; get a character
  6490 00001712 41                      	inc	cx				; increment counter
  6491                                          ;;cmp	al,0
  6492                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6493                                  	;jne	short countloop			; no - keep counting
  6494 00001713 08C0                    	or	al,al	
  6495 00001715 75FA                    	jnz	short countloop
  6496                                  
  6497                                  	;;;;mov	al,[Space]
  6498                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6499                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6500                                  	; 16/04/2023
  6501                                  	;mov	al,20h ; ' ' 
  6502 00001717 4E                      	dec	si				; move back one
  6503                                          ;mov	[si],al				; put a space at end of line
  6504 00001718 C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6505                                  
  6506                                  ; We now know how long the new pathspec for command.com is. Time to
  6507                                  ; figure out how long the current COMSPEC setting is, and then to move
  6508                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6509                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6510                                  ; where the filespec exists in the environment) is updated as well.
  6511                                  
  6512                                  	; MSDOS 6.0 COMMAND.COM
  6513                                  	;push	cx                              ;
  6514                                          ;mov	cx,ENVBIG                       ;
  6515                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6516                                          ;mov	al,0                            ;
  6517                                          ;repne	scasb                           ; find the end of COMSPEC
  6518                                          ;mov	si,di                           ;
  6519                                  ;comp_endenv:                                   ;
  6520                                          ;scasb                                  ; end of env?
  6521                                          ;je	got_endenv                      ; yes
  6522                                          ;repne	scasb                           ;
  6523                                          ;jmp	comp_endenv                     ;
  6524                                  ;got_endenv:                                    ;
  6525                                          ;mov    cx,di                           ;
  6526                                          ;sub    cx,si                           ;
  6527                                          ;mov    di,ComspOffset                  ;
  6528                                          ;sub    di,ComspStrLen                  ;
  6529                                          ;push   ds                              ;
  6530                                          ;push   es                              ;
  6531                                          ;pop    ds                              ;
  6532                                          ;rep    movsb                           ;
  6533                                          ;dec    di                              ; copy in new COMSPEC=
  6534                                          ;push   cs                              ;
  6535                                          ;pop    ds                              ;
  6536                                          ;assume ds:ResGroup                     ;
  6537                                          ;mov    si,offset RESGROUP:ComspString  ;
  6538                                          ;mov    cx,ComspStrLen                  ;
  6539                                          ;rep    movsb                           ;
  6540                                          ;mov    ComspOffset,di                  ;
  6541                                          ;pop    ds                              ;
  6542                                          ;assume ds:nothing                      ;
  6543                                          ;pop    cx                              ;
  6544                                  	;
  6545                                          ;pop    si                              ; get new comspec location back
  6546                                  
  6547                                  	; MSDOS 3.3 COMMAND.COM
  6548                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6549                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6550                                  	;mov	cl,4
  6551                                  	;shr	ax,cl
  6552                                  	;mov	dx,ds
  6553                                  	;add	ax,dx
  6554                                  	;mov	[ENVIRSEG],ax
  6555                                  	;mov	es,ax
  6556                                  	;;mov	al,' '
  6557                                  	;mov	al,[SPACE_CHR]
  6558                                  	;mov	[si-1],al
  6559                                  	;pop	si ; **				; Remember location
  6560                                  	;pop	cx ; *				; and count
  6561                                  	;;mov	di,[ECOMLOC]
  6562                                  	;mov	di,[COMSPOFFSET]
  6563                                  
  6564                                  	; 15/01/2023
  6565                                  	; MSDOS 5.0 COMMAND.COM
  6566 0000171B 5E                      	pop	si ; **
  6567                                  	;mov	di,14
  6568 0000171C BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6569                                  
  6570                                  ComtrLoop:
  6571                                  	; MSDOS 3.3 & MSDOS 6.0
  6572 0000171F AC                      	lodsb
  6573 00001720 49                      	dec	cx
  6574                                  	;;;;cmp	al,' '
  6575                                  	;;;cmp	al,[space_chr]
  6576                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6577                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6578                                  	; 16/04/2023
  6579 00001721 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6580 00001723 7405                    	je	short SetComsr
  6581                                  	; MSDOS 3.3
  6582                                  	;cmp	al,9
  6583                                  	;je	short SetComsr
  6584                                  	; MSDOS 3.3 & MSDOS 6.0
  6585 00001725 AA                      	stosb
  6586 00001726 E302                    	jcxz	SetComsr
  6587 00001728 EBF5                    	jmp	short ComtrLoop
  6588                                  
  6589                                  SetComsr:
  6590                                  	; 15/01/2023
  6591                                  	; MSDOS 6.0
  6592 0000172A 51                      	push	cx ; **
  6593 0000172B 0E                      	push	cs				; Get local segment
  6594 0000172C 1F                      	pop	ds				;
  6595                                  	;assume	ds:ResGroup			;
  6596 0000172D 1E                      	push	ds ; *
  6597                                  	;mov	si,offset ResGroup:ComSpect
  6598 0000172E BE[261C]                	mov	si,COMSPECT
  6599 00001731 B90E00                  	mov	cx,14
  6600 00001734 268A45FF                	mov	al,[es:di-1]
  6601 00001738 3A06[3C03]              	cmp	al,[RDirChar]
  6602 0000173C 7502                    	jne	short iNotRoot
  6603 0000173E 46                      	inc	si				; Don't make a double /
  6604 0000173F 49                      	dec	cx
  6605                                  	
  6606                                  	; MSDOS 3.3
  6607                                  	;push	si
  6608                                  	;push	cx
  6609                                  	;push	ds
  6610                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6611                                  	;mov	cx,14
  6612                                  	;mov	al,[es:di-1]
  6613                                  	;call	PATHCHRCMPR
  6614                                  	;jnz	short INOTROOT			
  6615                                  	;inc	si				; Don't make a double /
  6616                                  	;dec	cx
  6617                                  
  6618                                  iNotRoot:
  6619                                  	; MSDOS 3.3 & MSDOS 6.0
  6620 00001740 F3A4                    	rep	movsb
  6621                                  
  6622                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6623                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6624                                  	; 15/01/2023
  6625                                  	;mov	dx,14
  6626 00001742 BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6627                                  
  6628 00001745 06                      	push	es
  6629 00001746 1F                      	pop	ds
  6630                                  	;;mov	ax,OPEN shl 8
  6631                                  	;mov	ax,OPEN*256 ; 3D00h
  6632 00001747 B8003D                  	mov	ax,3D00h ; 15/01/2023
  6633 0000174A CD21                    	int	21h				; Open COMMAND.COM
  6634 0000174C 1F                      	pop	ds ; *
  6635 0000174D 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6636 0000174F 89C3                    	mov	bx,ax				; Handle
  6637 00001751 B43E                    	mov	ah,3Eh ; 15/01/2023
  6638                                  	;mov	ah,CLOSE ; 3Eh
  6639 00001753 CD21                    	int	21h				; Close COMMAND.COM
  6640                                  SetComsrRet:
  6641                                  	; 15/01/2023
  6642 00001755 59                      	pop	cx ; **
  6643 00001756 5E                      	pop	si ; ***
  6644                                  
  6645                                  	; MSDOS 6.0
  6646 00001757 1F                      	pop	ds ; ****			;
  6647                                  	;assume	ds:ResGroup			;
  6648                                  	;
  6649 00001758 0E                      	push	cs				; Make sure local ES is
  6650 00001759 07                      	pop	es				;  restored
  6651 0000175A E908FE                  	jmp	Parse_command_line		; continue parsing command line
  6652                                  
  6653                                  	; MSDOS 3.3
  6654                                  ;ARGSDONEJ2:
  6655                                  	;jcxz	ARGSDONE
  6656                                  	;jmp	CHKARG
  6657                                  
  6658                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6659                                  SetComsrBad:
  6660                                  	; MSDOS 3.3 & MSDOS 6.0
  6661                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6662 0000175D BA[AA1D]                	mov	dx,BADCOMLKMES
  6663                                  
  6664                                  ;	Note: we're about to make a near call to TriageError, which
  6665                                  ;	lives in a different segment and group. Some linkers will
  6666                                  ;	generate a warning like "Possible fix-up overflow". We're
  6667                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6668                                  ;	we're still all together.
  6669                                  
  6670                                  	; 16/01/2023
  6671                                  	TRIAGEERROR equ TRANSTART+TriageError
  6672                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6673                                  
  6674                                  	;call	50B2h
  6675 00001760 E8(7A4E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6676                                  				; in original MSDOS 3.3 COMMAND.COM
  6677                                  
  6678                                  			; TriageError procedure is at offset 50B2h
  6679                                  			; in original MSDOS 5.0 COMMAND.COM	
  6680 00001763 83F841                  	cmp	ax,65
  6681 00001766 7503                    	jne	short doprt
  6682                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6683 00001768 BA[D31D]                	mov	dx,BADCOMACCMSG
  6684                                  doprt:
  6685 0000176B E807FB                  	call	RPrint
  6686                                  	;mov	si,offset ResGroup:ComSpect
  6687 0000176E BE[261C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6688                                  	;;mov	di,[ECOMLOC]
  6689                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6690                                  	; 16/01/2023
  6691 00001771 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6692 00001774 B90E00                  	mov	cx,14
  6693 00001777 F3A4                    	rep	movsb				; get my default back
  6694                                  
  6695 00001779 EBDA                    	jmp	short SetComsrRet
  6696                                  
  6697                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6698                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6699                                  ArgsDone:
  6700                                  	; MSDOS 6.0
  6701 0000177B 8E06[2703]              	mov	es,[EnvirSeg]			; get environment back
  6702                                  	;assume	es:nothing			;
  6703                                  
  6704                                  	; MSDOS 3.3 & MSDOS 6.0
  6705 0000177F 803E[8D01]00                    cmp	byte [PermCom],0
  6706 00001784 742E                            jz	short ComReturns
  6707                                  
  6708 00001786 06                      	push	es				; Save environment pointer
  6709 00001787 B450                    	mov	ah,50h
  6710                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6711 00001789 8CDB                    	mov	bx,ds
  6712 0000178B 8EC3                    	mov	es,bx
  6713 0000178D CD21                    	int	21h				; current process is me
  6714 0000178F BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6715                                  	;;mov	ax,offset RESGROUP:LODCOM
  6716                                  	;mov	ax,LODCOM
  6717                                  	; 16/01/2023
  6718 00001792 B8[7E00]                	mov	ax,LodCom_Trap
  6719 00001795 AB                              stosw
  6720 00001796 8CD8                            mov	ax,ds
  6721 00001798 AB                              stosw
  6722                                  	;;mov	ax,offset RESGROUP:CONTC
  6723                                  	;mov	ax,CONTC
  6724                                  	; 16/01/2023
  6725 00001799 B8[4A00]                	mov	ax,Ctrlc_Trap
  6726 0000179C AB                              stosw
  6727 0000179D 8CD8                            mov	ax,ds
  6728 0000179F AB                              stosw
  6729                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6730                                  	;mov	ax,CRITERR
  6731                                  	; 16/01/2023
  6732 000017A0 B8[5500]                	mov	ax,CritErr_Trap
  6733 000017A3 AB                      	stosw
  6734 000017A4 8CD8                    	mov     ax,ds
  6735 000017A6 AB                      	stosw
  6736                                  	;;mov	word ptr ds:16h,ds
  6737                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6738 000017A7 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6739                                          ;;mov	dx,offset RESGROUP:Int_2e
  6740                                  	;mov	dx,Int_2e
  6741                                          ; 16/01/2023
  6742 000017AB BA[3F00]                	mov	dx,Int2e_Trap
  6743 000017AE B82E25                  	mov	ax,252Eh
  6744                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6745                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6746 000017B1 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6747                                  			; AL = interrupt number
  6748                                  			; DS:DX = new vector to be used for specified interrupt
  6749 000017B3 07                              pop	es				; Remember environment
  6750                                  	
  6751                                  ComReturns:
  6752                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6753 000017B4 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6754                                  	; 16/01/2023
  6755 000017B7 A3[2901]                	mov	[Parent],ax			; Save parent
  6756                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6757 000017BA 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6758                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6759 000017BE A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6760 000017C1 A3[8A01]                        mov	[Io_Save],ax		; Get the default stdin and out
  6761 000017C4 8C1E[2B03]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6762 000017C8 8C1E[2F03]                      mov	[Com_Fcb1+2],ds
  6763 000017CC 8C1E[3303]              	mov	[Com_Fcb2+2],ds
  6764                                          ;mov	di,offset ResGroup:ComSpec
  6765 000017D0 BF[3601]                        mov	di,ComSpec
  6766                                  
  6767                                  	;;mov	si,[ECOMLOC]
  6768                                  	; 16/01/2023
  6769                                  	;mov	si,[ComspOffset]
  6770 000017D3 BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6771 000017D6 803E[521C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6772                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6773                                  	
  6774 000017DB 8CD8                    	mov	ax,ds				; Xchg es,ds
  6775 000017DD 06                      	push	es
  6776 000017DE 1F                      	pop	ds
  6777 000017DF 8EC0                    	mov	es,ax
  6778                                  
  6779                                  	;jne	short CopyComsp ; MSDOS 6.0
  6780                                  	; 16/01/2023	
  6781 000017E1 7417                    	je	short CopyComsp ; MSDOS 5.0
  6782                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6783                                  
  6784 000017E3 0E                              push	cs
  6785 000017E4 1F                              pop	ds
  6786                                  
  6787                                          ;mov	si,offset ResGroup:ComspString
  6788 000017E5 BE[591C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6789 000017E8 06                      	push	es
  6790 000017E9 57                      	push	di
  6791 000017EA E8D701                  	call	IfindE
  6792 000017ED 89FE                    	mov	si,di
  6793 000017EF 06                      	push	es
  6794 000017F0 1F                      	pop	ds
  6795 000017F1 5F                      	pop	di
  6796 000017F2 07                      	pop	es
  6797 000017F3 7305                            jnc	short CopyComsp
  6798                                  
  6799                                  	; MSDOS 6.0
  6800                                  ComSpecNofnd:
  6801                                  	;mov	si,offset ResGroup:ComspString
  6802                                  	;add	si,ComspStrLen
  6803                                  	;push	cs
  6804                                  	;pop	ds
  6805                                  
  6806                                  	; 21/01/2023
  6807                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6808                                  	;mov	si,0Eh
  6809 000017F5 BE0E00                  	mov	si,ECOMSPEC
  6810 000017F8 0E                      	push	cs
  6811 000017F9 1F                      	pop	ds	
  6812                                  
  6813                                  	; 21/01/2023
  6814                                  ;COMSPECNOFND:
  6815                                  	; MSDOS 3.3
  6816                                          ;;mov	si,[es:ECOMLOC]
  6817                                          ;mov	si,[es:COMSPOFFSET]
  6818                                  	;;add	si,offset RESGROUP:PATHSTRING
  6819                                          ;add	si,PATHSTRING ; "PATH="
  6820                                  	;push	cs
  6821                                  	;pop	ds
  6822                                  
  6823                                  CopyComsp:
  6824                                  	; 21/01/2023
  6825                                  ;COPYCOMSP:
  6826                                  	; MSDOS 3.3 & MSDOS 6.0
  6827                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6828                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6829 000017FA 26893E[1501]            	mov	[es:PutBackComSpec],di
  6830 000017FF 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6831 00001803 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6832                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6833                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6834 00001805 268306[1501]02          	add	word [es:PutBackComSpec],2
  6835                                  CopyComspLoop:
  6836 0000180B AC                      	lodsb
  6837 0000180C AA                      	stosb
  6838 0000180D 08C0                    	or	al,al
  6839 0000180F 75FA                    	jnz	short CopyComspLoop
  6840                                  
  6841 00001811 26893E[7601]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6842 00001816 26FF0E[7601]            	dec	word [es:ComSpec_End]
  6843 0000181B 268A26[7F01]            	mov	ah,[es:ComDrv]
  6844 00001820 80C440                  	add	ah,'A'-1 ; 40h
  6845 00001823 268826[1A01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6846                                  
  6847                                  	; -------------------------------
  6848                                  
  6849                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6850                                  %if 0
  6851                                  
  6852                                  	; MSDOS 3.3
  6853                                  	push	cs
  6854                                          pop	ds
  6855                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6856                                  	mov	bx,DATARESEND+15
  6857                                          mov	cl,4
  6858                                          shr	bx,cl
  6859                                          MOV     AH,SETBLOCK ; 4Ah
  6860                                          int	21h			; Shrink me to the resident only
  6861                                  
  6862                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6863                                  
  6864                                  	mov	byte [TRNMVFLG], 1
  6865                                  	push	es ; *
  6866                                  	mov	si,TRANSTART
  6867                                  	mov	di,0
  6868                                  	mov	es,[TrnSeg]
  6869                                  	;mov	cx,4D5Ch
  6870                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6871                                  	push	cx
  6872                                  	mov	ax,cx
  6873                                  	add	ax,si
  6874                                  	mov	cl,4
  6875                                  	shr	ax,cl
  6876                                  	inc	ax
  6877                                  	mov	cx,ds
  6878                                  	add	ax,cx
  6879                                  	cmp	ax,[TrnSeg]
  6880                                  	pop	cx
  6881                                  	jb	short MOV_DOWN
  6882                                  
  6883                                  	call	LOADCOM
  6884                                  	jmp	short ICHKSUM
  6885                                  
  6886                                  MOV_DOWN:
  6887                                  	add     si,cx
  6888                                  	dec     si
  6889                                  	add     di,cx
  6890                                  	dec     di
  6891                                  	std
  6892                                  	rep	movsb
  6893                                  	cld
  6894                                  
  6895                                  ICHKSUM:
  6896                                  	; 24/09/2018
  6897                                  ;
  6898                                  ; Compute checksum right now before we can get corrupted and save it
  6899                                  ;
  6900                                  	; MSDOS 6.0
  6901                                  	;mov	si,offset RESGROUP:TranStart
  6902                                  	;add	si,100h
  6903                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6904                                  	;
  6905                                  	;cld
  6906                                  	;shr	cx,1
  6907                                  	;xor	dx,dx
  6908                                  ;Ichksum:
  6909                                  	;lodsw
  6910                                  	;add	dx,ax
  6911                                  	;adc	dx,0
  6912                                  	;loop	Ichksum
  6913                                  	;
  6914                                          ;mov	Sum,dx			; store checksum
  6915                                  
  6916                                  	; MSDOS 3.3
  6917                                  	pop     es ; *
  6918                                  	call    CHKSUM
  6919                                  	mov     [SUM],dx
  6920                                  
  6921                                  	; MSDOS 3.3 & MSDOS 6.0
  6922                                          cmp     byte [PRDATTM],0	;
  6923                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6924                                  ;
  6925                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6926                                  ;
  6927                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6928                                  	;mov	bx,3
  6929                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6930                                          mov     ah,ALLOC ; 48h		;
  6931                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6932                                  			; BX = number of 16-byte paragraphs desired
  6933                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6934                                          mov     [BATCH],ax		; save batch segment
  6935                                  
  6936                                  NOBATCHSEG:
  6937                                  
  6938                                  %endif
  6939                                  	; -------------------------------
  6940                                  
  6941                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6942                                  	
  6943                                  	; MSDOS 6.0
  6944 00001828 E81002                  	call	setup_for_messages		; set up parse and extended error messages
  6945                                  
  6946                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6947                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6948                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6949                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6950                                  ; the data otherwise it is just the data.
  6951                                   
  6952 0000182B E8A702                  	call	Setup_res_end			; put resident size in ResSize
  6953                                  
  6954 0000182E 0E                      	push	cs
  6955 0000182F 1F                      	pop	ds
  6956                                  	;assume	ds:RESGROUP
  6957                                  
  6958                                  ;Public EnvMaximum
  6959                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6960                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6961                                  
  6962                                  	; 21/01/2023
  6963                                  	; MSDOS 6.0
  6964                                  	;;mov	si,offset RESGROUP:TranStart
  6965                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6966                                  	;mov	si,TRANSTART
  6967                                  	;add	si,100h
  6968                                  	; 23/04/2023
  6969 00001830 BE0023                  	mov	si,TRANSTART+100h
  6970                                  
  6971                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6972                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6973 00001833 B9[1085]                	mov	cx,TRANDATAEND-100h
  6974                                  
  6975 00001836 FC                      	cld
  6976 00001837 D1E9                    	shr	cx,1
  6977 00001839 31D2                    	xor	dx,dx
  6978                                  Ichksum:
  6979 0000183B AD                      	lodsw
  6980 0000183C 01C2                    	add	dx,ax
  6981 0000183E 83D200                  	adc	dx,0
  6982 00001841 E2F8                    	loop	Ichksum
  6983                                  
  6984 00001843 8916[8201]                      mov	[Sum],dx			; store checksum
  6985                                  
  6986 00001847 803E[451C]00                    cmp     byte [PRDATTM],0
  6987 0000184C 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6988                                  	
  6989                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6990                                  
  6991                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6992                                  	; 21/01/2023
  6993                                  	;mov	bx,4
  6994 0000184E BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  6995 00001851 B448                    	mov	ah,48h
  6996                                  	;mov	ah,ALLOC                        ;
  6997 00001853 CD21                            int	21h                             ;
  6998 00001855 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  6999 00001857 A3[3401]                        mov	[Batch],ax			; save batch segment
  7000                                  
  7001                                  NoBatchSeg:
  7002                                  
  7003                                  ; 21/01/2023
  7004                                  %if 0
  7005                                  	; MSDOS 3.3
  7006                                  	mov     bx,0FFFFh ; 65535
  7007                                  	mov     ah,ALLOC ; 48h
  7008                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7009                                  			; BX = number of 16-byte paragraphs desired
  7010                                  	sub     bx,[TRNSIZE]
  7011                                  	sub     bx,128
  7012                                  	mov     [ENVMAX],bx
  7013                                  
  7014                                  	cmp     bx,4096
  7015                                  	jb      short ALLOCENVIRSEG
  7016                                  	mov     bx,4096-1		; max. allowed environment size
  7017                                  	mov     [ENVMAX],bx
  7018                                  
  7019                                  ALLOCENVIRSEG:
  7020                                  	mov     ah,ALLOC ; 48h
  7021                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  7022                                  			; BX = number of 16-byte paragraphs desired
  7023                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  7024                                  	mov     [OLDENV],bx		; save it	
  7025                                  	mov     word [USEDENV],0	; initialize environment size counter
  7026                                  	mov     ds,bx
  7027                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  7028                                  	mov     es,ax
  7029                                  	xor     si,si
  7030                                  	mov     di,si
  7031                                  	mov     bx,[ss:ENVMAX]
  7032                                  	shl     bx,1
  7033                                  	shl     bx,1
  7034                                  	shl     bx,1
  7035                                  	shl     bx,1
  7036                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  7037                                  	dec     bx			; dec by one to leave room for double 0
  7038                                  	xor     dx,dx			; use dx to indicate that there was
  7039                                  					; no environment size error.
  7040                                  
  7041                                  NXSTR:
  7042                                  	call    GETSTRLEN		; get the size of the current env string
  7043                                  
  7044                                  	push    ds
  7045                                  	push    cs
  7046                                  	pop     ds
  7047                                  	add     [USEDENV],cx		; add the string length to env size
  7048                                  	pop     ds
  7049                                  	cmp     cx,1			; end of environment was encountered.
  7050                                  	je      short ENVEXIT
  7051                                  	sub     bx,cx
  7052                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  7053                                  	inc     dx			; out of env space msg must be displayed
  7054                                  	jmp     short ENVEXIT
  7055                                  
  7056                                  	;nop
  7057                                  
  7058                                  OKCPYSTR:
  7059                                  	jmp     short NXSTR
  7060                                  
  7061                                  ENVEXIT: 
  7062                                  	push    cs
  7063                                  	pop     ds
  7064                                  	or      dx, dx			; dx will be non-zero if error
  7065                                  	jz      short ENVNOERR
  7066                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  7067                                  	call    RPRINT
  7068                                  
  7069                                  %endif
  7070                                  
  7071                                  	; 21/01/2023
  7072                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7073 0000185A 8B1E[2703]              	mov	bx,[EnvirSeg]			; get old environment segment
  7074 0000185E 891E[721C]              	mov	[OldEnv],bx			; save it
  7075 00001862 C706[741C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7076 00001868 8EDB                    	mov	ds,bx
  7077                                  	;assume	ds:nothing
  7078                                  	
  7079 0000186A 31F6                    	xor	si,si
  7080 0000186C 89F7                    	mov	di,si
  7081                                  
  7082                                  ; This is the maximum allowed size for the environment
  7083                                  
  7084                                  	; 21/01/2023
  7085                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7086                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7087                                  	;;mov	[ss:EnvMax],bx
  7088                                  	;shl	bx,1
  7089                                  	;shl	bx,1
  7090                                  	;shl	bx,1
  7091                                  	;shl	bx,1
  7092 0000186E BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7093 00001871 36891E[701C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7094 00001876 4B                      	dec	bx				; dec by one to leave room for double 0
  7095 00001877 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7096                                  						; no environment size error.
  7097                                  ;public NxtStr
  7098                                  NxtStr:
  7099 00001879 E81E01                  	call	GetStrLen			; get the size of the current env string
  7100                                  
  7101                                  ;Bugbug: Can use ss here to address UsedEnv
  7102                                  
  7103 0000187C 1E                      	push	ds                              ; get addressability to environment
  7104 0000187D 0E                              push	cs                              ;                       counter
  7105 0000187E 1F                              pop	ds                              ;
  7106                                  	;assume	ds:ResGroup
  7107 0000187F 010E[741C]                      add	[UsedEnv],cx			; add the string length to env size
  7108 00001883 1F                      	pop	ds                              ;
  7109                                  	;assume	ds:nothing
  7110                                  	
  7111 00001884 83F901                  	cmp	cx,1				; end of environment was encountered.
  7112 00001887 7405                    	je	short EnvExit
  7113 00001889 29CB                    	sub	bx,cx
  7114                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7115                                  	; 21/01/2023
  7116 0000188B 73EC                    	jae	short NxtStr
  7117 0000188D 42                      	inc	dx				; out of env space msg must be displayed
  7118                                  	;jmp	short EnvExit
  7119                                  
  7120                                  ;OkCpyStr:
  7121                                  	;jmp	short NxtStr
  7122                                  
  7123                                  EnvExit:
  7124 0000188E 0E                      	push	cs
  7125 0000188F 1F                      	pop	ds
  7126                                  	;assume	ds:ResGroup
  7127 00001890 09D2                    	or	dx,dx				; dx will be non-zero if error
  7128 00001892 7406                    	jz	short EnvNoErr
  7129                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7130 00001894 BA[301D]                	mov	dx,OUTENVMSG
  7131 00001897 E8DBF9                  	call 	RPrint
  7132                                  EnvNoErr:
  7133 0000189A A1[6E1C]                	mov	ax,[EnvSiz]			; env size previously set
  7134 0000189D B104                    	mov	cl,4
  7135 0000189F D3E0                    	shl	ax,cl				; get size in bytes
  7136 000018A1 3B06[741C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7137 000018A5 7706                    	ja	short st_envsize		; yes, store the size
  7138 000018A7 A1[741C]                	mov	ax,[UsedEnv]
  7139 000018AA 83C00F                  	add	ax,15				; round up
  7140                                  st_envsize:	
  7141 000018AD D3E8                    	shr	ax,cl
  7142 000018AF A3[6E1C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7143                                  
  7144                                  ;if MSVER
  7145                                  	;cmp	SingleCom,0
  7146                                  	;jnz	nophead 			; don't print header if SingleCom
  7147                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7148                                  	;call	RPrint
  7149                                  ;nophead:
  7150                                  ;endif
  7151                                  
  7152                                  ; 21/01/2023
  7153                                  %if 0
  7154                                  	; MSDOS 3.3
  7155                                  ENVNOERR:
  7156                                  	mov     cx,[ENVMAX]
  7157                                  	sub     cx,bx			; current environment size in bytes
  7158                                  	add     cx,16			; add memory arena to the size
  7159                                  	shr     cx,1
  7160                                  	shr     cx,1
  7161                                  	shr     cx,1
  7162                                  	shr     cx,1			; convert current env size to paragraphs
  7163                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7164                                  	;jb	short SET_ENVSIZE
  7165                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7166                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7167                                  
  7168                                  SET_ENVSIZE:
  7169                                  	mov     bx,[ENVSIZ]
  7170                                  	mov     ax,es
  7171                                  	add     ax,bx			; get end segment of environemnt
  7172                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7173                                  	ja      short NOPHEAD
  7174                                  					; free unused paragraghs		
  7175                                  	mov     ax,es
  7176                                  	mov     bx,[INITEND]
  7177                                  	sub     bx,ax
  7178                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7179                                  	mov	word [RESETENV],1	; environment segment reset sign
  7180                                  
  7181                                  NOPHEAD:
  7182                                  	; MSDOS 3.3
  7183                                  	mov     ah,SETBLOCK ; 4Ah
  7184                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7185                                  			; ES = segment address of block to change
  7186                                  			; BX = new size in paragraphs
  7187                                  %endif
  7188                                  	; 21/01/2023
  7189                                  
  7190                                  	; MSDOS 3.3 & 6.0
  7191 000018B2 833E[3401]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7192 000018B7 7503                    	jnz     short DoDate		; yes - go initialize it
  7193 000018B9 E99300                  	jmp     NoDttm			; don't do autoexec or date time
  7194                                  
  7195                                  DoDate:
  7196                                  
  7197                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7198                                  
  7199 000018BC A1[3401]                	mov	ax,[Batch]		; get batch segment
  7200 000018BF C606[8801]03            	mov	byte [EchoFlag],3	; set batch echo
  7201 000018C4 C706[9701]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7202 000018CA 8EC0                    	mov	es,ax
  7203                                  
  7204                                  ; initialize the segment
  7205                                  
  7206 000018CC 31FF                    	xor	di,di
  7207                                  	;;mov	al,0
  7208                                  	;mov	al,BATCHTYPE ; 0
  7209                                  	; 06/06/2023
  7210 000018CE 31C0                    	xor	ax,ax
  7211 000018D0 AA                      	stosb
  7212                                  	;mov	al,1			; initialize echo for batch exit
  7213                                  	;inc	al
  7214                                  	; 22/07/2024
  7215 000018D1 40                      	inc	ax
  7216 000018D2 AA                      	stosb
  7217                                  
  7218                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7219                                  
  7220                                  	;xor	ax,ax			; initialize to zero
  7221                                  	; 06/06/2023
  7222                                  	;dec	al ; ax = 0
  7223                                  	; 22/07/2024
  7224 000018D3 48                      	dec	ax
  7225                                  
  7226                                  	; 21/01/2023
  7227 000018D4 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7228                                  
  7229 000018D5 AB                      	stosw				; batch segment of last job - batlast
  7230 000018D6 AB                      	stosw				; segment for FOR
  7231 000018D7 AA                      	stosb				; FOR flag
  7232 000018D8 AB                      	stosw				; position in file - batseek
  7233 000018D9 AB                      	stosw
  7234                                  
  7235                                  ; clean out the parameters
  7236                                  
  7237                                  	;mov	ax,-1			; initialize to no parameters
  7238                                  	; 06/06/2023
  7239 000018DA 48                      	dec	ax ; ax = -1
  7240                                  
  7241 000018DB B90A00                  	mov	cx,10
  7242 000018DE F3AB                    	rep	stosw
  7243                                  
  7244                                  ; decide whether we should grab the default drive
  7245                                  
  7246 000018E0 803E[341C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7247 000018E5 7509                    	jne	short NoAutSet
  7248 000018E7 B419                    	mov	ah,19h	; 21/01/2023
  7249                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7250 000018E9 CD21                    	int	21h
  7251                                  	;;add	al,'A'
  7252                                  	;add	al,[letter_A] ; Ucasea
  7253                                  	;add	al,[ucasea] ; 21/01/2023
  7254                                  	; 21/01/2023
  7255 000018EB 0441                    	add	al,'A'
  7256 000018ED A2[341C]                	mov	[AUTOBAT],al
  7257                                  	; 21/01/2023
  7258                                  	;mov	[KAUTOBAT],al
  7259                                  NoAutSet:
  7260                                  
  7261                                  ; copy in the batch file name (including nul)
  7262                                  
  7263                                  	;mov	si,offset ResGroup:AutoBat
  7264 000018F0 BE[341C]                	mov	si,AUTOBAT
  7265 000018F3 B90800                  	mov	cx,8
  7266 000018F6 F3A5                    	rep	movsw
  7267                                  	; 23/04/2023
  7268 000018F8 A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7269                                  
  7270                                  	;mov	dx,offset ResGroup:AutoBat
  7271 000018F9 BA[341C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7272                                  
  7273                                  	;;mov	ax,OPEN shl 8
  7274 000018FC B8003D                  	mov	ax,3D00h ; 21/01/2023
  7275                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7276 000018FF CD21                    	int	21h			; see if autoexec.bat exists
  7277 00001901 7208                    	jc	short noabat
  7278 00001903 89C3                    	mov	bx,ax
  7279 00001905 B43E                    	mov	ah,3Eh ; 21/01/2023
  7280                                  	;mov	ah,CLOSE  ; 3Eh
  7281 00001907 CD21                    	int	21h
  7282 00001909 EB51                    	jmp	short Drv0		; go process autoexec
  7283                                  
  7284                                  noabat:
  7285 0000190B 50                      	push	ax
  7286 0000190C E89400                  	call	Setup_Seg
  7287 0000190F A3[501C]                	mov	[triage_add+2],ax
  7288 00001912 58                      	pop	ax
  7289 00001913 FF1E[4E1C]              	call	far [triage_add]	; get extended error
  7290 00001917 83F841                  	cmp	ax,65			; network access denied?
  7291                                  	;jne	short OPENERR		; no - go deallocate batch
  7292                                  	; 21/01/2023
  7293                                  	;je	short AccDenErr
  7294 0000191A 7506                    	jne	short OpenErr
  7295                                  
  7296                                  	; 21/01/2023
  7297                                  ;_ACCDENERROR:					; yes - put out message
  7298                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7299                                  ;	mov	dx,ACCDENERR
  7300                                  ;	call	RPRINT
  7301                                  
  7302                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7303                                  
  7304                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7305                                  
  7306                                  ; 21/01/2023
  7307                                  %if 0
  7308                                  
  7309                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7310                                  ; by Ellen to check only when in Korea. The country information
  7311                                  ; returned will overlay the old parse data area, but we don't care
  7312                                  ; since we won't need the parse information or country information.
  7313                                  ; We only care about the country code returned in BX.
  7314                                  
  7315                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7316                                  
  7317                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7318                                  	mov	dx,INTERNAT_INFO
  7319                                  	mov	ax,3800h
  7320                                  	;mov	ax,INTERNATIONAL<<8
  7321                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7322                                  	int	21h				;
  7323                                  	jc	short NoKabat 			; error - don't bother with it
  7324                                  	cmp	bx,52h
  7325                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7326                                  	jne	short OpenErr 			; no, don't check for kautoexe
  7327                                  
  7328                                  	;mov	di,BatFile			; 3/3/kk
  7329                                  	mov	di,20h
  7330                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7331                                  	mov	si,KAUTOBAT
  7332                                  	mov	cx,8				; auto execution for the 3/3/kk
  7333                                  	rep	movsw				; non-english country	3/3/kk
  7334                                  	movsb					; move in carraige return to terminate string
  7335                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7336                                  	mov	dx,KAUTOBAT
  7337                                  	mov	ax,3D00h
  7338                                  	;mov	ax,OPEN<<8
  7339                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7340                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7341                                  	jc	short NoKabat 			; 3/3/kk
  7342                                  	mov	bx,ax				; 3/3/kk
  7343                                  	mov	ah,3Eh
  7344                                  	;mov	ah,CLOSE			; 3/3/kk
  7345                                  	int	21h				; 3/3/kk
  7346                                  	jmp	short Drv0			; 3/3/kk
  7347                                  
  7348                                  NoKabat:					; 3/3/kk
  7349                                  	call	far [triage_add]		; get extended error
  7350                                  	cmp	ax,65				; network access denied?
  7351                                  	jnz	short OpenErr 			; no - go deallocate batch
  7352                                  
  7353                                  %endif
  7354                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7355                                  
  7356                                  AccDenErr:					; yes - put out message
  7357                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7358 0000191C BA[BB05]                	mov	dx,ACCDEN
  7359 0000191F E853F9                  	call	RPrint
  7360                                  OpenErr:
  7361                                  ;OPENERR:
  7362 00001922 8E06[3401]              	mov	es,[Batch]		; not found--turn off batch job
  7363 00001926 B449                    	mov	ah,49h
  7364                                  	;mov	ah,DEALLOC ; 49h
  7365 00001928 CD21                    	int	21h
  7366 0000192A C706[3401]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7367 00001930 C606[8801]01            	mov	byte [EchoFlag],1
  7368 00001935 C706[9701]0000          	mov	word [Nest],0		; indicate no batch in progress
  7369                                  
  7370                                  ;DoDttm:
  7371                                  	;mov	ax,offset TranGroup:Datinit
  7372 0000193B B8[612E]                	mov	ax,DATINIT
  7373 0000193E A3[461C]                	mov	[INITADD],ax
  7374                                  
  7375                                  	; MSDOS 6.0
  7376                                  ;;M004;;mov	ax,TrnSeg	
  7377                                  ;
  7378                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7379                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7380                                  ; M004; We use TranStart to get the start of the transient segment.
  7381                                  
  7382                                  	; 21/01/2023
  7383                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7384                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7385                                  	; 06/06/2023
  7386                                  	;mov	ax,TRANSTART
  7387                                  	;mov	cl,4				; M004
  7388                                  	;shr	ax,cl				; get relative seg ; M004
  7389                                  	; 06/06/2023
  7390 00001941 B82002                  	mov	ax,TRANSTART>>4	
  7391                                  
  7392 00001944 8CC9                    	mov	cx,cs
  7393 00001946 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7394                                  
  7395                                  	; 21/01/2023
  7396                                  	; MSDOS 3.3
  7397                                  	; 25/09/2018
  7398                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7399                                  
  7400                                  	; MSDOS 3.3 & MSDOS 6.0
  7401 00001948 A3[481C]                	mov	[INITADD+2],ax
  7402                                  	;call	dword ptr InitAdd
  7403 0000194B FF1E[461C]              	call	far [INITADD]
  7404                                  
  7405                                  NoDttm:
  7406                                  	; MSDOS 6.0
  7407                                  	; 21/01/2023
  7408                                  ;Copyright:
  7409                                  	;public	Copyright
  7410                                  ;	Bugbug:	remove Copyright label.
  7411                                  
  7412                                  ;if IBMVER
  7413 0000194F 833E[8E01]00            	cmp	word [SingleCom],0
  7414 00001954 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7415                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7416 00001956 BA[4B1D]                	mov	dx,COPYRIGHTMSG
  7417 00001959 E819F9                  	call	RPrint
  7418                                  ;endif
  7419                                  	; 21/01/2023
  7420                                  	; MSDOS 3.3
  7421                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7422                                  	;jnz	short DRV0
  7423                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7424                                  	;call	RPRINT
  7425                                  ;DRV0:
  7426                                  	; MSDOS 3.3
  7427                                  	;mov	byte [INITFLAG],0
  7428                                  	;jmp	ENDINIT
  7429                                  
  7430                                  	; 21/01/2023
  7431                                  	; MSDOS 6.0
  7432                                  Drv0:						; Reset APPEND state
  7433 0000195C 1E                      	push	ds				; save data segment
  7434 0000195D 0E                      	push	cs				; Get local segment into DS
  7435 0000195E 1F                      	pop	ds				;
  7436 0000195F B807B7                  	mov	ax,0B707h ; 21/01/2023
  7437                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7438 00001962 8B1E[AB01]              	mov	bx,[Append_State] 		;  back to the original state
  7439 00001966 CD2F                    	int	2Fh				;
  7440 00001968 1F                      	pop	ds				; get data segment back
  7441                                  
  7442                                  ;Check FirstCom set previously to see if this is the first instance of
  7443                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7444                                  ;jump table from the previous stub to the current stub.
  7445                                  
  7446 00001969 803E[C020]01            	cmp	byte [FirstCom],1		; first command.com?
  7447 0000196E 7424                    	jz	short move_code			; yes, move it
  7448                                  
  7449 00001970 06                      	push	es
  7450 00001971 1E                      	push	ds
  7451                                  
  7452 00001972 1E                      	push	ds
  7453 00001973 07                      	pop	es
  7454                                  	;mov	di,offset DATARES:Int2f_Entry
  7455 00001974 BF[0400]                	mov	di,Int2f_Entry	
  7456                                  
  7457                                  	;mov	ds,[es:ResJmpTable+2]		; get segment address
  7458                                  	;mov	si,[es:ResJmpTable]		; get offset address
  7459                                  	; 22/07/2024 - PCDOS 7.1 COMMAND.COM
  7460 00001977 26C536[BC20]            	lds	si,[es:ResJmpTable]
  7461                                  
  7462                                  	;mov	cx,11
  7463                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7464                                  	;shl	cx,1
  7465                                  	;shl	cx,1				; size of table in bytes
  7466                                  	; 21/01/2023
  7467 0000197C B92C00                  	mov	cx,44				; size of table in bytes
  7468                                  
  7469 0000197F FC                      	cld
  7470 00001980 F3A4                    	rep	movsb				; copy the jump table
  7471                                  
  7472                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7473                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7474                                  
  7475 00001982 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7476 00001988 7206                    	jb	short res_low			; no, dont set flag
  7477                                  
  7478 0000198A 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7479                                  res_low:
  7480 00001990 1F                      	pop	ds
  7481 00001991 07                      	pop	es
  7482 00001992 EB03                    	jmp	short finish_init
  7483                                  
  7484                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7485                                  ;or to overlay the messages in the data segment if the user has not used the
  7486                                  ;/msg switch.
  7487                                  
  7488                                  move_code:
  7489 00001994 E88501                  	call	Move_res_code			; move the code
  7490                                  
  7491                                  finish_init:
  7492                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7493 00001997 E968E8                  	jmp	EndInit
  7494                                  
  7495                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7496                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7497                                  
  7498                                  GetStrLen:
  7499                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7500                                  ;	Length is returned in CX
  7501                                  
  7502                                  	; MSDOS 3.3 & MSDOS 6.0
  7503 0000199A 31C9                    	xor	cx,cx
  7504                                  NxtChar:
  7505 0000199C AC                      	lodsb
  7506 0000199D 41                      	inc	cx
  7507 0000199E 08C0                    	or	al,al
  7508 000019A0 75FA                    	jnz	short NxtChar
  7509 000019A2 C3                      	retn
  7510                                  
  7511                                  	; 29/01/2023
  7512                                  Setup_Seg:
  7513                                  
  7514                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7515                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7516                                  ; code segment is used
  7517                                  ; Segment returned in AX.
  7518                                  
  7519                                  	; MSDOS 3.3 & MSDOS 6.0
  7520 000019A3 A1[7A01]                	mov	ax,[TrnSeg]
  7521 000019A6 803E[7C01]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7522 000019AB 7405                    	je	short setup_end
  7523                                  
  7524                                  ;06/06/2023
  7525                                  %if 0
  7526                                  	push	bx
  7527                                  	mov	bx,cs
  7528                                  	;mov	ax,offset ResGroup:TranStart
  7529                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7530                                  	; 06/06/2023
  7531                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7532                                  	;mov	ax,TRANSTART
  7533                                  	;shr	ax,1
  7534                                  	;shr	ax,1
  7535                                  	;shr	ax,1
  7536                                  	;shr	ax,1
  7537                                  	; 29/01/2023
  7538                                  	mov	ax,TRANSTART>>4
  7539                                  	add	ax,bx
  7540                                  	pop	bx
  7541                                  %endif
  7542                                  	; 06/06/2023
  7543 000019AD 8CC8                    	mov	ax,cs
  7544 000019AF 052002                  	add	ax,TRANSTART>>4
  7545                                  
  7546                                  setup_end:
  7547 000019B2 C3                      	retn
  7548                                  
  7549                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7550                                  ;RPRINT:
  7551                                  	; MSDOS 3.3
  7552                                  	;push    ax
  7553                                  	;call    SETUP_SEG
  7554                                  	;mov     [PRINTADD+2], ax
  7555                                  	;;call	dword ptr PRINTADD
  7556                                  	;call	far [PRINTADD]
  7557                                  	;pop     ax
  7558                                  	;retn
  7559                                  
  7560                                  	; 29/01/2023
  7561                                  	; MSDOS 6.0
  7562                                  ;***	RPrintParse - display parse error message
  7563                                  ;
  7564                                  ;	ENTRY	DX = parse error #
  7565                                  ;
  7566                                  ;	EXIT	nothing
  7567                                  ;
  7568                                  ;	USED	flags
  7569                                  ;
  7570                                  ;	EFFECTS
  7571                                  ;	  Message is displayed on stdout.
  7572                                  
  7573                                  RPrintParse:	;proc
  7574                                  	;assume	ds:ResGroup,ss:ResGroup
  7575                                  
  7576 000019B3 52                      	push	dx				; preserve DX
  7577 000019B4 87DA                    	xchg	bx,dx				; bx = parse error #
  7578                                  						; dx = saved BX
  7579 000019B6 4B                      	dec	bx				; bx = parse error index, from 0
  7580 000019B7 D1E3                    	shl	bx,1				; bx = offset in word table
  7581                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7582 000019B9 8B9F[FD08]              	mov	bx,[bx+PARSMSGPTRS]
  7583 000019BD 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7584                                  						; bx = restored
  7585 000019BF E8B3F8                  	call	RPrint				; print the message
  7586 000019C2 5A                      	pop	dx				; restore DX
  7587 000019C3 C3                      	retn
  7588                                  
  7589                                  ;RPrintParse	endp
  7590                                  
  7591                                  	; 29/01/2023
  7592                                  ;PATHCHRCMPR:
  7593                                  	; MSDOS 3.3
  7594                                  	;push	dx
  7595                                  	;mov	dl,[slash_chr]
  7596                                  	;;cmp	byte [RSWITCHAR],'/'
  7597                                          ;cmp	[RSWITCHAR],dl
  7598                                  	;je	short RNOSLASHT
  7599                                  	;;cmp	al,'/'
  7600                                  	;cmp	al,dl
  7601                                  	;je	short RET41 ; zf = 1 
  7602                                  ;RNOSLASHT:
  7603                                          ;;cmp	al,'\'
  7604                                  	;cmp	al,[bslash_chr]
  7605                                  ;RET41:
  7606                                  	;pop	dx
  7607                                  	;retn
  7608                                  
  7609                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7610                                  IfindE:
  7611                                  	; MSDOS 3.3 & MSDOS 6.0
  7612 000019C4 E80300                  	call	ifind				; find the name
  7613                                  	;jc	short ifind2			; carry means not found
  7614                                  	;jmp	short Iscasb1 			; scan for = sign
  7615                                  	; 29/01/2023
  7616 000019C7 733A                    	jnc	short Iscasb1
  7617                                  ifind2:
  7618 000019C9 C3                      	retn
  7619                                  
  7620                                  	; 29/01/2023
  7621                                  
  7622                                  ; on return of find1, es:di points to beginning of name
  7623                                  
  7624                                  ifind:
  7625 000019CA FC                      	cld
  7626 000019CB E82700                  	call	Icount0				; cx = length of name
  7627 000019CE 8E06[2703]              	mov	es,[EnvirSeg]
  7628 000019D2 31FF                    	xor	di,di
  7629                                  ifind1:
  7630 000019D4 51                      	push	cx
  7631 000019D5 56                      	push	si
  7632 000019D6 57                      	push	di
  7633                                  ifind11:
  7634 000019D7 AC                      	lodsb
  7635 000019D8 E83400                  	call	iupconv
  7636 000019DB 47                      	inc	di
  7637 000019DC 263A45FF                	cmp	al,[es:di-1]
  7638 000019E0 7502                    	jnz	short ifind12
  7639 000019E2 E2F3                    	loop	ifind11
  7640                                  ifind12:
  7641 000019E4 5F                      	pop	di
  7642 000019E5 5E                      	pop	si
  7643 000019E6 59                      	pop	cx
  7644 000019E7 74E0                    	jz	short ifind2
  7645 000019E9 51                      	push	cx
  7646 000019EA E81A00                  	call	Iscasb2 			; scan for a nul
  7647 000019ED 59                      	pop	cx
  7648                                  	;cmp	byte [es:di],0
  7649                                  	;jnz	short ifind1
  7650                                  	;stc					; indicate not found
  7651 000019EE 26803D01                	cmp	byte [es:di],1
  7652 000019F2 73E0                    	jnb	short ifind1
  7653                                  	; cf=1					; indicate not found
  7654                                  ;ifind2:
  7655 000019F4 C3                      	retn
  7656                                  
  7657                                  	; 29/01/2023
  7658                                  Icount0:
  7659 000019F5 1E                      	push	ds
  7660 000019F6 07                      	pop	es
  7661 000019F7 89F7                    	mov	di,si
  7662                                  
  7663 000019F9 57                      	push	di				; count number of chars until "="
  7664 000019FA E80600                  	call	Iscasb1
  7665                                  	; 25/09/2018
  7666                                  	;jmp	short Icountx
  7667                                  	;push	di				; count number of chars until nul
  7668                                  	;call	Iscasb2
  7669                                  ;Icountx:
  7670 000019FD 59                      	pop	cx
  7671 000019FE 29CF                    	sub	di,cx
  7672 00001A00 87F9                    	xchg	di,cx
  7673 00001A02 C3                      	retn
  7674                                  
  7675                                  Iscasb1:
  7676                                  	; 29/01/2023
  7677 00001A03 B03D                    	mov	al,"="
  7678                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7679 00001A05 EB02                    	jmp	short Iscasbx
  7680                                  Iscasb2:
  7681 00001A07 30C0                    	xor	al,al				; scan for a nul
  7682                                  Iscasbx:
  7683 00001A09 B90001                  	mov	cx,256 ; 100h
  7684 00001A0C F2AE                    	repnz	scasb
  7685 00001A0E C3                      	retn
  7686                                  
  7687                                  	; 29/01/2023
  7688                                  ;IUPCONV:
  7689                                  	; MSDOS 3.3
  7690                                          ;;cmp	al,"a"
  7691                                  	;cmp	al,[letter_a]
  7692                                          ;jb	short IRET22
  7693                                          ;;cmp	al,"z"
  7694                                          ;cmp	al,[letter_z]
  7695                                  	;ja	short IRET22
  7696                                          ;sub	al,20h			; Lower-case changed to upper-case
  7697                                  ;IRET22:
  7698                                  	;retn
  7699                                  
  7700                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7701                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7702                                  
  7703                                  	; MSDOS 6.0
  7704                                  ; *****************************************************************
  7705                                  ; *
  7706                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7707                                  ; *
  7708                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7709                                  ; *		 the character in AL from the file upper case table
  7710                                  ; *		 in DOS if character if above ascii 128, else
  7711                                  ; *		 subtracts 20H if between "a" and "z".
  7712                                  ; *
  7713                                  ; * INPUT:	 DS	      set to resident
  7714                                  ; *		 AL	      char to be upper cased
  7715                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7716                                  ; *
  7717                                  ; * OUTPUT:	 AL	      upper cased character
  7718                                  ; *
  7719                                  ; *****************************************************************
  7720                                  
  7721                                  iupconv:	;proc	near				
  7722                                  	;assume	ds:ResGroup			;
  7723                                  
  7724 00001A0F 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7725 00001A11 7210                    	jb	short other_fucase		; no - upper case math
  7726 00001A13 2C80                    	sub	al,80h				; only upper 128 chars in table
  7727 00001A15 1E                      	push	ds				;
  7728 00001A16 53                      	push	bx				;
  7729                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7730 00001A17 C51E[9F01]              	lds     bx,[FUCase_Addr+1]
  7731 00001A1B 83C302                  	add	bx,2				; skip over first word
  7732                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7733 00001A1E D7                      	xlat
  7734 00001A1F 5B                      	pop	bx				;
  7735 00001A20 1F                      	pop	ds				;
  7736 00001A21 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7737                                  
  7738                                  other_fucase:					;
  7739                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7740 00001A23 3C61                    	cmp	al,'a'
  7741 00001A25 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7742                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7743 00001A27 3C7A                    	cmp	al,'z'
  7744 00001A29 7702                    	ja	short iupconv_end		;
  7745 00001A2B 2C20                    	sub	al,20h				; Change lower-case to upper
  7746                                  iupconv_end:					;
  7747 00001A2D C3                      	retn
  7748                                  
  7749                                  ;iupConv endp
  7750                                  
  7751                                  	; 29/01/2023
  7752                                  init_contc_specialcase:
  7753                                  	; MSDOS 3.3 & MSDOS 6.0
  7754                                  						; This routine is called if control-C
  7755 00001A2E 83C406                  	add	sp,6				;  is type during the date/time prompt
  7756 00001A31 56                      	push	si				;  at initialization time.  The desired
  7757 00001A32 89D6                    	mov	si,dx				;  response is to make it look like the
  7758 00001A34 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7759 00001A39 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7760 00001A3A CF                      	iret					;  a <CR> in the user's buffer, and
  7761                                  						;  returning directly to the user.
  7762                                  						; In this case the user is TCODE.
  7763                                  
  7764                                  ; ----------------------------------------------------------------------------
  7765                                  
  7766                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7767                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7768                                  
  7769                                  	; MSDOS 6.0
  7770                                  ; ****************************************************************
  7771                                  ; *
  7772                                  ; * ROUTINE:	 Setup_for_messages
  7773                                  ; *
  7774                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7775                                  ; *		 messages as follows:
  7776                                  ; *
  7777                                  ; *		 IF /P and /MSG are entered
  7778                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7779                                  ; *		 ELSE IF /P is entered
  7780                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7781                                  ; *		    remove PARSE ERRORS from memory
  7782                                  ; *		 ELSE
  7783                                  ; *		    remove PARSE ERRORS from memory
  7784                                  ; *		 ENDIF
  7785                                  ; *
  7786                                  ; * INPUT:	 PERMCOM	Set up with user input
  7787                                  ; *		 EXT_MSG	Set up with user input
  7788                                  ; *		 System set up to retain PARSE ERRORS
  7789                                  ; *
  7790                                  ; * OUTPUT:	 registers unchanged
  7791                                  ; *
  7792                                  ; ****************************************************************
  7793                                  
  7794                                  setup_for_messages: ;proc near		
  7795                                  
  7796 00001A3B 53                      	push	bx
  7797 00001A3C 1E                      	push	ds				; save data segment
  7798 00001A3D 06                      	push	es				; save environment segment
  7799 00001A3E 50                      	push	ax				;
  7800 00001A3F 52                      	push	dx				;
  7801 00001A40 57                      	push	di				;
  7802 00001A41 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7803 00001A43 8ED8                    	mov	ds,ax				;
  7804 00001A45 8EC0                    	mov	es,ax				;
  7805                                  
  7806 00001A47 803E[8D01]00            	cmp	byte [PermCom],0		; was permcom set?
  7807 00001A4C 743C                    	jz	short no_permcom		; No - don't worry about messages
  7808                                  
  7809                                  ;*	We're permanent. Install our message services int 2f handler.
  7810                                  
  7811 00001A4E 06                      	push	es
  7812                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7813 00001A4F B82F35                  	mov	ax,352Fh
  7814 00001A52 CD21                    	int	21h
  7815                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7816                                  			; AL = interrupt number
  7817                                  			; Return: ES:BX = value of interrupt vector
  7818 00001A54 891E[9B03]              	mov	[Int2fHandler],bx
  7819 00001A58 8C06[9D03]              	mov	[Int2fHandler+2],es
  7820 00001A5C 07                      	pop	es
  7821                                  
  7822                                  ;	DS = RESGROUP seg addr
  7823                                  
  7824                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7825                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7826                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7827                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7828                                  ; M005; call) goes off into space.
  7829                                  
  7830 00001A5D 803E[C020]00            	cmp	byte [FirstCom],0		; M005
  7831 00001A62 7416                    	je	short no_msg_hook		; M005
  7832                                  ;
  7833                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7834                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7835                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7836                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7837                                  ; M005; segment matches the command.com PSP and then updates these segments
  7838                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7839                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7840                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7841                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7842                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7843                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7844                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7845                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7846                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7847                                  ; M005; jump to the actual int 2fh entry point.
  7848                                  ;
  7849 00001A64 1E                      	push	ds				; M005
  7850                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7851 00001A65 BA[C300]                	mov     dx,Carousel_i2f_Hook
  7852 00001A68 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7853 00001A6B 8CD8                    	mov	ax,ds				; M005
  7854 00001A6D 40                      	inc	ax				; Relocated cs ; M005
  7855 00001A6E 8ED8                    	mov	ds,ax				; M005
  7856                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7857 00001A70 B82F25                  	mov	ax,252Fh
  7858 00001A73 CD21                    	int	21h
  7859                                  			; DOS - SET INTERRUPT VECTOR
  7860                                  			; AL = interrupt number
  7861                                  			; DS:DX = new vector to be used for specified interrupt
  7862 00001A75 1F                      	pop	ds				; M005
  7863                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7864 00001A76 8C1E[C600]              	mov	[Carousel_i2f_Hook+3],ds
  7865                                  						; patch in the cs for jump
  7866                                  no_msg_hook:					; M005
  7867 00001A7A 803E[811C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7868 00001A7F 7516                    	jne	short permcom_end		; no /msg - exit
  7869                                  
  7870                                  permcom_slash_msg:				; Keep messages in memory
  7871                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7872 00001A81 BF[F60B]                	mov     di,ExtMsgEnd
  7873 00001A84 893E[9F03]              	mov	[ResMsgEnd],di			; save it
  7874 00001A88 EB0D                    	jmp	short permcom_end		; exit
  7875                                  
  7876                                  no_permcom:					
  7877                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7878 00001A8A 803E[811C]01            	cmp	byte [ext_msg],1
  7879 00001A8F 7506                    	jne	short permcom_end		; no - no error
  7880                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7881 00001A91 BA0200                  	mov	dx,2
  7882 00001A94 E81CFF                  	call	RPrintParse
  7883                                  
  7884                                  permcom_end:
  7885 00001A97 5F                      	pop	di				;
  7886 00001A98 5A                      	pop	dx				;
  7887 00001A99 58                      	pop	ax				;
  7888 00001A9A 07                      	pop	es				; get environment back
  7889 00001A9B 1F                      	pop	ds				;
  7890 00001A9C 5B                      	pop	bx
  7891                                  
  7892 00001A9D C3                      	retn					;
  7893                                  
  7894                                  ;setup_for_messages	endp
  7895                                  
  7896                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7897                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7898                                  
  7899                                  	; MSDOS 6.0
  7900                                  
  7901                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7902                                  ;
  7903                                  ;	ENTRY	command-line tail at 81h
  7904                                  ;
  7905                                  ;	EXIT	return if /? not found
  7906                                  ;		terminate if /? found
  7907                                  ;
  7908                                  ;	USED	AX,BX,CX,DX,SI,DI
  7909                                  ;
  7910                                  ;	EFFECTS	Help text displayed if /? found on command line
  7911                                  
  7912                                  CheckHelp:	; proc
  7913                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7914                                  
  7915 00001A9E BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7916                                  	;mov	di,offset RESGROUP:Parse_Command
  7917 00001AA1 BF[861C]                	mov	di,PARSE_COMMAND
  7918                                  					; ES:DI = ptr to primary parse block
  7919 00001AA4 31C9                    	xor	cx,cx			; CX = # positional param's found
  7920 00001AA6 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7921                                  chParse:
  7922                                  	;call	dword ptr Init_Parse
  7923 00001AA8 FF1E[7A1C]              	call	far [Init_Parse]	; call system parser
  7924                                  
  7925                                  	;;cmp	ax,END_OF_LINE
  7926                                  	;cmp	ax,-1 ; 0FFFFh	
  7927                                  	;je	short chRet		; end of command line, no /? found
  7928                                  	;;cmp	ax,RESULT_NO_ERROR
  7929                                  	;;cmp	ax,0
  7930                                  	;;je	short chWhich		; valid syntax element found
  7931                                  	;;jmp	short chParse		; go parse more
  7932                                  	;and	ax,ax ; cmp ax,0
  7933                                  	;jnz	short chParse ; jne
  7934                                  	; 10/06/2023
  7935 00001AAC 40                      	inc	ax	; cmp ax,-1
  7936 00001AAD 7413                    	jz	short chRet   ; 0FFFFh -> 0
  7937 00001AAF 48                      	dec	ax	; cmp ax,0
  7938 00001AB0 75F6                    	jnz	short chParse ; 1 -> 0
  7939                                  	; ax = 0
  7940                                  chWhich:
  7941                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7942 00001AB2 813E[0D1D][081D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7943 00001AB8 7409                    	je	short chHelp		; /? found - display help & exit
  7944                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7945 00001ABA 813E[0D1D][EE1C]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7946                                  	;je	short chRet		; /c found - ignore rest of line
  7947                                  	; 29/01/2023
  7948 00001AC0 75E6                    	jne	short chParse
  7949                                  	; MSDOS 6.0
  7950                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7951                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7952                                  	;je	short chRet		; /k found - ignore rest of line
  7953                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7954                                  chRet:
  7955 00001AC2 C3                      	retn
  7956                                  chHelp:
  7957                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7958 00001AC3 BE[9220]                	mov	si,HelpMsgs
  7959                                  chHelpNext:
  7960 00001AC6 AD                      	lodsw					; AX = ptr to msg
  7961 00001AC7 09C0                    	or	ax,ax
  7962 00001AC9 7407                    	jz	short chHelpDone		; end of list - all done
  7963 00001ACB 89C2                    	mov	dx,ax				; DX = ptr to msg
  7964 00001ACD E8A5F7                  	call	RPrint				; display msg
  7965 00001AD0 EBF4                    	jmp	short chHelpNext		; go do next msg
  7966                                  
  7967                                  chHelpDone:
  7968 00001AD2 CD20                    	int	20h				; terminate program
  7969                                  ;chRet:
  7970 00001AD4 C3                      	retn
  7971                                  
  7972                                  ;CheckHelp	endp
  7973                                  
  7974                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7975                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7976                                  
  7977                                  	; MSDOS 6.0
  7978                                  
  7979                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7980                                  ;
  7981                                  ; It determines based on 2 factors:
  7982                                  ;	1. Is this is the first COMMAND?
  7983                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7984                                  ;   The strategy works as follows:
  7985                                  ;
  7986                                  ;	if (First COMMAND)
  7987                                  ;	then if (COMMAND in HIMEM)
  7988                                  ;		ResSize = resident_data;
  7989                                  ;	     else
  7990                                  ;		ResSize = resident_data + resident_code;
  7991                                  ;	else
  7992                                  ;	   ResSize = resident_data;
  7993                                  ;
  7994                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7995                                  ; COMMAND and whether DOS is in HIMEM.
  7996                                  ;
  7997                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7998                                  ;
  7999                                  ;	EXIT:  ResSize = resident size in low memory
  8000                                  ;
  8001                                  ;	REGISTERS AFFECTED: ax,cx,dx
  8002                                  ;
  8003                                  
  8004                                  GET_HMA_ADDR	equ	4A02h
  8005                                  
  8006                                  Setup_res_end:	;proc near
  8007                                  	
  8008 00001AD5 1E                      	push	ds
  8009 00001AD6 8CC8                    	mov	ax,cs
  8010 00001AD8 8ED8                    	mov	ds,ax				;ds = RESGROUP
  8011                                  	;assume	ds:RESGROUP
  8012                                  
  8013 00001ADA 8B0E[9F03]              	mov	cx,[ResMsgEnd]			;set resident size = data
  8014                                  
  8015                                  ;ifndef	ROMDOS
  8016                                  
  8017                                  ;M042 -- Begin changes
  8018                                  ;If messages are to be kept behind, we need to round up the messages to
  8019                                  ;the next para boundary. This is because we have a dummy segment between the
  8020                                  ;data and the resident code segment so that the code segment starts on a
  8021                                  ;para boundary
  8022                                  
  8023                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  8024 00001ADE 81F9[F60B]              	cmp	cx,ExtMsgEnd
  8025 00001AE2 7506                    	jne	short calc_res			;no, continue
  8026 00001AE4 83C10F                  	add	cx,15				;round up
  8027 00001AE7 83E1F0                  	and	cx,0FFF0h
  8028                                  calc_res:
  8029                                  
  8030                                  ;M042 -- End changes
  8031                                  
  8032                                  	; 18/07/2024
  8033                                  	;xor	ax,ax
  8034                                         	
  8035 00001AEA 803E[C020]01            	cmp	byte [FirstCom],1		;is it first command.com?
  8036                                  	;jne	short not_first			;no, do not keep code
  8037                                  	; 06/06/2023
  8038 00001AEF 751A                    	jne	short not_first2
  8039                                  
  8040                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  8041                                  ;bit 4 of dh is set
  8042                                  
  8043 00001AF1 53                      	push	bx
  8044 00001AF2 51                      	push	cx
  8045                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  8046 00001AF3 B80633                  	mov	ax,3306h
  8047 00001AF6 CD21                    	int	21h
  8048                                  		; DOS - 5+ Get TRUE Version Number
  8049                                  		; (BL major, BH minor, DL revision, DH flags)
  8050 00001AF8 59                      	pop	cx
  8051                                  
  8052                                  ;bugbug: remove version check after testing
  8053                                  
  8054 00001AF9 80FB05                  	cmp	bl,5				;bl has true version ; M013
  8055 00001AFC 7207                    	jb	short oldver
  8056                                  
  8057 00001AFE 31C0                    	xor	ax,ax
  8058 00001B00 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  8059                                  	;pop	bx
  8060                                  	;jnz	short not_first			;DOS in HIMEM, code not
  8061                                  						;	resident
  8062                                  	; 29/01/2023
  8063 00001B03 7503                    	jnz	short not_first_pop
  8064                                  oldver:
  8065                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8066                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8067                                  	; 06/06/2023
  8068                                  	; 29/01/2023
  8069                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  8070                                  	; 03/05/2023
  8071 00001B05 B8(F908)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  8072                                  
  8073                                  not_first_pop:
  8074                                  	; 29/01/2023
  8075 00001B08 5B                      	pop	bx
  8076                                  
  8077                                  not_first:
  8078                                  
  8079                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  8080                                  
  8081 00001B09 01C1                    	add	cx,ax
  8082                                  
  8083                                  not_first2:	; 06/06/2023
  8084                                  
  8085                                  ;endif	;not ROMDOS
  8086                                  
  8087 00001B0B 83C10F                  	add	cx,15				;round up to next para
  8088 00001B0E D1E9                    	shr	cx,1
  8089 00001B10 D1E9                    	shr	cx,1
  8090 00001B12 D1E9                    	shr	cx,1
  8091 00001B14 D1E9                    	shr	cx,1				;ax = para size of res code
  8092 00001B16 890E[A103]              	mov	[ResSize],cx			;store resident size
  8093                                  
  8094 00001B1A 1F                      	pop	ds
  8095                                  	;assume	ds:nothing
  8096 00001B1B C3                      	retn
  8097                                  
  8098                                  ;ifndef	ROMDOS
  8099                                  
  8100                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8101                                  
  8102                                  	; 29/01/2023
  8103                                  ;oldver:
  8104                                  ;	pop	bx
  8105                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8106                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8107                                  ;	; 29/01/2023
  8108                                  ;	mov	ax,EndCode-RCODE_START
  8109                                  ;	jmp	short not_first
  8110                                  
  8111                                  ;endif	;not ROMDOS
  8112                                  
  8113                                  ;setup_res_end	endp
  8114                                  
  8115                                  ;ifndef	ROMDOS
  8116                                  
  8117                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8118                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8119                                  
  8120                                  	; MSDOS 6.0
  8121                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8122                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8123                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8124                                  ; the correct resident size. When remaining low, we have to check if we 
  8125                                  ; need to overlay the messages part of the data segment which is determined
  8126                                  ; by the /msg switch.
  8127                                  ;
  8128                                  ;	ENTRY: ResMsgEnd = end of resident data
  8129                                  ;
  8130                                  ;	EXIT:  The resident code is either up high or in its final location
  8131                                  ;		down low.
  8132                                  ;
  8133                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8134                                  	
  8135                                  Move_res_code:	;proc near
  8136                                  
  8137 00001B1C 1E                      	push	ds
  8138 00001B1D 06                      	push	es
  8139                                  
  8140 00001B1E 8CC8                    	mov	ax,cs
  8141 00001B20 8ED8                    	mov	ds,ax
  8142                                  	;assume	ds:RESGROUP
  8143                                  
  8144                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8145 00001B22 B80633                  	mov	ax,3306h
  8146 00001B25 CD21                    	int	21h				;DOS in HIMEM?
  8147                                  		; DOS - 5+ Get TRUE Version Number
  8148                                  		; (BL major, BH minor, DL revision, DH flags)
  8149                                  
  8150 00001B27 80E610                  	and	dh,10h				; M013
  8151 00001B2A 750E                    	jnz	short move_high			;yes, move code high
  8152                                  
  8153                                  ;Check if messages have been discarded or not
  8154                                  
  8155                                  load_low:
  8156 00001B2C 1E                      	push	ds
  8157 00001B2D 07                      	pop	es				;es = RESGROUP
  8158 00001B2E 8B3E[9F03]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8159                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8160                                  	;mov	bx,ExtMsgEnd
  8161                                  	; 29/01/2023
  8162 00001B32 81FF[F60B]              	cmp	di,ExtMsgEnd
  8163                                  	;cmp	di,bx				;are messages to be kept?
  8164 00001B36 7431                    	je	short no_move			;yes, dont move code
  8165                                  
  8166 00001B38 EB37                    	jmp	short setup_move		;es:di points at dest.
  8167                                  
  8168                                  move_high:
  8169                                  
  8170                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8171                                  ;We pass in bx the number of bytes we need
  8172                                  
  8173                                  	;mov	bx,offset CODERES:EndCode
  8174                                  	; 29/01/2023
  8175                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8176                                  	; 06/06/2023
  8177                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8178                                  	; 03/05/2023
  8179 00001B3A BB(F908)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8180                                  
  8181                                  ;M030;
  8182                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8183                                  
  8184 00001B3D BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8185                                  						;this ; M030
  8186 00001B40 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8187 00001B43 CD2F                    	int	2Fh
  8188                                  
  8189                                  ;If the offset = 0xffff, then no HMA available
  8190                                  
  8191 00001B45 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8192 00001B48 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8193 00001B4D 7522                    	jne	short setup_move		;no error, es:di = memory
  8194                                  
  8195                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8196                                  	; 29/01/2023	
  8197 00001B4F FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8198                                  
  8199                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8200                                  ;ResSize to reflect this
  8201                                  
  8202 00001B53 8B0E[9F03]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8203                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8204                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8205                                  	;mov	ax,EndCode-RCODE_START
  8206                                  	;add	cx,ax
  8207                                  	; 06/06/2023
  8208                                  	; 29/01/2023
  8209                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8210                                  	;add	cx,15				;round up to next para
  8211                                  	; 03/05/2023
  8212 00001B57 81C1(0809)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8213 00001B5B D1E9                    	shr	cx,1
  8214 00001B5D D1E9                    	shr	cx,1
  8215 00001B5F D1E9                    	shr	cx,1
  8216 00001B61 D1E9                    	shr	cx,1				;ax = para size of res code
  8217 00001B63 890E[A103]              	mov	[ResSize],cx			;store resident size
  8218 00001B67 EBC3                    	jmp	short load_low			;let code remain low
  8219                                  
  8220                                  no_move:
  8221                                  	; 05/05/2023
  8222                                  	;mov	cl,4
  8223 00001B69 83C70F                  	add	di,0Fh
  8224 00001B6C 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8225 00001B6F EB0B                    	jmp	short patch_up
  8226                                  
  8227                                  setup_move:
  8228                                  	;mov	si,offset RESGROUP:StartCode
  8229                                  	; 03/05/2023
  8230 00001B71 BE[000C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8231                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8232                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8233                                  	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8234                                  	; 06/06/2023
  8235                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8236                                  	; 03/05/2023
  8237 00001B74 B9(F908)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8238                                  
  8239 00001B77 FC                      	cld
  8240 00001B78 57                      	push	di				;need di for patching offset
  8241 00001B79 F3A4                    	rep	movsb
  8242 00001B7B 5F                      	pop	di
  8243                                  
  8244                                  patch_up:
  8245 00001B7C E84200                  	call	patch_stub
  8246 00001B7F 07                      	pop	es
  8247 00001B80 1F                      	pop	ds
  8248                                  	;assume	ds:nothing
  8249 00001B81 C3                      	retn
  8250                                  
  8251                                  ;Move_res_code endp
  8252                                  
  8253                                  ;else	;ROMDOS
  8254                                  ;
  8255                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8256                                  ;
  8257                                  ;Move_res_code	proc
  8258                                  ;
  8259                                  ;	push	es
  8260                                  ;
  8261                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8262                                  ;	call	patch_stub
  8263                                  ;
  8264                                  ;	pop	es
  8265                                  ;	ret
  8266                                  ;
  8267                                  ;Move_res_code	endp
  8268                                  ;
  8269                                  ;	assume	ds:NOTHING		; to match ending assume above
  8270                                  ;
  8271                                  ;endif	;ROMDOS
  8272                                  
  8273                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8274                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8275                                  
  8276                                  	; MSDOS 6.0
  8277                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8278                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8279                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8280                                  ; the contents of this temporary environment are copied to it. This routine
  8281                                  ; will not be called in case a valid environment is passed to command.com
  8282                                  ;
  8283                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8284                                  ;
  8285                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8286                                  ;
  8287                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8288                                  
  8289                                  alloc_env:	;proc near
  8290                                  	;assume ds:nothing
  8291                                  	
  8292 00001B82 1E                              push    ds
  8293 00001B83 06                      	push	es
  8294 00001B84 56                      	push	si
  8295 00001B85 57                      	push	di
  8296                                  
  8297                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8298                                  %if 0
  8299                                          push    ss
  8300                                          pop     ds
  8301                                  	;assume ds:RESGROUP
  8302                                  
  8303                                          mov     ax,[EnvirSeg]
  8304                                  
  8305                                          cmp	byte [AllocedEnv],0
  8306                                          je	short alloc_cont
  8307                                          jmp     alloc_done
  8308                                  
  8309                                  alloc_cont:
  8310                                          sub     di,di                           ; default start
  8311                                          ;mov	bx,SIZE Environment             ; default size needed
  8312                                  	; 29/01/2023
  8313                                  	mov	bx,ENVIRONSIZ
  8314                                  
  8315                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8316                                          je	short alloc_seg			; no
  8317                                  
  8318                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8319                                  ;   Record their respective locations and do not add the default vars.
  8320                                  
  8321                                  	or      ax,ax
  8322                                  	jz	short alloc_new			; no previous environment
  8323                                  
  8324                                          mov     es,ax
  8325                                  	;assume es:nothing
  8326                                  
  8327                                  _find_path:
  8328                                          mov     al,0
  8329                                          sub     di,di
  8330                                  comp_path:
  8331                                          scasb                                   ; end of env?
  8332                                  	je	short _find_prompt		; yes
  8333                                          dec     di
  8334                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8335                                          ;mov	si,offset RESGROUP:PathString
  8336                                  	mov	si,PathString	
  8337                                          repe    cmpsb
  8338                                          je	short got_path
  8339                                          mov	cx,256
  8340                                          repne   scasb                           ; find next NULL
  8341                                          jmp     short comp_path
  8342                                  
  8343                                  got_path:
  8344                                          mov	byte [PathString],0		; don't add it
  8345                                  
  8346                                  _find_prompt:
  8347                                          sub     di,di
  8348                                  comp_prompt:
  8349                                  	scasb                                   ; end of env?
  8350                                  	je	short find_comspec		; yes
  8351                                  	dec     di
  8352                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8353                                  	;mov	si,offset RESGROUP:PrmptString
  8354                                  	mov	si,PrmptString
  8355                                          repe    cmpsb
  8356                                          je	short got_prompt
  8357                                          mov     cx,256
  8358                                          repne   scasb                           ; find next NULL
  8359                                          jmp	short comp_prompt
  8360                                  
  8361                                  got_prompt:
  8362                                  	mov	byte [PrmptString],0		; don't add it
  8363                                  
  8364                                  find_comspec:
  8365                                          sub     di,di
  8366                                  comp_comspec:
  8367                                          scasb                                   ; end of env?
  8368                                          je	short got_envend		; yes
  8369                                          dec     di
  8370                                          mov	cx,ComspStrLen ; mov cx,8
  8371                                  	;mov	si,offset RESGROUP:ComspString
  8372                                  	mov	si,ComspString
  8373                                          repe    cmpsb
  8374                                          je	short got_comspec
  8375                                          mov     cx,256
  8376                                          repne   scasb                           ; find next NULL
  8377                                          jmp	short comp_comspec
  8378                                  
  8379                                  got_comspec:
  8380                                          mov     [ComspOffset],di
  8381                                  
  8382                                  find_envend:
  8383                                          sub     di,di
  8384                                          mov     cx,ENVBIG                       ; max env size
  8385                                  comp_envend:
  8386                                          dec     cx                              ;
  8387                                          scasb                                   ; end of env?
  8388                                          je	short got_envend		; yes
  8389                                          repne   scasb
  8390                                          jmp	short comp_envend
  8391                                  
  8392                                  got_envend:
  8393                                          dec     di
  8394                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8395                                  
  8396                                  ;   We want to fall through to alloc_new and set up default
  8397                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8398                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8399                                  
  8400                                          push    ds
  8401                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8402                                          mov	ds,[PDB.PARENT_PID]
  8403                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8404                                  	cmp	word [PDB.PARENT_PID],0
  8405                                  	pop     ds
  8406                                          jne	short alloc_seg			; no, we're not the first process
  8407                                                                                  ; so don't muck with the env.
  8408                                  alloc_new:
  8409                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8410                                  
  8411                                  alloc_seg:
  8412                                  
  8413                                  ; Allocate default environment size
  8414                                  
  8415                                          mov     cx,bx                           ; save byte-granular size in CX
  8416                                          add     bx,15
  8417                                          shr     bx,1
  8418                                          shr     bx,1
  8419                                          shr     bx,1
  8420                                          shr     bx,1                            ; BX = # paras
  8421                                  	mov	ah,ALLOC
  8422                                  	int	21h
  8423                                          jnc	short init_ok
  8424                                          jmp     init_nomem                      ; insufficient memory, error
  8425                                  
  8426                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8427                                  ; the new buffer
  8428                                  
  8429                                  init_ok:
  8430                                  	mov	es,ax
  8431                                  	;assume	es:nothing                      ; es = temp env segment
  8432                                  
  8433                                  	or      di,di
  8434                                          jz	short copy_path
  8435                                  
  8436                                          push    cx
  8437                                          push    ds
  8438                                          mov     ds,[EnvirSeg]
  8439                                          ;assume ds:nothing
  8440                                          sub     si,si
  8441                                          mov     cx,di
  8442                                          sub     di,di
  8443                                          rep     movsb
  8444                                          pop     ds
  8445                                          ;assume ds:RESGROUP
  8446                                          pop     cx
  8447                                          sub     cx,di
  8448                                  
  8449                                  copy_path:
  8450                                  
  8451                                  ; First clear out (the rest of) the buffer
  8452                                  
  8453                                          push    di
  8454                                          sub     ax,ax
  8455                                          rep     stosb
  8456                                          pop     di
  8457                                  
  8458                                  ; Initialize the path string (PATH=) first
  8459                                  
  8460                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8461                                  	mov	si,PathString
  8462                                          cmp     byte [si],al			; add it?
  8463                                          je	short init_prompt		; no
  8464                                  	;mov	cx,PathStrLen+1                 ;
  8465                                  	mov	cx,6 ; db "PATH=",0
  8466                                          rep     movsb                           ;
  8467                                          cmp     [AllocedEnv],al			; virgin env?
  8468                                          je	short init_prompt		; no
  8469                                  
  8470                                  ; Establish a more reasonable default for the PATH
  8471                                  
  8472                                  	;mov	ah,GET_DEFAULT_DRIVE
  8473                                  	mov	ah,19h
  8474                                  	int	21h
  8475                                          add     al,'A'                          ; convert to letter
  8476                                          mov     [DefPathString],al              ;
  8477                                          mov     [DefPath2String],al             ; now our default paths are complete
  8478                                  
  8479                                          mov     dl,0                            ; get dir for default drive
  8480                                          push    ds                              ;
  8481                                          push    es                              ;
  8482                                          pop     ds                              ;
  8483                                          mov     byte [di],'\'			;
  8484                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8485                                  	;mov	ah,Current_Dir                  ;
  8486                                          mov	ah,47h
  8487                                  	int     21h                             ;
  8488                                          pop     ds                              ;
  8489                                  
  8490                                  	;mov	cx,DefPathStrLen+1              ;
  8491                                  	mov	cx,9 ; db "C:\MSDOS",0
  8492                                  	;mov	dx,offset RESGROUP:DefPathString
  8493                                  	mov	dx,DefPathString 
  8494                                  	mov	si,dx                           ;
  8495                                          ;mov	ah,CHDir                        ;
  8496                                          mov	ah,3Bh
  8497                                  	int     21h                             ;
  8498                                          jnc	short init_setpath		; DefPathString exists!
  8499                                  
  8500                                  	;mov	cx,DefPath2StrLen+1		;
  8501                                          mov	cx,7 ; db "C:\DOS",0
  8502                                  	;mov	dx,offset RESGROUP:DefPath2String
  8503                                  	mov	dx,DefPath2String
  8504                                          mov     si,dx                           ;
  8505                                          ;mov	ah,CHDir                        ;
  8506                                          mov	ah,3Bh
  8507                                          int     21h                             ;
  8508                                          jc	short init_prompt		; DefPath2String doesn't exist
  8509                                  
  8510                                  init_setpath:
  8511                                          mov     dx,di                           ; success
  8512                                          push    ds                              ; so restore prev dir
  8513                                          push    es                              ;
  8514                                          pop     ds                              ; DS:DX -> prev dir
  8515                                          ;mov	ah,CHDir                        ;
  8516                                          mov	ah,3Bh
  8517                                          int     21h                             ;
  8518                                          pop     ds                              ;
  8519                                  
  8520                                          dec     di                              ; then copy in DefPathString
  8521                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8522                                  
  8523                                  ; Initialize the default prompt
  8524                                  
  8525                                  init_prompt:
  8526                                          push    di                              ;
  8527                                          sub     ax,ax                           ;
  8528                                          mov     cx,64                           ; insure any data read in
  8529                                          rep     stosb                           ; from Current_Dir is zapped
  8530                                          pop     di                              ;
  8531                                  
  8532                                  	cmp	[AllocedEnv],al			; virgin env?
  8533                                          je	short init_comspec		; no
  8534                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8535                                          mov	si,PrmptString
  8536                                  	cmp     [si],al				; add it?
  8537                                          je      short init_comspec		; no
  8538                                  	;mov	cx,PrmptStrLen+1                ;
  8539                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8540                                  	rep     movsb                           ;
  8541                                  
  8542                                  ; Initialize the Comspec string
  8543                                  
  8544                                  init_comspec:
  8545                                          cmp	[ComspOffset],ax		; add it?
  8546                                          jne	short init_done			; no
  8547                                          lea     ax,[di+ComspStrLen]             ;
  8548                                          mov	[ComspOffset],ax		;
  8549                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8550                                          mov	si,ComspString
  8551                                  	;mov	cx,ComspStrLen2+1               ;
  8552                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8553                                  	rep     movsb                           ;
  8554                                  
  8555                                  init_done:
  8556                                          mov     ax,es                           ; return env seg in ax
  8557                                          mov     [EnvirSeg],ax			; save env seg
  8558                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8559                                  %endif
  8560                                  
  8561                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8562                                  %if 1
  8563                                  	;mov	bx,10
  8564 00001B86 BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8565 00001B89 B448                    	mov	ah,48h
  8566 00001B8B CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8567                                  			; BX = number of 16-byte paragraphs desired
  8568 00001B8D 722C                    	jc	short init_nomem
  8569                                  
  8570                                  init_ok:
  8571 00001B8F 8EC0                    	mov	es,ax
  8572                                  	;assume	es:nothing                      ; es = temp env segment
  8573                                  
  8574 00001B91 31FF                    	xor	di,di
  8575 00001B93 89F8                    	mov	ax,di
  8576                                  	;mov	cx,160	
  8577 00001B95 B9A000                          mov     cx,ENVIRONSIZ
  8578 00001B98 F3AA                            rep	stosb
  8579                                  
  8580                                  init_pathstr:
  8581                                  
  8582                                  ; Initialize the path string (PATH=) first
  8583                                  
  8584 00001B9A 16                      	push	ss
  8585 00001B9B 1F                      	pop	ds
  8586                                  
  8587                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8588 00001B9C BE[531C]                	mov	si,PathString
  8589 00001B9F BF0000                  	mov	di,0
  8590                                  init_cp_pathstr:
  8591 00001BA2 AC                      	lodsb
  8592 00001BA3 AA                      	stosb
  8593 00001BA4 08C0                    	or	al,al
  8594 00001BA6 75FA                    	jnz	short init_cp_pathstr
  8595                                  
  8596                                  ; Initialize the Comspec string
  8597                                  
  8598                                  init_comspec:
  8599                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8600 00001BA8 BE[591C]                        mov	si,ComspString
  8601                                  	; 05/05/2023
  8602 00001BAB BF0600                  	mov	di,6
  8603                                  init_cp_compstr:
  8604 00001BAE AC                      	lodsb
  8605 00001BAF AA                      	stosb
  8606 00001BB0 08C0                    	or	al,al
  8607 00001BB2 75FA                    	jnz	short init_cp_compstr
  8608                                  
  8609                                  init_done:
  8610 00001BB4 8CC0                            mov     ax,es                           ; return env seg in ax
  8611                                          ;mov	[EnvirSeg],ax			; save env seg
  8612                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8613                                  %endif	
  8614                                  
  8615                                  	; 29/01/2023
  8616                                  alloc_done:
  8617 00001BB6 5F                      	pop	di
  8618 00001BB7 5E                      	pop	si
  8619 00001BB8 07                      	pop	es
  8620 00001BB9 1F                              pop     ds
  8621                                  	;assume	ds:nothing
  8622 00001BBA C3                      	retn
  8623                                  
  8624                                  	; 29/01/2023
  8625                                  init_nomem:
  8626                                  
  8627                                  ;We call the error routine from here. This routine never returns. It either
  8628                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8629                                  ;the system ( if it is the first COMMAND.COM ).
  8630                                  
  8631 00001BBB E80000                  	call	Alloc_error
  8632                                  
  8633                                  ;Alloc_env	endp
  8634                                  
  8635                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8636                                  ; check if this is a permanent or secondary command.com and take the 
  8637                                  ; appropriate action.
  8638                                  ;
  8639                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8640                                  ;
  8641                                  ;	EXIT:	None - does not return
  8642                                  ;
  8643                                  ;	REGISTERS AFFECTED: Does not matter
  8644                                  ;
  8645                                  
  8646                                  ;public Alloc_error
  8647                                  Alloc_error:	;proc	near
  8648                                  
  8649                                  	;jmp	RESGROUP:BadMemErr
  8650                                  	; 29/01/2023
  8651 00001BBE E946F1                  	jmp	BadMemErr	
  8652                                  	
  8653                                  ;Alloc_error	endp
  8654                                  
  8655                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8656                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8657                                  
  8658                                  	; MSDOS 6.0
  8659                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8660                                  ; the stub table of the various entry points in the resident code segment.
  8661                                  ; Some of them are interrupt entry points and some of them are entries from
  8662                                  ; the transient to the resident code segment.
  8663                                  ;
  8664                                  ;	ENTRY:	ds = RESGROUP
  8665                                  ;		es:di = segment:offset of final location of resident code
  8666                                  ;
  8667                                  ;	EXIT:	All segments and offsets patched into the stub table
  8668                                  ;
  8669                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8670                                  
  8671                                  patch_stub:	;proc near
  8672                                  	;assume	ds:RESGROUP
  8673                                  	
  8674 00001BC1 06                      	push	es
  8675                                  
  8676 00001BC2 8CC3                    	mov	bx,es			;bx = resident code segment
  8677 00001BC4 89FA                    	mov	dx,di
  8678                                  	;mov	di,offset DATARES:Int2f_Entry
  8679 00001BC6 BF[0400]                	mov	di,Int2f_Entry
  8680                                  	;mov	si,offset RESGROUP:Reloc_Table
  8681 00001BC9 BE[A620]                	mov	si,Reloc_Table
  8682 00001BCC 1E                      	push	ds
  8683 00001BCD 07                      	pop	es			;es = RESGROUP = DATARES
  8684                                  
  8685                                  ;bx:dx = segment:offset of resident code segment
  8686                                  ;es:di = entry point table in stub
  8687                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8688                                  
  8689                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8690 00001BCE B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8691                                  patchlp:
  8692 00001BD1 AD                      	lodsw				;get current offset
  8693 00001BD2 01D0                    	add	ax,dx			;offset it by code seg location 
  8694 00001BD4 AB                      	stosw				;store offset
  8695 00001BD5 89D8                    	mov	ax,bx			
  8696 00001BD7 AB                      	stosw				;store segment 
  8697 00001BD8 E2F7                    	loop	patchlp
  8698                                  
  8699 00001BDA 07                      	pop	es
  8700 00001BDB C3                      	retn
  8701                                  
  8702                                  ;Patch_stub	endp
  8703                                  
  8704                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8705                                  
  8706                                  	; MSDOS 6.0
  8707                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8708                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8709                                  ; are temporarily needed to handle these interrupts if they occur before
  8710                                  ; the resident is relocated to its final position and all the addresses of
  8711                                  ; the handlers have been updated.
  8712                                  ;
  8713                                  ;	ENTRY:	es = PSP segment = code segment
  8714                                  ;
  8715                                  ;	EXIT:	Current segment values patched into the jump table in the
  8716                                  ;		stub.
  8717                                  ;
  8718                                  ;	REGISTERS AFFECTED: ax, cx, di
  8719                                  
  8720                                  patch_segs:	;proc near
  8721                                  
  8722                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8723 00001BDC BF[0400]                	mov	di,Int2f_Entry 
  8724 00001BDF B90400                  	mov	cx,4			;we have to patch 4 handlers
  8725 00001BE2 83C702                  	add	di,2
  8726 00001BE5 8CC0                    	mov	ax,es
  8727                                  pseglp:
  8728 00001BE7 AB                      	stosw				;store the segment value
  8729 00001BE8 83C702                  	add	di,2			;skip the next offset value
  8730 00001BEB E2FA                    	loop	pseglp
  8731                                  
  8732 00001BED C3                      	retn
  8733                                  
  8734                                  ;Patch_segs	endp
  8735                                  
  8736                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8737                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8738                                  
  8739                                  	; MSDOS 6.0
  8740                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8741                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8742                                  ; and is used by the stub when we have to jump to the resident in HMA
  8743                                  ;
  8744                                  ;	ENTRY:	ds = RESGROUP
  8745                                  ;
  8746                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8747                                  ;
  8748                                  ;	REGISTERS AFFECTED:
  8749                                  ;
  8750                                  
  8751                                  get_XMMAddr:	;proc near
  8752                                  	;assume	ds:RESGROUP
  8753                                  
  8754 00001BEE 06                      	push	es
  8755                                  
  8756                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8757 00001BEF B80043                  	mov	ax,4300h
  8758 00001BF2 CD2F                    	int	2Fh
  8759                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8760                                  		; Return: AL = 80h XMS driver installed
  8761                                  		; AL <> 80h no driver
  8762 00001BF4 3C80                    	cmp	al,80h			; Q: installed
  8763 00001BF6 750D                    	jne	short cXMMexit		; N: set error, quit
  8764                                  ;
  8765                                  ; get the XMM control functions entry point, save it, we
  8766                                  ; need to call it later.
  8767                                  ;
  8768                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8769 00001BF8 B81043                  	mov	ax,4310h
  8770 00001BFB CD2F                    	int	2Fh
  8771                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8772                                  		; Return: ES:BX -> driver entry point
  8773                                  
  8774 00001BFD 891E[3000]              	mov	[XMMCallAddr], bx
  8775 00001C01 8C06[3200]              	mov	[XMMCallAddr+2],es
  8776                                  cXMMexit:
  8777 00001C05 07                      	pop	es
  8778 00001C06 C3                      	retn				; done
  8779                                  
  8780                                  ;get_XMMAddr	endp
  8781                                  
  8782                                  ;=============================================================================
  8783                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8784                                  ;=============================================================================
  8785                                  ; 24/09/2018 - Retro DOS v3.0
  8786                                  
  8787                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8788                                  
  8789                                  ; TITLE	COMMAND Initialization messages
  8790                                  
  8791                                  ;INIT	SEGMENT PUBLIC PARA
  8792                                  
  8793                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8794                                  
  8795                                  	; 25/09/2018
  8796                                  	; (15 bytes filler)
  8797 00001C07 00                      	db 0
  8798                                  	;db "25/9/2018 ETAN"
  8799                                  	; 15/06/2023
  8800                                  	;db "15/6/2023 ETAN"	
  8801                                  	; 31/07/2024
  8802 00001C08 33312F372F32303234-     	db "31/7/2024 ETAN"
  8802 00001C11 204554414E         
  8803 00001C16 00                      	db 0
  8804                                  
  8805                                  ; 30/01/2023
  8806                                  %if 0
  8807                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8808                                  	;dw 0
  8809                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8810                                  	db 0Dh,0Ah
  8811                                  	db 0Dh,0Ah
  8812                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8813                                  	db 0Dh,0Ah
  8814                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8815                                  	db ' ',0Dh,0Ah
  8816                                  	db '                                                   ',
  8817                                  	db 0Dh,0Ah,0
  8818                                  
  8819                                  	times 43 db 20h
  8820                                  
  8821                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8822                                  BADCOMLKMES:
  8823                                  	dw _152Fh
  8824                                  
  8825                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8826                                  BADCOMACCMSG:
  8827                                  	dw _155Ah
  8828                                  
  8829                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8830                                  ACCDENERR:
  8831                                  	dw _1593h
  8832                                  
  8833                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8834                                  OUTENVMSG:
  8835                                  	dw _15A5h
  8836                                  
  8837                                  BADVERMSG:
  8838                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8839                                  
  8840                                  BADENVSIZMSG:
  8841                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8842                                  
  8843                                  HEADERPTR:
  8844                                  	dw COPYRIGHTMSG
  8845                                  %endif
  8846                                  
  8847                                  ; 30/01/2023
  8848                                  ;align 16
  8849                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8850                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8851                                  ICONDEV:
  8852 00001C17 2F4445562F                      db '/DEV/'
  8853 00001C1C 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8854                                  BADCSPFL:
  8855 00001C25 00                      	db 0
  8856                                  COMSPECT:
  8857 00001C26 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8857 00001C2F 434F4D00           
  8858 00001C33 00                      	db 0
  8859                                  AUTOBAT:
  8860 00001C34 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8860 00001C3D 45432E424154000D   
  8861                                  ;KAUTOBAT:
  8862                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8863                                  PRDATTM:
  8864 00001C45 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8865                                  INITADD:
  8866 00001C46 00000000                	dd 0
  8867                                  print_add:
  8868 00001C4A [DD4D]                  	dw Printf_Init
  8869 00001C4C 0000                    	dw 0
  8870                                  triage_add:
  8871 00001C4E [A12C]                  	dw Triage_Init
  8872 00001C50 0000                    	dw 0
  8873                                  ;CHUCKENV:
  8874                                  AllocedEnv:
  8875 00001C52 00                      	db 0
  8876                                  
  8877                                  ; 30/01/2023 - MSDOS 3.3
  8878                                  ;COMSPOFFSET:
  8879                                  ;ECOMLOC:
  8880                                  ;	;dw 0Eh
  8881                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8882                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8883                                  ;COMSPSTRING:
  8884                                  ;	db 'COMSPEC='
  8885                                  
  8886                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8887                                  PathString:
  8888 00001C53 504154483D00            	db 'PATH=',0
  8889                                  PathStrLen equ $-PathString-1
  8890                                  ; MSDOS 6.0
  8891                                  ;DefPathString:
  8892                                  ;	db 'C:\MSDOS',0
  8893                                  ;DefPathStrLen equ  $-DefPathString-1
  8894                                  ;DefPath2String:
  8895                                  ;	db 'C:\DOS',0
  8896                                  ;DefPath2StrLen equ $-DefPath2String-1
  8897                                  ;
  8898                                  ;PrmptString:
  8899                                  ;	db 'PROMPT=$P$G',0
  8900                                  ;PrmptStrLen equ $-PrmptString-1
  8901                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8902                                  ;ComspOffset:
  8903                                  ;	dw 0
  8904                                  ComspString:
  8905 00001C59 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8905 00001C62 434F4D4D414E442E43-
  8905 00001C6B 4F4D00             
  8906                                  ComspStrLen equ 8		; length of COMSPEC=
  8907                                  ComspStrLen2 equ $-ComspString-1
  8908                                  				; length of full COMSPEC
  8909                                  	; 29/01/2023
  8910                                  ;equal_sign:
  8911                                  ;equalsign:
  8912                                  ;	db '='
  8913                                  ;letter_a:
  8914                                  ;lcasea:
  8915                                  ;	db 'a'
  8916                                  ;letter_z:
  8917                                  ;lcasez:
  8918                                  ;	db 'z'
  8919                                  	; 30/01/2023
  8920                                  ;;slash_chr:
  8921                                  ;;	db '/'
  8922                                  ;;bslash_chr:
  8923                                  ;;	db '\'
  8924                                  ;space_chr:
  8925                                  ;;space:
  8926                                  ;	db 20h
  8927                                  ;;letter_p:
  8928                                  ;;	db 'p'
  8929                                  ;;letter_d:
  8930                                  ;;	db 'd'
  8931                                  ;;letter_c:
  8932                                  ;;	db 'c'
  8933                                  	; 16/04/2023
  8934                                  ; MSDOS 5.0 & MSDOS 6.0
  8935                                  ;scswitch:
  8936                                  ;	db 'C'		; Single command
  8937                                  ;;skswitch:
  8938                                  ;	db 'K' ; MSDOS 6.0
  8939                                  ;;letter_A:
  8940                                  ;ucasea: ; 21/01/2023 
  8941                                  ;	db 'A'
  8942                                  
  8943                                  	; 30/01/2023
  8944                                  EnvSiz:
  8945 00001C6E 0000                    	dw 0		; size user wants to allocate
  8946                                  EnvMax:
  8947 00001C70 0000                    	dw 0		; maximum size allowed
  8948                                  OldEnv:
  8949 00001C72 0000                    	dw 0		; envirseg at initialization
  8950                                  UsedEnv:
  8951 00001C74 0000                    	dw 0		; amount of envirseg used
  8952                                  	; MSDOS 5.0 & MSDOS 6.0
  8953                                  PARS_MSG_OFF:
  8954 00001C76 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8955                                  PARS_MSG_SEG:
  8956 00001C78 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8957                                  
  8958                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8959                                  
  8960                                  Init_Parse:
  8961                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8962                                  init_p:
  8963 00001C7A [D94D]                  	dw append_parse
  8964                                  initend:
  8965 00001C7C 0000                    	dw 0		; segment address of end of init
  8966                                  TrnSize:
  8967 00001C7E 0000                    	dw 0		; size of transient in paragraphs
  8968                                  
  8969                                  ; 23/07/2024 - Retro DOS v4.1 (& 4.0) COMMAND.COM
  8970                                  ;%if 0
  8971                                  resetenv:
  8972                                  	;dw 0		; set if we need to setblck env at endinit
  8973                                  	; 23/07/2024
  8974 00001C80 00                      	db 0
  8975                                  ;%endif
  8976                                  
  8977                                  ext_msg:
  8978 00001C81 00                      	db 0		; set if /MSG switch entered
  8979                                  eswitch:
  8980 00001C82 00                      	db 0		; set if /e was entered
  8981                                  dswitch:
  8982 00001C83 00                      	db 0		; set if /d was entered
  8983                                  parsemes_ptr:
  8984 00001C84 0000                    	dw 0		; word to store parse error number
  8985                                  
  8986                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8987                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  8988                                  
  8989                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8990                                  ;  The following parse control block is used for COMMAND. This block is
  8991                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8992                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8993                                  ;
  8994                                  ;  Anything on the command line after the /C switch will be passed to the
  8995                                  ;  executable command, so if /C is used, it must be specified last. The
  8996                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8997                                  ;
  8998                                  ;  The /? switch causes help text to be displayed. Any other options
  8999                                  ;  on the command line are ignored. Command.com will not load if /?
  9000                                  ;  is specified.
  9001                                  
  9002                                  INTERNAT_INFO:		; used for country info after parsing is completed
  9003                                  PARSE_COMMAND:
  9004 00001C86 [891C]                  	dw COMMAND_PARMS
  9005 00001C88 00                      	db 0			; no extra delimiter
  9006                                  COMMAND_PARMS:
  9007 00001C89 0002                    	db 0,2			; 1 positional parm
  9008 00001C8B [9F1C]                  	dw COMMAND_FILE
  9009 00001C8D [9F1C]                  	dw COMMAND_FILE
  9010                                          ; MSDOS 5.0
  9011 00001C8F 07                      	db 7			; 7 switches
  9012                                  	; MSDOS 6.0
  9013                                  	;db 8 			; 8 switches
  9014 00001C90 [A81C]                  	dw COMMAND_SWITCH1
  9015 00001C92 [B41C]                  	dw COMMAND_SWITCH2
  9016 00001C94 [C01C]                  	dw COMMAND_SWITCH3
  9017 00001C96 [CC1C]                  	dw COMMAND_SWITCH4
  9018 00001C98 [E51C]                  	dw COMMAND_SWITCH5
  9019 00001C9A [F11C]                  	dw COMMAND_SWITCH6
  9020 00001C9C [FF1C]                  	dw COMMAND_SWITCH7
  9021                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  9022 00001C9E 00                      	db 0			; no keywords
  9023                                  
  9024                                  COMMAND_FILE:
  9025 00001C9F 0102                    	dw 0201h		; filespec - optional
  9026 00001CA1 0100                    	dw 1			; capitalize - file table
  9027 00001CA3 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9028 00001CA5 [131D]                  	dw NO_VAL 		;
  9029 00001CA7 00                      	db 0			; no keywords
  9030                                  
  9031                                  COMMAND_SWITCH1:
  9032 00001CA8 0000                    	dw 0			; no match flags
  9033 00001CAA 0200                    	dw 2			; capitalize by char table
  9034 00001CAC [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9035 00001CAE [131D]                  	dw NO_VAL 		;
  9036 00001CB0 01                      	db 1			; 1 keyword
  9037                                  COMMAND_P_SYN:
  9038 00001CB1 2F5000                  	db '/P',0		; /P switch
  9039                                  
  9040                                  COMMAND_SWITCH2:
  9041 00001CB4 0000                    	dw 0			; no match flags
  9042 00001CB6 0200                    	dw 2			; capitalize by char table
  9043 00001CB8 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9044 00001CBA [131D]                  	dw NO_VAL 		;
  9045 00001CBC 01                      	db 1			; 1 keyword
  9046                                  COMMAND_F_SYN:
  9047 00001CBD 2F4600                  	db '/F',0		; /F switch
  9048                                  
  9049                                  COMMAND_SWITCH3:
  9050 00001CC0 0000                    	dw 0			; no match flags
  9051 00001CC2 0200                    	dw 2			; capitalize by char table
  9052 00001CC4 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9053 00001CC6 [131D]                  	dw NO_VAL 		;
  9054 00001CC8 01                      	db 1			; 1 keyword
  9055                                  COMMAND_D_SYN:
  9056 00001CC9 2F4400                  	db '/D',0		; /D switch
  9057                                  
  9058                                  COMMAND_SWITCH4:
  9059 00001CCC 0080                    	dw 8000h		; numeric value - required
  9060 00001CCE 0000                    	dw 0			; no function flags
  9061 00001CD0 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9062 00001CD2 [D81C]                  	dw COMMAND_E_VAL	; pointer to value list
  9063 00001CD4 01                      	db 1			; 1 keyword
  9064                                  COMMAND_E_SYN:
  9065 00001CD5 2F4500                  	db '/E',0		; /E switch
  9066                                  
  9067                                  COMMAND_E_VAL:
  9068 00001CD8 01                      	db 1			;
  9069 00001CD9 01                      	db 1			; 1 range
  9070 00001CDA 01                      	db 1			; returned if result
  9071                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  9072                                  	; MSDOS 5.0 COMMAND.COM
  9073                                  	; (RESGROUP:1F2Bh)
  9074 00001CDB A0000000                	dd 160	 ; ENVSML
  9075 00001CDF 00800000                	dd 32768 ; ENVBIG
  9076 00001CE3 00                      	db 0			; no numeric values
  9077 00001CE4 00                      	db 0			; no string values
  9078                                  
  9079                                  COMMAND_SWITCH5:
  9080 00001CE5 0000                    	dw 0			; no match flags
  9081 00001CE7 0200                    	dw 2			; capitalize by char table
  9082 00001CE9 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9083 00001CEB [131D]                  	dw NO_VAL 		;
  9084 00001CED 01                      	db 1			; 1 keyword
  9085                                  COMMAND_C_SYN:
  9086 00001CEE 2F4300                  	db '/C',0		; /C switch
  9087                                  
  9088                                  COMMAND_SWITCH6:
  9089 00001CF1 0000                    	dw 0			; no match flags
  9090 00001CF3 0200                    	dw 2			; capitalize by char table
  9091 00001CF5 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9092 00001CF7 [131D]                  	dw NO_VAL 		;
  9093 00001CF9 01                      	db 1			; 1 keyword
  9094                                  COMMAND_M_SYN:
  9095 00001CFA 2F4D534700              	db '/MSG',0		; /MSG switch
  9096                                  
  9097                                  COMMAND_SWITCH7:
  9098 00001CFF 0000                    	dw 0			; no match flags
  9099 00001D01 0200                    	dw 2			; capitalize by char table
  9100 00001D03 [0B1D]                  	dw COMND1_OUTPUT	; result buffer
  9101 00001D05 [131D]                  	dw NO_VAL 		;
  9102 00001D07 01                      	db 1			; 1 keyword
  9103                                  COMMAND_?_SYN:
  9104 00001D08 2F3F00                  	db '/?',0 		; /? switch
  9105                                  
  9106                                  	; MSDOS 6.0
  9107                                  ;COMMAND_SWITCH8:
  9108                                  ;	dw 0			; no match flags
  9109                                  ;	dw 2			; capitalize by char table
  9110                                  ;	dw COMND1_OUTPUT	; result buffer
  9111                                  ;	dw NO_VAL 		;
  9112                                  ;	db 1			; 1 keyword
  9113                                  ;COMMAND_K_SYN:
  9114                                  ;	db '/K',0		; /K switch
  9115                                  
  9116                                  COMND1_OUTPUT:
  9117                                  COMND1_TYPE:
  9118 00001D0B 00                      	db 0			; type
  9119                                  COMND1_CODE:
  9120 00001D0C 00                      	db 0			; return value
  9121                                  COMND1_SYN:
  9122 00001D0D 0000                    	dw 0			; synonym pointer
  9123                                  COMND1_ADDR:
  9124 00001D0F 00000000                	dd 0			; numeric value / address
  9125                                  				; of string value
  9126                                  NO_VAL:
  9127 00001D13 00                      	db 0			; no values
  9128                                  num_positionals:
  9129 00001D14 0000                    	dw 0			; counter for positionals
  9130                                  old_parse_ptr:
  9131 00001D16 0000                    	dw 0			; SI position before calling parser
  9132                                  
  9133                                  	; 30/01/2023
  9134                                  ;***	INITIALIZATION MESSAGES
  9135                                  ;	-------------------------
  9136                                  ;	include	comimsg.inc	;M00
  9137                                  ;-----------------------------------------------------------------------------	
  9138                                  
  9139                                  BADVERMSG:
  9140 00001D18 17                      	db 23
  9141 00001D19 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9141 00001D22 20444F532076657273-
  9141 00001D2B 696F6E0D0A         
  9142                                  OUTENVMSG:
  9143 00001D30 1A                      	db 26
  9144 00001D31 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9144 00001D3A 7669726F6E6D656E74-
  9144 00001D43 2073706163650D0A   
  9145                                  COPYRIGHTMSG:
  9146 00001D4B 5E                      	db 94
  9147 00001D4C 0D0A                    	db 0Dh,0Ah
  9148 00001D4E 0D0A                    	db 0Dh,0Ah
  9149 00001D50 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9149 00001D59 285229204D532D444F-
  9149 00001D62 532852292056657273-
  9149 00001D6B 696F6E20352E30300D-
  9149 00001D74 0A                 
  9150 00001D75 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9150 00001D7E 20202020284329436F-
  9150 00001D87 70797269676874204D-
  9150 00001D90 6963726F736F667420-
  9150 00001D99 436F72702031393831-
  9150 00001DA2 2D313939312E0D0A   
  9151                                  BADCOMLKMES:
  9152 00001DAA 28                      	db 40
  9153 00001DAB 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9153 00001DB4 20434F4D4D414E4420-
  9153 00001DBD 736561726368206469-
  9153 00001DC6 726563746F72792062-
  9153 00001DCF 61640D0A           
  9154                                  BADCOMACCMSG:
  9155 00001DD3 36                      	db 54
  9156 00001DD4 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9156 00001DDD 20434F4D4D414E4420-
  9156 00001DE6 736561726368206469-
  9156 00001DEF 726563746F72792062-
  9156 00001DF8 616420             
  9157 00001DFB 616363657373206465-     	db 'access denied',0Dh,0Ah
  9157 00001E04 6E6965640D0A       
  9158                                  HELPMSG1:
  9159 00001E0A 3C                      	db 60
  9160 00001E0B 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9160 00001E14 6E657720696E737461-
  9160 00001E1D 6E6365206F66207468-
  9160 00001E26 65204D532D444F5320-
  9160 00001E2F 636F6D6D616E642069-
  9160 00001E38 6E7465727072657465-
  9160 00001E41 722E0D0A           
  9161 00001E45 0D0A                    	db 0Dh,0Ah
  9162                                  HELPMSG2:
  9163 00001E47 46                      	db 70
  9164 00001E48 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9164 00001E51 5B64726976653A5D70-
  9164 00001E5A 6174685D205B646576-
  9164 00001E63 6963655D205B2F453A-
  9164 00001E6C 6E6E6E6E6E5D205B2F-
  9164 00001E75 505D205B2F43207374-
  9164 00001E7E 72696E675D205B2F4D-
  9164 00001E87 53475D             
  9165 00001E8A 0D0A                    	db 0Dh,0Ah
  9166 00001E8C 0D0A                    	db 0Dh,0Ah
  9167                                  HELPMSG3:
  9168 00001E8E 48                              db 72
  9169 00001E8F 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9169 00001E98 5D7061746820202020-
  9169 00001EA1 537065636966696573-
  9169 00001EAA 207468652064697265-
  9169 00001EB3 63746F727920636F6E-
  9169 00001EBC 7461696E696E672043-
  9169 00001EC5 4F4D4D414E442E434F-
  9169 00001ECE 4D20               
  9170 00001ED0 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9171                                  HELPMSG4:
  9172 00001ED7 4D                      	db 77
  9173 00001ED8 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9173 00001EE1 202020202020202020-
  9173 00001EEA 537065636966696573-
  9173 00001EF3 207468652064657669-
  9173 00001EFC 636520746F20757365-
  9173 00001F05 20666F7220636F6D6D-
  9173 00001F0E 616E6420696E707574-
  9173 00001F17 20616E6420         
  9174 00001F1C 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9175                                  HELPMSG5:
  9176 00001F25 45                      	db 69
  9177 00001F26 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9177 00001F2F 6E2020202020202020-
  9177 00001F38 536574732074686520-
  9177 00001F41 696E697469616C2065-
  9177 00001F4A 6E7669726F6E6D656E-
  9177 00001F53 742073697A6520746F-
  9177 00001F5C 206E6E6E6E6E206279-
  9177 00001F65 7465732E           
  9178 00001F69 0D0A                    	db 0Dh,0Ah
  9179                                  HELPMSG6:
  9180 00001F6B 4D                      	db 77
  9181 00001F6C 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9181 00001F75 202020202020202020-
  9181 00001F7E 4D616B657320746865-
  9181 00001F87 206E657720636F6D6D-
  9181 00001F90 616E6420696E746572-
  9181 00001F99 707265746572207065-
  9181 00001FA2 726D616E656E7420   
  9182 00001FAA 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9182 00001FB3 6974292E0D0A       
  9183                                  HELPMSG7:
  9184 00001FB9 50                      	db 80
  9185 00001FBA 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9185 00001FC3 6E6720202020202020-
  9185 00001FCC 43617272696573206F-
  9185 00001FD5 75742074686520636F-
  9185 00001FDE 6D6D616E6420737065-
  9185 00001FE7 636966696564206279-
  9185 00001FF0 20737472696E672C20-
  9185 00001FF9 616E6420           
  9186 00001FFD 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9186 00002006 732E0D0A           
  9187                                  HELPMSG8:
  9188 0000200A 4E                      	db 78
  9189 0000200B 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9189 00002014 202020202020202020-
  9189 0000201D 537065636966696573-
  9189 00002026 207468617420616C6C-
  9189 0000202F 206572726F72206D65-
  9189 00002038 737361676573206265-
  9189 00002041 2073746F7265642069-
  9189 0000204A 6E20               
  9190 0000204C 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9190 00002055 6F750D0A           
  9191                                  HELPMSG9:
  9192 00002059 38                      	db 56
  9193 0000205A 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9193 00002063 202020202020202020-
  9193 0000206C 6E65656420746F2073-
  9193 00002075 706563696679202F50-
  9193 0000207E 207769746820746869-
  9193 00002087 73207377697463682E-
  9193 00002090 0D0A               
  9194                                  HelpMsgs:
  9195 00002092 [0A1E]                          dw HELPMSG1
  9196 00002094 [471E]                  	dw HELPMSG2
  9197 00002096 [8E1E]                  	dw HELPMSG3
  9198 00002098 [D71E]                  	dw HELPMSG4
  9199 0000209A [251F]                  	dw HELPMSG5
  9200 0000209C [6B1F]                  	dw HELPMSG6
  9201 0000209E [B91F]                  	dw HELPMSG7
  9202 000020A0 [0A20]                  	dw HELPMSG8
  9203 000020A2 [5920]                  	dw HELPMSG9
  9204                                  
  9205                                  	; 23/04/2023
  9206 000020A4 0000                    	dw 0
  9207                                  
  9208                                  ;-----------------------------------------------------------------------------
  9209                                  
  9210                                  ;SR;
  9211                                  ; This table of offsets is used by the init code to calculate the new offsets
  9212                                  ;for these labels after the resident code has been relocated
  9213                                  
  9214                                  ;Reloc_Table:
  9215                                  	;dw offset CODERES:MsgInt2fHandler
  9216                                  	;dw offset CODERES:Int_2e
  9217                                  	;dw offset CODERES:ContC
  9218                                  	;dw offset CODERES:DskErr
  9219                                  	;dw offset CODERES:Exec_Ret
  9220                                  	;dw offset CODERES:TRemCheck
  9221                                  	;dw offset CODERES:TrnLodCom1
  9222                                  	;dw offset CODERES:LodCom
  9223                                  	;dw offset CODERES:MsgRetriever
  9224                                  	;dw offset CODERES:THeadFix
  9225                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9226                                  
  9227                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9228                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9229                                  
  9230                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9231 000020A6 1707                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9232 000020A8 7301                    	dw Int_2e - RCODE_START		  ; 177h	
  9233 000020AA 3300                    	dw ContC - RCODE_START		  ; 035h
  9234 000020AC 3404                    	dw DSKERR - RCODE_START		  ; 445h
  9235 000020AE 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9236 000020B0 9702                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9237 000020B2 1104                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9238 000020B4 AA01                    	dw LodCom - RCODE_START		  ; 1AEh
  9239 000020B6 5A07                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9240 000020B8 B602                    	dw THeadFix - RCODE_START	  ; 2C2h
  9241 000020BA D307                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9242                                  
  9243                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9244                                  
  9245                                  ResJmpTable:
  9246 000020BC 00000000                	dd 0			; stores prev stub jump table addr
  9247                                  FirstCom:
  9248 000020C0 00                      	db 0			; flag set if first command.com
  9249                                  DevFlag:
  9250 000020C1 00                      	db 0
  9251                                  PathFlag:
  9252 000020C2 00                      	db 0
  9253                                  
  9254                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9255                                  	;times 13 db 0
  9256                                  
  9257                                  ; 30/01/2023
  9258                                  coderes_end equ $
  9259                                  
  9260                                  ;INIT	ENDS
  9261                                  
  9262                                  ;	END
  9263                                  
  9264                                  ;-----------------------------------------------------------------------------
  9265                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9266                                  ;-----------------------------------------------------------------------------
  9267                                  
  9268                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9269                                  	; 30/01/2023
  9270 000020C3 00                      db	0
  9271                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"
  9272 000020C4 526574726F20444F53-     db	"Retro DOS v4 COMMAND.COM by Erdogan Tan [2024]" ; 21/07/2024	
  9272 000020CD 20763420434F4D4D41-
  9272 000020D6 4E442E434F4D206279-
  9272 000020DF 204572646F67616E20-
  9272 000020E8 54616E205B32303234-
  9272 000020F1 5D                 
  9273 000020F2 00                      db	0
  9274                                  
  9275                                  ;-----------------------------------------------------------------------------
  9276                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9277                                  ;-----------------------------------------------------------------------------
  9278                                  
  9279                                  ;TAIL    SEGMENT PUBLIC PARA
  9280                                  ;        ORG     0
  9281                                  ;TRANSTART LABEL WORD
  9282                                  ;TAIL    ENDS
  9283                                  
  9284                                  ;ALIGN 16  ; 25/09/2018
  9285                                  
  9286                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9287                                  
  9288                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9289                                  numbertomod equ (numbertodiv % 16)
  9290                                  
  9291                                  %if numbertomod>0 & numbertomod<16
  9292 000020F3 00<rep Dh>              	times (16-numbertomod) db 0
  9293                                  %endif
  9294                                  
  9295                                  ; 30/01/2023
  9296                                  ;TRANSTART:
  9297                                  
  9298                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9299                                  ;	times	128 db 0	
  9300                                  
  9301                                  ;-----------------------------------------------------------------------------
  9302                                  ; SEGMENT - TRANSCODE
  9303                                  ;-----------------------------------------------------------------------------
  9304                                  
  9305                                  ;TRANGROUP: ; 21/04/2018
  9306                                  
  9307                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9308                                  ;-----------------------------------------------------------------------------
  9309                                  
  9310                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9311                                  
  9312                                  ; 21/04/2018 - Retro DOS v2.0
  9313                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9314                                  ; (these values must be changed when transcom.s source code is changed
  9315                                  ; and data offsets are changed)
  9316                                  ;
  9317                                  ; 30/04/2018
  9318                                  ; 29/04/2018
  9319                                  
  9320                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9321                                  ;COMMAND      EQU  012CH
  9322                                  ;DATINIT      EQU  2091H
  9323                                  ;HEADCALL     EQU  428FH
  9324                                  ;TRANSPACEEND EQU  4D5CH
  9325                                  ;TRANDATAEND  EQU  3F44H
  9326                                  
  9327                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9328                                  ;TRIAGE_INIT  EQU  1F15H
  9329                                  ;PRINTF_INIT  EQU  34E0H 
  9330                                  
  9331                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9332                                  
  9333                                  ;TPA	EQU  4293H
  9334                                  ;TRNLEN	EQU  04D6H
  9335                                  
  9336                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9337                                  ;COMMAND      EQU  012CH
  9338                                  ;DATINIT      EQU  206FH
  9339                                  ;HEADCALL     EQU  426FH
  9340                                  ; 09/01/2023
  9341                                  ;TRANSPACEEND EQU  4D3CH
  9342                                  ;TRANDATAEND  EQU  3F24H
  9343                                  ;TRIAGE_INIT  EQU  1EF3H
  9344                                  ;PRINTF_INIT  EQU  34BFH 
  9345                                  ;
  9346                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9347                                  
  9348                                  ;-----------------------------------------------------------------------------
  9349                                  ; ARENA.INC, MSDOS 6.0, 1991
  9350                                  ;-----------------------------------------------------------------------------
  9351                                  ; 13/10/2018 - Retro DOS 3.0
  9352                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9353                                  
  9354                                  ;BREAK <Memory arena structure>
  9355                                  
  9356                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9357                                  
  9358                                  ; arena item
  9359                                  
  9360                                  struc ARENA
  9361 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9362 00000001 ????                      .owner:	resw 1		; owner of arena item
  9363 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9364                                  endstruc
  9365                                  
  9366                                  ;-----------------------------------------------------------------------------
  9367                                  ;START OF TRANSIENT PORTION
  9368                                  ;This code is loaded at the end of memory and may be overwritten by
  9369                                  ;memory-intensive user programs.
  9370                                  ;-----------------------------------------------------------------------------
  9371                                  
  9372                                  ; 16/04/2023
  9373                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9374                                  ; 29/09/2018
  9375                                  ; 31/01/2023 
  9376                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9377                                  			; 09/01/2023
  9378                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9379                                  
  9380                                  ; 25/09/2018
  9381                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9382                                  ;
  9383                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9384                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9385                                  ;
  9386                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9387                                  ;
  9388                                  ;
  9389                                  ;COMTRANS:
  9390                                  ;
  9391                                  ; 20/10/2018 - Retro DOS v3.0	
  9392                                  ;INCBIN	"TRANCOM3.BIN"
  9393                                  ;
  9394                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9395                                  ;
  9396                                  ; 29/04/2018
  9397                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9398                                  ;
  9399                                  ;TIMES BSS_SIZE db 0
  9400                                  ;
  9401                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9402                                  
  9403                                  ;COMMANDCOMSIZE equ $ - 100h
  9404                                  
  9405                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9406                                  ; ============================================================================
  9407                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9408                                  ; ============================================================================
  9409                                  
  9410                                  ; ----------------------------------------------------------------------------
  9411                                  ; START OF TRANSIENT PORTION
  9412                                  ; ----------------------------------------------------------------------------
  9413                                  ; SEGMENT - TRANSCODE
  9414                                  ; ----------------------------------------------------------------------------
  9415                                  
  9416                                  ; 18/04/2023
  9417                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9418                                  
  9419                                  ; 18/04/2023
  9420                                  ;-----------------------------------------------------------------------------
  9421                                  ; TRANSCODE segment offset 0
  9422                                  TRANSIENTSTART:
  9423                                  
  9424                                  	; 31/01/2023
  9425 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9426                                  
  9427                                  ;============================================================================
  9428                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9429                                  ;============================================================================
  9430                                  ; 12/10/2018 - Retro DOS v3.0
  9431                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9432                                  
  9433                                  ;[ORG 100h]
  9434                                  
  9435                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9436                                  
  9437                                  ; ---------------------------------------------------------------------------
  9438                                  		
  9439                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9440                                  		; (TRANGROUP:0100h)
  9441                                  SETDRV:
  9442 00000100 B40E                    	mov	ah,0Eh
  9443                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9444 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9445                                  			; DL = new default drive number
  9446                                  			;		(0 = A, 1 = B, ..)
  9447                                  			; Return: AL = number of logical drives
  9448                                  
  9449                                  ; ---------------------------------------------------------------------------
  9450                                  
  9451                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9452                                  ; No registers (CS:IP) no flags, nothing.
  9453                                  
  9454                                  TCOMMAND:
  9455 00000104 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
  9456 00000109 B8FFFF                  	mov	ax,-1
  9457 0000010C 8706[9001]              	xchg	ax,[VerVal]
  9458 00000110 83F8FF                  	cmp	ax,-1
  9459 00000113 7404                    	je	short NOSETVER2
  9460 00000115 B42E                    	mov	ah,2Eh
  9461                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9462 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9463                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9464                                  NOSETVER2:
  9465 00000119 2EFF1E[C38A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9466 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9467 00000120 833E[8E01]FF            	cmp	word [SingleCom],-1
  9468 00000125 7505                    	jne	short COMMAND
  9469                                  _$EXITPREP:
  9470 00000127 0E                      	push	cs
  9471 00000128 1F                      	pop	ds
  9472 00000129 E92020                  	jmp	_$EXIT		; Have finished the single command
  9473                                  
  9474                                  ; ---------------------------------------------------------------------------
  9475                                  ;
  9476                                  ; Main entry point from resident portion.
  9477                                  ;
  9478                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9479                                  ;   just beginning the processing of another command.
  9480                                  ;
  9481                                  ; ---------------------------------------------------------------------------
  9482                                  
  9483                                  ; We are not always sure of the state of the world at this time. We presume
  9484                                  ; worst case and initialize the relevant registers: segments and stack.
  9485                                  
  9486                                  COMMAND:
  9487 0000012C FC                      	cld
  9488 0000012D 8CC8                    	mov	ax,cs
  9489 0000012F FA                      	cli
  9490 00000130 8ED0                    	mov	ss,ax
  9491                                  	;mov	sp,offset TRANGROUP:STACK
  9492                                  				; 07/06/2023
  9493 00000132 BC[2395]                	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
  9494                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9495 00000135 FB                      	sti
  9496                                  		
  9497 00000136 8EC0                    	mov	es,ax
  9498                                  		
  9499                                  	; MSDOS 6.0
  9500 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9501                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9502                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9503                                  	; 31/01/2023
  9504 0000013A E8914D                  	call	TSYSLOADMSG
  9505 0000013D C606[BA8D]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9506                                  
  9507                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9508                                  	;mov	ds,[ss:RESSEG]
  9509                                  	; 31/01/2023
  9510 00000142 8E1E[C58A]              	mov	ds,[RESSEG]
  9511 00000146 36C606[A188]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9512 0000014C 36C606[2489]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9513                                  
  9514                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9515                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9516                                  ; I guess not: the only circumstances in which we reload the command processor
  9517                                  ; is after a transient program execution. In this case, we let the current
  9518                                  ; directory lie where it may.
  9519                                  
  9520 00000152 09ED                    	or	bp,bp		; See if just read
  9521 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9522 00000156 36C706[A288]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9523 0000015D EB17                    	jmp	short NOSETBUF
  9524                                  TESTRDIR:
  9525 0000015F 803E[8C01]00            	cmp	byte [RestDir],0
  9526 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9527 00000166 1E                      	push	ds
  9528                                  
  9529                                  ; We have an unusual situation to handle. The user *may* have changed his
  9530                                  ; directory as a result of an internal command that got aborted. Restoring it
  9531                                  ; twice may not help us: the problem may never go away. We just attempt it
  9532                                  ; once and give up.
  9533                                  
  9534 00000167 C606[8C01]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9535                                  
  9536                                  	; Restore users directory
  9537 0000016C 0E                      	push	cs
  9538 0000016D 1F                      	pop	ds
  9539 0000016E BA[A789]                	mov	dx,USERDIR1
  9540 00000171 B43B                    	mov	ah,3Bh
  9541                                  	;mov	ah,CHDir ; 3Bh
  9542 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9543                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9544 00000175 1F                      	pop	ds
  9545                                  NOSETBUF:
  9546 00000176 803E[0102]00            	cmp	byte [PipeFiles],0
  9547 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9548 0000017D 803E[0002]00            	cmp	byte [PipeFlag],0
  9549 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9550 00000184 E8662B                  	call	PIPEDEL
  9551                                  NOPCLOSE:
  9552                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9553                                  	; 31/01/2023
  9554 00000187 C606[8401]00            	mov	byte [ExtCom],0 ; Flag internal command
  9555 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9556 0000018E 8ED8                    	mov	ds,ax
  9557 00000190 50                      	push	ax
  9558                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9559 00000191 BA[2395]                	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
  9560                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9561 00000194 B80038                  	mov	ax,3800h
  9562                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9563 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9564                                  			; get current-country info
  9565                                  			; DS:DX	-> buffer for returned info
  9566 00000199 58                      	pop	ax
  9567 0000019A 2B06[C78A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9568 0000019E 53                      	push	bx
  9569 0000019F BB1000                  	mov	bx,16
  9570 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9571 000001A4 5B                      	pop	bx
  9572 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9573 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9574 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9575                                  SAVSIZ:
  9576                                  
  9577                                  ; AX is the number of bytes free in the buffer between the resident and the
  9578                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9579                                  
  9580 000001AC 3D0002                  	cmp	ax,512
  9581 000001AF 7603                    	jbe	short GOTSIZE
  9582                                  	;and	ax,~1FFh
  9583 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9584                                  GOTSIZE:
  9585 000001B4 A3[E68A]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9586 000001B7 8E1E[C58A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9587                                  
  9588 000001BB F606[8801]01            	test	byte [EchoFlag],1 
  9589 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9590 000001C2 E8072B                  	call	SINGLETEST
  9591 000001C5 7219                    	jb	short GETCOM
  9592 000001C7 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1
  9593 000001CC 7512                    	jnz	short GETCOM
  9594                                  				; G  Don't print prompt in FOR
  9595 000001CE F606[9401]FF            	test	byte [ForFlag],0FFh ; -1
  9596 000001D3 750B                    	jnz	short GETCOM
  9597                                  				; G  Don't print prompt if in batch
  9598 000001D5 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
  9599 000001DB 7503                    	jnz	short GETCOM
  9600 000001DD E8F123                  	call	CRLF2
  9601                                  GETCOM:
  9602 000001E0 C606[9901]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9603 000001E5 C606[9A01]00            	mov	byte [Call_Batch_Flag],0
  9604 000001EA B419                    	mov	ah,19h
  9605                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9606 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9607 000001EE 36A2[D98A]              	mov	[ss:CURDRV],al
  9608 000001F2 F606[0002]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9609 000001F7 7403                    	jz	short NOPIPE
  9610 000001F9 E9BC2B                  	jmp	PIPEPROC	; Continue the pipeline
  9611                                  NOPIPE:
  9612 000001FC F606[8801]01            	test	byte [EchoFlag],1
  9613 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9614 00000203 E8C62A                  	call	SINGLETEST
  9615 00000206 7212                    	jb	short NOPDRV
  9616 00000208 F606[9401]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9617 0000020D 750B                    	jnz	short NOPDRV
  9618 0000020F F706[3401]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9619 00000215 750D                    	jnz	short TESTFORBAT
  9620 00000217 E8791B                  	call	PRINT_PROMPT	; Prompt the user
  9621                                  NOPDRV:
  9622 0000021A F606[9401]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9623 0000021F 7403                    	jz	short TESTFORBAT
  9624 00000221 E9B70B                  	jmp	FORPROC		; Continue the FOR
  9625                                  
  9626                                  TESTFORBAT:
  9627 00000224 36C606[708A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9628 0000022A C606[AF01]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9629 0000022F C606[AE01]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9630 00000234 C606[9301]00            	mov	byte [IfFlag],0	; no more ifs...
  9631 00000239 F706[3401]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9632 0000023F 7441                    	jz	short ISNOBAT
  9633                                  
  9634                                  	; 31/01/2023
  9635                                  
  9636                                  	; MSDOS 6.0
  9637                                  
  9638                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9639                                  
  9640 00000241 06                      	push	es			;AN000; save ES
  9641 00000242 1E                      	push	ds			;AN000; save DS
  9642                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9643                                  	; 05/02/2023
  9644 00000243 B80219                  	mov	ax,1902h
  9645 00000246 8E06[3401]              	mov	es,[Batch]		;AN000; get batch segment
  9646                                  	;mov	di,20h
  9647 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9648 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9649 0000024E 1F                      	pop	ds			;AN000;
  9650                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9651 0000024F BA[2489]                	mov	dx,COMBUF
  9652 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9653                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9654                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9655                                  		; final filename element uppercased
  9656                                  		; DS:DX -> buffer for results
  9657                                  	;cmp	al,0FFh
  9658 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9659 00000256 1F                      	pop	ds			;AN000; restore DS
  9660 00000257 07                      	pop	es			;AN000; restore ES
  9661 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9662                                  
  9663                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9664 0000025A 1E                      	push	ds
  9665 0000025B E81603                  	call	READBAT			; Continue BATCH
  9666 0000025E 1F                      	pop	ds
  9667 0000025F C606[9D01]00            	mov	byte [NullFlag],0	;G reset no command flag
  9668 00000264 F706[3401]FFFF          	test	word [Batch],0FFFFh
  9669 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9670 0000026C 8B1E[9B01]              	mov	bx,[Next_Batch]
  9671                                  	; 31/01/2023
  9672 00000270 09DB                    	or	bx,bx
  9673                                  	;cmp	bx,0			;G see if there is a new batch file
  9674 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9675 00000274 891E[3401]              	mov	[Batch],bx		;G get segment of next batch file
  9676 00000278 C706[9B01]0000          	mov	word [Next_Batch],0	;G reset next batch
  9677                                  JDOCOM1:
  9678 0000027E 0E                      	push	cs
  9679 0000027F 1F                      	pop	ds
  9680 00000280 EB55                    	jmp	short DOCOM1
  9681                                  ISNOBAT:
  9682 00000282 833E[8E01]00            	cmp	word [SingleCom],0
  9683 00000287 741C                    	jz	short REGCOM
  9684                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9685 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9686 0000028C 8736[8E01]              	xchg	si,[SingleCom]
  9687 00000290 BF[2689]                	mov	di,COMBUF+2
  9688 00000293 31C9                    	xor	cx,cx
  9689                                  SINGLELOOP:
  9690 00000295 AC                      	lodsb
  9691 00000296 AA                      	stosb
  9692 00000297 41                      	inc	cx
  9693 00000298 3C0D                    	cmp	al,0Dh
  9694 0000029A 75F9                    	jnz	short SINGLELOOP
  9695 0000029C 49                      	dec	cx
  9696 0000029D 0E                      	push	cs
  9697 0000029E 1F                      	pop	ds
  9698 0000029F 880E[2589]              	mov	[COMBUF+1],cl
  9699                                  
  9700                                  ; do NOT issue a trailing CRLF...
  9701                                  
  9702 000002A3 EB32                    	jmp	short DOCOM1
  9703                                  
  9704                                  	;nop
  9705                                  
  9706                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9707                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9708                                  
  9709                                  ; We have a normal command.  
  9710                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9711                                  ; sometimes they aren't. At this point, we automatically close all spool
  9712                                  ; files and turn on truncation mode.
  9713                                  
  9714                                  REGCOM:
  9715                                  	;mov	ax,(ServerCall shl 8) + 9
  9716                                  	; 31/01/2023
  9717 000002A5 B8095D                  	mov	ax,5D09h
  9718                                  	;mov	ax,(SERVERCALL<<8)+9
  9719 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9720                                  	;mov	ax,(ServerCall shl 8) + 8
  9721 000002AA B8085D                  	mov	ax,5D08h
  9722                                  	;mov	ax,(SERVERCALL<<8)+8
  9723 000002AD B201                    	mov	dl,1
  9724 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9725                                  			; DL = 00h redirected output is	combined
  9726                                  			;      01h redirected output placed in separate	jobs
  9727                                  			; start	new print job now
  9728 000002B1 0E                      	push	cs
  9729 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9730 000002B3 BA[A188]                	mov	dx,UCOMBUF
  9731                                  
  9732                                  	; MSDOS 6.0
  9733                                  ;	Try to read interactive command line via DOSKey.
  9734                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9735                                  
  9736                                  	; 31/01/2023
  9737 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9738 000002B9 CD2F                    	int	2Fh
  9739 000002BB 09C0                    	or	ax,ax
  9740 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9741                                  
  9742 000002BF B40A                    	mov	ah,0Ah
  9743                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9744 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9745                                  			; DS:DX	-> buffer
  9746                                  GOTCOM:
  9747 000002C3 8A0E[A188]              	mov	cl,[UCOMBUF]
  9748 000002C7 30ED                    	xor	ch,ch
  9749 000002C9 83C103                  	add	cx,3
  9750 000002CC BE[A188]                	mov	si,UCOMBUF
  9751 000002CF BF[2489]                	mov	di,COMBUF
  9752 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9753                                  DOCOM:
  9754 000002D4 E8FA22                  	call	CRLF2
  9755                                  DOCOM1:
  9756 000002D7 E87E26                  	call	PRESCAN		; Cook the input buffer
  9757 000002DA 7406                    	jz	short NOPIPEPROC
  9758 000002DC E9582A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9759                                  
  9760                                  NULLCOMJ:
  9761 000002DF E9FA00                  	jmp	NULLCOM
  9762                                  
  9763                                  NOPIPEPROC:
  9764 000002E2 E8502D                  	call	PARSELINE
  9765 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9766                                  BADPARSE:
  9767 000002E7 0E                      	push	cs
  9768 000002E8 1F                      	pop	ds
  9769 000002E9 BA[3E7F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9770 000002EC E8F84A                  	call	std_eprintf
  9771 000002EF E912FE                  	jmp	TCOMMAND
  9772                                  
  9773                                  OKPARSE:
  9774                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9775                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9776                                  	; 01/02/2023
  9777 000002F2 F606[D68D]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9778 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9779                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9780 000002F9 833E[9490]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9781 000002FE 74DF                    	jz	short NULLCOMJ
  9782                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9783 00000300 833E[D98D]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9784 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9785                                  
  9786 00000307 BE[2689]                	mov	si,COMBUF+2
  9787 0000030A BF[4F8B]                	mov	di,IDLEN
  9788                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9789                                  				; Make FCB with blank scan-off
  9790                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9791 0000030D B80129                  	mov	ax,2901h
  9792 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9793                                  			; DS:SI	-> string to parse
  9794                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9795                                  			; AL = bit mask	to control parsing
  9796                                  	;mov	bx,[ARG_ARGV]
  9797 00000312 8B1E[D48D]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9798 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9799 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9800 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9801                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9802                                  	;and	dl,~20h
  9803 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9804                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9805                                  	; 31/01/2023
  9806 00000321 80EA41                  	sub	dl,'A'
  9807 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9808 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9809                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9810 00000328 8B3E[D78D]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9811 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9812 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9813 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9814                                  DRVBADJ:
  9815 00000334 E92325                  	jmp	DRVBAD
  9816                                  DRVGD:
  9817 00000337 8A05                    	mov	al,[di]
  9818 00000339 A2[E58A]                	mov	[SPECDRV],al
  9819 0000033C B020                    	mov	al,' '
  9820 0000033E B90900                  	mov	cx,9
  9821 00000341 47                      	inc	di
  9822 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9823 00000344 B008                    	mov	al,8
  9824 00000346 28C8                    	sub	al,cl
  9825 00000348 A2[4F8B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9826 0000034B BF8100                  	mov	di,81h
  9827 0000034E 56                      	push	si
  9828 0000034F BE[2689]                	mov	si,COMBUF+2	; Skip over all leading delims
  9829 00000352 E88922                  	call	scanoff
  9830                                  
  9831                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9832                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9833                                  
  9834                                  	; MSDOS 6.0
  9835                                  ;SR;
  9836                                  ; We are going to skip over the first char always. The logic is that the
  9837                                  ;command tail can never start from the first character. The code below is 
  9838                                  ;trying to figure out the command tail and copy it to the command line 
  9839                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9840                                  ;character and the user given command line is a full 128 bytes, we try to
  9841                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9842                                  ;char overwrites the code and leads to a crash on future commands.
  9843                                  
  9844 00000355 46                      	inc	si ;  MSDOS 6.0
  9845                                  DO_SKIPCOM:
  9846 00000356 AC                      	lodsb			; move command line pointer over
  9847 00000357 E88C22                  	call	DELIM		; pathname -- have to do it ourselves
  9848 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9849 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9850 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9851 00000360 3A06[C98A]              	cmp	al,[SWITCHAR]	; specified command string
  9852 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9853                                  DO_SKIPPED:
  9854 00000366 4E                      	dec	si
  9855 00000367 31C9                    	xor	cx,cx
  9856                                  COMTAIL:
  9857 00000369 AC                      	lodsb
  9858 0000036A AA                      	stosb			; Move command tail to 80h
  9859 0000036B 3C0D                    	cmp	al,0Dh
  9860 0000036D E0FA                    	loopne	COMTAIL
  9861 0000036F 4F                      	dec	di
  9862 00000370 89FD                    	mov	bp,di
  9863 00000372 F6D1                    	not	cl
  9864 00000374 880E8000                	mov	[80h],cl
  9865 00000378 5E                      	pop	si
  9866                                  ;-----
  9867                                  ; Some of these comments are sadly at odds with this brave new code.
  9868                                  ;-----
  9869                                  ; If the command has 0 parameters must check here for
  9870                                  ; any switches that might be present.
  9871                                  ; SI -> first character after the command.
  9872                                  
  9873                                  	;mov	di,arg.argv[0].argsw_word
  9874                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9875 00000379 8B3E[DB8D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9876 0000037D 893E[DC8A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9877                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9878                                  				; s = argv[1];
  9879                                  	;mov	si,[ARGV1_ARGPOINTER]
  9880 00000381 8B36[DF8D]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9881 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9882 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9883 00000389 89EE                    	mov	si,bp
  9884                                  DOPARSE:
  9885 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9886                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9887                                  	; 01/02/2023
  9888 0000038E B80129                  	mov	ax,2901h
  9889                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9890 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9891                                  			; DS:SI	-> string to parse
  9892                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9893                                  			; AL = bit mask	to control parsing
  9894 00000393 A2[DA8A]                	mov	[PARM1],al	; Save result of parse
  9895                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9896                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9897 00000396 8B3E[E68D]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9898 0000039A 893E[DE8A]              	mov	[ARG1S],di
  9899                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9900                                  				; s = argv[2];
  9901                                  	;mov	si,[ARGV2_ARGPOINTER]
  9902 0000039E 8B36[EA8D]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9903 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9904 000003A4 7502                    	jnz	short DOPARSE2
  9905 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9906                                  DOPARSE2:			
  9907 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9908                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9909 000003AB B80129                  	mov	ax,2901h
  9910                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9911 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9912                                  			; DS:SI	-> string to parse
  9913                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9914                                  			; AL = bit mask	to control parsing
  9915 000003B0 A2[DB8A]                	mov	[PARM2],al	; Save result
  9916                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9917                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9918 000003B3 8B3E[F18D]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9919 000003B7 893E[E08A]              	mov	[ARG2S],di
  9920                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9921                                  	;mov	di,arg.argv[0].argsw_word
  9922 000003BB 8B3E[DB8D]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9923 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9924                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9925                                  	;and	di,arg.argswinfo	
  9926 000003C1 233E[9690]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9927 000003C5 893E[E28A]              	mov	[ARGTS],di
  9928                                  
  9929 000003C9 A0[4F8B]                	mov	al,[IDLEN]
  9930 000003CC 8A16[E58A]              	mov	dl,[SPECDRV]
  9931 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9932 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9933 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9934 000003D6 E9D423                  	jmp	FNDCOM		; otherwise, check internal com table
  9935                                  EXTERNALJ1:
  9936 000003D9 E9D624                  	jmp	EXTERNAL
  9937                                  NULLCOM:
  9938 000003DC 8E1E[C58A]              	mov	ds,[RESSEG]
  9939 000003E0 F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9940 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9941 000003E8 C606[9D01]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9942                                  	;mov	byte [NullFlag],nullcommand ; 1
  9943                                  NOSETFLAG:
  9944 000003ED 833E[8E01]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9945 000003F2 7403                    	je	short EXITJ
  9946 000003F4 E9E9FD                  	jmp	GETCOM
  9947                                  EXITJ:
  9948 000003F7 E92DFD                  	jmp	_$EXITPREP
  9949                                  
  9950                                  ;============================================================================
  9951                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9952                                  ;============================================================================
  9953                                  ; 12/10/2018 - Retro DOS v3.0
  9954                                  
  9955                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9956                                  
  9957                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9958                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9959                                  ;   there is a header that describes a block of rom program.  This header
  9960                                  ;   contains information needed to initialize a module and to provide PCDOS
  9961                                  ;   with a set of reserved names for execution.
  9962                                  ;
  9963                                  ;   This header has the following format:
  9964                                  ;
  9965                                  ;   rom_header	STRUC
  9966                                  ;	Signature1  DB	55h
  9967                                  ;	Signature2  DB	AAh
  9968                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9969                                  ;	init_jmp    DB	3 dup (?)
  9970                                  ;	name_list   name_struc <>
  9971                                  ;   rom_header	ENDS
  9972                                  ;
  9973                                  ;   name_struc	STRUC
  9974                                  ;	name_len    DB	?
  9975                                  ;	name_text   DB	? DUP (?)
  9976                                  ;	name_jmp    DB	3 DUP (?)
  9977                                  ;   name_struc	ENDS
  9978                                  ;
  9979                                  ;   The name list is a list of names that are reserved by a particular section
  9980                                  ;   of a module.  This list of names is terminated by a null name (length
  9981                                  ;   is zero).
  9982                                  ;
  9983                                  ;   Consider now, the PCDOS action when a user enters a command:
  9984                                  ;
  9985                                  ;	COMMAND.COM has control.
  9986                                  ;	o   If location FFFFEh has FDh then
  9987                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  9988                                  ;		    by AAh, stop scan if we get above or = F0000H
  9989                                  ;	o	When we've found one, compare the name entered by the user
  9990                                  ;		    with the one found in the rom.  If we have a match, then
  9991                                  ;		    set up the environment for execution and do a long jump
  9992                                  ;		    to the near jump after the found name.
  9993                                  ;	o	If no more names in the list, then continue scanning the module
  9994                                  ;		    for more 55h followed by AAh.
  9995                                  ;	o   We get to this point only if there is no matching name in the
  9996                                  ;		rom.  We now look on disk for the command.
  9997                                  ;
  9998                                  ;   This gives us the flexibility to execute any rom cartridge without having
  9999                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10000                                  ;   want to be invisible to the DOS should not have any names in their lists
 10001                                  ;   (i.e. they have a single null name).
 10002                                  ;
 10003                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10004                                  ;   Clearly this version will be available on disk.  How does a user actually
 10005                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10006                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10007                                  ;   solution:
 10008                                  ;
 10009                                  ;   o	Keep things consistent and force the user to have his software named
 10010                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10011                                  
 10012                                  struc ROM_HEADER
 10013 00000000 ??                          .signature1: resb 1
 10014 00000001 ??                          .signature2: resb 1
 10015 00000002 ??                          .rom_length: resb 1
 10016 00000003 ??????                      .init_jmp:	 resb 3
 10017 00000006 ??                          .name_list:	 resb 1
 10018                                      .size:
 10019                                  endstruc
 10020                                  
 10021                                  struc NAME_STRUC
 10022 00000000 ??                          .name_len:	resb 1
 10023 00000001 ??                          .name_text:	resb 1
 10024 00000002 ??????                      .name_jmp:	resb 3
 10025                                      .size:	
 10026                                  endstruc
 10027                                  
 10028                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10029                                  
 10030                                  ; =============== S U B	R O U T	I N E =======================================
 10031                                  
 10032                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10033                                  
 10034                                  ; 05/02/2023
 10035                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10036                                  
 10037                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10038                                  
 10039                                  ROM_SCAN:
 10040 000003FA 06                      	push	es
 10041 000003FB 56                      	push	si
 10042 000003FC 57                      	push	di
 10043 000003FD 51                      	push	cx
 10044 000003FE 50                      	push	ax
 10045 000003FF 53                      	push	bx
 10046                                  
 10047                                  	; check for PC Jr signature in rom
 10048                                  
 10049 00000400 B800F0                  	mov	ax,0F000h
 10050 00000403 8EC0                    	mov	es,ax
 10051 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10052 0000040B 7408                    	je	short SCAN_IT
 10053                                  NO_ROM:
 10054 0000040D F8                      	clc
 10055                                  ROM_RET:
 10056 0000040E 5B                      	pop	bx
 10057 0000040F 58                      	pop	ax
 10058 00000410 59                      	pop	cx
 10059 00000411 5F                      	pop	di
 10060 00000412 5E                      	pop	si
 10061 00000413 07                      	pop	es
 10062 00000414 C3                      	retn
 10063                                  
 10064                                  	; start scanning at C000h
 10065                                  SCAN_IT:
 10066 00000415 B800C0                  	mov	ax,0C000h
 10067                                  SCAN_ONE:
 10068 00000418 8EC0                    	mov	es,ax
 10069 0000041A 31FF                    	xor	di,di
 10070                                  
 10071                                  	; check for a valid header
 10072                                  SCAN_MODULE:
 10073 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
 10074 00000421 740A                    	je	short SCAN_LIST
 10075 00000423 058000                  	add	ax,80h
 10076                                  SCAN_END:
 10077 00000426 3D00F0                  	cmp	ax,0F000h
 10078 00000429 72ED                    	jb	short SCAN_ONE
 10079 0000042B EBE0                    	jmp	short NO_ROM
 10080                                  
 10081                                  	; trundle down list of names
 10082                                  SCAN_LIST:
 10083                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10084 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10085 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
 10086 00000433 D1E3                    	shl	bx,1
 10087 00000435 D1E3                    	shl	bx,1		; number of paragraphs
 10088 00000437 83C37F                  	add	bx,7Fh
 10089 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
 10090                                  	;mov	di,6
 10091                                  	; 05/05/2023
 10092 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
 10093                                  	;nop
 10094                                  SCAN_NAME:
 10095 00000440 268A0D                  	mov	cl,[es:di]	; length of name
 10096 00000443 47                      	inc	di		; point to name
 10097 00000444 30ED                    	xor	ch,ch
 10098 00000446 09C9                    	or	cx,cx		; zero length name
 10099 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
 10100 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
 10101 0000044C EBD8                    	jmp	short SCAN_END
 10102                                  
 10103                                  	; compare a single name
 10104                                  SCAN_TEST:
 10105 0000044E 89D6                    	mov	si,dx
 10106 00000450 46                      	inc	si
 10107 00000451 F3A6                    	repe cmpsb		 ; compare name
 10108 00000453 7407                    	jz	short SCAN_FOUND ; success!
 10109                                  SCAN_NEXT:
 10110 00000455 01CF                    	add	di,cx		; failure, next name piece
 10111 00000457 83C703                  	add	di,3
 10112 0000045A EBE4                    	jmp	short SCAN_NAME
 10113                                  
 10114                                  	; found a name. save entry location
 10115                                  SCAN_FOUND:	
 10116 0000045C 803C3F                  	cmp	byte [si],'?'
 10117 0000045F 7405                    	je	short SCAN_SAVE
 10118 00000461 803C20                  	cmp	byte [si],' '
 10119 00000464 75EF                    	jne	short SCAN_NEXT
 10120                                  SCAN_SAVE:
 10121 00000466 2E8C06[4A8C]            	mov	[cs:ROM_CS],es
 10122 0000046B 2E893E[488C]            	mov	[cs:ROM_IP],di
 10123 00000470 F9                      	stc
 10124 00000471 EB9B                    	jmp	short ROM_RET
 10125                                  
 10126                                  ; ---------------------------------------------------------------------------
 10127                                  
 10128                                  ; execute a rom-placed body of code. allocate largest block
 10129                                  
 10130                                  ROM_EXEC:
 10131 00000473 BBFFFF                  	mov	bx,0FFFFh
 10132                                  	; 05/02/2023
 10133 00000476 B448                    	mov	ah,48h
 10134                                  	;mov	ah,ALLOC ; 48h
 10135 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10136                                  			; BX = number of 16-byte paragraphs desired
 10137 0000047A B448                    	mov	ah,48h
 10138                                  	;mov	ah,ALLOC ; 48h
 10139 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10140                                  			; BX = number of 16-byte paragraphs desired
 10141 0000047E 53                      	push	bx
 10142 0000047F 50                      	push	ax
 10143                                  
 10144                                  	; set terminate addresses
 10145                                  
 10146 00000480 B82225                  	mov	ax,2522h
 10147                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10148                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10149 00000483 1E                      	push	ds
 10150 00000484 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
 10151                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10152                                  	;mov	dx,131h ; MSDOS 3.3
 10153                                  	; 05/02/2023
 10154                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10155 00000489 BA[290C]                	mov	dx,Exec_Wait
 10156 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10157                                  			; AL = interrupt number
 10158                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10159 0000048E 8CDA                    	mov	dx,ds
 10160 00000490 8EC2                    	mov	es,dx
 10161 00000492 1F                      	pop	ds
 10162                                  		
 10163                                  	; and create program header and dup all jfn's
 10164                                  
 10165 00000493 5A                      	pop	dx
 10166 00000494 B455                    	mov	ah,55h
 10167                                  	;mov	ah,DUP_PDB ; 55h
 10168 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10169                                  			; DX = segment number at which to set up PSP
 10170                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10171                                  		
 10172                                  	; set up dma address
 10173                                  
 10174 00000498 8EDA                    	mov	ds,dx
 10175 0000049A BA8000                  	mov	dx,80h
 10176 0000049D B41A                    	mov	ah,1Ah
 10177                                  	;mov	ah,Set_DMA ; 1Ah
 10178 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10179                                  			; DS:DX	-> disk	transfer buffer
 10180                                  
 10181                                  	; copy in environment info
 10182                                  
 10183 000004A1 26A1[2703]              	mov	ax,[es:EnvirSeg]
 10184                                  	;mov	[2Ch],ax
 10185 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10186                                  
 10187                                  	; set up correct size of block
 10188                                  
 10189 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10190 000004A9 8CDA                    	mov	dx,ds
 10191 000004AB 01DA                    	add	dx,bx
 10192                                  	;mov	[2],dx
 10193 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10194                                  
 10195                                  	; change ownership of block
 10196                                  
 10197 000004B1 8CDA                    	mov	dx,ds
 10198 000004B3 4A                      	dec	dx
 10199 000004B4 8EDA                    	mov	ds,dx
 10200 000004B6 42                      	inc	dx	
 10201                                  	;mov	[1],dx
 10202 000004B7 89160100                	mov	[ARENA.owner],dx
 10203 000004BB 8EDA                    	mov	ds,dx
 10204                                  
 10205                                  	; set up correct stack
 10206                                  
 10207 000004BD 81FB0010                	cmp	bx,1000h
 10208 000004C1 7202                    	jb	short GOT_STACK
 10209 000004C3 31DB                    	xor	bx,bx
 10210                                  GOT_STACK:
 10211 000004C5 B104                    	mov	cl,4
 10212 000004C7 D3E3                    	shl	bx,cl
 10213 000004C9 8CDA                    	mov	dx,ds
 10214 000004CB 8ED2                    	mov	ss,dx
 10215 000004CD 89DC                    	mov	sp,bx
 10216 000004CF 31C0                    	xor	ax,ax
 10217 000004D1 50                      	push	ax
 10218                                  
 10219                                  	; set up initial registers and go to the guy
 10220                                  
 10221 000004D2 F7D0                    	not	ax
 10222 000004D4 2EFF36[4A8C]            	push	word [cs:ROM_CS]
 10223 000004D9 2EFF36[488C]            	push	word [cs:ROM_IP]
 10224 000004DE 8EC2                    	mov	es,dx
 10225 000004E0 CB                      	retf	; far return
 10226                                  
 10227                                  ;============================================================================
 10228                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10229                                  ;============================================================================
 10230                                  ; 12/10/2018 - Retro DOS v3.0
 10231                                  
 10232                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10233                                  
 10234                                  ; =============== S U B	R O U T	I N E =======================================
 10235                                  
 10236                                  ;Break	<PromptBat - Open or wait for batch file>
 10237                                  
 10238                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10239                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10240                                  
 10241                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10242                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10243                                  ; file. Leave segment registers alone.
 10244                                  
 10245                                  PROMPTBAT:
 10246 000004E1 E84808                  	call	BATOPEN
 10247 000004E4 7201                    	jc	short PROMPTBAT1
 10248 000004E6 C3                      	retn
 10249                                  PROMPTBAT1:
 10250                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10251                                  	; MSDOS 6.0 COMMAND.COM
 10252 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10253 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10254 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10255 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10256                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10257 000004F1 E83500                  	call	output_batch_name
 10258 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10259                                  
 10260                                  	; 05/02/2023
 10261                                  	; MSDOS 3.3 COMMAND.COM
 10262                                  	;cmp	dx,ACCDENPTR
 10263                                  	;jz	short BATDIE
 10264                                  
 10265                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10266                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10267 000004F6 2EFF1E[CF8A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10268 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10269                                  
 10270                                  ; The media is not changeable. Turn everything off.
 10271                                  
 10272 000004FD E83D0B                  	call	FOROFF
 10273 00000500 E8652A                  	call	PipeOff
 10274 00000503 A2[9301]                	mov	[IfFlag],al	; No If in progress.	
 10275 00000506 BA[387F]                	mov	dx,BADBAT_PTR
 10276                                  BATDIE:
 10277 00000509 E8F003                  	call	BATCHOFF
 10278 0000050C 0E                      	push	cs
 10279 0000050D 1F                      	pop	ds
 10280                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10281                                  	; 05/02/2023
 10282 0000050E E8D648                  	call	std_eprintf	; MSDOS 6.0
 10283                                  	;call	STD_PRINTF	; MSDOS 3.3
 10284                                  
 10285                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10286                                  
 10287 00000511 E9F0FB                  	jmp	TCOMMAND
 10288                                  
 10289                                  ; Ask the user to reinsert the batch file
 10290                                  
 10291                                  ASKFORBAT:
 10292 00000514 1E                      	push	ds
 10293 00000515 0E                      	push	cs
 10294 00000516 1F                      	pop	ds
 10295                                  
 10296                                  	; MSDOS 6.0
 10297                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10298 00000517 BA[3B7F]                	mov	dx,NEEDBAT_PTR
 10299                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10300                                  	; 05/02/2023
 10301 0000051A E8CA48                  	call	std_eprintf
 10302                                  	;mov	dx,offset trangroup:pausemes_ptr
 10303 0000051D BA[AD7F]                	mov	dx,PAUSEMES_PTR
 10304                                  	;invoke std_eprintf		;AN000; get second part of message
 10305 00000520 E8C448                  	call	std_eprintf
 10306                                  					;AN000; print it to stderr
 10307                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10308                                  	;call	STD_EPRINTF
 10309 00000523 E82E00                  	call	GETKEYSTROKE
 10310 00000526 1F                      	pop	ds
 10311 00000527 EBB8                    	jmp	short PROMPTBAT
 10312                                  
 10313                                  
 10314                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10315                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10316                                  
 10317                                  	; MSDOS 6.0
 10318                                  ;****************************************************************
 10319                                  ;*
 10320                                  ;* ROUTINE:	Output_batch_name
 10321                                  ;*
 10322                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10323                                  ;*
 10324                                  ;* INPUT:	DX - extended error number
 10325                                  ;*
 10326                                  ;* OUTPUT:	Ready to call print routine
 10327                                  ;*
 10328                                  ;****************************************************************
 10329                                  ;
 10330                                  ;public	output_batch_name		;AN022;
 10331                                  
 10332                                  output_batch_name:	;proc near	;AN022;
 10333                                  
 10334 00000529 1E                      	push	ds			;AN022; save resident segment
 10335 0000052A 8E1E[3401]              	mov	ds,[Batch]		;AN022; get batch file segment
 10336                                  	;assume	DS:nothing		;AN022;
 10337                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10338                                  	; 05/02/2023
 10339                                  	;mov	si,20h
 10340                                  	; 24/04/2023
 10341 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10342                                  	;invoke	dstrlen 		;AN022; get length of string
 10343 00000531 E83827                  	call	dstrlen
 10344                                  	;mov	di,offset Trangroup:bwdbuf
 10345                                  					;AN022; target for batch name
 10346 00000534 BF[CE8B]                	mov	di,BWDBUF
 10347 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10348                                  
 10349 00000539 0E                      	push	cs			;AN022; get local segment
 10350 0000053A 1F                      	pop	ds			;AN022;
 10351                                  	;assume	DS:trangroup		;AN022;
 10352                                  	; 05/02/2023
 10353 0000053B 8916[1B7F]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10354                                  	;mov	byte [msg_disp_class],1
 10355 0000053F C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 10356                                  					;AN022; set up extended error msg class
 10357                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10358 00000544 BA[1B7F]                	mov	dx,extend_buf_ptr	
 10359                                  					;AN022; get extended message pointer
 10360                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10361 00000547 C706[358C][CE8B]        	mov	word [string_ptr_2],BWDBUF	
 10362                                  					;AN022; point to substitution
 10363                                  	;mov	byte [extend_buf_sub],1
 10364 0000054D C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 10365                                  					;AN022; set up for one subst
 10366 00000552 1F                      	pop	ds			;AN022; restore data segment
 10367 00000553 C3                      	retn				;AN022; return
 10368                                  
 10369                                  ;output_batch_name    endp		;AN022;
 10370                                  
 10371                                  
 10372                                  ; =============== S U B	R O U T	I N E =======================================
 10373                                  
 10374                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10375                                  
 10376                                  ; Read the next keystroke. Since there may be several characters in the queue
 10377                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10378                                  ; AFTER waiting.
 10379                                  
 10380                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10381                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10382                                  
 10383                                  GETKEYSTROKE:
 10384                                  	; 05/02/2023
 10385                                  	; MSDOS 3.3
 10386                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10387                                  	;;mov	ax,0C08h
 10388                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10389                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10390                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10391                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10392                                  	;;mov	ax,0C00h
 10393                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10394                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10395                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10396                                  	;retn
 10397                                  
 10398                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10399                                  	; MSDOS 6.0
 10400 00000554 52                      	push	dx			;AN000;  3/3/KK
 10401                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10402                                  					;AN000;  3/3/KK
 10403 00000555 B80263                  	mov	ax,6302h
 10404 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10405                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10406                                  	
 10407 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10408                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10409                                  					;AN000;  3/3/KK
 10410 0000055B B80163                  	mov	ax,6301h
 10411 0000055E B201                    	mov	dl,1
 10412                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10413 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10414                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10415                                  		; DL = new mode
 10416                                  		; 00h return only full characters on DOS keyboard input functions
 10417                                  		; 01h return partially-formed characters also
 10418                                  	
 10419                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10420 00000562 B8080C                  	mov	ax,0C08h
 10421 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10422                                  		; DOS - CLEAR KEYBOARD BUFFER
 10423                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10424                                  
 10425                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10426 00000567 B8000C                  	mov	ax,0C00h
 10427 0000056A CD21                    	int	21h
 10428                                  		; DOS - CLEAR KEYBOARD BUFFER
 10429                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10430                                  
 10431                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10432                                  					;AN000;  3/3/KK
 10433 0000056C B80163                  	mov	ax,6301h
 10434 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10435 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10436 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10437                                  	
 10438 00000573 C3                      	retn
 10439                                  
 10440                                  ; =============== S U B	R O U T	I N E =======================================
 10441                                  
 10442                                  ; Break	<ReadBat - read 1 line from batch file>
 10443                                  
 10444                                  ; ReadBat - read a single line from the batch file. 
 10445                                  ; Perform all substitutions as appropriate.
 10446                                  
 10447                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10448                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10449                                  
 10450                                  READBAT:
 10451                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10452                                  		
 10453                                  	;mov	byte [Suppress],1
 10454                                  				; initialize line suppress status
 10455 00000574 C606[8901]01            	mov	byte [Suppress],YES_ECHO
 10456 00000579 F606[7E01]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10457 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10458 00000580 C606[7D01]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10459                                  
 10460                                  	; MSDOS 6.0
 10461                                  
 10462                                  ;M037; Start of changes
 10463                                  ; We check here if we have set the flag indicating that the batchfile is at
 10464                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10465                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10466                                  ;batch file gets closed etc. and then return as if everything is done.
 10467                                  
 10468                                  	; 05/02/2023
 10469 00000585 1E                      	push	ds
 10470 00000586 8E1E[3401]              	mov	ds,[Batch]
 10471                                  	;cmp	byte [2],0
 10472 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10473                                  				; are we at EOF in batchfile
 10474 0000058F 1F                      	pop	ds
 10475 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10476                                  	;invoke	GetBatByt	; frees up batchseg
 10477 00000592 E8D303                  	call	GETBATBYT
 10478 00000595 26A2[2689]              	mov	[es:COMBUF+2],al
 10479                                  				; stuff CR into command buffer
 10480                                  				; as a dummy command
 10481                                  	;;invoke CrLf2		; print a CR-LF
 10482                                  	;call	CRLF2
 10483                                  	;;return		; done batch processing
 10484                                  	;retn
 10485                                  	; 24/04/2023
 10486 00000599 E93520                  	jmp	CRLF2
 10487                                  
 10488                                  ;M037; End of changes
 10489                                  		
 10490                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10491                                  CONTBAT:
 10492 0000059C E842FF                  	call	PROMPTBAT
 10493                                  
 10494                                  TRYING_TO_ABORT:
 10495 0000059F BF[2689]                	mov	di,COMBUF+2
 10496                                  
 10497                                  ; Save position and try to scan for first non delimiter.
 10498                                  
 10499                                  TESTNOP:
 10500 000005A2 8CD8                    	mov	ax,ds
 10501 000005A4 8E1E[3401]              	mov	ds,[Batch]
 10502 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10503 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10504                                  				; save current location.
 10505 000005B0 8ED8                    	mov	ds,ax
 10506 000005B2 E84B06                  	call	SKIPDELIM	; skip to first non-delim
 10507                                  
 10508                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10509                                  ; beginning and read the line.
 10510                                  
 10511 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10512 000005B7 59                      	pop	cx
 10513 000005B8 5A                      	pop	dx		; restore position in bat file
 10514 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10515 000005BB F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10516 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10517                                  
 10518                                  	;cmp	al,'@'
 10519 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10520 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10521                                  	;mov	byte [Suppress],0
 10522 000005C7 C606[8901]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10523 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10524                                  	;nop
 10525                                  SET_BAT_POS:
 10526 000005CE 1E                      	push	ds
 10527 000005CF 8E1E[3401]              	mov	ds,[Batch]
 10528                                  	;mov	[8],dx
 10529 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10530                                  	;mov	[10],cx
 10531 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10532 000005DB 1F                      	pop	ds
 10533                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10534                                  	; 05/02/2023
 10535 000005DC B80042                  	mov	ax,4200h
 10536                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10537 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10538                                  			; AL = method: offset from beginning of	file
 10539                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10540                                  	; 24/04/2023
 10541                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10542 000005E1 26C706[4C95]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10543                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10544 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10545 000005EA EB0F                    	jmp	short RDBAT
 10546                                  
 10547                                  	;nop
 10548                                  
 10549                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10550                                  ; We eat characters until a CR is seen.
 10551                                  
 10552                                  NOPLINE:
 10553 000005EC E80501                  	call	SKIPTOEOL
 10554 000005EF E87603                  	call	GETBATBYT	; eat trailing LF
 10555                                  	;test	word [Batch],0FFFFh
 10556 000005F2 F706[3401]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10557 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10558                                  READBAT_RETN:			; Hit EOF
 10559 000005FA C3                      	retn
 10560                                  
 10561                                  ; ---------------------------------------------------------------------------
 10562                                  
 10563                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10564                                  ; input, we are to consider two special cases:
 10565                                  ;
 10566                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10567                                  ;   %sym%	This is a symbol from the environment
 10568                                  
 10569                                  RDBAT:
 10570 000005FB E86A03                  	call	GETBATBYT
 10571 000005FE 41                      	inc	cx		; Inc the line length
 10572                                  
 10573                                  	; 05/02/2023
 10574                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10575 000005FF E8BD1D                  	call	testkanj
 10576 00000602 740C                    	jz	short RDBAT1
 10577                                  	;cmp	cx,127
 10578 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10579 00000607 7350                    	jnb	short TOOLONG
 10580 00000609 AA                      	stosb
 10581 0000060A E85B03                  	call    GETBATBYT
 10582 0000060D 41                      	inc	cx
 10583 0000060E EB0A                    	jmp	short SAVBATBYT
 10584                                  RDBAT1:
 10585 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10586 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10587                                  
 10588                                  ; See if we have a parameter character.
 10589                                  
 10590 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10591 00000618 7449                    	je	short NEEDPARM
 10592                                  
 10593                                  ; no parameter character. Store it as usual and see if we are done.
 10594                                  
 10595                                  SAVBATBYT:
 10596 0000061A AA                      	stosb			; End of line found?
 10597 0000061B 3C0D                    	cmp	al,0Dh
 10598 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10599                                  
 10600                                  ; We have read in an entire line. 
 10601                                  ; Decide whether we should echo the command line or not.
 10602                                  
 10603                                  FOUND_EOL:
 10604 0000061F 81EF[2789]              	sub	di,COMBUF+3
 10605 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10606 00000625 26A2[2589]              	mov	[es:COMBUF+1],al
 10607                                  				; Set length of line
 10608 00000629 E83C03                  	call	GETBATBYT	; Eat linefeed
 10609 0000062C E8E906                  	call	BATCLOSE
 10610 0000062F 803E[8901]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10611 00000634 7407                    	jz	short RESET
 10612 00000636 F606[8801]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10613 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10614                                  RESET:
 10615 0000063D 0E                      	push	cs
 10616 0000063E 1F                      	pop	ds		; Go back to local segment
 10617 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10618                                  TRY_NEXTFLAG:
 10619 00000641 803E[9D01]01            	cmp	byte [NullFlag],nullcommand ; 1
 10620                                  				;G was there a command last time?
 10621 00000646 7403                    	jz	short NO_CRLF_PRINT
 10622                                  				;G no - don't print crlf
 10623 00000648 E8861F                  	call	CRLF2		;G Print out prompt
 10624                                  NO_CRLF_PRINT:
 10625 0000064B E84517                  	call	PRINT_PROMPT
 10626 0000064E 0E                      	push	cs		;G change data segment
 10627 0000064F 1F                      	pop	ds
 10628 00000650 BA[2689]                	mov	dx,COMBUF+2	; get command line for echoing
 10629 00000653 E8D41F                  	call	CRPRINT
 10630                                  	;call	CRLF2
 10631                                  	;retn
 10632                                  	; 06/02/2023
 10633 00000656 E9781F                  	jmp	CRLF2
 10634                                  
 10635                                  ; The line was too long. Eat remainder of input text up until the CR
 10636                                  
 10637                                  TOOLONG:
 10638 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10639 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10640 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10641                                  LTLCONT:
 10642 00000660 AA                      	stosb			; Terminate the command
 10643 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10644                                  
 10645                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10646                                  
 10647                                  NEEDPARM:
 10648 00000663 E80203                  	call	GETBATBYT	; get next character
 10649 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10650 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10651 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10652 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10653                                  
 10654                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10655                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10656                                  ; see if the <something> has a terminating % and then look up the contents
 10657                                  ; in the environment.
 10658                                  
 10659                                  PAROK:
 10660 0000066E 2C30                    	sub	al,'0'
 10661 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10662 00000672 3C09                    	cmp	al,9
 10663 00000674 7735                    	ja	short NEEDENV
 10664                                  
 10665                                  ; We have found %<number>. This is taken from the parameters in the
 10666                                  ; allocated batch area.
 10667                                  
 10668 00000676 98                      	cbw
 10669 00000677 89C3                    	mov	bx,ax		; move index into AX
 10670 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10671 0000067B 06                      	push	es
 10672 0000067C 8E06[3401]              	mov	es,[Batch]
 10673                                  
 10674                                  ; The structure of the batch area is:
 10675                                  ;
 10676                                  ;   BYTE    type of segment
 10677                                  ;   DWORD   offset for next line
 10678                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10679                                  ;   ASCIZ   file name (with . and ..)
 10680                                  ;   BYTES   CR-terminated parameters
 10681                                  ;   BYTE    0 flag to indicate end of parameters
 10682                                  ;
 10683                                  ; Get pointer to BX'th argument
 10684                                  
 10685                                  	;;mov	si,[es:bx+0Bh]
 10686                                  	; 05/02/2023
 10687                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10688 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10689 00000684 07                      	pop	es
 10690                                  
 10691                                  ; Is there a parameter here?
 10692                                  
 10693 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10694 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10695 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10696                                  
 10697                                  ; Copy in the found parameter from batch segment
 10698                                  
 10699                                  YES_THERE_IS:
 10700 0000068D 1E                      	push	ds
 10701 0000068E 8E1E[3401]              	mov	ds,[Batch]
 10702 00000692 49                      	dec	cx		; Don't count '%' in line length
 10703                                  COPYPARM:
 10704 00000693 AC                      	lodsb			; From resident segment
 10705 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10706 00000696 740F                    	je	short ENDPARAM
 10707 00000698 41                      	inc	cx		; Inc the line length
 10708 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10709 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10710 0000069F AA                      	stosb
 10711 000006A0 EBF1                    	jmp	short COPYPARM
 10712                                  
 10713                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10714                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10715                                  ; believing that we are at EOL. Clobber AL too.
 10716                                  
 10717                                  LINETOOL:
 10718 000006A2 30C0                    	xor	al,al
 10719 000006A4 1F                      	pop	ds
 10720 000006A5 EBB2                    	jmp	short TOOLONG
 10721                                  
 10722                                  ; We have copied in an entire parameter. Go back for more
 10723                                  
 10724                                  ENDPARAM:
 10725 000006A7 1F                      	pop	ds
 10726 000006A8 E950FF                  	jmp	RDBAT
 10727                                  
 10728                                  ; We have found % followed by something other than 0-9. We presume that there
 10729                                  ; will be a following % character. In between is an environment variable that
 10730                                  ; we will fetch and replace in the batch line with its value.
 10731                                  
 10732                                  NEEDENV:
 10733                                  	; MSDOS 6.0 COMMAND.COM
 10734                                  	; 05/02/2023 
 10735 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10736                                  
 10737                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10738 000006AC 1E                      	push	ds
 10739 000006AD 57                      	push	di
 10740                                  				; temp spot for name
 10741 000006AE BF[508B]                	mov	di,ID
 10742 000006B1 0430                    	add	al,'0'		; reconvert character
 10743 000006B3 AA                      	stosb			; store it in appropriate place
 10744                                  
 10745                                  ; loop getting characters until the next % is found or until EOL
 10746                                  
 10747                                  GETENV1:
 10748 000006B4 E8B102                  	call	GETBATBYT	; get the byte
 10749 000006B7 AA                      	stosb			; store it
 10750 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10751 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10752                                  
 10753                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10754                                  
 10755 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10756 000006C1 BE[508B]                	mov	si,ID 		; point to buffer
 10757 000006C4 5F                      	pop	di		; point to line buffer
 10758 000006C5 0E                      	push	cs
 10759 000006C6 1F                      	pop	ds
 10760 000006C7 E88B02                  	call	STRCPY
 10761                                  	; 05/02/2023
 10762 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10763                                  	; 24/04/2023
 10764                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10765 000006CC 1F                      	pop	ds
 10766 000006CD E94AFF                  	jmp	SAVBATBYT
 10767                                  GETENV15:
 10768 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10769 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10770                                  
 10771                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10772                                  ; This was the source of bug #1.
 10773                                  ;	dec	cx		;AN070; Don't count "%"
 10774                                  
 10775 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10776 000006D6 268845FF                	mov	[es:di-1],al
 10777                                  
 10778                                  ; ID now either has a =-terminated string which we are to find in the
 10779                                  ; environment or a non =-terminated string which will not be found in the
 10780                                  ; environment.
 10781                                  
 10782                                  GETENV2:
 10783 000006DA BE[508B]                	mov	si,ID
 10784 000006DD 0E                      	push	cs
 10785 000006DE 1F                      	pop	ds		; DS:SI points to name
 10786 000006DF 51                      	push	cx
 10787 000006E0 E8321C                  	call	find_name_in_environment
 10788 000006E3 59                      	pop	cx
 10789 000006E4 06                      	push	es
 10790 000006E5 1F                      	pop	ds
 10791 000006E6 0E                      	push	cs
 10792 000006E7 07                      	pop	es
 10793 000006E8 89FE                    	mov	si,di
 10794 000006EA 5F                      	pop	di		; get back pointer to command line
 10795                                  
 10796                                  ; If the parameter was not found, there is no need to perform any replacement.
 10797                                  ; We merely pretend that we've copied the parameter.
 10798                                  
 10799 000006EB 7203                    	jc	short GETENV6
 10800                                  
 10801                                  ; ES:DI points to command line being built
 10802                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10803                                  
 10804 000006ED E86502                  	call	STRCPY		; (let RdBat handle overflow)
 10805                                  	; 24/04/2022
 10806                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10807                                  GETENV6:
 10808 000006F0 1F                      	pop	ds
 10809 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10810                                  
 10811                                  ; =============== S U B	R O U T	I N E =======================================
 10812                                  
 10813                                  ;   SkipToEOL - read from batch file until end of line
 10814                                  
 10815                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10816                                  SKIPTOEOL:
 10817 000006F4 F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10818                                  	;jnz	short SKIPTOEOL1  	
 10819                                  	;retn			; no batch file in effect
 10820                                  	
 10821 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10822                                  SKIPTOEOL1:
 10823 000006FC E86902                  	call	GETBATBYT
 10824 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10825 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10826                                  SKIPTOEOL2:
 10827 00000703 C3                      	retn
 10828                                  
 10829                                  ; =============== S U B	R O U T	I N E =======================================
 10830                                  
 10831                                  ;Break	<Allocate and deallocate the transient portion>
 10832                                  
 10833                                  ; Free Transient. Modify ES,AX,flags
 10834                                  
 10835                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10836                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10837                                  FREE_TPA:
 10838 00000704 06                      	push	es
 10839 00000705 8E06[C58A]              	mov	es,[RESSEG]
 10840 00000709 268E06[4703]            	mov	es,[es:Res_Tpa]
 10841 0000070E B449                    	mov	ah,49h
 10842                                  	;mov	ah,DEALLOC ; 49h
 10843 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10844                                  			; ES = segment address of area to be freed
 10845 00000712 07                      	pop	es
 10846 00000713 C3                      	retn
 10847                                  
 10848                                  ; =============== S U B	R O U T	I N E =======================================
 10849                                  
 10850                                  ; Allocate transient. Modify AX,BX,DX,flags
 10851                                  
 10852                                  	; 06/02/2023
 10853                                  ALLOC_TPA:
 10854 00000714 06                      	push	es
 10855 00000715 8E06[C58A]              	mov	es,[RESSEG]
 10856 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10857 0000071C B448                    	mov	ah,48h
 10858                                  	;mov	ah,ALLOC ; 48h
 10859 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10860                                  			; BX = number of 16-byte paragraphs desired
 10861 00000720 53                      	push	bx	  	; Save size of block
 10862 00000721 B448                    	mov	ah,48h
 10863                                  	;mov	ah,ALLOC ; 48h
 10864 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10865                                  			; BX = number of 16-byte paragraphs desired
 10866                                  
 10867                                  ; Attempt to align TPA on 64K boundary
 10868                                  
 10869 00000725 5B                      	pop	bx		; Restore size of block
 10870 00000726 26A3[4703]              	mov	[es:Res_Tpa],ax
 10871                                  				; Save segment to beginning of block
 10872 0000072A A3[D58A]                	mov	[TRAN_TPA],ax
 10873                                  
 10874                                  ; Is the segment already aligned on a 64K boundary
 10875                                  
 10876 0000072D 89C2                    	mov	dx,ax		; Save segment
 10877 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10878 00000732 7507                    	jnz	short CALC_TPA
 10879 00000734 89D0                    	mov	ax,dx
 10880 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10881 00000739 7523                    	jnz	short NOROUND
 10882                                  CALC_TPA:
 10883 0000073B 89D0                    	mov	ax,dx
 10884 0000073D 2500F0                  	and	ax,0F000h
 10885 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10886 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10887                                  
 10888                                  ; Make sure that new boundary is within allocated range
 10889                                  
 10890 00000745 268B16[4703]            	mov	dx,[es:Res_Tpa]
 10891 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10892 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10893 0000074E 720E                    	jb	short NOROUND
 10894                                  
 10895                                  ; Make sure that we won't overwrite the transient
 10896                                  
 10897 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10898 00000752 39C3                    	cmp	bx,ax
 10899 00000754 7208                    	jb	short NOROUND
 10900                                  
 10901                                  ; The area from the 64K boundary to the beginning of the transient must
 10902                                  ; be at least 64K.
 10903                                  
 10904 00000756 29C3                    	sub	bx,ax
 10905                                  	;cmp	bx,4096
 10906 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10907 0000075C 7304                    	jnb	short ROUNDDONE
 10908                                  NOROUND:
 10909 0000075E 26A1[4703]              	mov	ax,[es:Res_Tpa]
 10910                                  ROUNDDONE:
 10911 00000762 26A3[3903]              	mov	[es:LTpa],ax	; Re-compute everything
 10912 00000766 A3[C78A]                	mov	[TPA],ax
 10913 00000769 89C3                    	mov	bx,ax
 10914 0000076B 8CC8                    	mov	ax,cs
 10915 0000076D 29D8                    	sub	ax,bx
 10916 0000076F 53                      	push	bx
 10917 00000770 BB1000                  	mov	bx,16
 10918 00000773 F7E3                    	mul	bx
 10919 00000775 5B                      	pop	bx
 10920 00000776 09D2                    	or	dx,dx
 10921 00000778 7403                    	jz	short SAVSIZ2
 10922 0000077A B8FFFF                  	mov	ax,-1
 10923                                  SAVSIZ2:
 10924                                  
 10925                                  ; AX is the number of bytes free in the buffer between the resident and the
 10926                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10927                                  
 10928 0000077D 3D0002                  	cmp	ax,512
 10929 00000780 7603                    	jbe	short GOTSIZE2
 10930                                  	;and	ax,~1FFh
 10931 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10932                                  GOTSIZE2:
 10933 00000785 A3[E68A]                	mov	[BYTCNT],ax
 10934 00000788 07                      	pop	es
 10935 00000789 C3                      	retn
 10936                                  
 10937                                  ; =============== S U B	R O U T	I N E =======================================
 10938                                  
 10939                                  ;Break	<BatCom - enter a batch file>
 10940                                  
 10941                                  ; The exec search has determined that the user has requested a batch file for
 10942                                  ; execution. We parse the arguments, create the batch segment, and signal
 10943                                  ; batch processing.
 10944                                  
 10945                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10946                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10947                                  BATCOM:	
 10948                                  
 10949                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10950                                  
 10951                                  ; Batch parameters are read with ES set to segment of resident part
 10952                                  
 10953                                  	; MSDOS 6.0
 10954 0000078A 8E06[C58A]              	mov	es,[RESSEG]
 10955                                  	;ASSUME	ES:RESGROUP
 10956                                  	;cmp	byte [es:Call_Batch_Flag],1
 10957 0000078E 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10958                                  					;AN043; If in CALL,
 10959 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10960                                  	;invoke	IOSET			; Set up any redirection
 10961 00000796 E8E423                  	call	IOSET
 10962                                  skip_ioset:				;AN043;
 10963 00000799 E868FF                  	call	FREE_TPA		; G
 10964                                  	;cmp	byte [es:Call_Batch_Flag],1
 10965 0000079C 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10966 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10967                                  
 10968                                  	; 12/02/2023
 10969                                  	; MSDOS 3.3
 10970                                  	;call	IOSET
 10971                                  	;mov	es,[RESSEG]
 10972                                  	;call	FREE_TPA
 10973                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 10974                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 10975                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 10976                                  
 10977                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10978                                  
 10979                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 10980                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 10981                                  ; Don't execute if in call
 10982                                  
 10983 000007A4 E89608                  	call	FOROFF
 10984                                  GETECHO:
 10985 000007A7 E8BE27                  	call	PipeOff
 10986 000007AA 26A0[8801]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 10987 000007AE 2401                    	and	al,1			; Save current echo state
 10988                                  
 10989 000007B0 50                      	push	ax
 10990 000007B1 31C0                    	xor	ax,ax
 10991 000007B3 26F706[3401]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 10992 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 10993 000007BC 26A1[3401]              	mov	ax,[es:Batch] 		; Get current batch segment
 10994                                  	;cmp	byte [es:Call_Batch_Flag],1
 10995 000007C0 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10996 000007C6 7408                    	jz	short LEAVEBAT
 10997                                  
 10998                                  ;  We are in a chained batch file, save batlast from previous batch segment
 10999                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11000                                  
 11001 000007C8 06                      	push	es
 11002 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 11003                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11004                                  				; Get previous batch segment
 11005                                  	; 12/02/2023
 11006                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11007 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11008 000007CF 07                      	pop	es
 11009                                  LEAVEBAT:
 11010 000007D0 50                      	push	ax		; Keep segment until new one created
 11011                                  	;cmp	byte [es:Call_Batch_Flag],1
 11012 000007D1 26803E[9A01]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11013 000007D7 7403                    	jz	short STARTBAT
 11014 000007D9 E82001                  	call	BATCHOFF
 11015                                  
 11016                                  ; Find length of batch file
 11017                                  
 11018                                  STARTBAT:
 11019 000007DC 26C606[9A01]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11020 000007E2 BE[ED89]                	mov	si,EXECPATH
 11021                                  
 11022                                  	; 12/02/2023
 11023                                  	; MSDOS 6.0
 11024 000007E5 B811B7                  	mov	ax,0B711h
 11025                                  	;mov	ax,AppendTruename
 11026                                  				;AN042; Get the real path where the batch file
 11027 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11028 000007EA B44E                    	mov	ah,4Eh
 11029                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11030 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 11031 000007EE B91300                  	mov	cx,13h
 11032                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11033 000007F1 CD21                    	int	21h		;AN042;
 11034                                  
 11035                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11036 000007F3 E87624                  	call	dstrlen
 11037                                  ;
 11038                                  ; Allocate batch area:
 11039                                  ;   BYTE    type of segment
 11040                                  ;   WORD    segment of last batch file
 11041                                  ;   WORD    segment for FOR command
 11042                                  ;   BYTE    FOR flag state on entry to batch file
 11043                                  ;   DWORD   offset for next line
 11044                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11045                                  ;   ASCIZ   file name (with . and ..)
 11046                                  ;   BYTES   CR-terminated parameters
 11047                                  ;   BYTE    0 flag to indicate end of parameters
 11048                                  ;
 11049                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11050                                  ; later when we've squeezed out the extra
 11051                                  ;
 11052 000007F6 89CB                    	mov	bx,cx		; length of file name.
 11053                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11054                                  	; 12/02/2023
 11055                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11056                                  	; 25/04/2023
 11057 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11058                                  					; structure + max len + round up
 11059 000007FC 51                      	push	cx
 11060 000007FD B104                    	mov	cl,4
 11061 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 11062 00000801 53                      	push	bx		; Save size of batch segment
 11063 00000802 B448                    	mov	ah,48h
 11064                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11065 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11066                                  				; BX = number of 16-byte paragraphs desired
 11067 00000806 5B                      	pop	bx		; Get size of batch segment
 11068                                  
 11069                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11070                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11071                                  ; G This error will occur with nesting of batch files. We also need to
 11072                                  ; G make sure that we don't overlay the transient.
 11073                                  
 11074 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11075                                  
 11076 00000809 50                      	push	ax		;G save batch segment
 11077 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 11078 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 11079 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 11080                                  
 11081                                  	; MSDOS 6.0
 11082                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11083                                  ; M006; batchseg is always above the transient. We need to change this code
 11084                                  ; M006; to only check for an overlap
 11085                                  
 11086                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11087                                  	; 12/02/2023
 11088                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11089                                  	;mov	dx,TRANSPACEEND		
 11090                                  	;add	dx,15		;round up para; M006
 11091 00000811 BAA395                  	mov	dx,TRANSPACEEND+15
 11092                                  
 11093 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 11094 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 11095                                  
 11096 00000818 39D8                    	cmp	ax,bx		; M006
 11097 0000081A 7211                    	jb	short ENOUGH_MEM
 11098                                  				; Batchseg below transient
 11099                                  				; enough memory ; M006
 11100 0000081C 39D0                    	cmp	ax,dx		; M006
 11101 0000081E 770D                    	ja	short ENOUGH_MEM	
 11102                                  				; Batchseg above transient
 11103                                  				; enough memory ; M006
 11104                                  
 11105                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11106                                  
 11107 00000820 58                      	pop	ax		; restore ax; M006
 11108                                  
 11109                                  	; 12/02/2023
 11110                                  	; MSDOS 3.3
 11111                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11112                                  ; M006;	pop	ax		;G get batch segment back
 11113                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11114                                  
 11115                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11116 00000821 06                      	push	es		;G no we're hitting the transient
 11117 00000822 8EC0                    	mov	es,ax
 11118 00000824 B80049                  	mov	ax,4900h
 11119                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11120 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11121                                  			; ES = segment address of area to be freed
 11122 00000829 07                      	pop	es
 11123                                  MEM_ERROR:
 11124 0000082A E9B800                  	jmp	NO_MEMORY	;G Set up for message and exit
 11125                                  
 11126                                  ENOUGH_MEM:
 11127                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11128                                  	; MSDOS 6.0
 11129 0000082D 58                      	pop	ax		; restore ax; M006
 11130                                  
 11131                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11132 0000082E 26A3[3401]              	mov	[es:Batch],ax
 11133 00000832 E8DFFE                  	call	ALLOC_TPA
 11134                                  
 11135                                  ; Initialize batch segment
 11136                                  
 11137 00000835 5A                      	pop	dx		; length of name
 11138 00000836 58                      	pop	ax		;G get saved batch segment back
 11139 00000837 26FF06[9701]            	inc	word [es:Nest]	;G increment # batch files in progress
 11140 0000083C 06                      	push	es
 11141 0000083D 268E06[3401]            	mov	es,[es:Batch]
 11142                                  	;mov	byte [ES:0],0
 11143                                  				; signal batch file type
 11144 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11145                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11146                                  				;G save segment of last batch file
 11147                                  	;mov	[es:3],ax	; MSDOS 6.0
 11148 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11149 0000084C 1E                      	push	ds
 11150 0000084D 8E1E[C58A]              	mov	ds,[RESSEG]	;G set to resident data
 11151                                  
 11152 00000851 31C0                    	xor	ax,ax
 11153 00000853 8A1E[9401]              	mov	bl,[ForFlag]	;G get the current FOR state
 11154                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11155                                  				;G save it in the batch segment
 11156                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11157 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11158 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11159 0000085F 7406                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11160                                  	;mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11161                                  	;mov	byte [ForFlag],0 ;G reset forflag
 11162                                  	; 26/07/2024
 11163 00000861 A2[9401]                	mov	[ForFlag],al ; 0
 11164 00000864 A1[9501]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11165                                  FOR_NOT_ON:
 11166                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11167                                  				;G save FOR segment in batch segment
 11168                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11169 00000867 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11170 0000086B 31C0                    	xor	ax,ax
 11171 0000086D A3[9501]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11172 00000870 8A1E[8801]              	mov	bl,[EchoFlag]
 11173 00000874 1F                      	pop	ds
 11174                                  	;mov	[es:1],bl 
 11175                                  				 ;G save echo state of parent
 11176 00000875 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11177                                  ;SR;
 11178                                  ; Initialize the new BatchEOF flag we have added to 0
 11179                                  
 11180                                  	; MSDOS 6.0
 11181                                  	;mov	byte [es:2],0
 11182 0000087A 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11183                                  
 11184                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11185 00000880 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11186                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11187 00000884 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11188                                  
 11189                                  ; Initialize pointers
 11190                                  
 11191 00000888 48                      	dec	ax		; put -1 into AX
 11192                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11193                                  				; point to parm area
 11194                                  	;mov	di,0Ch	; MSDOS 6.0
 11195 00000889 BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11196 0000088C 89FB                    	mov	bx,di
 11197 0000088E B90A00                  	mov	cx,10
 11198 00000891 F3AB                    	rep stosw		; Init to no parms
 11199                                  
 11200                                  ; Move in batch file name
 11201                                  
 11202 00000893 89D1                    	mov	cx,dx
 11203 00000895 F3A4                    	rep	movsb
 11204                                  
 11205                                  ; Now copy the command line into batch segment, parsing the arguments along
 11206                                  ; the way. Segment will look like this:
 11207                                  ;
 11208                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11209                                  ;
 11210                                  ; or, in the case of fewer arguments:
 11211                                  ;
 11212                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11213                                  
 11214 00000897 BE[2689]                	mov	si,COMBUF+2
 11215                                  	;mov	cx,10		; at most 10 arguments
 11216                                  	; 07/06/2023
 11217 0000089A B10A                    	mov	cl,10
 11218                                  EACHPARM:
 11219 0000089C E83F1D                  	call	scanoff		; skip to argument
 11220                                  
 11221                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11222                                  
 11223 0000089F 3C0D                    	cmp	al,0Dh		; end of road?
 11224 000008A1 741D                    	jz	short HAVPARM	; yes, no more arguments
 11225                                  
 11226                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11227                                  
 11228 000008A3 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11229                                  
 11230                                  ; Go into allocated piece and stick in new argument pointer.
 11231                                  
 11232 000008A5 26893F                  	mov	[es:bx],di	; store batch pointer
 11233 000008A8 83C302                  	add	bx,2		; advance arg counter
 11234                                  
 11235                                  ; Move the parameter into batch segment
 11236                                  
 11237                                  MOVPARM:
 11238 000008AB AC                      	lodsb			; get byte
 11239 000008AC E8371D                  	call	DELIM		; if delimiter
 11240 000008AF 7407                    	jz	short ENDPARM	; then done with parm
 11241 000008B1 AA                      	stosb			; store byte
 11242 000008B2 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11243 000008B4 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11244 000008B6 EBF3                    	jmp	short MOVPARM
 11245                                  
 11246                                  ; We have copied a parameter up until the first separator.
 11247                                  ; Terminate it with CR.
 11248                                  
 11249                                  ENDPARM:
 11250 000008B8 B00D                    	mov	al,0Dh
 11251 000008BA AA                      	stosb
 11252 000008BB E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11253 000008BD 49                      	dec	cx		; remember that we've seen one.	
 11254 000008BE EBDC                    	jmp	short EACHPARM
 11255                                  
 11256                                  ; We have parsed the entire line. Terminate the arg list
 11257                                  
 11258                                  HAVPARM:
 11259 000008C0 30C0                    	xor	al,al		; Nul terminate the parms
 11260 000008C2 AA                      	stosb
 11261                                  
 11262                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11263                                  ; into paragraphs and setblock to the appropriate size
 11264                                  
 11265 000008C3 8D5D0F                  	lea	bx,[di+15]
 11266 000008C6 B104                    	mov	cl,4
 11267 000008C8 D3EB                    	shr	bx,cl
 11268 000008CA B44A                    	mov	ah,4Ah
 11269                                  	;mov	ah,SETBLOCK ; 4Ah
 11270 000008CC CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11271                                  			; ES = segment address of block	to change
 11272                                  			; BX = new size	in paragraphs
 11273 000008CE 07                      	pop	es
 11274 000008CF 06                      	push	es
 11275 000008D0 1F                      	pop	ds		; Simply batch FCB setup
 11276 000008D1 833E[8E01]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11277 000008D6 7506                    	jne	short NOBATSING
 11278 000008D8 C706[8E01]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11279                                  
 11280                                  NOBATSING:
 11281                                  
 11282                                  ; Enter the batch file with the current echo state
 11283                                  
 11284 000008DE 58                      	pop	ax		; Get original echo state
 11285 000008DF A2[8801]                	mov	[EchoFlag],al	; restore it
 11286 000008E2 E91FF8                  	jmp	TCOMMAND
 11287                                  
 11288                                  ; The following is executed if there isn't enough memory for batch segment
 11289                                  
 11290                                  NO_MEMORY:
 11291 000008E5 5A                      	pop	dx		; even up our stack 
 11292 000008E6 58                      	pop	ax
 11293 000008E7 58                      	pop	ax
 11294 000008E8 E829FE                  	call	ALLOC_TPA	; reallocate memory
 11295                                  
 11296                                  	; 12/02/2023
 11297                                  	; MSDOS 3.3
 11298                                  	;mov	dx,INSFMEMMESPTR
 11299                                  	;jmp	CERROR
 11300                                  
 11301                                  	; MSDOS 6.0
 11302                                  	;mov	byte [msg_disp_class],1
 11303 000008EB C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 11304                                  				;AN000; set up extended error msg class
 11305                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11306 000008F0 BA[1B7F]                	mov	dx,extend_buf_ptr
 11307                                  	;			;AC000; get extended message pointer
 11308                                  	;mov	word [extend_buf_ptr],8
 11309 000008F3 C706[1B7F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11310                                  				;AN000; get message number in control block
 11311 000008F9 E95620                  	jmp	cerror		;g print error message and go...
 11312                                  
 11313                                  ; =============== S U B	R O U T	I N E =======================================
 11314                                  
 11315                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11316                                  BATCHOFF:
 11317 000008FC 50                      	push	ax
 11318 000008FD 06                      	push	es
 11319 000008FE 1E                      	push	ds
 11320 000008FF 53                      	push	bx
 11321                                  
 11322 00000900 2E8E06[C58A]            	mov	es,[cs:RESSEG]
 11323                                  	;mov	ds,[cs:RESSEG]
 11324                                  	; 26/07/2024
 11325 00000905 06                      	push	es
 11326 00000906 1F                      	pop	ds
 11327                                  
 11328 00000907 A1[3401]                	mov	ax,[Batch]	; Free the batch segment
 11329 0000090A 09C0                    	or	ax,ax
 11330 0000090C 7442                    	jz	short NOTFREE
 11331                                  
 11332 0000090E 06                      	push	es
 11333 0000090F 8EC0                    	mov	es,ax
 11334 00000911 F606[8801]01            	test	byte [EchoFlag],1
 11335                                  				;G Is echo on?
 11336 00000916 7505                    	jnz	short ECHO_LAST_LINE
 11337                                  				;G Yes - echo last line in file
 11338                                  	;mov	byte [SUPPRESS],0
 11339 00000918 C606[8901]00            	mov	byte [Suppress],NO_ECHO
 11340                                  				;G no - don't echo last line in file	
 11341                                  ECHO_LAST_LINE:
 11342                                  	;mov	bl,[es:1]
 11343 0000091D 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11344                                  				; G get echo state
 11345 00000922 881E[8801]              	mov	[EchoFlag],bl
 11346                                  				; G  and restore it
 11347                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11348                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11349 00000926 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11350                                  				;G Get FOR segment
 11351 0000092B 891E[9501]              	mov	[ForPtr],bx	;G  and restore it
 11352                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11353                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11354 0000092F 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11355                                  				;G Get FOR flag
 11356 00000934 881E[9401]              	mov	[ForFlag],bl
 11357                                  				;G  and restore it
 11358                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11359                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11360 00000938 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11361                                  				;G  Get old batch segment
 11362                                  
 11363 0000093D B449                    	mov	ah,49h
 11364                                  	;mov	ah,DEALLOC ; 49h
 11365 0000093F CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11366                                  			; ES = segment address of area to be freed
 11367 00000941 07                      	pop	es
 11368 00000942 891E[9B01]              	mov	[Next_Batch],bx	;G reset batch segment	
 11369 00000946 26FF0E[9701]            	dec	word [es:Nest]
 11370 0000094B 31C0                    	xor	ax,ax
 11371 0000094D A3[3401]                	mov	[Batch],ax	; No batch in progress
 11372                                  NOTFREE:
 11373 00000950 5B                      	pop	bx
 11374 00000951 1F                      	pop	ds
 11375 00000952 07                      	pop	es
 11376 00000953 58                      	pop	ax
 11377 00000954 C3                      	retn
 11378                                  
 11379                                  ; =============== S U B	R O U T	I N E =======================================
 11380                                  
 11381                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11382                                  
 11383                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11384                                  ;	Entry : DS:SI ==> source string
 11385                                  ;		ES:DI ==> destination string
 11386                                  ;		CX = current length of destination string
 11387                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11388                                  
 11389                                  	; 12/02/2023	
 11390                                  	; MSDOS 3.3
 11391                                  ;STRCPY:
 11392                                  	;push	ax
 11393                                  ;CCYCLE:
 11394                                  	;lodsb
 11395                                  	;stosb
 11396                                  	;or	al,al
 11397                                  	;jnz	short CCYCLE
 11398                                  	;pop	ax
 11399                                  	;retn
 11400                                  
 11401                                  ;Procedure StrCpy,NEAR
 11402                                  
 11403                                  	; 12/02/2023
 11404                                  	; MSDOS 6.0
 11405                                  STRCPY:
 11406 00000955 50                      	push	ax
 11407                                  ccycle:
 11408 00000956 AC                      	lodsb
 11409 00000957 41                      	inc	cx
 11410                                  	;cmp	cx,128
 11411 00000958 81F98000                	cmp	cx,COMBUFLEN
 11412                                  	;jb	short ccopy
 11413                                  	;stc			; set carry to signal error
 11414                                  	;jmp	short ccend
 11415                                  	; 12/02/2023
 11416 0000095C F5                      	cmc
 11417 0000095D 7205                    	jc	short ccend
 11418                                  ccopy:
 11419 0000095F AA                      	stosb
 11420 00000960 08C0                    	or	al,al
 11421 00000962 75F2                    	jnz	short ccycle
 11422                                  ccend:
 11423 00000964 49                      	dec	cx		; discount extra byte
 11424 00000965 4F                      	dec	di		; back up pointer
 11425 00000966 58                      	pop	ax
 11426 00000967 C3                      	retn			; return carry clear
 11427                                  
 11428                                  ;EndProc StrCpy
 11429                                  
 11430                                  ;============================================================================
 11431                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11432                                  ;============================================================================
 11433                                  ; 12/10/2018 - Retro DOS v3.0
 11434                                  
 11435                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11436                                  
 11437                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11438                                  
 11439                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11440                                  
 11441                                  ; =============== S U B	R O U T	I N E =======================================
 11442                                  
 11443                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11444                                  
 11445                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11446                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11447                                  ; AH, DX destroyed.
 11448                                  
 11449                                  GETBATBYT:
 11450 00000968 53                      	push	bx
 11451 00000969 51                      	push	cx
 11452 0000096A 1E                      	push	ds
 11453 0000096B F606[7E01]FF            	test	byte [Batch_Abort],-1
 11454                                  	;jnz	short BATEOF
 11455                                  	; 14/02/2023
 11456 00000970 7403                    	jz	short getbatbyt1
 11457 00000972 E9D100                  	jmp	BATEOF
 11458                                  getbatbyt1:
 11459 00000975 F706[3401]FFFF          	test	word [Batch],-1
 11460                                  	;jz	short BATEOF
 11461                                  	; 14/02/2023
 11462 0000097B 7503                    	jnz	short getbatbyt2
 11463 0000097D E9C600                  	jmp	BATEOF
 11464                                  getbatbyt2:
 11465 00000980 06                      	push	es
 11466 00000981 8E06[3401]              	mov	es,[Batch]
 11467                                  
 11468                                  	; MSDOS 6.0
 11469                                  ;M020;
 11470                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11471                                  ;try to read from the batchfile again.
 11472                                  
 11473                                  	;cmp	byte [es:2],0
 11474 00000985 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11475                                  				;already reached EOF?	;M020
 11476 0000098B 7403                    	jz	short not_eof	;no, read batch file	;M020
 11477 0000098D E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11478                                  not_eof:						;M020
 11479                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11480                                  	;add	word [es:8],1	; MSDOS 6.0
 11481 00000990 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11482                                  	;adc	word [es:10],0	; MSDOS 6.0
 11483 00000996 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11484 0000099C 07                      	pop	es
 11485                                  
 11486                                  ; See if we have bytes buffered...
 11487                                  
 11488 0000099D 8CC8                    	mov	ax,cs
 11489 0000099F 8ED8                    	mov	ds,ax
 11490 000009A1 8B1E[4C95]              	mov	bx,[BATBUFPOS]
 11491 000009A5 83FBFF                  	cmp	bx,-1
 11492 000009A8 7540                    	jnz	short UNBUF
 11493                                  
 11494                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11495                                  
 11496 000009AA BA[4E95]                	mov	dx,BATBUF
 11497 000009AD 8B0E[6384]              	mov	cx,[BATBUFLEN] ; max to read.
 11498 000009B1 8B1E[798D]              	mov	bx,[BATHAND]
 11499                                  	; 14/02/2023
 11500 000009B5 B43F                    	mov	ah,3Fh
 11501                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11502 000009B7 CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11503                                  			; BX = file handle,CX = number	of bytes to read
 11504                                  			; DS:DX	-> buffer
 11505                                  	; MSDOS 6.0
 11506 000009B9 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11507                                  	;invoke	get_ext_error_number	;AN022; get the error
 11508 000009BB E83213                  	call	get_ext_error_number
 11509 000009BE 1E                      	push	ds			;AN022; save local segment
 11510 000009BF 8E1E[C58A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11511                                  	;assume ds:resgroup		;AN022;
 11512 000009C3 89C2                    	mov	dx,ax			;AN022; put error in DX
 11513                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11514 000009C5 E861FB                  	call	output_batch_name
 11515 000009C8 1F                      	pop	ds			;AN022;
 11516                                  	;assume	ds:trangroup		;AN022;
 11517                                  	;invoke	std_eprintf		;AN022; print out the error
 11518 000009C9 E81B44                  	call	std_eprintf
 11519                                  	;mov	byte ptr combuf+2,end_of_line_in
 11520 000009CC C606[2689]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11521                                  	;				;AN022; terminate the batch line for parsing
 11522                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11523 000009D1 C606[2789]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11524                                  	;				;AN022; terminate the batch line for output
 11525                                  ;M020;
 11526                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11527                                  ;error is never hit (and it shouldn't be)
 11528                                  
 11529 000009D6 8E1E[C58A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11530 000009DA EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11531                                  bat_read_ok:				;AN022;
 11532                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11533 000009DC 89C1                    	mov	cx,ax
 11534                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11535                                  	; 14/02/2023
 11536 000009DE E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11537 000009E0 890E[6E95]              	mov	[BATBUFEND],cx
 11538 000009E4 31DB                    	xor	bx,bx
 11539 000009E6 891E[4C95]              	mov	[BATBUFPOS],bx
 11540                                  
 11541                                  	; Buffered bytes!
 11542                                  UNBUF:
 11543 000009EA 8A87[4E95]              	mov	al,[BATBUF+bx]		; get next byte
 11544 000009EE 43                      	inc	bx
 11545 000009EF 3B1E[6E95]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11546 000009F3 7203                    	jb	short SETBUFPOS
 11547 000009F5 BBFFFF                  	mov	bx,-1
 11548                                  SETBUFPOS:
 11549 000009F8 891E[4C95]              	mov	[BATBUFPOS],bx
 11550 000009FC 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11551 000009FE 7575                    	jne	short GETBYTEDONE
 11552                                  
 11553                                  ;We get here only when we hit an EOF
 11554                                  	
 11555                                  	; MSDOS 6.0
 11556                                  BATEOFDS:
 11557                                  ;SR;
 11558                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11559                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11560                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11561                                  ;batch processing is turned off before the last line is processed and so 
 11562                                  ;this line would never be executed. 
 11563                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11564                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11565                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11566                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11567                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11568                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11569                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11570                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11571                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11572                                  ;another redundant CR-LF. There is no work-around I can think of.
 11573                                  ; 	I would love to restructure this entire routine and its caller to
 11574                                  ;make the flow really easy to understand but I guess this will have to wait.
 11575                                  ;
 11576 00000A00 06                      	push	es
 11577 00000A01 8E06[C58A]              	mov	es,[RESSEG]
 11578                                  ;SR;
 11579                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11580                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11581                                  ;
 11582 00000A05 268E06[3401]            	mov	es,[es:Batch]
 11583                                  	;cmp	byte [es:2],0
 11584 00000A0A 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11585 00000A10 7516                    	jnz	short crpresent
 11586                                  
 11587                                  	;inc	byte [es:2]
 11588 00000A12 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11589                                  					;match the dec following
 11590 00000A17 8B1E[6E95]              	mov	bx,[BATBUFEND]
 11591 00000A1B 80BF[4D95]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11592 00000A20 7406                    	je	short crpresent		;yes, no need to fake it
 11593                                  
 11594                                  	;add	byte [es:2],3
 11595 00000A22 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11596                                  					;BatchEOF == 4 to fake CR-LF
 11597                                  crpresent:
 11598                                  ;;	;pop	es
 11599                                  
 11600                                  	;ASSUME	DS:TranGroup
 11601                                  	; 14/02/2023
 11602 00000A28 8E1E[C58A]              	mov	ds,[RESSEG]
 11603                                  	;ASSUME	DS:ResGroup
 11604                                  ;SR;
 11605                                  ; The shift operation is done here to replace the decrement. This is because
 11606                                  ;we can jump to this label directly from above when bogus calls are made to
 11607                                  ;this routine even after batch processing is turned off. The shift ensures
 11608                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11609                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11610                                  ;calls.
 11611                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11612                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11613                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11614                                  ;turning batch processing off.
 11615                                  
 11616                                  At_EOF:					;new label added ;M020
 11617                                  	;shr	byte [es:2],1
 11618 00000A2C 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11619                                  					;decrement the flag
 11620 00000A31 7412                    	jz	short turn_off		;zero,turn batch off
 11621                                  	;cmp	byte [es:2],1
 11622 00000A33 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11623 00000A39 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11624                                  ;
 11625                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11626                                  ;
 11627 00000A3B B00D                    	mov	al,0Dh			;return fake CR.
 11628 00000A3D 07                      	pop	es
 11629 00000A3E EB35                    	jmp	short GETBYTEDONE
 11630                                  ret_lf:
 11631 00000A40 B00A                    	mov	al,0Ah			;return fake LF
 11632 00000A42 07                      	pop	es
 11633 00000A43 EB30                    	jmp	short GETBYTEDONE		
 11634                                  turn_off:
 11635 00000A45 07                      	pop	es
 11636                                  ;BATEOF:
 11637                                  	; MSDOS 3.3
 11638                                  ;TURN_OFF:
 11639                                  	;mov	ds,[RESSEG]
 11640                                  
 11641                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11642                                  BATEOF:
 11643 00000A46 E8B3FE                  	call	BATCHOFF
 11644 00000A49 E8CC02                  	call	BATCLOSE
 11645                                  
 11646                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11647                                  
 11648                                  ;SR; BugBug
 11649                                  ; There is a good reason why this carriage return is being returned here. 
 11650                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11651                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11652                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11653                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11654                                  ;the batchfile already had a CR-LF. 
 11655                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11656                                  ;the end-of-line. This CR is to mark the end-of-file.
 11657                                  
 11658 00000A4C B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11659 00000A4E F606[7E01]FF            	test	byte [Batch_Abort],-1
 11660 00000A53 C606[7E01]00            	mov	byte [Batch_Abort],0
 11661 00000A58 7407                    	jz	short CONT_GET_BYT
 11662 00000A5A BF[2689]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11663 00000A5D 31C9                    	xor	cx,cx			; zero line length
 11664 00000A5F EB14                    	jmp	short GETBYTEDONE
 11665                                  CONT_GET_BYT:
 11666 00000A61 833E[8E01]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11667 00000A66 750D                    	jne	short GETBYTEDONE
 11668 00000A68 833E[9701]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11669 00000A6D 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11670 00000A6F C706[8E01]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11671                                  GETBYTEDONE:
 11672 00000A75 1F                      	pop	ds
 11673 00000A76 59                      	pop	cx
 11674 00000A77 5B                      	pop	bx
 11675 00000A78 C3                      	retn
 11676                                  
 11677                                  ; ---------------------------------------------------------------------------
 11678                                  
 11679                                  ;break	<$If - conditional execution>
 11680                                  
 11681                                  	; 17/04/2023
 11682                                  ;IFERRORP:
 11683                                  ;	pop	ax
 11684                                  ;IFERROR:
 11685                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11686                                  ;FORERROR:
 11687                                  ;	mov	dx,SYNTMES_PTR
 11688                                  ;	jmp	cerror
 11689                                  
 11690                                  ; ---------------------------------------------------------------------------
 11691                                  
 11692                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11693                                  _$IF:
 11694                                  	; MSDOS 6.0
 11695                                  ; Turn off any pipes in progress.
 11696 00000A79 1E                      	push	ds			;AN004; save local DS
 11697 00000A7A 8E1E[C58A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11698                                  	;assume	ds:resgroup		;AN004;
 11699 00000A7E 803E[0102]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11700 00000A83 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11701                                  	;invoke	PipeDel 		;AN004; turn off piping
 11702 00000A85 E86522                  	call	PIPEDEL	
 11703                                  IFNoPipe:				;AN004;
 11704 00000A88 1F                      	pop	ds			;AN004; get local DS back
 11705                                  	;assume	ds:trangroup		;AN004;
 11706                                  
 11707                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11708 00000A89 C606[D88A]00            	mov	byte [IFNOTFLAG],0
 11709 00000A8E C706[2094]0000          	mov	word [IF_NOT_COUNT],0
 11710 00000A94 BE8100                  	mov	si,81h
 11711                                  IFREENT:
 11712 00000A97 E8441B                  	call	scanoff
 11713 00000A9A 3C0D                    	cmp	al,0Dh
 11714 00000A9C 743C                    	je	short IFERROR
 11715 00000A9E 89F5                    	mov	bp,si
 11716 00000AA0 BF[B482]                	mov	di,IFTAB		; Prepare to search if table	
 11717                                  	;mov	ch,0
 11718                                  	; 17/04/2023
 11719 00000AA3 30ED                    	xor	ch,ch
 11720                                  IFINDCOM:
 11721 00000AA5 89EE                    	mov	si,bp
 11722 00000AA7 8A0D                    	mov	cl,[di]
 11723 00000AA9 47                      	inc	di
 11724 00000AAA E33E                    	jcxz	IFSTRING
 11725 00000AAC EB02                    	jmp	short FIRSTCOMP
 11726                                  IFCOMP:
 11727 00000AAE 7510                    	jnz	short IF_DIF
 11728                                  FIRSTCOMP:
 11729 00000AB0 AC                      	lodsb
 11730 00000AB1 268A25                  	mov	ah,[es:di]
 11731 00000AB4 47                      	inc	di
 11732 00000AB5 38E0                    	cmp	al,ah
 11733 00000AB7 7405                    	je	short IFLP
 11734 00000AB9 80CC20                  	or	ah,20h			; Try lower case
 11735 00000ABC 38E0                    	cmp	al,ah
 11736                                  IFLP:
 11737 00000ABE E2EE                    	loop	IFCOMP
 11738                                  IF_DIF:
 11739 00000AC0 9F                      	lahf
 11740 00000AC1 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11741 00000AC3 8B1D                    	mov	bx,[di]			; Get handler address
 11742 00000AC5 47                      	inc	di
 11743 00000AC6 47                      	inc	di
 11744 00000AC7 9E                      	sahf
 11745 00000AC8 75DB                    	jnz	short IFINDCOM
 11746 00000ACA AC                      	lodsb
 11747 00000ACB 3C0D                    	cmp	al,0Dh
 11748                                  IFERRJ:
 11749 00000ACD 740B                    	jz	short IFERROR
 11750 00000ACF E8141B                  	call	DELIM
 11751 00000AD2 75D1                    	jnz	short IFINDCOM
 11752 00000AD4 E8071B                  	call	scanoff
 11753 00000AD7 FFE3                    	jmp	bx
 11754                                  
 11755                                  	; 17/04/2023
 11756                                  IFERRORP:
 11757 00000AD9 58                      	pop	ax
 11758                                  IFERROR:
 11759                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11760                                  FORERROR:
 11761 00000ADA BA[B37F]                	mov	dx,SYNTMES_PTR
 11762 00000ADD E9721E                  	jmp	cerror
 11763                                  
 11764                                  IFNOT:
 11765 00000AE0 F616[D88A]              	not	byte [IFNOTFLAG]
 11766 00000AE4 FF06[2094]              	inc	word [IF_NOT_COUNT]
 11767 00000AE8 EBAD                    	jmp	short IFREENT
 11768                                  
 11769                                  ; We are comparing two strings for equality. First, find the end of the
 11770                                  ; first string.
 11771                                  
 11772                                  IFSTRING:
 11773 00000AEA 56                      	push	si			; save away pointer for later compare
 11774 00000AEB 31C9                    	xor	cx,cx			; count of chars in first string
 11775                                  FIRST_STRING:
 11776 00000AED AC                      	lodsb				; get character
 11777 00000AEE 3C0D                    	cmp	al,0Dh			; end of line?
 11778 00000AF0 74E7                    	jz	short IFERRORP		; yes => error
 11779 00000AF2 E8F11A                  	call	DELIM			; is it a delimiter?
 11780 00000AF5 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11781 00000AF7 41                      	inc	cx			; remember 1 byte for the length
 11782 00000AF8 EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11783                                  EQUAL_CHECK:
 11784 00000AFA 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11785 00000AFC 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11786 00000AFE 3C0D                    	cmp	al,0Dh			; end of line?
 11787 00000B00 74D7                    	je	short IFERRORP		; yes, syntax error
 11788 00000B02 AC                      	lodsb				; get next char
 11789 00000B03 EBF5                    	jmp	short EQUAL_CHECK
 11790                                  
 11791                                  ; The first = has been found. The next char had better be an = too.
 11792                                  
 11793                                  EQUAL_CHECK2:
 11794 00000B05 AC                      	lodsb				; get potential = char
 11795 00000B06 3C3D                    	cmp	al,'='			; is it good?	
 11796                                  	;jnz	short IFERRPJ		; no, error
 11797                                  	; 17/04/2023
 11798 00000B08 75CF                    	jne	short IFERRORP
 11799                                  
 11800                                  ; Find beginning of second string.
 11801                                  
 11802 00000B0A E8D11A                  	call	scanoff
 11803 00000B0D 3C0D                    	cmp	al,0Dh
 11804                                  	;jz	short IFERRPJ
 11805                                  	; 17/04/2023
 11806 00000B0F 74C8                    	je	short IFERRORP
 11807 00000B11 5F                      	pop	di
 11808                                  
 11809                                  ; DS:SI points to second string
 11810                                  ; CX has number of chars in first string
 11811                                  ; ES:DI points to first string
 11812                                  
 11813 00000B12 F3A6                    	repe	cmpsb
 11814 00000B14 7414                    	jz	short MATCH		; match found!
 11815                                  
 11816                                  ; No match. Let's find out what was wrong. The character that did not match
 11817                                  ; has been advanced over. Let's back up to it.
 11818                                  
 11819 00000B16 4E                      	dec	si
 11820                                  
 11821                                  ; If it is EOL, then syntax error
 11822                                  
 11823 00000B17 803C0D                  	cmp	byte [si],0Dh
 11824                                  	;jz	short IFERRJ
 11825                                  	; 17/04/2023
 11826 00000B1A 74BE                    	je	short IFERROR
 11827                                  
 11828                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11829                                  
 11830                                  SKIPSTRINGEND:
 11831 00000B1C AC                      	lodsb
 11832                                  NOTMATCH:
 11833 00000B1D 3C0D                    	cmp	al,0Dh
 11834                                  IFERRORJ2:
 11835                                  	;jz	short IFERRJ
 11836                                  	; 17/04/2023
 11837 00000B1F 74B9                    	jz	short IFERROR
 11838 00000B21 E8C21A                  	call	DELIM
 11839 00000B24 75F6                    	jnz	short SKIPSTRINGEND
 11840                                  
 11841                                  ; Signal that we did NOT have a match
 11842                                  
 11843 00000B26 B0FF                    	mov	al,-1
 11844 00000B28 EB37                    	jmp	short IFRET
 11845                                  
 11846                                  	; 17/04/2023
 11847                                  ;IFERRPJ:
 11848                                  	;jmp	IFERRORP
 11849                                  
 11850                                  ; The compare succeeded. Was the second string longer than the first?
 11851                                  ; We do this by seeing if the next char is a delimiter.
 11852                                  
 11853                                  MATCH:
 11854 00000B2A AC                      	lodsb
 11855 00000B2B E8B81A                  	call	DELIM
 11856 00000B2E 75ED                    	jnz	short NOTMATCH ; not same.
 11857 00000B30 30C0                    	xor	al,al
 11858 00000B32 EB2D                    	jmp	short IFRET
 11859                                  
 11860                                  ; ---------------------------------------------------------------------------
 11861                                  
 11862                                  IFEXISTS:
 11863                                  
 11864                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11865                                  
 11866                                  ;MOREDELIM:
 11867 00000B34 AC                      	lodsb
 11868 00000B35 E8AE1A                  	call	DELIM
 11869 00000B38 75FA                    	jnz	short IFEXISTS
 11870                                  	;jnz	short MOREDELIM
 11871                                  
 11872 00000B3A BA[CE8B]                	mov	dx,DIRBUF
 11873 00000B3D B8001A                  	mov	ax,1A00h
 11874                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11875 00000B40 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11876                                  			; DS:DX	-> disk	transfer buffer
 11877 00000B42 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11878 00000B45 031E[2094]              	add	bx,[IF_NOT_COUNT]
 11879                                  	;mov	ax,ARG_ARGV
 11880                                  	;mov	ax,ARG+ARG_UNIT.argv
 11881 00000B49 B8[D48D]                	mov	ax,ARG
 11882 00000B4C E8FF25                  	call	argv_calc		; convert arg index to pointer
 11883 00000B4F 8B17                    	mov	dx,[bx]
 11884                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11885                                  	;mov	cx,6
 11886 00000B51 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11887 00000B54 B8004E                  	mov	ax,4E00h
 11888                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11889 00000B57 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11890                                  			; CX = search attributes
 11891                                  			; DS:DX	-> ASCIZ filespec
 11892                                  			; (drive,path, and wildcards allowed)
 11893 00000B59 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11894 00000B5B 30C0                    	xor	al,al
 11895 00000B5D EB02                    	jmp	short IFRET
 11896                                  
 11897                                  	;nop
 11898                                  IF_EX_C:
 11899 00000B5F B0FF                    	mov	al,-1			; false 'n' fall through...
 11900                                  IFRET:
 11901 00000B61 F606[D88A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11902 00000B66 7402                    	jz	short REALTEST
 11903 00000B68 F6D0                    	not	al
 11904                                  REALTEST:
 11905 00000B6A 08C0                    	or	al,al
 11906 00000B6C 7403                    	jz	short IFTRUE
 11907 00000B6E E993F5                  	jmp	TCOMMAND
 11908                                  
 11909                                  IFTRUE:
 11910 00000B71 E86A1A                  	call	scanoff
 11911 00000B74 89F1                    	mov	cx,si
 11912 00000B76 81E98100                	sub	cx,81h
 11913 00000B7A 280E8000                	sub	[80h],cl
 11914 00000B7E 8A0E8000                	mov	cl,[80h]
 11915 00000B82 880E[2589]              	mov	[COMBUF+1],cl
 11916 00000B86 BF[2689]                	mov	di,COMBUF+2
 11917 00000B89 FC                      	cld
 11918 00000B8A F3A4                    	rep	movsb
 11919 00000B8C B00D                    	mov	al,0Dh
 11920 00000B8E AA                      	stosb
 11921                                  
 11922                                  ; Signal that an IF was done. 
 11923                                  ; This prevents the redirections from getting lost.
 11924                                  
 11925 00000B8F 1E                      	push	ds
 11926 00000B90 8E1E[C58A]              	mov	ds,[RESSEG]
 11927 00000B94 C606[9301]FF            	mov	byte [IfFlag],-1
 11928 00000B99 1F                      	pop	ds
 11929                                  
 11930                                  ; Go do the command
 11931                                  
 11932 00000B9A E93AF7                  	jmp	DOCOM1
 11933                                  
 11934                                  ; ---------------------------------------------------------------------------
 11935                                  
 11936                                  IFERRORJ3:
 11937 00000B9D EB80                    	jmp	IFERRORJ2
 11938                                  
 11939                                  IFERLEV:
 11940 00000B9F B70A                    	mov	bh,10
 11941 00000BA1 30DB                    	xor	bl,bl
 11942                                  GETNUMLP:
 11943 00000BA3 AC                      	lodsb
 11944 00000BA4 3C0D                    	cmp	al,0Dh
 11945 00000BA6 74F5                    	je	short IFERRORJ3
 11946 00000BA8 E83B1A                  	call	DELIM
 11947 00000BAB 740C                    	jz	short GOTNUM
 11948 00000BAD 2C30                    	sub	al,'0'
 11949 00000BAF 86C3                    	xchg	al,bl
 11950 00000BB1 F6E7                    	mul	bh
 11951 00000BB3 00D8                    	add	al,bl
 11952 00000BB5 86C3                    	xchg	al,bl
 11953 00000BB7 EBEA                    	jmp	short GETNUMLP
 11954                                  GOTNUM:
 11955 00000BB9 1E                      	push	ds
 11956 00000BBA 8E1E[C58A]              	mov	ds,[RESSEG]
 11957 00000BBE 8A26[8501]              	mov	ah,[RetCode]
 11958 00000BC2 1F                      	pop	ds
 11959 00000BC3 30C0                    	xor	al,al
 11960 00000BC5 38DC                    	cmp	ah,bl
 11961 00000BC7 7398                    	jnb	short IFRET
 11962 00000BC9 FEC8                    	dec	al
 11963 00000BCB EB94                    	jmp	short IFRET
 11964                                  
 11965                                  ; ---------------------------------------------------------------------------
 11966                                  
 11967                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11968                                  ; This is a NOP if no batch in progress.
 11969                                  
 11970                                  _SHIFT:
 11971 00000BCD 8E1E[C58A]              	mov	ds,[RESSEG]
 11972 00000BD1 A1[3401]                	mov	ax,[Batch]		; get batch pointer
 11973 00000BD4 09C0                    	or	ax,ax			; in batch mode?
 11974 00000BD6 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 11975                                  SHIFT_RETN:				; no, done.
 11976 00000BD8 C3                      	retn
 11977                                  SHIFT1:
 11978 00000BD9 8EC0                    	mov	es,ax
 11979 00000BDB 8ED8                    	mov	ds,ax
 11980                                  
 11981                                  ; Now move the batch args down by 1 word
 11982                                  
 11983                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 11984                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 11985 00000BDD BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 11986 00000BE0 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 11987 00000BE3 B90900                  	mov	cx,9			; move 9 parameters
 11988 00000BE6 F3A5                    	rep	movsw			; SHIFT down
 11989                                  
 11990                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 11991                                  ; We have copied it into the previous position.
 11992                                  
 11993 00000BE8 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 11994 00000BEB 74EB                    	je	short SHIFT_RETN ; No new parm
 11995                                  
 11996                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 11997                                  ; Assume, first, that there is no next argument.
 11998                                   
 11999 00000BED 8B35                    	mov	si,[di]
 12000 00000BEF C705FFFF                	mov	word [di],-1		; Assume no parm
 12001                                  
 12002                                  ; The parameters are CR separated. Scan for end of this parm.
 12003                                  
 12004                                  SKIPCRLP:
 12005 00000BF3 AC                      	lodsb
 12006 00000BF4 3C0D                    	cmp	al,0Dh
 12007 00000BF6 75FB                    	jne	short SKIPCRLP
 12008                                  
 12009                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12010                                  ; are finished. There are no more parms and the pointer has been previously
 12011                                  ; initialized to indicate it.
 12012                                  
 12013 00000BF8 803C00                  	cmp	byte [si],0
 12014 00000BFB 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12015 00000BFD 8935                    	mov	[di],si			; Pointer to next parm as %9
 12016 00000BFF C3                      	retn
 12017                                  
 12018                                  ; =============== S U B	R O U T	I N E =======================================
 12019                                  
 12020                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12021                                  ; returns char in AL, carry set -> eof
 12022                                  
 12023                                  SKIPDELIM:
 12024 00000C00 F706[3401]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12025 00000C06 740A                    	jz	short SKIPERR
 12026 00000C08 E85DFD                  	call	GETBATBYT		; get a char
 12027 00000C0B E8D819                  	call	DELIM			; check for ignoreable chars
 12028 00000C0E 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12029 00000C10 F8                      	clc
 12030 00000C11 C3                      	retn
 12031                                  SKIPERR:
 12032 00000C12 F9                      	stc
 12033                                  GOTO_RETN:
 12034 00000C13 C3                      	retn
 12035                                  
 12036                                  ; ---------------------------------------------------------------------------
 12037                                  
 12038                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12039                                  ;  .com file. This routine strips the CALL off the command line, sets
 12040                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12041                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12042                                  ;  being CALLed.
 12043                                  
 12044                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12045                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12046                                  _$CALL:
 12047                                  
 12048                                  ;  strip off CALL from command line
 12049                                  
 12050                                  	;ASSUME DS:trangroup,ES:trangroup
 12051                                  
 12052 00000C14 56                      	push	si
 12053 00000C15 57                      	push	di
 12054 00000C16 50                      	push	ax
 12055 00000C17 51                      	push	cx
 12056 00000C18 BE[2689]                	mov	si,COMBUF+2
 12057 00000C1B E8C019                  	call	scanoff			;get to first non-delimeter
 12058                                  	;add	si,4
 12059 00000C1E 83C604                  	add	si,length_call		;point to char past CALL
 12060 00000C21 BF[2689]                	mov	di,COMBUF+2
 12061                                  	;mov	cx,124		
 12062 00000C24 B97C00                  	mov	cx,COMBUFLEN-length_call 
 12063                                  					;get length of buffer
 12064 00000C27 F3A4                    	rep	movsb			;move it
 12065 00000C29 59                      	pop	cx
 12066 00000C2A 58                      	pop	ax
 12067 00000C2B 5F                      	pop	di
 12068 00000C2C 5E                      	pop	si
 12069                                  
 12070                                  ;  set call flag to indicate call in progress
 12071                                  
 12072 00000C2D 1E                      	push	ds
 12073 00000C2E 8E1E[C58A]              	mov	ds,[RESSEG]
 12074 00000C32 C606[9901]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12075 00000C37 C606[9A01]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12076                                  
 12077                                  ; Turn off any pipes in progress.
 12078                                  
 12079 00000C3C 803E[0102]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12080 00000C41 7403                    	jz	short _NOPIPE
 12081 00000C43 E8A720                  	call	PIPEDEL
 12082                                  _NOPIPE:
 12083 00000C46 1F                      	pop	ds
 12084 00000C47 C3                      	retn
 12085                                  
 12086                                  ; ---------------------------------------------------------------------------
 12087                                  
 12088                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12089                                  _GOTO:
 12090 00000C48 8E1E[C58A]              	mov	ds,[RESSEG]
 12091 00000C4C F706[3401]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12092 00000C52 74BF                    	jz	short GOTO_RETN
 12093 00000C54 31D2                    	xor	dx,dx
 12094 00000C56 1E                      	push	ds
 12095 00000C57 8E1E[3401]              	mov	ds,[Batch]
 12096                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12097 00000C5B 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12098                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12099 00000C5F 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12100                                  
 12101                                  	; MSDOS 6.0
 12102                                  ;M037
 12103                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12104                                  ;
 12105 00000C63 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12106                                  					; clear eof indicator ;M037
 12107                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12108 00000C68 1F                      	pop	ds
 12109                                  GOTOOPEN:
 12110 00000C69 E875F8                  	call	PROMPTBAT
 12111                                  	;mov	di,5Dh
 12112 00000C6C BF5D00                  	mov	di,FCB+1		; Get the label
 12113 00000C6F B90B00                  	mov	cx,11
 12114 00000C72 B020                    	mov	al,' '
 12115 00000C74 F2AE                    	repne	scasb
 12116 00000C76 7501                    	jnz	short NOINC
 12117 00000C78 41                      	inc	cx
 12118                                  NOINC:
 12119 00000C79 83E90B                  	sub	cx,11
 12120 00000C7C F7D9                    	neg	cx
 12121                                  	;mov	[cs:GOTOLEN],cx
 12122                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12123 00000C7E 26890E[CE8B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12124                                  
 12125                                  ; At beginning of file. Skip to first non-delimiter char
 12126                                  
 12127 00000C83 E87AFF                  	call	SKIPDELIM
 12128 00000C86 721C                    	jb	short BADGOTO
 12129 00000C88 3C3A                    	cmp	al,':'
 12130 00000C8A 7426                    	jz	short CHKLABEL
 12131                                  LABLKLP:				; Look for the label
 12132 00000C8C E8D9FC                  	call	GETBATBYT
 12133 00000C8F 3C0A                    	cmp	al,0Ah
 12134 00000C91 7509                    	jne	short LABLKTST
 12135                                  
 12136                                  ; At beginning of line. Skip to first non-delimiter char
 12137                                  
 12138 00000C93 E86AFF                  	call	SKIPDELIM
 12139 00000C96 720C                    	jb	short BADGOTO
 12140 00000C98 3C3A                    	cmp	al,':'
 12141 00000C9A 7416                    	je	short CHKLABEL
 12142                                  LABLKTST:
 12143 00000C9C F706[3401]FFFF          	test	word [Batch],0FFFFh ; -1
 12144 00000CA2 75E8                    	jnz	short LABLKLP
 12145                                  BADGOTO:
 12146 00000CA4 E87100                  	call	BATCLOSE
 12147                                  
 12148                                  	; MSDOS 6.0
 12149                                  ;SR;
 12150                                  ; At this point we are terminating without freeing up any nested batch 
 12151                                  ;segments i.e if the error occurred within a called batch file. This routine
 12152                                  ;will traverse the linked list of batch segments and free all of them.
 12153                                  ;
 12154 00000CA7 E8BB00                  	call	free_batch		; free up nested batch segments
 12155                                  
 12156                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12157 00000CAA 0E                      	push	cs
 12158 00000CAB 1F                      	pop	ds
 12159 00000CAC BA[B07F]                	mov	dx,BADLAB_PTR
 12160 00000CAF E9A01C                  	jmp	cerror
 12161                                  
 12162                                  ; Found the :.	Skip to first non-delimiter char
 12163                                  
 12164                                  CHKLABEL:
 12165 00000CB2 E84BFF                  	call	SKIPDELIM
 12166 00000CB5 72ED                    	jb	short BADGOTO
 12167 00000CB7 BF5D00                  	mov	di,FCB+1 ; 5Dh
 12168                                  	;mov	cx,[cs:GOTOLEN]
 12169                                  	; 14/02/2023
 12170 00000CBA 268B0E[CE8B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12171 00000CBF EB05                    	jmp	short GOTBYTE
 12172                                  
 12173                                  NEXTCHRLP:
 12174 00000CC1 51                      	push	cx
 12175 00000CC2 E8A3FC                  	call	GETBATBYT
 12176 00000CC5 59                      	pop	cx
 12177                                  GOTBYTE:
 12178                                  	; 18/03/2023
 12179                                  	; 14/02/2023
 12180                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12181 00000CC6 E8F616                  	call	testkanj
 12182 00000CC9 7413                    	jz	short NOTKANJ1
 12183 00000CCB 263A05                  	cmp	al,[es:di]
 12184 00000CCE 75CC                    	jne	short LABLKTST
 12185 00000CD0 47                      	inc	di
 12186 00000CD1 49                      	dec	cx
 12187 00000CD2 E3C8                    	jcxz	LABLKTST
 12188 00000CD4 51                      	push	cx
 12189 00000CD5 E890FC                  	call	GETBATBYT
 12190 00000CD8 59                      	pop	cx
 12191 00000CD9 263A05                  	cmp	al,[es:di]
 12192 00000CDC EB0C                    	jmp	short KNEXTLABCHR
 12193                                  NOTKANJ1:
 12194                                  	; 14/02/2023
 12195                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12196 00000CDE 0C20                    	or	al,20h
 12197 00000CE0 263A05                  	cmp	al,[es:di]
 12198                                  	;jne	short TRYUPPER
 12199                                  	;jmp	short NEXTLABCHR
 12200                                  	; 25/04/2023
 12201 00000CE3 7407                    	je	short NEXTLABCHR 
 12202                                  TRYUPPER:
 12203 00000CE5 2C20                    	sub	al,20h
 12204 00000CE7 263A05                  	cmp	al,[es:di]
 12205                                  KNEXTLABCHR:
 12206 00000CEA 75B0                    	jnz	short LABLKTST
 12207                                  NEXTLABCHR:
 12208 00000CEC 47                      	inc	di
 12209 00000CED E2D2                    	loop	NEXTCHRLP
 12210 00000CEF E876FC                  	call	GETBATBYT
 12211                                  	; 14/02/2023
 12212 00000CF2 26833E[CE8B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12213                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12214 00000CF8 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12215 00000CFA 3C20                    	cmp	al,' '
 12216 00000CFC 779E                    	ja	short LABLKTST
 12217                                  GOTOCONT:
 12218 00000CFE 3C0D                    	cmp	al,0Dh
 12219 00000D00 7407                    	je	short SKIPLFEED
 12220                                  TONEXTBATLIN:
 12221 00000D02 E863FC                  	call	GETBATBYT
 12222 00000D05 3C0D                    	cmp	al,0Dh
 12223 00000D07 75F9                    	jne	short TONEXTBATLIN
 12224                                  SKIPLFEED:
 12225 00000D09 E85CFC                  	call	GETBATBYT
 12226                                  
 12227                                  	; MSDOS 6.0
 12228                                  ;SR;
 12229                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12230                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12231                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12232                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12233                                  ;all other cases, EOF will be hit while trying to read the next line and
 12234                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12235                                  ;
 12236 00000D0C 06                      	push	es
 12237 00000D0D 8E06[3401]              	mov	es,[Batch]
 12238 00000D11 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12239                                  					;invalidate fake CR-LF flag
 12240 00000D17 07                      	pop	es
 12241                                  
 12242                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12243                                  	;call	BATCLOSE
 12244                                  	;retn
 12245                                  	; 14/02/2023
 12246                                  	;jmp	short BATCLOSE
 12247                                  
 12248                                  ; =============== S U B	R O U T	I N E =======================================
 12249                                  
 12250                                  BATCLOSE:
 12251 00000D18 2E8B1E[798D]            	mov	bx,[cs:BATHAND]
 12252 00000D1D 83FB05                  	cmp	bx,5
 12253 00000D20 7204                    	jb	short CLOSERETURN
 12254                                  	; 14/02/2023
 12255 00000D22 B43E                    	mov	ah,3Eh
 12256                                  	;mov	ah,CLOSE ; 3Eh
 12257 00000D24 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12258                                  			; BX = file handle
 12259                                  CLOSERETURN:
 12260 00000D26 C606[7D01]00            	mov	byte [In_Batch],0 ; reset flag	
 12261 00000D2B C3                      	retn
 12262                                  
 12263                                  ; =============== S U B	R O U T	I N E =======================================
 12264                                  
 12265                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12266                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12267                                  
 12268                                  	; 14/02/2023
 12269                                  BATOPEN:
 12270 00000D2C 1E                      	push	ds
 12271 00000D2D 8E1E[3401]              	mov	ds,[Batch]
 12272                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12273                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12274 00000D31 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12275 00000D34 B8003D                  	mov	ax,3D00h
 12276                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12277 00000D37 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12278                                  			; DS:DX	-> ASCIZ filename
 12279                                  			; AL = access mode
 12280                                  			; 0 - read
 12281 00000D39 721C                    	jc	short SETERRDL
 12282                                  	;mov	dx,[8]
 12283 00000D3B 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12284                                  	;mov	cx,[10]
 12285 00000D3F 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12286 00000D43 1F                      	pop	ds
 12287                                  	;mov	[cs:BATHAND],ax
 12288 00000D44 26A3[798D]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12289 00000D48 89C3                    	mov	bx,ax
 12290 00000D4A B80042                  	mov	ax,4200h
 12291                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12292 00000D4D CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12293                                  			; AL = method: offset from beginning of	file
 12294                                  
 12295                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12296                                  					; nuke batch buffer position
 12297 00000D4F 26C706[4C95]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12298                                  BATOPEN_RETN:
 12299 00000D56 C3                      	retn
 12300                                  
 12301                                  SETERRDL:
 12302 00000D57 89D3                    	mov	bx,dx
 12303                                  	; MSDOS 6.0
 12304                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12305                                  	; 14/02/2023
 12306 00000D59 E8940F                  	call	get_ext_error_number
 12307 00000D5C 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12308                                  
 12309                                  	; MSDOS 3.3
 12310                                  	;mov	dx,INSERTDSKPTR
 12311                                  	;call	GET_EXT_ERR_NUMBER
 12312                                  
 12313                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12314 00000D5E 8A07                    	mov	al,[bx]			; Get drive spec
 12315 00000D60 2C40                    	sub	al,'@'			; A = 1
 12316 00000D62 1F                      	pop	ds
 12317 00000D63 F9                      	stc				; SUB mucked over carry
 12318 00000D64 C3                      	retn
 12319                                  
 12320                                  ; =============== S U B	R O U T	I N E =======================================
 12321                                  
 12322                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12323                                  ;the batch and FOR segments until all of them are freed. It also restores
 12324                                  ;the old state of the EchoFlag.
 12325                                  ;
 12326                                  ;	ENTRY:	ds = RESGROUP
 12327                                  ;
 12328                                  ;	EXIT: 	All batch & FOR segments freed.
 12329                                  ;		EchoFlag restored to old state before batch process.
 12330                                  ;
 12331                                  ;	REGISTERS AFFECTED: bx, cx
 12332                                  
 12333                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12334                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12335                                  
 12336                                  free_batch: ;proc near
 12337                                  	;assume	ds:RESGROUP,es:nothing
 12338                                  
 12339 00000D65 06                      	push	es
 12340 00000D66 8B1E[9B01]              	mov	bx,[Next_Batch]
 12341 00000D6A 09DB                    	or	bx,bx
 12342 00000D6C 7431                    	jz	short fb_ret
 12343                                  _ClearBatch:
 12344 00000D6E 8EC3                    	mov	es,bx			; get batch segment
 12345                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12346 00000D70 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12347                                  	;cmp	bx,0			; is a FOR in progress
 12348                                  	; 27/07/2024
 12349 00000D75 21DB                    	and	bx,bx
 12350 00000D77 7408                    	jz	short no_bat_for	; no - don't deallocate
 12351 00000D79 06                      	push	es			;
 12352 00000D7A 8EC3                    	mov	es,bx			; yes - free it up...
 12353 00000D7C B449                    	mov	ah,49h
 12354                                  	;mov	ah,DEALLOC		;
 12355 00000D7E CD21                    	int	21h			;
 12356 00000D80 07                      	pop	es			; restore to batch segment
 12357                                  no_bat_for:
 12358                                  	;mov	cl,[es:1]
 12359 00000D81 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12360                                  					; get old echo flag
 12361                                  	;mov	bx,[es:3]
 12362 00000D86 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12363                                  					; get old batch segment
 12364 00000D8B B449                    	mov	ah,49h
 12365                                  	;mov	ah,DEALLOC		; free it up...
 12366 00000D8D CD21                    	int	21h
 12367                                  	; 14/02/2023
 12368                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12369 00000D8F FF0E[9701]              	dec	word [Nest]		; is there another batch file?
 12370 00000D93 75D9                    	jnz	short _ClearBatch	; keep going until no batch file
 12371                                  	
 12372 00000D95 880E[8801]              	mov	[EchoFlag],cl		;restore echo status
 12373 00000D99 C706[3401]0000          	mov	word [Batch],0		;no batch process in progress
 12374                                  fb_ret:
 12375 00000D9F 07                      	pop	es
 12376 00000DA0 C3                      	ret
 12377                                  
 12378                                  ;free_batch endp
 12379                                  
 12380                                  ;============================================================================
 12381                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12382                                  ;============================================================================
 12383                                  ; 10/10/2018 - Retro DOS v3.0
 12384                                  
 12385                                  ; All batch proccessing has DS set to segment of resident portion
 12386                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12387                                  
 12388                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12389                                  
 12390                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12391                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12392                                  
 12393                                  ; ---------------------------------------------------------------------------
 12394                                  
 12395                                  	; 15/02/2023
 12396                                  FORTERM:
 12397                                  	; MSDOS 6.0
 12398 00000DA1 0E                      	push	cs			;AN037; Get local segment into
 12399 00000DA2 1F                      	pop	ds			;AN037;  DS, ES
 12400 00000DA3 0E                      	push	cs			;AN037;
 12401 00000DA4 07                      	pop	es			;AN037;
 12402                                  
 12403                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12404 00000DA5 E89502                  	call	FOROFF
 12405                                  	;mov	ds,[cs:RESSEG]
 12406 00000DA8 268E1E[C58A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12407 00000DAD 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 12408 00000DB3 750F                    	jne	short BAT_CRLF
 12409 00000DB5 833E[9701]00            	cmp	word [Nest],0		;See if we have nested batch files
 12410 00000DBA 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12411 00000DBC C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12412 00000DC2 EB12                    	jmp	short NOFORP2
 12413                                  BAT_CRLF:
 12414 00000DC4 F606[8801]01            	test	byte [EchoFlag],1 	; Is echo on?
 12415 00000DC9 740B                    	jz	short NOFORP2		; no - exit
 12416 00000DCB F706[3401]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12417                                  					; print CRLF if in batch
 12418 00000DD1 7403                    	jz	short NOFORP2
 12419 00000DD3 E8FB17                  	call	CRLF2
 12420                                  NOFORP2:
 12421 00000DD6 E92BF3                  	jmp	TCOMMAND
 12422                                  
 12423                                  ; ---------------------------------------------------------------------------
 12424                                  
 12425                                  ;------
 12426                                  ;   For-loop processing. For loops are of the form:
 12427                                  ;	    for %<loop-variable> in (<list>) do <command>
 12428                                  ; where <command> may contain references of the form %<variable>, which are
 12429                                  ; later substituted with the items in <list>. The for-loop structure is
 12430                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12431                                  ; <command> once for each item in <list>. All of the information needed for
 12432                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12433                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12434                                  ; a complete copy of the original command-line structure as parsed by
 12435                                  ; 'parseline', loop control variables, and a dma buffer for the
 12436                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12437                                  ; processing has completed, this chunk of memory is returned to the system.
 12438                                  ;
 12439                                  ;   All of the previously defined variables, in 'datares', used for loop
 12440                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12441                                  ;
 12442                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12443                                  ; containing all of the other error messages.
 12444                                  ;
 12445                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12446                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12447                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12448                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12449                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12450                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12451                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12452                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12453                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12454                                  ; instead of
 12455                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12456                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12457                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12458                                  ; doesn't matter whether we put brackets around the location or not -- the
 12459                                  ; assembler is "smart" enough to know that we want an address instead of the
 12460                                  ; contents of that location.
 12461                                  ;
 12462                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12463                                  ; One method would be to have a link field in each for-structure pointing to
 12464                                  ; its parent.  Variable references that couldn't be resolved in the local
 12465                                  ; frame would cause a search of prior frames. For-structures would still be
 12466                                  ; allocated and released in exactly the same fashion. The only limit on the
 12467                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12468                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12469                                  ; maintained in the resident data area. This structure would be an array of
 12470                                  ; control-variable names and pointers to for-structure blocks. This would
 12471                                  ; greatly speed up the resolution of non-local variable references. However,
 12472                                  ; since space in the resident is precious, we would have to compromise on a
 12473                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12474                                  ; allocation and de-allocation would have to be modified slightly to take this
 12475                                  ; new structure into account.
 12476                                  ;
 12477                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12478                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12479                                  ; it may be easier to allocate it as part of 'for_segment'.
 12480                                  ;------
 12481                                  		; include fordata.asm
 12482                                  
 12483                                  ; Data structure definitions included by tfor.asm
 12484                                  
 12485                                  struc FOR_INFO
 12486 00000000 <res 444h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12487 00000444 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12488 00000445 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12489 00000447 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12490 00000449 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12491 0000044B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12492 000004CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12493 0000054B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12494                                    .size:
 12495                                  endstruc
 12496                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12497                                  					; ARG_UNIT.SIZE = 1092 ; 27/07/2024
 12498                                  _$FOR_EXIT:
 12499 00000DD9 EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12500                                  
 12501                                  ; ---------------------------------------------------------------------------
 12502                                  
 12503                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12504                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12505                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 12506                                  FORPROC:
 12507 00000DDB A1[9501]                	mov	ax,[ForPtr]
 12508 00000DDE 8ED8                    	mov	ds,ax
 12509 00000DE0 8EC0                    	mov	es,ax			; operate in for-info area
 12510                                  	;;mov	dx,5CBh	; MSDOS 5.0 & 6.22
 12511                                  	;mov	dx,4CBh ; PCDOS 7.1 ; 27/07/2024
 12512 00000DE2 BACB04                  	mov	dx,FOR_INFO.FORDMA	; 1348+1+2+2+2+128 = 1483 = 5CBh
 12513                                  		; PCDOS 7.1 COMMAND.COM ; 1092+1+2+2+2+128 = 1227 = 4CBh
 12514 00000DE5 B8001A                  	mov	ax,1A00h
 12515                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12516 00000DE8 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12517                                  			; DS:DX	-> disk	transfer buffer
 12518                                  FOR_BEGIN:
 12519                                  	;;cmp	word [545h],0
 12520                                  	;cmp	word [445h] ; 27/07/2024
 12521 00000DEA 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12522 00000DEF 7404                    	jz	short FOR_BEGIN1
 12523                                  					; non-zero for_expand equals FALSE
 12524                                  	;;inc	word [547h]
 12525                                  	;inc	word [447h] ; 27/07/2024
 12526 00000DF1 FF064704                	inc	word [FOR_INFO.FOR_MINARG]
 12527                                  FOR_BEGIN1:
 12528                                  	;mov	bx,[447h] ; 27/07/2024
 12529 00000DF5 8B1E4704                	mov	bx,[FOR_INFO.FOR_MINARG] ; current item in <list> to examine
 12530                                  	;cmp	bx,[449h] ; 27/07/2024
 12531 00000DF9 3B1E4904                	cmp	bx,[FOR_INFO.FOR_MAXARG]
 12532 00000DFD 7FDA                     	jg	short _$FOR_EXIT	; exceeding maxarg means all done
 12533                                  	;mov	ax,0
 12534 00000DFF B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12535 00000E02 E84923                  	call	argv_calc		; compute argv[x] address
 12536                                  	;mov	cx,[bx+3]
 12537 00000E05 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12538 00000E08 8B17                    	mov	dx,[bx]
 12539                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12540                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12541 00000E0A F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12542 00000E0E 7512                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12543 00000E10 8B37                    	mov	si,[bx]
 12544                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12545                                  
 12546                                  	;mov	al,[cs:LPAREN]
 12547                                  	; 15/02/2023
 12548                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12549                                  	;mov	al,'('	; mov al,lparen
 12550                                  	;cmp	[si-1],	al		; If the current token is the first
 12551                                  	; 27/07/2024
 12552 00000E12 807CFF28                	cmp	byte [si-1],'('
 12553 00000E16 750A                    	jne	short FORSUB		;  one in the list and originally had
 12554 00000E18 41                      	inc	cx			;  the opening paren as its first char,
 12555                                  					;  the argstartel ptr needs to be
 12556                                  					;  advanced passed it before the prefix
 12557                                  					;  length is computed.
 12558                                  	;mov	al,':'
 12559                                  	;cmp	[si+1],	al		; If the token begins with "(d:",
 12560                                  	; 27/07/2024
 12561 00000E19 807C013A                	cmp	byte [si+1],':'
 12562 00000E1D 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12563 00000E1F 83C102                  	add	cx,2			;  rest of the prefix as well.
 12564                                  FORSUB:
 12565 00000E22 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12566                                  	;;cmp	word [545h],0
 12567                                  	;cmp	word [445h],0 ; 27/07/2024
 12568 00000E24 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12569                                  					; are we still expanding a name?
 12570 00000E29 7416                    	jz	short FOR_FIND_NEXT
 12571                                  					; if so, get next matching filename
 12572                                  	;test	byte [bx+2],2
 12573 00000E2B F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12574 00000E2F 7505                    	jnz	short FOR_FIND_FIRST
 12575                                  					; should we expand THIS (new) arg?
 12576                                  	;mov	cx,[bx+5]
 12577                                  					; else, just copy all of it directly
 12578 00000E31 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12579 00000E34 EB1D                    	jmp	short FOR_SMOOSH
 12580                                  
 12581                                  	;nop
 12582                                  	; 15/02/2023
 12583                                  FOR_FIND_FIRST:
 12584 00000E36 51                      	push	cx
 12585 00000E37 31C9                    	xor	cx,cx
 12586 00000E39 B8004E                  	mov	ax,4E00h
 12587                                  	;mov	ax,Find_First*256 ; 4E00h
 12588 00000E3C CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12589                                  			; CX = search attributes
 12590                                  			; DS:DX	-> ASCIZ filespec
 12591                                  			; (drive,path, and wildcards allowed)
 12592 00000E3E 59                      	pop	cx
 12593 00000E3F EB05                    	jmp	short FOR_RESULT
 12594                                  
 12595                                  	;nop
 12596                                  FOR_FIND_NEXT:
 12597 00000E41 B8004F                  	mov	ax,4F00h
 12598                                  	;mov	ax,Find_Next*256 ;4F00h
 12599 00000E44 CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12600                                  			; [DTA]	= data block from
 12601                                  			; last AH = 4Eh/4Fh call
 12602                                  FOR_RESULT:
 12603 00000E46 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12604 00000E49 7201                    	jc	short FOR_CHECK
 12605                                  	; 15/02/2023
 12606 00000E4B 40                      	inc	ax ; ax = 0
 12607                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12608                                  FOR_CHECK:				; record success of findfirst/next
 12609                                  	;;mov	[545h],ax
 12610                                  	;mov	[445h],ax ; 27/07/2024
 12611 00000E4C A34504                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12612 00000E4F 09C0                    	or	ax,ax			; anything out there?
 12613 00000E51 7597                    	jnz	short FOR_BEGIN		; if not, try next arg
 12614                                  FOR_SMOOSH:
 12615                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12616 00000E53 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12617                                  	;;mov	di,54Bh	; MSDOS 5.0 & 6.22 COMMAND.COM
 12618                                  	;mov	di,44Bh ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12619 00000E55 BF4B04                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12620 00000E58 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12621                                  					
 12622 00000E5A 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12623                                  					; if we're not expanding, we can
 12624 00000E5F 7509                    	jnz	short FOR_MAKE_COM 	; skip the following
 12625                                  	; 15/02/2023
 12626                                  	;;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.22 COMMAND.COM ; 27/07/2024
 12627                                  	; 27/07/2024
 12628                                  	;mov	si,04E9h ; PCDOS 7.1 COMMAND.COM
 12629 00000E61 BEE904                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12630                                  FOR_MORE:
 12631                                  	;cmp	byte [si],0		; tack on matching filename
 12632                                  	;jz	short FOR_MAKE_COM
 12633                                  	;movsb
 12634                                  	;jnz	short FOR_MORE
 12635                                  	; 25/04/2023
 12636 00000E64 AC                      	lodsb
 12637 00000E65 AA                      	stosb
 12638 00000E66 08C0                    	or	al,al
 12639 00000E68 75FA                    	jnz	short FOR_MORE
 12640                                  FOR_MAKE_COM:
 12641                                  	; 25/04/2023
 12642                                  	;xor	al,al			; tack a null byte onto the end
 12643                                  	;stosb				; of the substitute string
 12644 00000E6A 31C9                    	xor	cx,cx			; character count for command line
 12645 00000E6C F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12646 00000E6E 31DB                    	xor	bx,bx			; argpointer
 12647 00000E70 BF[2689]                	mov	di,COMBUF+2
 12648                                  	; 15/02/2023
 12649                                  	;;mov	bl,[544h] ; MSDOS 5.0-6.22 ; 27/07/2024
 12650                                  	; 27/07/2024
 12651                                  	;mov	bl,[444h] ; PCDOS 7.1 COMMAND.COM 
 12652 00000E73 8A1E4404                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12653                                  	;;mov	dh,[64Bh]
 12654                                  	;mov	dh,[54Bh] ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12655 00000E77 8A364B05                	mov	dh,[FOR_INFO.FOR_VAR]
 12656                                  					; %<for-var> is replaced by [forbuf]
 12657 00000E7B 0E                      	push	cs			; time to form the <command> string
 12658 00000E7C 07                      	pop	es
 12659                                  	;assume ES:trangroup
 12660                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12661 00000E7D B80000                  	mov	ax,0			; translate offset to pointer
 12662 00000E80 E8CB22                  	call	argv_calc
 12663                                  	;mov	si,[bx+9]
 12664 00000E83 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr]
 12665                                  					; mov ptr passed beginning space
 12666 00000E86 46                      	inc	si
 12667                                  FOR_MAKE_LOOP:
 12668 00000E87 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12669 00000E89 46                      	inc	si
 12670 00000E8A 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12671 00000E8C 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12672 00000E8E 3834                    	cmp	[si],dh			; got the right <variable>?
 12673 00000E90 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12674 00000E92 46                      	inc	si			; skip over <for-variable>
 12675                                  
 12676 00000E93 56                      	push	si
 12677                                  	; 15/02/2023
 12678                                  	;;mov	si,54Bh	; MSDOS 5.0-6.22 ; 27/07/2024
 12679                                  	; 27/07/2024
 12680                                  	;mov	si,44Bh ; PCDOS 7.1 COMMAND.COM
 12681 00000E94 BE4B04                  	mov	si,FOR_INFO.FORBUF
 12682                                  					; substitute the <item> for <variable>
 12683                                  					; to make a final <command> to execute
 12684                                  SLOOP:					
 12685 00000E97 AC                      	lodsb				; grab all those <item> bytes, and
 12686 00000E98 AA                      	stosb				; add 'em to the <command> string,
 12687 00000E99 08C0                    	or	al,al			; until we run into a null
 12688 00000E9B E0FA                    	loopne	SLOOP
 12689 00000E9D 4F                      	dec	di			; adjust length and <command> pointer
 12690 00000E9E 41                      	inc	cx			; so we can overwrite the null
 12691 00000E9F 5E                      	pop	si
 12692 00000EA0 EBE5                    	jmp	short FOR_MAKE_LOOP
 12693                                  					; got back for more <command> bytes
 12694                                  FOR_STOSB:
 12695 00000EA2 AA                      	stosb				; take a byte from the <command> arg
 12696 00000EA3 49                      	dec	cx			; and put it into the <command> to be
 12697                                  					; executed (and note length, too)
 12698 00000EA4 3C0D                    	cmp	al,0Dh
 12699 00000EA6 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12700                                  FOR_MADE_COM:
 12701 00000EA8 F6D1                    	not	cl
 12702                                  	;mov	[cs:COMBUF+1],cl
 12703                                  	;mov	ds,[cs:RESSEG]
 12704                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12705                                  	; MSDOS 5.0 COMMAND.COM
 12706 00000EAA 26880E[2589]            	mov	[es:COMBUF+1],cl
 12707 00000EAF 268E1E[C58A]            	mov	ds,[es:RESSEG]
 12708                                  	;assume DS:resgroup
 12709 00000EB4 F606[8801]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12710 00000EB9 742F                    	jz	short NOECHO3
 12711                                  	;cmp	byte [NullFlag],nullcommand
 12712 00000EBB 803E[9D01]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12713 00000EC0 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf
 12714                                  
 12715 00000EC2 E80C17                  	call	CRLF2		  	;G Print out prompt
 12716                                  NO_CRLF_PR:
 12717 00000EC5 C606[9D01]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12718 00000ECA 0E                      	push	cs
 12719 00000ECB 1F                      	pop	ds
 12720 00000ECC 57                      	push	di
 12721 00000ECD E8C30E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12722 00000ED0 5F                      	pop	di
 12723                                  
 12724 00000ED1 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12725 00000ED6 C706[358C][2689]        	mov	word [string_ptr_2],COMBUF+2
 12726                                  	; 17/04/2023
 12727 00000EDC BA[E280]                	mov	dx,string_buf_ptr
 12728 00000EDF E80D3F                  	call	std_printf
 12729 00000EE2 26C645FF0D              	mov	byte [es:di-1],0Dh
 12730 00000EE7 E9EAF3                  	jmp	DOCOM		  	; run silent, run deep...
 12731                                  NOECHO3:
 12732 00000EEA C606[9D01]00            	mov	byte [NullFlag],0
 12733 00000EEF 0E                      	push	cs
 12734 00000EF0 1F                      	pop	ds
 12735 00000EF1 E9E3F3                  	jmp	DOCOM1
 12736                                  
 12737                                  FORNESTERRJ:				; no multi-loop processing... yet!
 12738 00000EF4 E84601                  	call	FOROFF
 12739 00000EF7 E92901                  	jmp	FORNESTERR
 12740                                  
 12741                                  ; ---------------------------------------------------------------------------
 12742                                  
 12743                                  FORERRORJ:
 12744 00000EFA E9DDFB                  	jmp	FORERROR
 12745                                  
 12746                                  ; ---------------------------------------------------------------------------
 12747                                  
 12748                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F24h
 12749                                  
 12750                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12751                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 12752                                  
 12753                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12754                                  	; PCDOS 7.1 COMMAND.COM - TRANGROUP:1040h
 12755                                  _$FOR:
 12756 00000EFD 8E06[C58A]              	mov	es,[RESSEG]
 12757 00000F01 26803E[9401]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12758 00000F07 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12759                                  
 12760                                  ; Turn off any pipes in progress.
 12761                                  
 12762 00000F09 26803E[0102]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12763 00000F0F 7403                    	jz	short NO_PIPE
 12764 00000F11 E8D91D                  	call	PIPEDEL
 12765                                  NO_PIPE:
 12766 00000F14 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12767 00000F16 E8F400                  	call	NEXTARG			; move to next argv[n]
 12768 00000F19 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12769 00000F1B 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12770 00000F1D 75DB                    	jne	short FORERRORJ
 12771 00000F1F 89C5                    	mov	bp,ax			; save forloop variable
 12772 00000F21 AC                      	lodsb
 12773 00000F22 08C0                    	or	al,al			; and MUST end immediately...
 12774 00000F24 75D4                    	jnz	short FORERRORJ
 12775 00000F26 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12776 00000F29 72CF                    	jb	short FORERRORJ
 12777                                  	;and	ax,0DFDFh
 12778 00000F2B 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12779                                  	; 15/02/2023
 12780                                  	;cmp	ax,4E49h  	; MSDOS 5.0
 12781                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12782                                  	;cmp	ax,in_word	; MSDOS 5.0
 12783 00000F2E 3D494E                  	cmp	ax,'IN'
 12784 00000F31 75C7                    	jnz	short FORERRORJ
 12785 00000F33 AC                      	lodsb
 12786                                  
 12787                                  	; 15/02/2023
 12788                                  	; MSDOS 3.3
 12789                                  	;or	al,al			; it, too, must end right away
 12790                                  	;jz	short CHECKLPAREN
 12791                                  	;cmp	al,[LPAREN]
 12792                                  	;jnz	short FORERRORJ
 12793                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12794                                  	;add	word [bx],2
 12795                                  	;;add	word [bx+9],2
 12796                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12797                                  	;;sub	word [bx+5],2
 12798                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12799                                  	;mov	ax,[si-1]
 12800                                  	;jmp	short LPCHECK
 12801                                  
 12802                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12803                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12804                                  
 12805                                  	; MSDOS 6.0
 12806                                  ; Compaq bug fix -- exit from this loop on error
 12807                                  
 12808 00000F34 08C0                    	or	al,al
 12809 00000F36 75C2                    	jne	short FORERRORJ		; jump on error
 12810                                  
 12811                                  ;	je	short CHECKLPAREN
 12812                                  ;
 12813                                  ; Not null. Perhaps there are no spaces between this and the (:
 12814                                  ;   FOR %i in(foo bar...
 12815                                  ; Check for the Lparen here
 12816                                  ;
 12817                                  ;;	cmp	al,lparen
 12818                                  ;;	jnz	short FORERRORJ
 12819                                  ;
 12820                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12821                                  ; being there in the first place.
 12822                                  ;
 12823                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12824                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12825                                  ;;						; advance original string
 12826                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12827                                  ;
 12828                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12829                                  ; current value.
 12830                                  ;
 12831                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12832                                  ;;	jmp	short LPCHECK
 12833                                  ;
 12834                                  ; end of Compaq bug fix
 12835                                  
 12836                                  ; ---------------------------------------------------------------------------
 12837                                  
 12838                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12839                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12840                                  
 12841                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12842                                  CHECKLPAREN:
 12843 00000F38 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12844 00000F3B 72BD                    	jc	short FORERRORJ
 12845                                  LPCHECK:
 12846                                  	; 15/02/2023
 12847                                  	; MSDOS 5.0 (% MSDOS 6.0)
 12848                                  	;;cmp	al,[LPAREN]
 12849                                  	;cmp	al,lparen
 12850 00000F3D 3C28                    	cmp	al,'('
 12851 00000F3F 75B9                    	jne	short FORERRORJ
 12852 00000F41 80FC00                  	cmp	ah,0
 12853 00000F44 7410                    	je	short FOR_PAREN_TOKEN
 12854                                  	;;cmp	ah,[RPAREN]		; special case:  null list
 12855                                  	;cmp	ah,rparen
 12856 00000F46 80FC29                  	cmp	ah,')'
 12857 00000F49 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12858 00000F4B E953FE                  	jmp	FORTERM
 12859                                  FOR_LIST_NOT_EMPTY:
 12860                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12861 00000F4E FF07                    	inc	word [bx]		; Advance ptr past "("
 12862                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry
 12863 00000F50 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12864 00000F53 46                      	inc	si			; Inc si so check for ")" works
 12865 00000F54 EB0D                    	jmp	short FOR_LIST
 12866                                  
 12867                                  	;nop
 12868                                  FOR_PAREN_TOKEN:
 12869 00000F56 E8B400                  	call	NEXTARG			; what have we in our <list>?
 12870 00000F59 729F                    	jc	short FORERRORJ
 12871                                  	; 15/02/2023
 12872                                  	;;;cmp	ax,[RPAREN+1]
 12873                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12874                                  	;cmp	ax,nullrparen
 12875 00000F5B 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12876 00000F5E 7503                    	jne	short FOR_LIST
 12877 00000F60 E93EFE                  	jmp	FORTERM
 12878                                  
 12879                                  ;FORERORJJ:
 12880                                  	;jmp	FORERROR
 12881                                  
 12882                                  FOR_LIST:				; skip over rest of <list>
 12883 00000F63 89D1                    	mov	cx,dx			; first arg of <list>
 12884                                  
 12885                                  SKIP_LIST:
 12886                                  	;add	si,[bx+5]
 12887 00000F65 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12888 00000F68 83EE03                  	sub	si,3			; si = ptr to last char of token
 12889                                  	; 15/02/2023
 12890                                  	;;mov	al,[RPAREN]
 12891                                  	;mov	al,rparen
 12892 00000F6B B029                    	mov	al,')'
 12893 00000F6D 3804                    	cmp	[si],al			; Is this the last element in <list>
 12894 00000F6F 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12895 00000F71 E89900                  	call	NEXTARG			; No, get next arg <list>
 12896                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12897                                  	;jmp	short SKIP_LIST
 12898                                  	; 15/02/2023
 12899 00000F74 73EF                    	jnc	short SKIP_LIST
 12900                                  
 12901                                  	; 15/02/2023
 12902                                  FORERORJJ:
 12903 00000F76 E961FB                  	jmp	FORERROR
 12904                                  
 12905                                  FOR_END_LIST:
 12906 00000F79 89D7                    	mov	di,dx			; record position of last arg in <list>
 12907 00000F7B C60400                  	mov	byte [si],0		; Zap the rparen
 12908                                  	; 15/02/2023
 12909                                  	;;;cmp	ax,[RPAREN+1]
 12910                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12911                                  	;cmp	ax,nullparen
 12912 00000F7E 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12913 00000F81 7401                    	je	short FOR_DO		; Yes, continue
 12914 00000F83 47                      	inc	di			; No, inc position of last arg
 12915                                  FOR_DO:
 12916 00000F84 E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12917 00000F87 72ED                    	jc	short FORERORJJ
 12918                                  	;and	ax,0DFDFh
 12919 00000F89 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12920                                  	; 15/02/2023
 12921                                  	;;cmp	ax,[DO_WORD]
 12922                                  	;cmp	ax,do_word ; 4F44h
 12923 00000F8C 3D444F                  	cmp	ax,'DO'	 ; 4F44h
 12924 00000F8F 75E5                    	jne	short FORERORJJ
 12925 00000F91 AC                      	lodsb
 12926 00000F92 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12927 00000F94 75E0                    	jnz	short FORERORJJ
 12928                                  		
 12929 00000F96 E87400                  	call	NEXTARG			; on to the beginning of <command>
 12930 00000F99 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12931                                  
 12932 00000F9B 50                      	push	ax
 12933 00000F9C 53                      	push	bx
 12934 00000F9D 51                      	push	cx
 12935 00000F9E 52                      	push	dx			; preserve registers against disaster
 12936 00000F9F 57                      	push	di
 12937 00000FA0 56                      	push	si
 12938 00000FA1 55                      	push	bp
 12939 00000FA2 E85FF7                  	call	FREE_TPA		; need to make free memory, first
 12940 00000FA5 E89500                  	call	FOROFF
 12941                                  	;mov	bx,264
 12942 00000FA8 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12943 00000FAB E8C524                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12944 00000FAE 9C                      	pushf
 12945 00000FAF 26A3[9501]              	mov	[es:ForPtr],ax
 12946 00000FB3 E85EF7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12947 00000FB6 9D                      	popf
 12948 00000FB7 5D                      	pop	bp
 12949 00000FB8 5E                      	pop	si
 12950 00000FB9 5F                      	pop	di
 12951 00000FBA 5A                      	pop	dx
 12952 00000FBB 59                      	pop	cx
 12953 00000FBC 5B                      	pop	bx
 12954 00000FBD 58                      	pop	ax
 12955 00000FBE 723C                    	jc	short FOR_ALLOC_ERR
 12956                                  
 12957 00000FC0 06                      	push	es			; save resgroup seg...
 12958 00000FC1 26FF36[9501]            	push	word [es:ForPtr]
 12959 00000FC6 07                      	pop	es
 12960                                  	;assume es:for_segment
 12961 00000FC7 49                      	dec	cx			; forproc wants min pointing before
 12962 00000FC8 4F                      	dec	di			; first arg, max right at last one
 12963                                  	; 15/02/2023
 12964                                  	;;mov	[547h],cx
 12965                                  	; 27/07/2024
 12966                                  	;mov	[447h],cx ; PCDOS 7.1 COMMAND.COM
 12967 00000FC9 26890E4704              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12968                                  	;;mov	[549h],di
 12969                                  	;mov	[449h],di ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12970 00000FCE 26893E4904              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12971                                  	;;mov	[544h],dl
 12972                                  	;mov	[444h],dl ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12973 00000FD3 2688164404              	mov	[es:FOR_INFO.FOR_COM_START],dl
 12974                                  	;;mov	word [545h],0FFFFh ; -1
 12975                                  	;mov	[445h],0FFFFh ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 12976 00000FD8 26C7064504FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 12977                                  					; non-zero means FALSE
 12978 00000FDF 89E8                    	mov	ax,bp
 12979                                  	;;mov	[64Bh],ah
 12980                                  	;mov	[54Bh],ah ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12981 00000FE1 2688264B05              	mov	[es:FOR_INFO.FOR_VAR],ah
 12982 00000FE6 07                      	pop	es
 12983                                  	;assume es:resgroup
 12984 00000FE7 26FE06[9401]            	inc	byte [es:ForFlag]
 12985 00000FEC 26833E[8E01]FF          	cmp	word [es:SingleCom],-1
 12986 00000FF2 7507                    	jne	short FOR_RET
 12987 00000FF4 26C706[8E01]00FF        	mov	word [es:SingleCom],0FF00h
 12988                                  FOR_RET:
 12989 00000FFB C3                      	retn
 12990                                  
 12991                                  FOR_ALLOC_ERR:
 12992                                  	; 15/02/2023
 12993                                  	; MSDOS 3.3
 12994                                  	;mov	dx,INSFMEMMESPTR
 12995                                  	;jmp	CERROR
 12996                                  
 12997                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12998                                  	; MSDOS 6.0
 12999                                  	;mov	byte [msg_disp_class],1
 13000 00000FFC C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 13001                                  					;AN000; set up extended error msg class
 13002                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 13003 00001001 BA[1B7F]                	mov	dx,extend_buf_ptr
 13004                                  					;AC000; get extended message pointer
 13005                                  	;mov	word [extend_buf_ptr],8
 13006 00001004 C706[1B7F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13007                                  					;AN000; get message number in control block
 13008 0000100A E94519                  	jmp	cerror
 13009                                  
 13010                                  
 13011                                  ; =============== S U B	R O U T	I N E =======================================
 13012                                  
 13013                                  NEXTARG:
 13014 0000100D 42                      	inc	dx			; next argv[n]
 13015                                  	;cmp	dx,[ARG_ARGVCNT]
 13016 0000100E 3B16[9490]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13017                                  					; make sure we don't run off end
 13018 00001012 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13019 00001014 89D3                    	mov	bx,dx
 13020                                  	;mov	ax,ARG_ARGV
 13021                                  	;mov	ax,ARG+ARG_UNIT.argv
 13022 00001016 B8[D48D]                	mov	ax,ARG
 13023 00001019 E83221                  	call	argv_calc		; convert array index to pointer
 13024 0000101C 8B37                    	mov	si,[bx]			; load pointer to argstring
 13025                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13026 0000101E AD                      	lodsw				; and load first two chars
 13027 0000101F F8                      	clc
 13028 00001020 C3                      	retn
 13029                                  NEXTARG_ERR:
 13030 00001021 F9                      	stc
 13031 00001022 C3                      	retn
 13032                                  
 13033                                  ; ---------------------------------------------------------------------------
 13034                                  
 13035                                  FORNESTERR:
 13036 00001023 1E                      	push	ds
 13037 00001024 8E1E[C58A]              	mov	ds,[RESSEG]
 13038                                  	;ASSUME DS:RESGROUP
 13039 00001028 BA[7980]                	mov	dx,FORNESTMES_PTR
 13040 0000102B 813E[8E01]00FF          	cmp	word [SingleCom],0FF00h
 13041 00001031 7506                    	jne	short NOFORP3
 13042 00001033 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13043                                  NOFORP3:
 13044 00001039 1F                      	pop	ds
 13045 0000103A E91519                  	jmp	cerror
 13046                                  
 13047                                  ; =============== S U B	R O U T	I N E =======================================
 13048                                  
 13049                                  ; General routine called to free the for segment. We also clear the forflag
 13050                                  ; too. Change no registers.
 13051                                  
 13052                                  FOROFF:
 13053 0000103D 50                      	push	ax
 13054 0000103E 06                      	push	es
 13055 0000103F 2E8E06[C58A]            	mov	es,[cs:RESSEG]
 13056 00001044 26A1[9501]              	mov	ax,[es:ForPtr]
 13057 00001048 09C0                    	or	ax,ax
 13058 0000104A 7408                    	jz	short FREEDONE
 13059 0000104C 06                      	push	es
 13060 0000104D 8EC0                    	mov	es,ax
 13061                                  	; 15/02/2023
 13062 0000104F B449                    	mov	ah,49h
 13063                                  	;mov	ah,DEALLOC ; 49h
 13064 00001051 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13065                                  			; ES = segment address of area to be freed
 13066 00001053 07                      	pop	es
 13067                                  FREEDONE:
 13068 00001054 26C706[9501]0000        	mov	word [es:ForPtr],0
 13069 0000105B 26C606[9401]00          	mov	byte [es:ForFlag],0
 13070 00001061 07                      	pop	es
 13071 00001062 58                      	pop	ax
 13072 00001063 C3                      	retn
 13073                                  
 13074                                  ;============================================================================
 13075                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13076                                  ;============================================================================
 13077                                  ; 09/10/2018 - Retro DOS v3.0
 13078                                  
 13079                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13080                                  
 13081                                  ; ---------------------------------------------------------------------------
 13082                                  
 13083                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13084                                  
 13085                                  %if 0
 13086                                  
 13087                                  ; The DIR command displays the contents of a directory.
 13088                                  ;
 13089                                  ; ****************************************************************
 13090                                  ; *
 13091                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13092                                  ; *
 13093                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13094                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13095                                  ; *		 If an error occurs issue and error message and
 13096                                  ; *		 transfer control to CERROR.
 13097                                  ; *
 13098                                  ; * INPUT:	 command line at offset 81H
 13099                                  ; *
 13100                                  ; * OUTPUT:	 none
 13101                                  ; *
 13102                                  ; ****************************************************************
 13103                                  
 13104                                  CATALOG:
 13105                                  	; MSDOS 3.3
 13106                                  
 13107                                  	;mov	ax,ARG_ARGV
 13108                                  	;mov	ax,ARG+ARG_UNIT.argv
 13109                                  	mov	ax,ARG
 13110                                  	mov	dx,0FFFFh
 13111                                  	xor	cx,cx
 13112                                  	xor	si,si
 13113                                  DIR1:
 13114                                  	;cmp	cx,[ARG_ARGVCNT]
 13115                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13116                                  	jnb	short DIR6 ; No more arguments
 13117                                  	mov	bx,cx
 13118                                  	call	ARGV_CALC
 13119                                  	;or	si,[bx+7]
 13120                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13121                                  	test	si,7FFCh  ; test si,~8003
 13122                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13123                                  	;test	byte [bx+2],1
 13124                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13125                                  	jz	short DIR3
 13126                                  	jmp	short DIR5
 13127                                  DIR2:
 13128                                  	mov	dx,BADPARMPTR
 13129                                  	jmp	CERROR
 13130                                  DIR3:
 13131                                  	or	cx,cx
 13132                                  	jnz	short DIR4	
 13133                                  	;cmp	word [bx+5],3
 13134                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13135                                  	jz	short DIR5
 13136                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13137                                  	add	word [bx],3
 13138                                  	;add	word [bx+9],3
 13139                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13140                                  	;add	word [bx+3],3
 13141                                  	add	word [bx+ARGV_ELE.argstartel],3
 13142                                  	;sub	word [bx+5],3
 13143                                  	sub	word [bx+ARGV_ELE.arglen],3
 13144                                  DIR4:
 13145                                  	cmp	dx,0FFFFh
 13146                                  	jnz	short DIR2
 13147                                  	mov	dx,bx
 13148                                  DIR5:
 13149                                  	inc	cx
 13150                                  	jmp	short DIR1
 13151                                  DIR6:
 13152                                  	mov	[COMSW],si
 13153                                  	push	dx
 13154                                  	xor	al,al
 13155                                  	cmp	dx,0FFFFh
 13156                                  	jz	short DIR7
 13157                                  	mov	bx,dx
 13158                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13159                                  	mov	di,[bx]
 13160                                  	cmp	byte [di+1],':'
 13161                                  	jnz	short DIR7
 13162                                  	mov	al,[di]
 13163                                  	or	al,20h		; Lowercase drive name	
 13164                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13165                                  DIR7:
 13166                                  	;mov	[5CH],al
 13167                                  	mov	[FCB],al
 13168                                  	call	OKVOLARG
 13169                                  	mov	al,'?'		; *.* is default file spec.
 13170                                  	;mov	di,5Dh
 13171                                  	mov	di,FCB+1
 13172                                  	mov	cx,11
 13173                                  	rep stosb
 13174                                  
 13175                                  ; Begin by processing any switches that may have been specified.
 13176                                  ; BITS will contain any information about switches that was
 13177                                  ; found when the command line was parsed.
 13178                                  
 13179                                  	mov	ax,[COMSW]	; Get switches from command
 13180                                  	mov	[_BITS],ax	; initialize switches
 13181                                  	mov	word [COMSW],0	; initialize flags
 13182                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13183                                  	;test	al,1
 13184                                  	test	al,SWITCHW	; /W ?
 13185                                  	;mov	al,1
 13186                                  	mov	al,NORMPERLIN
 13187                                  	jz	short DIR8
 13188                                  	;mov	al,5
 13189                                  	mov	al,WIDEPERLIN
 13190                                  DIR8:
 13191                                  	mov	[LINLEN],al	; Set number of entries per line
 13192                                  	mov	[LINCNT],al
 13193                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13194                                  	mov	dx,DIRBUF
 13195                                  	mov	ah,Set_DMA ; 1Ah
 13196                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13197                                  			; DS:DX	-> disk	transfer buffer
 13198                                  	;mov	dl,[5Ch]
 13199                                  	mov	dl,[FCB]
 13200                                  	call	SAVUDIR
 13201                                  	pop	bx
 13202                                  	cmp	bx,0FFFFh
 13203                                  	jz	short DIR9
 13204                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13205                                  	mov	dx,[bx]
 13206                                  
 13207                                  ; The user may have specified a device. Search for the path and see if the
 13208                                  ; attributes indicate a device.
 13209                                  
 13210                                  	mov	ah,Find_First ; 4Eh
 13211                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13212                                  			; CX = search attributes
 13213                                  			; DS:DX	-> ASCIZ filespec
 13214                                  			; (drive,path, and wildcards allowed)
 13215                                  	jc	short DIR10
 13216                                  			; Check device atrribute..
 13217                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13218                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13219                                  	; 14/10/2018
 13220                                  	;test	byte [DIRBUF+21],40h
 13221                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13222                                  	jz	short DIR10	; no, go do normal operation
 13223                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13224                                  DIR9:
 13225                                  	jmp	short DOHEADER
 13226                                  DIR10:
 13227                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13228                                  	mov	dx,[bx]
 13229                                  	mov	ah,CHDir ; 3Bh
 13230                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13231                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13232                                  	jnc	short DOHEADER
 13233                                  	;mov	si,[bx+3]
 13234                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13235                                  	cmp	dx,si
 13236                                  	jz	short DIR_NO_DRIVE
 13237                                  	xor	cl,cl
 13238                                  	xchg	cl,[si]
 13239                                  	mov	ah,CHDir ; 3Bh
 13240                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13241                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13242                                  	xchg	cl,[si]
 13243                                  	jnc	short DIR_NO_DRIVE
 13244                                  	mov	al,[si-1]
 13245                                  	call	PATHCHRCMP
 13246                                  	jnz	short DIR11
 13247                                  	mov	al,[si-2]
 13248                                  	call	PATHCHRCMP
 13249                                  	jz	short DIR12
 13250                                  	xchg	cl,[si-1]
 13251                                  	mov	ah,CHDir ; 3Bh
 13252                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13253                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13254                                  	xchg	cl,[si-1]
 13255                                  	jnc	short DIR_NO_DRIVE
 13256                                  DIR11:
 13257                                  	mov	ch,':'
 13258                                  	cmp	ch,[si-1]
 13259                                  	jnz	short DIR12
 13260                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13261                                  	mov	cx,[bx]
 13262                                  	xchg	cx,si
 13263                                  	sub	cx,si
 13264                                  	cmp	cx,2
 13265                                  	jz	short DIR_NO_DRIVE
 13266                                  DIR12:
 13267                                  	mov	dx,BADCDPTR
 13268                                  	;test	byte [bx+2],4
 13269                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13270                                  	jnz	short DIRERROR
 13271                                  DIRNF:
 13272                                  	mov	dx,FNOTFOUNDPTR
 13273                                  DIRERROR:
 13274                                  	jmp	CERROR
 13275                                  DIR_NO_DRIVE:
 13276                                  	cmp	word [si],'..'
 13277                                  	jnz	short DOREALPARSE
 13278                                  	cmp	byte [si+2],0
 13279                                  	jnz	short DOREALPARSE
 13280                                  	inc	word [COMSW]
 13281                                  	jmp	short DOHEADER
 13282                                  DOREALPARSE:
 13283                                  	mov	di,FCB ; 5Ch	
 13284                                  	;mov	ax,290Eh
 13285                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13286                                  	int	21h	; DOS -	PARSE FILENAME
 13287                                  			; DS:SI	-> string to parse
 13288                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13289                                  			; AL = bit mask	to control parsing
 13290                                  	cmp	byte [si],0
 13291                                  	jz	short DOHEADER
 13292                                  	dec	word [COMSW]
 13293                                  DOHEADER:
 13294                                  		
 13295                                  ; Display the header
 13296                                  
 13297                                  	push	bx
 13298                                  	call	BUILD_DIR_STRING
 13299                                  	mov	dx,DIRBUF
 13300                                  	mov	[VOL_DIR],dx
 13301                                  	mov	dx,DIRHEADPTR
 13302                                  	call	PRINTF_CRLF
 13303                                  	pop	bx
 13304                                  	cmp	bx,0FFFFh
 13305                                  	jz	short DOSEARCH
 13306                                  
 13307                                  ; If there were chars left after parse or device, then invalid file name
 13308                                  
 13309                                  	cmp	word [COMSW],0
 13310                                  	jz	short DOSEARCH	; nothing left; good parse
 13311                                  	jl	short DIRNFFIX	; not .. => error file not found
 13312                                  	call	RESTUDIR
 13313                                  	mov	dx,BADCDPTR
 13314                                  	jmp	CERROR		; was .. => error directory not found
 13315                                  DIRNFFIX:
 13316                                  	call	RESTUDIR
 13317                                  	jmp	short DIRNF
 13318                                  
 13319                                  ; We are assured that everything is correct. Let's go and search. Use
 13320                                  ; attributes that will include finding directories. Perform the first search
 13321                                  ; and reset our directory afterward.
 13322                                  
 13323                                  DOSEARCH:
 13324                                  	;mov	byte [55h],0FFh
 13325                                  	mov	byte [FCB-7],0FFh
 13326                                  	;mov	byte [5Bh],10h
 13327                                  	mov	byte [FCB-1],10h
 13328                                  
 13329                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13330                                  ; the directory information as an extended FCB. We must bias all fetches into
 13331                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13332                                  
 13333                                  	mov	ah,Dir_Search_First ; 11h
 13334                                  	mov	dx,FCB-7 ; 55h
 13335                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13336                                  			; DS:DX	-> FCB
 13337                                  
 13338                                  ; Restore the user's directory. We preserve, though, the return from the
 13339                                  ; previous system call for later checking.
 13340                                  
 13341                                  FOUND_FIRST_FILE:
 13342                                  	push	ax		; save return state
 13343                                  	call	RESTUDIR	; restore user's dir	
 13344                                  	pop	ax		; get return state back
 13345                                  
 13346                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13347                                  ; no more.
 13348                                  
 13349                                  DIRSTART:
 13350                                  	inc	al		; 0FFh = file not found
 13351                                  	jnz	short DISPLAY	; Either an error or we are finished
 13352                                  	jmp	CHKCNT
 13353                                  DISPLAY:
 13354                                  	inc	word [FILECNT]	; Keep track of how many we find
 13355                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13356                                  	;call	SHONAME
 13357                                  	call	DISPLAYNAME
 13358                                  	;test	byte [_BITS],1
 13359                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13360                                  	jz	short DIRTEST	; If so, no size, date, or time
 13361                                  	jmp	NEXENT
 13362                                  DIRTEST:
 13363                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13364                                  	; 14/10/2018
 13365                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13366                                  	;test	byte [DIRBUF+19],10h
 13367                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13368                                  	jz	short FILEENT
 13369                                  	mov	dx,DMESPTR
 13370                                  	call	STD_PRINTF
 13371                                  	jmp	short NOFSIZ
 13372                                  FILEENT:
 13373                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13374                                  	;mov	dx,[DIRBUF+36]
 13375                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13376                                  	mov	[FILESIZE_L],dx
 13377                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13378                                  	;mov	dx,[DIRBUF+38]
 13379                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13380                                  	mov	[FILESIZE_H],dx
 13381                                  	mov	dx,FSIZEMESPTR
 13382                                  	call	STD_PRINTF	; Print size of file
 13383                                  NOFSIZ:
 13384                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13385                                  	;mov	ax,[DIRBUF+32]
 13386                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13387                                  	or	ax,ax
 13388                                  	jz	short NEXENT	; Skip if no date
 13389                                  	mov	di,CHARBUF
 13390                                  	push	ax
 13391                                  	mov	ax,'  '
 13392                                  	stosw
 13393                                  	pop	ax
 13394                                  	mov	bx,ax
 13395                                  	and	ax,1Fh		; Get day
 13396                                  	mov	dl,al
 13397                                  	mov	ax,bx
 13398                                  	mov	cl,5
 13399                                  	shr	ax,cl		; Align month
 13400                                  	and	al,0Fh		; Get month
 13401                                  	mov	dh,al
 13402                                  	mov	cl,bh
 13403                                  	shr	cl,1		; Align year
 13404                                  	xor	ch,ch
 13405                                  	add	cx,80		; Relative 1980
 13406                                  	cmp	cl,100
 13407                                  	jb	short MILLENIUM
 13408                                  	sub	cl,100
 13409                                  MILLENIUM:
 13410                                  	call	DATE_CXDX
 13411                                  	;mov	cx,[DIRBUF_FTIME]
 13412                                  	;mov	cx,[DIRBUF+30]
 13413                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13414                                  	jcxz	PRBUF		; Time field present?
 13415                                  	mov	ax,2020h
 13416                                  	stosw
 13417                                  	shr	cx,1
 13418                                  	shr	cx,1
 13419                                  	shr	cx,1
 13420                                  	shr	cl,1
 13421                                  	shr	cl,1		; Hours in CH, minutes in CL
 13422                                  	mov	bl,[TIME_24]
 13423                                  	or	bl,80h		; Tell P_TIME called from DIR
 13424                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13425                                  PRBUF:
 13426                                  	xor	ax,ax
 13427                                  	stosb
 13428                                  	mov	dx,CHARBUF
 13429                                  	mov	[STRING_PTR_2],dx
 13430                                  	mov	dx,STRINGBUF2PTR
 13431                                  	call	STD_PRINTF
 13432                                  NEXENT:
 13433                                  	dec	byte [LINCNT]
 13434                                  	jnz	short SAMLIN
 13435                                  NEXLIN:
 13436                                  	mov	al,[LINLEN]
 13437                                  	mov	[LINCNT],al
 13438                                  	call	CRLF2
 13439                                  	dec	byte [LINPERPAG]
 13440                                  	jnz	short SCROLL
 13441                                  	;test	byte [_BITS],2
 13442                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13443                                  	jz	short SCROLL	; If not, just continue
 13444                                  	mov	byte [LINPERPAG],23
 13445                                  	call	PAUSE
 13446                                  	jmp	short SCROLL
 13447                                  SAMLIN:
 13448                                  	mov	dx,TABPTR	; Output a tab
 13449                                  	call	STD_PRINTF
 13450                                  SCROLL:
 13451                                  	mov	ah,Dir_Search_Next ; 12h
 13452                                  	;mov	dx,55h
 13453                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13454                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13455                                  			; DS:DX	-> FCB
 13456                                  			; Return: AL = status
 13457                                  	jmp	DIRSTART
 13458                                  CHKCNT:
 13459                                  	test	word [FILECNT],0FFFFh ; -1
 13460                                  	jnz	short TRAILER
 13461                                  	jmp	DIRNF
 13462                                  TRAILER:
 13463                                  	mov	al,[LINLEN]
 13464                                  	cmp	al,[LINCNT]
 13465                                  	jz	short MMESSAGE
 13466                                  	call	CRLF2
 13467                                  MMESSAGE:
 13468                                  	mov	dx,DIRMESPTR
 13469                                  	mov	si,[FILECNT]
 13470                                  	mov	[DIR_NUM],si
 13471                                  	call	STD_PRINTF
 13472                                  DTFREE:
 13473                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13474                                  	;mov	dl,[5Ch]
 13475                                  	mov	dl,[FCB]
 13476                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13477                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13478                                  	cmp	ax,-1
 13479                                  	jnz	short DTFREE1
 13480                                  DTRET:
 13481                                  	retn
 13482                                  DTFREE1:
 13483                                  	mul	cx
 13484                                  	mul	bx
 13485                                  	mov	[BYTES_FREE],ax
 13486                                  	mov	[BYTES_FREE+2],dx
 13487                                  	mov	dx,BYTEMESPTR
 13488                                  	jmp	STD_PRINTF
 13489                                  
 13490                                  ; =============== S U B	R O U T	I N E =======================================
 13491                                  
 13492                                  SHONAME:
 13493                                  DISPLAYNAME:
 13494                                  	; MSDOS 3.3
 13495                                  	mov	di,CHARBUF
 13496                                  	mov	cx,8
 13497                                  	rep	movsb
 13498                                  	mov	al,' '
 13499                                  	stosb
 13500                                  	mov	cx,3
 13501                                  	rep	movsb
 13502                                  	xor	ax,ax
 13503                                  	stosb
 13504                                  	push	dx
 13505                                  	mov	dx,CHARBUF
 13506                                  	mov	[STRING_PTR_2],dx
 13507                                  	mov	dx,STRINGBUF2PTR
 13508                                  	call	STD_PRINTF
 13509                                  	pop	dx
 13510                                  	retn
 13511                                  
 13512                                  %endif
 13513                                  
 13514                                  ;============================================================================
 13515                                  ; DIR.ASM, MSDOS 6.0, 1991
 13516                                  ;============================================================================
 13517                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13518                                  
 13519                                  	; MSDOS 6.0
 13520                                  %if 0
 13521                                  
 13522                                  ;***	DIR.ASM - DIR internal command
 13523                                  
 13524                                  comment	% =================================================================
 13525                                  
 13526                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13527                                  "PART4 COMMAND Transient routines".
 13528                                  
 13529                                  From residual documentation, I surmise that TCMD.ASM originally
 13530                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13531                                  VER.  The file seems to have been successively split:
 13532                                  
 13533                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13534                                  
 13535                                  TCMD1A.ASM contained only the DIR command.
 13536                                  
 13537                                  Usage:
 13538                                  ------
 13539                                  
 13540                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13541                                  
 13542                                  DIR /?
 13543                                  
 13544                                  
 13545                                  <filespec> may include any or none of:  drive; directory path;
 13546                                             wildcarded filename.  If drive or directory path are
 13547                                  	   omitted, the current defaults are used.  If the
 13548                                  	   file name or extension is omitted, wildcards are
 13549                                  	   assumed.
 13550                                  
 13551                                  /w	Wide listing format.  Files are displayed in compressed
 13552                                  	'name.ext' format.  Subdirectory files are enclosed in
 13553                                  	brackets, '[dirname]'.
 13554                                  
 13555                                  /p	Paged, or prompted listing.  A screenful is displayed
 13556                                  	at a time.  The name of the directory being listed appears
 13557                                  	at the top of each page.
 13558                                  
 13559                                  	Bugbug:  pages nead to be uniform length..?
 13560                                  
 13561                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13562                                  	listed in compressed 'name.ext' format, one per line,
 13563                                  	without additional information.  Good for making batch
 13564                                  	files or for piping.  When used with /s, complete
 13565                                  	pathnames are listed.
 13566                                  
 13567                                  /s	Descend subdirectory tree.  Performs command on current
 13568                                  	or specified directory, then for each subdirectory below
 13569                                  	that directory.  Directory header and footer is displayed
 13570                                  	for each directory where matching files are found, unless
 13571                                  	used with /b.  /b suppresses headers and footers.
 13572                                  
 13573                                  	Tree is explored depth first, alphabetically within the
 13574                                  	same level.
 13575                                  
 13576                                  	Bugbug:  hidden directories aren't searched.
 13577                                  
 13578                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13579                                  
 13580                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13581                                  	compressed volume.
 13582                                  
 13583                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13584                                  	extension).  A sort order may be specified after /o.  Any of
 13585                                  	the following characters may be used: nedsgc (name, extension,
 13586                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13587                                  	a '-' before any letter causes a downward sort on that field.
 13588                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13589                                  	then within each extension sort by date and time in reverse
 13590                                  	chronological order.
 13591                                  
 13592                                  /a	Attribute selection.  Without /a, hidden and system files
 13593                                  	are suppressed from the listing.  With /a alone, all files
 13594                                  	are listed.  An attribute list may follow /a, consisting of
 13595                                  	any of the following characters:  hsdar (hidden, system,
 13596                                  	directory, archive, read-only).  A '-' before any letter
 13597                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13598                                  	are marked read-only and are not directory files.  Note
 13599                                  	that hidden or system files may be included in the listing.
 13600                                  	They are suppressed without /a but are treated like any other
 13601                                  	attribute with /a.
 13602                                  
 13603                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13604                                  
 13605                                  /h has been removed.					;M008
 13606                                  
 13607                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13608                                  	DIR command line.  Any command line options may be specified
 13609                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13610                                  	A filespec may be specified in DIRCMD and will be used unless
 13611                                  	a filespec is specified on the command line.  Any switch
 13612                                  	specified in DIRCMD may be overridden on the command line.
 13613                                  	If the original DIR default action is desired for a particular
 13614                                  	switch, the switch letter may be preceded by a '-' on the
 13615                                  	command line.  E.g.,
 13616                                  
 13617                                  	  /-w	use long listing format
 13618                                  	  /-p	don't page the listing
 13619                                  	  /-b	don't use bare format
 13620                                  	  /-s	don't descend subdirectory tree
 13621                                  	  /-o	display files in disk order
 13622                                  	  /-a	suppress hidden and system files
 13623                                  
 13624                                  Notes:
 13625                                  ------
 13626                                  
 13627                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13628                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13629                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13630                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13631                                  a flag byte which is made zero when the entry is loaded, and made one
 13632                                  when the entry is used.
 13633                                  
 13634                                  Revision History
 13635                                  ================
 13636                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13637                                  				in the absence of ANSI.SYS
 13638                                  
 13639                                  M007	sa	8/1/90		Allow /p/b combination
 13640                                  
 13641                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13642                                  				to internally handle /? message.
 13643                                  
 13644                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13645                                  
 13646                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13647                                  				first FCB with the drive number when the drive
 13648                                  				letter in the command line is preceded by a
 13649                                  				switch.  Now dir manually loads the drive
 13650                                  				number after parsing.
 13651                                  
 13652                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13653                                  				from the ROM BIOS.
 13654                                  
 13655                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13656                                  				a subdirectory having len(pathname)>MAXPATH.
 13657                                  				Just skip over that subdirectory.
 13658                                  
 13659                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13660                                  				byte value, rather than collating table.
 13661                                  				This to match MS-DOS Shell's sort order.
 13662                                  
 13663                                  ========================================================================= %
 13664                                  
 13665                                  %endif
 13666                                  
 13667                                  ; 16/02/2023
 13668                                  
 13669                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13670                                  
 13671                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13672                                  ;
 13673                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13674                                  ;		(order is hard-coded; see OnOffSw)
 13675                                  ;		Inmem is set when entries are loaded in memory.
 13676                                  
 13677                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13678                                  mask.wide  equ 1
 13679                                  mask.pagd  equ 2
 13680                                  mask.subd  equ 4
 13681                                  mask.bare  equ 8
 13682                                  mask.lcase equ 16
 13683                                  mask.inmem equ 32
 13684                                  ;
 13685                                  mask.dev    equ 1
 13686                                  mask.baddir equ 2	
 13687                                  
 13688                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13689                                  
 13690                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13691                                  
 13692                                  ;ResultBuffer	struc		; structure of parse result buffer
 13693                                  ;ValueType	db	?
 13694                                  ;ValueTag	db	?
 13695                                  ;SynPtr		dw	?
 13696                                  ;ValuePtr	dd	?
 13697                                  ;ResultBuffer	ends
 13698                                  
 13699                                  ;ErrorRec	record	baddir:1,dev:1
 13700                                  ;
 13701                                  ;		Error bits are:
 13702                                  ;		  Invalid directory format
 13703                                  ;		  File is device
 13704                                  
 13705                                  ;EntryStruc	struc			; our private directory entry structure
 13706                                  ;used		db	?		; =0 until entry used, then =1
 13707                                  ;filename	db	8 dup (?)	; filename
 13708                                  ;fileext	db	3 dup (?)	; extension
 13709                                  ;fileattr	db	?		; file attributes
 13710                                  ;filetime	dw	?		; file time
 13711                                  ;filedate	dw	?		; file date
 13712                                  ;filesize	dd	?		; file size
 13713                                  ;EntryStruc	ends
 13714                                  
 13715                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13716                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13717                                  ;	push	ax
 13718                                  ;	endm
 13719                                  
 13720                                  ;	public	Catalog		; our entry point
 13721                                  ;
 13722                                  ;	break	<DIR (Catalog) principal routines>
 13723                                  ;
 13724                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13725                                  ; ---------------------------------------------------------------------------
 13726                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13727                                  
 13728                                  ;----------------------------------------------------------------------------
 13729                                  ;----------------------------------------------------------------------------
 13730                                  
 13731                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13732                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13733                                  
 13734                                  ;***	Catalog - DIR command main routine
 13735                                  ;
 13736                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13737                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13738                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13739                                  ;		Tpa = TPA buffer seg addr
 13740                                  ;		BytCnt = # bytes in TPA buffer
 13741                                  ;
 13742                                  ;	EXIT	nothing
 13743                                  ;
 13744                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13745                                  ;
 13746                                  ;	ERROR EXITS
 13747                                  ;
 13748                                  ;	  Errors are handled by setting up error message pointers
 13749                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13750                                  ;	   the environment variable, however, are handled by printing
 13751                                  ;	   an error message and continuing.
 13752                                  ;
 13753                                  ;	EFFECTS
 13754                                  ;
 13755                                  ;	  Directory listing is displayed (on standard output).
 13756                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13757                                  ;	   restore APPEND state.
 13758                                  ;	  Working directory may be changed. The user's default
 13759                                  ;	   directory is saved and flagged for restoration by RestUDir
 13760                                  ;	   during COMMAND cycle.
 13761                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13762                                  ;
 13763                                  ;	NOTES
 13764                                  ;
 13765                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13766                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13767                                  
 13768                                  	; 16/02/2023
 13769                                  CATALOG:
 13770 00001064 E8A400                  	call	SetDefaults
 13771 00001067 E8C800                  	call	ParseEnvironment
 13772 0000106A E8E000                  	call	ParseCmdLine
 13773 0000106D 7303                    	jnc	short catalog1	; no parse error
 13774 0000106F E99600                  	jmp	catErr		; error msg is set up
 13775                                  catalog1:
 13776 00001072 E80901                  	call	SetOptions
 13777 00001075 E8DF00                  	call	SetCollatingTable
 13778                                  
 13779                                  ;	Drive # to operate on has already been placed in FCB by
 13780                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13781                                  
 13782                                  	;;;test	Bits,mask bare
 13783                                  	;;test 	word [_Bits],8
 13784                                  	;test	byte [_Bits],8
 13785 00001078 F606[208C]08            	test	byte [_Bits],mask.bare
 13786 0000107D 750A                    	jnz	short catalog2	; don't display volume info for /b
 13787                                  	;invoke	OkVolArg	; find & display volume info
 13788 0000107F E8E00B                  	call	OkVolArg
 13789                                  	;sub	byte [LeftOnpage],2
 13790 00001082 832E[EF8A]02            	sub	word [LeftOnPage],2
 13791                                  				; record display lines used by volume info
 13792 00001087 EB14                    	jmp	short catCrunch
 13793                                  
 13794                                  ;	OkVolArg side effects:
 13795                                  ;	APPEND is disabled;
 13796                                  ;	DTA established at DirBuf;
 13797                                  ;	Filename fields in FCB are wildcarded.
 13798                                  
 13799                                  catalog2:
 13800                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13801                                  
 13802                                  	;invoke	DisAppend	; disable APPEND
 13803 00001089 E8A30B                  	call	DisAppend
 13804                                  
 13805                                  	;mov	dx,offset TRANGROUP:DirBuf
 13806 0000108C BA[CE8B]                	mov	dx,DIRBUF
 13807 0000108F B41A                    	mov	ah,1Ah
 13808                                  	;mov	ah,Set_DMA
 13809 00001091 CD21                    	int	21h		; set DTA
 13810                                  
 13811                                  
 13812                                  	;mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13813                                  	;inc	di		; ES:DI = ptr to filename field of FCB
 13814                                  	; 28/07/2024
 13815 00001093 BF5D00                  	mov	di,FCB+1 ; 5Dh
 13816 00001096 B03F                    	mov	al,'?'		; AL = wildcard character
 13817 00001098 B90B00                  	mov	cx,11
 13818 0000109B F3AA                    	rep	stosb		; wildcard filename field
 13819                                  
 13820                                  catCrunch:
 13821 0000109D E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13822 000010A0 7230                    	jc	short catRecErr	; handle recorded or extended error
 13823                                  
 13824                                  ;	User's directory has been saved, we've changed to specified directory.
 13825                                  ;	ComSw = error bits for later use
 13826                                  ;	FCB contains parsed filename
 13827                                  
 13828                                  	;cmp	byte [COMSW],0
 13829 000010A2 833E[DC8A]00            	cmp	word [COMSW],0
 13830 000010A7 7529                    	jne	short catRecErr	; handle recorded error
 13831                                  
 13832 000010A9 E88701                  	call	InstallCtrlC	; install control-C handler
 13833 000010AC E8CD08                  	call	ZeroTotals	; zero grand totals
 13834 000010AF E84304                  	call	ListDir		; list main directory
 13835 000010B2 7244                    	jc	short catExtErr
 13836                                  
 13837                                  	;;;test	Bits,mask subd
 13838                                  	;;test	word [_Bits],4
 13839                                  	;test	byte [_Bits],4
 13840 000010B4 F606[208C]04            	test	byte [_Bits],mask.subd
 13841 000010B9 7405                    	jz	short catalog3	; subdirectories option not set
 13842 000010BB E88D01                  	call	ListSubds	; list subdirectories
 13843 000010BE 7238                    	jc	short catExtErr
 13844                                  catalog3:
 13845                                  ;	Check if any files were found.
 13846                                  
 13847                                  	;;;test	Bits,mask bare
 13848                                  	;;test	word [_Bits],8
 13849                                  	;test	byte [_Bits],8
 13850 000010C0 F606[208C]08            	test	byte [_Bits],mask.bare
 13851 000010C5 750A                    	jnz	short catRet	; don't bother for bare format
 13852                                  
 13853 000010C7 A1[F78A]                	mov	ax,[FileCntTotal]
 13854 000010CA 09C0                    	or	ax,ax
 13855 000010CC 7417                    	jz	short catNoFiles ; no files found
 13856                                  
 13857 000010CE E8A702                  	call	DisplayTotals	; display trailing grand totals
 13858                                  	;jmp	short catRet	; all done
 13859                                  	; 25/04/2023
 13860                                  catRet:
 13861 000010D1 C3                      	retn
 13862                                  
 13863                                  catRecErr:
 13864                                  
 13865                                  ;	ComSw may have error bit set. If not, do extended error.
 13866                                  
 13867                                  	;;;test	ComSw,mask dev
 13868                                  	;;test	word [COMSW],1
 13869                                  	;test	byte [COMSW],1
 13870 000010D2 F606[DC8A]01            	test	byte [COMSW],mask.dev
 13871 000010D7 750C                    	jnz	short catNoFiles 
 13872                                  				; filename is device, respond 'file not found'
 13873                                  	;;test	ComSw,mask baddir
 13874                                  	;;test	word [COMSW],2
 13875                                  	;test	byte [COMSW],2
 13876 000010D9 F606[DC8A]02            	test	byte [COMSW],mask.baddir
 13877 000010DE 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13878                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13879                                  				; invalid directory
 13880 000010E0 BA[5680]                	mov	dx,badcd_ptr
 13881 000010E3 EB23                    	jmp	short catErr
 13882                                  
 13883                                  catNoFiles:
 13884                                  
 13885                                  ;	Display header and force 'file not found' message.
 13886                                  
 13887 000010E5 E81107                  	call	DisplayHeader
 13888 000010E8 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13889 000010EB C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13890 000010F0 BA[1B7F]                	mov	dx,extend_buf_ptr
 13891 000010F3 A3[1B7F]                	mov	[extend_buf_ptr],ax
 13892 000010F6 EB10                    	jmp	short catErr
 13893                                  
 13894                                  catExtErr:
 13895                                  
 13896                                  ;	DOS has returned an error status. Get the extended error#, and
 13897                                  ;	set up an error message, changing 'No more files' error 
 13898                                  ;	to 'File not found' error.
 13899                                  
 13900 000010F8 E8E50B                  	call	Set_Ext_Error_Msg
 13901 000010FB 833E[1B7F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13902 00001100 7506                    	jne	short catalog4  ; catErr
 13903 00001102 C706[1B7F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13904                                  catalog4:
 13905                                  
 13906                                  ;	Error exit. Error message information has been set up
 13907                                  ;	for Std_EPrintf.
 13908                                  
 13909                                  catErr:
 13910 00001108 E94718                  	jmp	cerror		; go to COMMAND error recycle point
 13911                                  
 13912                                  	; 25/04/2023
 13913                                  ;catRet:
 13914                                  	;retn
 13915                                  
 13916                                  ; ---------------------------------------------------------------------------
 13917                                  
 13918                                  ;***	SetDefaults - set default pathname, options
 13919                                  ;
 13920                                  ;	ENTRY	DS = TRANGROUP seg addr
 13921                                  ;
 13922                                  ;	EXIT	nothing
 13923                                  ;
 13924                                  ;	USED	AX,DI
 13925                                  ;
 13926                                  ;	EFFECTS
 13927                                  ;	  SrcBuf = '*',EOL - default pathname
 13928                                  ;	  PathPos = ptr to pathname
 13929                                  ;	  PathCnt = length of pathname
 13930                                  
 13931                                  	; 16/02/2023
 13932                                  SetDefaults:
 13933 0000110B BF[B48C]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13934 0000110E 893E[248C]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13935                                  	;mov	al,STAR
 13936 00001112 B02A                    	mov	al,'*'
 13937 00001114 AA                      	stosb
 13938                                  	;mov	al,END_OF_LINE_IN
 13939 00001115 B00D                    	mov	al,0Dh ; cr
 13940 00001117 AA                      	stosb				; SrcBuf = '*',0Dh
 13941 00001118 C706[228C]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13942                                  
 13943 0000111E 31C0                    	xor	ax,ax			; AX = 0
 13944 00001120 A3[DC8A]                	mov	[COMSW],ax		; = no error
 13945 00001123 A3[208C]                	mov	[_Bits],ax		; = options off
 13946 00001126 A2[518C]                	mov	[DestBuf],al		; = no sort
 13947 00001129 C606[288C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13948 0000112E A2[298C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13949                                  peRet:	; 25/04/2023
 13950 00001131 C3                      	retn
 13951                                  
 13952                                  ; ---------------------------------------------------------------------------
 13953                                  
 13954                                  ;***	ParseEnvironment - find and parse our environment variable
 13955                                  ;
 13956                                  ;	Find our environment variable and parse it. If a parse
 13957                                  ;	error occurs, issue an error message. The parse results
 13958                                  ;	up to the error will still have effect. Always leave
 13959                                  ;	the option variables in a useable state.
 13960                                  ;
 13961                                  ;	ENTRY	DS = TRANGROUP seg addr
 13962                                  ;
 13963                                  ;	EXIT	nothing
 13964                                  ;
 13965                                  ;	USED	AX,BX,CX,DX,SI,DI
 13966                                  ;
 13967                                  ;	EFFECTS
 13968                                  ;
 13969                                  ;	  Bits may contain new option settings.
 13970                                  ;	  DestBuf may contain new series of sort codes.
 13971                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13972                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13973                                  ;	  PathPos, PathCnt updated for new pathname.
 13974                                  ;
 13975                                  ;	  If a parse error occurred, an error message will be issued.
 13976                                  
 13977                                  	; 16/02/2023
 13978                                  ParseEnvironment:
 13979 00001132 E87603                  	call	GetEnvValue		; get environment variable value
 13980 00001135 72FA                    	jc	short peRet		; name not found in environment
 13981                                  
 13982                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 13983                                  
 13984 00001137 E8B904                  	call	Parse_Line		; parse environment value
 13985 0000113A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13986                                  	;cmp	ax,END_OF_LINE
 13987 0000113D 74F2                    	je	short peRet		; successful completion
 13988                                  
 13989                                  ;	Some kind of parse error occurred.
 13990                                  ;	We're set up for a Std_EPrintf call.
 13991                                  
 13992 0000113F E8A53C                  	call	std_eprintf		; display the parse error
 13993                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 13994                                  					; restore default msg class
 13995 00001142 C606[197F]FF            	mov	byte [msg_disp_class],0FFh ; -1
 13996                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 13997 00001147 BA[5A81]                	mov	dx,errparsenv_ptr
 13998                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 13999                                  	;call	Printf_Crlf
 14000                                  	; 25/04/2023
 14001                                  	;retn
 14002 0000114A E9943C                  	jmp	Printf_Crlf
 14003                                  					;M008;Internal handling of /? removed
 14004                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14005                                  	; 25/04/2023
 14006                                  ;peRet:
 14007                                  	;retn
 14008                                  
 14009                                  ; ---------------------------------------------------------------------------
 14010                                  
 14011                                  ;***	ParseCmdLine - parse and record command line parameters
 14012                                  ;
 14013                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14014                                  ;		DS, ES, CS = TRANGROUP seg addr
 14015                                  ;
 14016                                  ;	EXIT	CY = set if parse error occurred
 14017                                  ;
 14018                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14019                                  ;		AX = system parser error code
 14020                                  ;		DX = ptr to message block
 14021                                  ;
 14022                                  ;	USED	AX,BX,CX,DX,SI,DI
 14023                                  ;
 14024                                  ;	EFFECTS
 14025                                  ;
 14026                                  ;	  Bits may contain new option settings.
 14027                                  ;	  DestBuf may contain new series of sort codes.
 14028                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14029                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14030                                  ;	  PathPos, PathCnt updated for new pathname.
 14031                                  ;
 14032                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14033                                  ;	  Msg_Disp_Class = parse error class
 14034                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14035                                  ;	  Message block (see DX) is set up for parse error message
 14036                                  
 14037                                  	; 16/02/2023
 14038                                  ParseCmdLine:
 14039 0000114D BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14040 00001150 E8A004                  	call	Parse_Line		; parse cmd line tail
 14041 00001153 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14042                                  	;;cmp	ax,END_OF_LINE
 14043                                  	; 25/04/2023
 14044                                  	;je	short pcOk		; parse completed successfully
 14045                                  
 14046                                  ;	A parse error occurred. We're all set up for message output.
 14047                                  
 14048                                  	; 25/04/2023
 14049                                  	; cf = 1 (ax < 0FFFFh)
 14050                                  	;stc		   		; return failure
 14051                                  	;jmp	short pcRet
 14052                                  	; 25/04/2023
 14053                                  	;retn
 14054                                  pcOk:
 14055                                  	; 25/04/2023
 14056                                  	;cf = 0 (ax = 0FFFFh)
 14057                                  	;clc				; return success
 14058                                  pcRet:
 14059 00001156 C3                      	retn
 14060                                  
 14061                                  ; ---------------------------------------------------------------------------
 14062                                  
 14063                                  ;***	SetCollatingTable - set up character collating table for sorting
 14064                                  ;
 14065                                  ;	If country is other than USA, try to get a collating table
 14066                                  ;	for character sorting. For USA, use straight byte values.
 14067                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14068                                  ;	by straight byte values in the USA for better performance.
 14069                                  ;
 14070                                  ;	ENTRY	ES = TRANGROUP seg addr
 14071                                  ;
 14072                                  ;	EXIT	nothing
 14073                                  ;
 14074                                  ;	USED	AX,BX,CX,DX,DI
 14075                                  ;
 14076                                  ;	EFFECTS
 14077                                  ;
 14078                                  ;	  If collating table is set -
 14079                                  ;	    CountryPtrId = 6.
 14080                                  ;	    CountryPtr points to collating table.
 14081                                  ;
 14082                                  ;	  Otherwise -
 14083                                  ;	    CountryPtrId = 0.
 14084                                  
 14085                                  SetCollatingTable:
 14086                                  
 14087                                  ;	Begin modification M028
 14088                                  
 14089                                  	;mov	dx,offset TRANGROUP:InternatVars
 14090                                  	;			; DS:DX = ptr to international info buffer
 14091 00001157 BA[2395]                	mov	dx,INTERNATVARS
 14092 0000115A B80038                  	mov	ax,3800h
 14093                                  	;mov	ax,INTERNATIONAL << 8
 14094                                  	;;mov	ax,INTERNATIONAL shl 8
 14095                                  				; AX = 'Get current country info'
 14096 0000115D CD21                    	int	21h		; call DOS
 14097 0000115F 7217                    	jc	short scNoTable	; error - so don't collate
 14098                                  
 14099                                  ;	BX = country code
 14100                                  
 14101 00001161 83FB01                  	cmp	bx,1
 14102 00001164 7412                    	je	short scNoTable	; we're in USA, don't collate
 14103                                  
 14104                                  ;	End modification M028
 14105                                  
 14106                                  ;*	Country code is other than USA. Try to get a collating table.
 14107                                  
 14108 00001166 B80665                  	mov	ax,6506h
 14109                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14110                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14111                                  				; AH = 'Get Extended Country Info'
 14112                                  				; AL = 'Get Pointer to Collating Table'
 14113 00001169 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14114 0000116C B90500                  	mov	cx,5		; CX = length of info buffer
 14115 0000116F 89DA                    	mov	dx,bx		; DX = country ID = default
 14116                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14117 00001171 BF[4395]                	mov	di,CountryPtrInfo
 14118                                  				; ES:DI = ptr to info buffer
 14119 00001174 CD21                    	int	21h		; call DOS
 14120 00001176 7305                    	jnc	short scRet	; success
 14121                                  
 14122                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14123                                  
 14124                                  scNoTable:			;M028
 14125 00001178 C606[4395]00            	mov	byte [CountryPtrId],0
 14126                                  scRet:
 14127 0000117D C3                      	retn
 14128                                  
 14129                                  ; ---------------------------------------------------------------------------
 14130                                  
 14131                                  ;***	SetOptions - check and set options
 14132                                  ;
 14133                                  ;	ENTRY	nothing
 14134                                  ;
 14135                                  ;	EXIT	nothing
 14136                                  ;
 14137                                  ;	USED	AX,BX,CX,DX
 14138                                  ;
 14139                                  ;	EFFECTS
 14140                                  ;
 14141                                  ;	  Bits may contain modified option settings.
 14142                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14143                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14144                                  ;	  PerLine is set according to /w presence.
 14145                                  
 14146                                  	; 16/02/2023
 14147                                  SetOptions:
 14148                                  
 14149                                  ;	If bare listing requested, cancel wide listings.
 14150                                  
 14151                                  	;;;test	Bits,mask bare
 14152                                  	;;test	word [_Bits],8
 14153                                  	;test	byte [_Bits],8
 14154 0000117E F606[208C]08            	test	byte [_Bits],mask.bare
 14155 00001183 7405                    	jz	short setopts1
 14156                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14157                                  	;;and	word [_Bits],0FFFEh
 14158                                  	;;and	byte [_Bits],0FEh
 14159 00001185 8026[208C]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 14160                                  setopts1:
 14161                                  ;	Set # lines per display page.
 14162                                  
 14163                                  ;M01  Obtain screen height from ROM BIOS data area
 14164                                  ;
 14165                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14166                                  
 14167 0000118A 1E                      	push	ds
 14168                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14169 0000118B B84000                  	mov	ax,40h
 14170 0000118E 8ED8                    	mov	ds,ax			;
 14171                                  	;Assume	DS:ROMBIOS_DATA
 14172                                  
 14173                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14174 00001190 A08400                  	mov	al,[84h]
 14175 00001193 1F                      	pop	ds			;
 14176                                  	;Assume	DS:Trangroup
 14177                                  
 14178 00001194 08C0                    	or	al,al			; If zero specified
 14179 00001196 7502                    	jnz	short setopts2		;
 14180                                  
 14181                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14182 00001198 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14183                                  setopts2:
 14184 0000119A 30E4                    	xor	ah,ah
 14185                                  setopts3:
 14186 0000119C FEC0                    	inc	al			; height + 1 ;M018
 14187                                  
 14188 0000119E A3[9B8D]                	mov	[LinPerPag],ax		; set the rows now
 14189                                  
 14190                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14191                                  
 14192                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE
 14193                                  					; IOCTL for handles
 14194 000011A1 B80C44                  	mov	ax,440Ch
 14195                                  	;mov	bx,STDOUT		; handle #
 14196 000011A4 BB0100                  	mov	bx,1
 14197                                  	;mov	ch,IOC_SC		; screen
 14198 000011A7 B503                    	mov	ch,3
 14199                                  	;mov	cl,get_generic		; get display info
 14200 000011A9 B17F                    	mov	cl,7Fh
 14201 000011AB BA[8B8D]                	mov	dx,Display_Ioctl	; info block
 14202 000011AE CD21                    	int	21h			; call DOS
 14203                                  
 14204 000011B0 A1[9B8D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14205 000011B3 A3[EF8A]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14206                                  
 14207                                  ;	Set # entries per line.
 14208                                  
 14209                                  	;mov	byte [PerLine],NORMPERLIN
 14210                                  					; # entries per line without /w
 14211 000011B6 C606[EC8A]01            	mov	byte [PerLine],1
 14212                                  	;;;test	Bits,mask wide
 14213                                  	;;test	word [_Bits],1
 14214                                  	;test	byte [_Bits],1
 14215 000011BB F606[208C]01            	test	byte [_Bits],mask.wide
 14216 000011C0 7405                    	jz	short setopts4
 14217                                  	;mov	byte [PerLine],WIDEPERLIN
 14218                                  					; # entries per line with /w
 14219 000011C2 C606[EC8A]05            	mov	byte [PerLine],5
 14220                                  setopts4:
 14221                                  				;M011;start;The following code checks if a drive
 14222                                  				;letter has been parsed into SrcBuf, and if
 14223                                  				;so, the correct drive number is loaded into
 14224                                  				;the first FCB, at offset 5C.
 14225                                  
 14226                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14227 000011C7 803E[B58C]3A            	cmp	byte [SrcBuf+1],':'
 14228 000011CC 750A                    	jne	short soRet
 14229                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14230 000011CE A0[B48C]                	mov	al,[SrcBuf]
 14231                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14232 000011D1 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14233 000011D3 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14234 000011D5 A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14235                                  						;M011;end
 14236                                  soRet:
 14237 000011D8 C3                      	retn
 14238                                  
 14239                                  ; ---------------------------------------------------------------------------
 14240                                  
 14241                                  ;***	CrunchPath - analyze supplied or default pathname
 14242                                  ;
 14243                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14244                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14245                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14246                                  ;		 must have space for another char after the delimiter.
 14247                                  ;
 14248                                  ;	EXIT	CY = clear if no error
 14249                                  ;		We are changed to directory found in pathname
 14250                                  ;		Previous directory ready to be restored via RestUDir
 14251                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14252                                  ;
 14253                                  ;		If error occurred,
 14254                                  ;		CY = set
 14255                                  ;		ComSw = error bits (see ErrorRec)
 14256                                  ;		If ComSw not set,
 14257                                  ;		Ready for DOS Get Extended Error call
 14258                                  
 14259                                  	; 16/02/2023
 14260                                  CrunchPath:
 14261 000011D9 E8E101                  	call	FileIsDevice
 14262 000011DC 7507                    	jne	short crpath1	; not a device, skip ahead
 14263                                  	;;;or	ComSw,mask dev	; signal file is device
 14264                                  	;;or	word [COMSW],1
 14265                                  	;or	byte [COMSW],1
 14266 000011DE 800E[DC8A]01            	or	byte [COMSW],mask.dev
 14267 000011E3 EB2F                    	jmp	short cpErr	; return error
 14268                                  crpath1:
 14269 000011E5 FF36[248C]              	push	word [PathPos]	; save ptr to pathname
 14270 000011E9 C606[2C8C]FF            	mov	byte [DirFlag],-1
 14271                                  				; tell PathCrunch not to parse file into FCB
 14272 000011EE E88914                  	call	PathCrunch	; change to directory in pathname
 14273 000011F1 C606[2C8C]00            	mov	byte [DirFlag],0
 14274                                  				; reset our little flag
 14275 000011F6 5E                      	pop	si		; SI = ptr to pathname
 14276 000011F7 7208                    	jc	short cpNoDir	; didn't find directory path
 14277 000011F9 741A                    	jz	short cpRet	; found directory path w/ no filename
 14278                                  				;  - leave wildcard default in FCB and return
 14279                                  
 14280                                  ;*	We found a directory, and there was a filename attached.
 14281                                  ;	DestTail = ptr to ASCIIZ filename
 14282                                  
 14283 000011FB 8B36[4E8C]              	mov	si,[DestTail]	; SI = ptr to filename
 14284 000011FF EB28                    	jmp	short cpFile	; go parse the file into FCB
 14285                                  
 14286                                  ;*	PathCrunch failed to find a directory in the pathname.
 14287                                  ;
 14288                                  ;	Msg_Numb = error code
 14289                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14290                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14291                                  
 14292                                  cpNoDir:
 14293 00001201 A1[B88D]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14294 00001204 09C0                    	or	ax,ax
 14295 00001206 750C                    	jnz	short cpErr	  ; error occurred - return it
 14296 00001208 803E[4C8C]00            	cmp	byte [DestIsDir],0
 14297 0000120D 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14298                                  crpath3:
 14299                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14300                                  	;;or	word [COMSW],2
 14301                                  	;or	byte [COMSW],2
 14302 0000120F 800E[DC8A]02            	or	byte [COMSW],mask.baddir
 14303                                  	;jmp	short cpErr	  ; return error
 14304                                  	; 16/02/2023
 14305                                  cpErr:
 14306 00001214 F9                      	stc			  ; return error
 14307                                  cpRet:
 14308 00001215 C3                      	retn
 14309                                  
 14310                                  cpMaybe:
 14311                                  ;	SI = ptr to pathname
 14312                                  
 14313                                  	;cmp	byte [si+1],COLON_CHAR
 14314 00001216 807C013A                	cmp	byte [si+1],':'
 14315 0000121A 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14316 0000121C AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14317                                  crpath2:
 14318 0000121D 813C2E2E                	cmp	word [si],".."
 14319 00001221 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14320 00001223 807C0200                	cmp	byte [si+2],0
 14321                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14322                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14323                                  	;;;or	word [COMSW],2
 14324                                  	;;or	byte [COMSW],2
 14325                                  	;or	byte [COMSW],mask.baddir
 14326                                  	;jmp	short cpErr	  ; return error
 14327                                  	; 16/02/2023
 14328 00001227 74E6                    	je	short crpath3
 14329                                  
 14330                                  ;	The preceding code was taken from the old DIR routine.
 14331                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14332                                  ;	occurring when we're at the root directory. Too bad it
 14333                                  ;	doesn't handle problems with "..\..", etc.
 14334                                  
 14335                                  ;	We're ready to parse a filename into the FCB.
 14336                                  ;	SI = ptr to ASCIIZ filename
 14337                                  
 14338                                  cpFile:	
 14339 00001229 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14340 0000122C B80E29                  	mov	ax,290Eh
 14341                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14342                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14343                                  				; wildcards already in FCB used as defaults
 14344 0000122F CD21                    	int	21h
 14345 00001231 F8                      	clc			; return success
 14346                                  	;jmp	short cpRet
 14347                                  	; 16/02/2023
 14348 00001232 C3                      	retn
 14349                                  
 14350                                  ;cpErr:
 14351                                  ;	stc			; return error
 14352                                  ;cpRet:
 14353                                  ;	retn
 14354                                  
 14355                                  ; ---------------------------------------------------------------------------
 14356                                  
 14357                                  ;***	InstallCtrlC - install our private control-C handler
 14358                                  ;
 14359                                  ;	Put our control-c handler in front of command.com's default
 14360                                  ;	handler, to make sure the user's default directory gets restored.
 14361                                  ;	This shouldn't be necessary, but, for now, there are situations
 14362                                  ;	where the TDATA segment is left in a modified state when a
 14363                                  ;	control-c occurs.  This means that the transient will be
 14364                                  ;	reloaded, and the user's directory cannot be restored.
 14365                                  ;
 14366                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14367                                  ;
 14368                                  ;	ENTRY	nothing
 14369                                  ;
 14370                                  ;	EXIT	nothing
 14371                                  ;
 14372                                  ;	USED	AX,BX,DX
 14373                                  ;
 14374                                  ;	EFFECTS
 14375                                  ;
 14376                                  ;	  CtrlCHandler address placed in int 23 vector.
 14377                                  ;
 14378                                  ;	NOTE
 14379                                  ;
 14380                                  ;	  Command.com's basic control-c handler will be restored
 14381                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14382                                  
 14383                                  	; 16/02/2023
 14384                                  InstallCtrlC:
 14385 00001233 06                      	push	es			; preserve ES
 14386 00001234 B82335                  	mov	ax,3523h
 14387                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14388                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14389 00001237 CD21                    	int	21h
 14390 00001239 891E[4895]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14391 0000123D 8C06[4A95]              	mov	[OldCtrlCHandler+2],es	 
 14392 00001241 07                      	pop	es			; restore ES
 14393                                  
 14394 00001242 BA[8719]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14395 00001245 B82325                  	mov	ax,2523h
 14396                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14397                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14398 00001248 CD21                    	int	21h
 14399 0000124A C3                      	retn
 14400                                  
 14401                                  ; ---------------------------------------------------------------------------
 14402                                  
 14403                                  ;***	ListSubds - search and list files in subdirectories
 14404                                  ;
 14405                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14406                                  ;		FCB is still set up for file searches
 14407                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14408                                  ;
 14409                                  ;	EXIT	CY = clear if no error
 14410                                  ;		FileCnt = # files found & displayed
 14411                                  ;		FileSiz = total size of files found
 14412                                  ;
 14413                                  ;		If error,
 14414                                  ;		CY = set
 14415                                  ;		Ready for DOS Get Extended Error call
 14416                                  ;
 14417                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14418                                  ;
 14419                                  ;	EFFECTS
 14420                                  ;
 14421                                  ;	  FileCntTotal, FileSizTotal are updated.
 14422                                  ;	  Subdirectories may be listed on standard output device.
 14423                                  ;
 14424                                  ;	NOTES
 14425                                  ;
 14426                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14427                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14428                                  ;	   Each name is stored ASCIIZ.
 14429                                  
 14430                                  	; 16/02/2023
 14431                                  ListSubds:
 14432                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14433 0000124B E8931A                  	call	SetRest1
 14434                                  
 14435 0000124E BB[0E8D]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14436                                  lsNode:
 14437 00001251 C60700                  	mov	byte [bx],0		; start with null child name
 14438                                  lsLoop:
 14439 00001254 E8F001                  	call	FindNextChild		; search for next subdirectory
 14440 00001257 7235                    	jc	short lsErr		; search failed - examine error
 14441                                  
 14442 00001259 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14443 0000125B E84004                  	call	ChangeDir		; enter child directory
 14444                                  
 14445                                  					; M023;start
 14446 0000125E 7306                    	jnc	short lstsd1		; check for error
 14447                                  	;cmp	ax,3
 14448 00001260 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14449 00001263 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14450                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14451                                  	; 16/02/2023			; M023;end
 14452 00001265 C3                      	retn
 14453                                  lstsd1:	
 14454 00001266 53                      	push	bx
 14455 00001267 E88B02                  	call	ListDir			; list the directory
 14456 0000126A 5B                      	pop	bx
 14457                                  
 14458                                  ;	Note we're ignoring errors returned here.
 14459                                  
 14460 0000126B 89DF                    	mov	di,bx			; DI = ptr to child's name
 14461 0000126D B90D00                  	mov	cx,13			; CX = max name length w/ null
 14462 00001270 30C0                    	xor	al,al			; AL = zero byte to look for
 14463 00001272 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14464 00001274 53                      	push	bx			; save ptr to child's name
 14465 00001275 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14466 00001277 E8D7FF                  	call	lsNode			; recurse from new node
 14467 0000127A 5B                      	pop	bx			; BX = ptr to child's name
 14468 0000127B 9C                      	pushf				; save error condition
 14469                                  	
 14470                                  	;;shove	0
 14471                                  	;mov	ax,0
 14472 0000127C 29C0                    	sub	ax,ax ; 0
 14473 0000127E 50                      	push	ax
 14474                                  	;shove	".."
 14475 0000127F B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14476 00001282 50                      	push	ax
 14477 00001283 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14478 00001285 E81604                  	call	ChangeDir		; return to parent directory
 14479 00001288 58                      	pop	ax			; restore stack
 14480 00001289 58                      	pop	ax
 14481                                  
 14482 0000128A 9D                      	popf				; restore error condition from child
 14483                                  	;jc	short lsRet		; return error
 14484                                  	;jmp	short lsLoop		; look for more children
 14485                                  	; 16/02/2023
 14486 0000128B 73C7                    	jnc	short lsLoop
 14487 0000128D C3                      	retn
 14488                                  lsErr:
 14489 0000128E E85F0A                  	call	get_ext_error_number	; AX = extended error code
 14490                                  	;cmp	ax,2
 14491 00001291 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14492 00001294 7406                    	je	short lsRet		; file not found, we're ok
 14493                                  	;cmp	ax,18
 14494 00001296 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14495 00001299 7401                    	je	short lsRet		; no more files, we're ok
 14496 0000129B F9                      	stc				; return other errors
 14497                                  lsRet:	
 14498 0000129C C3                      	retn
 14499                                  
 14500                                  ; ---------------------------------------------------------------------------
 14501                                  
 14502                                  	;break	<DIR support routines>
 14503                                  
 14504                                  ;***	SUPPORT ROUTINES
 14505                                  
 14506                                  ; ----------------------
 14507                                  
 14508                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14509                                  ;
 14510                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14511                                  ;		BX = ptr to last child's name
 14512                                  ;		BP = ptr to temp child's name
 14513                                  ;
 14514                                  ;	EXIT	nothing
 14515                                  ;
 14516                                  ;	USED	AX,CX,SI,DI
 14517                                  ;
 14518                                  ;	EFFECTS
 14519                                  ;
 14520                                  ;	  Filename pointed to by BP may be changed.
 14521                                  ;
 14522                                  ;	NOTES
 14523                                  ;
 14524                                  ;	  Potential filename replaces temp filename if:
 14525                                  ;	   it's a subdirectory file;
 14526                                  ;	   it doesn't start with a '.';
 14527                                  ;	   it's alphanumerically greater than last child's name;
 14528                                  ;	   and it's alphanumerically less than temp name.
 14529                                  
 14530                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14531                                  	; 07/06/2023
 14532                                  CheckChild:
 14533                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14534 0000129D F606[E38B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14535 000012A2 741D                    	jz	short ccRet	; not a subdirectory file- return
 14536                                  
 14537                                  	; 16/02/2023
 14538 000012A4 BE[EC8B]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14539 000012A7 803C2E                  	cmp	byte [si],'.'
 14540                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14541                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14542 000012AA 7415                    	je	short ccRet	; starts with a dot- return
 14543                                  
 14544                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14545                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14546 000012AC 89DF                    	mov	di,bx
 14547 000012AE E80404                  	call	CmpAscz		; compare candidate to last child's name
 14548 000012B1 760E                    	jna	short ccRet	; it's not above it- return
 14549                                  
 14550                                  
 14551                                  	; 07/06/2023
 14552                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14553                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14554                                  	; si = DIRBUF+FIND_BUF.PNAME
 14555 000012B3 89EF                    	mov	di,bp
 14556 000012B5 E8FD03                  	call	CmpAscz		; compare candidate to temp name
 14557 000012B8 7307                    	jnb	short ccRet	; it's not below it- return
 14558                                  
 14559                                  ;	New kid is alright. Copy to temp.
 14560                                  
 14561                                  	; 07/06/2023
 14562                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14563                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14564                                  	; si = DIRBUF+FIND_BUF.PNAME
 14565 000012BA 89EF                    	mov	di,bp
 14566 000012BC B90D00                  	mov	cx,13
 14567 000012BF F3A4                    	rep	movsb
 14568                                  ccRet:
 14569 000012C1 C3                      	retn
 14570                                  
 14571                                  ; ---------------------------------------------------------------------------
 14572                                  
 14573                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14574                                  ;
 14575                                  ;	Compare one directory entry against another according to
 14576                                  ;	the sort codes in DestBuf. One or more comparisons
 14577                                  ;	may be made of file name, extension, time/date, and
 14578                                  ;	size.  Comparisons may be made for upward or downward
 14579                                  ;	sort order.
 14580                                  ;
 14581                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14582                                  ;		ES:BP = ptr to entry to be compared against
 14583                                  ;		DestBuf contains sort codes (see DestBuf)
 14584                                  ;		DS = TRANGROUP seg addr
 14585                                  ;
 14586                                  ;	EXIT	BX = unchanged
 14587                                  ;		BP = unchanged
 14588                                  ;		Condition flags set for same, above, or below
 14589                                  ;		 comparing BX entry against BP entry.
 14590                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14591                                  ;
 14592                                  ;	USED:	AX,CX,DX,SI,DI
 14593                                  
 14594                                  	; 16/02/2023
 14595                                  CmpEntry:
 14596 000012C2 BE[518C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14597                                  ceLoop:
 14598 000012C5 31C0                    	xor	ax,ax		; AX = 0
 14599 000012C7 8A04                    	mov	al,[si]		; AL = sort code
 14600 000012C9 08C0                    	or	al,al
 14601 000012CB 741C                    	jz	short ceDone	; sort code is zero, we're done
 14602 000012CD 46                      	inc	si		; DS:SI = ptr to next sort code
 14603 000012CE 56                      	push	si		; save ptr to next sort code
 14604 000012CF FEC8                    	dec	al
 14605 000012D1 D0E0                    	shl	al,1
 14606                                  	;sal	al,1		; AX = index into cmp call table
 14607                                  				; CY set for downward sort order
 14608 000012D3 89C6                    	mov	si,ax		; SI = index into cmp call table
 14609 000012D5 2E8B84[EA12]            	mov	ax,[cs:si+FieldCmps]
 14610                                  				; AX = addr of compare routine
 14611 000012DA 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14612 000012DC FFD0                    	call	ax 		; do upwards sort
 14613 000012DE EB06                    	jmp	short ceNs
 14614                                  ceDn:
 14615 000012E0 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14616 000012E2 FFD0                    	call	ax		; do sort
 14617 000012E4 87DD                    	xchg	bx,bp		; swap ptrs back
 14618                                  ceNs:
 14619 000012E6 5E                      	pop	si		; SI = ptr to next sort code
 14620 000012E7 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14621                                  ceDone:
 14622                                  
 14623                                  ;	Get here either from unequal compare or sort code = 0.
 14624                                  ;	In the latter case, condition codes indicate equality,
 14625                                  ;	which is correct.
 14626                                  
 14627 000012E9 C3                      	retn
 14628                                  
 14629                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14630                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14631                                  
 14632                                  FieldCmps:		; call table of entry comparisons
 14633 000012EA [F412]                  	dw	CmpName
 14634 000012EC [FF12]                  	dw	CmpExt
 14635 000012EE [3D13]                  	dw	CmpTime
 14636 000012F0 [5913]                  	dw	CmpSize
 14637 000012F2 [5E13]                  	dw	CmpType
 14638                                  
 14639                                  ; ---------------------------------------------------------------------------
 14640                                  
 14641                                  ;***	CmpName - compare file name of two entries
 14642                                  ;***	CmpExt - compare extension of two entries
 14643                                  ;
 14644                                  ;	ENTRY	ES:BX = ptr to one entry
 14645                                  ;		ES:BP = ptr to another entry
 14646                                  ;
 14647                                  ;	EXIT	BX = unchanged
 14648                                  ;		BP = unchanged
 14649                                  ;		Condition flags set for same, above, or below
 14650                                  ;		comparing BX entry to BP entry.
 14651                                  ;
 14652                                  ;	USED:	AX,CX,DX,SI,DI
 14653                                  
 14654                                  	; 16/02/2023
 14655                                  CmpName:
 14656 000012F4 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14657 000012F6 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14658                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14659                                  	;add	si,1
 14660                                  	; 25/04/2023
 14661 000012F8 46                      	inc	si
 14662                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14663                                  	;add	di,1
 14664                                  	; 25/04/2023
 14665 000012F9 47                      	inc	di
 14666                                  	;mov	cx,size filename
 14667                                  				; CX = length of name
 14668 000012FA B90800                  	mov	cx,8
 14669 000012FD EB0C                    	jmp	short CmpStr
 14670                                  
 14671                                  CmpExt:
 14672                                  	; 07/06/2023
 14673                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14674                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14675                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14676                                  	;add	si,9
 14677                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14678                                  	;add	di,9
 14679                                  	;
 14680 000012FF BE0900                  	mov	si,9
 14681 00001302 89F7                    	mov	di,si ; mov di,9
 14682 00001304 01DE                    	add	si,bx
 14683 00001306 01EF                    	add	di,bp
 14684                                  	;
 14685                                  	;mov	cx,size fileext	; CX = length of extension field
 14686 00001308 B90300                  	mov	cx,3
 14687                                  
 14688                                  ;	Bugbug:	use symbol for subfunction code.
 14689                                  
 14690                                  CmpStr:	
 14691 0000130B 803E[4395]06            	cmp	byte [CountryPtrId],6
 14692 00001310 7527                    	jne	short cnNoCollTable
 14693                                  				; no collating table available
 14694                                  
 14695                                  ;*	Compare strings using collating table.
 14696                                  ;
 14697                                  ;	ES:SI = ptr to 1st string
 14698                                  ;	ES:DI = ptr to 2nd string
 14699                                  ;	CX = length
 14700                                  
 14701 00001312 55                      	push	bp		; preserve BP
 14702 00001313 53                      	push	bx		; preserve BX
 14703 00001314 1E                      	push	ds		; preserve DS
 14704 00001315 C51E[4495]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14705                                  	;assume	ds:NOTHING
 14706 00001319 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14707 0000131B 43                      	inc	bx
 14708 0000131C 43                      	inc	bx		; DS:BX = ptr to collating values
 14709                                  				; DS:[BX]-2 = size of table
 14710 0000131D 31C0                    	xor	ax,ax		; AX = 0 for starters
 14711                                  
 14712                                  ;	Bugbug:	Investigate removing collating table length checks.
 14713                                  
 14714                                  cnNextChar:
 14715 0000131F 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14716 00001322 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14717 00001323 39E8                    	cmp	ax,bp		; compare to collating table length
 14718 00001325 7301                    	jae	short cn1 	; char not in table
 14719 00001327 D7                      	xlat				
 14720                                  cn1:				; AL = AX = collating value
 14721 00001328 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14722                                  	;lods	byte ptr es:[si]
 14723 0000132A 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14724                                  				; ES:SI = ptr to next char 1st string
 14725 0000132C 39E8                    	cmp	ax,bp		; compare to collating table length
 14726 0000132E 7301                    	jae	short cn2	; char not in table
 14727 00001330 D7                      	xlat				
 14728                                  cn2:				; AL = AX = collating value
 14729 00001331 39D0                    	cmp	ax,dx		; compare collating values
 14730 00001333 E1EA                    	loope	cnNextChar	; until unequal or no more left
 14731                                  
 14732 00001335 1F                      	pop	ds		; restore DS
 14733                                  	;assume	ds:TRANGROUP
 14734 00001336 5B                      	pop	bx		; restore BX
 14735 00001337 5D                      	pop	bp		; restore BP
 14736 00001338 C3                      	retn
 14737                                  
 14738                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14739                                  ;	Don't we wish we could just do this all the time? Sigh.
 14740                                  
 14741                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14742                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14743                                  cnNoCollTable:
 14744                                  	;repe	cmps byte ptr es:[si],[di]
 14745                                  				;db 0F3h,26h,0A6h,0C3h
 14746 00001339 F3                      	repe	; 0F3h
 14747 0000133A 26                      	es	; 26h
 14748 0000133B A6                      	cmpsb	; 0A6h
 14749 0000133C C3                      	retn	; 0C3h
 14750                                  
 14751                                  ; ---------------------------------------------------------------------------
 14752                                  
 14753                                  ;***	CmpTime - compare entries by date/time
 14754                                  ;
 14755                                  ;	ENTRY	ES:BX = ptr to one entry
 14756                                  ;		ES:BP = ptr to another entry
 14757                                  ;
 14758                                  ;	EXIT	BX = unchanged
 14759                                  ;		BP = unchanged
 14760                                  ;		Condition flags set for same, above, or below
 14761                                  ;		 comparing BX entry to BP entry.
 14762                                  ;
 14763                                  ;	USED:	CX,SI,DI
 14764                                  ;
 14765                                  ;	NOTE	Filetime and filedate fields in our private entry
 14766                                  ;		structure must be adjacent and in that order.
 14767                                  
 14768                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14769                                  	; 07/06/2023
 14770                                  CmpTime:
 14771 0000133D 89DE                    	mov	si,bx
 14772 0000133F 89EF                    	mov	di,bp
 14773                                  	;add	si,filedate + size filedate - 1
 14774 00001341 83C610                  	add	si,16 ; 15+2-1
 14775                                  	;add	di,filedate + size filedate - 1
 14776 00001344 83C710                  	add	di,16 ; 15+2-1
 14777                                  	; 07/06/2023
 14778 00001347 BE1000                  	mov	si,16
 14779                                  CmpST2:		; 07/06/2023
 14780 0000134A 89F7                    	mov	di,si	; mov di,16
 14781 0000134C 01DE                    	add	si,bx
 14782 0000134E 01EF                    	add	di,bp
 14783                                  
 14784                                  	;mov	cx,size filetime + size filedate
 14785 00001350 B90400                  	mov	cx,4 ; 2+2
 14786 00001353 FD                      	std
 14787                                  	;repe	cmps byte ptr es:[si],[di]
 14788                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 14789 00001354 F3                      	repe	; 0F3h
 14790 00001355 26                      	es	; 26h
 14791 00001356 A6                      	cmpsb	; 0A6h
 14792                                  	
 14793 00001357 FC                      	cld	; 0FCh
 14794 00001358 C3                      	retn	; 0C3h
 14795                                  
 14796                                  ; ---------------------------------------------------------------------------
 14797                                  
 14798                                  ;***	CmpSize - compare entries by size
 14799                                  ;
 14800                                  ;	ENTRY	ES:BX = ptr to one entry
 14801                                  ;		ES:BP = ptr to another entry
 14802                                  ;
 14803                                  ;	EXIT	BX = unchanged
 14804                                  ;		BP = unchanged
 14805                                  ;		Condition flags set for same, above, or below
 14806                                  ;		 comparing BX entry to BP entry.
 14807                                  ;
 14808                                  ;	USED:	CX,SI,DI
 14809                                  
 14810                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14811                                  	; 07/06/2023
 14812                                  CmpSize:
 14813                                  	;mov	si,bx
 14814                                  	;mov	di,bp
 14815                                  	;;add	si,filesize + size filesize - 1
 14816                                  	;add	si,20  ; 17+4-1
 14817                                  	;;add	di,filesize + size filesize - 1
 14818                                  	;add	di,20  ; 17+4-1
 14819                                  	; 07/06/2023
 14820 00001359 BE1400                  	mov	si,20
 14821                                  	;;;
 14822 0000135C EBEC                    	jmp	short CmpST2 ; 07/06/2023
 14823                                  	;;;
 14824                                  ;CmpST2:
 14825                                  ;	mov	di,si	; mov di,20
 14826                                  ;	add	si,bx
 14827                                  ;	add	di,bp
 14828                                  ;
 14829                                  ;	;mov	cx,size filesize
 14830                                  ;	mov	cx,4
 14831                                  ;	std
 14832                                  ;	;repe	cmps byte ptr es:[si],[di]
 14833                                  ;				;db 0F3h,26h,0A6h
 14834                                  ;	repe	; 0F3h
 14835                                  ;	es	; 26h
 14836                                  ;	cmpsb	; 0A6h
 14837                                  ;
 14838                                  ;	cld
 14839                                  ;	retn
 14840                                  
 14841                                  ; ---------------------------------------------------------------------------
 14842                                  
 14843                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14844                                  ;
 14845                                  ;	ENTRY	ES:BX = ptr to one entry
 14846                                  ;		ES:BP = ptr to another entry
 14847                                  ;
 14848                                  ;	EXIT	BX = unchanged
 14849                                  ;		BP = unchanged
 14850                                  ;		Condition flags set for same, above, or below
 14851                                  ;		 comparing BX entry to BP entry.
 14852                                  ;
 14853                                  ;	USED:	AX
 14854                                  
 14855                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14856                                  CmpType:
 14857                                  	;mov	al,es:[bx].fileattr
 14858 0000135E 268A470C                	mov	al,[es:bx+12]
 14859                                  	;mov	ah,es:[bp].fileattr
 14860 00001362 268A660C                	mov	ah,[es:bp+12]
 14861                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14862                                  	;and	ax,1010h
 14863 00001366 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14864 00001369 38C4                    	cmp	ah,al
 14865 0000136B C3                      	retn
 14866                                  
 14867                                  ; ---------------------------------------------------------------------------
 14868                                  
 14869                                  ;***	DefaultAttr - set default attribute conditions
 14870                                  ;
 14871                                  ;	ENTRY	nothing
 14872                                  ;
 14873                                  ;	EXIT	CY clear
 14874                                  ;
 14875                                  ;	USED
 14876                                  ;
 14877                                  ;	EFFECTS
 14878                                  ;
 14879                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14880                                  
 14881                                  	; 16/02/2023
 14882                                  DefaultAttr:
 14883                                  	;mov	byte [AttrSpecified],6
 14884 0000136C C606[288C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14885                                  					; specify H and S
 14886 00001371 C606[298C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14887 00001376 F8                      	clc				; return success
 14888                                  dtRet:	; 18/02/2023
 14889 00001377 C3                      	retn
 14890                                  
 14891                                  ; ---------------------------------------------------------------------------
 14892                                  
 14893                                  ;***	DisplayTotals - display grand total stats
 14894                                  ;
 14895                                  ;	If we searched subdirectories, display the total # files found
 14896                                  ;	 and total size of files found.
 14897                                  ;	Display disk space remaining.
 14898                                  ;
 14899                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14900                                  ;		Bits contains setting of /s
 14901                                  ;		FCB contains drive #
 14902                                  ;
 14903                                  ;	EXIT	nothing
 14904                                  ;
 14905                                  ;	USES	AX,DX
 14906                                  ;		FileSiz
 14907                                  
 14908                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14909                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14910                                  
 14911                                  DisplayTotals:
 14912                                  	;;;test	Bits,mask subd
 14913                                  	;;test	word [_Bits],4
 14914                                  	;test	byte [_Bits],4
 14915 00001378 F606[208C]04            	test	byte [_Bits],mask.subd
 14916 0000137D 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14917                                  
 14918 0000137F E84F12                  	call	CRLF2			; start on new line
 14919 00001382 E8C403                  	call	UseLine
 14920                                  
 14921 00001385 BA[5781]                	mov	dx,total_ptr
 14922 00001388 E8643A                  	call	std_printf		; "Total:",cr,lf
 14923 0000138B E8BB03                  	call	UseLine
 14924                                  
 14925 0000138E A1[F78A]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14926 00001391 BE[FB8A]                	mov	si,FileSizTotal
 14927 00001394 BF[F38A]                	mov	di,FileSiz
 14928 00001397 A5                      	movsw
 14929 00001398 A5                      	movsw				; move total size to size variable
 14930 00001399 E87605                  	call	DisplayCntSiz		; display file count & size &
 14931                                  dtFree: 				;   (maybe) compression ratio
 14932 0000139C B436                    	mov	ah,36h
 14933                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14934 0000139E 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14935 000013A2 CD21                    	int	21h			; call DOS
 14936 000013A4 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14937 000013A7 74CE                    	jz	short dtRet		; can't get drive space - return
 14938 000013A9 F7E1                    	mul	cx
 14939 000013AB F7E3                    	mul	bx
 14940 000013AD A3[3C8C]                	mov	[Bytes_Free],ax
 14941 000013B0 8916[3E8C]              	mov	[Bytes_Free+2],dx
 14942 000013B4 BA[697F]                	mov	dx,bytmes_ptr
 14943 000013B7 E8353A                  	call	std_printf		; "nnn bytes free",cr,lf
 14944                                  	;call	UseLine
 14945                                  ;dtRet:
 14946                                  	;retn
 14947                                  	; 18/02/2023
 14948 000013BA E98C03                  	jmp	UseLine
 14949                                  
 14950                                  ; ---------------------------------------------------------------------------
 14951                                  
 14952                                  ;***	FileIsDevice - see if file looks like a device
 14953                                  ;
 14954                                  ;	ENTRY	PathPos = ptr to pathname
 14955                                  ;		PathCnt = length of pathname w/o terminating char
 14956                                  ;		DirBuf is DOS DTA
 14957                                  ;
 14958                                  ;	EXIT	ZR = set if file looks like a device
 14959                                  ;
 14960                                  ;	USED	AX,BX,CX,DX,DI
 14961                                  ;
 14962                                  ;	EFFECTS
 14963                                  ;
 14964                                  ;	  DTA buffer holds results of Find First function
 14965                                  ;
 14966                                  ;	NOTES
 14967                                  ;
 14968                                  ;	  We try to flag devices in two ways. First, we try
 14969                                  ;	  the DOS Find First function. It returns attribute bit 6
 14970                                  ;	  set on a successful find if it identifies a device name.
 14971                                  ;	  Unfortunately, it returns 'path not found' for a device
 14972                                  ;	  name terminated with colon, such as "CON:". So, we look
 14973                                  ;	  for any colon in the pathname after the 2nd character,
 14974                                  ;	  and flag the pathname as a device if we find one.
 14975                                  
 14976                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14977                                  FileIsDevice:
 14978 000013BD 8B16[248C]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 14979                                  
 14980 000013C1 89D7                    	mov	di,dx
 14981 000013C3 033E[228C]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 14982 000013C7 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 14983 000013C9 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 14984                                  
 14985 000013CB 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 14986 000013CD B44E                    	mov	ah,4Eh
 14987                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 14988 000013CF CD21                    	int	21h	 	 ; call DOS
 14989 000013D1 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 14990 000013D3 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 14991                                  
 14992                                  ;	Found a dir entry, see if Find First thinks it's a device.
 14993                                  
 14994                                  	;test	byte [DIRBUF+21],40h
 14995 000013D5 F606[E38B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 14996 000013DA 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 14997 000013DC 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 14998                                  	;jmp	short piRet
 14999                                  	; 25/04/2023
 15000                                  piRet:
 15001 000013DE C3                      	retn
 15002                                  
 15003                                  ;	Device attribute not returned by Find First function. But
 15004                                  ;	let's check for a colon anywhere in the pathname after the
 15005                                  ;	second byte.
 15006                                  ;
 15007                                  ;	DI = ptr to byte after pathname
 15008                                  
 15009                                  piCol:
 15010 000013DF 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15011 000013E0 B03A                    	mov	al,':'
 15012                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15013 000013E2 8B0E[228C]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15014 000013E6 49                      	dec	cx
 15015 000013E7 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15016 000013E8 09C9                    	or	cx,cx
 15017 000013EA 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15018 000013EC 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15019 000013EE FD                      	std			 ; scan downward
 15020 000013EF F2AE                    	repne	scasb
 15021 000013F1 FC                      	cld			 ; restore default upward direction
 15022                                  
 15023                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15024                                  ;piRet:
 15025 000013F2 C3                      	retn
 15026                                  
 15027                                  ;FileIsDevice endp
 15028                                  
 15029                                  ; ---------------------------------------------------------------------------
 15030                                  
 15031                                  ;***	FindFirst - find first directory entry to display
 15032                                  ;***	FindNext - find next directory entry to display
 15033                                  ;
 15034                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15035                                  ;		AttrSpecified, AttrSelect are set
 15036                                  ;
 15037                                  ;	EXIT	CY = clear if successful
 15038                                  ;		BX = offset in TPA buffer of directory entry found
 15039                                  ;
 15040                                  ;		If unsuccessful,
 15041                                  ;		CY = set
 15042                                  ;		AX = DOS error code
 15043                                  ;		DOS Get Extended Error call will get error code
 15044                                  ;
 15045                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15046                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15047                                  ;		but DOS Get Extended Error call WON'T return the correct
 15048                                  ;		error. That's ok, because we'll see the value in AX
 15049                                  ;		and recognize it as a non-error condition.
 15050                                  ;
 15051                                  ;	USED	AX,CX,DX,SI,DI
 15052                                  ;
 15053                                  ;	EFFECTS
 15054                                  ;
 15055                                  ;	  Entries in memory may be marked as output.
 15056                                  ;	  If not sorted, entry is loaded at TPA.
 15057                                  ;
 15058                                  ;	NOTES
 15059                                  ;
 15060                                  ;	  If we don't find a qualifying file, we return after the final
 15061                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15062                                  ;	   indicate an appropriate condition.
 15063                                  
 15064                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15065                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15066                                  	
 15067                                  FindFirst:
 15068                                  	;mov	ax,offset TRANGROUP:GetFirst
 15069 000013F3 B8[CA14]                	mov	ax,GetFirst
 15070 000013F6 EB03                    	jmp	short ffFindEntry
 15071                                  
 15072                                  	; 18/02/2023
 15073                                  FindNext:
 15074                                  	;mov	ax,offset TRANGROUP:GetNext
 15075 000013F8 B8[D814]                	mov	ax,GetNext
 15076                                  
 15077                                  ;	AX = address of correct disk get routine to use.
 15078                                  
 15079                                  ffFindEntry:
 15080 000013FB 06                      	push	es			; save TRANGROUP seg addr
 15081                                  	;;;test	Bits,mask inmem
 15082                                  	;;test	word [_Bits],20h
 15083                                  	;test	byte [_Bits],20h
 15084 000013FC F606[208C]20            	test	byte [_Bits],mask.inmem
 15085 00001401 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15086                                  
 15087                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15088                                  ;	There will always be one, or LoadEntries would've failed.
 15089                                  
 15090 00001403 E81A00                  	call	FindInMem		; find first entry in TPA
 15091 00001406 EB16                    	jmp	short ffRet		; return what TPA search returns
 15092                                  
 15093                                  ;	Get entry from disk.
 15094                                  
 15095                                  ffDisk:
 15096 00001408 FFD0                    	call	ax			; get entry from disk
 15097 0000140A 720E                    	jc	short ffGetErr		; get & return error
 15098 0000140C 8E06[C78A]              	mov	es,[TPA]		; ES = seg addr of TPA
 15099 00001410 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15100 00001412 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15101 00001414 E85601                  	call	LoadEntry		; load entry to TPA
 15102 00001417 F8                      	clc				; return success
 15103 00001418 EB04                    	jmp	short ffRet
 15104                                  
 15105                                  ffGetErr:
 15106 0000141A E8D308                  	call	 get_ext_error_number	; AX = DOS error code
 15107 0000141D F9                      	stc
 15108                                  ffRet:
 15109 0000141E 07                      	pop	es			; ES = TRANGROUP seg addr again
 15110 0000141F C3                      	retn
 15111                                  
 15112                                  ; ---------------------------------------------------------------------------
 15113                                  
 15114                                  ;***	FindInMem - find next directory entry in TPA buffer
 15115                                  ;
 15116                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15117                                  ;
 15118                                  ;	EXIT	BX = offset in TPA of entry found
 15119                                  ;
 15120                                  ;		If no more files,
 15121                                  ;		CY = set
 15122                                  ;		AX = DOS 'no more files' error code
 15123                                  ;
 15124                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15125                                  ;
 15126                                  ;	EFFECTS
 15127                                  ;
 15128                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15129                                  
 15130                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15131                                  FindInMem:
 15132 00001420 8E06[C78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15133 00001424 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15134 00001426 FC                      	cld				; make sure default string direction is up
 15135                                  	
 15136 00001427 E86D00                  	call	FindOneInMem		; locate an entry
 15137 0000142A 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15138                                  
 15139                                  ;	BX = ptr to entry in TPA
 15140                                  
 15141                                  fiBest:
 15142 0000142C 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15143                                  fiNext:
 15144 0000142E E87300                  	call	FindNextInMem		; locate next entry
 15145 00001431 720C                    	jc	short fiFound		; no more, best entry so far wins
 15146                                  
 15147                                  ;	BX = ptr to next entry
 15148                                  
 15149 00001433 E88CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15150 00001436 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15151 00001438 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15152                                  
 15153                                  fiNoMore:
 15154                                  
 15155                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15156                                  
 15157                                  	;mov	ax,18
 15158 0000143A B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15159 0000143D F9                      	stc				; return error
 15160                                  	;jmp	short fiRet
 15161                                  	; 18/02/2023
 15162 0000143E C3                      	retn
 15163                                  
 15164                                  fiFound:
 15165 0000143F 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15166 00001441 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15167 00001445 F8                      	clc				; return success
 15168                                  fiRet:
 15169 00001446 C3                      	retn
 15170                                  
 15171                                  ; ---------------------------------------------------------------------------
 15172                                  
 15173                                  ;***	FindNextChild - find next subdirectory in current directory
 15174                                  ;
 15175                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15176                                  ;		DirBuf is established DTA
 15177                                  ;
 15178                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15179                                  ;
 15180                                  ;		If failure,
 15181                                  ;		CY = set
 15182                                  ;		DOS Get Extended Error call will get error
 15183                                  ;
 15184                                  ;	USED	AX,CX,DX,SI,DI,BP
 15185                                  ;
 15186                                  ;	EFFECTS
 15187                                  ;
 15188                                  ;	  DirBuf is used for find first/next calls.
 15189                                  ;
 15190                                  ;	NOTES
 15191                                  ;
 15192                                  ;	  We keep on checking files until DOS returns an error. If
 15193                                  ;	  the error is 'no more files' and the temp filename is not
 15194                                  ;	  the initial high tag, copy the temp to the child's name spot
 15195                                  ;	  and return success. Otherwise, send the error back to caller.
 15196                                  ;
 15197                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15198                                  
 15199                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15200                                  FindNextChild:
 15201 00001447 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15202                                  	;shove	00FFh			; temp filename = high tag
 15203 0000144A B8FF00                  	mov	ax,0FFh
 15204 0000144D 50                      	push	ax
 15205 0000144E 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15206                                  	;shove	"*"	
 15207 00001450 B02A                    	mov	al,'*'  ; ax = 002Ah
 15208 00001452 50                      	push	ax
 15209                                  	;;shove	".*" 
 15210                                  	;mov	ax,"*."
 15211                                  	;mov	ax,2E2Ah
 15212 00001453 B42E                    	mov	ah,'.'
 15213 00001455 50                      	push	ax
 15214 00001456 E8F704                  	call	GetDriveLtr		; AX = "d:"
 15215 00001459 50                      	push	ax
 15216 0000145A 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15217                                  
 15218                                  ;	See that the stack is restored properly at the end of this proc.
 15219                                  
 15220                                  	;mov	cx,10h
 15221 0000145C B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15222 0000145F B44E                    	mov	ah,4Eh
 15223                                  	;mov	ah,Find_First
 15224 00001461 CD21                    	int	21h			; DOS- Find First matching file
 15225 00001463 722C                    	jc	short fcRet		; return error
 15226                                  
 15227 00001465 E835FE                  	call	CheckChild		; check child against last, temp
 15228                                  fcNext:	
 15229                                  	;mov	cx,10h
 15230 00001468 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15231 0000146B B44F                    	mov	ah,4Fh
 15232                                  	;mov	ah,Find_Next
 15233 0000146D CD21                    	int	21h			; DOS- Find Next matching file
 15234 0000146F 7205                    	jc	short fcErr		; examine error
 15235                                  
 15236 00001471 E829FE                  	call	CheckChild		; check child against last, temp
 15237 00001474 EBF2                    	jmp	short fcNext		; go find another child
 15238                                  
 15239                                  fcErr:
 15240 00001476 E87708                  	call	get_ext_error_number	; AX = extended error code
 15241                                  	;cmp	ax,18
 15242 00001479 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15243 0000147C 7512                    	jne	short fcNope		; some other error- return it
 15244                                  
 15245                                  ;	We ran out of files. See if we qualified at least one.
 15246                                  
 15247 0000147E 807E00FF                	cmp	byte [bp],0FFh
 15248 00001482 740C                    	je	short fcNope		; temp filename is unused- no child
 15249                                  
 15250                                  ;	Move temp filename to child name position.
 15251                                  
 15252 00001484 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15253 00001486 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15254                                  fcMove:
 15255 00001488 AC                      	lodsb				; AL = next byte of filename
 15256 00001489 AA                      	stosb				; store byte
 15257 0000148A 08C0                    	or	al,al
 15258 0000148C 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15259 0000148E EBF8                    	jmp	short fcMove		; go move another byte
 15260                                  fcNope:
 15261 00001490 F9                      	stc				; return error
 15262                                  fcRet:
 15263 00001491 9F                      	lahf
 15264 00001492 83C414                  	add	sp,20			; restore stack
 15265 00001495 9E                      	sahf
 15266 00001496 C3                      	retn
 15267                                  
 15268                                  ; ---------------------------------------------------------------------------
 15269                                  
 15270                                  ;***	FindOneInMem - find the first available entry in TPA
 15271                                  ;***	FindNextInMem - find the next available entry in TPA
 15272                                  ;
 15273                                  ;	ENTRY	ES = TPA seg addr
 15274                                  ;		BX = ptr to entry in TPA
 15275                                  ;
 15276                                  ;	EXIT	BX = ptr to entry found
 15277                                  ;		CY = set if no more entries available in TPA
 15278                                  ;
 15279                                  ;	USED	AL
 15280                                  
 15281                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15282                                  FindOneInMem:
 15283 00001497 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15284 0000149A 3C01                    	cmp	al,1
 15285 0000149C 7406                    	je	short FindNextInMem	; entry has already been used
 15286 0000149E 3CFF                    	cmp	al,0FFh
 15287 000014A0 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15288                                  
 15289                                  ;	BX = ptr to entry that hasn't been output yet.
 15290                                  
 15291 000014A2 F8                      	clc				; return success
 15292 000014A3 C3                      	retn
 15293                                  
 15294                                  FindNextInMem:
 15295 000014A4 83C315                  	add	bx,21
 15296                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15297 000014A7 EBEE                    	jmp	short FindOneInMem	; go look at it
 15298                                  foNoMore:
 15299 000014A9 F9                      	stc				; ran out of entries, return failure
 15300 000014AA C3                      	retn
 15301                                  
 15302                                  ; ---------------------------------------------------------------------------
 15303                                  
 15304                                  ;***	GetEnvValue - get value of our environment variable
 15305                                  ;
 15306                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15307                                  ;
 15308                                  ;	EXIT	CY = set if environment variable not in environment
 15309                                  ;
 15310                                  ;		Otherwise:
 15311                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15312                                  ;
 15313                                  ;	USED	AX,BX,CX,DX,DI
 15314                                  ;		(We assume the (almost) worst, since we don't know about
 15315                                  ;		Find_Name_In_Environment.)
 15316                                  ;
 15317                                  ;	EFFECTS
 15318                                  ;
 15319                                  ;	  ScanBuf is loaded with value text
 15320                                  
 15321                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15322                                  GetEnvValue:
 15323 000014AB 06                      	push	es				; save ES
 15324                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15325 000014AC BE[9F81]                	mov	si,DirEnvVar
 15326                                  	;invoke	Find_Name_In_Environment
 15327 000014AF E8630E                  	call	find_name_in_environment
 15328 000014B2 7214                    	jc	short geRet			; name not found in environment
 15329                                  
 15330                                  ;	ES:DI = ptr to value of environment variable
 15331                                  ;	We're assuming DS, CS, and SS are unchanged.
 15332                                  
 15333 000014B4 1E                      	push	ds
 15334 000014B5 06                      	push	es
 15335 000014B6 1F                      	pop	ds
 15336 000014B7 07                      	pop	es
 15337                                  
 15338                                  	;assume	ds:nothing
 15339                                  
 15340                                  ;	DS = seg addr of environment variable value (in environment segment)
 15341                                  ;	ES = TRANGROUP seg addr
 15342                                  
 15343 000014B8 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15344                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15345 000014BA BF[0E8D]                	mov	di,ScanBuf
 15346                                  geLoop:
 15347                                  ;@@:	
 15348 000014BD AC                      	lodsb
 15349 000014BE 08C0                    	or	al,al
 15350 000014C0 AA                      	stosb
 15351                                  	;loopnz	@B		; move the string, including trailing null
 15352 000014C1 E0FA                    	loopnz	geLoop
 15353                                  
 15354 000014C3 06                      	push	es
 15355 000014C4 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15356                                  	;assume	ds:TRANGROUP
 15357                                  
 15358                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15359 000014C5 BE[0E8D]                	mov	si,ScanBuf
 15360                                  geRet:
 15361 000014C8 07                      	pop	es				; restore ES
 15362 000014C9 C3                      	retn
 15363                                  
 15364                                  ; ---------------------------------------------------------------------------
 15365                                  
 15366                                  ;***	GetFirst - get first directory entry from disk
 15367                                  ;
 15368                                  ;	ENTRY	DOS DTA established at DirBuf
 15369                                  ;		FCB contains drive # and filename
 15370                                  ;		Current directory (on selected drive) is the one to search
 15371                                  ;		AttrSpecified & AttrSelect masks set
 15372                                  ;
 15373                                  ;	EXIT	CY = clear if success
 15374                                  ;		DirBuf contains extended FCB for file found
 15375                                  ;
 15376                                  ;		If unsuccessful,
 15377                                  ;		CY = set
 15378                                  ;		Ready for DOS Get Extended Error call
 15379                                  ;
 15380                                  ;	USED	AX,DX
 15381                                  ;
 15382                                  ;	EFFECTS
 15383                                  ;
 15384                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15385                                  ;	  FCB-1 = attribute mask to find all files
 15386                                  ;	  These fields should remain unmodified for GetNext calls.
 15387                                  ;
 15388                                  ;***	GetNext - get next directory entry from disk
 15389                                  ;
 15390                                  ;	ENTRY	As for GetFirst, plus
 15391                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15392                                  ;
 15393                                  ;	EXIT	As for GetFirst
 15394                                  ;
 15395                                  ;	USED	AX,DX
 15396                                  
 15397                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15398                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15399                                  GetFirst:
 15400                                  	;mov	byte [55h],0FFh	; -1
 15401 000014CA C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15402                                  	;mov	byte [5Bh],16h
 15403 000014CF C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15404                                  					; find any file
 15405                                  	; 07/06/2023
 15406                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15407 000014D4 B411                    	mov	ah,11h
 15408                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15409                                  	; 07/06/2023
 15410                                  	;int	21h			; call DOS
 15411                                  	;shl	al,1			; CY = set if error
 15412                                  	;jc	short gfRet		; return error
 15413                                  	;jmp	short gfFound		; go look at attr's
 15414                                  	; 07/06/2023
 15415 000014D6 EB02                    	jmp	short GetFrstNxt
 15416                                  GetNext:
 15417                                  	; 07/06/2023
 15418                                  	;;mov	dx,55h
 15419                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15420 000014D8 B412                    	mov	ah,12h
 15421                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15422                                  GetFrstNxt:
 15423                                  	; 07/06/2023
 15424 000014DA BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15425                                  	;
 15426 000014DD CD21                    	int	21h			; call DOS
 15427 000014DF D0E0                    	shl	al,1			; CY = set if error
 15428 000014E1 7211                    	jc	short gfRet		; return error
 15429                                  
 15430                                  ;*	Found an entry. Check attributes.
 15431                                  gfFound:
 15432                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15433                                  	;mov	al,[DIRBUF+19]
 15434 000014E3 A0[E18B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15435 000014E6 8A26[288C]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15436 000014EA 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15437 000014EC 2226[298C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15438 000014F0 38E0                    	cmp	al,ah
 15439 000014F2 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15440                                  gfRet:
 15441 000014F4 C3                      	retn
 15442                                  
 15443                                  ; ---------------------------------------------------------------------------
 15444                                  
 15445                                  ;***	ListDir - search for and list files in the current directory
 15446                                  ;
 15447                                  ;	List header, files, and trailer for current directory on selected
 15448                                  ;	drive. Header & trailer are listed if at least one file is found.
 15449                                  ;	If no qualifying files are found, no display output occurs.
 15450                                  ;
 15451                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15452                                  ;		FCB contains selected drive # and filename spec
 15453                                  ;		Option bits, attribute masks, and sort codes set up
 15454                                  ;
 15455                                  ;	EXIT	CY = clear if no error
 15456                                  ;		FileCnt = # files found & displayed
 15457                                  ;
 15458                                  ;		If error,
 15459                                  ;		CY = set
 15460                                  ;		Ready for DOS Get Extended Error call
 15461                                  ;
 15462                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15463                                  ;		FileSiz
 15464                                  ;
 15465                                  ;	EFFECTS
 15466                                  ;
 15467                                  ;	  FileCntTotal, FileSizTotal are updated.
 15468                                  ;	  Files found are listed. A directory header and trailer are
 15469                                  ;	   displayed only if files are found.
 15470                                  
 15471                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15472                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15473                                  
 15474                                  ListDir:
 15475 000014F5 31C0                    	xor	ax,ax ; 0
 15476 000014F7 A3[F18A]                	mov	[FileCnt],ax		; zero file count
 15477 000014FA A3[F38A]                	mov	[FileSiz],ax		; zero file size accumulator
 15478 000014FD A3[F58A]                	mov	[FileSiz+2],ax
 15479                                  	;cmp	byte [DestBuf],0	; check for sort code
 15480                                  	; 31/07/2024
 15481 00001500 3806[518C]              	cmp	[DestBuf],al ; 0
 15482 00001504 740A                    	je	short ld1		; no sort
 15483 00001506 E83000                  	call	LoadEntries		; load entries for sorted listing
 15484 00001509 7305                    	jnc	short ld1		; no error - continue
 15485 0000150B E8E207                  	call	get_ext_error_number	; AX = DOS error code
 15486                                  	; 19/02/2023
 15487                                  	;stc
 15488 0000150E EB12                    	jmp	short ldErr		; return error
 15489                                  ld1:
 15490 00001510 E8E0FE                  	call	FindFirst		; find first file
 15491 00001513 720D                    	jc	short ldErr		; not found, return error
 15492                                  
 15493                                  ;	BX = offset in TPA buffer of entry found
 15494                                  
 15495 00001515 E8E102                  	call	DisplayHeader		; if at least one file, display header
 15496                                  ldNext:
 15497 00001518 E8B902                  	call	DisplayFile		; display the file entry
 15498                                  ;ldNext:
 15499 0000151B E8DAFE                  	call	FindNext		; find another file
 15500 0000151E 7202                    	jc	short ldErr		; not found
 15501                                  	;call	DisplayFile		; display entry
 15502                                  	;jmp	short ldNext		; go find another one
 15503                                  	; 19/02/2023
 15504 00001520 EBF6                    	jmp	short ldNext
 15505                                  ldErr:
 15506                                  	;cmp	ax,2
 15507 00001522 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15508 00001525 7407                    	je	short ldDone		; file not found, we're done
 15509                                  	;cmp	ax,18
 15510 00001527 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15511 0000152A 7402                    	je	short ldDone		; no more files, we're done
 15512 0000152C F9                      	stc
 15513                                  	;jmp	short ldRet
 15514                                  	; 19/02/2023
 15515 0000152D C3                      	retn
 15516                                  ldDone:
 15517 0000152E 833E[F18A]00            	cmp	word [FileCnt],0
 15518                                  	;je	short ld2		; no files found, just return
 15519                                  	; 25/04/2023
 15520 00001533 7403                    	jz	short ldRet
 15521 00001535 E8CA03                  	call	DisplayTrailer		; display trailing info
 15522                                  	; 08/06/2023
 15523                                  	; cf=0
 15524                                  ;ld2:	
 15525                                  	;clc				; return success
 15526                                  ldRet:
 15527 00001538 C3                      	retn
 15528                                  
 15529                                  ; ---------------------------------------------------------------------------
 15530                                  
 15531                                  ;***	LoadEntries - attempt to load entries from current directory
 15532                                  ;
 15533                                  ;	Load all qualifying directory entries from the current directory
 15534                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15535                                  ;	other than 'no more files', return to caller with carry flag set.
 15536                                  ;	If we run out of buffer space, display a message that we haven't
 15537                                  ;	enough memory to sort this directory, but return without error.
 15538                                  ;	Other routines know whether or not entries have been loaded by
 15539                                  ;	the 'inmem' flag bit, which we set here.
 15540                                  ;
 15541                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15542                                  ;	this allows sorting over 3000 entries in a directory.
 15543                                  ;
 15544                                  ;	ENTRY	Tpa = buffer seg addr
 15545                                  ;		BytCnt = buffer length, in bytes
 15546                                  ;		Current directory (on selected drive) is the one to load
 15547                                  ;		FCB contains drive # and filespec
 15548                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15549                                  ;
 15550                                  ;	EXIT	CY = set if error
 15551                                  ;		If error, DOS Get Extended Error will get error info
 15552                                  ;
 15553                                  ;	USED	AX,CX,DX,SI,DI
 15554                                  ;
 15555                                  ;	EFFECTS
 15556                                  ;
 15557                                  ;	  Inmem bit of Bits = set if load succeeded.
 15558                                  ;	  Tpa buffer contains directory entries.
 15559                                  ;	  Byte after last entry = 0FFh.
 15560                                  
 15561                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15562                                  LoadEntries:
 15563 00001539 06                      	push	es			; save TRANGROUP seg addr
 15564 0000153A 8E06[C78A]              	mov	es,[TPA]		; ES = TPA seg addr
 15565 0000153E 31FF                    	xor	di,di			; ES:DI = destination ptr
 15566                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15567                                  	;;and	word [_Bits],0FFDFh
 15568                                  	;and	byte [_Bits],0DFh	; not 20h
 15569 00001540 8026[208C]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15570                                  
 15571 00001545 E882FF                  	call	GetFirst		; look for first file
 15572 00001548 7221                    	jc	short leRet		; return any error
 15573 0000154A E82000                  	call	LoadEntry		; load entry into TPA
 15574                                  leNext:
 15575 0000154D E888FF                  	call	GetNext			; get another file
 15576 00001550 720F                    	jc	short leLoaded		; assume any error is no more files
 15577 00001552 A1[E68A]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15578 00001555 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15579                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15580 00001557 83F817                  	cmp	ax,23 ; 21+2 
 15581 0000155A 720E                    	jb	short leOk		; not enough memory left, give up
 15582 0000155C E80E00                  	call	LoadEntry		; load entry into TPA
 15583 0000155F EBEC                    	jmp	short leNext		; go get another file
 15584                                  
 15585                                  leLoaded:
 15586 00001561 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15587                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15588                                  	;;or	word [_Bits],20h
 15589                                  	;or	byte [_Bits],20h
 15590 00001565 800E[208C]20            	or	byte [_Bits],mask.inmem
 15591                                  	; 25/04/2023
 15592                                  	; cf = 0
 15593                                  leOk:
 15594 0000156A F8                      	clc				; return no error
 15595                                  leRet:
 15596 0000156B 07                      	pop	es			; ES = TRANGROUP seg addr again
 15597 0000156C C3                      	retn
 15598                                  
 15599                                  
 15600                                  ; ---------------------------------------------------------------------------
 15601                                  
 15602                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15603                                  ;
 15604                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15605                                  ;		DirBuf contains extended FCB of entry to load
 15606                                  ;
 15607                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15608                                  ;
 15609                                  ;	USED	AX,CX,SI
 15610                                  ;
 15611                                  ;	NOTES
 15612                                  ;
 15613                                  ;	  I could've used symbolic offsets and sizes of fields from
 15614                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15615                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15616                                  ;	   as well as our private directory entry structure.
 15617                                  ;
 15618                                  ;	  We force a zero size for subdirectory files. A zero size is
 15619                                  ;	   ordinarily returned for subdirectories, but with Novell
 15620                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15621                                  
 15622                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15623                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15624                                  LoadEntry:
 15625                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15626 0000156D BE[D68B]                	mov	si,DIRBUF+8
 15627 00001570 30C0                    	xor	al,al				; AL = 0
 15628 00001572 AA                      	stosb					; 'used' byte = false
 15629 00001573 B90B00                  	mov	cx,11
 15630 00001576 F3A4                    	rep	movsb				; transfer filename & extension
 15631 00001578 AC                      	lodsb					; AL = attrib byte
 15632 00001579 AA                      	stosb					; store attrib byte
 15633                                  	;add	si,10 ; 22-11-1
 15634                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15635 0000157A 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15636 0000157D A5                      	movsw					; transfer time
 15637 0000157E A5                      	movsw					; transfer date
 15638 0000157F 46                      	inc	si				; skip alloc unit
 15639 00001580 46                      	inc	si
 15640                                  	;and	al,10h
 15641 00001581 2410                    	and	al,ATTR_DIRECTORY
 15642 00001583 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15643 00001585 A5                      	movsw
 15644 00001586 A5                      	movsw					; transfer size
 15645 00001587 C3                      	retn
 15646                                  leSetDirSize:
 15647 00001588 31C0                    	xor	ax,ax ; 0
 15648 0000158A AB                      	stosw
 15649 0000158B AB                      	stosw					; store zero size
 15650 0000158C C3                      	retn
 15651                                  
 15652                                  ; ---------------------------------------------------------------------------
 15653                                  
 15654                                  ;***	NoOrder - turn sorting off
 15655                                  ;
 15656                                  ;	ENTRY	nothing
 15657                                  ;
 15658                                  ;	EXIT	CY clear
 15659                                  ;
 15660                                  ;	USED	AX
 15661                                  ;
 15662                                  ;	EFFECTS
 15663                                  ;
 15664                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15665                                  
 15666                                  	; 19/02/2023
 15667                                  NoOrder:
 15668 0000158D C606[518C]00            	mov	byte [DestBuf],0
 15669                                  				; no sort
 15670 00001592 F8                      	clc			; no error
 15671 00001593 C3                      	retn
 15672                                  
 15673                                  ; ---------------------------------------------------------------------------
 15674                                  
 15675                                  ;***	OnOffSw - record occurence of on/off option switch
 15676                                  ;
 15677                                  ;	ENTRY	DI = index into word list of switches
 15678                                  ;
 15679                                  ;	EXIT	CY clear
 15680                                  ;
 15681                                  ;	USED	AX,CX
 15682                                  ;
 15683                                  ;	EFFECTS
 15684                                  ;
 15685                                  ;	  Bits modified to indicate option state.
 15686                                  
 15687                                  	; 19/02/2023
 15688                                  OnOffSw:
 15689 00001594 89F9                    	mov	cx,di		; CX = index into word list of options
 15690 00001596 D1E9                    	shr	cx,1
 15691 00001598 D1E9                    	shr	cx,1		; CX = bit position of option
 15692 0000159A B80100                  	mov	ax,1		
 15693 0000159D D3E0                    	shl	ax,cl		; AX = bit mask of option
 15694 0000159F F7C70200                	test	di,2		; check if it is a negated option
 15695 000015A3 7405                    	jz	short oo1	; it's negated
 15696                                  	;or	Bits,ax		; turn option on
 15697 000015A5 0906[208C]              	or	[_Bits],ax
 15698                                  	;jmp	short ooRet
 15699                                  	; 19/02/2023
 15700                                  	;cf=0
 15701 000015A9 C3                      	retn
 15702                                  oo1:	
 15703 000015AA F7D0                    	not	ax		; AX = complemented bit mask of option
 15704                                  	;and	Bits,ax		; turn option off
 15705 000015AC 2106[208C]              	and	[_Bits],ax
 15706                                  ooRet:
 15707                                  	; 19/02/2023
 15708                                  	;cf=0
 15709                                  	;clc			; always return success
 15710 000015B0 C3                      	retn
 15711                                  
 15712                                  ; ---------------------------------------------------------------------------
 15713                                  
 15714                                  ;***	ParseAttr - parse and record /A option
 15715                                  ;
 15716                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15717                                  ;
 15718                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15719                                  ;
 15720                                  ;		For parse error, we set up for Std_EPrintf call:
 15721                                  ;		AX = parse error code, like system parser
 15722                                  ;		DX = ptr to message block
 15723                                  ;
 15724                                  ;	USED	AX,CX,DX,DI
 15725                                  ;
 15726                                  ;	EFFECTS
 15727                                  ;
 15728                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15729                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15730                                  ;
 15731                                  ;	  For parse error, we set up for Std_EPrintf call:
 15732                                  ;	  Msg_Disp_Class = parse error message class
 15733                                  ;	  Message block (see DX) is set up for parse error message
 15734                                  
 15735                                  	; 19/02/2023
 15736                                  ParseAttr:
 15737 000015B1 56                      	push	si			; save SI
 15738 000015B2 C606[288C]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15739                                  
 15740                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15741                                  
 15742                                  	;;mov	si,word ptr [bx].ValuePtr
 15743                                  					; SI = ptr to string after /A
 15744                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15745 000015B7 8B7704                  	mov	si,[bx+4]
 15746                                  paLoop:	
 15747 000015BA BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15748 000015BD AC                      	lodsb				; AL = next char in string
 15749 000015BE 08C0                    	or	al,al
 15750                                  	;jz	short paOk		; it's terminating null, we're done
 15751                                  	; 19/02/2023
 15752 000015C0 742F                    	jz	short paRet ; cf=0
 15753 000015C2 3C2D                    	cmp	al,'-'
 15754 000015C4 7502                    	jne	short pa1		; not '-', go look for letter
 15755 000015C6 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15756 000015C7 AC                      	lodsb				; AL = next char
 15757                                  pa1:	
 15758                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15759                                  					; DI = ptr to attrib letter list
 15760 000015C8 BF[5784]                	mov	di,AttrLtrs ; "RHSvDA"
 15761                                  	;mov	cx,6
 15762 000015CB B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15763 000015CE F2AE                    	repne	scasb			; look for our letter in the list
 15764 000015D0 751B                    	jne	short paErr		; not found, return error
 15765                                  
 15766 000015D2 F7D1                    	not	cx
 15767                                  	;add	cx,6
 15768 000015D4 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15769                                  
 15770                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15771                                  ;	starting from bit 0.
 15772                                  
 15773                                  ;	Record this attribute bit in AttrSpecified.
 15774                                  
 15775 000015D7 B001                    	mov	al,1
 15776 000015D9 D2E0                    	shl	al,cl			; AL = mask for our bit
 15777 000015DB 0806[288C]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15778                                  
 15779                                  ;	Record the selected state for this attribute in AttrSelect.
 15780                                  ;	DX = 0 or 1, the selected state for this attribute.
 15781                                  
 15782 000015DF F6D0                    	not	al			; AL = mask for all other bits
 15783 000015E1 2006[298C]              	and	[AttrSelect],al		; clear our bit
 15784 000015E5 D2E2                    	shl	dl,cl			; DL = our bit state in position
 15785 000015E7 0816[298C]              	or	[AttrSelect],dl		; set selected attr state
 15786 000015EB EBCD                    	jmp	short paLoop		; go look at next char
 15787                                  
 15788                                  ;	The attribute letter string is invalid.
 15789                                  
 15790                                  paErr:	
 15791 000015ED E87103                  	call	SetupParamError		; set message up for Std_EPrintf
 15792 000015F0 F9                      	stc		   		; return error
 15793                                  	; 19/02/2023
 15794                                  	;jmp	short paRet
 15795                                  ;paOk:
 15796                                  	;clc				; return success		
 15797                                  paRet:	
 15798 000015F1 5E                      	pop	si			; restore SI
 15799 000015F2 C3                      	retn
 15800                                  
 15801                                  ; ---------------------------------------------------------------------------
 15802                                  
 15803                                  ;***	ParseLine - parse a line of text
 15804                                  ;
 15805                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15806                                  ;	error occurs.
 15807                                  ;
 15808                                  ;	ENTRY	DS:SI = ptr to text
 15809                                  ;		CS, DS, ES = TRANGROUP seg addr
 15810                                  ;
 15811                                  ;	EXIT	AX = last return code from system parser
 15812                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15813                                  ;
 15814                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15815                                  ;		DX = ptr to message block
 15816                                  ;
 15817                                  ;	USED	BX,CX,DX,SI,DI
 15818                                  ;
 15819                                  ;	EFFECTS
 15820                                  ;
 15821                                  ;	  Bits may contain new option settings.
 15822                                  ;	  DestBuf may contain new series of sort codes.
 15823                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15824                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15825                                  ;	  PathPos, PathCnt updated for new pathname.
 15826                                  ;
 15827                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15828                                  ;	  Msg_Disp_Class = parse error class
 15829                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15830                                  ;	  Message block (see DX) is set up for parse error message
 15831                                  
 15832                                  	; 19/02/2023
 15833                                  Parse_Line:
 15834                                  	; 04/05/2023
 15835 000015F3 BF[2485]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15836 000015F6 31C9                    	xor	cx,cx			; CX = # positionals found
 15837                                  plPars:
 15838 000015F8 E8BE0B                  	call	Parse_With_Msg		; call parser
 15839 000015FB 83F8FF                  	cmp	ax,-1
 15840                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15841 000015FE 7411                    	je	short plRet		; EOL encountered, return
 15842 00001600 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15843 00001603 750C                    	jne	short plRet		; parse error occurred, return
 15844                                  
 15845                                  ;	Parse call succeeded. We have a filespec or a switch.
 15846                                  ;	DX = ptr to result buffer
 15847                                  
 15848 00001605 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15849 00001607 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15850 0000160A 7406                    	je	short plFil		; we have a filespec
 15851                                  
 15852 0000160C E85900                  	call	ParseSwitch		; else we have a switch
 15853                                  	;jc	short plRet		; error parsing switch, return
 15854                                  	;jmp	short plPars		; parse more
 15855                                  	; 19/02/2023
 15856 0000160F 73E7                    	jnc	short plPars
 15857                                  plRet:
 15858 00001611 C3                      	retn	
 15859                                  plFil:	
 15860 00001612 E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15861 00001615 EBE1                    	jmp	short plPars		; parse more
 15862                                  ;plRet:
 15863                                  ;	retn
 15864                                  
 15865                                  ; ---------------------------------------------------------------------------
 15866                                  
 15867                                  ;***	ParseOrder - parse and record /O option
 15868                                  ;
 15869                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15870                                  ;
 15871                                  ;	EXIT	CY = set if error occurs parsing order
 15872                                  ;
 15873                                  ;		For parse error, we set up for Std_EPrintf call:
 15874                                  ;		AX = parse error code, like system parser
 15875                                  ;		DX = ptr to message block
 15876                                  ;
 15877                                  ;	USED	AX,CX,DX,DI
 15878                                  ;
 15879                                  ;	EFFECTS
 15880                                  ;
 15881                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15882                                  ;
 15883                                  ;	  For parse error, we set up for Std_EPrintf call:
 15884                                  ;	  Msg_Disp_Class = parse error message class
 15885                                  ;	  Message block (see DX) is set up for parse error message
 15886                                  
 15887                                  	; 19/02/2023
 15888                                  ParseOrder:
 15889 00001617 56                      	push	si			; save SI
 15890 00001618 53                      	push	bx			; save ptr to result buffer
 15891                                  
 15892                                  	;;mov	si,word ptr [bx].ValuePtr
 15893                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15894 00001619 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15895                                  	;mov	bx,offset TRANGROUP:DestBuf
 15896                                  	; 08/06/2023 (BugFix)
 15897 0000161C BB[518C]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 15898 0000161F 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15899 00001621 08C0                    	or	al,al
 15900 00001623 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15901                                  
 15902                                  ;	We have /O alone. Set standard sort order.
 15903                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15904                                  
 15905 00001625 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15906 00001628 43                      	inc	bx
 15907 00001629 C60701                  	mov	byte [bx],1		; then by name
 15908 0000162C 43                      	inc	bx
 15909 0000162D C60702                  	mov	byte [bx],2		; then by extension
 15910 00001630 43                      	inc	bx
 15911 00001631 EB2F                    	jmp	short poOk		; return success
 15912                                  
 15913                                  ;	We have /O<something>. Parse sort order letters.
 15914                                  
 15915                                  poLtr:	
 15916 00001633 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15917 00001635 AC                      	lodsb				; AL = next sort order letter
 15918 00001636 08C0                    	or	al,al
 15919 00001638 7428                    	jz	short poOk		; NUL found, return success
 15920                                  
 15921 0000163A 3C2D                    	cmp	al,'-'
 15922 0000163C 7503                    	jne	short po1		; not '-', go look for letter
 15923 0000163E B280                    	mov	dl,80h			; DL = downward sort mask
 15924 00001640 AC                      	lodsb				; AL = next char
 15925                                  po1:
 15926                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15927                                  	; 08/06/2023 (BugFix)
 15928 00001641 BF[5D84]                	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
 15929 00001644 B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15930 00001647 F2AE                    	repne	scasb			; look for our letter in the list
 15931 00001649 7510                    	jne	short poErr		; not found, return error
 15932                                  
 15933 0000164B F7D9                    	neg	cx
 15934 0000164D 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15935                                  
 15936 00001650 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15937 00001652 880F                    	mov	[bx],cl			; store sort order code in buffer
 15938 00001654 43                      	inc	bx			; BX = ptr to next spot in buffer
 15939                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15940 00001655 81FB[A88C]              	cmp	bx,EndDestBuf
 15941                                  	;jae	short poErr		; too many letters
 15942                                  	;
 15943                                  	;jmp	short poLtr		; go look at next char
 15944                                  	; 19/02/2023
 15945 00001659 72D8                    	jb	short poLtr
 15946                                  
 15947                                  ;	The sort order string is invalid.  
 15948                                  
 15949                                  poErr:
 15950 0000165B 5B                      	pop	bx			; BX = ptr to result buffer
 15951 0000165C E80203                  	call	SetupParamError		; set message up for Std_EPrintf
 15952 0000165F F9                      	stc				; return failure
 15953 00001660 EB04                    	jmp	short poRet
 15954                                  poOk:	
 15955 00001662 C60700                  	mov	byte [bx],0		; mark end of sort code list
 15956 00001665 5B                      	pop	bx			; BX = ptr to result buffer
 15957                                  	; 19/02/2023
 15958                                  	;cf=0
 15959                                  	;clc				; return success
 15960                                  poRet:
 15961 00001666 5E                      	pop	si			; restore SI
 15962 00001667 C3                      	retn
 15963                                  
 15964                                  ; ---------------------------------------------------------------------------
 15965                                  
 15966                                  ;***	ParseSwitch - parse a switch
 15967                                  ;
 15968                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15969                                  ;		     a switch
 15970                                  ;
 15971                                  ;	EXIT	CY = set if parse error occurred
 15972                                  ;
 15973                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15974                                  ;		AX = parse error code, like system parser
 15975                                  ;		DX = ptr to message block
 15976                                  ;
 15977                                  ;	USED	AX,BX,DX
 15978                                  ;
 15979                                  ;	EFFECTS
 15980                                  ;
 15981                                  ;	  Bits may contain new option settings.
 15982                                  ;	  DestBuf may contain new series of sort codes.
 15983                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15984                                  ;
 15985                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15986                                  ;	  Msg_Disp_Class = parse error class
 15987                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15988                                  ;	  Message block (see DX) is set up for parse error message
 15989                                  
 15990                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15991                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 15992                                  ParseSwitch:
 15993 00001668 51                      	push	cx			; save CX
 15994 00001669 57                      	push	di			; save DI
 15995                                  
 15996                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 15997                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 15998 0000166A 8B4702                  	mov	ax,[bx+2]
 15999                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16000 0000166D BF[7485]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16001 00001670 B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16002 00001673 FC                      	cld				; scan direction = upward
 16003 00001674 F2AF                    	repne	scasw			; locate synonym ptr in list
 16004                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16005 00001676 81EF[7685]              	sub	di,Dir_Sw_Ptrs+2
 16006                                  
 16007                                  ;	DI = index into word list of synonym ptrs
 16008                                  
 16009 0000167A 2EFF95[8216]            	call	word [cs:di+SwHandler]	; use same index into call table
 16010                                  
 16011 0000167F 5F                      	pop	di			; restore DI
 16012 00001680 59                      	pop	cx			; restore CX
 16013                                  
 16014 00001681 C3                      	retn
 16015                                  
 16016                                  ; ---------------------------------------------------------------------------
 16017                                  
 16018                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16019                                  ;	Simple on/off switches must occur first in both lists, and must be
 16020                                  ;	  in order of option bits in Bits, starting with bit 0.
 16021                                  
 16022                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16023                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16024                                  
 16025                                  SwHandler:
 16026 00001682 [9415]                  	dw	OnOffSw		; /-W
 16027 00001684 [9415]                  	dw	OnOffSw		; /W
 16028 00001686 [9415]                  	dw	OnOffSw		; /-P
 16029 00001688 [9415]                  	dw	OnOffSw		; /P
 16030 0000168A [9415]                  	dw	OnOffSw		; /-S
 16031 0000168C [9415]                  	dw	OnOffSw		; /S
 16032 0000168E [9415]                  	dw	OnOffSw		; /-B
 16033 00001690 [9415]                  	dw	OnOffSw		; /B
 16034 00001692 [9415]                  	dw	OnOffSw		; /-L	;M010
 16035 00001694 [9415]                  	dw	OnOffSw		; /L	;M010
 16036 00001696 [8D15]                  	dw	NoOrder		; /-O
 16037 00001698 [1716]                  	dw	ParseOrder	; /O
 16038 0000169A [6C13]                  	dw	DefaultAttr	; /-A
 16039 0000169C [B115]                  	dw	ParseAttr	; /A
 16040                                  
 16041                                  ; ---------------------------------------------------------------------------
 16042                                  
 16043                                  	;break	<DIR utility routines>
 16044                                  
 16045                                  ;***	UTILITY ROUTINES
 16046                                  ; ---------------------- 
 16047                                  
 16048                                  ; ---------------------------------------------------------------------------
 16049                                  
 16050                                  ;***	ChangeDir - change directory on target drive
 16051                                  ;
 16052                                  ;	ENTRY	FCB contains drive #
 16053                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16054                                  ;
 16055                                  ;	EXIT	Changed current directory on drive
 16056                                  ;
 16057                                  ;		If error,
 16058                                  ;		CY = set
 16059                                  ;		DOS Get Extended Error call will get error
 16060                                  ;
 16061                                  ;	USED	AX,DX,SI,DI
 16062                                  ;
 16063                                  ;	EFFECTS
 16064                                  ;
 16065                                  ;	  DirBuf is used to build "d:string".
 16066                                  
 16067                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16068                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16069                                  
 16070                                  ChangeDir:
 16071                                  	;mov	di,offset TRANGROUP:DirBuf
 16072 0000169E BF[CE8B]                	mov	di,DIRBUF
 16073 000016A1 E8AC02                  	call	GetDriveLtr	; AX = "d:"
 16074 000016A4 AB                      	stosw			; put drive specifier in buffer
 16075 000016A5 89D6                    	mov	si,dx		; SI = ptr to argument string
 16076                                  cdLoop:
 16077 000016A7 AC                      	lodsb
 16078 000016A8 AA                      	stosb			; move byte to buffer
 16079 000016A9 08C0                    	or	al,al
 16080 000016AB 75FA                    	jne	short cdLoop	; continue until null transferred
 16081                                  
 16082                                  	;mov	dx,offset TRANGROUP:DirBuf
 16083 000016AD BA[CE8B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16084                                  	;mov	ah,CHDir
 16085 000016B0 B43B                    	mov	ah,3Bh
 16086 000016B2 CD21                    	int	21h		; change directory
 16087 000016B4 C3                      	retn			; return what CHDIR returns
 16088                                  
 16089                                  ; ---------------------------------------------------------------------------
 16090                                  
 16091                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16092                                  ;
 16093                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16094                                  ;		ES:DI = ptr to another ASCIIZ string
 16095                                  ;
 16096                                  ;	EXIT	flags set after REPE CMPSB
 16097                                  ;
 16098                                  ;	USED	AL,CX,SI,DI
 16099                                  ;
 16100                                  ;	NOTES
 16101                                  ;
 16102                                  ;	Maximum run of comparison is length of DS:SI string.
 16103                                  ;	This ensures that two identical strings followed by
 16104                                  ;	random characters will compare correctly.
 16105                                  
 16106                                  	; 19/02/2023
 16107                                  CmpAscz:
 16108                                  	; 07/06/2023
 16109 000016B5 56                      	push	si ; *
 16110                                  	;
 16111 000016B6 57                      	push	di
 16112                                  
 16113 000016B7 89F7                    	mov	di,si
 16114 000016B9 30C0                    	xor	al,al
 16115 000016BB B9FFFF                  	mov	cx,0FFFFh
 16116 000016BE F2AE                    	repne	scasb
 16117 000016C0 F7D1                    	not	cx
 16118                                  
 16119 000016C2 5F                      	pop	di
 16120 000016C3 F3A6                    	repe	cmpsb
 16121                                  
 16122                                  	; 07/06/2023
 16123 000016C5 5E                      	pop	si ; *
 16124                                  	;
 16125 000016C6 C3                      	retn
 16126                                  
 16127                                  ; ---------------------------------------------------------------------------
 16128                                  
 16129                                  ;***	CopyPathname - copy pathname to our buffer
 16130                                  ;
 16131                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16132                                  ;		     a filespec
 16133                                  ;
 16134                                  ;	EXIT	nothing
 16135                                  ;
 16136                                  ;	USED	AX
 16137                                  ;
 16138                                  ;	EFFECTS
 16139                                  ;
 16140                                  ;	  SrcBuf may contain a new pathname/filespec.
 16141                                  ;	  PathPos, PathCnt updated for new pathname.
 16142                                  
 16143                                  	; 19/02/2023
 16144                                  CopyPathname:
 16145 000016C7 56                      	push	si
 16146                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16147                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16148 000016C8 C57704                  	lds	si,[bx+4]
 16149                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16150 000016CB E8D715                  	call	Move_To_SrcBuf
 16151 000016CE 5E                      	pop	si
 16152 000016CF C3                      	retn
 16153                                  
 16154                                  ; ---------------------------------------------------------------------------
 16155                                  
 16156                                  ;***	CountFile - update counters with current file
 16157                                  ;
 16158                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16159                                  ;
 16160                                  ;	EXIT	nothing
 16161                                  ;
 16162                                  ;	USED	AX,DX
 16163                                  ;
 16164                                  ;	EFFECTS
 16165                                  ;
 16166                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16167                                  
 16168                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16169                                  CountFile:
 16170 000016D0 06                      	push	es			; save TRANGROUP seg addr
 16171 000016D1 8E06[C78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16172                                  
 16173 000016D5 FF06[F18A]              	inc	word [FileCnt]		; # files this directory
 16174 000016D9 FF06[F78A]              	inc	word [FileCntTotal]	; # files total
 16175 000016DD 7504                    	jnz	short cntf1
 16176 000016DF FF06[F98A]              	inc	word [FileCntTotal+2]
 16177                                  cntf1:
 16178                                  	;mov	ax,word ptr es:[bx].filesize
 16179                                  					; AX = low word of file size
 16180                                  	;mov	dx,word ptr es:[bx].filesize+2
 16181                                  					; DX = high word of file size
 16182 000016E3 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16183 000016E7 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16184 000016EB 0106[F38A]              	add	[FileSiz],ax
 16185 000016EF 1116[F58A]              	adc	[FileSiz+2],dx		; size of this directory
 16186 000016F3 0106[FB8A]              	add	[FileSizTotal],ax
 16187 000016F7 1116[FD8A]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16188                                  
 16189 000016FB 07                      	pop	es			; ES = TRANGROUP seg addr again
 16190                                  dbRet:	; 19/02/2023
 16191 000016FC C3                      	retn
 16192                                  
 16193                                  ; ---------------------------------------------------------------------------
 16194                                  
 16195                                  ;***	DisplayBare - display filename in bare format
 16196                                  ;
 16197                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16198                                  ;
 16199                                  ;	EXIT	DX = # char's displayed, including dot
 16200                                  ;
 16201                                  ;	USED	AX,CX,SI,DI
 16202                                  ;
 16203                                  ;	EFFECTS
 16204                                  ;
 16205                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16206                                  ;	  If /s is on, complete pathname is displayed.
 16207                                  ;
 16208                                  ;	NOTE
 16209                                  ;
 16210                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16211                                  
 16212                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16213                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16214                                  
 16215                                  DisplayBare:
 16216                                  ;	Suppress . and .. files from bare listing.
 16217                                  
 16218 000016FD 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16219 000016FF 8E1E[C78A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16220                                  	;assume	ds:NOTHING
 16221                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16222 00001703 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16223 00001707 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16224                                  	;assume	ds:TRANGROUP
 16225 00001709 74F1                    	je	short dbRet		; it's . or .. - don't display
 16226                                  
 16227                                  	;;;test	Bits,mask subd
 16228                                  	;;test	word [_Bits],4
 16229                                  	;test	byte [_Bits],4
 16230 0000170B F606[208C]04            	test	byte [_Bits],mask.subd
 16231 00001710 7431                    	jz	short dbNameExt		; not /s - display filename only
 16232                                  
 16233                                  	;invoke	Build_Dir_String
 16234 00001712 E83707                  	call	build_dir_string
 16235                                  	;mov	di,offset TRANGROUP:BwdBuf
 16236 00001715 BF[CE8B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16237                                     
 16238                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16239                                  	;;test	word [_Bits],10h
 16240                                  	;test	byte [_Bits],10h
 16241 00001718 F606[208C]10            	test	byte [_Bits],mask.lcase
 16242                                  	;jz	@F			;M010;lowercase not needed
 16243 0000171D 7405                    	jz	short dbare1
 16244 0000171F 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16245 00001721 E87E02                  	call	LowercaseString		;M010;path string is in BwdBuf
 16246                                  dbare1:
 16247                                  ;@@:	
 16248                                  	;xor	al,al			; AL = 0
 16249                                  	; 19/02/2023
 16250 00001724 31C0                    	xor	ax,ax
 16251 00001726 B9FFFF                  	mov	cx,0FFFFh
 16252 00001729 FC                      	cld
 16253 0000172A F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16254 0000172C 4F                      	dec	di			; ES:DI = ptr to null byte
 16255                                  
 16256 0000172D 26807DFF5C              	cmp	byte [es:di-1],'\'
 16257                                  	;je	@F
 16258 00001732 7403                    	je	short dbare2		; already terminated w/ '\'
 16259                                  
 16260                                  	;mov	ax,'\'			; AX = '\',0
 16261 00001734 B05C                    	mov	al,'\'
 16262 00001736 AB                      	stosw				; add to dir string
 16263                                  ;@@:
 16264                                  dbare2:
 16265                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16266 00001737 C706[358C][CE8B]        	mov	word [string_ptr_2],BWDBUF
 16267                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16268 0000173D BA[E280]                	mov	dx,string_buf_ptr
 16269                                  	;invoke	Std_Printf		; display device & directory path
 16270 00001740 E8AC36                  	call	std_printf
 16271                                  dbNameExt:
 16272 00001743 E82D00                  	call	DisplayDotForm		; display name.ext
 16273                                  	;invoke	CrLf2			; display cr/lf
 16274 00001746 E8880E                  	call	CRLF2
 16275                                  	; 19/02/2023
 16276                                  	;call	UseLine			;M007;Allow /p with /b
 16277                                  ;dbRet:
 16278                                  	;retn
 16279                                  
 16280                                  	; 19/02/2023
 16281                                  	;jmp	short UseLine
 16282                                  
 16283                                  ; ---------------------------------------------------------------------------
 16284                                  
 16285                                  ;***	UseLine - use a display line, start a new page if none left
 16286                                  ;
 16287                                  ;	ENTRY	nothing
 16288                                  ;
 16289                                  ;	EXIT	nothing
 16290                                  ;
 16291                                  ;	USED	flags
 16292                                  
 16293                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16294                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16295                                  UseLine:
 16296 00001749 FF0E[EF8A]              	dec	word [LeftOnPage]
 16297 0000174D 833E[EF8A]02            	cmp	word [LeftOnPage],2
 16298 00001752 771E                    	ja	short ulRet
 16299                                  	; 19/02/2023
 16300                                  	;call	EndPage
 16301                                  ;ulRet:
 16302                                  	;retn
 16303                                  
 16304                                  	; 19/02/2023
 16305                                  	;jmp	short EndPage
 16306                                  
 16307                                  ; ---------------------------------------------------------------------------
 16308                                  
 16309                                  ;***	EndPage - end the current display page
 16310                                  ;
 16311                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16312                                  ;		Current directory (on selected drive) is the one being listed
 16313                                  ;		Bits contains /p setting
 16314                                  ;
 16315                                  ;	EXIT	LeftOnPage = # lines left for next page
 16316                                  ;
 16317                                  ;	USED	AX,DX
 16318                                  ;
 16319                                  ;	EFFECTS
 16320                                  ;
 16321                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16322                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16323                                  
 16324                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16325                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16326                                  
 16327                                  EndPage:
 16328                                  	;;;test	Bits,mask pagd
 16329                                  	;;test	word [_Bits],2
 16330                                  	;test	byte [_Bits],2
 16331 00001754 F606[208C]02            	test	byte [_Bits],mask.pagd
 16332 00001759 7410                    	jz	short epNew		; paged display isn't enabled
 16333                                  
 16334 0000175B 53                      	push	bx			; save BX
 16335 0000175C 51                      	push	cx			; save CX
 16336                                  
 16337                                  	;invoke	Pause			; "Press any key to continue..."
 16338 0000175D E85302                  	call	PAUSE
 16339                                  
 16340                                  	;invoke	Build_Dir_String
 16341 00001760 E8E906                  	call	build_dir_string
 16342                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16343 00001763 BA[5D81]                	mov	dx,dircont_ptr
 16344                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16345 00001766 E87836                  	call	Printf_Crlf
 16346                                  
 16347 00001769 59                      	pop	cx			; restore CX
 16348 0000176A 5B                      	pop	bx			; restore BX
 16349                                  epNew:	
 16350 0000176B A1[9B8D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16351 0000176E 48                      	dec	ax			; AX = # lines till next EndPage
 16352 0000176F A3[EF8A]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16353                                  ulRet:	
 16354                                  	; 19/02/2023
 16355 00001772 C3                      	retn
 16356                                  
 16357                                  ; ---------------------------------------------------------------------------
 16358                                  
 16359                                  ;***	DisplayDotForm - display filename in compressed dot format
 16360                                  ;
 16361                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16362                                  ;	if the filename has a nonblank extension.
 16363                                  ;
 16364                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16365                                  ;
 16366                                  ;	EXIT	DX = # char's displayed, including dot
 16367                                  ;
 16368                                  ;	USED	AX,CX,SI,DI
 16369                                  ;
 16370                                  ;	EFFECTS
 16371                                  ;
 16372                                  ;	  Filename is displayed in name.ext format.
 16373                                  ;
 16374                                  ;	NOTE
 16375                                  ;
 16376                                  ;	  We allow for bogus filenames that have blanks embedded
 16377                                  ;	  in the name or extension.
 16378                                  
 16379                                  ;	Bugbug:	might be a good performance gain if we buffered
 16380                                  ;	up the output and used DOS function 9.
 16381                                  
 16382                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16383                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16384                                  
 16385                                  DisplayDotForm:
 16386 00001773 1E                      	push	ds			; save TRANGROUP seg addr
 16387 00001774 06                      	push	es			; save ES
 16388 00001775 2EA1[C78A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16389 00001779 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16390                                  	;assume	ds:nothing
 16391 0000177B 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16392                                  
 16393                                  	; 08/06/2023
 16394                                  	;mov	di,bx			; ES:DI = ptr to entry
 16395                                  	;;;add	di,filename + size filename - 1
 16396                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16397                                  	;;mov	cx,size filename	; CX = length of name field
 16398                                  	;mov	cx,8
 16399                                  	; 08/06/2023
 16400 0000177D B90800                  	mov	cx,8
 16401 00001780 89CF                    	mov	di,cx
 16402 00001782 01DF                    	add	di,bx
 16403                                  	
 16404 00001784 B020                    	mov	al,' '
 16405 00001786 FD                      	std				; scan down
 16406 00001787 F3AE                    	repe	scasb			; scan for nonblank
 16407                                  
 16408                                  ;	Assume file name has at least one character.
 16409                                  
 16410 00001789 41                      	inc	cx			; CX = # chars in name
 16411 0000178A 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16412                                  
 16413 0000178C 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16414                                  	;;add	si,filename		; DS:SI = ptr to name
 16415                                  	;add	si,1 
 16416                                  	;		; add si,EntryStruc.filename
 16417                                  	; 25/04/2023
 16418 0000178E 46                      	inc	si
 16419                                  NextNameChar:
 16420 0000178F FC                      	cld
 16421 00001790 AC                      	lodsb				; AL = next char
 16422                                  
 16423                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16424                                  	;;test	word [ss:_Bits],10h
 16425                                  	;test	byte [ss:_Bits],10h
 16426 00001791 36F606[208C]10          	test	byte [ss:_Bits],mask.lcase
 16427                                  	;jz	short @F		;M010;lowercase not required
 16428 00001797 7403                    	jz	short ddf1
 16429 00001799 E8FB01                  	call	LowerCase		;M010;filename char is in AL
 16430                                  ddf1:
 16431                                  ;@@:	
 16432                                  	;invoke	Print_Char		; display it
 16433 0000179C E85E06                  	call	PRINT_CHAR
 16434 0000179F E2EE                    	loop	NextNameChar
 16435                                  
 16436                                  ;	Now do extension.
 16437                                  
 16438 000017A1 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16439                                  	;add	di,fileext + size fileext - 1
 16440 000017A3 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16441                                  	;mov	cx,size fileext		; CX = length of ext field
 16442 000017A6 B90300                  	mov	cx,3
 16443 000017A9 B020                    	mov	al,' '
 16444 000017AB FD                      	std				; scan down
 16445 000017AC F3AE                    	repe	scasb			; scan for nonblank
 16446 000017AE 7420                    	je	short ddDone		; no nonblank chars in ext
 16447                                  
 16448 000017B0 41                      	inc	cx			; CX = # chars in ext
 16449 000017B1 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16450 000017B3 42                      	inc	dx			;      including dot
 16451                                  
 16452 000017B4 B02E                    	mov	al,'.'
 16453 000017B6 E84406                  	call	PRINT_CHAR
 16454 000017B9 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16455                                  	;add	si,fileext		; DS:SI = ptr to ext
 16456 000017BB 83C609                  	add	si,9
 16457                                  
 16458                                  NextExtChar:
 16459 000017BE FC                      	cld
 16460 000017BF AC                      	lodsb				; AL = next char
 16461                                  
 16462                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16463                                  	;;test	word [cs:_Bits],10h
 16464                                  	;test	byte [cs:_Bits],10h
 16465 000017C0 2EF606[208C]10          	test	byte [cs:_Bits],mask.lcase
 16466                                  	;jz	short @F		;M010;lowercase not required
 16467 000017C6 7403                    	jz	short ddf2
 16468 000017C8 E8CC01                  	call	LowerCase		;M010;fileext char is in AL
 16469                                  ;@@:	
 16470                                  ddf2:
 16471                                  	;invoke	Print_Char		; display it
 16472 000017CB E82F06                  	call	PRINT_CHAR
 16473 000017CE E2EE                    	loop	NextExtChar
 16474                                  ddDone:
 16475 000017D0 07                      	pop	es			; restore ES
 16476 000017D1 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16477                                  	;assume	ds:TRANGROUP
 16478 000017D2 FC                      	cld				; leave direction flag = up
 16479 000017D3 C3                      	retn
 16480                                  
 16481                                  ; ---------------------------------------------------------------------------
 16482                                  
 16483                                  ;***	DisplayFile - display file entry, update counters
 16484                                  ;
 16485                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16486                                  ;		Bits contains /w, /p settings
 16487                                  ;
 16488                                  ;	EXIT	nothing
 16489                                  ;
 16490                                  ;	USED	AX,CX,DX,SI,DI,BP
 16491                                  ;
 16492                                  ;	EFFECTS
 16493                                  ;
 16494                                  ;	  Entry is displayed.
 16495                                  ;	  If not /b,
 16496                                  ;	    Cursor is left at end of entry on screen.
 16497                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16498                                  ;	  If /b,
 16499                                  ;	    Cursor is left at beginning of next line.
 16500                                  ;	    Cnt's and Siz's aren't updated.
 16501                                  
 16502                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16503                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16504                                  
 16505                                  DisplayFile:
 16506                                  	;;;test	Bits,mask bare
 16507                                  	;;test	word [_Bits],8
 16508                                  	;test	byte [_Bits],8
 16509 000017D4 F606[208C]08            	test	byte [_Bits],mask.bare
 16510 000017D9 7405                    	jz	short dfNorm		; not /b - do normal display
 16511                                  
 16512 000017DB E81FFF                  	call	DisplayBare		; display file in bare format
 16513 000017DE EB18                    	jmp	short dfRet
 16514                                  dfNorm:	
 16515 000017E0 E87800                  	call	DisplayNext		; pos'n cursor for next entry
 16516                                  	;;;test	Bits,mask wide
 16517                                  	;;test	word [_Bits],1
 16518                                  	;test	byte [_Bits],1
 16519 000017E3 F606[208C]01            	test	byte [_Bits],mask.wide
 16520 000017E8 7405                    	jz	short dfFull		; full format
 16521 000017EA E83701                  	call	DisplayWide		; wide format
 16522 000017ED EB06                    	jmp	short dfCnt
 16523                                  dfFull:	
 16524 000017EF E83400                  	call	DisplayName		; display filename & extension
 16525 000017F2 E88D00                  	call	DisplayTheRest		; display size, date, time
 16526                                  dfCnt:
 16527 000017F5 E8D8FE                  	call	CountFile		; update file counters
 16528                                  dfRet:
 16529                                  dhRet:	; 19/02/2023
 16530 000017F8 C3                      	retn
 16531                                  
 16532                                  ; ---------------------------------------------------------------------------
 16533                                  
 16534                                  ;***	DisplayHeader - display directory header of working directory
 16535                                  ;
 16536                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16537                                  ;		LeftOnPage = # lines left on display page
 16538                                  ;
 16539                                  ;	EXIT	nothing
 16540                                  ;
 16541                                  ;	ERROR EXIT
 16542                                  ;
 16543                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16544                                  ;	   specification" if there's a problem obtaining the current
 16545                                  ;	   directory pathname.
 16546                                  ;
 16547                                  ;	USED	AX,DX,SI,DI
 16548                                  ;
 16549                                  ;	EFFECTS
 16550                                  ;
 16551                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16552                                  ;	   we are using for the DTA) contains the directory string.
 16553                                  ;	  LeftOnPage is adjusted.
 16554                                  
 16555                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16556                                  
 16557                                  DisplayHeader:
 16558                                  	;;;test	Bits,mask bare
 16559                                  	;;test	word [_Bits],8
 16560                                  	;test	byte [_Bits],8
 16561 000017F9 F606[208C]08            	test	byte [_Bits],mask.bare
 16562 000017FE 75F8                    	jnz	short dhRet		; /b - don't display header
 16563                                  
 16564                                  	;;;test	Bits,mask subd
 16565                                  	;;test	word [_Bits],4
 16566                                  	;test	byte [_Bits],4
 16567 00001800 F606[208C]04            	test	byte [_Bits],mask.subd
 16568 00001805 7408                    	jz	short dhNorm		; not /s
 16569                                  
 16570                                  ;	For subdirectory listings, put a blank line before the header.
 16571                                  
 16572                                  	;invoke	Crlf2			; start with a blank line
 16573 00001807 E8C70D                  	call	CRLF2
 16574 0000180A E83CFF                  	call	UseLine
 16575 0000180D EB05                    	jmp	short dhCom
 16576                                  dhNorm:
 16577 0000180F B020                    	mov	al,' ' ; 20h
 16578                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16579 00001811 E8E905                  	call	PRINT_CHAR		; print a leading blank
 16580                                  dhCom:
 16581 00001814 E83506                  	call	build_dir_string
 16582 00001817 BA[6280]                	mov	dx,dirhead_ptr
 16583 0000181A E8D235                  	call	std_printf		; print header & cr/lf
 16584 0000181D E829FF                  	call	UseLine
 16585 00001820 E8AE0D                  	call	CRLF2			; another cr/lf
 16586                                  	;call	UseLine
 16587                                  ;dhRet:
 16588                                  	;retn
 16589                                  
 16590                                  	; 19/02/2023
 16591 00001823 E923FF                  	jmp	UseLine
 16592                                  
 16593                                  ; ---------------------------------------------------------------------------
 16594                                  
 16595                                  ;***	DisplayName - display file name & extension
 16596                                  ;
 16597                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16598                                  ;
 16599                                  ;	EXIT	nothing
 16600                                  ;
 16601                                  ;	USED	AX,CX,DX,SI,DI
 16602                                  ;
 16603                                  ;	EFFECTS
 16604                                  ;
 16605                                  ;	  Filename & extension are displayed in spread format.
 16606                                  ;	  Cursor is left at end of extension.
 16607                                  
 16608                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16609                                  	; 08/06/2023
 16610                                  DisplayName:
 16611 00001826 1E                      	push	ds			; save TRANGROUP seg addr
 16612 00001827 8E1E[C78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16613                                  	;assume	ds:nothing
 16614 0000182B 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16615                                  	;add	si,filename		; DS:SI = ptr to filename
 16616                                  	;add	si,1  ; EntryStruc.filename
 16617                                  	; 08/06/2023
 16618 0000182D 46                      	inc	si
 16619 0000182E BF[FF8A]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16620                                  
 16621 00001831 B90800                  	mov	cx,8
 16622 00001834 FC                      	cld
 16623 00001835 F3A4                    	rep	movsb			; move filename to CharBuf
 16624 00001837 B020                    	mov	al,' '
 16625 00001839 AA                      	stosb				; add a blank
 16626                                  	;mov	cx,3
 16627                                  	; 08/06/2023
 16628 0000183A B103                    	mov	cl,3
 16629 0000183C F3A4                    	rep	movsb			; add extension
 16630 0000183E 30C0                    	xor	al,al
 16631 00001840 AA                      	stosb				; add a NULL
 16632                                  
 16633 00001841 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16634                                  	;assume	ds:TRANGROUP
 16635                                  
 16636                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16637                                  	;;test	word [_Bits],10h
 16638                                  	;test	byte [_Bits],10h
 16639 00001842 F606[208C]10            	test	byte [_Bits],mask.lcase
 16640 00001847 7406                    	jz	short dn1		;M010;lowercase not required
 16641 00001849 BE[FF8A]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16642 0000184C E85301                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16643                                  dn1:	
 16644 0000184F C706[358C][FF8A]        	mov	word [string_ptr_2],CHARBUF
 16645 00001855 BA[E280]                	mov	dx,string_buf_ptr
 16646                                  	;call	std_printf		; print filename & extension
 16647                                  	;retn
 16648                                  	; 19/02/2023
 16649 00001858 E99435                  	jmp	std_printf
 16650                                  
 16651                                  ; ---------------------------------------------------------------------------
 16652                                  
 16653                                  ;***	DisplayNext - move display cursor to next entry position
 16654                                  ;
 16655                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16656                                  ;		LeftOnPage = # lines can still be printed for this page
 16657                                  ;		FileCnt = # files in this dir displayed before this one
 16658                                  ;		Bits contains /w setting
 16659                                  ;
 16660                                  ;	EXIT	nothing
 16661                                  ;
 16662                                  ;	USED	AX,DX
 16663                                  ;
 16664                                  ;	EFFECTS
 16665                                  ;
 16666                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16667                                  ;	   displayed.
 16668                                  ;	  LeftOnPage may be updated.
 16669                                  
 16670                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16671                                  
 16672                                  DisplayNext:
 16673 0000185B 833E[F18A]00            	cmp	word [FileCnt],0
 16674 00001860 7415                    	je	short dn1st		; 1st file in directory
 16675 00001862 803E[EB8A]00            	cmp	byte [LeftOnLine],0
 16676 00001867 7E08                    	jng	short dnEol		; no more room on this line
 16677                                  
 16678                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16679                                  ;	we still have room for more on this line.
 16680                                  ;	Tab to next position.
 16681                                  
 16682 00001869 BA[F180]                	mov	dx,tab_ptr
 16683 0000186C E88035                  	call	std_printf
 16684 0000186F EB0C                    	jmp	short dnDone
 16685                                  dnEol:	
 16686                                  ;	Start this entry on a new line.
 16687                                  
 16688 00001871 E85D0D                  	call	CRLF2		; start on new line
 16689 00001874 E8D2FE                  	call	UseLine
 16690                                  dn1st:
 16691 00001877 A0[EC8A]                	mov	al,[PerLine]
 16692 0000187A A2[EB8A]                	mov	[LeftOnLine],al	; reset # entries left on line
 16693                                  
 16694                                  dnDone:
 16695 0000187D FE0E[EB8A]              	dec	byte [LeftOnLine]
 16696                                  				; reflect the entry about to be displayed
 16697 00001881 C3                      	retn
 16698                                  
 16699                                  ; ---------------------------------------------------------------------------
 16700                                  
 16701                                  ;***	DisplayTheRest - display file size/dir, date, time
 16702                                  ;
 16703                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16704                                  ;		Display cursor is at end of file extension
 16705                                  ;
 16706                                  ;	EXIT	nothing
 16707                                  ;
 16708                                  ;	USED	AX,CX,DX,SI,DI,BP
 16709                                  ;
 16710                                  ;	EFFECTS
 16711                                  ;
 16712                                  ;	  File size, date, & time are displayed.
 16713                                  
 16714                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16715                                  DisplayTheRest:
 16716 00001882 06                      	push	es			; save TRANGROUP seg addr
 16717 00001883 8E06[C78A]              	mov	es,[TPA]		; ES = TPA seg addr
 16718 00001887 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16719                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16720                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16721 00001889 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16722 0000188E 7408                    	jz	short drNonDir		; not a directory file
 16723                                  
 16724                                  ;	For a directory file, display <DIR> instead of size.
 16725                                  
 16726 00001890 BA[F480]                	mov	dx,dmes_ptr
 16727 00001893 E85935                  	call	std_printf
 16728 00001896 EB16                    	jmp	short drCom		; skip to common fields
 16729                                  
 16730                                  drNonDir:
 16731                                  ;	For a non-directory file, display file size.
 16732                                  
 16733                                  	;;mov	dx,word ptr es:[bp].filesize
 16734                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16735 00001898 268B5611                	mov	dx,[es:bp+17]
 16736 0000189C 8916[318C]              	mov	[File_Size_Low],dx
 16737                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16738                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16739 000018A0 268B5613                	mov	dx,[es:bp+19]
 16740 000018A4 8916[338C]              	mov	[File_Size_High],dx
 16741 000018A8 BA[D480]                	mov	dx,disp_file_size_ptr
 16742 000018AB E84135                  	call	std_printf
 16743                                  drCom:
 16744                                  ;	For all files, display date & time.
 16745                                  
 16746                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16747                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16748 000018AE 268B460F                	mov	ax,[es:bp+15]
 16749 000018B2 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16750 000018B4 7448                    	jz	short drDone		; no date, skip date/time display
 16751 000018B6 89C3                    	mov	bx,ax			; BX = date word
 16752 000018B8 83E01F                  	and	ax,1Fh			; AX = day of month
 16753 000018BB 88C2                    	mov	dl,al			; DL = day of month
 16754 000018BD 89D8                    	mov	ax,bx			; AX = date word
 16755 000018BF B105                    	mov	cl,5
 16756 000018C1 D3E8                    	shr	ax,cl			; shift day out
 16757 000018C3 240F                    	and	al,0Fh			; AL = month
 16758 000018C5 88C6                    	mov	dh,al			; DH = month
 16759 000018C7 88F9                    	mov	cl,bh
 16760 000018C9 D0E9                    	shr	cl,1			; CL = year - 1980
 16761 000018CB 30ED                    	xor	ch,ch			; CX = year - 1980
 16762 000018CD 83C150                  	add	cx,80			; CX = 2-digit year
 16763 000018D0 80F964                  	cmp	cl,100
 16764 000018D3 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16765 000018D5 80E964                  	sub	cl,100			; adjust for 21st century
 16766                                  dr_1:	
 16767 000018D8 86F2                    	xchg	dh,dl			; DX = month/day
 16768 000018DA 890E[3281]              	mov	[DirDat_Yr],cx		; move year to msg block
 16769 000018DE 8916[3481]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16770                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16771                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16772 000018E2 268B4E0D                	mov	cx,[es:bp+13]
 16773 000018E6 E310                    	jcxz	drPrint			; no time field - go print
 16774 000018E8 D1E9                    	shr	cx,1
 16775 000018EA D1E9                    	shr	cx,1
 16776 000018EC D1E9                    	shr	cx,1			; CH = hours
 16777 000018EE D0E9                    	shr	cl,1
 16778 000018F0 D0E9                    	shr	cl,1			; CL = minutes
 16779 000018F2 86E9                    	xchg	ch,cl			; CX = hr/min
 16780 000018F4 890E[3D81]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16781                                  drPrint:
 16782 000018F8 BA[2D81]                	mov	dx,dirdattim_ptr
 16783 000018FB E8F134                  	call	std_printf		; print date & time
 16784                                  drDone:
 16785 000018FE 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16786 000018FF 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16787                                  dtrRet:
 16788                                  	; 19/02/2023
 16789 00001901 C3                      	retn
 16790                                  
 16791                                  ; ---------------------------------------------------------------------------
 16792                                  
 16793                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16794                                  ;
 16795                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16796                                  ;		FileCnt = # files listed
 16797                                  ;		FileSiz = total size of files listed
 16798                                  ;
 16799                                  ;	EXIT	nothing
 16800                                  ;
 16801                                  ;	USED
 16802                                  ;
 16803                                  ;	EFFECTS
 16804                                  ;
 16805                                  ;	  Trailing info lines are displayed
 16806                                  
 16807                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16808                                  
 16809                                  DisplayTrailer:
 16810                                  	;;;test	Bits,mask bare
 16811                                  	;;test	word [_Bits],8
 16812                                  	;test	byte [_Bits],8
 16813 00001902 F606[208C]08            	test	byte [_Bits],mask.bare
 16814 00001907 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16815                                  
 16816 00001909 E8C50C                  	call	CRLF2			; start on new line
 16817 0000190C E83AFE                  	call	UseLine
 16818 0000190F A1[F18A]                	mov	ax,[FileCnt]		; AX = # files found
 16819                                  
 16820                                  ;	DisplayTotals uses this entry point.
 16821                                  ;
 16822                                  DisplayCntSiz:
 16823                                  ;	AX = # files
 16824                                  ;	FileSiz = dword total size of files
 16825                                  
 16826 00001912 A3[3A8C]                	mov	[Dir_Num],ax		; load # files
 16827 00001915 BA[5B7F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16828 00001918 E8D434                  	call	std_printf		; "nnn File(s)"
 16829                                  
 16830 0000191B BA[4981]                	mov	dx,bytes_ptr
 16831 0000191E E8CE34                  	call	std_printf		; "nnn bytes",cr,lf
 16832                                  	; 19/02/2023
 16833                                  	;call	UseLine
 16834                                  ;dtrRet:
 16835                                  	;retn
 16836                                  
 16837                                  	; 19/02/2023
 16838 00001921 E925FE                  	jmp	UseLine
 16839                                  
 16840                                  ; ---------------------------------------------------------------------------
 16841                                  
 16842                                  ;***	DisplayWide - display filename in wide format
 16843                                  ;
 16844                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16845                                  ;
 16846                                  ;	EXIT	nothing
 16847                                  ;
 16848                                  ;	USED	AX,CX,DX,SI,DI
 16849                                  ;
 16850                                  ;	EFFECTS
 16851                                  ;
 16852                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16853                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16854                                  
 16855                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16856                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16857                                  
 16858                                  DisplayWide:
 16859 00001924 1E                      	push	ds			; save TRANGROUP seg addr
 16860 00001925 8E1E[C78A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16861                                  	;assume	ds:nothing
 16862                                  
 16863                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16864                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16865 00001929 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16866 0000192D 9C                      	pushf	; 03/08/2024
 16867 0000192E 7405                    	jz	short dw1		; not a subdirectory file
 16868 00001930 B05B                    	mov	al,'['
 16869 00001932 E8C804                  	call	PRINT_CHAR		; prefix subdirectory
 16870                                  dw1:	
 16871 00001935 E83BFE                  	call	DisplayDotForm		; display name.ext
 16872                                  
 16873                                  ;	DX = # chars displayed in name.ext
 16874                                  
 16875                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16876                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16877                                  	; 03/08/2024
 16878                                  	;test	byte [bx+12],ATTR_DIRECTORY
 16879 00001938 9D                      	popf	; 03/08/2024
 16880 00001939 7405                    	jz	short dw2		; not a subdirectory file
 16881 0000193B B05D                    	mov	al,']'
 16882 0000193D E8BD04                  	call	PRINT_CHAR		; postfix subdirectory
 16883                                  dw2:
 16884                                  ;	Pad field with blanks.
 16885                                  
 16886                                  	;mov	cx,size filename + size fileext + 1
 16887 00001940 B90C00                  	mov	cx,12 ; 8+3+1
 16888                                  					; CX = field size
 16889 00001943 29D1                    	sub	cx,dx			; CX = # pad char's
 16890 00001945 E307                    	jcxz	dwDone
 16891 00001947 B020                    	mov	al,' '
 16892                                  dw3:	
 16893 00001949 E8B104                  	call	PRINT_CHAR
 16894 0000194C E2FB                    	loop	dw3
 16895                                  dwDone:	
 16896 0000194E 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16897                                  	;assume	ds:TRANGROUP
 16898 0000194F C3                      	retn
 16899                                  
 16900                                  ; ---------------------------------------------------------------------------
 16901                                  
 16902                                  ;***	GetDriveLtr - get target drive letter
 16903                                  ;
 16904                                  ;	ENTRY	FCB contains drive #
 16905                                  ;
 16906                                  ;	EXIT	AX = "d:"
 16907                                  ;
 16908                                  ;	USED	nothing
 16909                                  
 16910                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16911                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16912                                  GetDriveLtr:
 16913 00001950 A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16914 00001953 08C0                    	or	al,al
 16915 00001955 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16916 00001957 A0[D98A]                	mov	al,[CURDRV]	; AL = current drive #
 16917 0000195A FEC0                    	inc	al		; AL = 1-based drive #
 16918                                  gdl1:	
 16919 0000195C 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16920 0000195E B43A                    	mov	ah,':'		; AX = "d:"
 16921 00001960 C3                      	retn
 16922                                  
 16923                                  ; ---------------------------------------------------------------------------
 16924                                  
 16925                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16926                                  ;
 16927                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16928                                  ;	for system parser calls. Set up a message substitution block,
 16929                                  ;	etc. for invalid value strings. I copied the procedure from
 16930                                  ;	Setup_Parse_Error_Msg.
 16931                                  ;
 16932                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16933                                  ;		
 16934                                  ;
 16935                                  ;	EXIT	AX = system parser error return code for bad param format
 16936                                  ;		DX = ptr to message description block for Std_EPrintf
 16937                                  ;
 16938                                  ;	USED	SI
 16939                                  ;
 16940                                  ;	EFFECTS
 16941                                  ;
 16942                                  ;	  Msg_Disp_Class = parse error message class
 16943                                  ;	  Message block (see DX) is set up for parse error message
 16944                                  
 16945                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16946                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16947                                  SetupParamError:
 16948 00001961 B80900                  	mov	ax,9			; parse error #
 16949 00001964 C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class
 16950                                  	;mov	byte [msg_disp_class],2
 16951 00001969 A3[1B7F]                	mov	[extend_buf_ptr],ax
 16952                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16953 0000196C 8B7704                  	mov	si,[bx+4]
 16954 0000196F 8936[358C]              	mov	[string_ptr_2],si
 16955 00001973 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 16956                                  	;mov	byte [extend_buf_sub],1
 16957 00001978 BA[1B7F]                	mov	dx,extend_buf_ptr
 16958 0000197B C3                      	retn
 16959                                  
 16960                                  ; ---------------------------------------------------------------------------
 16961                                  
 16962                                  ;***	ZeroTotals - zero grand total file count, size
 16963                                  ;
 16964                                  ;	ENTRY	nothing
 16965                                  ;
 16966                                  ;	EXIT	nothing
 16967                                  ;
 16968                                  ;	USED	AX
 16969                                  ;
 16970                                  ;	EFFECTS
 16971                                  ;
 16972                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 16973                                  ;
 16974                                  ;	NOTES
 16975                                  ;
 16976                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 16977                                  	
 16978                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16979                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 16980                                  ZeroTotals:
 16981 0000197C BF[F78A]                	mov	di,FileCntTotal
 16982                                  
 16983                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 16984 0000197F B90800                  	mov	cx,8
 16985                                  
 16986 00001982 30C0                    	xor	al,al
 16987 00001984 F3AA                    	rep	stosb
 16988 00001986 C3                      	retn	
 16989                                  
 16990                                  ; ---------------------------------------------------------------------------
 16991                                  
 16992                                  ;***	CtrlCHandler - our own control-c handler
 16993                                  ;
 16994                                  ;	Make sure user's default directory gets restored. See notes
 16995                                  ;	at InstallCtrlCHandler.
 16996                                  ;
 16997                                  ;	ENTRY	control-c
 16998                                  ;
 16999                                  ;	EXIT	to OldCtrlCHandler
 17000                                  ;
 17001                                  ;	USED	DS,flags
 17002                                  ;
 17003                                  ;	EFFECTS
 17004                                  ;
 17005                                  ;	  Restore user's default directory.
 17006                                  ;
 17007                                  ;	NOTES
 17008                                  ;
 17009                                  ;	  This handler is only installed after calling PathCrunch,
 17010                                  ;	  which sets UserDir1, so the restoration will work.
 17011                                  ;
 17012                                  ;	  The original control-c vector will be restored, whether
 17013                                  ;	  or not this one is invoked, in the HeadFix routine.
 17014                                  
 17015                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17016                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17017                                  
 17018                                  CtrlCHandler:	;proc	far
 17019                                  
 17020                                  ;SR;
 17021                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17022                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17023                                  ;
 17024 00001987 1E                      	push	ds
 17025 00001988 0E                      	push	cs
 17026 00001989 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17027 0000198A 50                      	push	ax
 17028 0000198B 52                      	push	dx
 17029 0000198C E8FF0A                  	call	RestUDir		; restore user's default directory
 17030 0000198F 5A                      	pop	dx
 17031 00001990 58                      	pop	ax
 17032 00001991 1F                      	pop	ds
 17033 00001992 2EFF2E[4895]            	jmp	far [cs:OldCtrlCHandler]
 17034                                  					; go to previous int 23 handler
 17035                                  
 17036                                  ; ---------------------------------------------------------------------------
 17037                                  
 17038                                  ;M010;start
 17039                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17040                                  ;
 17041                                  ;	ENTRY	AL = character to be displayed
 17042                                  ;
 17043                                  ;	EXIT	AL is lowercase
 17044                                  ;
 17045                                  ;	USED	nothing
 17046                                  
 17047                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17048                                  LowerCase:
 17049 00001997 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 17050 00001999 7206                    	jb	short lcRet
 17051 0000199B 3C5A                    	cmp	al,'Z'
 17052 0000199D 7702                    	ja	short lcRet
 17053                                  
 17054 0000199F 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17055                                  lcRet:
 17056 000019A1 C3                      	retn
 17057                                  
 17058                                  ; ---------------------------------------------------------------------------
 17059                                  
 17060                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17061                                  ;
 17062                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17063                                  ;		ES = DS
 17064                                  ;
 17065                                  ;	EXIT	nothing
 17066                                  ;	
 17067                                  ;	USED	AL,SI
 17068                                  
 17069                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17070                                  LowercaseString:
 17071 000019A2 57                      	push	di			; save di
 17072 000019A3 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17073 000019A5 FC                      	cld
 17074                                  NextChar: 
 17075 000019A6 AC                      	lodsb				; get character from string into al
 17076 000019A7 08C0                    	or	al,al			; are we at end of string?
 17077 000019A9 7406                    	jz	short EndOfString
 17078                                  
 17079 000019AB E8E9FF                  	call	LowerCase		; convert character to lowercase
 17080 000019AE AA                      	stosb				; store character back into buffer
 17081 000019AF EBF5                    	jmp	short NextChar		; repeat until end of string
 17082                                  
 17083                                  EndOfString:
 17084 000019B1 5F                      	pop	di			; restore di
 17085 000019B2 C3                      	retn
 17086                                  
 17087                                  ;M010;end
 17088                                  
 17089                                  ;============================================================================
 17090                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 17091                                  ;============================================================================
 17092                                  ; 09/10/2018 - Retro DOS v3.0
 17093                                  
 17094                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 17095                                  
 17096                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17097                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 17098                                  
 17099                                  ; =============== S U B	R O U T	I N E =======================================
 17100                                  
 17101                                  PAUSE:
 17102 000019B3 BA[AD7F]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 17103 000019B6 E83634                  	call	std_printf
 17104 000019B9 E898EB                  	call	GETKEYSTROKE
 17105                                  	;call	CRLF2
 17106                                  	;retn
 17107                                  	; 19/02/2023
 17108 000019BC E9120C                  	jmp	CRLF2
 17109                                  
 17110                                  ; ---------------------------------------------------------------------------
 17111                                  
 17112                                  ;****************************************************************
 17113                                  ;*
 17114                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 17115                                  ;*
 17116                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 17117                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 17118                                  ;*		up an error message and transfer control to CERROR.
 17119                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 17120                                  ;*		entered or SLASHP_ERASE if /P entered.
 17121                                  ;*
 17122                                  ;* INPUT:	command line at offset 81H
 17123                                  ;*
 17124                                  ;* OUTPUT:	if no error:
 17125                                  ;*		FCB at 5ch set up with filename(s) entered
 17126                                  ;*		Current directory set to entered directory
 17127                                  ;*
 17128                                  ;****************************************************************
 17129                                  
 17130                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17131                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 17132                                  	; 10/06/2023
 17133                                  ERASE:
 17134                                  	; MSDOS 6.0
 17135                                  
 17136                                  	;assume	ds:trangroup,es:trangroup
 17137                                  
 17138 000019BF BE8100                  	mov	si,81h		;AC000; get command line
 17139 000019C2 C706[DC8A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 17140 000019C8 BF[1985]                	mov	di,PARSE_ERASE
 17141                                  				;AN000; Get address of PARSE_ERASE
 17142 000019CB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17143                                  erase_scan:
 17144 000019CD 31D2                    	xor	dx,dx		;AN000;
 17145 000019CF E8E707                  	call	Parse_With_Msg	;AC018; call parser
 17146                                  
 17147                                  	;cmp	ax,-1  ; 0FFFFh
 17148                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 17149                                  	;je	short good_line	;AN000; yes - done parsing
 17150                                  	;;cmp	ax,0
 17151                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 17152                                  	;and	ax,ax		;AC000; did we have an error?
 17153                                  	;jnz	short errj2	;AC000; yes exit
 17154                                  	; 10/06/2023
 17155 000019D2 40                      	inc	ax  ; cmp ax,-1
 17156 000019D3 743C                    	jz	short good_line ; 0FFFFh -> 0
 17157 000019D5 48                      	dec	ax  ; cmp ax,0	
 17158 000019D6 7566                    	jnz	short errj2  ; 1 -> 0
 17159                                  	; ax = 0
 17160                                  
 17161 000019D8 813E[7695][8C84]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 17162                                  				;AN000; was /P entered?
 17163 000019DE 741C                    	je	short set_erase_prompt
 17164                                  				;AN000; yes - go set prompt
 17165                                  ;
 17166                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 17167                                  ;
 17168 000019E0 56                      	push	si		;AC000; save position in line
 17169 000019E1 C536[7895]              	lds	si,[PARSE1_ADDR]
 17170                                  				;AC000; get address of filespec
 17171                                  	;cmp	byte [si+1],colon_char
 17172 000019E5 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 17173 000019E9 750B                    	jne	short erase_drive_ok
 17174                                  				;AC000; no - continue
 17175                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 17176 000019EB 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 17177 000019EF 7505                    	jne	short erase_drive_ok
 17178                                  				;AC000; no - continue
 17179 000019F1 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 17180                                  				;AN022; get message number in control block
 17181 000019F4 EB3D                    	jmp	short extend_setup
 17182                                  				;AC000; exit
 17183                                  erase_drive_ok:
 17184 000019F6 E8AC12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17185 000019F9 5E                      	pop	si		;AC000; get position back
 17186 000019FA EBD1                    	jmp	short erase_scan
 17187                                  				;AN000; continue parsing
 17188                                  set_erase_prompt:
 17189 000019FC 833E[DC8A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 17190 00001A01 7408                    	jz	short ok_to_set_erase_prompt
 17191                                  				;AN018; no go set switch
 17192                                  	;mov	ax,1
 17193 00001A03 B80100                  	mov	ax,MoreArgs_Ptr 
 17194                                  				;AN018; set up too many arguments
 17195 00001A06 E8BF07                  	call	setup_parse_error_msg
 17196                                  				;AN018; set up an error message
 17197 00001A09 EB33                    	jmp	short errj2	;AN018; exit
 17198                                  
 17199                                  ok_to_set_erase_prompt: 	;AN018;
 17200 00001A0B FF06[DC8A]              	inc	word [COMSW]	;AN000; indicate /p specified
 17201 00001A0F EBBC                    	jmp	short erase_scan
 17202                                  				;AN000; continue parsing
 17203                                  good_line:			;G  We know line is good
 17204 00001A11 E8660C                  	call	PathCrunch
 17205 00001A14 730D                    	jnc	short checkdr
 17206 00001A16 A1[B88D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17207                                  	;cmp	ax,0		;AN022; was message flag set?
 17208 00001A19 09C0                    	or	ax,ax
 17209 00001A1B 7516                    	jnz	short extend_setup
 17210                                  				;AN022; yes - print out message
 17211                                  	;cmp	byte [DestIsDir],0
 17212 00001A1D 3806[4C8C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 17213 00001A21 750D                    	jnz	short badpath_err
 17214                                  				;AC022; see if they should have
 17215                                  checkdr:
 17216 00001A23 833E[DC8A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 17217 00001A28 7403                    	jz	short notest2j	;AN000; no - go to notest2
 17218 00001A2A E9091B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 17219                                  notest2j:
 17220 00001A2D E9A11A                  	jmp	notest2
 17221                                  
 17222                                  badpath_err:			;AN022; "Path not found" message
 17223 00001A30 B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 17224                                  				;AN022; set up error number
 17225                                  extend_setup:			;AN022;
 17226                                  	;mov	byte [msg_disp_class],1
 17227 00001A33 C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 17228                                  				;AN022; set up extended error msg class
 17229 00001A38 BA[1B7F]                	mov	dx,extend_buf_ptr
 17230                                  				;AC022; get extended message pointer
 17231 00001A3B A3[1B7F]                	mov	[extend_buf_ptr],ax
 17232                                  				;AN022; get message number in control block
 17233                                  errj2:				;AC022; exit jump
 17234 00001A3E E9110F                  	jmp	cerror		;AN022;
 17235                                  
 17236                                  ; 20/02/2023
 17237                                  %if 0
 17238                                  	; MSDOS 3.3
 17239                                  	mov	dx,BADARGSPTR
 17240                                  	mov	si,80h
 17241                                  	lodsb
 17242                                  	or	al,al
 17243                                  	jz	short ERRJ2
 17244                                  	call	SCANOFF
 17245                                  	cmp	al,0Dh		; Return key
 17246                                  	jz	short ERRJ2	; If so no parameters specified
 17247                                  	push	dx
 17248                                  	push	si
 17249                                  	mov	dx,FNOTFOUNDPTR
 17250                                  ERASE_SCAN:
 17251                                  	lodsb
 17252                                  	call	DELIM
 17253                                  	jz	short ERASE_CHKDELIMCHR
 17254                                  	cmp	al,0Dh
 17255                                  	jz	short GOOD_LINE
 17256                                  	jmp	short ERASE_SCAN
 17257                                  ERASE_CHKDELIMCHR:
 17258                                  	cmp	al,20h
 17259                                  	jg	short ERRJ2
 17260                                  	lodsb
 17261                                  	call	DELIM
 17262                                  	jz	short ERASE_CHKDELIMCHR
 17263                                  	cmp	al,0Dh
 17264                                  	jz	short GOOD_LINE
 17265                                  	mov	dx,BADARGSPTR
 17266                                  	jmp	short ERRJ2
 17267                                  GOOD_LINE:
 17268                                  	pop	si
 17269                                  	pop	dx
 17270                                  	push	si
 17271                                  	call	PATHCRUNCH
 17272                                  	jnc	short CHECKDR
 17273                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17274                                  	jz	short CHECKDR	   ; see if they should have
 17275                                  BADCDERR:
 17276                                  	pop	si
 17277                                  	mov	dx,BADCDPTR
 17278                                  ERRJ2:
 17279                                  	jmp	CERROR
 17280                                  CHECKDR:
 17281                                  	mov	dx,FNOTFOUNDPTR
 17282                                  	pop	cx
 17283                                  	mov	al,' '
 17284                                  	;cmp	[5Dh],al
 17285                                  	cmp	[FCB+1],al
 17286                                  	jz	short ERRJ2
 17287                                  	add	cx,3
 17288                                  	cmp	si,cx
 17289                                  	jnz	short NOTEST2J
 17290                                  	mov	al,':'
 17291                                  	cmp	[si-2],al
 17292                                  	jz	short ERRJ2
 17293                                  NOTEST2J:
 17294                                  	jmp	NOTEST2
 17295                                  %endif
 17296                                  
 17297                                  ; ---------------------------------------------------------------------------
 17298                                  
 17299                                  ; ****************************************************************
 17300                                  ; *
 17301                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17302                                  ; *
 17303                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17304                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17305                                  ; *		 Make sure the second filespec only contains a
 17306                                  ; *		 filename. If both openands are valid, attempt
 17307                                  ; *		 to rename the file.
 17308                                  ; *
 17309                                  ; * INPUT:	 command line at offset 81H
 17310                                  ; *
 17311                                  ; * OUTPUT:	 none
 17312                                  ; *
 17313                                  ; ****************************************************************
 17314                                  
 17315                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17316                                  CRENAME:
 17317                                  	; MSDOS 6.0
 17318                                  	;assume	ds:trangroup,es:trangroup
 17319                                  
 17320 00001A41 BE8100                  	mov	si,81h		;AC000; Point to command line
 17321 00001A44 BF[9085]                	mov	di,PARSE_RENAME
 17322                                  				;AN000; Get address of PARSE_RENAME
 17323 00001A47 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17324 00001A49 31D2                    	xor	dx,dx		;AN000;
 17325 00001A4B E86B07                  	call	Parse_With_Msg	;AC018; call parser
 17326                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17327 00001A4E 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17328                                  ;	jz	short crename_no_parse_error
 17329                                  				;AC000; no - continue
 17330 00001A50 752C                    	jnz	short crename_parse_error
 17331                                  				;AC000; Yes, fail. (need long jump)
 17332                                  ;
 17333                                  ;  Get first file name returned from parse into our buffer
 17334                                  ;
 17335                                  crename_no_parse_error:
 17336 00001A52 56                      	push	si		;AN000; save position in line
 17337 00001A53 C536[7895]              	lds	si,[PARSE1_ADDR]
 17338                                  				;AN000; get address of filespec
 17339 00001A57 E84B12                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17340 00001A5A 5E                      	pop	si		;AN000; restore position in line
 17341                                  
 17342 00001A5B 31D2                    	xor	dx,dx		;AN000; clear dx
 17343 00001A5D E85907                  	call	Parse_With_Msg	;AC018; call parser
 17344                                  	;cmp	ax,RESULT_NO_ERROR
 17345 00001A60 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17346 00001A62 751A                    	jnz	short crename_parse_error
 17347                                  				;AN000; Yes, fail.
 17348                                  ;
 17349                                  ;  Check the second file name for drive letter colon
 17350                                  ;
 17351 00001A64 56                      	push	si		;AN000; save position in line
 17352 00001A65 C536[7895]              	lds	si,[PARSE1_ADDR]
 17353                                  				;AC000; get address of path
 17354                                  	;mov	al,':'		;AC000;
 17355                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17356 00001A69 807C013A                	cmp	byte [si+1],':'
 17357 00001A6D 7511                    	jnz	short ren_no_drive
 17358                                  				;AN000; Yes, error
 17359                                  	;mov	byte [msg_disp_class],2
 17360 00001A6F C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class
 17361                                  				;AN000; set up parse error msg class
 17362 00001A74 BA[1B7F]                	mov	dx,extend_buf_ptr
 17363                                  				;AC000; get extended message pointer
 17364                                  	;mov	word [extend_buf_ptr],0Ah
 17365 00001A77 C706[1B7F]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17366                                  				;AN000; get "Invalid parameter" message number
 17367 00001A7D 5E                      	pop	si		;AN000;
 17368                                  crename_parse_error:		;AC022;
 17369 00001A7E EB64                    	jmp	short errj	;AC000;
 17370                                  
 17371                                  ;  Get second file name returned from parse into the fCB. Save
 17372                                  ;  character after file name so we can later check to make sure it
 17373                                  ;  isn't a path character.
 17374                                  
 17375                                  ren_no_drive:
 17376 00001A80 BF6C00                  	mov	di,FCB+10h ; 6Ch
 17377                                  				;AC000; set up to parse second file name
 17378                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17379 00001A83 B80129                  	mov	ax,2901h
 17380 00001A86 CD21                    	int	21h		;AC000; do the function
 17381 00001A88 AC                      	lodsb			;AC000; Load char after filename
 17382 00001A89 A2[448C]                	mov	[One_Char_Val],al
 17383                                  				;AN000; save char after filename
 17384 00001A8C 5E                      	pop	si		;AN000; get line position back
 17385                                  ;
 17386                                  ; We have source and target. See if any args beyond.
 17387                                  ;
 17388 00001A8D BF[9085]                	mov	di,PARSE_RENAME
 17389                                  				;AC000; get address of parse_rename
 17390 00001A90 E81007                  	call	parse_check_eol ;AC000; are we at end of line?
 17391 00001A93 75E9                    	jnz	short crename_parse_error
 17392                                  				;AN000; no, fail.
 17393                                  
 17394 00001A95 E8E20B                  	call	PathCrunch
 17395 00001A98 BA[2C7F]                	mov	dx,BADCPMES_PTR
 17396 00001A9B 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17397 00001A9D 730F                    	jnc	short notest3
 17398 00001A9F A1[B88D]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17399                                  	;cmp	ax,0		;AN022; was message flag set?
 17400 00001AA2 21C0                    	and	ax,ax ; 0 ?
 17401 00001AA4 758D                    	jnz	short extend_setup
 17402                                  				;AN022; yes - print out message
 17403                                  	;cmp	byte [DestIsDir],0
 17404 00001AA6 3806[4C8C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17405 00001AAA 7402                    	jz	short notest3 	; see if they should have
 17406 00001AAC EB82                    	Jmp	badpath_err	;AC022; set up error
 17407                                  notest3:
 17408 00001AAE A0[448C]                	mov	al,[One_Char_Val]
 17409                                  				;AN000; move char into AX
 17410 00001AB1 BA[4A7F]                	mov	dx,INORNOT_PTR 
 17411                                  				; Load invalid fname error ptr
 17412 00001AB4 E8B50B                  	call	pathchrcmp	; Is the char in al a path sep?
 17413 00001AB7 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17414                                  				;  filename only.
 17415                                  	;mov	ah,FCB_Rename
 17416 00001AB9 B417                    	mov	ah,17h
 17417 00001ABB BA5C00                  	mov	dx,FCB ; 5Ch
 17418 00001ABE CD21                    	int	21h
 17419 00001AC0 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17420 00001AC2 7506                    	jne	short renameok
 17421                                  
 17422 00001AC4 E82902                  	call	get_ext_error_number
 17423                                  				;AN022; get extended error
 17424 00001AC7 50                      	push	ax		;AC022; Save results
 17425 00001AC8 B0FF                    	mov	al,0FFh		; Restore original error state
 17426                                  renameok:
 17427 00001ACA 50                      	push	ax
 17428 00001ACB E8C009                  	call	RestUDir
 17429 00001ACE 58                      	pop	ax
 17430 00001ACF FEC0                    	inc	al
 17431                                  	;;retnz
 17432                                  	;jz	short rn1
 17433                                  	;retn	
 17434 00001AD1 7514                    	jnz	short ret56
 17435                                  rn1:
 17436 00001AD3 58                      	pop	ax		;AC022; get the error number back
 17437 00001AD4 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17438                                  				;AN022; error file not found?
 17439 00001AD7 7408                    	jz	short use_renerr
 17440                                  				;AN022; yes - use generic error message
 17441 00001AD9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17442                                  				;AN022; error file not found?
 17443 00001ADC 7403                    	jz	short use_renerr
 17444                                  				;AN022; yes - use generic error message
 17445 00001ADE E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17446                                  
 17447                                  use_renerr:
 17448 00001AE1 BA[297F]                	mov	dx,RENERR_PTR	;AC022;
 17449                                  errj:
 17450 00001AE4 E96B0E                  	jmp	cerror
 17451                                  ret56:
 17452                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17453 00001AE7 C3                      	retn
 17454                                  
 17455                                  ; 20/02/2023
 17456                                  %if 0
 17457                                  	; MSDOS 3.3
 17458                                  	mov	dx,BADARGSPTR
 17459                                  	call	SCANOFF
 17460                                  	cmp	al,0Dh
 17461                                  	jz	short ERRJ2
 17462                                  	call	PATHCRUNCH
 17463                                  	mov	dx,BADCPMESPTR
 17464                                  	jz	short ERRJ2
 17465                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17466                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17467                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17468                                  	jmp	short BADCDERR
 17469                                  
 17470                                  ;  Get first file name returned from parse into our buffer
 17471                                  
 17472                                  CRENAME_NO_PARSE_ERROR:
 17473                                  	mov	si,[PATHPOS]
 17474                                  	call	SCANOFF
 17475                                  	cmp	al,0Dh
 17476                                  	mov	dx,BADARGSPTR
 17477                                  	jz	short ERRJ
 17478                                  	mov	al,':'
 17479                                  	mov	dx,BADPARMPTR
 17480                                  	cmp	[si+1],al
 17481                                  	jz	short ERRJ
 17482                                  
 17483                                  ;  Get second file name returned from parse into the FCB. Save
 17484                                  ;  character after file name so we can later check to make sure it
 17485                                  ;  isn't a path character.
 17486                                  
 17487                                  REN_NO_DRIVE:
 17488                                  	;mov	di,6Ch
 17489                                  	mov	di,FCB+10h
 17490                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17491                                  	int	21h	; DOS -	PARSE FILENAME
 17492                                  			; DS:SI	-> string to parse
 17493                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17494                                  			; AL = bit mask	to control parsing
 17495                                  	mov	al,' '
 17496                                  	;cmp	[6Dh],al
 17497                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17498                                  	jz	short ERRJ	; Error if missing parameter
 17499                                  	lodsb
 17500                                  	mov	dx,INORNOTPTR
 17501                                  	call	PATHCHRCMP
 17502                                  	jz	short ERRJ
 17503                                  	mov	ah,FCB_RENAME ; 17h
 17504                                  	mov	dx,FCB ; 5Ch
 17505                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17506                                  			; DS:DX	-> FCB
 17507                                  			; FCB contains new name	starting at byte 17h.
 17508                                  	cmp	al,0FFh		; Did an error occur??	
 17509                                  	jnz	short RENAMEOK
 17510                                  	stc
 17511                                  	mov	dx,RENERRPTR
 17512                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17513                                  	push	dx
 17514                                  	mov	al,0FFh		; Restore original error state
 17515                                  RENAMEOK:
 17516                                  	push	ax
 17517                                  	call	RESTUDIR
 17518                                  	pop	ax
 17519                                  	inc	al
 17520                                  	jz	short RENAME_ERR
 17521                                  RENAME_RETN:
 17522                                  TYPELP_RET:
 17523                                  	retn
 17524                                  RENAME_ERR:
 17525                                  	pop	dx
 17526                                  ERRJ:				; Retro DOS v3.0
 17527                                  	call	STD_EPRINTF
 17528                                  	jmp	TCOMMAND
 17529                                  
 17530                                  ; ---------------------------------------------------------------------------
 17531                                  
 17532                                  ;ERRJ:
 17533                                  ;	jmp	CERROR
 17534                                  
 17535                                  ; ---------------------------------------------------------------------------
 17536                                  
 17537                                  ;TYPELP_RET:
 17538                                  ;	retn
 17539                                  
 17540                                  %endif
 17541                                  
 17542                                  ; ---------------------------------------------------------------------------
 17543                                  
 17544                                  ;****************************************************************
 17545                                  ;*
 17546                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17547                                  ;*		standard output device
 17548                                  ;*
 17549                                  ;* SYNTAX:	TYPE filespec
 17550                                  ;*
 17551                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17552                                  ;*		1Ah and display the contents to STDOUT.
 17553                                  ;*
 17554                                  ;* INPUT:	command line at offset 81H
 17555                                  ;*
 17556                                  ;* OUTPUT:	none
 17557                                  ;*
 17558                                  ;****************************************************************
 17559                                  
 17560                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17561                                  TYPEFIL:
 17562                                  	; MSDOS 6.0	
 17563                                  	;assume	ds:trangroup,es:trangroup
 17564                                  
 17565 00001AE8 BE8100                  	mov	si,81h
 17566 00001AEB BF[0785]                	mov	di,PARSE_MRDIR
 17567                                  				;AN000; Get address of PARSE_MRDIR
 17568 00001AEE 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17569 00001AF0 31D2                    	xor	dx,dx		;AN000;
 17570 00001AF2 E8C406                  	call	Parse_With_Msg	;AC018; call parser
 17571                                  	;cmp	ax,RESULT_NO_ERROR
 17572 00001AF5 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17573 00001AF7 751E                    	jnz	short typefil_parse_error
 17574                                  				;AN000; yes - issue error message
 17575                                  
 17576 00001AF9 56                      	push	si		;AC000; save position in line
 17577 00001AFA C536[7895]              	lds	si,[PARSE1_ADDR]
 17578                                  				;AC000; get address of filespec
 17579 00001AFE E8A411                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17580 00001B01 5E                      	pop	si		;AC000; get position back
 17581 00001B02 BF[0785]                	mov	di,PARSE_MRDIR
 17582                                  				;AC000; get address of parse_mrdir
 17583 00001B05 E89B06                  	call	parse_check_eol ;AC000; are we at end of line?
 17584                                  	;jz	short gottarg 	;AC000; yes - continue
 17585                                  	; 20/02/2023
 17586                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17587                                  	;jmp	cerror
 17588 00001B08 750D                    	jnz	short typefil_parse_error
 17589                                  gottarg:
 17590 00001B0A E8DF0F                  	call	SETPATH
 17591 00001B0D F606[508C]02            	test	byte [DestInfo],00000010b ; 2
 17592                                  				; Does the filespec contain wildcards
 17593 00001B12 7406                    	jz	short nowilds 	; No, continue processing
 17594 00001B14 BA[4A7F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17595                                  	; 20/02/2023
 17596                                  typefil_parse_error:
 17597 00001B17 E9380E                  	jmp	cerror
 17598                                  nowilds:
 17599                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17600 00001B1A B8006C                  	mov	ax,6C00h
 17601                                  	;mov	bx,read_open_mode ; 0
 17602                                  				;AN000; get open mode for TYPE
 17603 00001B1D 31C9                    	xor	cx,cx		;AN000; no special files
 17604 00001B1F 89CB                    	mov	bx,cx ; 20/02/2023
 17605 00001B21 BA0101                  	mov	dx,101h
 17606                                  	;mov	dx,read_open_flag ; 101h
 17607                                  				;AN000; set up open flags
 17608 00001B24 BE[B48C]                	mov	si,SrcBuf	;AN030; get file name
 17609 00001B27 CD21                    	int	21h
 17610 00001B29 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17611                                  
 17612                                  typerr: 			;AN022;
 17613 00001B2B 0E                      	push	cs		;AN022; make sure we have local segment
 17614 00001B2C 1F                      	pop	ds		;AN022;
 17615 00001B2D E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 17616 00001B30 C706[358C][B48C]        	mov	word [string_ptr_2],SrcBuf 
 17617                                  				;AC022; get address of failed string
 17618                                  	;mov	byte [extend_buf_sub],1
 17619 00001B36 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 17620                                  				;AC022; put number of subst in control block
 17621 00001B3B E9140E                  	jmp	cerror		;AC022; exit
 17622                                  
 17623                                  typecont:
 17624 00001B3E 89C3                    	mov	bx,ax		;AC000; get Handle
 17625                                  ;M043
 17626                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17627                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17628                                  ;indicate it is a device.
 17629                                  ;
 17630                                  	;mov	ax,(IOCTL shl 8) or 0
 17631 00001B40 B80044                  	mov	ax,4400h
 17632 00001B43 CD21                    	int	21h
 17633                                  
 17634 00001B45 F6C280                  	test	dl,80h		;is it a device?
 17635 00001B48 7408                    	jz	short not_device
 17636                                  				;no, a file
 17637                                  
 17638 00001B4A C706[7295]FFFF          	mov	word [TypeFilSiz+2],-1
 17639                                  				;indicate it is a device
 17640 00001B50 EB17                    	jmp	short dotype
 17641                                  not_device:
 17642                                  ;SR;
 17643                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17644                                  ;start of file
 17645                                  
 17646                                  	;mov	ax,(LSEEK shl 8) or 2
 17647 00001B52 B80242                  	mov	ax,4202h
 17648 00001B55 31D2                    	xor	dx,dx
 17649 00001B57 89D1                    	mov	cx,dx		;seek  to end of file
 17650 00001B59 CD21                    	int	21h
 17651                                  
 17652 00001B5B A3[7095]                	mov	[TypeFilSiz],ax
 17653 00001B5E 8916[7295]              	mov	[TypeFilSiz+2],dx ;store filesize
 17654                                  	;mov	ax,(LSEEK shl 8) or 0
 17655 00001B62 B80042                  	mov	ax,4200h
 17656 00001B65 31D2                    	xor	dx,dx
 17657 00001B67 CD21                    	int	21h	        ;reset file pointer to start
 17658                                  dotype:				;M043
 17659 00001B69 C606[2294]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17660 00001B6E 8E1E[C78A]              	mov	ds,[TPA]
 17661 00001B72 31D2                    	xor	dx,dx
 17662                                  	;ASSUME	DS:NOTHING
 17663                                  typelp:
 17664 00001B74 2E803E[2294]00          	cmp	byte [cs:zflag],0
 17665                                  				;AC050; Is the ^Z flag set?
 17666                                  	;retnz			; Yes, return
 17667                                  	; 17/04/2023
 17668 00001B7A 7401                    	jz	short tf1
 17669 00001B7C C3                      	retn
 17670                                  tf1:
 17671 00001B7D 2E8B0E[E68A]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17672                                  
 17673                                  ;Update the filesize left to read
 17674                                  
 17675 00001B82 2E833E[7295]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17676                                  				;is it a device? M043
 17677 00001B88 7431                    	je	short typ_read	;yes, just read from it; M043
 17678                                  
 17679 00001B8A 2E833E[7295]00          	cmp	word [cs:TypeFilSiz+2],0
 17680                                  				;more than 64K left?
 17681 00001B90 740D                    	jz	short lt64k	;no, do word subtraction
 17682 00001B92 2E290E[7095]            	sub	[cs:TypeFilSiz],cx
 17683 00001B97 2E831E[7295]00          	sbb	word [cs:TypeFilSiz+2],0
 17684                                  				;update filesize
 17685 00001B9D EB1C                          	jmp	short typ_read	;do the read
 17686                                  lt64k:
 17687 00001B9F 2E3B0E[7095]            	cmp	cx,[cs:TypeFilSiz]
 17688                                  				;readsize <= buffer?
 17689 00001BA4 7610                    	jbe	short gtbuf	; yes, just update readsize
 17690                                  
 17691                                  ;Buffer size is larger than bytes to read
 17692                                  
 17693 00001BA6 2E8B0E[7095]            	mov	cx,[cs:TypeFilSiz]
 17694 00001BAB E361                    	jcxz	typelp_ret
 17695 00001BAD 2EC706[7095]0000        	mov	word [cs:TypeFilSiz],0
 17696 00001BB4 EB05                    	jmp	short typ_read
 17697                                  gtbuf:
 17698 00001BB6 2E290E[7095]            	sub	[cs:TypeFilSiz],cx
 17699                                  				;update filesize remaining
 17700                                  typ_read:
 17701                                  	;mov	ah,read
 17702 00001BBB B43F                    	mov	ah,3Fh
 17703 00001BBD CD21                    	int	21h
 17704 00001BBF 7303                    	jnc	short tf2	;M043
 17705 00001BC1 E967FF                  	jmp	typerr		;M043
 17706                                  tf2:				;M043
 17707                                  ;M043;	jc	typerr		;AN022; Exit if error
 17708                                  
 17709 00001BC4 89C1                    	mov	cx,ax
 17710 00001BC6 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17711 00001BC8 1E                      	push	ds
 17712 00001BC9 07                      	pop	es		; Check to see if a ^Z was read.
 17713                                  	;assume es:nothing
 17714 00001BCA 31FF                    	xor	di,di
 17715 00001BCC 50                      	push	ax
 17716 00001BCD B01A                    	mov	al,1Ah
 17717 00001BCF F2AE                    	repnz	scasb
 17718 00001BD1 58                      	pop	ax
 17719 00001BD2 91                      	xchg	ax,cx
 17720                                  	;cmp	ax,0
 17721 00001BD3 21C0                    	and	ax,ax
 17722 00001BD5 7506                    	jnz	short foundz	; Yes, handle it
 17723 00001BD7 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17724 00001BDB 750A                    	jnz	short typecont2	; No ^Z, continue
 17725                                  foundz:
 17726 00001BDD 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17727 00001BDF 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17728 00001BE0 0E                      	push	cs		;  will be typed.
 17729 00001BE1 07                      	pop	es
 17730                                  	;assume es:trangroup
 17731 00001BE2 26F616[2294]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17732                                  typecont2:			;  will quit after this write.
 17733 00001BE7 53                      	push	bx
 17734 00001BE8 BB0100                  	mov	bx,1
 17735                                  	;mov	ah,Write
 17736 00001BEB B440                    	mov	ah,40h
 17737 00001BED CD21                    	int	21h
 17738 00001BEF 5B                      	pop	bx
 17739 00001BF0 720C                    	jc	short Error_outputj
 17740 00001BF2 39C8                    	cmp	ax,cx
 17741 00001BF4 7503                    	jnz	short tf3	;M043
 17742 00001BF6 E97BFF                  	jmp	typelp		;M043
 17743                                  tf3:				;M043
 17744                                  ;M043;	jz	short typelp
 17745 00001BF9 49                      	dec	cx
 17746 00001BFA 39C8                    	cmp	ax,cx
 17747                                  	;;retz			; One less byte OK (^Z)
 17748                                  	;jnz	short Error_outputj
 17749                                  ;tf4:
 17750                                  	;retn
 17751 00001BFC 7410                    	jz	short typelp_ret ; 20/02/2023
 17752                                  
 17753                                  Error_outputj:
 17754 00001BFE BB0100                  	mov	bx,1
 17755                                  	;mov	ax,IOCTL SHL 8
 17756 00001C01 B80044                  	mov	ax,4400h
 17757 00001C04 CD21                    	int	21h
 17758 00001C06 F6C280                  	test	dl,80h
 17759                                  	;test	dl,devid_ISDEV
 17760                                  	;;retnz			; If device, no error message
 17761                                  	;jnz	short tf4
 17762 00001C09 7503                    	jnz	short typelp_ret
 17763 00001C0B E9440A                  	jmp	error_output
 17764                                  typelp_ret:
 17765 00001C0E C3                      	retn
 17766                                  
 17767                                  ; 20/02/2023
 17768                                  %if 0
 17769                                  	; MSDOS 3.3
 17770                                  	mov	si,81h
 17771                                  	call	SCANOFF		; Skip to first non-delim
 17772                                  	cmp	al,0Dh
 17773                                  	jnz	short GOTTARG
 17774                                  	mov	dx,BADARGSPTR
 17775                                  
 17776                                  	;jmp	CERROR
 17777                                  	jmp	short ERRJ	; No args
 17778                                  GOTTARG:
 17779                                  	call	SETPATH
 17780                                  	test	byte [DESTINFO],2
 17781                                  	jz	short NOWILDS
 17782                                  	mov	dx,INORNOTPTR
 17783                                  
 17784                                  	;jmp	CERROR
 17785                                  	jmp	short ERRJ
 17786                                  NOWILDS:
 17787                                  	mov	ax,OPEN*256 ; 3D00h
 17788                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17789                                  			; DS:DX	-> ASCIZ filename
 17790                                  			; AL = access mode
 17791                                  			; 0 - read
 17792                                  	jnc	short TYPECONT
 17793                                  	mov	dx,FNOTFOUNDPTR
 17794                                  	cmp	ax,2
 17795                                  	jz	short ERRJ
 17796                                  	mov	dx,BADCPMESPTR
 17797                                  	stc
 17798                                  	call	GET_EXT_ERR_NUMBER
 17799                                  	
 17800                                  	;jmp	CERROR
 17801                                  	jmp	short ERRJ
 17802                                  TYPECONT:
 17803                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17804                                  	mov	bx,ax		; Handle
 17805                                  	mov	ds,[TPA]
 17806                                  	xor	dx,dx
 17807                                  TYPELP:
 17808                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17809                                  	jnz	short RENAME_RETN ; Yes, return	
 17810                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17811                                  	mov	ah,READ ; 3Fh
 17812                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17813                                  			; BX = file handle,CX = number	of bytes to read
 17814                                  			; DS:DX	-> buffer
 17815                                  	mov	cx,ax
 17816                                  	jcxz	TYPELP_RET	; exit if nothing read
 17817                                  				; Check to see if a ^Z was read.
 17818                                  	push	ds
 17819                                  	pop	es		
 17820                                  	xor	di,di
 17821                                  	push	ax
 17822                                  	mov	al,1Ah
 17823                                  	repne	scasb
 17824                                  	pop	ax
 17825                                  	xchg	ax,cx
 17826                                  	cmp	ax,0
 17827                                  	jnz	short FOUNDZ	; Yes, handle it
 17828                                  	cmp	byte [di-1],1Ah	; No, double check
 17829                                  	jnz	short TYPECONT2	; No ^Z, continue
 17830                                  FOUNDZ:
 17831                                  	sub	cx,ax		; Otherwise change cx so that only those
 17832                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17833                                  	push	cs		;  will be typed.
 17834                                  	pop	es
 17835                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17836                                  				;  will quit after this write.
 17837                                  TYPECONT2:
 17838                                  	push	bx
 17839                                  	mov	bx,1
 17840                                  	mov	ah,WRITE ; 40h
 17841                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17842                                  			; BX = file handle, CX = number of bytes to write,
 17843                                  			; DS:DX -> buffer
 17844                                  	pop	bx
 17845                                  	jc	short ERROR_OUTPUTJ
 17846                                  	cmp	ax,cx
 17847                                  	jz	short TYPELP
 17848                                  	dec	cx
 17849                                  	cmp	ax,cx		; One less byte OK (^Z)
 17850                                  	jnz	short ERROR_OUTPUTJ
 17851                                  TYPEFIL_RETN:
 17852                                  	retn
 17853                                  ERROR_OUTPUTJ:
 17854                                  	mov	bx,1
 17855                                  	mov	ax,IOCTL*256 ; 4400h
 17856                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17857                                  			; BX = file or device handle
 17858                                  	;test	dl,devid_ISDEV
 17859                                  	test	dl,80h
 17860                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17861                                  	jmp	ERROR_OUTPUT
 17862                                  %endif
 17863                                  
 17864                                  ; ---------------------------------------------------------------------------
 17865                                  
 17866                                  ; VOLUME command displays the volume ID on the specified drive
 17867                                  
 17868                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17869                                  	; 10/06/2023
 17870                                  VOLUME:
 17871                                  	; MSDOS 6.0
 17872 00001C0F BE8100                  	mov	si,81h
 17873 00001C12 BF[F584]                	mov	di,PARSE_VOL
 17874                                  				;AN000; Get address of PARSE_VOL
 17875 00001C15 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17876 00001C17 31D2                    	xor	dx,dx		;AN000;
 17877 00001C19 E89D05                  	call	Parse_With_Msg	;AC018; call parser
 17878                                  
 17879                                  	;cmp	ax,-1 ; 0FFFFh
 17880                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17881                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 17882                                  	;;cmp	ax,RESULT_NO_ERROR
 17883                                  	;;cmp	ax,0		;AC000; did we have an error?
 17884                                  	;or	ax,ax ; 0?
 17885                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 17886                                  	; 10/06/2023
 17887 00001C1C 40                      	inc	ax  ; cmp ax,-1
 17888 00001C1D 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 17889 00001C1F 48                      	dec	ax  ; cmp ax,0
 17890 00001C20 750A                    	jnz	short badvolarg ; 1 -> 0
 17891                                  	; ax = 0
 17892                                  
 17893                                  ; We have parsed off the drive. See if there are any more chars left
 17894                                  
 17895 00001C22 BF[F584]                	mov	di,PARSE_VOL
 17896                                  				;AC000; get address of parse_vol
 17897 00001C25 31D2                    	xor	dx,dx		;AC000;
 17898 00001C27 E87905                  	call	parse_check_eol ;AC000; call parser
 17899 00001C2A 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17900                                  
 17901                                  ; The line was not interpretable. Report an error.
 17902                                  
 17903                                  badvolarg:
 17904 00001C2C E9230D                  	jmp	cerror
 17905                                  
 17906                                  ; 20/02/2023
 17907                                  %if 0
 17908                                  	; MSDOS 3.3
 17909                                  	mov	si,81h
 17910                                  	call	SCANOFF		; Skip to first non-delim
 17911                                  	;mov	ah,[5Ch]
 17912                                  	mov	ah,[FCB]
 17913                                  	;mov	byte [5Ch],0
 17914                                  	mov	byte [FCB],0
 17915                                  	cmp	al,0Dh		; are we at end of line?
 17916                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17917                                  	;mov	[5Ch],ah
 17918                                  	mov	[FCB],ah
 17919                                  	lodsb
 17920                                  	lodsb
 17921                                  	cmp	al,':'
 17922                                  	jnz	short VOLUME_ERR
 17923                                  	call	SCANOFF
 17924                                  	cmp	al,0Dh
 17925                                  	jz	short OKVOLARG
 17926                                  VOLUME_ERR:
 17927                                  	mov	dx,BADDRVPTR
 17928                                  	jmp	CERROR
 17929                                  
 17930                                  ; ---------------------------------------------------------------------------
 17931                                  
 17932                                  OKVOLARG:
 17933                                  	call	CRLF2
 17934                                  	push	ds
 17935                                  	pop	es
 17936                                  	;mov	di,55h
 17937                                  	mov	di,FCB-7	; Set up extended FCB
 17938                                  	mov	al,-1
 17939                                  	stosb
 17940                                  	xor	ax,ax
 17941                                  	stosw
 17942                                  	stosw
 17943                                  	stosb
 17944                                  	mov	al,8		; Look for volume label
 17945                                  	stosb
 17946                                  	inc	di		; Skip drive byte
 17947                                  	mov	cx,11
 17948                                  	mov	al,'?'
 17949                                  	rep stosb
 17950                                  	mov	dx,DIRBUF
 17951                                  	mov	ah,Set_DMA ; 1Ah
 17952                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17953                                  			; DS:DX	-> disk	transfer buffer
 17954                                  	;mov	dx,55h
 17955                                  	mov	dx,FCB-7
 17956                                  	mov	ah,Dir_Search_First ; 11h
 17957                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17958                                  			; DS:DX	-> FCB
 17959                                  	jmp	PRINTVOL
 17960                                  %endif
 17961                                  
 17962                                  ; ---------------------------------------------------------------------------
 17963                                  
 17964                                  ;***	DisAppend - disable APPEND
 17965                                  ;
 17966                                  ;	ENTRY	nothing
 17967                                  ;
 17968                                  ;	EXIT	nothing
 17969                                  ;
 17970                                  ;	USED	AX,BX
 17971                                  ;
 17972                                  ;	EFFECTS
 17973                                  ;
 17974                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 17975                                  ;	  after the command finishes, by the HeadFix routine.
 17976                                  ;
 17977                                  ;	NOTE
 17978                                  ;
 17979                                  ;	  This routine must not be called more than once during a single
 17980                                  ;	  command cycle. The second call would permanently disable APPEND.
 17981                                  
 17982                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17983                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 17984                                  
 17985                                  	; MSDOS 6.0
 17986                                  DisAppend:
 17987 00001C2F 1E                      	push	ds			; save DS
 17988 00001C30 06                      	push	es			; save ES
 17989 00001C31 57                      	push	di
 17990                                  
 17991                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 17992 00001C32 B800B7                  	mov	ax,0B700h
 17993 00001C35 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17994 00001C37 08C0                    	or	al,al
 17995 00001C39 7423                    	jz	short daRet		; APPEND not installed, return
 17996                                  
 17997                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 17998 00001C3B B802B7                  	mov	ax,0B702h
 17999 00001C3E CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18000 00001C40 83F8FF                  	cmp	ax,0FFFFh
 18001 00001C43 7519                    	jne	short daRet		; it's not a local version, return
 18002                                  
 18003                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 18004 00001C45 B806B7                  	mov	ax,0B706h
 18005 00001C48 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18006                                  
 18007 00001C4A 8E1E[C58A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 18008                                  
 18009 00001C4E 891E[AB01]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 18010 00001C52 C606[AD01]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 18011                                  
 18012 00001C57 31DB                    	xor	bx,bx			; BX = APPEND state = off
 18013                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 18014 00001C59 B807B7                  	mov	ax,0B707h
 18015 00001C5C CD2F                    	int	2Fh			; talk to APPEND via multiplex
 18016                                  daRet:	
 18017 00001C5E 5F                      	pop	di
 18018 00001C5F 07                      	pop	es			; restore ES
 18019 00001C60 1F                      	pop	ds			; restore DS
 18020                                  
 18021 00001C61 C3                      	retn
 18022                                  
 18023                                  ; ---------------------------------------------------------------------------
 18024                                  
 18025                                  ; Find the Volume ID on the disk.
 18026                                  
 18027                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18028                                  
 18029                                  	; MSDOS 6.0
 18030                                  OkVolArg:
 18031 00001C62 E8CAFF                  	call	DisAppend		; disable APPEND
 18032 00001C65 E86909                  	call	CRLF2
 18033                                  	;mov	al,blank			
 18034 00001C68 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18035 00001C6A E89001                  	call	PRINT_CHAR		;AN051;  before volume message
 18036 00001C6D 1E                      	push	ds
 18037 00001C6E 07                      	pop	es
 18038                                  
 18039                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 18040                                  ; of volume_id ONLY.
 18041                                  
 18042 00001C6F BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 18043 00001C72 B0FF                    	mov	al,-1			; Tag to indicate Extention
 18044 00001C74 AA                      	stosb
 18045 00001C75 31C0                    	xor	ax,ax			; Zero padding to volume label
 18046 00001C77 AB                      	stosw
 18047 00001C78 AB                      	stosw
 18048 00001C79 AA                      	stosb
 18049 00001C7A B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 18050 00001C7C AA                      	stosb
 18051 00001C7D 47                      	inc	di			; Skip drive byte; it is already set
 18052 00001C7E B90B00                  	mov	cx,11			; fill in remainder of file
 18053 00001C81 B03F                    	mov	al,'?'
 18054 00001C83 F3AA                    	rep	stosb
 18055                                  
 18056                                  ; Set up transfer address (destination of search first information)
 18057                                  
 18058 00001C85 BA[CE8B]                	mov	dx,DIRBUF
 18059                                  	;mov	ah,Set_DMA
 18060 00001C88 B41A                    	mov	ah,1Ah
 18061 00001C8A CD21                    	int	21h
 18062                                  
 18063                                  ; Do the search
 18064                                  
 18065 00001C8C BA5500                  	mov	dx,FCB-7 ; 55h
 18066                                  	;mov	ah,Dir_Search_First
 18067 00001C8F B411                    	mov	ah,11h
 18068 00001C91 CD21                    	int	21h
 18069                                  
 18070                                  ;********************************
 18071                                  ; Print volume ID info
 18072                                  
 18073 00001C93 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 18074 00001C94 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 18075 00001C97 0440                    	add	al,'@'  ; add al,40h
 18076 00001C99 3C40                    	cmp	al,'@'
 18077 00001C9B 7505                    	jne	short drvok
 18078 00001C9D A0[D98A]                	mov	al,[CURDRV]
 18079                                  	;add	al,capital_A
 18080 00001CA0 0441                    	add	al,'A'
 18081                                  drvok:
 18082 00001CA2 A2[468C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 18083 00001CA5 58                      	pop	ax			;AC000; get return code back
 18084 00001CA6 08C0                    	or	al,al			;AC000; volume label found?
 18085 00001CA8 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 18086 00001CAA BA[1680]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 18087 00001CAD EB13                    	jmp	short print_serial	;AC000; go print it
 18088                                  
 18089                                  Get_vol_name:
 18090 00001CAF BF[FF8A]                	mov	di,CHARBUF
 18091 00001CB2 89FA                    	mov	dx,di
 18092 00001CB4 BE[D68B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 18093 00001CB7 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 18094 00001CBA F3A4                    	rep	movsb			;AN000;  3/3/KK
 18095                                  
 18096 00001CBC 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 18097 00001CBE AA                      	stosb
 18098 00001CBF BA[2480]                	mov	dx,VolMes_Ptr		;AC000; set up message
 18099                                  
 18100                                  print_serial:
 18101                                  
 18102                                  ; Attempt to get the volume serial number from the disk. If an error
 18103                                  ; occurs, do not print volume serial number.
 18104                                  
 18105 00001CC2 52                      	push	dx			;AN000; save message offset
 18106                                  	;mov	ax,(GetSetMediaID SHL 8)
 18107 00001CC3 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 18108 00001CC6 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 18109 00001CCA BA[9D8D]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 18110 00001CCD CD21                    	int	21h			;AN000; do the call
 18111                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 18112                                  			; AL = 00h get serial number / 01h set serial number
 18113                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 18114                                  			; DS:DX -> disk info
 18115 00001CCF 5A                      	pop	dx			;AN000; get message offset back
 18116 00001CD0 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 18117 00001CD2 E81A31                  	call	std_printf		;AC000; go print volume message
 18118                                  	;mov	al,blank				
 18119 00001CD5 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 18120 00001CD7 E82301                  	call	PRINT_CHAR		;AN051;  before volume message
 18121 00001CDA BA[3D80]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 18122                                  printvol_end:
 18123 00001CDD E90F31                  	jmp	std_printf		;AC000; go print and exit
 18124                                  
 18125                                  ; ---------------------------------------------------------------------------
 18126                                  
 18127                                  ;****************************************************************
 18128                                  ;*
 18129                                  ;* ROUTINE:	Set_ext_error_msg
 18130                                  ;*
 18131                                  ;* FUNCTION:	Sets up extended error message for printing
 18132                                  ;*
 18133                                  ;* INPUT:	return from INT 21
 18134                                  ;*
 18135                                  ;* OUTPUT:	extended error message set up in extended error
 18136                                  ;*		buffer.
 18137                                  ;*
 18138                                  ;****************************************************************
 18139                                  	
 18140                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18141                                  
 18142                                  	; MSDOS 6.0
 18143                                  Set_Ext_Error_Msg:			;AN000;
 18144 00001CE0 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 18145 00001CE3 C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 18146                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 18147 00001CE8 BA[1B7F]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 18148 00001CEB A3[1B7F]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 18149 00001CEE F9                      	stc				;AN000; make sure carry is set
 18150 00001CEF C3                      	retn				;AN000; return
 18151                                  
 18152                                  ; ---------------------------------------------------------------------------
 18153                                  
 18154                                  ;****************************************************************
 18155                                  ;*
 18156                                  ;* ROUTINE:	Get_ext_error_number
 18157                                  ;*
 18158                                  ;* FUNCTION:	Does get extended error function call
 18159                                  ;*
 18160                                  ;* INPUT:	return from INT 21
 18161                                  ;*
 18162                                  ;* OUTPUT:	AX - extended error number
 18163                                  ;*
 18164                                  ;****************************************************************
 18165                                  
 18166                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18167                                  
 18168                                  	; MSDOS 6.0
 18169                                  get_ext_error_number:			;AN022;
 18170                                  
 18171                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 18172                                  					;AN022; save registers
 18173 00001CF0 53                      	push	bx
 18174 00001CF1 51                      	push	cx
 18175 00001CF2 52                      	push	dx
 18176 00001CF3 56                      	push	si
 18177 00001CF4 57                      	push	di
 18178 00001CF5 55                      	push	bp
 18179 00001CF6 06                      	push	es
 18180 00001CF7 1E                      	push	ds
 18181                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 18182 00001CF8 B459                    	mov	ah,59h
 18183 00001CFA 31DB                    	xor	bx,bx			;AN022; clear BX
 18184 00001CFC CD21                    	int	21h			;AN022;
 18185                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 18186                                  			; BX = version code (0000h for DOS 3.x)
 18187                                  
 18188                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 18189                                  					;AN022; restore registers
 18190 00001CFE 1F                      	pop	ds
 18191 00001CFF 07                      	pop	es
 18192 00001D00 5D                      	pop	bp
 18193 00001D01 5F                      	pop	di
 18194 00001D02 5E                      	pop	si
 18195 00001D03 5A                      	pop	dx
 18196 00001D04 59                      	pop	cx
 18197 00001D05 5B                      	pop	bx
 18198                                  
 18199 00001D06 C3                      	retn				;AN022; return
 18200                                  
 18201                                  ;============================================================================
 18202                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 18203                                  ;============================================================================
 18204                                  ; 08/10/2018 - Retro DOS v3.0
 18205                                  
 18206                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 18207                                  
 18208                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18209                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 18210                                  
 18211                                  ; ---------------------------------------------------------------------------
 18212                                  
 18213                                  ; MSDOS 6.0
 18214                                  ;***	Version - display DOS version
 18215                                  ;
 18216                                  ;	SYNTAX	ver [/debug]
 18217                                  ;
 18218                                  ;		/debug - display additional DOS configuration info
 18219                                  ;
 18220                                  ;	ENTRY	command-line tail is in PSP
 18221                                  ;
 18222                                  ;	EXIT	if successful, nothing
 18223                                  ;		if parse fails,
 18224                                  ;		  parse error message is set up (for Std_EPrintf)
 18225                                  ;		    AX = system parser error code
 18226                                  ;		    DX = ptr to message block
 18227                                  ;		  we jump to CError
 18228                                  ;
 18229                                  ;	EFFECTS
 18230                                  ;	  If parse fails, a parse error message is displayed.
 18231                                  ;	  Otherwise, version message is displayed.
 18232                                  ;	  If /debug is specified, additional DOS info is displayed.
 18233                                  
 18234                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18235                                  VERSION:
 18236                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 18237                                  
 18238                                  ;	Parse command line for /debug switch.
 18239                                  
 18240 00001D07 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 18241 00001D0A BF[AD85]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 18242 00001D0D 31C9                    	xor	cx,cx			; CX = # positional param's found
 18243 00001D0F E8A704                  	call	Parse_With_Msg
 18244                                  
 18245 00001D12 B301                    	mov	bl,1			; BL = flag = /debug present
 18246                                  	;cmp	ax,RESULT_NO_ERROR
 18247                                  	;cmp	ax,0
 18248                                  	;je	short verPrintVer	; something parsed - must be /debug
 18249 00001D14 09C0                    	or	ax,ax
 18250 00001D16 740C                    	jz	short verPrintVer 
 18251 00001D18 FECB                    	dec	bl			; BL = flag = no /debug present
 18252                                  	;cmp	ax,END_OF_LINE ; -1
 18253 00001D1A 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18254 00001D1D 7405                    	je	short verPrintVer	; reached end of line - ok
 18255                                  
 18256                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18257                                  %if 0
 18258                                  	je	short verPrintVer	; reached end of line - ok
 18259                                  %else
 18260 00001D1F 7414                    	je	short not_truever_sw
 18261                                  %endif
 18262                                  
 18263                                  ;	The parse failed. Error message has been set up.
 18264                                  
 18265 00001D21 E92E0C                  	jmp	cerror
 18266                                  
 18267                                  verPrintVer:
 18268                                  
 18269                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 18270                                  %if 1
 18271                                  check_t_switch:
 18272 00001D24 813E[7695][CD85]        	cmp	word [PARSE1_SYN],SLASH_T_SYN ; "/T" ; /t switch
 18273 00001D2A 7509                    	jne	short not_truever_sw
 18274 00001D2C BA[DF85]                	mov	dx,RD4CMD_VER_MSG
 18275 00001D2F B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9 ; print the message
 18276 00001D31 CD21                    	int	21h
 18277 00001D33 EB43                    	jmp	short verDone
 18278                                  not_truever_sw:
 18279                                  %endif
 18280 00001D35 53                      	push	bx			; save /debug flag
 18281 00001D36 E89808                  	call	CRLF2
 18282 00001D39 E83F00                  	call	PRINT_VERSION
 18283 00001D3C E89208                  	call	CRLF2
 18284 00001D3F 5B                      	pop	bx   			; BL = /debug flag
 18285 00001D40 08DB                    	or	bl,bl
 18286 00001D42 7434                    	jz	short verDone		; /debug is false - we're done
 18287                                  
 18288                                  ;*	For /debug, display DOS internal revision and DOS location
 18289                                  ;	(low memory, HMA, or ROM).
 18290                                  
 18291                                  ;	Bugbug:	use symbols for bitmasks below.
 18292                                  
 18293                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 18294 00001D44 B80633                  	mov	ax,3306h
 18295 00001D47 CD21                    	int	21h
 18296                                  		; DOS - 5+ Get TRUE Version Number
 18297                                  		; (BL major, BH minor, DL revision, DH flags)
 18298 00001D49 88D0                    	mov	al,dl			;revision number in dl; M013
 18299 00001D4B 88F7                    	mov	bh,dh			;flags in dh now; M013
 18300                                  ;M032	and	al,7			; AL = DOS internal revision
 18301 00001D4D 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18302                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18303 00001D4F 7602                    	jbe	short ver1
 18304 00001D51 B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18305                                  ;@@:
 18306                                  ver1:
 18307 00001D53 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18308 00001D55 A2[448C]                	mov	[One_Char_Val],al
 18309 00001D58 BA[6B81]                	mov	dx,dosrev_ptr
 18310 00001D5B E89130                  	call	std_printf		; print DOS internal revision
 18311                                  
 18312 00001D5E B104                    	mov	cl,4
 18313 00001D60 D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18314 00001D62 7209                    	jc	short verRom
 18315 00001D64 D0EF                    	shr	bh,1			; CY = DOS in HMA
 18316 00001D66 720A                    	jc	short verHma
 18317                                  
 18318                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18319                                  
 18320                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18321 00001D68 BA[7F81]                	mov	dx,DosLow_Ptr
 18322 00001D6B EB08                    	jmp	short verPrintLoc
 18323                                  verRom: 
 18324                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18325 00001D6D BA[7981]                	mov	dx,DosRom_Ptr
 18326 00001D70 EB03                    	jmp	short verPrintLoc
 18327                                  verHma: 
 18328                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18329 00001D72 BA[7C81]                	mov	dx,DosHma_Ptr
 18330                                  verPrintLoc:
 18331 00001D75 E87730                  	call	std_printf
 18332                                  verDone:
 18333 00001D78 E95608                  	jmp	CRLF2
 18334                                  
 18335                                  ; 21/02/2023
 18336                                  ;	; MSDOS 3.3
 18337                                  ;VERSION:
 18338                                  ;	call	CRLF2
 18339                                  ;	call	PRINT_VERSION
 18340                                  ;	jmp	CRLF2
 18341                                  
 18342                                  ; =============== S U B	R O U T	I N E =======================================
 18343                                  
 18344                                  	; 21/02/2023 - Retro DOS v4.0
 18345                                  PRINT_VERSION:
 18346                                  	;mov	ah,GET_VERSION ; 30h
 18347 00001D7B B430                    	mov	ah,30h
 18348 00001D7D CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18349                                  			; Return: AL = major version number (00h for DOS 1.x)
 18350 00001D7F 50                      	push	ax
 18351 00001D80 30E4                    	xor	ah,ah
 18352 00001D82 A3[408C]                	mov	[Major_Ver_Num],ax
 18353 00001D85 58                      	pop	ax
 18354 00001D86 86E0                    	xchg	ah,al
 18355 00001D88 30E4                    	xor	ah,ah
 18356 00001D8A A3[428C]                	mov	[Minor_Ver_Num],ax
 18357 00001D8D BA[FD7F]                	mov	dx,VerMes_Ptr
 18358 00001D90 E95C30                  	jmp	std_printf
 18359                                  
 18360                                  ; =============== S U B	R O U T	I N E =======================================
 18361                                  
 18362                                  	; 21/02/2023 - Retro DOS v4.0
 18363                                  PRINT_PROMPT:
 18364 00001D93 1E                      	push	ds
 18365 00001D94 0E                      	push	cs
 18366 00001D95 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 18367 00001D96 06                      	push	es
 18368 00001D97 E87805                  	call	find_prompt	; Look for prompt string
 18369 00001D9A 7206                    	jc	short PP0	; Can't find one
 18370 00001D9C 26803D00                	cmp	byte [es:di],0
 18371 00001DA0 7524                    	jnz	short PP1
 18372                                  PP0:				; Use default prompt
 18373 00001DA2 E86700                  	call	PRINT_DRIVE
 18374 00001DA5 B03E                    	mov	al,'>'
 18375                                  	;mov	al,SYM
 18376 00001DA7 E85300                  	call	PRINT_CHAR
 18377 00001DAA EB36                    	jmp	short PP5
 18378                                  ;PP1:
 18379                                  ;	mov	al,[es:di]	; Get a char
 18380                                  ;	inc	di
 18381                                  ;	or	al,al
 18382                                  ;	jz	short PP5	; Nul terminated
 18383                                  ;	; 21/02/2023
 18384                                  ;	cmp	al,'$' ; 24h
 18385                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18386                                  ;	jz	short PP2	; Nope
 18387                                  ;	call	PRINT_CHAR
 18388                                  ;	jmp	short PP1
 18389                                  PP2:
 18390 00001DAC 268A05                  	mov	al,[es:di]
 18391 00001DAF 47                      	inc	di
 18392                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18393 00001DB0 BB[8982]                	mov	bx,PROMPT_TABLE-3
 18394 00001DB3 08C0                    	or	al,al
 18395 00001DB5 742B                    	jz	short PP5
 18396                                  PP3:
 18397 00001DB7 83C303                  	add	bx,3
 18398                                  	; 21/02/2023
 18399 00001DBA E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18400                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18401 00001DBD 3A07                    	cmp	al,[bx]
 18402 00001DBF 7416                    	jz	short PP4
 18403 00001DC1 803F00                  	cmp	byte [bx],0
 18404 00001DC4 75F1                    	jnz	short PP3
 18405                                  	;jmp	short PP1
 18406                                  	; 21/02/2023
 18407                                  PP1:
 18408 00001DC6 268A05                  	mov	al,[es:di]	; Get a char
 18409 00001DC9 47                      	inc	di
 18410 00001DCA 08C0                    	or	al,al
 18411 00001DCC 7414                    	jz	short PP5	; Nul terminated
 18412                                  	; 21/02/2023
 18413 00001DCE 3C24                    	cmp	al,'$' ; 24h
 18414                                  	;cmp	al,[DOLLAR]	; Meta character
 18415 00001DD0 74DA                    	jz	short PP2	; Nope
 18416 00001DD2 E82800                  	call	PRINT_CHAR
 18417 00001DD5 EBEF                    	jmp	short PP1
 18418                                  PP4:
 18419 00001DD7 06                      	push	es
 18420 00001DD8 57                      	push	di
 18421 00001DD9 0E                      	push	cs
 18422 00001DDA 07                      	pop	es
 18423 00001DDB FF5701                  	call	word [bx+1]
 18424 00001DDE 5F                      	pop	di
 18425 00001DDF 07                      	pop	es
 18426 00001DE0 EBE4                    	jmp	short PP1
 18427                                  PP5:
 18428 00001DE2 07                      	pop	es		; Restore segments
 18429 00001DE3 1F                      	pop	ds
 18430 00001DE4 C3                      	retn
 18431                                  
 18432                                  ; ---------------------------------------------------------------------------
 18433                                  
 18434                                  PRINT_BACK:
 18435                                  	; 21/02/2023
 18436 00001DE5 BA[F780]                	mov	dx,dback_ptr
 18437 00001DE8 E90430                  	jmp	std_printf
 18438                                  
 18439                                  ; ---------------------------------------------------------------------------
 18440                                  
 18441                                  PRINT_EQ:
 18442 00001DEB B03D                    	mov	al,'='
 18443 00001DED EB0E                    	jmp	short PRINT_CHAR
 18444                                  
 18445                                  ; ---------------------------------------------------------------------------
 18446                                  
 18447                                  PRINT_ESC:
 18448 00001DEF B01B                    	mov	al,1Bh
 18449 00001DF1 EB0A                    	jmp	short PRINT_CHAR
 18450                                  
 18451                                  ; ---------------------------------------------------------------------------
 18452                                  
 18453                                  	; 21/02/2023
 18454                                  PRINT_G:
 18455                                  	;mov	al,[RABRACKET]
 18456 00001DF3 B03E                    	mov	al,'>' ; 3Eh
 18457 00001DF5 EB06                    	jmp	short PRINT_CHAR
 18458                                  
 18459                                  ; ---------------------------------------------------------------------------
 18460                                  
 18461                                  	; 21/02/2023
 18462                                  PRINT_L:
 18463                                  	;mov	al,[LABRACKET]
 18464 00001DF7 B03C                    	mov	al,'<' ; 3Ch
 18465 00001DF9 EB02                    	jmp	short PRINT_CHAR
 18466                                  
 18467                                  ; ---------------------------------------------------------------------------
 18468                                  
 18469                                  	; 21/02/2023
 18470                                  Print_B:
 18471                                  	;mov	al,[VBAR]
 18472 00001DFB B07C                    	mov	al,'|' ; 7Ch
 18473                                  
 18474                                  ; =============== S U B	R O U T	I N E =======================================
 18475                                  
 18476                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18477                                  PRINT_CHAR:
 18478                                  	; MSDOS 6.0
 18479                                  
 18480                                  ;	Bugbug:	Why bother with ds,es here?
 18481                                  		
 18482 00001DFD 06                      	push	es
 18483 00001DFE 1E                      	push	ds
 18484 00001DFF 07                      	pop	es
 18485 00001E00 57                      	push	di
 18486 00001E01 52                      	push	dx
 18487 00001E02 88C2                    	mov	dl,al		;AC000; Get char into al
 18488                                  	;mov	ah,STD_CON_OUTPUT
 18489                                  				;AC000; print the char to stdout
 18490 00001E04 B402                    	mov	ah,2
 18491 00001E06 CD21                    	int	21h		;AC000;
 18492 00001E08 5A                      	pop	dx
 18493 00001E09 5F                      	pop	di
 18494 00001E0A 07                      	pop	es
 18495 00001E0B C3                      	retn
 18496                                  
 18497                                  ;21/02/2023
 18498                                  %if 0
 18499                                  	; MSDOS 3.3
 18500                                  	push	es
 18501                                  	push	ds
 18502                                  	pop	es
 18503                                  	push	di
 18504                                  	push	dx
 18505                                  	mov	di,ONE_CHAR_VAL	
 18506                                  	stosb
 18507                                  	mov	dx,ONECHRVALPTR
 18508                                  	call	STD_PRINTF
 18509                                  	pop	dx
 18510                                  	pop	di
 18511                                  	pop	es
 18512                                  	retn
 18513                                  %endif
 18514                                  
 18515                                  ; ---------------------------------------------------------------------------
 18516                                  
 18517                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18518                                  PRINT_DRIVE:
 18519                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18520 00001E0C B419                    	mov	ah,19h
 18521 00001E0E CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18522 00001E10 0441                    	add	al,'A'
 18523                                  	;add	al,[CAPITAL_A]
 18524                                  	;call	PRINT_CHAR
 18525                                  	;retn
 18526                                  	; 21/02/2023
 18527 00001E12 EBE9                    	jmp	short PRINT_CHAR
 18528                                  
 18529                                  ; ---------------------------------------------------------------------------
 18530                                  
 18531                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18532                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18533                                  
 18534                                  build_dir_for_prompt:
 18535 00001E14 30D2                    	xor	dl,dl
 18536 00001E16 BE[CE8B]                	mov	si,BWDBUF
 18537 00001E19 89F7                    	mov	di,si
 18538 00001E1B A0[D98A]                	mov	al,[CURDRV]
 18539 00001E1E 0441                    	add	al,'A'
 18540 00001E20 B43A                    	mov	ah,':'
 18541 00001E22 AB                      	stosw
 18542 00001E23 A0[CA8A]                	mov	al,[DIRCHAR]
 18543 00001E26 AA                      	stosb
 18544 00001E27 87F7                    	xchg	si,di
 18545 00001E29 893E[358C]              	mov	[string_ptr_2],di
 18546                                  	;mov	ah,CURRENT_DIR ; 47h
 18547 00001E2D B447                    	mov	ah,47h
 18548 00001E2F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18549                                  			; DL = drive (0=default,1=A,etc.)
 18550                                  			; DS:SI	points to 64-byte buffer area
 18551                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18552 00001E31 BA[E280]                	mov	dx,string_buf_ptr
 18553 00001E34 7303                    	jnc	short doprint
 18554                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18555 00001E36 BA[AA7F]                	mov	dx,BADCURDRV
 18556                                  doprint:
 18557                                  	;call	std_printf
 18558                                  	;retn
 18559 00001E39 E9B32F                  	jmp	std_printf
 18560                                  
 18561                                  ; =============== S U B	R O U T	I N E =======================================
 18562                                  
 18563                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18564                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18565                                  
 18566                                  build_dir_for_chdir:
 18567 00001E3C E80D00                  	call	build_dir_string
 18568 00001E3F BA[CE8B]                	mov	dx,DIRBUF
 18569 00001E42 8916[358C]              	mov	[string_ptr_2],dx
 18570                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18571                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18572 00001E46 BA[E280]                	mov	dx,string_buf_ptr
 18573                                  	;call	std_printf
 18574                                  	;retn
 18575                                  	; 21/02/2023
 18576                                  	;jmp	short doprint
 18577 00001E49 E9A32F                  	jmp	std_printf
 18578                                  
 18579                                  ; =============== S U B	R O U T	I N E =======================================
 18580                                  
 18581                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18582                                  build_dir_string:
 18583 00001E4C 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18584 00001E50 88D0                    	mov	al,dl
 18585 00001E52 0440                    	add	al,'@'	; 40h
 18586 00001E54 3C40                    	cmp	al,'@'
 18587 00001E56 7506                    	jne	short gotdrive
 18588 00001E58 0206[D98A]              	add	al,[CURDRV]
 18589 00001E5C FEC0                    	inc	al
 18590                                  gotdrive:
 18591 00001E5E 50                      	push	ax
 18592 00001E5F BE[D18B]                	mov	si,BWDBUF+3
 18593                                  	;mov	ah,CURRENT_DIR ; 47h
 18594 00001E62 B447                    	mov	ah,47h
 18595 00001E64 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18596                                  			; DL = drive (0=default,1=A,etc.)
 18597                                  			; DS:SI	points to 64-byte buffer area
 18598 00001E66 7305                    	jnc	short dpbisok
 18599 00001E68 0E                      	push	cs
 18600 00001E69 1F                      	pop	ds
 18601 00001E6A E9ED09                  	jmp	DRVBAD
 18602                                  dpbisok:
 18603 00001E6D BF[CE8B]                	mov	di,BWDBUF
 18604 00001E70 89FA                    	mov	dx,di
 18605 00001E72 58                      	pop	ax
 18606 00001E73 B43A                    	mov	ah,':'
 18607 00001E75 AB                      	stosw
 18608 00001E76 A0[CA8A]                	mov	al,[DIRCHAR]
 18609 00001E79 AA                      	stosb
 18610 00001E7A C3                      	retn
 18611                                  
 18612                                  ; ---------------------------------------------------------------------------
 18613                                  
 18614                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18615                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18616                                  PATH:
 18617                                  	; MSDOS 6.0
 18618 00001E7B 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18619 00001E7D BF[F387]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18620 00001E80 AA                      	stosb				;AN049; Initialize PATH to null
 18621 00001E81 4F                      	dec	di			;AN049; point to the start of buffer
 18622 00001E82 E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 18623 00001E85 7460                    	jz	short disppath		; Print the current path
 18624                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18625 00001E87 3C3B                    	cmp	al,';' ; 3Bh
 18626 00001E89 7503                    	jne	short pathslp 		;AC049;
 18627 00001E8B 46                      	inc	si			;AN049; point past semicolon
 18628 00001E8C EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18629                                  pathslp:					; Get the user specified path
 18630 00001E8E AC                      	lodsb				; Get a character
 18631 00001E8F 3C0D                    	cmp	al,0Dh
 18632                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18633 00001E91 7434                    	je	short path_eol		;AC049; yes - end of command
 18634 00001E93 E82905                  	call	testkanj		;See if DBCS
 18635 00001E96 7405                    	jz	short notkanj2		;No - continue
 18636 00001E98 AA                      	stosb				;AC049; Yes - store the first byte
 18637 00001E99 AC                      	lodsb				;skip second byte of DBCS
 18638                                  path_hold:				;AN049;
 18639 00001E9A AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18640 00001E9B EBF1                    	jmp	short pathslp		;continue parsing
 18641                                  notkanj2:
 18642 00001E9D E84905                  	call	UPCONV			;upper case the character
 18643                                  
 18644 00001EA0 3C3B                    	cmp	al,';' ; 3Bh
 18645                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18646 00001EA2 74F6                    	je	short path_hold		;AC049; go store it
 18647 00001EA4 E83F07                  	call	DELIM			;delimiter?
 18648 00001EA7 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18649                                  scan_white:				;AN049; make sure were at EOL
 18650 00001EA9 AC                      	lodsb				;AN049; get a character
 18651 00001EAA 3C0D                    	cmp	al,0Dh
 18652                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18653 00001EAC 7419                    	je	short path_eol		;AN049; yes - go set path
 18654 00001EAE 3C20                    	cmp	al,' ' ; 20h
 18655                                  	;cmp	al,blank		;AN049; whitespace?
 18656 00001EB0 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18657                                  	;cmp	al,9
 18658 00001EB2 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18659 00001EB4 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18660                                  
 18661 00001EB6 BA[1B7F]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18662                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18663 00001EB9 C706[1B7F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18664                                  	;mov	byte [msg_disp_class],2		
 18665                                  					;AN049; set up parse error msg class
 18666 00001EBF C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class
 18667 00001EC4 E98B0A                  	jmp	cerror			;AN049;
 18668                                  path_eol:				;AN049; Parsing was clean
 18669 00001EC7 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18670 00001EC9 AA                      	stosb				;AN049;    buffer
 18671 00001ECA E84004                  	call	find_path		;AN049; Find PATH in environment
 18672 00001ECD E81404                  	call	delete_path		;AC049; Delete any offending name
 18673 00001ED0 E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 18674 00001ED3 E89A04                  	call	move_name		;AC049; move in PATH=
 18675 00001ED6 BE[F387]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18676                                  store_path:				;AN049; Store the PATH in the environment
 18677 00001ED9 AC                      	lodsb				;AN049; Get a character
 18678                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18679 00001EDA 20C0                    	and	al,al ; al=0 ?
 18680 00001EDC 7405                    	jz	short got_paths		;AN049; yes - exit
 18681 00001EDE E82A05                  	call	store_char		;AN049; no - store character
 18682 00001EE1 EBF6                    	jmp	short store_path	;AN049; continue
 18683                                  got_paths:				;AN049; we're finished
 18684 00001EE3 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18685 00001EE5 AB                      	stosw				;    	the environment
 18686 00001EE6 C3                      	retn
 18687                                  disppath:
 18688 00001EE7 E82304                  	call	find_path		;AN049;
 18689 00001EEA E80300                  	call	print_path
 18690                                  	;call	CRLF2
 18691                                  	;retn
 18692                                  	; 21/02/2023
 18693 00001EED E9E106                  	jmp	CRLF2
 18694                                  
 18695                                  ; 21/02/2023
 18696                                  %if 0
 18697                                  	; MSDOS 3.3
 18698                                  	call	FIND_PATH		; Find PATH in environment
 18699                                  	call	PGETARG			; Pre scan for arguments
 18700                                  	jz	short DISPPATH		; Print the current path
 18701                                  	call	DELETE_PATH		; Delete any offending name
 18702                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18703                                  	call	MOVE_NAME		; Move in PATH=
 18704                                  	call	PGETARG
 18705                                  	cmp	al,';'
 18706                                  	jz	short GOTPATHS
 18707                                  PATHSLP:
 18708                                  	lodsb
 18709                                  	cmp	al,0Dh			; End of line (CR) ?		
 18710                                  	jz	short GOTPATHS		; yes - exit
 18711                                  	;call	UPCONV	; MSDOS 6.0
 18712                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18713                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18714                                  	jz	short NOTDELIM		; go set path
 18715                                  	call	DELIM			; is it delim/null char ?
 18716                                  	jz	short GOTPATHS		; yes - exit
 18717                                  NOTDELIM:
 18718                                  	call	STORE_CHAR		; no - store character
 18719                                  	jmp	short PATHSLP
 18720                                  GOTPATHS:
 18721                                  	xor	ax,ax			; null terminate the PATH
 18722                                  	stosw				; in the environment
 18723                                  	retn
 18724                                  DISPPATH:
 18725                                  	call	PRINT_PATH
 18726                                  	call	CRLF2
 18727                                  	retn
 18728                                  %endif
 18729                                  
 18730                                  ; =============== S U B	R O U T	I N E =======================================
 18731                                  
 18732                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18733                                  print_path:
 18734 00001EF0 26803D00                	cmp	byte [es:di],0
 18735 00001EF4 750A                    	jnz	short path1
 18736                                  path0:
 18737 00001EF6 BA[7080]                	mov	dx,NULLPATH_PTR
 18738 00001EF9 0E                      	push	cs
 18739 00001EFA 07                      	pop	es
 18740 00001EFB 0E                      	push	cs
 18741 00001EFC 1F                      	pop	ds
 18742 00001EFD E9EF2E                  	jmp	std_printf
 18743                                  path1:
 18744 00001F00 06                      	push	es
 18745 00001F01 1F                      	pop	ds
 18746 00001F02 83EF05                  	sub	di,5
 18747 00001F05 89FE                    	mov	si,di
 18748 00001F07 E8AD04                  	call	SCASB2		; Look for null
 18749                                  	;cmp	cx,0FFh ; 255
 18750                                  	; 21/02/2023
 18751                                  	;ch = 0
 18752 00001F0A 80F9FF                  	cmp	cl,255
 18753 00001F0D 74E7                    	je	short path0
 18754 00001F0F 0E                      	push	cs
 18755 00001F10 07                      	pop	es
 18756 00001F11 BF[1A93]                	mov	di,Arg_Buf
 18757                                  	;mov	dx,100h ; 256
 18758                                  	;sub	dx,cx
 18759                                  	;xchg	dx,cx
 18760                                  	; 21/02/2023
 18761 00001F14 F6D9                    	neg	cl ; 256-cl
 18762 00001F16 F3A4                    	rep	movsb
 18763 00001F18 BA[B880]                	mov	dx,arg_buf_ptr
 18764 00001F1B 0E                      	push	cs
 18765 00001F1C 1F                      	pop	ds
 18766 00001F1D E9CF2E                  	jmp	std_printf
 18767                                  
 18768                                  ; ---------------------------------------------------------------------------
 18769                                  
 18770                                  ; ****************************************************************
 18771                                  ; *
 18772                                  ; * ROUTINE:	 CLS
 18773                                  ; *
 18774                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18775                                  ; *		 installed, send a control string to clear the
 18776                                  ; *		 screen.
 18777                                  ; *
 18778                                  ; * INPUT:	 command line at offset 81H
 18779                                  ; *
 18780                                  ; * OUTPUT:	 none
 18781                                  ; *
 18782                                  ; ****************************************************************
 18783                                  
 18784                                  	; MSDOS 6.0
 18785                                  
 18786                                  ANSI_installed	equ 0FFh
 18787                                  
 18788                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18789                                  CLS:
 18790                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18791                                  	;mov	ah,1Ah
 18792                                  	;mov	al,0			;AN000;
 18793 00001F20 B8001A                  	mov	ax,1A00h
 18794 00001F23 CD2F                    	int	2Fh			;AN000;
 18795                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18796                                  		; Return: AL = FFh if installed
 18797 00001F25 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18798 00001F27 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18799                                  
 18800                                  check_lines:
 18801                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18802 00001F29 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18803                                  	;mov	bx,stdout		;AN000; lines for stdout
 18804 00001F2C BB0100                  	mov	bx,1   ; handle
 18805                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18806                                  	;mov	ch,3   ; CON device	
 18807                                  	;;mov	cl,get_generic		;AN000; get information
 18808                                  	;mov	cl,7Fh ; minor function, get display info
 18809                                  	; 25/04/2023
 18810 00001F2F B97F03                  	mov	cx,037Fh
 18811 00001F32 BA[8B8D]                	mov	dx,Display_Ioctl	;AN000;
 18812 00001F35 CD21                    	int	21h			;AN000;
 18813 00001F37 720A                    	jc	short no_variable	;AN000; function had error, use default
 18814                                  		; 21/02/2023
 18815                                  		; ds:dx = parameter block
 18816                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18817                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18818                                  		;   	 01h  byte  reserved
 18819                                  		;   	 02h  word  length of following data
 18820                                  		;   	 04h  word  control flags
 18821                                  		;	       bit 0 set for blink, clear for intensity
 18822                                  		;	       bits 1 to 15 reserved
 18823                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18824                                  		;   	 07h  byte  reserved
 18825                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18826                                  		;   	 0Ah  word  pixel columns
 18827                                  		;   	 0Ch  word  pixel rows
 18828                                  		;   	 0Eh  word  character columns
 18829                                  		;   	 10h  word  character rows
 18830                                  	
 18831                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18832                                  	;				;AN000; get number of rows returned
 18833                                  	;mov	dh,al			;AN000; set number of rows
 18834                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18835                                  	;				;AN000; get number of columns returned
 18836                                  	;mov	dl,al			;AN000; set number of columns
 18837                                  	; 21/02/2023
 18838 00001F39 8A16[998D]              	mov	dl,[display_width]
 18839 00001F3D 8A36[9B8D]              	mov	dh,[LinPerPag]
 18840 00001F41 EB3B                    	jmp	short regcls		;AN000; go do cls
 18841                                  
 18842                                  no_variable:
 18843                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18844                                  	;mov	bx,1
 18845                                  	; bx = 1
 18846                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18847 00001F43 B80044                  	mov	ax,4400h
 18848 00001F46 CD21                    	int	21h			;AC000;
 18849 00001F48 F6C280                  	test	dl,80h
 18850                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18851 00001F4B 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18852 00001F4D F6C210                  	test	dl,10h
 18853                                  	;test	dl,devid_SPECIAL	;AC000;
 18854 00001F50 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18855                                  
 18856                                  ansicls:
 18857 00001F52 E85200                  	call	ansi_cls		;AN000; clear the screen
 18858 00001F55 EB2C                    	jmp	short cls_ret		;AN000; exit
 18859                                  
 18860                                  ; Get video mode
 18861                                  
 18862                                  cls_normal:				;AC000;
 18863                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18864 00001F57 B40F                    	mov	ah,0Fh
 18865                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18866 00001F59 CD10                    	int	10h
 18867 00001F5B 3C03                    	cmp	al,3
 18868                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18869 00001F5D 760A                    	jbe	short DoAlpha
 18870 00001F5F 3C07                    	cmp	al,7
 18871                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18872 00001F61 7406                    	je	short DoAlpha
 18873                                  
 18874                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18875                                  ; be just as bogus and set the mode that we just got. This will blank the
 18876                                  ; screen too.
 18877                                  
 18878                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18879 00001F63 B400                    	mov	ah,0
 18880                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18881 00001F65 CD10                    	int	10h
 18882 00001F67 EB1A                    	jmp	short cls_ret		;AC000; exit
 18883                                  
 18884                                  DoAlpha:
 18885                                  
 18886                                  ; Get video mode and number of columns to scroll
 18887                                  
 18888                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18889                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18890                                  ;M01   area
 18891                                  ;M01   Commented out code here is the original
 18892                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18893                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18894                                  ;M01	mov	dl,ah
 18895                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18896                                  
 18897                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18898                                  
 18899 00001F69 1E                      	push	ds
 18900                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18901 00001F6A B84000                  	mov	ax,40h
 18902 00001F6D 8ED8                    	mov	ds,ax			;  *			M01
 18903                                  
 18904                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18905 00001F6F 8A164A00                	mov	dl,[4Ah]
 18906                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18907 00001F73 8A368400                	mov	dh,[84h]
 18908 00001F77 1F                      	pop	ds			;			M01
 18909                                  
 18910 00001F78 08F6                    	or	dh,dh			; Q:ZERO		M01
 18911 00001F7A 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18912                                  
 18913                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18914                                  	; 25/04/2023
 18915 00001F7C B619                    	mov	dh,25
 18916                                  regcls:
 18917 00001F7E FEC6                    	inc	dh			; height+1		M018
 18918 00001F80 E80100                  	call	reg_cls 		; go clear the screen
 18919                                  cls_ret:
 18920 00001F83 C3                      	retn				; exit
 18921                                  
 18922                                  ; ---------------------------------------------------------------------------
 18923                                  
 18924                                  ; 21/02/2023
 18925                                  %if 0
 18926                                  	; MSDOS 3.3
 18927                                  CLS:
 18928                                  	mov	bx,STDOUT ; 1
 18929                                  	mov	ax,IOCTL*256 ; 4400h
 18930                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18931                                  			; BX = file or device handle
 18932                                  	test	dl,80h	; devid_ISDEV
 18933                                  	jz	short ANSICLS	; If a file put out ANSI
 18934                                  	test	dl,10h  ; devid_SPECIAL
 18935                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18936                                  
 18937                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18938                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18939                                  			; AL = interrupt number
 18940                                  			; Return: ES:BX	= value	of interrupt vector
 18941                                  	mov	dx,es
 18942                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18943                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18944                                  			; AL = interrupt number
 18945                                  			; Return: ES:BX	= value	of interrupt vector
 18946                                  	mov	ax,es
 18947                                  	cmp	dx,ax	; If not default driver, do ANSI
 18948                                  	ja	short ANSICLS
 18949                                  
 18950                                  	mov	ah,0Fh
 18951                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18952                                  			; Return: AH = number of columns on screen
 18953                                  			; AL = current video mode
 18954                                  			; BH = current active display page
 18955                                  	cmp	al,3
 18956                                  	jbe	short DOALPHA
 18957                                  	cmp	al,7
 18958                                  	jz	short DOALPHA
 18959                                  	mov	ah,0
 18960                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18961                                  			; AL = mode
 18962                                  	retn
 18963                                  
 18964                                  DOALPHA:
 18965                                  	mov	ah,0Bh	; Set overscan to black
 18966                                  	xor	bx,bx
 18967                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18968                                  			; BH = 00h, BL = border color
 18969                                  			; BH = 01h, BL = palette (0-3)
 18970                                  	mov	ah,0Fh
 18971                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18972                                  			; Return: AH = number of columns on screen
 18973                                  			; AL = current video mode
 18974                                  			; BH = current active display page
 18975                                  	mov	dl,ah
 18976                                  	dec	dl
 18977                                  	mov	dh,24
 18978                                  	xor	ax,ax
 18979                                  	mov	cx,ax
 18980                                  	mov	bx,700h
 18981                                  	mov	ah,6
 18982                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 18983                                  			; AL = number of lines to scroll window	
 18984                                  			;	(0 = blank whole window)
 18985                                  			; BH = attributes to be	used on	blanked	lines
 18986                                  			; CH,CL	= row,column of	upper left corner of window 
 18987                                  			;	  to scroll
 18988                                  			; DH,DL	= row,column of	lower right corner of window
 18989                                  	xor	dx,dx
 18990                                  	mov	bh,0
 18991                                  	mov	ah,2
 18992                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 18993                                  			; DH,DL	= row,column (0,0 = upper left)
 18994                                  			; BH = page number
 18995                                  	retn
 18996                                  
 18997                                  ANSICLS:
 18998                                  	mov	si,CLSSTRING
 18999                                  	lodsb
 19000                                  	mov	cl,al
 19001                                  	xor	ch,ch
 19002                                  	mov	ah,RAW_CON_IO ; 6
 19003                                  CLRLOOP:
 19004                                  	lodsb
 19005                                  	mov	dl,al
 19006                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 19007                                  			; DL = character <> FFh
 19008                                  			;  Return: ZF set = no character
 19009                                  			;   ZF clear = character recieved, AL = character
 19010                                  	loop	CLRLOOP
 19011                                  	retn
 19012                                  %endif
 19013                                  
 19014                                  ; ---------------------------------------------------------------------------
 19015                                  
 19016                                  ; MSDOS 6.0
 19017                                  
 19018                                  ; ****************************************************************
 19019                                  ; *
 19020                                  ; * ROUTINE:	 REG_CLS
 19021                                  ; *
 19022                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 19023                                  ; *
 19024                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 19025                                  ; *		 DH = NUMBER OF ROWS
 19026                                  ; *
 19027                                  ; * OUTPUT:	 none
 19028                                  ; *
 19029                                  ; ****************************************************************
 19030                                  
 19031                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19032                                  reg_cls:
 19033                                  ; Set overscan to black.
 19034                                  
 19035 00001F84 FECE                    	dec	dh			; decrement rows and columns
 19036 00001F86 FECA                    	dec	dl			;  to zero base
 19037 00001F88 52                      	push	dx			; save rows,columns
 19038                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 19039 00001F89 B40B                    	mov	ah,0Bh
 19040 00001F8B 31DB                    	xor	bx,bx
 19041                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19042 00001F8D CD10                    	int	10h
 19043 00001F8F 5A                      	pop	dx			;  restore rows,colums
 19044                                  
 19045 00001F90 31C0                    	xor	ax,ax			; zero out ax
 19046 00001F92 89C1                    	mov	cx,ax			;  and cx
 19047                                  
 19048                                  ; Scroll active page
 19049                                  
 19050                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 19051 00001F94 B406                    	mov	ah,6
 19052                                  	;mov	bh,video_attribute	; attribute for blank line
 19053 00001F96 B707                    	mov	bh,7
 19054 00001F98 30DB                    	xor	bl,bl			; set BL to 0
 19055                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19056 00001F9A CD10                    	int	10h
 19057                                  
 19058                                  ; Seek to cursor to 0,0
 19059                                  
 19060                                  ;M022 following two lines added
 19061                                  	;mov	ah,get_video_state	; get current video page in BH
 19062 00001F9C B40F                    	mov	ah,0Fh
 19063                                  	;int	video_io_int
 19064 00001F9E CD10                    	int	10h
 19065                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 19066 00001FA0 B402                    	mov	ah,2
 19067 00001FA2 31D2                    	xor	dx,dx			; row and column 0
 19068                                  ;M022	mov	bh,0
 19069                                  	;int	video_io_int		; do into 10h - BIOS video IO
 19070 00001FA4 CD10                    	int	10h
 19071                                  
 19072 00001FA6 C3                      	retn
 19073                                  
 19074                                  ; ---------------------------------------------------------------------------
 19075                                  
 19076                                  ; MSDOS 6.0
 19077                                  
 19078                                  ; ****************************************************************
 19079                                  ; *
 19080                                  ; * ROUTINE:	 ANSI_CLS
 19081                                  ; *
 19082                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 19083                                  ; *		 to STDOUT.
 19084                                  ; *
 19085                                  ; * INPUT:	 none
 19086                                  ; *
 19087                                  ; * OUTPUT:	 none
 19088                                  ; *
 19089                                  ; ****************************************************************
 19090                                  
 19091                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19092                                  ansi_cls:			;AC000;
 19093 00001FA7 BE[8782]                	mov	si,CLSSTRING
 19094                                  			; db 4,1Bh,'[2J'
 19095 00001FAA AC                      	lodsb
 19096 00001FAB 88C1                    	mov	cl,al	; al = 4
 19097 00001FAD 30ED                    	xor	ch,ch
 19098                                  	;mov	ah,Raw_CON_IO
 19099 00001FAF B406                    	mov	ah,6
 19100                                  clrloop:
 19101 00001FB1 AC                      	lodsb
 19102 00001FB2 88C2                    	mov	dl,al
 19103 00001FB4 CD21                    	int	21h
 19104                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 19105 00001FB6 E2F9                    	loop	clrloop
 19106 00001FB8 C3                      	retn
 19107                                  
 19108                                  ;============================================================================
 19109                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 19110                                  ;============================================================================
 19111                                  ; 08/10/2018 - Retro DOS v3.0
 19112                                  
 19113                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 19114                                  
 19115                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19116                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 19117                                  
 19118                                  ; ---------------------------------------------------------------------------
 19119                                  
 19120                                  ; ****************************************************************
 19121                                  ; *
 19122                                  ; * ROUTINE:	 CTTY - Change console
 19123                                  ; *
 19124                                  ; * SYNTAX:	 CTTY device
 19125                                  ; *
 19126                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 19127                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 19128                                  ; *		 STDERR. This routine returns to LODCOM1.
 19129                                  ; *
 19130                                  ; * INPUT:	 command line at offset 81H
 19131                                  ; *
 19132                                  ; * OUTPUT:	 none
 19133                                  ; *
 19134                                  ; ****************************************************************
 19135                                  
 19136                                  	; 21/02/2023 - Retro DOS v4.0
 19137                                  	; 10/06/2023
 19138                                  CTTY:
 19139                                  	; MSDOS 6.0
 19140 00001FB9 1E                      	push	ds			;AN000; Get local ES
 19141 00001FBA 07                      	pop	es			;AN000;
 19142 00001FBB BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 19143 00001FBE BF[9B85]                	mov	di,PARSE_CTTY
 19144                                  					;AC000; Get address of PARSE_CTTY
 19145 00001FC1 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 19146 00001FC3 31D2                    	xor	dx,dx			;AC000;
 19147 00001FC5 E85623                  	call	cmd_parse		;AC000; call parser
 19148                                  
 19149                                  	;cmp	ax,-1 ; 0FFFFh
 19150                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19151                                  	;je	short ctty_error	;AN000; yes - error
 19152                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 19153                                  	;and	ax,ax ; ax > 0 ?
 19154                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 19155                                  	; 10/06/2023
 19156 00001FC8 40                      	inc	ax  ; cmp ax,-1
 19157 00001FC9 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 19158 00001FCB 48                      	dec	ax  ; cmp ax,0
 19159 00001FCC 7531                    	jnz	short ctty_error  ; 1 -> 0
 19160                                  	; ax = 0
 19161                                  
 19162 00001FCE 56                      	push	si			;AN000; save position in line
 19163 00001FCF C536[7895]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19164 00001FD3 BF[B48C]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 19165                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 19166 00001FD6 AC                      	lodsb				;AN000; get a char from buffer
 19167 00001FD7 AA                      	stosb				;AN000; store in srcbuf
 19168                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 19169 00001FD8 08C0                    	or	al,al ; al = 0 ?
 19170 00001FDA 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 19171                                  					;AN000; no - keep moving
 19172 00001FDC 5E                      	pop	si			;AN000; get line position back
 19173 00001FDD BF[9B85]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 19174 00001FE0 E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 19175                                  	;jz	short nocolon 		;AN000; yes - continue
 19176                                  	; 21/02/2023
 19177 00001FE3 751A                    	jnz	short ctty_error
 19178                                  ;ctty_error:
 19179                                  	;jmp	short isbaddev		;AC000; yes - exit
 19180                                  
 19181                                  	; 21/02/2023
 19182                                  	; MSDOS 3.3
 19183                                  	;call	SETPATH
 19184                                  	;dec	si
 19185                                  	;dec	si
 19186                                  	;cmp	byte [si],':'
 19187                                  	;jnz	short NOCOLON
 19188                                  	;mov	byte [si],0
 19189                                  nocolon:
 19190                                  	; 21/02/2023
 19191                                  	; MSDOS 6.0
 19192 00001FE5 BA[B48C]                	mov	dx,SrcBuf
 19193                                  ;NOCOLON:
 19194                                  	; MSDOS 3.3 & MSDOS 6.0
 19195                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 19196                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 19197 00001FE8 B8023D                  	mov	ax,3D02h ; 21/02/2023
 19198 00001FEB CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 19199                                  			; DS:DX	-> ASCIZ filename
 19200                                  			; AL = access mode
 19201                                  			; 2 - read & write
 19202 00001FED 7210                    	jc	short isbaddev
 19203 00001FEF 89C3                    	mov	bx,ax
 19204                                  	;mov	ax,IOCTL*256 ; 4400h
 19205 00001FF1 B80044                  	mov	ax,4400h
 19206 00001FF4 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 19207                                  			; BX = file or device handle
 19208 00001FF6 F6C280                  	test	dl,80h
 19209 00001FF9 750C                    	jnz	short devisok
 19210                                  closedev:
 19211                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 19212 00001FFB B43E                    	mov	ah,3Eh
 19213 00001FFD CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19214                                  			; BX = file handle
 19215                                  ctty_error:
 19216                                  isbaddev:
 19217 00001FFF BA[7680]                	mov	dx,BADDEV_PTR
 19218 00002002 E8EA2D                  	call	std_printf
 19219 00002005 EB40                    	jmp	short resret
 19220                                  
 19221                                  	;nop
 19222                                  devisok:
 19223                                  	; 21/02/2023
 19224                                  	; MSDOS 6.0
 19225 00002007 52                      	push	dx		;AN007; save device info
 19226                                  	; 08/06/2023 (BugFix)
 19227 00002008 A1[FA80]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 19228                                  	;mov	dh,util_msg_class
 19229 0000200B B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 19230 0000200D 53                      	push	bx		;AN021; save handle
 19231 0000200E E8C32E                  	call	TSYSGETMSG	;AN021; get the address of the message
 19232 00002011 89F2                    	mov	dx,si		;AN021; get address into dx
 19233                                  	;mov	ax,(Write shl 8)
 19234 00002013 B80040                  	mov	ax,4000h	;AN007; write to device
 19235 00002016 B90200                  	mov	cx,2		;AN007; write two bytes
 19236 00002019 CD21                    	int	21h		;AN007;
 19237 0000201B 5B                      	pop	bx		;AN021; get back handle
 19238 0000201C 5A                      	pop	dx		;AN007; get back device info
 19239 0000201D 72DC                    	jc	short closedev	;AN007; if error, quit
 19240                                  
 19241                                  	; MSDOS 3.3 & MSDOS 6.0
 19242 0000201F 30F6                    	xor	dh,dh
 19243 00002021 80CA03                  	or	dl,3
 19244                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 19245                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 19246 00002024 B80144                  	mov	ax,4401h
 19247 00002027 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 19248                                  			; BX = device handle,DH = 0
 19249                                  			; DL = device information to set 
 19250                                  			;	(bits 0-7 from	function 0)
 19251 00002029 53                      	push	bx
 19252 0000202A B90300                  	mov	cx,3
 19253 0000202D 31DB                    	xor	bx,bx
 19254                                  iclloop:			; Close basic handles
 19255                                  	;mov	ah,CLOSE ; 3Eh
 19256 0000202F B43E                    	mov	ah,3Eh
 19257 00002031 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19258                                  			; BX = file handle
 19259 00002033 43                      	inc	bx
 19260 00002034 E2F9                    	loop	iclloop
 19261 00002036 5B                      	pop	bx		; Get handle
 19262                                  	;mov	ah,XDUP ; 45h
 19263 00002037 B445                    	mov	ah,45h
 19264 00002039 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19265                                  			; BX = file handle to duplicate
 19266                                  	;mov	ah,XDUP ; 45h
 19267 0000203B B445                    	mov	ah,45h
 19268 0000203D CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19269                                  			; BX = file handle to duplicate
 19270                                  	;mov	ah,XDUP ; 45h
 19271 0000203F B445                    	mov	ah,45h
 19272 00002041 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19273                                  			; BX = file handle to duplicate
 19274                                  	;mov	ah,CLOSE ; 3Eh
 19275 00002043 B43E                    	mov	ah,3Eh
 19276 00002045 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19277                                  			; BX = file handle
 19278                                  resret:
 19279 00002047 8E1E[C58A]              	mov	ds,[RESSEG]
 19280 0000204B 1E                      	push	ds
 19281                                  	;mov	ax,[18h]
 19282 0000204C A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 19283 0000204F A3[8A01]                	mov	[Io_Save],ax
 19284                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 19285                                  	;;mov	ax,LODCOM1
 19286                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 19287                                  	;mov	ax,175h ; MSDOS 6.0
 19288 00002052 B8[7400]                	mov	ax,TrnLodCom1_Trap
 19289 00002055 50                      	push	ax
 19290                                  
 19291 00002056 CB                      	retf		; Far return
 19292                                  
 19293                                  ; ---------------------------------------------------------------------------
 19294                                  
 19295                                  ;****************************************************************
 19296                                  ;*
 19297                                  ;* ROUTINE:	CHCP - Change code page internal command
 19298                                  ;*		(added DOS 3.30 07/21/86)
 19299                                  ;*
 19300                                  ;* SYNTAX:	CHCP [xxx]
 19301                                  ;*		where xxx is a valid code page
 19302                                  ;*
 19303                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 19304                                  ;*		6402H to set the code page to xxxx. If no parameters
 19305                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19306                                  ;*		to get global code page and display it to the user.
 19307                                  ;*
 19308                                  ;* INPUT:	command line at offset 81H
 19309                                  ;*
 19310                                  ;* OUTPUT:	none
 19311                                  ;*
 19312                                  ;****************************************************************
 19313                                  
 19314                                  NLSFUNC_installed equ  0FFh
 19315                                  set_global_cp	  equ  2
 19316                                  get_global_cp	  equ  1
 19317                                  
 19318                                  	; 21/02/2023 - Retro DOS v4.0
 19319                                  	; 09/06/2023
 19320                                  	; 10/06/2023
 19321                                  CHCP:
 19322                                  	; MSDOS 6.0
 19323 00002057 1E                      	push	ds		;AN000; Get local ES
 19324 00002058 07                      	pop	es		;AN000;
 19325 00002059 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19326 0000205C BF[B284]                	mov	di,PARSE_CHCP
 19327                                  				;AN000; Get address of PARSE_CHCP
 19328 0000205F 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19329 00002061 31D2                    	xor	dx,dx		;AC000;
 19330 00002063 E85301                  	call    Parse_With_Msg	;AC018; call parser
 19331                                  
 19332                                  	;cmp	ax,-1
 19333                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19334                                  	;;jne	short setcp	;AC000; no go get number & set code page
 19335                                  	;je	short getcp	;AC000; yes - no parm - get code page
 19336                                  ;setcp:
 19337                                  	;;cmp	ax,0
 19338                                  	;;cmp	ax,RESULT_NO_ERROR
 19339                                  	;			;AN000; did we have an error?
 19340                                  	;;jne	short cp_error	;AC018; yes - go issue message
 19341                                  	;and	ax,ax ; ax > 0 ?
 19342                                  	;jnz	short cp_error	
 19343                                  	; 10/06/2023
 19344 00002066 40                      	inc	ax  ; cmp ax,-1	
 19345 00002067 745C                    	jz	short getcp ; 0FFFFh -> 0
 19346 00002069 48                      	dec	ax  ; cmp ax,0
 19347 0000206A 7556                    	jnz	short cp_error ; 1 -> 0
 19348                                  	; ax = 0
 19349                                  
 19350                                  	;;push	cx		;AN000; save positional count
 19351                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 19352                                  	;;mov	cx,[bx]		;AN000;  into cx
 19353                                  	;;mov	[system_cpage],cx
 19354                                  	;			;AN000; save user input number
 19355                                  	;;pop	cx		;AC000; restore positional count
 19356                                  	;; 21/02/2023
 19357                                  	;mov	di,[bx]
 19358                                  	;mov	[system_cpage],di
 19359                                  	; 09/06/2023	
 19360 0000206C 8B1E[7895]              	mov	bx,[PARSE1_ADDR]
 19361 00002070 891E[2F8C]              	mov	[system_cpage],bx
 19362                                  	;
 19363 00002074 BF[B284]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19364 00002077 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 19365 0000207A 7546                    	jnz	short cp_error	;AC000; no - exit
 19366                                  okset:
 19367                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19368                                  	;mov	ah,14h
 19369                                  	;mov	al,0		;AN000;
 19370 0000207C B80014                  	mov	ax,1400h
 19371 0000207F CD2F                    	int	2Fh		;AN000;
 19372                                  	;cmp	al,0FFh
 19373 00002081 3CFF                    	cmp	al,NLSFUNC_installed
 19374                                  				;AN000;
 19375 00002083 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19376 00002085 BA[A47F]                	mov	dx,NLSFUNC_PTR
 19377                                  				;AN000; no - set up error message
 19378 00002088 EB38                    	jmp	short cp_error	;AN000; error exit
 19379                                  
 19380                                  ; 21/02/2023
 19381                                  %if 0
 19382                                  	; MSDOS 3.3
 19383                                  	mov	si,81h
 19384                                  	call	SCANOFF
 19385                                  	cmp	al,0Dh ; CR
 19386                                  	jnz	short SETCP
 19387                                  	jmp	short GETCP
 19388                                  
 19389                                  	;nop
 19390                                  SETCP:
 19391                                  	xor	bx,bx
 19392                                  	mov	cx,bx
 19393                                  	mov	ax,bx
 19394                                  GET_CP_DIGIT:
 19395                                  	lodsb
 19396                                  	cmp	al,'0'
 19397                                  	jb	short CHRNOTNUMBER
 19398                                  	cmp	al,'9'
 19399                                  	ja	short CHRNOTNUMBER
 19400                                  	sub	al,'0'
 19401                                  	inc	cl
 19402                                  	cmp	cl,4
 19403                                  	ja	short CHCP_BADPARM
 19404                                  	mov	dx,bx
 19405                                  	shl	dx,1
 19406                                  	shl	dx,1
 19407                                  	add	bx,dx
 19408                                  	shl	bx,1
 19409                                  	add	bx,ax
 19410                                  	jmp	short GET_CP_DIGIT
 19411                                  CP_NEXTCHR:
 19412                                  	lodsb
 19413                                  CHRNOTNUMBER:
 19414                                  	cmp	al,' '		; SPACE
 19415                                  	jz	short CP_NEXTCHR
 19416                                  	cmp	al,9		; TAB
 19417                                  	jz	short CP_NEXTCHR
 19418                                  	cmp	al,0Dh		; CR
 19419                                  	jz	short SET_CP_TBL_NUM
 19420                                  CHCP_BADPARM:
 19421                                  	mov	dx,BADPARMPTR
 19422                                  	jmp	CERROR
 19423                                  ;GOT_NLS:
 19424                                  %endif
 19425                                  	; 21/02/2023
 19426                                  got_NLS:
 19427                                  	; MSDOS 6.0
 19428 0000208A 8B1E[2F8C]              	mov	bx,[system_cpage]
 19429                                  				;AN000; get user input code page
 19430                                  ;SET_CP_TBL_NUM:
 19431                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19432                                  	;
 19433                                  	; MSDOS 3.3 & MSDOS 6.0
 19434                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19435                                  	;mov	ah,66h
 19436                                  	;;mov	al,set_global_cp 
 19437                                  	;mov	al,2		;minor - set
 19438                                  	; 26/04/2023
 19439 0000208E B80266                  	mov	ax,6602h
 19440 00002091 CD21                    	int	21h
 19441                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19442                                  		; BX = active code page
 19443                                  		; DX = system code page (active page at boot time)
 19444                                  
 19445 00002093 733F                    	jnc	short chcp_return
 19446                                  				;no error - exit
 19447                                  
 19448 00002095 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19449 00002098 7515                    	jnz	short chcp_other_error
 19450                                  
 19451                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19452 0000209A B459                    	mov	ah,59h
 19453 0000209C 31DB                    	xor	bx,bx
 19454 0000209E CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19455                                  			; BX = version code (0000h for DOS 3.x)
 19456                                  
 19457 000020A0 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19458 000020A3 7505                    	jne	short no_countrysys ; 26/04/2023
 19459                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19460 000020A5 BA[A77F]                	mov	dx,INV_CODE_PAGE
 19461                                  	;jmp	cerror
 19462 000020A8 EB18                    	jmp	short cp_error
 19463                                  
 19464                                  	; 21/02/2023
 19465                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19466                                  no_countrysys:
 19467                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19468                                  ;					;AN000; set up extended error msg class
 19469                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19470                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19471                                  					;AN000; get message number in control block
 19472 000020AA BA[8881]                	mov	dx,NoCntry_Ptr
 19473 000020AD EB13                    	jmp	short cp_error
 19474                                  
 19475                                  chcp_other_error:		; end of p716
 19476                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19477 000020AF B459                    	mov	ah,59h
 19478 000020B1 31DB                    	xor	bx,bx
 19479 000020B3 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19480                                  			; BX = version code (0000h for DOS 3.x)
 19481 000020B5 83F841                  	cmp	ax,65		;was it access denied?
 19482 000020B8 7505                    	jne	short none_set	;no - assume all failed
 19483 000020BA BA[887F]                	mov	dx,cp_not_all_ptr
 19484                                  				;set up message
 19485                                  	;jmp	cerror		;AC000; error exit
 19486 000020BD EB03                    	jmp     short cp_error
 19487                                  none_set:
 19488 000020BF BA[7A7F]                	mov	dx,cp_not_set_ptr
 19489                                  				;set up message
 19490                                  cp_error:
 19491 000020C2 E98D08                  	jmp	cerror		;exit
 19492                                  getcp:
 19493                                  	;;mov	ah,GETSETCDPG ; 66h
 19494                                  	;mov	ah,66h		;get/set global code page function	
 19495                                  	;;mov	al,get_global_cp ; 1
 19496                                  	;mov	al,1		;minor - get
 19497                                  	; 26/04/2023
 19498 000020C5 B80166                  	mov	ax,6601h
 19499 000020C8 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19500 000020CA 891E[2F8C]              	mov	[system_cpage],bx
 19501                                  				;get active cp for output
 19502 000020CE BA[967F]                	mov	dx,cp_active_ptr
 19503 000020D1 E81B2D                  	call	std_printf	;print it out
 19504                                  chcp_return:
 19505 000020D4 C3                      	retn
 19506                                  
 19507                                  ; ---------------------------------------------------------------------------
 19508                                  
 19509                                  ; ****************************************************************
 19510                                  ; *
 19511                                  ; * ROUTINE:	 TRUENAME
 19512                                  ; *
 19513                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19514                                  ; *		 Parses the command line. If a path is found, set
 19515                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19516                                  ; *		 set SRCXNAME to the drive letter. If no path
 19517                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19518                                  ; *		 current directory. Use the NAME TRANSLATE system
 19519                                  ; *		 call to get the real name and  then display the 
 19520                                  ; *		 real name. If an error occurs issue an error
 19521                                  ; *		 message and transfer control to  CERROR.
 19522                                  ; *
 19523                                  ; * INPUT:	 command line at offset 81H
 19524                                  ; *
 19525                                  ; * OUTPUT:	 none
 19526                                  ; *
 19527                                  ; ****************************************************************
 19528                                  
 19529                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19530                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19531                                  	; 10/06/2023
 19532                                  TRUENAME:				;AN000; TRUENAME entry point
 19533 000020D5 1E                      	push	ds			;AN000; Get local ES
 19534 000020D6 07                      	pop	es			;AN000;
 19535 000020D7 BE8100                  	mov	si,81h			;AN000; Get command line
 19536 000020DA BF[1085]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19537 000020DD 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19538 000020DF 31D2                    	xor	dx,dx			;AN000;
 19539 000020E1 E8D500                  	call	Parse_With_Msg		;AC018; call parser
 19540                                  
 19541 000020E4 BF[F387]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19542                                  	;cmp	ax,0FFFFh
 19543                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19544                                  	;je	short tn_eol		;AN000; yes - go process
 19545                                  	;; 22/02/2023
 19546                                  	;;cmp	ax,0
 19547                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19548                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 19549                                  	;and	ax,ax ; ax = 0 ?
 19550                                  	;jnz	short tn_parse_error ; no, parse error
 19551                                  	; 10/06/2023
 19552 000020E7 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 19553 000020E8 7433                    	jz	short tn_eol ; ah = 0 ; *
 19554 000020EA 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 19555 000020EB 752D                    	jnz	short tn_parse_error
 19556                                  
 19557                                  	;cmp	byte [PARSE1_TYPE],6
 19558 000020ED 803E[7495]06            	cmp	byte [PARSE1_TYPE],result_drive
 19559                                  					;AN000; was a drive entered?
 19560                                  	;je	short tn_drive		;AN000; yes - go process
 19561                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19562                                  	; 23/02/2023
 19563 000020F2 7512                    	jne	short tn_filespec
 19564                                  
 19565                                  ;tn_eol: 
 19566                                  ;	;mov	ah,0			;AN000; no parameters on line
 19567                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19568                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19569                                  ;	mov	al,'.'
 19570                                  ;	stosw				;AN000; store in srcxname
 19571                                  ;	jmp	short tn_doit		;AN000; go do command
 19572                                  
 19573                                  tn_drive:				;AN000; a drive was entered
 19574 000020F4 56                      	push	si			;AN000; save position in line
 19575 000020F5 BE[7895]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19576 000020F8 AC                      	lodsb				;AN000; get the drive number
 19577 000020F9 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19578 000020FB AA                      	stosb				;AN000; store it in srcxname
 19579                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19580 000020FC B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19581 000020FF AB                      	stosw				;AN000;  store in srcxname
 19582                                  	;mov	al,0
 19583 00002100 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19584 00002102 AA                      	stosb				;AN000;
 19585 00002103 5E                      	pop	si			;AN000; get line position back
 19586 00002104 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19587                                  
 19588                                  tn_filespec:				;AN000; a filespec was entered
 19589 00002106 56                      	push	si			;AN000; save position in line
 19590 00002107 C536[7895]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19591                                  
 19592                                  tn_move_filename:			;AN000; put filespec in srcxname
 19593 0000210B AC                      	lodsb				;AN000; get a char from buffer
 19594 0000210C AA                      	stosb				;AN000; store in srcxname
 19595                                  	;;cmp	al,0
 19596                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19597 0000210D 08C0                    	or	al,al ; al = 0 ?
 19598 0000210F 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19599 00002111 5E                      	pop	si			;AN000; get line position back
 19600                                  
 19601                                  tn_check_eol:				;AN000; make sure no extra parms
 19602 00002112 BF[1085]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19603 00002115 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19604 00002118 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 19605                                  tn_parse_error: 			;AN000; A parse error occurred
 19606 0000211A E93508                  	jmp	cerror			;AN000; Go to error routine
 19607                                  
 19608                                  tn_eol: 
 19609                                  	;23/02/2023
 19610                                  	;;mov	ah,0			;AN000; no parameters on line
 19611                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19612                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19613                                  	;mov	al,'.'
 19614                                  	; 10/06/2023
 19615                                  	;mov	ax,002Eh
 19616                                  	; ah = 0 ; *
 19617 0000211D B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 19618                                  	;
 19619 0000211F AB                      	stosw				;AN000; store in srcxname
 19620                                  	; 23/02/2023
 19621                                  	;jmp	short tn_doit		;AN000; go do command
 19622                                  
 19623                                  tn_doit:				;AN000;
 19624 00002120 BE[F387]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19625 00002123 BF[2489]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19626                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19627 00002126 B460                    	mov	ah,60h
 19628 00002128 CD21                    	int	21h			;AN000;
 19629 0000212A 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19630                                  
 19631 0000212C E8B1FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19632 0000212F C706[358C][F387]        	mov	word [string_ptr_2],SRCXNAME
 19633                                  					;AN000; get address of failed string
 19634                                  	;mov	byte [extend_buf_sub],1
 19635 00002135 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 19636                                  					;AN000; put number of subst in control block
 19637 0000213A E91508                  	jmp	cerror			;AN000; Go to error routine
 19638                                  
 19639                                  tn_print_xname: 			;AN000;
 19640 0000213D C706[358C][2489]        	mov	word [string_ptr_2],COMBUF
 19641                                  					;AN000; Set up address of combuf
 19642 00002143 BA[E280]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19643 00002146 E88804                  	call	CRLF2			;AN000; print a crlf
 19644                                  	;call	Printf_Crlf		;AN000; print it out
 19645                                  	;retn				;AN000;
 19646                                  	; 23/02/2023
 19647 00002149 E9952C                  	jmp	Printf_Crlf
 19648                                  
 19649                                  ; ---------------------------------------------------------------------------
 19650                                  
 19651                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19652                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19653                                  _$EXIT:
 19654                                  	; MSDOS 6.0
 19655 0000214C 1E                      	push	ds			;AN000; save data segment
 19656 0000214D 8E1E[C58A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19657                                  	;assume	ds:resgroup		;AN000;
 19658                                  
 19659 00002151 803E[8D01]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19660 00002156 740A                    	jz	short free_com		;AN045; no - free everything
 19661                                  
 19662                                  ;	We're a permanent command.
 19663                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19664                                  
 19665 00002158 833E[8E01]FF            	cmp	word [SingleCom],-1	;M034
 19666 0000215D 7412                    	je	short no_reset		;M034 ; exit singlecom
 19667 0000215F E9A2DF                  	jmp	TCOMMAND		;permanent command, recycle
 19668                                  
 19669                                  free_com:
 19670                                  	;mov	ax,(multdos shl 8 or message_2f)
 19671 00002162 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19672                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19673 00002165 B205                    	mov	dl,5
 19674 00002167 8B3E[A301]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19675 0000216B 8E06[A501]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19676 0000216F CD2F                    	int	2Fh			;AN000; go set it
 19677                                  no_reset:				;AN045;
 19678 00002171 1F                      	pop	ds			;AN000; restore local data segment
 19679                                  	;assume	ds:trangroup		;AN000;
 19680                                  ;M040
 19681                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19682                                  ;this, restores user dir if flag is set and resets the flag.
 19683                                  
 19684                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19685 00002172 E80C03                  	call	RestUDir1
 19686 00002175 8E06[C58A]              	mov	es,[RESSEG]
 19687                                  	;assume	es:resgroup
 19688                                  
 19689 00002179 26A1[2901]              	mov	ax,[es:Parent]
 19690                                  	;mov	[es:16h],ax
 19691                                  	;mov	[es:PDB_Parent_PID],ax
 19692 0000217D 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19693 00002181 26A1[2B01]              	mov	ax,[es:OldTerm]
 19694                                  	;mov	[es:0Ah],ax
 19695                                  	;mov	[es:PDB_Exit],ax
 19696 00002185 26A30A00                	mov	[es:PDB.EXIT],ax
 19697 00002189 26A1[2D01]              	mov	ax,[es:OldTerm+2]
 19698                                  	;mov	[es:0Ch],ax
 19699                                  	;mov	[es:PDB_Exit+2],ax
 19700 0000218D 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19701                                  
 19702 00002191 06                      	push	es
 19703 00002192 8E06[D58A]              	mov	es,[TRAN_TPA]
 19704                                  	;mov	ah,DEALLOC
 19705 00002196 B449                    	mov	ah,49h
 19706 00002198 CD21                    	int	21h			; Now running in "free" space
 19707 0000219A 07                      	pop	es
 19708                                  
 19709                                  	;mov	ah,Exit
 19710 0000219B B44C                    	mov	ah,4Ch
 19711                                  	;mov	al,byte ptr RetCode
 19712 0000219D 26A0[8501]              	mov	al,[es:RetCode]
 19713 000021A1 CD21                    	int	21h
 19714                                  
 19715                                  	;..........
 19716                                  
 19717                                  ; 23/02/2023
 19718                                  %if 0
 19719                                  _$EXIT:
 19720                                  	; MSDOS 3.3
 19721                                  	mov	es,[RESSEG]
 19722                                  	mov	ax,[es:PARENT]
 19723                                  	;mov	[es:16h],ax
 19724                                  	mov	[es:PDB.PARENT_PID],ax
 19725                                  	mov	ax,[es:OLDTERM]
 19726                                  	;mov	[es:0Ah],ax
 19727                                  	mov	[es:PDB.EXIT],ax
 19728                                  	mov	ax,[es:OLDTERM+2]
 19729                                  	;mov	[es:0Ch],ax
 19730                                  	mov	[es:PDB.EXIT+2],ax
 19731                                  	push	es
 19732                                  	mov	es,[TRAN_TPA]
 19733                                  	mov	ah,DEALLOC ; 49h
 19734                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19735                                  			; ES = segment address of area to be freed
 19736                                  	pop	es
 19737                                  	mov	ah,EXIT ; 4Ch
 19738                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19739                                  	mov	al,byte [es:RETCODE]
 19740                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19741                                  ;;here:
 19742                                  ;;	jmp	short here
 19743                                  %endif
 19744                                  
 19745                                  ; ---------------------------------------------------------------------------
 19746                                  
 19747                                  ; MSDOS 6.0
 19748                                  ; ****************************************************************
 19749                                  ; *
 19750                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19751                                  ; *
 19752                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19753                                  ; *		 If not end of line, set up to print parse
 19754                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19755                                  ; *		 EXPECTED!
 19756                                  ; *
 19757                                  ; * INPUT:	 DS:SI	  last output from parser
 19758                                  ; *		 ES:DI	  points to parse block
 19759                                  ; *		 CX	  last output from parser
 19760                                  ; *
 19761                                  ; * OUTPUT:	 AX	  parser return code
 19762                                  ; *
 19763                                  ; *		 if end of line found
 19764                                  ; *		     zero flag set
 19765                                  ; *		 else
 19766                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19767                                  ; *
 19768                                  ; ****************************************************************
 19769                                  
 19770                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19771                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19772                                  
 19773                                  parse_check_eol:
 19774 000021A3 31D2                    	xor	dx,dx			;AN000;
 19775 000021A5 8936[2D8C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19776 000021A9 E87221                  	call	cmd_parse		;AN000; call parser
 19777 000021AC 3CFF                    	cmp	al,-1 ; 0FFh
 19778                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19779 000021AE 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19780                                  	;cmp	ax,0
 19781                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19782 000021B0 21C0                    	and	ax,ax ; ax = 0 ?
 19783 000021B2 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19784 000021B4 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19785                                  ok_to_setup_pmsg:
 19786 000021B5 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19787                                  parse_good_eol:
 19788                                  parse_msg_good:	; 23/02/2023
 19789 000021B8 C3                      	retn				;AN000;
 19790                                  
 19791                                  ; ---------------------------------------------------------------------------
 19792                                  
 19793                                  ; MSDOS 6.0
 19794                                  ; ****************************************************************
 19795                                  ; *
 19796                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19797                                  ; *
 19798                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19799                                  ; *		 message is set up.
 19800                                  ; *
 19801                                  ; * INPUT:	 DS:SI	  last output from parser
 19802                                  ; *		 ES:DI	  points to parse block
 19803                                  ; *		 CX	  last output from parser
 19804                                  ; *
 19805                                  ; * OUTPUT:	 AX	  parser return code
 19806                                  ; *
 19807                                  ; *		 if no error
 19808                                  ; *		     outputs from parser
 19809                                  ; *		 else
 19810                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19811                                  ; *		     error message set up for STD_PRINTF
 19812                                  ; *
 19813                                  ; ****************************************************************
 19814                                  
 19815                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19816                                  Parse_With_Msg:
 19817 000021B9 8936[2D8C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19818 000021BD E85E21                  	call	cmd_parse		;AN018; call parser
 19819 000021C0 3CFF                    	cmp	al,-1 ; 0FFh
 19820                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19821 000021C2 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19822                                  	;cmp	ax,0
 19823                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19824 000021C4 09C0                    	or	ax,ax ; ax = 0 ?
 19825 000021C6 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19826                                  	; 23/02/2023
 19827                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19828                                  ;parse_msg_good:
 19829                                  	;retn				;AN018;
 19830                                  	; 23/02/2023
 19831                                  	;jmp	short setup_parse_error_msg	
 19832                                  
 19833                                  ; ---------------------------------------------------------------------------
 19834                                  
 19835                                  ; MSDOS 6.0
 19836                                  ; ****************************************************************
 19837                                  ; *
 19838                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19839                                  ; *
 19840                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19841                                  ; *		 message is set up.
 19842                                  ; *
 19843                                  ; * INPUT:	 AX	     Parse error number
 19844                                  ; *		 SI	     Set to past last parameter
 19845                                  ; *		 Parse_last  Set to start of last parameter
 19846                                  ; *
 19847                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19848                                  ; *		 error message set up for STD_PRINTF
 19849                                  ; *
 19850                                  ; ****************************************************************
 19851                                  
 19852                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19853                                  setup_parse_error_msg:
 19854 000021C8 C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class
 19855                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19856 000021CD BA[1B7F]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19857 000021D0 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19858                                  					;AC018; terminate the parameter string
 19859 000021D3 A3[1B7F]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19860 000021D6 83F802                  	cmp	ax,2
 19861                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19862 000021D9 740D                    	je	short setup_parse_msg_ret
 19863                                  					;AN018;    no subst
 19864 000021DB 8B36[2D8C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19865 000021DF 8936[358C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19866 000021E3 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 19867                                  					;AC018; put number of subst in control block
 19868                                  	;mov	byte [extend_buf_sub],1
 19869                                  setup_parse_msg_ret:
 19870 000021E8 46                      	inc	si			;AN018; make sure zero flag not set
 19871 000021E9 C3                      	retn				;AC018;
 19872                                  
 19873                                  ;============================================================================
 19874                                  ; TENV.ASM, MSDOS 6.0, 1991
 19875                                  ;============================================================================
 19876                                  ; 08/10/2018 - Retro DOS v3.0
 19877                                  
 19878                                  ; TITLE	Part6 COMMAND Transient routines.
 19879                                  
 19880                                  ;	Environment utilities and misc. routines
 19881                                  
 19882                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19883                                  
 19884                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19885                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19886                                  
 19887                                  ; ---------------------------------------------------------------------------
 19888                                  
 19889                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19890                                  ADD_PROMPT:
 19891 000021EA E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19892 000021ED E8AD01                  	call	scan_double_null
 19893                                  
 19894                                  ADD_PROMPT2:
 19895 000021F0 56                      	push	si
 19896 000021F1 E89B01                  	call	GETARG
 19897 000021F4 5E                      	pop	si
 19898 000021F5 7501                    	jnz	short ADD_PROMPT3
 19899                                  ADD_PROMPT_RETN:
 19900 000021F7 C3                      	retn
 19901                                  ADD_PROMPT3:			; Pre scan for arguments
 19902 000021F8 E87501                  	call	move_name	; Move in name
 19903 000021FB E89101                  	call	GETARG
 19904 000021FE 56                      	push	si
 19905 000021FF EB53                    	jmp	short ADD_NAME
 19906                                  
 19907                                  ;break	The SET command
 19908                                  
 19909                                  ; Input: DS:SI points to a CR terminated string
 19910                                  ; Output: carry flag is set if no room
 19911                                  ;	  otherwise name is added to environment
 19912                                  
 19913                                  DISP_ENVJ:
 19914 00002201 E9BC00                  	jmp	DISP_ENV
 19915                                  
 19916                                  ADD_NAME_TO_ENVIRONMENT:
 19917 00002204 E88801                  	call	GETARG
 19918 00002207 74F8                    	jz	short DISP_ENVJ
 19919                                  
 19920                                  ; check if line contains exactly one equals sign
 19921                                  
 19922 00002209 31DB                    	xor	bx,bx		; = count is 0
 19923 0000220B 56                      	push	si		; Save pointer to beginning of line
 19924                                  EQLP:
 19925 0000220C AC                      	lodsb			; Get a char
 19926 0000220D 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19927 0000220F 740F                    	je	short QUEQ	
 19928 00002211 3C3D                    	cmp	al,'='		; Look for = sign	
 19929 00002213 75F7                    	jne	short EQLP	; not there, get next char
 19930 00002215 FEC3                    	inc	bl		; Otherwise increment EQ count
 19931 00002217 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19932 0000221A 75F0                    	jne	short EQLP
 19933 0000221C FEC7                    	inc	bh		; Set BH=1 means no parameters
 19934 0000221E EBEC                    	jmp	short EQLP	; And look for more
 19935                                  QUEQ:
 19936 00002220 5E                      	pop	si		; Restore beginning of line
 19937 00002221 FECB                    	dec	bl		; Zero flag means only one EQ
 19938 00002223 7406                    	jz	short ONEQ	; Good line
 19939 00002225 BA[B37F]                	mov	dx,SYNTMES_PTR
 19940 00002228 E92707                  	jmp	cerror
 19941                                  ONEQ:
 19942 0000222B 53                      	push	bx
 19943 0000222C E8BD00                  	call	delete_name_in_environment
 19944 0000222F 5B                      	pop	bx
 19945 00002230 FECF                    	dec	bh
 19946 00002232 74C3                    	jz	short ADD_PROMPT_RETN
 19947 00002234 E86601                  	call	scan_double_null
 19948 00002237 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19949 00002239 E83401                  	call	move_name
 19950 0000223C 56                      	push	si
 19951 0000223D 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19952                                  				;  env var name
 19953                                  		
 19954                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19955                                  ; necessary in the resident for re-reading the transient. Let's look for
 19956                                  ; COMSPEC=
 19957                                  
 19958 0000223F C606[6284]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19959 00002244 BE[9781]                	mov	si,COMSPECSTR ; "COMSPEC="
 19960 00002247 B90400                  	mov	cx,4
 19961 0000224A F3A7                    	repe	cmpsw
 19962 0000224C 7504                    	jnz	short NOT_COMSPEC
 19963                                  				; Zero set => exact match
 19964 0000224E FE06[6284]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19965                                  	;mov	byte [COMSPEC_FLAG],1
 19966                                  NOT_COMSPEC:
 19967 00002252 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19968                                  ADD_NAME:
 19969 00002254 5E                      	pop	si		; Add the value of the new env var
 19970 00002255 56                      	push	si		;  to the environment.
 19971                                  ADD_NAME1:
 19972 00002256 AC                      	lodsb
 19973 00002257 3C0D                    	cmp	al,13 ; 0Dh
 19974 00002259 7405                    	je	short ADD_NAME_RET
 19975 0000225B E8AD01                  	call	store_char
 19976 0000225E EBF6                    	jmp	short ADD_NAME1
 19977                                  ADD_NAME_RET:
 19978 00002260 5E                      	pop	si
 19979 00002261 803E[6284]00            	cmp	byte [comspec_flag],0
 19980                                  				; If the new env var is comspec,	
 19981                                  ADD_NAME_JZ_RET:
 19982 00002266 748F                    	jz	short ADD_PROMPT_RETN 
 19983                                  				;  copy the value into the
 19984                                  				;  comspec var in the resident
 19985                                  
 19986                                  ; We have changed the COMSPEC variable. We need to update the resident
 19987                                  ; pieces necessary to reread in the info. First, skip all delimiters
 19988                                  
 19989 00002268 E87303                  	call	scanoff
 19990 0000226B 8E06[C58A]              	mov	es,[RESSEG]	;  comspec var in the resident
 19991                                  
 19992                                  ; Make sure that the printer knows where the beginning of the string is
 19993                                  
 19994 0000226F BF[3601]                	mov	di,ComSpec
 19995 00002272 89FB                    	mov	bx,di
 19996                                  
 19997                                  ; Generate drive letter for display
 19998                                  
 19999 00002274 31C0                    	xor	ax,ax		;g assume no drive first
 20000 00002276 26A2[7F01]              	mov	[es:ComDrv],al
 20001                                  	; 23/02/2023
 20002                                  	; MSDOS 6.0 (& 5.0)
 20003 0000227A 50                      	push	ax		;AN000; 3/3/KK
 20004 0000227B 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 20005 0000227D E83F01                  	call	testkanj	;AN000; 3/3/KK	
 20006 00002280 58                      	pop	ax		;AN000; 3/3/KK
 20007 00002281 7518                    	jnz	short _GOTDRIVE
 20008                                  	;
 20009 00002283 807C013A                	cmp	byte [si+1],':'	; drive specified?
 20010 00002287 7512                    	jne	short _GOTDRIVE
 20011 00002289 8A04                    	mov	al,[si]		; get his specified drive
 20012                                  	; 23/02/2023
 20013 0000228B E85B01                  	call	UPCONV
 20014                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 20015 0000228E 2C41                    	sub	al,'A'		; convert to 0-based
 20016 00002290 83C702                  	add	di,2
 20017 00002293 FEC0                    	inc	al		; convert to 1-based number
 20018 00002295 26A2[7F01]              	mov	[es:ComDrv],al
 20019                                  
 20020                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 20021                                  ; done here..
 20022                                  	;add	al,40h
 20023 00002299 0440                    	add	al,'A'-1
 20024                                  _GOTDRIVE:
 20025                                  	; 23/02/2023
 20026                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 20027                                  	;mov	[es:PUTBACKSUBSTPTR],di
 20028                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 20029 0000229B 26893E[1501]            	mov	[es:PutBackComSpec],di
 20030                                  				;g point to beginning of name after drive
 20031                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 20032                                  	;mov	[es:PUTBACKDRV],al
 20033                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 20034 000022A0 26A2[1A01]              	mov	[es:PutBackDrv],al
 20035                                  
 20036                                  ; Copy chars until delim      	
 20037                                  
 20038 000022A4 89DF                    	mov	di,bx
 20039                                  COPY_COMSPEC:
 20040 000022A6 AC                      	lodsb
 20041 000022A7 E83C03                  	call	DELIM
 20042 000022AA 7407                    	jz	short COPYDONE
 20043 000022AC 3C0D                    	cmp	al,13 ; 0Dh
 20044 000022AE 7403                    	je	short COPYDONE
 20045 000022B0 AA                      	stosb
 20046 000022B1 EBF3                    	jmp	short COPY_COMSPEC
 20047                                  COPYDONE:
 20048 000022B3 30C0                    	xor	al,al		; Null terminate the string and quit
 20049 000022B5 AA                      	stosb
 20050                                  	;mov	byte [comspec_flag],0
 20051 000022B6 A2[6284]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 20052 000022B9 4F                      	dec	di
 20053 000022BA 26893E[7601]            	mov	[es:ComSpec_End],di
 20054 000022BF C3                      	retn
 20055                                  
 20056                                  DISP_ENV:
 20057 000022C0 8E1E[C58A]              	mov	ds,[RESSEG]
 20058 000022C4 8E1E[2703]              	mov	ds,[EnvirSeg]
 20059                                  	; assume ds:nothing
 20060 000022C8 31F6                    	xor	si,si
 20061                                  PENVLP:
 20062 000022CA 803C00                  	cmp	byte [si],0
 20063 000022CD 7497                    	jz	short ADD_NAME_JZ_RET
 20064 000022CF BF[1A93]                	mov	di,Arg_Buf
 20065                                  PENVLP2:
 20066 000022D2 AC                      	lodsb
 20067 000022D3 AA                      	stosb
 20068 000022D4 08C0                    	or	al,al
 20069 000022D6 75FA                    	jnz	short PENVLP2
 20070 000022D8 BA[B880]                	mov	dx,arg_buf_ptr
 20071 000022DB 1E                      	push	ds
 20072 000022DC 06                      	push	es
 20073 000022DD 1F                      	pop	ds
 20074                                  	; assume ds:nothing
 20075 000022DE E8002B                  	call	Printf_Crlf
 20076 000022E1 1F                      	pop	ds
 20077 000022E2 EBE6                    	jmp	short PENVLP
 20078                                  
 20079                                  ; =============== S U B	R O U T	I N E =======================================
 20080                                  
 20081                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20082                                  delete_path:
 20083 000022E4 BE[8B81]                	mov	si,PATH_TEXT ; "PATH="
 20084 000022E7 EB03                    	jmp	short delete_name_in_environment
 20085                                  
 20086                                  ; =============== S U B	R O U T	I N E =======================================
 20087                                  
 20088                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20089                                  delete_prompt:
 20090 000022E9 BE[9081]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20091                                  
 20092                                  ; ---------------------------------------------------------------------------
 20093                                  
 20094                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20095                                  delete_name_in_environment:
 20096                                  
 20097                                  ; Input: DS:SI points to a "=" terminated string
 20098                                  ; Output: carry flag is set if name not found
 20099                                  ;	  otherwise name is deleted
 20100                                  
 20101 000022EC 56                      	push	si
 20102 000022ED 1E                      	push	ds
 20103 000022EE E82C00                  	call	FIND		; ES:DI points to name
 20104 000022F1 7217                    	jc	short del1
 20105 000022F3 89FE                    	mov	si,di		; Save it
 20106 000022F5 E8BF00                  	call	SCASB2		; Scan for the nul
 20107 000022F8 87F7                    	xchg	si,di
 20108                                  ;SR;
 20109                                  ; If we have only one env string, then the double null is lost when the last
 20110                                  ;string is deleted and we have an invalid empty environment with only a 
 20111                                  ;single null. To avoid this, we will look for the double null case and then
 20112                                  ;move an extra null char.
 20113                                  ; Bugbug: The only possible problem is that the last pathstring 
 20114                                  ;will be followed by a triple null. Is this really a problem?
 20115                                  
 20116                                  	; MSDOS 6.0
 20117 000022FA 26803C00                	cmp	byte [es:si],0	;null char?
 20118 000022FE 7501                    	jnz	short not_dnull	;no, we are at a double null
 20119 00002300 4E                      	dec	si		;point at the double null
 20120                                  not_dnull:
 20121                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20122 00002301 E86901                  	call	GETENVSIZ
 20123 00002304 29F1                    	sub	cx,si
 20124 00002306 06                      	push	es
 20125 00002307 1F                      	pop	ds		; ES:DI points to name
 20126                                  				; DS:SI points to next name
 20127 00002308 F3A4                    	rep	movsb
 20128                                  del1:
 20129 0000230A 1F                      	pop	ds
 20130 0000230B 5E                      	pop	si
 20131                                  find_retn:
 20132 0000230C C3                      	retn
 20133                                  
 20134                                  ; =============== S U B	R O U T	I N E =======================================
 20135                                  
 20136                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20137                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 20138                                  find_path:
 20139 0000230D BE[8B81]                	mov	si,PATH_TEXT ; "PATH="
 20140 00002310 EB03                    	jmp	short find_name_in_environment
 20141                                  
 20142                                  ; =============== S U B	R O U T	I N E =======================================
 20143                                  
 20144                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20145                                  find_prompt:
 20146 00002312 BE[9081]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20147                                  
 20148                                  ; ---------------------------------------------------------------------------
 20149                                  
 20150                                  find_name_in_environment:
 20151                                  
 20152                                  ; Input: DS:SI points to a "=" terminated string
 20153                                  ; Output: ES:DI points to the arguments in the environment
 20154                                  ;	  zero is set if name not found
 20155                                  ;	  carry flag is set if name not valid format
 20156                                  
 20157 00002315 E80500                  	call	FIND		; Find the name
 20158 00002318 72F2                    	jc	short find_retn	; Carry means not found	
 20159 0000231A E99600                  	jmp	SCASB1		; Scan for = sign
 20160                                  
 20161                                  ; ---------------------------------------------------------------------------
 20162                                  	;nop
 20163                                  
 20164                                  ; =============== S U B	R O U T	I N E =======================================
 20165                                  
 20166                                  ; On return of FIND1, ES:DI points to beginning of name
 20167                                  
 20168                                  FIND:
 20169 0000231D FC                      	cld
 20170 0000231E E84100                  	call	COUNT0		; CX = Length of name
 20171 00002321 8E06[C58A]              	mov	es,[RESSEG]
 20172                                  	;assume es:RESGROUP
 20173 00002325 268E06[2703]            	mov	es,[es:EnvirSeg]
 20174                                  	;assume es:NOTHING
 20175 0000232A 31FF                    	xor	di,di
 20176                                  find1:	
 20177 0000232C 51                      	push	cx
 20178 0000232D 56                      	push	si
 20179 0000232E 57                      	push	di
 20180                                  find11:
 20181 0000232F AC                      	lodsb
 20182                                  	; 23/02/2023 
 20183                                  	; MSDOS 6.0 (& 5.0)
 20184 00002330 E88C00                  	call	testkanj	
 20185 00002333 740F                    	jz	short notkanj3
 20186 00002335 4E                      	dec	si
 20187 00002336 AD                      	lodsw
 20188 00002337 47                      	inc	di
 20189 00002338 47                      	inc	di
 20190 00002339 263B45FE                	cmp	ax,[es:di-2]
 20191 0000233D 7511                    	jne	short find12
 20192 0000233F 49                      	dec	cx
 20193 00002340 E2ED                    	loop	find11
 20194 00002342 EB0C                    	jmp	short find12
 20195                                  notkanj3:
 20196 00002344 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 20197                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 20198 00002347 47                      	inc	di
 20199 00002348 263A45FF                	cmp	al,[es:di-1]
 20200 0000234C 7502                    	jne	short find12
 20201 0000234E E2DF                    	loop	find11
 20202                                  find12:
 20203 00002350 5F                      	pop	di
 20204 00002351 5E                      	pop	si
 20205 00002352 59                      	pop	cx
 20206 00002353 74B7                    	jz	short find_retn
 20207 00002355 51                      	push	cx
 20208 00002356 E85E00                  	call	SCASB2		; Scan for a nul
 20209 00002359 59                      	pop	cx
 20210 0000235A 26803D00                	cmp	byte [es:di],0
 20211 0000235E 75CC                    	jnz	short find1
 20212 00002360 F9                      	stc			; Indicate not found
 20213 00002361 C3                      	retn
 20214                                  
 20215                                  ; =============== S U B	R O U T	I N E =======================================
 20216                                  
 20217                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20218                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 20219                                  COUNT0:
 20220 00002362 1E                      	push	ds
 20221 00002363 07                      	pop	es
 20222                                  	;assume es:nothing
 20223 00002364 89F7                    	mov	di,si
 20224                                  ;COUNT1:
 20225 00002366 57                      	push	di		; Count number of chars until "="
 20226 00002367 E84900                  	call	SCASB1
 20227                                  	; 23/02/2023
 20228                                  ;	jmp	short COUNTX
 20229                                  ;COUNT2:
 20230                                  ;	push	di		; Count number of chars until nul
 20231                                  ;	call	SCASB2
 20232                                  ;COUNTX:
 20233 0000236A 59                      	pop	cx
 20234 0000236B 29CF                    	sub	di,cx
 20235 0000236D 87F9                    	xchg	di,cx
 20236                                  move_name_retn:
 20237 0000236F C3                      	retn
 20238                                  
 20239                                  ; =============== S U B	R O U T	I N E =======================================
 20240                                  
 20241                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20242                                  move_name:
 20243 00002370 803C0D                  	cmp	byte [si],13 ; 0Dh
 20244 00002373 74FA                    	je	short move_name_retn
 20245 00002375 AC                      	lodsb
 20246                                  	; 23/02/2023 
 20247                                  	; MSDOS 6.0 (& 5.0)
 20248 00002376 E84600                  	call	testkanj		
 20249 00002379 7409                    	jz	short notkanj1
 20250 0000237B E88D00                  	call	store_char
 20251 0000237E AC                      	lodsb
 20252 0000237F E88900                  	call	store_char
 20253 00002382 EBEC                    	jmp	short move_name
 20254                                  notkanj1: 
 20255 00002384 E86200                  	call	UPCONV
 20256                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 20257 00002387 E88100                  	call	store_char
 20258 0000238A 3C3D                    	cmp	al,'='
 20259 0000238C 75E2                    	jne	short move_name
 20260                                  getarg_retn:
 20261 0000238E C3                      	retn
 20262                                  
 20263                                  ; =============== S U B	R O U T	I N E =======================================
 20264                                  
 20265                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20266                                  GETARG:
 20267 0000238F BE8000                  	mov	si,80h
 20268 00002392 AC                      	lodsb
 20269 00002393 08C0                    	or	al,al
 20270 00002395 74F7                    	jz	short getarg_retn
 20271 00002397 E84402                  	call	scanoff
 20272 0000239A 3C0D                    	cmp	al,13 ; 0Dh
 20273                                  sdn_retn:
 20274 0000239C C3                      	retn
 20275                                  
 20276                                  ; =============== S U B	R O U T	I N E =======================================
 20277                                  
 20278                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 20279                                  ; there is NO double NULL, merely a string that is empty.
 20280                                  
 20281                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20282                                  scan_double_null:
 20283 0000239D 8E06[C58A]              	mov	es,[RESSEG]
 20284 000023A1 268E06[2703]            	mov	es,[es:EnvirSeg]
 20285 000023A6 31FF                    	xor	di,di
 20286                                  
 20287                                  ; Top cycle-point. If the string here is empty, then we are done
 20288                                  
 20289                                  sdn1:
 20290 000023A8 26803D00                	cmp	byte [es:di],0	; nul string?
 20291 000023AC 74EE                    	jz	short sdn_retn	; yep, all done
 20292 000023AE E80600                  	call	SCASB2
 20293 000023B1 EBF5                    	jmp	short sdn1
 20294                                  
 20295                                  ; =============== S U B	R O U T	I N E =======================================
 20296                                  
 20297                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20298                                  SCASB1:
 20299 000023B3 B03D                    	mov	al,'='		; Scan for an =
 20300 000023B5 EB02                    	jmp	short SCASBX
 20301                                  
 20302                                  ; =============== S U B	R O U T	I N E =======================================
 20303                                  
 20304                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20305                                  SCASB2:
 20306 000023B7 30C0                    	xor	al,al		; Scan for a nul
 20307                                  
 20308                                  ; ---------------------------------------------------------------------------
 20309                                  
 20310                                  	; 23/02/2023
 20311                                  SCASBX:
 20312 000023B9 B90001                  	mov	cx,256
 20313 000023BC F2AE                    	repne	scasb
 20314 000023BE C3                      	retn
 20315                                  
 20316                                  ; =============== S U B	R O U T	I N E =======================================
 20317                                  
 20318                                  ; MSDOS 6.0
 20319                                  
 20320                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 20321                                  
 20322                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20323                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 20324                                  testkanj:
 20325 000023BF 1E                      	push	ds			;AN000;  3/3/KK
 20326 000023C0 56                      	push	si			;AN000;  3/3/KK
 20327 000023C1 50                      	push	ax			;AN000;  3/3/KK
 20328 000023C2 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20329 000023C7 C536[A701]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20330                                  ktlop:					;AN000;  3/3/KK
 20331 000023CB 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20332 000023CE 740E                    	je	short notlead 		;AN000;  3/3/KK
 20333 000023D0 58                      	pop	ax			;AN000;  3/3/KK
 20334 000023D1 50                      	push	ax			;AN000;  3/3/KK
 20335 000023D2 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20336 000023D4 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20337 000023D6 46                      	inc	si			;AN000;  3/3/KK
 20338 000023D7 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20339 000023D9 7607                    	jbe	short islead		;AN000;  3/3/KK
 20340 000023DB 46                      	inc	si			;AN000;  3/3/KK
 20341 000023DC EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20342                                  notlead:				;AN000;  3/3/KK
 20343 000023DE 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20344 000023E0 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20345                                  islead: 				;AN000;  3/3/KK
 20346 000023E2 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20347 000023E4 40                      	inc	ax			;AN000;  3/3/KK
 20348                                  ktret:					;AN000;  3/3/KK
 20349 000023E5 58                      	pop	ax			;AN000;  3/3/KK
 20350 000023E6 5E                      	pop	si			;AN000;  3/3/KK
 20351 000023E7 1F                      	pop	ds			;AN000;  3/3/KK
 20352 000023E8 C3                      	retn				;AN000;  3/3/KK
 20353                                  
 20354                                  ; =============== S U B	R O U T	I N E =======================================
 20355                                  
 20356                                  ; MSDOS 6.0
 20357                                  
 20358                                  ; ****************************************************************
 20359                                  ; *
 20360                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20361                                  ; *
 20362                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20363                                  ; *		 the character in AL from the file upper case table
 20364                                  ; *		 in DOS if character if above  ascii 128, else
 20365                                  ; *		 subtracts 20H if between "a" and "z".
 20366                                  ; *
 20367                                  ; * INPUT:	 AL	      char to be upper cased
 20368                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20369                                  ; *
 20370                                  ; * OUTPUT:	 AL	      upper cased character
 20371                                  ; *
 20372                                  ; ****************************************************************
 20373                                  
 20374                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20375                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20376                                  UPCONV:
 20377 000023E9 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20378 000023EB 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20379 000023ED 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20380 000023EF 1E                      	push	ds			;AN000;
 20381 000023F0 53                      	push	bx			;AN000;
 20382 000023F1 8E1E[C58A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20383                                  	;lds	bx,dword ptr FUCase_Addr+1
 20384 000023F5 C51E[9F01]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20385 000023F9 83C302                  	add	bx,2			;AN000;  skip over first word
 20386                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20387 000023FC D7                      	xlat
 20388 000023FD 5B                      	pop	bx			;AN000;
 20389 000023FE 1F                      	pop	ds			;AN000;
 20390                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20391                                  	; 24/02/2023
 20392 000023FF C3                      	retn
 20393                                  oth_fucase:				;AN000;
 20394 00002400 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20395 00002402 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20396 00002404 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20397 00002406 7702                    	ja	short upconv_end	;AC000;
 20398 00002408 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20399                                  upconv_end:				;AN000;
 20400 0000240A C3                      	retn
 20401                                  
 20402                                  ; ---------------------------------------------------------------------------
 20403                                  
 20404                                  ; MSDOS 3.3
 20405                                  
 20406                                  	; 24/02/2023
 20407                                  ;UPCONV_MAPCALL:
 20408                                  	;			; If between "a" and "z"
 20409                                  	;cmp	al,[small_a]
 20410                                  	;jb	short UPCONV_END
 20411                                  	;cmp	al,[small_z]
 20412                                  	;ja	short UPCONV_END
 20413                                  	;sub	al,20h		; Change lower-case to upper
 20414                                  ;UPCONV_END:
 20415                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20416                                  	;			  ; 	  for (current) country
 20417                                  	;retn
 20418                                  
 20419                                  ; =============== S U B	R O U T	I N E =======================================
 20420                                  
 20421                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20422                                  
 20423                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20424                                  	; 10/06/2023
 20425                                  store_char:
 20426 0000240B 51                      	push	cx
 20427 0000240C 53                      	push	bx
 20428                                  
 20429                                  	; 24/02/2023
 20430                                  	;;16/10/2018
 20431                                  	; MSDOS 6.0
 20432 0000240D 06                      	push	es		;AN056;*
 20433 0000240E 1E                      	push	ds		;AN056; Save local DS
 20434 0000240F 8E1E[C58A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20435 00002413 8E06[2703]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20436 00002417 1F                      	pop	ds		;AN056; Get local segment back
 20437                                  
 20438                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20439 00002418 E85200                  	call	GETENVSIZ
 20440 0000241B 89CB                    	mov	bx,cx		; Save room for double nul
 20441 0000241D 83EB02                  	sub	bx,2
 20442 00002420 39DF                    	cmp	di,bx
 20443 00002422 723F                    	jb	short store1
 20444 00002424 50                      	push	ax
 20445 00002425 51                      	push	cx
 20446 00002426 53                      	push	bx		; Save Size of environment
 20447 00002427 E8DAE2                  	call	FREE_TPA
 20448 0000242A 5B                      	pop	bx
 20449 0000242B 83C302                  	add	bx,2		; Recover true environment size
 20450                                  
 20451 0000242E 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20452 00002432 7203                    	jb	short envsiz_ok
 20453                                  bad_env_size:			;AN056;
 20454 00002434 F9                      	stc
 20455 00002435 EB16                    	jmp	short envnoset
 20456                                  	;nop
 20457                                  envsiz_ok:
 20458 00002437 B104                    	mov	cl,4
 20459 00002439 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20460 0000243B 43                      	inc	bx
 20461                                  	; 24/02/2023
 20462                                  	; MSDOS 6.0
 20463 0000243C 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20464 0000243E 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20465 00002440 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20466 00002443 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20467 00002445 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20468 00002447 73EB                    	jnb	short bad_env_size
 20469                                  				;AN056; Yes - don't do it!!!
 20470                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20471 00002449 B44A                    	mov	ah,4Ah
 20472                                  	;mov	ah,SETBLOCK ; 4Ah
 20473 0000244B CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20474                                  			; ES = segment address of block	to change
 20475                                  			; BX = new size	in paragraphs
 20476                                  envnoset:
 20477 0000244D 9C                      	pushf
 20478 0000244E 06                      	push	es
 20479 0000244F 8E06[C58A]              	mov	es,[RESSEG]
 20480 00002453 E8BEE2                  	call	ALLOC_TPA
 20481 00002456 07                      	pop	es
 20482 00002457 9D                      	popf
 20483 00002458 59                      	pop	cx
 20484 00002459 58                      	pop	ax
 20485                                  	; 24/02/2023
 20486                                  	;pop	es ; MSDOS 6.0	;AN056;*	
 20487 0000245A 7307                    	jnc	short store1
 20488                                  	; 10/06/2023 (BugFix)
 20489 0000245C 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20490 0000245D BA[327F]                	mov	dx,ENVERR_PTR
 20491 00002460 E9EF04                  	jmp	cerror
 20492                                  store1:	
 20493 00002463 AA                      	stosb
 20494 00002464 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20495                                  	; 24/02/2023
 20496 00002469 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20497 0000246A 5B                      	pop	bx
 20498 0000246B 59                      	pop	cx
 20499 0000246C C3                      	retn
 20500                                  
 20501                                  ; =============== S U B	R O U T	I N E =======================================
 20502                                  
 20503                                  	; 24/02/2023
 20504                                  GETENVSIZ:
 20505                                  
 20506                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20507                                  ;ES has environment segment
 20508                                  ;Size returned in CX, all other registers preserved
 20509                                  
 20510 0000246D 06                      	push	es
 20511 0000246E 50                      	push	ax
 20512 0000246F 8CC0                    	mov	ax,es
 20513 00002471 48                      	dec	ax		;Point at arena
 20514 00002472 8EC0                    	mov	es,ax
 20515                                  	;mov	ax,[es:3]
 20516 00002474 26A10300                	mov	ax,[es:ARENA.size]
 20517 00002478 B104                    	mov	cl,4
 20518 0000247A D3E0                    	shl	ax,cl		;Convert to bytes
 20519 0000247C 89C1                    	mov	cx,ax
 20520 0000247E 58                      	pop	ax
 20521 0000247F 07                      	pop	es
 20522                                  getenvsiz_retn:
 20523 00002480 C3                      	retn
 20524                                  
 20525                                  ; =============== S U B	R O U T	I N E =======================================
 20526                                  
 20527                                  	; 24/02/2023
 20528                                  RestUDir1:
 20529 00002481 1E                      	push	ds
 20530 00002482 8E1E[C58A]              	mov	ds,[RESSEG]
 20531 00002486 803E[8C01]00            	cmp	byte [RestDir],0
 20532 0000248B 1F                      	pop	ds
 20533 0000248C 74F2                    	jz	short getenvsiz_retn
 20534                                  
 20535                                  ; =============== S U B	R O U T	I N E =======================================
 20536                                  
 20537                                  	; 24/02/2023
 20538                                  RestUDir:
 20539 0000248E BA[A789]                	mov	dx,USERDIR1
 20540 00002491 B43B                    	mov	ah,3Bh
 20541                                  	;mov	ah,CHDir ; 3Bh
 20542 00002493 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20543                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20544 00002495 30C0                    	xor	al,al
 20545                                  	;call	SETREST
 20546                                  	;retn
 20547                                  	; 24/02/2023
 20548 00002497 E94908                  	jmp	SETREST
 20549                                  
 20550                                  ;============================================================================
 20551                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20552                                  ;============================================================================
 20553                                  ; 07/10/2018 - Retro DOS v3.0
 20554                                  
 20555                                  ; TITLE	Part6 COMMAND Transient routines.
 20556                                  
 20557                                  ;	Environment utilities and misc. routines
 20558                                  
 20559                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20560                                  
 20561                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20562                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20563                                  
 20564                                  ; ---------------------------------------------------------------------------
 20565                                  
 20566                                  ; ****************************************************************
 20567                                  ; *
 20568                                  ; * ROUTINE:	 $CHDIR
 20569                                  ; *
 20570                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20571                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20572                                  ; *		 letter is found, get and display the current dir
 20573                                  ; *		 of the specified drive. If nothing is found, get
 20574                                  ; *		 and display the current dir of the default drive.
 20575                                  ; *
 20576                                  ; * INPUT:	 command line at offset 81H
 20577                                  ; *
 20578                                  ; * OUTPUT:	 none
 20579                                  ; *
 20580                                  ; ****************************************************************
 20581                                  
 20582                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20583                                  	; 10/06/2023
 20584                                  _$CHDIR:
 20585                                  	; MSDOS 6.0
 20586 0000249A BE8100                  	mov	si,81h
 20587 0000249D BF[1085]                	mov	di,PARSE_CHDIR
 20588                                  				;AN000; Get address of PARSE_CHDIR
 20589 000024A0 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20590 000024A2 31D2                    	xor	dx,dx		;AN000;
 20591 000024A4 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20592                                  	
 20593                                  	;cmp	ax,-1
 20594                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20595                                  	;je	short bwdj	; No args
 20596                                  	;;cmp	ax,0
 20597                                  	;;cmp	ax,RESULT_NO_ERROR
 20598                                  	;			;AC000; did we have an error?
 20599                                  	;or	ax,ax ; ax = 0 ?
 20600                                  	;jnz	short ChDirErr	;AC018; yes - exit
 20601                                  	
 20602                                  	; 10/06/2023
 20603 000024A7 40                      	inc	ax	; cmp ax,-1
 20604 000024A8 7414                    	jz	short bwdj ; 0FFFFh -> 0
 20605 000024AA 48                      	dec	ax	; cmp ax,0
 20606 000024AB 756D                    	jnz	short ChDirErr ; 1 -> 0
 20607                                  	; ax = 0	
 20608                                  
 20609                                  	;cmp	byte [PARSE1_TYPE],6
 20610 000024AD 803E[7495]06            	cmp	byte [PARSE1_TYPE],result_drive
 20611                                  				;AC000; was a drive entered?
 20612 000024B2 7511                    	jne	short REALCD	; no
 20613                                  
 20614                                  ; D: was found. See if there is anything more.
 20615                                  
 20616 000024B4 BF[1085]                	mov	di,PARSE_CHDIR
 20617                                  				;AC000; get address of parse_chdir
 20618 000024B7 31D2                    	xor	dx,dx		;AC000;
 20619 000024B9 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 20620 000024BC 755C                    	jnz	short ChDirErr	;AC000;
 20621                                  bwdj:
 20622 000024BE E87BF9                  	call	build_dir_for_chdir
 20623                                  				; Drive only specified
 20624 000024C1 E80D01                  	call	CRLF2
 20625                                  chdir_retn:
 20626 000024C4 C3                      	retn
 20627                                  
 20628                                  	; 24/02/2023
 20629                                  	; MSDOS 3.3
 20630                                  	;mov	ax,[COMSW]
 20631                                  	;or	ax,[ALLSWITCH]
 20632                                  	;mov	dx,BADPARMPTR
 20633                                  	;jnz	short CHDIR_ERR
 20634                                  	;mov	si,81h
 20635                                  	;call	SCANOFF
 20636                                  	;cmp	al,0Dh		; are we at end of line?
 20637                                  	;je	short BWDJ	; No args
 20638                                  	;inc	si
 20639                                  	;lodsb
 20640                                  	;cmp	al,':'
 20641                                  	;jne	short REALCD
 20642                                  	;push	si
 20643                                  	;call	SCANOFF
 20644                                  	;pop	si
 20645                                  	;cmp	al,0Dh		; was a drive entered?
 20646                                  	;jne	short REALCD	; no
 20647                                  ;BWDJ:
 20648                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20649                                  	;call	CRLF2
 20650                                  ;CHDIR_RETN:
 20651                                  	;retn
 20652                                  
 20653                                  	; 24/02/2023
 20654                                  	; MSDOS 6.0
 20655                                  REALCD:
 20656 000024C5 56                      	push	si		;AN000; save position in line
 20657 000024C6 C536[7895]              	lds	si,[PARSE1_ADDR]
 20658                                  				;AN000; get address of filespec
 20659 000024CA E8D807                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20660 000024CD 5E                      	pop	si		;AN000; restore position in line
 20661 000024CE BF[1085]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20662 000024D1 31D2                    	xor	dx,dx		;AC000;
 20663 000024D3 E8CDFC                  	call	parse_check_eol ;AC000; call parser
 20664 000024D6 7542                    	jnz	short ChDirErr	;AC000;
 20665                                  	
 20666 000024D8 E81106                  	call	SETPATH
 20667 000024DB F606[508C]02            	test	byte [DestInfo],2
 20668 000024E0 7518                    	jnz	short BadChDir
 20669                                  
 20670                                  	; 26/04/2023
 20671 000024E2 B43B                    	mov	ah,3Bh
 20672                                  	;mov	ah,CHDir
 20673 000024E4 CD21                    	int	21h
 20674 000024E6 73DC                    	jnc	short chdir_retn
 20675                                  	
 20676 000024E8 E805F8                  	call	get_ext_error_number
 20677                                  				;AN022; get the extended error
 20678 000024EB 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20679                                  				;AN022; see if path not found
 20680 000024EE 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20681                                  ;SR;
 20682                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20683                                  ;but is not a directory. The extended error returns "Access denied" which
 20684                                  ;is kind of confusing. Issue the old message if access denied error is 
 20685                                  ;returned
 20686                                  
 20687 000024F0 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20688 000024F3 7405                    	je	short BadChDir
 20689                                  	
 20690 000024F5 E89E00                  	call	set_ext_error_subst ;AN022;
 20691 000024F8 EB20                    	jmp	short ChDirErr	;AN022;
 20692                                  
 20693                                  BadChDir:
 20694 000024FA BA[5680]                	mov	dx,badcd_ptr
 20695                                  ;ChDirErr:
 20696                                  ;	call	std_eprintf
 20697                                  ;mkdir_retn:
 20698                                  	;retn
 20699                                  	; 24/02/2023
 20700 000024FD EB1B                    	jmp	short ChDirErr	;AN022;
 20701                                  
 20702                                  	; 24/02/2023
 20703                                  	; MSDOS 3.3
 20704                                  ;REALCD:
 20705                                  	;call	SETPATH
 20706                                  	;test	byte [DESTINFO],2
 20707                                  	;jnz	short BADCHDIR
 20708                                  	;mov	ah,CHDir ; 3Bh
 20709                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20710                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20711                                  	;jnc	short CHDIR_RETN
 20712                                  ;BADCHDIR:
 20713                                  	;mov	dx,BADCDPTR
 20714                                  ;CHDIR_ERR:
 20715                                  	;call	STD_EPRINTF
 20716                                  ;MKDIR_RETN:
 20717                                  	;retn
 20718                                  
 20719                                  ; =============== S U B	R O U T	I N E =======================================
 20720                                  
 20721                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20722                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20723                                  _$MKDIR:
 20724                                  	; MSDOS 6.0
 20725 000024FF E86300                  	call	SETRMMK
 20726 00002502 7216                    	jc	short MkDirErr
 20727                                  
 20728 00002504 B439                    	mov	ah,39h
 20729                                  	;mov	ah,MKDIR
 20730 00002506 CD21                    	int	21h
 20731 00002508 7313                    	jnc	short mkdir_retn
 20732                                  
 20733 0000250A E8E3F7                  	call	get_ext_error_number	
 20734                                  				;AN022; get the extended error
 20735 0000250D 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20736                                  				;AN022; see if path not found
 20737 00002510 742A                    	je	short MD_other_err
 20738                                  				;AN022; yes - issue old message
 20739 00002512 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20740                                  				;AN022; access denied?
 20741 00002515 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20742                                  	
 20743 00002517 E87C00                  	call	set_ext_error_subst
 20744                                  				;AN022;
 20745                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20746                                  	; 24/02/2023
 20747                                  ChDirErr:
 20748                                  MkDirErr:
 20749                                  RmDirErr:
 20750 0000251A E8CA28                  	call	std_eprintf
 20751                                  mkdir_retn:
 20752                                  rmdir_retn:
 20753 0000251D C3                      	retn
 20754                                  	
 20755                                  badmderr:
 20756 0000251E BA[F387]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20757 00002521 B41A                    	mov	ah,1Ah
 20758                                  	;mov	ah,Set_DMA	;AN006;
 20759 00002523 CD21                    	int	21h		;AN006;
 20760                                  	
 20761 00002525 B44E                    	mov	ah,4Eh
 20762                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20763                                  	;mov	cx,10h
 20764 00002527 B91000                  	mov	cx,ATTR_DIRECTORY
 20765                                  				;AN006;   search for directory
 20766 0000252A CD21                    	int	21h		;AN006;
 20767 0000252C 720E                    	jc	short MD_other_err
 20768                                  				;AN006; doesn't exist - must be something else
 20769                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20770                                  				;AN006; we found a file/dir
 20771                                  	;mov	dl,[SRCXNAME+21] 
 20772 0000252E 8A16[0888]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20773 00002532 F6C210                  	test	dl,ATTR_DIRECTORY
 20774                                  				;AN006; was it a directory?
 20775 00002535 7405                    	jz	short MD_other_err
 20776                                  				;AN006; no - must have been a file
 20777 00002537 BA[4681]                	mov	dx,MD_EXISTS_PTR
 20778                                  				;AN006; set up already exists error
 20779 0000253A EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20780                                  MD_other_err:			;AN006;
 20781 0000253C BA[5980]                	mov	dx,badmkd_ptr
 20782                                  ;MkDirErr:
 20783                                  	;call	std_eprintf
 20784                                  	;retn
 20785                                  	; 24/02/2023
 20786 0000253F EBD9                    	jmp	short MkDirErr
 20787                                  
 20788                                  	; 24/02/2023
 20789                                  	; MSDOS 3.3
 20790                                  	;call	SETRMMK
 20791                                  	;jb	short MKDIRERR
 20792                                  	;mov	ah,MKDIR ; 39h
 20793                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20794                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20795                                  	;jnc	short MKDIR_RETN
 20796                                  	;mov	dx,BADMKDPTR
 20797                                  	;call	GET_EXT_ERR_NUMBER
 20798                                  ;MKDIRERR:
 20799                                  	;call	STD_EPRINTF
 20800                                  	;retn
 20801                                  
 20802                                  ; =============== S U B	R O U T	I N E =======================================
 20803                                  
 20804                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20805                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20806                                  _$RMDIR:
 20807 00002541 E82100                  	call	SETRMMK
 20808 00002544 72D4                    	jb	short RmDirErr
 20809 00002546 7518                    	jnz	short badrderr
 20810                                  
 20811 00002548 B43A                    	mov	ah,3Ah
 20812                                  	;mov	ah,RMDIR ; 3Ah
 20813 0000254A CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20814                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20815 0000254C 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20816                                  
 20817                                  	; 24/02/2023
 20818                                  	; MSDOS 6.0
 20819 0000254E E89FF7                  	call	get_ext_error_number
 20820                                  				;AN022; get the extended error
 20821 00002551 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20822                                  				;AN022; see if path not found
 20823 00002554 740A                    	je	short badrderr	;AN022; yes - issue old message
 20824 00002556 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20825                                  				;AN022; access denied?
 20826 00002559 7405                    	je	short badrderr	;AN022; yes - issue old message
 20827                                  
 20828 0000255B E83800                  	call	set_ext_error_subst
 20829                                  				;AN022;
 20830 0000255E EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20831                                  
 20832                                  	; MSDOS 6.0
 20833                                  badrderr:
 20834                                  	; 24/02/2023
 20835 00002560 BA[5C80]                	mov	dx,badrmd_ptr
 20836 00002563 EBB5                    	jmp	short RmDirErr
 20837                                  ;RmDirErr:
 20838                                  	;call	std_eprintf
 20839                                  ;;rmdir_retn
 20840                                  	;retn
 20841                                  
 20842                                  	; 24/02/2023
 20843                                  	; MSDOS 3.3
 20844                                  	;mov	dx,BADRMDPTR
 20845                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20846                                  ;RMDIRERR:
 20847                                  	;call	STD_EPRINTF
 20848                                  ;RMDIR_RETN:
 20849                                  	;retn
 20850                                  
 20851                                  ; =============== S U B	R O U T	I N E =======================================
 20852                                  
 20853                                  ; 	<Common MkDir/RmDir set up code>
 20854                                  ;****************************************************************
 20855                                  ;*
 20856                                  ;* ROUTINE:	SETRMMK
 20857                                  ;*
 20858                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20859                                  ;*		commands. Parses the command line for a required
 20860                                  ;*		filespec.
 20861                                  ;*
 20862                                  ;* INPUT:	command line at offset 81H
 20863                                  ;*
 20864                                  ;* OUTPUT:	carry clear
 20865                                  ;*		    DS:DX points to ASCIIZ argument
 20866                                  ;*		carry set
 20867                                  ;*		    DS:DX has error message pointer
 20868                                  ;*
 20869                                  ;****************************************************************
 20870                                  
 20871                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20872                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20873                                  SETRMMK:
 20874                                  	; MSDOS 6.0
 20875 00002565 BE8100                  	mov	si,81h
 20876 00002568 BF[0785]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20877 0000256B 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20878 0000256D 31D2                    	xor	dx,dx		;AN000;
 20879                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20880 0000256F E847FC                  	call	Parse_With_Msg
 20881                                  	;cmp	ax,0
 20882                                  	;cmp	ax,RESULT_NO_ERROR
 20883 00002572 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20884 00002574 7519                    	jnz	short noargerr	;AC000; yes - exit
 20885                                  
 20886 00002576 BF[F387]                	mov	di,SRCXNAME
 20887                                  				;AN000; get address of srcxname
 20888 00002579 57                      	push	di		;AN000; save address
 20889 0000257A 56                      	push	si		;AN000; save position in line
 20890 0000257B C536[7895]              	lds	si,[PARSE1_ADDR]
 20891                                  				;AN000; get address of path
 20892                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20893 0000257F AC                      	lodsb			;get a char from buffer
 20894 00002580 AA                      	stosb			;AN000; store in srcxname
 20895                                  	;cmp	al,0
 20896                                  	;cmp	al,END_OF_LINE_OUT
 20897 00002581 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20898 00002583 75FA                    	jnz	short mrdir_move_filename
 20899                                  				;AC000; no - keep moving
 20900 00002585 5E                      	pop	si		;AN000; get line position back
 20901                                  
 20902                                  ; we have scanned an argument.	See if any args beyond.
 20903                                  
 20904 00002586 BF[0785]                	mov	di,PARSE_MRDIR
 20905 00002589 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20906 0000258C 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20907                                  	;retz			;yes - return no error
 20908 0000258D 7406                    	jz	short setrmmk_retn
 20909                                  noargerr:
 20910 0000258F BA[1B7F]                	mov	dx,extend_buf_ptr
 20911                                  				;AC000; get extended message pointer
 20912 00002592 31C0                    	xor	ax,ax
 20913 00002594 F9                      	stc
 20914                                  setrmmk_retn:
 20915 00002595 C3                      	retn
 20916                                  
 20917                                  	; 24/02/2023
 20918                                  	; MSDOS 3.3
 20919                                  ;SETRMMK:
 20920                                  	;mov	si,81h
 20921                                  	;call	SCANOFF
 20922                                  	;cmp	al,0Dh
 20923                                  	;je	short NOARGERR
 20924                                  	;mov	dx,si
 20925                                  ;SETRMMK1:
 20926                                  	;lodsb
 20927                                  	;call	DELIM
 20928                                  	;jz	short SETRMMK3
 20929                                  	;cmp	al,0Dh
 20930                                  	;jne	short SETRMMK1
 20931                                  	;mov	byte [si-1],0
 20932                                  ;SETRMMK2:
 20933                                  	;retn
 20934                                  ;SETRMMK3:
 20935                                  	;mov	byte [si-1],0
 20936                                  	;push	si
 20937                                  	;call	SCANOFF
 20938                                  	;pop	si
 20939                                  	;cmp	al,0Dh
 20940                                  	;je	short SETRMMK2
 20941                                  ;NOARGERR:
 20942                                  	;mov	dx,BADARGSPTR
 20943                                  	;xor	ax,ax
 20944                                  	;stc
 20945                                  ;SETRMMK_RETN:
 20946                                  	;retn
 20947                                  
 20948                                  ; =============== S U B	R O U T	I N E =======================================
 20949                                  
 20950                                  ; MSDOS 6.0
 20951                                  
 20952                                  ;****************************************************************
 20953                                  ;*
 20954                                  ;* ROUTINE:	Set_ext_error_subst
 20955                                  ;*
 20956                                  ;* FUNCTION:	Sets up substitution for extended error
 20957                                  ;*
 20958                                  ;* INPUT:	AX - extended error number
 20959                                  ;*		DX - offset of string
 20960                                  ;*
 20961                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20962                                  ;*
 20963                                  ;****************************************************************
 20964                                  
 20965                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20966                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20967                                  set_ext_error_subst:
 20968                                  	;mov	byte [msg_disp_class],1
 20969 00002596 C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 20970                                  					;AN022; set up extended error msg class
 20971 0000259B 8916[358C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20972                                  	;mov	byte [extend_buf_sub],1
 20973 0000259F C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst
 20974                                  	;AN022; put number of subst in control block
 20975 000025A4 BA[1B7F]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 20976 000025A7 A3[1B7F]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 20977                                  savudir_err_retn: ; 24/02/2023
 20978 000025AA C3                      	retn				;AN022; return
 20979                                  
 20980                                  ; =============== S U B	R O U T	I N E =======================================
 20981                                  
 20982                                  ; <SavUDir - preserve the users current directory on a particular drive>
 20983                                  
 20984                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 20985                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 20986                                  ;   buffer
 20987                                  ;
 20988                                  ;   Inputs:	DL has 1-based drive number
 20989                                  ;		ES:DI has destination buffer (SavUDir1 only)
 20990                                  ;   Outputs:	Carry Clear
 20991                                  ;		    DS = TranGroup
 20992                                  ;		Carry Set
 20993                                  ;		    AX has error code
 20994                                  ;   Registers Modified: AX, SI
 20995                                  
 20996                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20997                                  SAVUDIR:
 20998 000025AB BF[A789]                	mov	di,USERDIR1
 20999                                  ; --------------
 21000                                  SAVUDIR1:
 21001 000025AE 88D0                    	mov	al,dl
 21002 000025B0 0440                    	add	al,'@' ; 40h
 21003 000025B2 3C40                    	cmp	al,'@' ; 40h
 21004 000025B4 7506                    	jne	short GOTUDRV
 21005 000025B6 0206[D98A]              	add	al,[CURDRV]
 21006 000025BA FEC0                    	inc	al		; A = 1
 21007                                  GOTUDRV:
 21008 000025BC AA                      	stosb
 21009 000025BD 8A26[CA8A]              	mov	ah,[DIRCHAR]
 21010 000025C1 B03A                    	mov	al,':' ; 3Ah
 21011 000025C3 AB                      	stosw
 21012 000025C4 06                      	push	es
 21013 000025C5 1F                      	pop	ds
 21014 000025C6 89FE                    	mov	si,di
 21015 000025C8 B447                    	mov	ah,47h ; 24/02/2023
 21016                                  	;mov	ah,CURRENT_DIR	; 47h
 21017 000025CA CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 21018                                  			; DL = drive (0=default,1=A,etc.)
 21019                                  			; DS:SI	points to 64-byte buffer area
 21020 000025CC 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 21021 000025CE 0E                      	push	cs
 21022 000025CF 1F                      	pop	ds
 21023 000025D0 C3                      	retn
 21024                                  
 21025                                  ; =============== S U B	R O U T	I N E =======================================
 21026                                  
 21027                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21028                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 21029                                  CRLF2:
 21030 000025D1 52                      	push	dx
 21031 000025D2 BA[FA80]                	mov	dx,acrlf_ptr
 21032 000025D5 1E                      	push	ds
 21033 000025D6 0E                      	push	cs
 21034 000025D7 1F                      	pop	ds
 21035 000025D8 E81428                  	call	std_printf
 21036 000025DB 1F                      	pop	ds
 21037 000025DC 5A                      	pop	dx
 21038 000025DD C3                      	retn
 21039                                  
 21040                                  ; =============== S U B	R O U T	I N E =======================================
 21041                                  
 21042                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 21043                                  ; may NOT be TRANGROUP
 21044                                  
 21045                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21046                                  scanoff:
 21047 000025DE AC                      	lodsb
 21048 000025DF E80400                  	call	DELIM
 21049 000025E2 74FA                    	jz	short scanoff
 21050 000025E4 4E                      	dec	si		; Point to first non-delimiter
 21051                                  scanoff_retn:
 21052 000025E5 C3                      	retn
 21053                                  
 21054                                  ; =============== S U B	R O U T	I N E =======================================
 21055                                  
 21056                                  ; Input:    AL is character to classify
 21057                                  ; Output:   Z set if delimiter
 21058                                  ;	    NZ set otherwise
 21059                                  ; Registers modified: none
 21060                                  
 21061                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21062                                  DELIM:
 21063 000025E6 3C20                    	cmp	al,' '	 ;20h
 21064 000025E8 74FB                    	je	short scanoff_retn
 21065 000025EA 3C3D                    	cmp	al,'='  ; 3Dh
 21066 000025EC 74F7                    	je	short scanoff_retn
 21067 000025EE 3C2C                    	cmp	al,','	; 2Ch
 21068 000025F0 74F3                    	je	short scanoff_retn
 21069 000025F2 3C3B                    	cmp	al,';'	 ;3Bh
 21070 000025F4 74EF                    	je	short scanoff_retn
 21071 000025F6 3C09                    	cmp	al,9		; Check for TAB character
 21072 000025F8 74EB                    	je	short scanoff_retn
 21073 000025FA 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 21074 000025FC C3                      	retn
 21075                                  
 21076                                  
 21077                                  ; =============== S U B	R O U T	I N E =======================================
 21078                                  
 21079                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21080                                  FCB_TO_ASCZ:			
 21081                                  	; Convert DS:SI to ASCIZ ES:DI
 21082 000025FD B90800                  	mov	cx,8
 21083                                  MAINNAME:
 21084 00002600 AC                      	lodsb
 21085 00002601 3C20                    	cmp	al,' ' ; 20h
 21086 00002603 7401                    	jz	short SKIPSPC
 21087 00002605 AA                      	stosb
 21088                                  SKIPSPC:
 21089 00002606 E2F8                    	loop	MAINNAME
 21090 00002608 AC                      	lodsb
 21091 00002609 3C20                    	cmp	al,' '
 21092 0000260B 740F                    	je	short GOTNAME
 21093 0000260D 88C4                    	mov	ah,al
 21094                                  	; 24/02/2023
 21095 0000260F B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 21096                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 21097                                  	;stosb
 21098                                  	;xchg	al,ah
 21099                                  	;stosb
 21100                                  	; 24/02/2023
 21101 00002611 AB                      	stosw
 21102 00002612 B102                    	mov	cl,2
 21103                                  EXTNAME:
 21104 00002614 AC                      	lodsb
 21105 00002615 3C20                    	cmp	al,' '
 21106 00002617 7403                    	je	short GOTNAME
 21107 00002619 AA                      	stosb
 21108 0000261A E2F8                    	loop	EXTNAME
 21109                                  GOTNAME:
 21110 0000261C 30C0                    	xor	al,al
 21111 0000261E AA                      	stosb
 21112                                  STRCOMP_RETN:
 21113 0000261F C3                      	retn
 21114                                  
 21115                                  ; =============== S U B	R O U T	I N E =======================================
 21116                                  
 21117                                  ; Compare ASCIZ DS:SI with ES:DI.
 21118                                  ; SI,DI destroyed.
 21119                                  
 21120                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21121                                  STRCOMP:	
 21122 00002620 A6                      	cmpsb
 21123 00002621 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 21124 00002623 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 21125                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 21126                                  	;jmp	short STRCOMP	; Equal so far, keep going
 21127                                  	; 24/02/2023
 21128 00002627 75F7                    	jnz	short STRCOMP
 21129 00002629 C3                      	retn
 21130                                  
 21131                                  ; =============== S U B	R O U T	I N E =======================================
 21132                                  
 21133                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21134                                  CRPRINT:
 21135 0000262A 50                      	push	ax
 21136                                  	;mov	al,13	; 0Dh
 21137 0000262B B00D                    	mov	al,0Dh
 21138 0000262D 51                      	push	cx
 21139 0000262E 57                      	push	di
 21140 0000262F 89D7                    	mov	di,dx
 21141 00002631 B9FFFF                  	mov	cx,65535 ; 0FFFFh
 21142 00002634 06                      	push	es
 21143 00002635 1E                      	push	ds
 21144 00002636 07                      	pop	es
 21145 00002637 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 21146 00002639 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 21147 0000263D 07                      	pop	es
 21148 0000263E 8916[358C]              	mov	[string_ptr_2],dx
 21149                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 21150 00002642 BA[E280]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 21151 00002645 E8A727                  	call	std_printf
 21152                                  	;mov	byte [di-1],13
 21153 00002648 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 21154 0000264C 7204                    	jb	short error_output
 21155 0000264E 5F                      	pop	di
 21156 0000264F 59                      	pop	cx
 21157 00002650 58                      	pop	ax
 21158 00002651 C3                      	retn
 21159                                  
 21160                                  ; ---------------------------------------------------------------------------
 21161                                  
 21162                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21163                                  error_output:
 21164 00002652 0E                      	push	cs
 21165 00002653 1F                      	pop	ds
 21166 00002654 8E06[C58A]              	mov	es,[RESSEG]
 21167 00002658 BA[2F7F]                	mov	dx,NOSPACE_PTR
 21168 0000265B 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 21169 00002661 7406                    	jz	short go_to_error
 21170 00002663 E80209                  	call	PipeOff
 21171 00002666 BA[7C80]                	mov	dx,PIPEEMES_PTR
 21172                                  go_to_error:
 21173 00002669 E9E602                  	jmp	cerror
 21174                                  
 21175                                  ; =============== S U B	R O U T	I N E =======================================
 21176                                  
 21177                                  ;---- Mod for path invocation ----
 21178                                  
 21179                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21180                                  pathchrcmp:
 21181                                  	; 18/03/2023	
 21182                                  	;push	ax
 21183                                  	;mov	ah,'/' ; 2Fh
 21184                                  	;cmp	[SWITCHAR],ah
 21185 0000266C 803E[C98A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 21186 00002671 7404                    	je	short noslasht
 21187 00002673 3C2F                    	cmp	al,'/'
 21188 00002675 7402                    	je	short pccont
 21189                                  noslasht:
 21190 00002677 3C5C                    	cmp	al,'\' ; 5Ch
 21191                                  pccont:	
 21192                                  	;pop	ax
 21193 00002679 C3                      	retn
 21194                                  
 21195                                  ; =============== S U B	R O U T	I N E =======================================
 21196                                  
 21197                                  ; PATHCRUNCH -
 21198                                  ;
 21199                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 21200                                  ;       PathPos = ptr to string with pathname in it
 21201                                  ;       PathCnt = length of string
 21202                                  ;
 21203                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 21204                                  ;       PathCnt = length left in string
 21205                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 21206                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 21207                                  ;       If path crunched successfully,
 21208                                  ;         CY = clear
 21209                                  ;         Current directory is changed to directory in pathname
 21210                                  ;         UserDir1 contains previous directory for use by RestUDir
 21211                                  ;         RestDir = nonzero to flag later restoration of user's dir
 21212                                  ;         DestTail = ptr to beginning of filename
 21213                                  ;         If filename found in pathname,
 21214                                  ;           ZR = clear
 21215                                  ;           FCB filename fields contain filename
 21216                                  ;         If filename not found (pure directory path),
 21217                                  ;           ZR = set
 21218                                  ;           FCB filename fields are wildcarded with ?'s
 21219                                  ;       If pathcrunch failed (no ChDir's worked),
 21220                                  ;         CY = set
 21221                                  ;         Msg_Numb = extended error code
 21222                                  ;
 21223                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 21224                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 21225                                  ;       with the filename wildcarded.
 21226                                  
 21227                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21228                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 21229                                  
 21230                                  PathCrunch:
 21231                                  	; MSDOS 6.0
 21232 0000267A C706[B88D]0000          	mov     word [Msg_Numb],0
 21233                                  				;AN022; Set up message flag
 21234                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21235                                  	;mov	dl,[5Ch]
 21236 00002680 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 21237 00002684 E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 21238                                  	; MSDOS 6.0
 21239 00002687 7233                     	jc	short pcrunch_cderrj
 21240                                  				;AN022; if error on current dir - report
 21241 00002689 E86004                  	call	SETPATH		; scan past switches, whitespace
 21242                                  
 21243                                  ;       DX = ptr to pathname, NULL-terminated
 21244                                  ;       PathPos = ptr to byte after NULL at end of pathname
 21245                                  
 21246                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21247 0000268C F606[508C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 21248 00002691 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 21249                                  
 21250                                  	;mov	ah,CHDir ; 3Bh
 21251 00002693 B43B                    	mov	ah,3Bh
 21252 00002695 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21253                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21254                                  	; MSDOS 6.0
 21255 00002697 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 21256                                  	
 21257 00002699 E854F6                  	call	get_ext_error_number    ;AN022; get the extended error
 21258 0000269C 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 21259 0000269F 741E                    	je	short trypeel		;AC022;    keep trying
 21260 000026A1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 21261 000026A4 7419                    	je	short trypeel		;AC022;    keep trying
 21262 000026A6 A3[B88D]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 21263 000026A9 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 21264                                  
 21265                                  	; MSDOS 3.3
 21266                                  	;jc	short trypeel
 21267                                  chdir_worked:
 21268                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21269 000026AC E83206                  	call	SetRest1	; set 'Restore Directory' flag true
 21270 000026AF B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 21271 000026B1 BF5D00                  	mov	di,5Dh  ; FCB+1
 21272 000026B4 B90B00                  	mov	cx,11
 21273 000026B7 F3AA                    	rep	stosb
 21274 000026B9 30C0                    	xor	al,al		; return carry clear, zero set
 21275 000026BB C3                      	retn
 21276                                  
 21277                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 21278 000026BC E98100                  	jmp	pcrunch_cderr	;AN022;
 21279                                  
 21280                                  trypeel:
 21281 000026BF 8B36[248C]              	mov	si,[PathPos]
 21282 000026C3 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 21283 000026C4 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 21284                                  	; 25/02/2023
 21285                                  	; MSDOS 5.0 (& 6.0)
 21286 000026C7 803E[D38D]00            	cmp	byte [KPARSE],0
 21287 000026CC 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 21288                                  	
 21289 000026CE E89BFF                  	call	pathchrcmp
 21290 000026D1 7475                    	jz	short peelfail	; Trailing '/'
 21291                                  delstrt:
 21292 000026D3 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 21293 000026D5 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 21294 000026D7 52                      	push	dx		; save ptr to pathname
 21295                                  delloop:
 21296 000026D8 39CE                    	cmp	si,cx
 21297                                  	;jz	short BADRET
 21298                                  	; 25/02/2023
 21299 000026DA 7413                    	je	short gotdele	; no char's left, we have what we have
 21300 000026DC AC                      	lodsb			; AL = next char of pathname
 21301 000026DD E8DFFC                  	call	testkanj
 21302 000026E0 7403                    	jz	short notkanj8	; not Kanji, move along
 21303 000026E2 46                      	inc	si
 21304 000026E3 EBF3                    	jmp	short delloop	
 21305                                  
 21306                                  	; 25/02/2023
 21307                                  	; MSDOS 3.3
 21308                                  	;mov	al,[si]
 21309                                  	;call	PATHCHRCMP
 21310                                  	;jz	short TRYCD
 21311                                  	;dec	si
 21312                                  	;jmp	short delloop
 21313                                  
 21314                                  notkanj8:
 21315 000026E5 E884FF                  	call	pathchrcmp
 21316 000026E8 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 21317 000026EA 89F2                    	mov	dx,si
 21318 000026EC 4A                      	dec	dx		; DX = ptr to last delimiter found	
 21319 000026ED EBE9                    	jmp	short delloop	; go look for more
 21320                                  
 21321                                  	; 25/02/2023
 21322                                  	; MSDOS 5.0 (& 6.0)
 21323                                  gotdele:
 21324 000026EF 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 21325 000026F1 5A                      	pop	dx		; DX = ptr to pathname
 21326 000026F2 39D6                    	cmp	si,dx
 21327 000026F4 7454                    	je	short badret	; didn't find path delim
 21328 000026F6 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 21329 000026F8 89D6                    	mov	si,dx		; SI = ptr to pathname
 21330                                  delloop2:			; Set value of KPARSE
 21331 000026FA 39CE                    	cmp	si,cx
 21332 000026FC 7412                    	je	short trycd	; roll up till SI meets CX
 21333 000026FE C606[D38D]00            	mov	byte [KPARSE],0
 21334 00002703 AC                      	lodsb
 21335 00002704 E8B8FC                  	call	testkanj
 21336 00002707 74F1                    	jz	short delloop2
 21337 00002709 46                      	inc	si
 21338 0000270A FE06[D38D]              	inc	byte [KPARSE]
 21339 0000270E EBEA                    	jmp	short delloop2
 21340                                  
 21341                                  trycd:
 21342 00002710 50                      	push	ax
 21343                                  	; 25/02/2023
 21344 00002711 B02E                    	mov	al,'.'
 21345                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21346                                  	; MSDOS 6.0
 21347 00002713 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21348                                  				;M019; allow continuation if '. ' or 
 21349                                  				;M019; '..' is not found.
 21350 00002716 7509                    	jne	short trycd1	;M019; '.' not found
 21351 00002718 384402                  	cmp	[si+2],al	;M019; check for '..'
 21352 0000271B 7404                    	je	short trycd1	;M019; found '..'
 21353 0000271D 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21354                                  trycd1:	
 21355 00002721 58                      	pop     ax
 21356 00002722 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21357                                  
 21358                                  	; 25/02/2023
 21359                                  	; MSDOS 3.3
 21360                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21361                                  	;pop	ax
 21362                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21363                                  
 21364                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21365 00002724 8A44FF                  	mov	al,[si-1]
 21366 00002727 3C3A                    	cmp	al,':' 		; Special case d:\file
 21367 00002729 741F                    	je	short badret
 21368                                  	; 25/02/2023
 21369                                  	; MSDOS 6.0
 21370 0000272B 803E[D38D]00            	cmp	byte [KPARSE],0
 21371 00002730 7505                    	jnz	short notdoublesl
 21372 00002732 E837FF                  	call	pathchrcmp
 21373                                  	;jnz	short notdoublesl
 21374                                  				; Last char is 2nd KANJI byte, might be '\'
 21375                                  	; 25/02/2023
 21376 00002735 7411                    	jz	short peelfail 
 21377                                  ;peelfail:
 21378                                  	;stc
 21379                                  	;retn
 21380                                  
 21381                                  notdoublesl:
 21382 00002737 C60400                  	mov	byte [si],0
 21383                                  	;mov	ah,CHDir ; 3Bh
 21384 0000273A B43B                    	mov	ah,3Bh
 21385 0000273C CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21386                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21387 0000273E 7320                    	jnc	short cdsucc
 21388                                  
 21389                                  	; 25/02/2023
 21390                                  	; MSDOS 6.0
 21391                                  pcrunch_cderr:
 21392 00002740 E8ADF5                  	call	get_ext_error_number
 21393                                  				;AN022; get the extended error
 21394 00002743 A3[B88D]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21395 00002746 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21396                                  peelfail: ; 25/02/2023
 21397 00002748 F9                      	stc			;AN022; set up carry flag
 21398                                  pcrunch_retn:
 21399 00002749 C3                      	retn
 21400                                  
 21401                                  badret:
 21402                                  	; MSDOS 3.3 & MSDOS 6.0
 21403 0000274A 8A04                    	mov	al,[si]
 21404 0000274C E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21405 0000274F F9                      	stc
 21406 00002750 75F7                    	jnz	short pcrunch_retn
 21407 00002752 30DB                    	xor	bl,bl
 21408 00002754 865C01                  	xchg	bl,[si+1]
 21409                                  	;mov	ah,CHDir ; 3Bh
 21410 00002757 B43B                    	mov	ah,3Bh
 21411 00002759 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21412                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21413                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21414                                  	; 25/02/2023
 21415 0000275B 72E3                    	jc	short pcrunch_cderr
 21416                                  				;AN022; go to error exit 
 21417 0000275D 885C01                  	mov	[si+1],bl
 21418                                  cdsucc:
 21419 00002760 E87E05                  	call	SetRest1
 21420 00002763 46                      	inc	si		; Reset zero
 21421 00002764 8936[4E8C]              	mov	[DestTail],si
 21422                                  	; 25/02/2023
 21423                                  	; MSDOS 6.0
 21424 00002768 9C                      	pushf			;AN015; save flags
 21425 00002769 803E[2C8C]FF            	cmp	byte [DirFlag],-1
 21426                                  				;AN015; don't do parse if in DIR
 21427 0000276E 7408                    	je	short pcrunch_end
 21428                                  				;AN015;
 21429                                  	; MSDOS 3.3 & MSDOS 6.0
 21430 00002770 BF5C00                  	mov	di,FCB  ; 5Ch
 21431                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21432 00002773 B80229                  	mov	ax,2902h	
 21433 00002776 CD21                    	int	21h		; Parse with default drive
 21434                                  			; DOS -	PARSE FILENAME
 21435                                  			; DS:SI	-> string to parse
 21436                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21437                                  			; AL = bit mask	to control parsing
 21438                                  	; MSDOS 3.3
 21439                                  	;retn
 21440                                  
 21441                                  pcrunch_end:
 21442 00002778 9D                      	popf			;AN015; get flags back
 21443 00002779 C3                      	retn
 21444                                  
 21445                                  ;============================================================================
 21446                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21447                                  ;============================================================================
 21448                                  ; 05/10/2018 - Retro DOS v3.0
 21449                                  
 21450                                  ;TITLE	Part7 COMMAND Transient Routines
 21451                                  
 21452                                  ;	More misc routines
 21453                                  
 21454                                  ;---------------------------
 21455                                  ; We can get rid of this switch processing code if we can take
 21456                                  ; care of the remaining two calls to switch, later in the file.
 21457                                  ; However, I have not checked whether or not any other files use
 21458                                  ; switch -- after all, it IS public!
 21459                                  ;---------------------------
 21460                                  
 21461                                  ; 28/03/2023
 21462                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21463                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21464                                  
 21465                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21466                                  
 21467                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21468                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21469                                  
 21470                                  ; ---------------------------------------------------------------------------
 21471                                  
 21472                                  	; 25/02/2023
 21473                                  RETSW:
 21474 0000277A 93                      	xchg	ax,bx		; Put switches in AX
 21475 0000277B C3                      	retn
 21476                                  
 21477                                  ; =============== S U B	R O U T	I N E =======================================
 21478                                  
 21479                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21480                                  SWITCH:
 21481 0000277C 31DB                    	xor	bx,bx		; Initialize - no switches set
 21482                                  SWLOOP:
 21483 0000277E E85DFE                  	call	scanoff		; Skip any delimiters
 21484 00002781 3A06[C98A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21485 00002785 75F3                    	jnz	short RETSW	; No -- we're finished
 21486 00002787 81CB0080                	or	bx,8000h
 21487                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21488 0000278B 46                      	inc	si		; Skip over the switch character
 21489 0000278C E84FFE                  	call	scanoff
 21490 0000278F 3C0D                    	cmp	al,0Dh
 21491 00002791 74E7                    	je	short RETSW	; Oops
 21492 00002793 46                      	inc	si
 21493                                  
 21494                                  	; Convert lower case input to upper case
 21495                                  
 21496 00002794 E852FC                  	call	UPCONV
 21497                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21498                                  
 21499 00002797 BF[5184]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21500                                  				; ("VBAPW" (for MSDOS 3.3))
 21501 0000279A B90600                  	mov	cx,6  ; MSDOS 6.0
 21502                                  	;mov	cx,5  ; MSDOS 3.3
 21503                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21504                                  		
 21505                                  	;nop
 21506                                  		
 21507 0000279D F2AE                    	repne	scasb		; Look for matching switch
 21508 0000279F 7507                    	jnz	short BADSW
 21509 000027A1 B80100                  	mov	ax,1
 21510 000027A4 D3E0                    	shl	ax,cl		; Set a bit for the switch
 21511 000027A6 09C3                    	or	bx,ax
 21512                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21513 000027A8 EBD4                    	jmp	short SWLOOP
 21514                                  ;BADSW:
 21515                                  	;jmp	short SWLOOP
 21516                                  ;DRVBAD:
 21517                                  ;	mov	dx,baddrv_ptr
 21518                                  ;	jmp	cerror
 21519                                  EXTERNALJ:
 21520 000027AA E90501                  	jmp	EXTERNAL
 21521                                  FNDCOM:				; search the internal command table
 21522 000027AD 08C0                    	or	al,al		; Get real length of first arg
 21523 000027AF 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21524                                  				;  to be external.
 21525                                  ; barryf code starts here
 21526                                  
 21527 000027B1 E82703                  	call	test_append	; see if APPEND installed
 21528 000027B4 7429                    	jz	short CONTCOM	; not loaded
 21529                                  
 21530                                  APPEND_INTERNAL:
 21531 000027B6 8A0E[4F8B]              	mov	cl,[IDLEN]
 21532 000027BA B500                    	mov	ch,0
 21533 000027BC 890E[248C]              	mov	[PathPos],cx
 21534                                  	
 21535                                  	; 25/02/2023	
 21536                                  	; MSDOS 6.0
 21537 000027C0 FE06[BA8D]              	inc 	byte [append_exec]
 21538                                  				;AN041; set APPEND to ON
 21539 000027C4 E8B603                  	call	IOSET		; re-direct the o'l io
 21540                                  
 21541 000027C7 BE[4F8B]                	mov	si,IDLEN	; address command name, DS already set	
 21542 000027CA BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21543                                  		
 21544                                  	; MSDOS 6.0
 21545 000027CD BF[D94D]                	mov	di,append_parse
 21546                                  				;AN010; Get the entry point for PARSE for APPEND
 21547                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21548 000027D0 B801AE                  	mov	ax,0AE01h
 21549 000027D3 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21550                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21551                                  			; DX = FFFFh, DS:SI -> buffer
 21552                                  			; Return: buffer at DS:SI filled with a	length byte
 21553                                  			; followed by the uppercase internal command
 21554                                  			; to execute (if length not 0)
 21555                                  	; 25/02/2023
 21556                                  	; INT 2Fh
 21557                                  	; 	AX = AE01h
 21558                                  	; entry:
 21559                                  	; 	DX = magic value FFFFh
 21560                                  	; 	CH = 00h
 21561                                  	; 	CL = length of command name
 21562                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21563                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21564                                  	; return:
 21565                                  	;	DS:SI buffer updated
 21566                                  	;	if length byte is nonzero, the following bytes contain
 21567                                  	;	the uppercase internal command to execute and the command line
 21568                                  	; 	buffer contains the command's parameters
 21569                                  	;	(the first DS:[SI] bytes are ignored)
 21570                                  	;
 21571                                  	; Format of COMMAND.COM command line buffer:
 21572                                  	;	Offset  Size    Description
 21573                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21574                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21575                                  	;	N BYTEs command line text, terminated by 0Dh
 21576                                  	;
 21577                                  	; Format of command name buffer:
 21578                                  	;	Offset  Size    Description
 21579                                  	;	00h     BYTE    length of command name
 21580                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21581                                  
 21582 000027D5 803E[4F8B]00            	cmp	byte [IDLEN],0 ; execute requested
 21583 000027DA 7503                    	jne	short CONTCOM
 21584 000027DC E9A300                  	jmp	CMD_DONE
 21585                                  
 21586                                  	;nop
 21587                                  CONTCOM:			; continue with internal scan
 21588 000027DF BF[D082]                	mov	di,COMTAB
 21589 000027E2 31C9                    	xor	cx,cx
 21590                                  FINDCOM:
 21591 000027E4 BE[508B]                	mov	si,ID		; pointer to command argument
 21592 000027E7 8A0D                    	mov	cl,[di]		; load length of internal command
 21593 000027E9 47                      	inc	di		; advance past length
 21594 000027EA E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21595 000027EC 3A0E[4F8B]              	cmp	cl,[IDLEN]	; that of the command argument
 21596 000027F0 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21597 000027F2 890E[248C]              	mov	[PathPos],cx	; store length of command
 21598 000027F6 F3A6                    	repe	cmpsb
 21599                                  ABCD:					
 21600 000027F8 9F                      	lahf			; save the good ol' flags
 21601 000027F9 01CF                    	add	di,cx		; skip over remaining internal, if any
 21602 000027FB 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21603 000027FD A2[D78A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21604 00002800 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21605 00002801 8B1D                    	mov	bx,[di]		; load internal command address
 21606 00002803 47                      	inc	di		; skip over the puppy
 21607 00002804 47                      	inc	di
 21608                                  		
 21609                                  	; MSDOS 6.0
 21610 00002805 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21611 00002807 47                      	inc	di
 21612 00002808 47                      	inc	di
 21613 00002809 9E                      	sahf			; remember those flags?
 21614 0000280A 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21615                                  
 21616                                  ; All messages get redirected.
 21617                                  
 21618 0000280C 803E[BA8D]00            	cmp     byte [append_exec],0
 21619                                  				;AN041; APPEND just executed?
 21620 00002811 7503                    	jnz 	short DONT_SET_IO
 21621                                  				;AN041; Yes - this junk is already set
 21622 00002813 E86703                  	call	IOSET		; re-direct the ol' i/o
 21623                                  
 21624                                  DONT_SET_IO:			;AN041;
 21625                                  
 21626                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21627                                  ; respond to /? only if it is the only command-line argument.
 21628                                  
 21629 00002816 A1[DC8A]                	mov	ax,[COMSW]	; AX = switches after command
 21630 00002819 0B06[E28A]              	or	ax,[AllSwitch]	; AX = all switches
 21631                                  	;and	ax,SwitchQues	
 21632 0000281D 83E020                  	and	ax,20h
 21633 00002820 7426                    	jz	short DRIVE_CHECK
 21634                                  				; /? not in command line
 21635 00002822 F606[D78A]04            	test	byte [CHKDRV],4	
 21636                                  	;test	byte [CHKDRV],fLimitHelp
 21637 00002827 7407                    	jz	short DO_HELP	; /? allowed in combination
 21638                                  
 21639                                  ; Make sure /? is the only argument on the command line.
 21640                                  
 21641 00002829 833E[9490]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21642 0000282E 7518                    	jne	short DRIVE_CHECK
 21643                                  				; /? not only arg - ignore
 21644                                  
 21645                                  ; Note: this is all the check we need, even against things like /??.
 21646                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21647                                  
 21648                                  DO_HELP:
 21649                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21650                                  
 21651 00002830 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21652                                      	;mov	ax,no_subst	; AL = no subst's code
 21653 00002832 B80000                  	mov	ax,0
 21654 00002835 50                      	push	ax		; build subst block on stack
 21655                                  
 21656                                  NEXT_HELP_MSG:
 21657 00002836 AD                      	lodsw			; AX = help msg # or zero
 21658 00002837 09C0                    	or	ax,ax
 21659 00002839 7409                    	jz	short HELP_DONE
 21660 0000283B 50                      	push	ax		; SS:SP = ptr to subst block
 21661                                  				; (msg # and no_subst byte)
 21662                                  ;; We assume DS = SS.
 21663                                  	
 21664 0000283C 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21665 0000283E E8AE25                  	call	std_printf	; display help message	
 21666 00002841 58                      	pop	ax		; remove msg # from stack
 21667 00002842 EBF2                    	jmp	short NEXT_HELP_MSG
 21668                                  
 21669                                  HELP_DONE:
 21670 00002844 58                      	pop	ax		; clean up stack
 21671 00002845 E9BCD8                  	jmp	TCOMMAND	
 21672                                  
 21673                                  	; 25/02/2023
 21674                                  	; MSDOS 3.3
 21675                                  	;sahf			; remember those flags?
 21676                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21677                                  	;call	IOSET		; re-direct the ol' i/o
 21678                                  
 21679                                  DRIVE_CHECK:
 21680 00002848 F606[D78A]01            	test	byte [CHKDRV],1
 21681                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21682                                  				; did we wanna check those drives?
 21683 0000284D 7411                    	jz	short NOCHECK
 21684 0000284F A0[DA8A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21685 00002852 0A06[DB8A]              	or	al,[PARM2]	; us whether those drives were OK
 21686 00002856 3CFF                    	cmp	al,-1
 21687 00002858 7506                    	jne	short NOCHECK
 21688                                  	;jmp	DRVBAD
 21689                                  	; 25/02/2023
 21690                                  DRVBAD:
 21691 0000285A BA[777F]                	mov	dx,baddrv_ptr
 21692 0000285D E9F200                  	jmp	cerror
 21693                                  
 21694                                  ; The user may have omitted the space between the command and its arguments.
 21695                                  ; We need to copy the remainder of the user's command line into the buffer.
 21696                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21697                                  ; into the command line at 80.
 21698                                  
 21699                                  NOCHECK:
 21700 00002860 E85B02                  	call	cmd_copy
 21701                                  SWITCHECK:
 21702                                  	;test	byte [CHKDRV],2
 21703 00002863 F606[D78A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21704                                  				; Does the command take switches
 21705 00002868 7516                    	jnz	short REALWORK	; Yes, process the command
 21706 0000286A E82F00                  	call	noswit		; No, check to see if any switches
 21707 0000286D 7511                    	jnz	short REALWORK	; None, process the command
 21708                                  
 21709                                  	; MSDOS 6.0
 21710                                  	;mov	byte [msg_disp_class],2
 21711 0000286F C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class
 21712                                  				;AN000; set up parse error msg class
 21713 00002874 BA[1B7F]                	mov	dx,extend_buf_ptr	
 21714                                  				;AC000; get extended message pointer
 21715                                  	;mov	word [extend_buf_ptr],3
 21716 00002877 C706[1B7F]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21717                                  				;AN000; get "Invalid switch" message number
 21718 0000287D E9D200                  	jmp	cerror		; Print error and chill out...
 21719                                  
 21720                                  	; 25/02/2023
 21721                                  	; MSDOS 3.3
 21722                                  	;mov	dx,BADPARMPTR
 21723                                  	;jmp	CERROR
 21724                                  
 21725                                  REALWORK:
 21726 00002880 FFD3                    	call	bx		; do some real work, at last
 21727                                  
 21728                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21729                                  ; otherwise, go get another command.
 21730                                  
 21731                                  CMD_DONE:
 21732 00002882 0E                      	push	cs		; g  restore data segment
 21733 00002883 1F                      	pop	ds		; g
 21734 00002884 1E                      	push	ds
 21735 00002885 8E1E[C58A]              	mov	ds,[RESSEG]	; g  save data segment
 21736                                  	;cmp	byte [Call_Flag],1
 21737                                  				; G  Is a call in progress?
 21738 00002889 803E[9901]01            	cmp	byte [Call_Flag],call_in_progress
 21739 0000288E C606[9901]00            	mov	byte [Call_Flag],0
 21740                                  				; G  Either way, reset flag
 21741 00002893 1F                      	pop	ds		; g  get data segment back
 21742 00002894 7403                    	jz	short INCALL	; G
 21743 00002896 E96BD8                  	jmp	TCOMMAND	; chill out...
 21744                                  INCALL:
 21745 00002899 E93BDA                  	jmp	DOCOM1
 21746                                  
 21747                                  ; =============== S U B	R O U T	I N E =======================================
 21748                                  
 21749                                  	; 25/02/2023
 21750                                  noswit:
 21751 0000289C 57                      	push	di		; Save di
 21752 0000289D BF8100                  	mov	di,81h		; di = ptr to command args
 21753 000028A0 BE8000                  	mov	si,80h		; Get address of length of command args
 21754 000028A3 AC                      	lodsb			; Load length
 21755 000028A4 88C1                    	mov	cl,al		; Move length to cl
 21756 000028A6 30ED                    	xor	ch,ch		; Zero ch
 21757 000028A8 2EA0[C98A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21758                                  	;cmp	al,0		; Turn off ZF
 21759                                  	; 25/02/2023
 21760 000028AC 20C0                    	and	al,al
 21761 000028AE F2AE                    	repne	scasb		; Scan for a switch character and return
 21762 000028B0 5F                      	pop	di		;  with ZF set if one was found
 21763 000028B1 C3                      	retn
 21764                                  
 21765                                  ; ---------------------------------------------------------------------------
 21766                                  
 21767                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21768                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21769                                  
 21770                                  EXTERNAL:
 21771 000028B2 E82602                  	call	test_append	; check to see if append installed
 21772 000028B5 7403                    	jz	short NOT_BARRYF
 21773                                  				; no - truly external command
 21774 000028B7 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21775                                  
 21776                                  NOT_BARRYF:
 21777 000028BA 2EC606[D88A]00          	mov	byte [cs:FILTYP],0
 21778 000028C0 2E8A16[E58A]            	mov	dl,[cs:SPECDRV]
 21779 000028C5 2E8816[4F8B]            	mov	[cs:IDLEN],dl
 21780 000028CA 2EC606[478C]00          	mov	byte [cs:ROM_CALL],0
 21781 000028D0 52                      	push	dx
 21782 000028D1 BA[4F8B]                	mov	dx,IDLEN
 21783 000028D4 E823DB                  	call	ROM_SCAN
 21784 000028D7 5A                      	pop	dx
 21785                                  	;jnc	short POSTSAVE
 21786 000028D8 7305                    	jnc	short DO_SCAN
 21787 000028DA 2EFE06[478C]            	inc	byte [cs:ROM_CALL]
 21788                                  	;jmp	short POSTSAVE
 21789                                  
 21790                                  	;nop
 21791                                  DO_SCAN:
 21792                                  POSTSAVE:
 21793 000028DF BF[ED89]                	mov	di,EXECPATH
 21794 000028E2 C60500                  	mov	byte [di],0	; Initialize to current directory
 21795                                  	
 21796 000028E5 2E803E[478C]00          	cmp	byte [cs:ROM_CALL],0
 21797                                  	;jz	short RESEARCH
 21798                                  	; 25/02/2023
 21799                                  	;jmp	short NEOEXECUTE
 21800 000028EB 750F                    	jnz	short NEOEXECUTE	
 21801                                  
 21802                                  	;nop
 21803                                  RESEARCH:
 21804 000028ED E87008                  	call	path_search	; find the mother (result in execpath)
 21805 000028F0 09C0                    	or	ax,ax		; did we find anything?
 21806                                  	;jz	short BADCOMJ45	; null means no (sob)
 21807                                  	; 25/02/2023
 21808 000028F2 7459                    	jz	short BADCOM
 21809 000028F4 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21810                                  				; fuckin' sixteen-bit machine ought
 21811                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21812                                  				; DISPLACEMENT!!
 21813                                  	;;jmp	short NEOEXECUTE
 21814                                  	;jmp	short EXECUTE	
 21815                                  	; 25/02/2023
 21816 000028F7 7D03                    	jnl	short EXECUTE ; jge
 21817                                  
 21818                                  	; 02H is .bat
 21819                                  
 21820                                  	;nop
 21821                                  BATCOMJ:
 21822 000028F9 E98EDE                  	jmp	BATCOM
 21823                                  
 21824                                  	; 25/02/2023
 21825                                  ;BADCOMJ45:
 21826                                  	;jmp	short BADCOM
 21827                                  
 21828                                  	;nop
 21829                                  EXECUTE:
 21830                                  NEOEXECUTE:
 21831 000028FC E87E02                  	call	IOSET
 21832                                  
 21833                                  ; MSDOS 6.0
 21834                                  ;M051
 21835                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21836                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21837                                  ;After a close, this would still leave one open active resulting in sharing
 21838                                  ;errors on subsequent opens of the redirected file.
 21839                                  
 21840                                  LH_EXECUTE:			;M051	
 21841 000028FF 8E06[D58A]              	mov	es,[TRAN_TPA]
 21842                                  	;mov	ah,DEALLOC ; 49h
 21843 00002903 B449                    	mov	ah,49h
 21844 00002905 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21845                                  			; ES = segment address of area to be freed
 21846                                  				; Now running in "free" space
 21847 00002907 8E06[C58A]              	mov	es,[RESSEG]
 21848 0000290B 26FE06[8401]            	inc	byte [es:ExtCom] ; Indicate external command
 21849 00002910 26C606[8C01]00          	mov	byte [es:RestDir],0 
 21850                                  				; Since USERDIR1 is in transient, insure
 21851                                  				; this flag value for re-entry to COMMAND
 21852                                  	; MSDOS 6.0
 21853 00002916 BE[ED89]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21854 00002919 BF[4B03]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21855                                  	;mov	cx,LENMSGORPATHBUF
 21856 0000291C B95000                  	mov	cx,80
 21857 0000291F FC                      	cld
 21858 00002920 F3A4                    	rep	movsb		; copy program pathname to resident
 21859                                  
 21860                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21861 00002922 BF5C00                  	mov	di,FCB ; 5Ch
 21862 00002925 89FE                    	mov	si,di
 21863                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21864 00002927 B152                    	mov	cl,82 ; 25/02/2023
 21865 00002929 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21866                                  	
 21867                                  	; 25/02/2023
 21868                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21869                                  	; MSDOS 6.0 (& 5.0)
 21870                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21871 0000292B BA[4B03]                	mov	dx,SafePathBuffer
 21872 0000292E 06                      	push	es
 21873 0000292F 1F                      	pop	ds
 21874                                  
 21875                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21876 00002930 BB[2703]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21877                                  	;mov	ax,EXEC*256 ; 4B00h
 21878 00002933 B8004B                  	mov	ax,4B00h
 21879                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21880 00002936 2EF606[478C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21881 0000293C 7403                    	jz	short OK_EXEC
 21882 0000293E E932DB                  	jmp	ROM_EXEC
 21883                                  
 21884                                  OK_EXEC:
 21885                                  
 21886                                  ; we are now running in free space. Anything we do from here on may get
 21887                                  ; trashed. Move the stack (also in free space) to allocated space because
 21888                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21889                                  
 21890 00002941 8CC1                    	mov	cx,es
 21891 00002943 8ED1                    	mov	ss,cx
 21892 00002945 BC[2004]                	mov	sp,RStack
 21893                                  	; MSDOS 3.3
 21894                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21895                                  	; 25/02/2023
 21896                                  	; MSDOS 6.0
 21897 00002948 2EFF2E[CB8A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21898                                  
 21899                                  ; ---------------------------------------------------------------------------
 21900                                  
 21901                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21902                                  BADCOM:
 21903 0000294D 0E                      	push	cs
 21904 0000294E 1F                      	pop	ds
 21905 0000294F BA[3E7F]                	mov	dx,BADNAM_PTR
 21906                                  cerror:		
 21907 00002952 E89224                  	call	std_eprintf
 21908 00002955 E9ACD7                  	jmp	TCOMMAND
 21909                                  
 21910                                  ; =============== S U B	R O U T	I N E =======================================
 21911                                  
 21912                                  ; Prescan converts the input buffer into a canonicalized form.
 21913                                  ; All redirections and pipes are removed.
 21914                                  
 21915                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21916                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21917                                  
 21918                                  PRESCAN:
 21919 00002958 31C9                    	xor	cx,cx
 21920 0000295A 8E06[C58A]              	mov	es,[RESSEG]
 21921 0000295E BE[2689]                	mov	si,COMBUF+2
 21922 00002961 89F7                    	mov	di,si
 21923                                  COUNTQUOTES:
 21924 00002963 AC                      	lodsb			; get a byte
 21925 00002964 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21926 00002966 7504                    	jne	short COUNTEND	; no, try for end of road
 21927 00002968 FEC5                    	inc	ch		; bump count
 21928 0000296A EBF7                    	jmp	short COUNTQUOTES
 21929                                  				; go get next char
 21930                                  COUNTEND:
 21931 0000296C 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21932 0000296E 75F3                    	jne	short COUNTQUOTES
 21933                                  				; no, go back for next char
 21934                                  	; 26/02/2023
 21935                                  	; MSDOS 5.0 (& 6.0)
 21936 00002970 51                      	push	cx		; save count
 21937 00002971 89FE                    	mov	si,di		; restore pointer to begining
 21938                                  KanjiScan:
 21939 00002973 AC                      	lodsb			; get a byte
 21940 00002974 E848FA                  	call	testkanj	; is it a leadin byte
 21941 00002977 740F                    	jz	short KanjiQuote
 21942                                  				; no, check for quotes
 21943 00002979 88C4                    	mov	ah,al		; save leadin
 21944 0000297B AC                      	lodsb			; get trailing byte
 21945 0000297C 3D2020                  	cmp	ax,2020h
 21946                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21947 0000297F 75F2                    	jne	short KanjiScan	; no, go get next
 21948 00002981 C744FE2020              	mov	word [si-2],2020h
 21949                                  				; replace with spaces
 21950 00002986 EBEB                    	jmp	short KanjiScan	; go get next char
 21951                                  	
 21952                                  KanjiQuote:
 21953 00002988 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21954 0000298A 750D                    	jne	short KanjiEnd	; no, check for end
 21955 0000298C FECD                    	dec	ch		; drop count
 21956 0000298E 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21957                                  KanjiQuoteLoop:
 21958 00002990 AC                      	lodsb			; get next byte
 21959 00002991 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21960 00002993 75FB                    	jne	short KanjiQuoteLoop
 21961                                  				; no, get another
 21962 00002995 FECD                    	dec	ch		; yes, drop count
 21963 00002997 EBDA                    	jmp	short KanjiScan	; go get next char
 21964                                  KanjiEnd:
 21965 00002999 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21966 0000299B 75D6                    	jne	short KanjiScan	; go back to beginning
 21967 0000299D 59                      	pop	cx		; get back original count
 21968                                  	; 26/04/2023
 21969 0000299E 89FE                    	mov	si,di		; restore pointer to beginning
 21970                                  	
 21971                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21972                                  PRESCANLP:
 21973 000029A0 AC                      	lodsb
 21974                                  	; 26/02/2023
 21975 000029A1 E81BFA                  	call	testkanj
 21976 000029A4 740C                    	jz	short NOTKANJ6
 21977                                  	; MSDOS 6.0
 21978 000029A6 8805                    	mov	[di],al
 21979 000029A8 47                      	inc	di		; fake STOSB into DS
 21980 000029A9 AC                      	lodsb			; grab second byte
 21981 000029AA 8805                    	mov	[di],al		; fake stosb into DS
 21982 000029AC FEC1                    	inc	cl
 21983 000029AE FEC1                    	inc	cl
 21984 000029B0 EBEE                    	jmp	short PRESCANLP
 21985                                  
 21986                                  NOTKANJ6:
 21987                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21988 000029B2 3C22                    	cmp	al,'"'	; 22h	; " character
 21989 000029B4 7510                    	jne	short TRYGREATER
 21990 000029B6 FECD                    	dec	ch
 21991 000029B8 740C                    	jz	short TRYGREATER
 21992                                  QLOOP:
 21993 000029BA 8805                    	mov	[di],al
 21994 000029BC 47                      	inc	di
 21995 000029BD FEC1                    	inc	cl
 21996 000029BF AC                      	lodsb
 21997 000029C0 3C22                    	cmp	al,'"'		; " character
 21998 000029C2 75F6                    	jne	short QLOOP
 21999 000029C4 FECD                    	dec	ch
 22000                                  TRYGREATER:
 22001 000029C6 3C3E                    	cmp	al,'>' ; 3Eh
 22002                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 22003                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 22004 000029C8 7557                    	jne	short NOOUT
 22005                                  
 22006                                  ; We have found a ">" char. We need to see if there is another ">"
 22007                                  ; following it.
 22008                                  
 22009 000029CA 3804                    	cmp	[si],al
 22010 000029CC 7506                    	jne	short NOAPPND
 22011 000029CE AC                      	lodsb
 22012 000029CF 26FE06[AE01]            	inc	byte [es:Re_Out_App] ; Flag >>
 22013                                  NOAPPND:
 22014                                  ; Now we attempt to find the file name. First, scan off all whitespace
 22015                                  
 22016 000029D4 E807FC                  	call	scanoff
 22017                                  
 22018                                  	; 26/02/2023
 22019                                  	; MSDOS 6.0
 22020 000029D7 3C3C                    	cmp	al,'<' ; 3Ch
 22021                                  	;cmp	al,labracket	;AN040; was there no filename?
 22022 000029D9 7404                    	je	short REOUT_ERRSET
 22023                                  				;AN040; yes - set up error
 22024                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22025 000029DB 3C0D                    	cmp	al,0Dh
 22026 000029DD 750D                    	jnz	short GOTREOFIL
 22027                                  
 22028                                  ; There was no file present. Set us up at end-of-line.
 22029                                  
 22030                                  REOUT_ERRSET:			;AN040; set up for an error
 22031 000029DF C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 22032 000029E2 26C706[AF01]0900        	mov	word [es:Re_OutStr],9
 22033                                  				; Cause an error later
 22034 000029E9 E9A900                  	jmp	PRESCANEND
 22035                                  
 22036                                  GOTREOFIL:
 22037 000029EC 57                      	push	di
 22038                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 22039 000029ED BF[AF01]                	mov	di,Re_OutStr
 22040 000029F0 89FB                    	mov	bx,di
 22041 000029F2 06                      	push	es
 22042                                  
 22043                                  	; 26/02/2023
 22044                                  	; MSDOS 6.0
 22045                                  SETREOUTSTR:			; Get the output redirection name
 22046                                  				; MSKK06 07/14/89
 22047 000029F3 51                      	push	cx		; save cx
 22048 000029F4 B94D00                  	mov	cx,64+13	; CX = max string length
 22049                                  SETREOUTSTR_LOOP:
 22050 000029F7 AC                      	lodsb
 22051 000029F8 3C0D                    	cmp	al,0Dh
 22052 000029FA 741A                    	je	short GOTRESTR_J
 22053 000029FC E8E7FB                  	call	DELIM
 22054 000029FF 7415                    	jz	short GOTRESTR_J
 22055 00002A01 3A06[C98A]              	cmp	al,[SWITCHAR]
 22056 00002A05 740F                    	je	short GOTRESTR_J
 22057 00002A07 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 22058 00002A09 7413                    	je	short PIPEERRSYNJ5_J
 22059                                  				;AN033; Yes - get out quick - or system crashes
 22060 00002A0B 3C3C                    	cmp	al,'<' ; 3Ch
 22061                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 22062 00002A0D 7404                    	je	short ABRACKET_TERM
 22063                                  				;AN002; yes - end of string
 22064 00002A0F 3C3E                    	cmp	al,'>' ; 3Eh
 22065                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 22066 00002A11 7506                    	jne	short NO_ABRACKET
 22067                                  				;AN002; no - not end of string
 22068                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 22069 00002A13 4E                      	dec	si		;AN002; back up over symbol
 22070 00002A14 B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 22071                                  GOTRESTR_J:
 22072 00002A16 59                      	pop	cx		; MSKK06 07/14/89
 22073 00002A17 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 22074                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 22075 00002A19 AA                      	stosb			; store it into resgroup
 22076 00002A1A E2DB                    	loop	SETREOUTSTR_LOOP
 22077                                  				; MSKK06 07/14/89
 22078 00002A1C EBF8                    	jmp	short GOTRESTR_J
 22079                                  PIPEERRSYNJ5_J:
 22080 00002A1E 59                      	pop	cx		; recover CX
 22081 00002A1F EB4B                    	jmp	short PIPEERRSYNJ5
 22082                                  
 22083                                  	; 26/02/2023
 22084                                  ;	; MSDOS 3.3
 22085                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 22086                                  ;	lodsb
 22087                                  ;	cmp	al,0Dh
 22088                                  ;	jz	short GOTRESTR
 22089                                  ;	call	DELIM
 22090                                  ;	jz	short GOTRESTR
 22091                                  ;	cmp	al,[SWITCHAR]
 22092                                  ;	je	short GOTRESTR
 22093                                  ;	cmp	al,'"'
 22094                                  ;	jne	short NO_ABRACKET
 22095                                  ;	dec	ch
 22096                                  ;NO_ABRACKET:
 22097                                  ;	stosb
 22098                                  ;	jmp	short SETREOUTSTR_LOOP
 22099                                  
 22100                                  NOOUT:
 22101                                  	; 26/02/2023
 22102                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22103 00002A21 3C3C                    	cmp	al, '<' ; 3Ch
 22104                                  	;cmp	al,labracket	; MSDOS 6.0
 22105                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 22106 00002A23 7523                    	jne	short CHKPIPE
 22107 00002A25 89F3                    	mov	bx,si		; Save loc of "<"
 22108 00002A27 E8B4FB                  	call	scanoff
 22109                                  	; MSDOS 6.0
 22110 00002A2A 3C3E                    	cmp	al,'>' ; 3Eh
 22111                                  	;cmp	al,rabracket	;AN040; was there no filename?
 22112 00002A2C 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 22113                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22114 00002A2E 3C0D                    	cmp	al,0Dh
 22115 00002A30 750B                    	jne	short GOTREIFIL
 22116                                  REIN_ERRSET:			;AN040; set up for error
 22117 00002A32 C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 22118 00002A35 C706[708A]0900          	mov	word [RE_INSTR],9 
 22119                                  				; Cause an error later
 22120 00002A3B EB58                    	jmp	short PRESCANEND
 22121                                  GOTREIFIL:
 22122 00002A3D 57                      	push	di
 22123 00002A3E BF[708A]                	mov	di,RE_INSTR
 22124 00002A41 89FB                    	mov	bx,di
 22125 00002A43 06                      	push	es
 22126 00002A44 0E                      	push	cs
 22127 00002A45 07                      	pop	es		; store in TRANGROUP
 22128                                  	; 26/04/2023
 22129                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 22130 00002A46 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 22131                                  				; Get the input redirection name
 22132                                  CHKPIPE:
 22133 00002A48 88C4                    	mov	ah,al
 22134                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22135 00002A4A 80FC7C                  	cmp	ah,'|' ; 7Ch
 22136                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 22137                                  	;je	short ISPIPE3
 22138                                  	;; MSDOS 6.0
 22139                                  	;cmp	ah,'|' ; 7Ch
 22140                                  	;;cmp	al,vbar ; 7Ch
 22141                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 22142 00002A4D 7539                    	jne	short CONTPRESCAN
 22143                                  ISPIPE3:
 22144                                  ; Only push the echo flag if we are entering the pipe for the first time.
 22145                                  
 22146 00002A4F 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22147 00002A55 7505                    	jne	short NOECHOPUSH
 22148 00002A57 26D026[8801]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 22149                                  NOECHOPUSH:
 22150 00002A5C 26FE06[0002]            	inc	byte [es:PipeFlag]
 22151 00002A61 E87AFB                  	call	scanoff
 22152 00002A64 3C0D                    	cmp	al,0Dh
 22153 00002A66 7404                    	je	short PIPEERRSYNJ5
 22154                                  	; 26/02/2023
 22155 00002A68 3C7C                    	cmp	al,'|' ; 7Ch
 22156                                  	;cmp	al,ALTPIPECHR ; 7Ch
 22157                                  	;je	short PIPEERRSYNJ5
 22158                                  	;; MSDOS 6.0
 22159                                  	;cmp	al,'|' ; 7Ch
 22160                                  	;;cmp	al,vbar ; 7Ch
 22161                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 22162 00002A6A 751C                    	jne	short CONTPRESCAN
 22163                                  
 22164                                  PIPEERRSYNJ5:
 22165 00002A6C 06                      	push	es
 22166 00002A6D 1F                      	pop	ds
 22167 00002A6E E99C02                  	jmp	PIPEERRSYN
 22168                                  
 22169                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 22170                                  ; than just a : in the redir string.
 22171                                  
 22172                                  GOTRESTR:
 22173 00002A71 86E0                    	xchg	ah,al
 22174 00002A73 B03A                    	mov	al,':' ; 3Ah
 22175 00002A75 29FB                    	sub	bx,di		; compute negative of number of chars
 22176 00002A77 83FBFF                  	cmp	bx,-1		; is there just a :?
 22177 00002A7A 7407                    	je	short NOTRAILCOL ; yep, don't change
 22178 00002A7C 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 22179 00002A80 7501                    	jne	short NOTRAILCOL
 22180 00002A82 4F                      	dec	di		; Back up over trailing ':'
 22181                                  NOTRAILCOL:
 22182 00002A83 30C0                    	xor	al,al
 22183 00002A85 AA                      	stosb			; NUL terminate the string
 22184 00002A86 07                      	pop	es
 22185 00002A87 5F                      	pop	di		; Remember the start
 22186                                  CONTPRESCAN:
 22187 00002A88 8825                    	mov	[di],ah		; "delete" the redirection string
 22188 00002A8A 47                      	inc	di
 22189 00002A8B 80FC0D                  	cmp	ah,0Dh
 22190 00002A8E 7405                    	je	short PRESCANEND
 22191 00002A90 FEC1                    	inc	cl
 22192 00002A92 E90BFF                  	jmp	PRESCANLP
 22193                                  PRESCANEND:
 22194 00002A95 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22195 00002A9B 7414                    	jz	short ISNOPIPE
 22196                                  
 22197                                  	; 26/02/2023
 22198                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 22199                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 22200                                  	;;			; (EndInit+160]
 22201                                  	;mov	di,offset RESGROUP:PIPESTR
 22202 00002A9D BF[A202]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 22203                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 22204                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 22205 00002AA0 26893E[A002]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 22206                                  	
 22207 00002AA5 BE[2689]                	mov	si,COMBUF+2
 22208 00002AA8 E833FB                  	call	scanoff
 22209                                  PIPESETLP:			; Transfer the pipe into the resident
 22210 00002AAB AC                      	lodsb			; pipe buffer
 22211 00002AAC AA                      	stosb
 22212 00002AAD 3C0D                    	cmp	al,0Dh
 22213 00002AAF 75FA                    	jnz	short PIPESETLP
 22214                                  ISNOPIPE:
 22215 00002AB1 880E[2589]              	mov	[COMBUF+1],cl
 22216 00002AB5 26803E[0002]00          	cmp	byte [es:PipeFlag],0
 22217 00002ABB 0E                      	push	cs
 22218 00002ABC 07                      	pop	es
 22219 00002ABD C3                      	retn
 22220                                  
 22221                                  ; =============== S U B	R O U T	I N E =======================================
 22222                                  
 22223                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22224                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 22225                                  cmd_copy:
 22226 00002ABE BE[2689]                	mov	si,COMBUF+2
 22227 00002AC1 E81AFB                  	call	scanoff		; advance past separators...
 22228 00002AC4 0336[248C]              	add	si,[PathPos]
 22229 00002AC8 BF8100                  	mov	di,81h
 22230 00002ACB 31C9                    	xor	cx,cx
 22231                                  cmdcopy:
 22232 00002ACD AC                      	lodsb
 22233 00002ACE AA                      	stosb
 22234 00002ACF 3C0D                    	cmp	al,0Dh
 22235 00002AD1 7403                    	je	short copy_done
 22236 00002AD3 41                      	inc	cx
 22237 00002AD4 EBF7                    	jmp	short cmdcopy
 22238                                  copy_done:
 22239 00002AD6 880E8000                	mov	[80h],cl
 22240 00002ADA C3                      	retn
 22241                                  
 22242                                  ; =============== S U B	R O U T	I N E =======================================
 22243                                  
 22244                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22245                                  test_append:
 22246 00002ADB BB[2489]                	mov	bx,COMBUF	; barry can address
 22247 00002ADE BE[4F8B]                	mov	si,IDLEN	; address command name, DS already set 	
 22248 00002AE1 BAFFFF                  	mov	dx,-1
 22249 00002AE4 B800AE                  	mov	ax,0AE00h
 22250 00002AE7 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 22251                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 22252                                  			; DX = FFFFh,[BX -> command line
 22253                                  			; Return: AL = FFh if this command is a TSR extension 
 22254                                  			;		   to COMMAND.COM
 22255                                  			; AL = 00h if the command should be executed as	usual
 22256                                  	;cmp	al,0
 22257 00002AE9 08C0                    	or	al,al ; 25/02/2023
 22258 00002AEB C3                      	retn
 22259                                  
 22260                                  	; 25/02/2023
 22261                                  	; INT 2Fh
 22262                                  	; 	AX = AE00h
 22263                                  	; entry:
 22264                                  	; 	DX = magic value FFFFh
 22265                                  	; 	CH = FFh
 22266                                  	; 	CL = length of command line tail
 22267                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22268                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22269                                  	; return:
 22270                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 22271                                  	;	AL = 00h if the command should be executed as usual
 22272                                  	;
 22273                                  	; Format of COMMAND.COM command line buffer:
 22274                                  	;	Offset  Size    Description
 22275                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22276                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22277                                  	;	N BYTEs command line text, terminated by 0Dh
 22278                                  	;
 22279                                  	; Format of command name buffer:
 22280                                  	;	Offset  Size    Description
 22281                                  	;	00h     BYTE    length of command name
 22282                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22283                                  
 22284                                  ;============================================================================
 22285                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 22286                                  ;============================================================================
 22287                                  ; 05/10/2018 - Retro DOS v3.0
 22288                                  
 22289                                  ;	More misc routines
 22290                                  
 22291                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 22292                                  
 22293                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22294                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 22295                                  
 22296                                  ; =============== S U B	R O U T	I N E =======================================
 22297                                  
 22298                                  SETPATH:
 22299                                  
 22300                                  ; ENTRY PathPos = ptr to string
 22301                                  ;       PathCnt = length of string
 22302                                  ;
 22303                                  ; EXIT  PathPos = ptr to string after pathname
 22304                                  ;       PathCnt = length of rest of string
 22305                                  ;       DX = ptr to pathname in string, made ASCIIZ
 22306                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 22307                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 22308                                  ;
 22309                                  ;       A null character is dropped at the end of the pathname. If the
 22310                                  ;       character in that spot previously was CR, it is copied into the
 22311                                  ;       following byte. So there must be at least two two character 
 22312                                  ;       positions in the buffer following the pathname.
 22313                                  
 22314                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22315                                  	; 11/06/2023
 22316                                  	; MSDOS 6.0
 22317                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 22318                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 22319                                  
 22320                                  	; 26/02/2023
 22321                                  	; MSDOS 3.3
 22322                                  	;mov	si,80h
 22323                                  	;lodsb
 22324                                  	;xor	ah,ah
 22325                                  	;mov	[PATCNT],ax
 22326                                  	;mov	[PATHPOS],si
 22327                                  GETPATH:
 22328                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22329 00002AEC C606[508C]00            	mov	byte [DestInfo],0
 22330 00002AF1 C606[4C8C]00            	mov	byte [DestIsDir],0
 22331 00002AF6 8B36[248C]              	mov	si,[PathPos]	; SI = ptr to string
 22332 00002AFA 8B0E[228C]              	mov	cx,[PathCnt]	; CX = string length
 22333 00002AFE 89F2                    	mov	dx,si		; DX = ptr to string
 22334 00002B00 E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 22335 00002B02 51                      	push	cx		; save string length
 22336 00002B03 56                      	push	si		; save ptr to string
 22337 00002B04 E875FC                  	call	SWITCH
 22338                                  
 22339                                  ;       After Switch, SI has been scanned past any switches, and
 22340                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22341                                  
 22342 00002B07 A3[268C]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22343 00002B0A 5B                      	pop	bx		; BX = ptr to original string
 22344 00002B0B 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22345 00002B0D 59                      	pop	cx		; CX = string length
 22346 00002B0E 01D9                    	add	cx,bx		; CX = string length from current SI
 22347 00002B10 89F2                    	mov	dx,si		; DX = ptr to current string
 22348                                  SKIPPATH:
 22349                                  	; 26/02/2023
 22350                                  	; MSDOS 6.0
 22351 00002B12 C606[D38D]00            	mov	byte [KPARSE],0
 22352                                  SKIPPATH2:
 22353 00002B17 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22354 00002B19 49                      	dec	cx		; CX = length left after next char
 22355 00002B1A AC                      	lodsb			; AL = next char of string
 22356                                  				; SI = ptr to char after this one
 22357                                  	; 26/02/2023
 22358 00002B1B E8A1F8                  	call	testkanj
 22359 00002B1E 7408                    	jz	short TESTPPSEP
 22360 00002B20 49                      	dec	cx
 22361 00002B21 46                      	inc	si
 22362 00002B22 FE06[D38D]              	inc	byte [KPARSE]
 22363 00002B26 EBEF                    	jmp	short SKIPPATH2
 22364                                  TESTPPSEP:
 22365 00002B28 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 22366 00002B2B 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22367 00002B2D FE06[4C8C]              	inc	byte [DestIsDir]
 22368                                  				; DestIsDir = 1, signalling path char
 22369                                  TESTPMETA:
 22370 00002B31 3C3F                    	cmp	al,'?'
 22371 00002B33 7505                    	jne	short TESTPSTAR	; char is not '?'
 22372 00002B35 800E[508C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22373                                  TESTPSTAR:
 22374 00002B3A 3C2A                    	cmp	al,'*'
 22375                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22376 00002B3C 7505                    	jne	short TESTPDELIM ; char is not '*'
 22377 00002B3E 800E[508C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22378                                  TESTPDELIM:
 22379 00002B43 E8A0FA                  	call	DELIM		; compare AL to all delimiters
 22380 00002B46 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22381 00002B48 3A06[C98A]              	cmp	al,[SWITCHAR]
 22382 00002B4C 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22383                                  PATHDONEDEC:
 22384 00002B4E 4E                      	dec	si		; SI = ptr to char after pathname
 22385                                  PATHDONE:
 22386 00002B4F 30C0                    	xor	al,al		; AL = NULL
 22387 00002B51 8604                    	xchg	al,[si]		; place NULL after pathname
 22388 00002B53 46                      	inc	si		; SI = ptr to byte after NULL
 22389 00002B54 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22390 00002B56 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22391 00002B58 8804                    	mov	[si],al		; save EOL after NULL
 22392                                  NOPSTORE:
 22393 00002B5A 8936[248C]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22394 00002B5E 890E[228C]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22395                                  SETPATH_RETN:
 22396 00002B62 C3                      	retn
 22397                                  
 22398                                  ; ---------------------------------------------------------------------------
 22399                                  
 22400                                  PGETARG:
 22401 00002B63 BE8000                  	mov	si,80h
 22402 00002B66 AC                      	lodsb
 22403 00002B67 08C0                    	or	al,al
 22404 00002B69 74F7                    	jz	short SETPATH_RETN
 22405 00002B6B E80300                  	call	PSCANOFF
 22406 00002B6E 3C0D                    	cmp	al,0Dh
 22407 00002B70 C3                      	retn
 22408                                  
 22409                                  ; ---------------------------------------------------------------------------
 22410                                  
 22411                                  PSCANOFF:
 22412 00002B71 AC                      	lodsb
 22413 00002B72 E871FA                  	call	DELIM
 22414 00002B75 7504                    	jnz	short PSCANOFFD
 22415 00002B77 3C3B                    	cmp	al,';' ; 3Bh
 22416 00002B79 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22417                                  PSCANOFFD:
 22418 00002B7B 4E                      	dec	si		; Point to first non-delimiter
 22419 00002B7C C3                      	retn
 22420                                  
 22421                                  ; =============== S U B	R O U T	I N E =======================================
 22422                                  
 22423                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22424                                  IOSET:
 22425                                  	; ALL REGISTERS PRESERVED
 22426 00002B7D 1E                      	push	ds
 22427 00002B7E 52                      	push	dx
 22428 00002B7F 50                      	push	ax
 22429 00002B80 53                      	push	bx
 22430 00002B81 51                      	push	cx
 22431 00002B82 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
 22432 00002B87 803E[0002]00            	cmp	byte [PipeFlag],0
 22433 00002B8C 750D                    	jne	short NOREDIR
 22434 00002B8E F606[9301]FF            	test	byte [IfFlag],0FFh
 22435 00002B93 7506                    	jnz	short NOREDIR
 22436 00002B95 E88C00                  	call	TESTDOREIN
 22437 00002B98 E80600                  	call	TESTDOREOUT
 22438                                  NOREDIR:
 22439 00002B9B 59                      	pop	cx
 22440 00002B9C 5B                      	pop	bx
 22441 00002B9D 58                      	pop	ax
 22442 00002B9E 5A                      	pop	dx
 22443 00002B9F 1F                      	pop	ds
 22444                                  IOSET_RETN:	; 06/08/2024
 22445 00002BA0 C3                      	retn
 22446                                  
 22447                                  ; =============== S U B	R O U T	I N E =======================================
 22448                                  
 22449                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22450                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22451                                  	; 06/08/2024
 22452                                  TESTDOREOUT:
 22453 00002BA1 803E[AF01]00            	cmp	byte [Re_OutStr],0
 22454                                  	;je	short NOREOUT  ; MSDOS 3.3
 22455                                  	; 26/02/2023
 22456                                  	;jne	short REOUTEXISTS
 22457                                  	;jmp	NOREOUT
 22458                                  	; 06/08/2024
 22459 00002BA6 74F8                    	jz	short IOSET_RETN
 22460                                  REOUTEXISTS:
 22461 00002BA8 803E[AE01]00            	cmp	byte [Re_Out_App],0
 22462 00002BAD 745D                    	je	short REOUTCRT
 22463                                  
 22464 00002BAF BA[AF01]                	mov	dx,Re_OutStr
 22465                                  
 22466                                  	; 26/02/2023
 22467                                  	; MSDOS 6.0
 22468                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22469 00002BB2 B8023D                  	mov	ax,3D02h
 22470                                  	; MSDOS 3.3
 22471                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22472                                  	
 22473                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22474 00002BB5 50                      	push	ax
 22475 00002BB6 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22476                                  			; DS:DX	-> ASCIZ filename
 22477                                  			; AL = access mode
 22478                                  			; 1 - write
 22479 00002BB8 5B                      	pop	bx
 22480 00002BB9 724B                    	jc	short OpenWriteError
 22481                                  
 22482                                  	; 26/02/2023
 22483                                  	; MSDOS 6.0
 22484 00002BBB 89C3                    	mov	bx,ax
 22485                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22486 00002BBD B80044                  	mov	ax,4400h
 22487 00002BC0 CD21                    	int	21h			;AN035;
 22488                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22489                                  			; BX = file or device handle
 22490 00002BC2 F6C280                  	test	dl,80h
 22491                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22492 00002BC5 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22493                                  
 22494                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22495 00002BC7 B80242                  	mov	ax,4202h
 22496 00002BCA B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22497 00002BCD 89CA                    	mov	dx,cx			;AC011;
 22498 00002BCF CD21                    	int	21h
 22499                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22500                                  			; AL = method: offset from end of file
 22501 00002BD1 0E                      	push	cs			;AN011; Get transient seg to DS
 22502 00002BD2 1F                      	pop	ds			;AN011;
 22503                                  
 22504                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22505 00002BD3 B8003F                  	mov	ax,3F00h
 22506 00002BD6 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22507 00002BD9 BA[448C]                	mov	dx,One_Char_Val		;AN011;
 22508 00002BDC CD21                    	int	21h			;AN011;
 22509                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22510                                  			; BX = file handle, CX = number of bytes to read
 22511                                  			; DS:DX -> buffer
 22512 00002BDE 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22513 00002BE0 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22514 00002BE2 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22515                                  
 22516 00002BE4 803E[448C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22517 00002BE9 8E1E[C58A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22518 00002BED 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22519                                  	
 22520                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22521 00002BEF B80142                  	mov	ax,4201h
 22522 00002BF2 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22523                                  setreout_p:	; 26/02/2023
 22524 00002BF5 89CA                    	mov	dx,cx			;AN011;
 22525 00002BF7 CD21                    	int	21h			;AN011;
 22526 00002BF9 EB20                    	jmp	short SET_REOUT
 22527                                  reout_0_length: 			;AN017; We have a 0 length file
 22528                                  	; ds = cs ; 26/02/2023
 22529                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22530                                  					;AN017; Get resident segment back
 22531                                  	; 26/02/2023
 22532 00002BFB 8E1E[C58A]              	mov	ds,[RESSEG]
 22533                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22534 00002BFF B80042                  	mov	ax,4200h
 22535 00002C02 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22536                                  	;mov	dx,cx			;AN017;
 22537                                  	;int	21h			;AN017;
 22538                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22539                                  	; 26/02/2023
 22540 00002C04 EBEF                    	jmp	short setreout_p
 22541                                  
 22542                                  	; 26/02/2023
 22543                                  	; MSDOS 3.3
 22544                                  	;xor	dx,dx
 22545                                  	;xor	cx,cx
 22546                                  	;mov	bx,ax
 22547                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22548                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22549                                  	;		; AL = method: offset from end of file
 22550                                  	;jmp	short SET_REOUT
 22551                                  
 22552                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22553                                  OpenWriteError:	
 22554                                  	;cmp	ax,5
 22555 00002C06 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22556 00002C09 F9                      	stc
 22557                                  	;;je	short REDIRERR ; MSDOS 3.3
 22558                                  	; 26/02/2023
 22559                                  	;jnz	short REOUTCRT
 22560                                  	;jmp	REDIRERR
 22561 00002C0A 743B                    	je	short REDIRERR
 22562                                  
 22563                                  REOUTCRT:
 22564 00002C0C BA[AF01]                	mov	dx,Re_OutStr
 22565 00002C0F 31C9                    	xor	cx,cx
 22566                                  	;mov	ah,CREAT ; 3Ch
 22567 00002C11 B43C                    	mov	ah,3Ch
 22568 00002C13 50                      	push	ax
 22569 00002C14 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22570                                  			; CX = attributes for file
 22571                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22572 00002C16 5B                      	pop	bx
 22573                                  	;jc	short REDIRERR ; MSDOS 3.3
 22574                                  	; 26/02/2023
 22575                                  	;jnc	short NOREDIRERR
 22576                                  	;jmp	REDIRERR
 22577 00002C17 722E                    	jc	short REDIRERR
 22578                                  
 22579                                  NOREDIRERR:
 22580 00002C19 89C3                    	mov	bx,ax
 22581                                  SET_REOUT:
 22582                                  
 22583                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22584                                  ; spot. We invalidate the new JFN we got.
 22585                                  
 22586 00002C1B B0FF                    	mov	al,0FFh
 22587                                  	;xchg	al,[bx+18h]
 22588 00002C1D 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22589 00002C20 A21900                  	mov	[PDB.JFN_TABLE+1],al
 22590                                  	; 06/08/2024
 22591                                  NOREOUT:
 22592                                  ;IOSET_RETN:	; 17/04/2023
 22593 00002C23 C3                      	retn
 22594                                  
 22595                                  ; =============== S U B	R O U T	I N E =======================================
 22596                                  
 22597                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22598                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22599                                  	; 06/08/2024
 22600                                  TESTDOREIN:
 22601 00002C24 2E803E[708A]00          	cmp	byte [cs:RE_INSTR],0
 22602                                  	;jz	short IOSET_RETN
 22603                                  	; 06/08/2024
 22604 00002C2A 74F7                    	jz	short NOREOUT
 22605 00002C2C 1E                      	push	ds
 22606 00002C2D 0E                      	push	cs
 22607 00002C2E 1F                      	pop	ds
 22608 00002C2F BA[708A]                	mov	dx,RE_INSTR
 22609                                  	;mov	ax,OPEN*256 ; 3D00h
 22610 00002C32 B8003D                  	mov	ax,3D00h
 22611 00002C35 89C3                    	mov	bx,ax
 22612 00002C37 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22613                                  			; DS:DX	-> ASCIZ filename
 22614                                  			; AL = access mode
 22615                                  			; 0 - read
 22616 00002C39 1F                      	pop	ds
 22617                                  
 22618 00002C3A 720B                    	jc	short REDIRERR
 22619                                  
 22620 00002C3C 89C3                    	mov	bx,ax
 22621 00002C3E B0FF                    	mov	al,0FFh
 22622                                  
 22623                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22624                                  ; spot. We invalidate the new JFN we got.
 22625                                  
 22626                                  	;xchg	al,[bx+18h]
 22627 00002C40 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22628 00002C43 A21800                  	mov	[PDB.JFN_TABLE],al
 22629 00002C46 C3                      	retn
 22630                                  
 22631                                  ; ---------------------------------------------------------------------------
 22632                                  
 22633                                  ; We had some kind of error on the redirection. Figure out what the
 22634                                  ; appropriate message should be; BX has the system call that failed
 22635                                  
 22636                                  REDIRERR:
 22637 00002C47 0E                      	push	cs
 22638 00002C48 1F                      	pop	ds
 22639 00002C49 E82E00                  	call	TriageError  ; MSDOS 6.0
 22640                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22641                                  
 22642                                  ; At this point, we have recognized the network-generated access denied error.
 22643                                  ; The correct message is in DX
 22644                                  
 22645 00002C4C 83F841                  	cmp	ax,65
 22646 00002C4F 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22647 00002C51 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22648 00002C54 7406                    	je	short OpenError
 22649 00002C56 BA[357F]                	mov	dx,FULLDIR_PTR
 22650                                  _CERRORJ:
 22651 00002C59 E9F6FC                  	jmp	cerror
 22652                                  
 22653                                  OpenError:
 22654                                  ; The system call was an OPEN. Report either file not found or path not found.
 22655                                  
 22656                                  	; 26/02/2023
 22657                                  	; MSDOS 6.0
 22658                                  	;mov	byte [cs:msg_disp_class],1
 22659 00002C5C 2EC606[197F]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22660                                  				;AN000; set up extended error msg class
 22661 00002C62 BA[1B7F]                	mov	dx,extend_buf_ptr
 22662                                  				;AC000; get extended message pointer
 22663 00002C65 2EA3[1B7F]              	mov	[cs:extend_buf_ptr],ax
 22664                                  				;AN000; get message number in control block
 22665 00002C69 E9E6FC                  	jmp	cerror
 22666                                  
 22667                                  	; 26/02/2023
 22668                                  	; MSDOS 3.3
 22669                                  	;mov	dx,FNOTFOUNDPTR
 22670                                  	;;cmp	ax,2
 22671                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22672                                  	;je	short _CERRORJ
 22673                                  	;mov	dx,ACCDENPTR
 22674                                  	;;cmp	ax,5 ; Access denied error
 22675                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22676                                  	;je	short _CERRORJ
 22677                                  	;	; ERROR_PATH_NOT_FOUND
 22678                                  	;mov	dx,PNOTFOUNDPTR
 22679                                  	;jmp	CERROR
 22680                                  
 22681                                  ; =============== S U B	R O U T	I N E =======================================
 22682                                  
 22683                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22684                                  ; registers
 22685                                  
 22686                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22687                                  dstrlen:
 22688 00002C6C 50                      	push	ax
 22689 00002C6D 31C9                    	xor	cx,cx
 22690 00002C6F FC                      	cld
 22691                                  dloop:
 22692 00002C70 AC                      	lodsb
 22693 00002C71 41                      	inc	cx
 22694 00002C72 08C0                    	or	al,al
 22695 00002C74 75FA                    	jnz	short dloop
 22696 00002C76 29CE                    	sub	si,cx
 22697 00002C78 58                      	pop	ax
 22698                                  TRIAGEERR_RETN:
 22699 00002C79 C3                      	retn
 22700                                  
 22701                                  ; =============== S U B	R O U T	I N E =======================================
 22702                                  
 22703                                  ;Break	<Extended error support>
 22704                                  
 22705                                  TriageError:  ; MSDOS 6.0
 22706                                  
 22707                                  ; TriageError will examine the return from a carry-set system call and
 22708                                  ; return the correct error if applicable.
 22709                                  ;
 22710                                  ;   Inputs:	outputs from a carry-settable system call
 22711                                  ;		No system calls may be done in the interrim
 22712                                  ;   Outputs:	If carry was set on input
 22713                                  ;		   carry set on output
 22714                                  ;		   DX contains trangroup offset to printf message
 22715                                  ;		else
 22716                                  ;		   No registers changed
 22717                                  
 22718                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22719                                  
 22720                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22721                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22722                                  
 22723                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22724 00002C7A 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22725 00002C7C 9C                      	pushf
 22726 00002C7D 53                      	push	bx
 22727 00002C7E 51                      	push	cx
 22728 00002C7F 56                      	push	si
 22729 00002C80 57                      	push	di
 22730 00002C81 55                      	push	bp
 22731 00002C82 06                      	push	es
 22732 00002C83 1E                      	push	ds
 22733 00002C84 50                      	push	ax
 22734 00002C85 52                      	push	dx
 22735 00002C86 B459                    	mov	ah,59h
 22736                                  	;mov	ah,GETEXTENDEDERROR
 22737 00002C88 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22738                                  			; BX = version code (0000h for DOS 3.x)
 22739 00002C8A 59                      	pop	cx
 22740 00002C8B 5B                      	pop	bx		; restore original AX
 22741 00002C8C BA[417F]                	mov	dx,ACCDEN_PTR
 22742 00002C8F 83F841                  	cmp	ax,65		; network access denied?
 22743 00002C92 7404                    	je	short NoMove	; Yes, return it.
 22744 00002C94 89D8                    	mov	ax,bx
 22745 00002C96 89CA                    	mov	dx,cx
 22746                                  NoMove:
 22747 00002C98 1F                      	pop	ds
 22748 00002C99 07                      	pop	es
 22749 00002C9A 5D                      	pop	bp
 22750 00002C9B 5F                      	pop	di
 22751 00002C9C 5E                      	pop	si
 22752 00002C9D 59                      	pop	cx
 22753 00002C9E 5B                      	pop	bx
 22754 00002C9F 9D                      	popf
 22755 00002CA0 C3                      	retn
 22756                                  
 22757                                  ; =============== S U B	R O U T	I N E =======================================
 22758                                  
 22759                                  	; Far call from resident portion/segment of COMMAND.COM
 22760                                  
 22761                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22762                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22763                                  
 22764                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22765                                  Triage_Init:
 22766 00002CA1 E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22767                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22768 00002CA4 CB                      	retf
 22769                                  
 22770                                  ; =============== S U B	R O U T	I N E =======================================
 22771                                  
 22772                                  ; MSDOS 6.0
 22773                                  
 22774                                  ; ****************************************************************
 22775                                  ; *
 22776                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22777                                  ; *
 22778                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22779                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22780                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22781                                  ; *
 22782                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22783                                  ; *		 ES    points to TRANGROUP
 22784                                  ; *
 22785                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22786                                  ; *		 PATHCNT set to length of string
 22787                                  ; *		 PATHPOS set to start of SRCBUF
 22788                                  ; *		 CX,AX	 changed
 22789                                  ; *
 22790                                  ; ****************************************************************
 22791                                  
 22792                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22793                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22794                                  Move_To_SrcBuf:
 22795 00002CA5 56                      	push	si			;AN000;  save si,di
 22796 00002CA6 57                      	push	di			;AN000;
 22797 00002CA7 51                      	push	cx			;AN000;
 22798 00002CA8 BF[B48C]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22799 00002CAB 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22800 00002CAD 89C8                    	mov	ax,cx			;AN000; clear ax
 22801 00002CAF 57                      	push	di			;AN000; save start of srcbuf
 22802 00002CB0 AC                      	lodsb				;AN000; get a character from DS:SI
 22803                                  mts_get_chars:				;AN000;
 22804                                  	;cmp	al,0			;AN000; was it a null char?
 22805 00002CB1 20C0                    	and 	al,al ; al = 0 ?
 22806 00002CB3 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22807 00002CB5 AA                      	stosb				;AN000; no - store it in srcbuf
 22808 00002CB6 41                      	inc	cx			;AN000; increment length count
 22809 00002CB7 AC                      	lodsb				;AN000; get a character from DS:SI
 22810 00002CB8 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22811                                  mts_end_string: 			;AN000; we've reached the end of line
 22812                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22813 00002CBA B00D                    	mov	al,0Dh
 22814 00002CBC AA                      	stosb				;AN000;
 22815 00002CBD 5F                      	pop	di			;AN000; restore start of srcbuf
 22816 00002CBE 0E                      	push	cs			;AN000; set DS to local segment
 22817 00002CBF 1F                      	pop	ds			;AN000;
 22818 00002CC0 890E[228C]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22819 00002CC4 893E[248C]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22820 00002CC8 59                      	pop	cx			;AN000; restore cx,di,si
 22821 00002CC9 5F                      	pop	di			;AN000;
 22822 00002CCA 5E                      	pop	si			;AN000;
 22823 00002CCB C3                      	retn				;AN000; exit
 22824                                  
 22825                                  ;============================================================================
 22826                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22827                                  ;============================================================================
 22828                                  ; 03/10/2018 - Retro DOS v3.0
 22829                                  
 22830                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22831                                  
 22832                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22833                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22834                                  
 22835                                  ; =============== S U B	R O U T	I N E =======================================
 22836                                  
 22837                                  	; 26/02/2023
 22838                                  SINGLETEST:
 22839 00002CCC 1E                      	push	ds
 22840 00002CCD 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
 22841 00002CD2 833E[8E01]00            	cmp	word [SingleCom],0
 22842 00002CD7 7406                    	jz	short TESTDONE
 22843 00002CD9 813E[8E01]FFEF          	cmp	word [SingleCom],0EFFFh
 22844                                  TESTDONE:
 22845 00002CDF 1F                      	pop	ds
 22846 00002CE0 C3                      	retn
 22847                                  
 22848                                  ; =============== S U B	R O U T	I N E =======================================
 22849                                  
 22850                                  	; 26/02/2023
 22851                                  SetRest1:
 22852 00002CE1 B001                    	mov	al,1
 22853                                  
 22854                                  ; ---------------------------------------------------------------------------
 22855                                  
 22856                                  SETREST:
 22857 00002CE3 1E                      	push	ds
 22858 00002CE4 8E1E[C58A]              	mov	ds,[RESSEG]
 22859 00002CE8 A2[8C01]                	mov	[RestDir],al
 22860 00002CEB 1F                      	pop	ds
 22861 00002CEC C3                      	retn
 22862                                  
 22863                                  ; =============== S U B	R O U T	I N E =======================================
 22864                                  
 22865                                  ; Note that we need to handle the same thing that RestDir handles: the
 22866                                  ; requirement that we try only once to restore the user's environment after
 22867                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22868                                  ; disappear, we just give up.
 22869                                  
 22870                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22871                                  PIPEDEL:
 22872 00002CED 1E                      	push	ds
 22873 00002CEE 52                      	push	dx
 22874 00002CEF 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
 22875                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22876                                  			; Pipe1 = offset RESGROUP:EndInit
 22877 00002CF4 BA[0202]                	mov	dx,Pipe1	; Clean up in case ^C
 22878                                  	;mov	ah,Unlink ; 41h 
 22879 00002CF7 B441                    	mov	ah,41h
 22880 00002CF9 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22881                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22882                                  			;		(no wildcards allowed)
 22883                                  
 22884                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22885                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22886 00002CFB BA[5102]                	mov	dx,Pipe2
 22887                                  	;mov	ah,Unlink ; 41h
 22888 00002CFE B441                    	mov	ah,41h
 22889 00002D00 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22890                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22891                                  			;		(no wildcards allowed)
 22892 00002D02 5A                      	pop	dx
 22893 00002D03 E86202                  	call	PipeOff
 22894 00002D06 C606[0102]00            	mov	byte [PipeFiles],0
 22895 00002D0B 1F                      	pop	ds
 22896 00002D0C C3                      	retn
 22897                                  
 22898                                  ; ---------------------------------------------------------------------------
 22899                                  
 22900                                  	; 26/02/2023
 22901                                  PIPEERRSYN:
 22902 00002D0D BA[B37F]                	mov	dx,SYNTMES_PTR
 22903 00002D10 E8DAFF                  	call	PIPEDEL
 22904 00002D13 0E                      	push	cs
 22905 00002D14 1F                      	pop	ds
 22906 00002D15 E93AFC                  	jmp	cerror
 22907                                  
 22908                                  ; ---------------------------------------------------------------------------
 22909                                  
 22910                                  	; 26/02/2023
 22911                                  PIPERR:
 22912 00002D18 9C                      	pushf
 22913 00002D19 E85EFF                  	call    TriageError
 22914                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22915 00002D1C 50                      	push	ax		; Save results from TriageError
 22916 00002D1D 52                      	push	dx
 22917 00002D1E BA[7C80]                	mov	dx,PIPEEMES_PTR
 22918 00002D21 E8C9FF                  	call	PIPEDEL
 22919 00002D24 0E                      	push	cs
 22920 00002D25 1F                      	pop	ds
 22921 00002D26 E8BE20                  	call	std_eprintf
 22922 00002D29 5A                      	pop	dx		; Restore results from TriageError
 22923 00002D2A 58                      	pop	ax
 22924 00002D2B 9D                      	popf
 22925 00002D2C 83F841                  	cmp	ax,65
 22926 00002D2F 7503                    	jne	short TCOMMANDJ
 22927 00002D31 E91EFC                  	jmp	cerror
 22928                                  
 22929                                  TCOMMANDJ:
 22930 00002D34 E9CDD3                  	jmp	TCOMMAND
 22931                                  
 22932                                  ; ---------------------------------------------------------------------------
 22933                                  
 22934                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22935                                  PIPEPROCSTRT:
 22936 00002D37 8E1E[C58A]              	mov	ds,[RESSEG]
 22937 00002D3B FE06[0102]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22938                                  
 22939                                  	; MSDOS 6.0
 22940 00002D3F 06                      	push	es
 22941 00002D40 57                      	push	di
 22942 00002D41 1E                      	push	ds
 22943 00002D42 56                      	push	si
 22944                                  	
 22945 00002D43 1E                      	push	ds
 22946 00002D44 06                      	push	es
 22947 00002D45 1F                      	pop	ds			;ds = TRANGROUP
 22948 00002D46 BE[D985]                	mov	si,TempVarName		;ds:si = "TEMP="
 22949                                  
 22950                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22951                                  ;so the routine is not really general
 22952                                  
 22953 00002D49 E8C9F5                  	call	find_name_in_environment
 22954                                  					;es:di points at path
 22955 00002D4C 1F                      	pop	ds			;ds = DATARES again
 22956 00002D4D 721F                    	jc	short no_temp_path
 22957                                  	
 22958 00002D4F 1E                      	push	ds
 22959 00002D50 06                      	push	es
 22960 00002D51 1F                      	pop	ds
 22961 00002D52 07                      	pop	es			;swap ds and es
 22962 00002D53 89FE                    	mov	si,di			;ds:si points at path
 22963                                  	
 22964 00002D55 E8AA02                  	call	skip_white		;skip white space chars
 22965                                  
 22966                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22967                                  
 22968 00002D58 E8B302                  	call	copy_pipe_path		;copy the pipe path
 22969                                  	
 22970                                  ;Check if the TEMP path is valid
 22971                                  
 22972 00002D5B 06                      	push	es
 22973 00002D5C 1F                      	pop	ds			;ds = DATARES
 22974                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 22975                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 22976 00002D5D BA[0202]                	mov	dx,Pipe1
 22977                                  	;mov	ax,(CHMOD shl 8) or 0
 22978 00002D60 B80043                  	mov	ax,4300h
 22979 00002D63 CD21                    	int	21h
 22980 00002D65 7207                    	jc	short no_temp_path
 22981                                  	
 22982 00002D67 F7C11000                	test	cx,10h			;is it a directory?
 22983 00002D6B 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 22984                                  	
 22985 00002D6D F9                      	stc				;no, indicate fail
 22986                                  no_temp_path:
 22987 00002D6E 5E                      	pop	si
 22988 00002D6F 1F                      	pop	ds
 22989 00002D70 5F                      	pop	di
 22990 00002D71 07                      	pop	es
 22991 00002D72 730B                    	jnc	short crt_temp		;path found, create tempfiles
 22992                                  
 22993                                  	; 27/02/2023
 22994                                  	; MSDOS 3.3
 22995                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 22996                                  	;				; Get current drive
 22997                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 22998                                  	;add	al,[cs:CAPITAL_A]
 22999                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 23000                                  	;mov	bx,PIPE1
 23001                                  	;mov	[bx],al
 23002                                  	;xor	ah,ah			; nul terminate path names
 23003                                  	;mov	byte [PIPE1+3],ah
 23004                                  	;mov	byte [PIPE2+3],ah
 23005                                  
 23006                                  	; MSDOS 6.0
 23007                                  ;SR;
 23008                                  ; We want to create temp files in the current directory rather than in the 
 23009                                  ;root of the drive. This is because the number of files that can be present
 23010                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 23011                                  
 23012                                  	;mov	ah,'.'
 23013                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 23014                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 23015                                  	;xor	ah,ah
 23016                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 23017                                  	;mov	[Pipe2+1],ah		;create files in current dir
 23018                                  	; 27/02/2023
 23019 00002D74 B92E00                  	mov	cx,002Eh
 23020 00002D77 890E[0202]              	mov	[Pipe1],cx
 23021 00002D7B 890E[5102]              	mov	[Pipe2],cx
 23022                                  crt_temp:
 23023                                  	; MSDOS 6.0
 23024                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 23025                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 23026 00002D7F BA[0202]                	mov	dx,Pipe1
 23027                                  	; MSDOS 3.3
 23028                                  	;mov	dx,bx
 23029                                  	
 23030                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23031 00002D82 31C9                    	xor	cx,cx
 23032                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23033 00002D84 B45A                    	mov	ah,5Ah
 23034 00002D86 CD21                    	int	21h
 23035                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23036                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23037                                  		; receive generated filename
 23038                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23039 00002D88 728E                    	jc	short PIPERR	; Couldn't create
 23040                                  
 23041 00002D8A 89C3                    	mov	bx,ax
 23042                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23043 00002D8C B43E                    	mov	ah,3Eh
 23044 00002D8E CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23045                                  			; BX = file handle
 23046                                  	;;mov	dx,PIPE2
 23047                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 23048 00002D90 BA[5102]                	mov	dx,Pipe2
 23049                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23050 00002D93 B45A                    	mov	ah,5Ah
 23051 00002D95 CD21                    	int	21h
 23052                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23053                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23054                                  		; receive generated filename
 23055                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23056                                  	; 17/04/2023
 23057                                  	;jc	short PIPERR
 23058                                  	; 27/02/2023
 23059 00002D97 7303                    	jnc	short pps1
 23060 00002D99 E97CFF                  	jmp	PIPERR
 23061                                  pps1:
 23062 00002D9C 89C3                    	mov	bx,ax
 23063 00002D9E B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23064 00002DA0 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23065                                  				; BX = file handle
 23066                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 23067 00002DA2 E87FFE                  	call	TESTDOREIN
 23068 00002DA5 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23069 00002DA9 833E[8E01]FF            	cmp	word [SingleCom],-1
 23070 00002DAE 7506                    	jne	short NOSINGP
 23071 00002DB0 C706[8E01]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 23072                                  NOSINGP:
 23073 00002DB6 EB29                    	jmp	short FIRSTPIPE
 23074                                  
 23075                                  ; ---------------------------------------------------------------------------
 23076                                  
 23077                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23078                                  PIPEPROC:
 23079 00002DB8 8026[8801]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 23080 00002DBD 8B36[A002]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23081 00002DC1 AC                      	lodsb
 23082                                  	; 27/02/2023
 23083 00002DC2 3C7C                    	cmp	al,'|'		
 23084                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 23085                                  	;je	short ISPIPE1	; Yes
 23086                                  	;cmp	al,'|'
 23087                                  	;;cmp	al,[cs:VBAR]
 23088 00002DC4 7403                    	je	short ISPIPE1
 23089 00002DC6 E98400                  	jmp	PIPEEND		; Pipe done
 23090                                  ISPIPE1:
 23091 00002DC9 8B16[2303]              	mov	dx,[InPipePtr]	; Get the input file name
 23092                                  	;mov	ax,OPEN*256 ; 3D00h
 23093 00002DCD B8003D                  	mov	ax,3D00h
 23094 00002DD0 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23095                                  			; DS:DX	-> ASCIZ filename
 23096                                  			; AL = access mode
 23097                                  			; 0 - read
 23098                                  PIPEERRJ:
 23099 00002DD2 7303                    	jnc	short NO_PIPEERR
 23100 00002DD4 E941FF                  	jmp	PIPERR		; Lost the pipe file
 23101                                  NO_PIPEERR:
 23102 00002DD7 89C3                    	mov	bx,ax
 23103 00002DD9 B0FF                    	mov	al,0FFh
 23104                                  	;xchg	al,[bx+18h]
 23105 00002DDB 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23106 00002DDE A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 23107                                  FIRSTPIPE:
 23108 00002DE1 BF[2689]                	mov	di,COMBUF+2
 23109 00002DE4 31C9                    	xor	cx,cx
 23110 00002DE6 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 23111 00002DE9 7503                    	jne	short PIPEOK1
 23112                                  PIPEERRSYNJ:
 23113 00002DEB E91FFF                  	jmp	PIPEERRSYN
 23114                                  PIPEOK1:
 23115                                  	;;;mov	al,[cs:VBAR]
 23116                                  	; 27/02/2023
 23117                                  	;;mov	al,vbar
 23118                                  	;mov	al,'|'
 23119                                  	;cmp	[si],al		; '||'
 23120                                  	;je	short PIPEERRSYNJ
 23121 00002DEE 803C7C                  	cmp	byte [si],'|'
 23122                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 23123 00002DF1 74F8                    	je	short PIPEERRSYNJ
 23124                                  PIPECOMLP:
 23125 00002DF3 AC                      	lodsb
 23126 00002DF4 AA                      	stosb
 23127                                  	; 27/02/2023
 23128 00002DF5 E8C7F5                  	call	testkanj
 23129 00002DF8 7405                    	jz	short NOTKANJ5
 23130 00002DFA A4                      	movsb
 23131                                  ;  Added following 2 commands to the fix pipe bug.
 23132 00002DFB 41                      	inc	cx		;AN000;  3/3/KK
 23133 00002DFC 41                      	inc	cx		;AN000;  3/3/KK
 23134 00002DFD EBF4                    	jmp	short PIPECOMLP
 23135                                  NOTKANJ5:
 23136 00002DFF 3C0D                    	cmp	al,0Dh
 23137 00002E01 7438                    	je	short LASTPIPE
 23138 00002E03 41                      	inc	cx
 23139                                  	; 27/02/2023
 23140 00002E04 3C7C                    	cmp	al,'|'
 23141                                  	;cmp	al,ALTPIPECHR
 23142                                  	;je	short ISPIPE2
 23143                                  	;;cmp	al,[cs:VBAR]
 23144                                  	;cmp	al,vbar
 23145 00002E06 75EB                    	jne	short PIPECOMLP
 23146                                  ISPIPE2:
 23147 00002E08 26C645FF0D              	mov	byte [es:di-1],0Dh
 23148 00002E0D 49                      	dec	cx
 23149                                  	;mov	[cs:COMBUF+1],cl
 23150                                  	; 27/02/2023
 23151 00002E0E 26880E[2589]            	mov	[es:COMBUF+1],cl
 23152 00002E13 4E                      	dec	si
 23153                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23154 00002E14 8936[A002]              	mov	[PipePtr],si		; On to next pipe element
 23155                                  			; mov [EndInit+158],si
 23156 00002E18 8B16[2503]              	mov	dx,[OutPipePtr]
 23157 00002E1C 51                      	push	cx
 23158 00002E1D 31C9                    	xor	cx,cx
 23159                                  	;mov	ax,CREAT*256 ; 3C00h
 23160 00002E1F B8003C                  	mov	ax,3C00h
 23161 00002E22 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23162                                  			; CX = attributes for file
 23163                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23164 00002E24 59                      	pop	cx
 23165 00002E25 72AB                    	jc	short PIPEERRJ		; Lost the file
 23166 00002E27 89C3                    	mov	bx,ax
 23167 00002E29 B0FF                    	mov	al,0FFh
 23168                                  	;xchg	al,[bx+18h]
 23169 00002E2B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23170 00002E2E A21900                  	mov	[PDB.JFN_TABLE+1],al
 23171 00002E31 8716[2303]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 23172 00002E35 8916[2503]              	mov	[OutPipePtr],dx
 23173 00002E39 EB0D                    	jmp	short PIPECOM
 23174                                  LASTPIPE:
 23175                                  	;mov	[cs:COMBUF+1],cl 
 23176                                  	; 27/02/2023
 23177 00002E3B 26880E[2589]            	mov	[es:COMBUF+1],cl
 23178 00002E40 4E                      	dec	si
 23179                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23180 00002E41 8936[A002]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 23181                                  		; mov [EndInit+158],si
 23182 00002E45 E859FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 23183                                  PIPECOM:
 23184 00002E48 0E                      	push	cs
 23185 00002E49 1F                      	pop	ds
 23186 00002E4A E995D4                  	jmp	NOPIPEPROC	; Process the pipe element
 23187                                  PIPEEND:
 23188 00002E4D E89DFE                  	call	PIPEDEL
 23189 00002E50 813E[8E01]00F0          	cmp	word [SingleCom],0F000h
 23190 00002E56 7506                    	jnz	short NOSINGP2
 23191 00002E58 C706[8E01]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 23192                                  NOSINGP2:
 23193 00002E5E E9A3D2                  	jmp	TCOMMAND
 23194                                  
 23195                                  ; =============== S U B	R O U T	I N E =======================================
 23196                                  
 23197                                  ; Date and time are set during initialization and use
 23198                                  ; this routines since they need to do a long return
 23199                                  
 23200                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23201                                  DATINIT:
 23202 00002E61 2E8C1E[C58A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 23203 00002E66 06                      	push	es
 23204 00002E67 1E                      	push	ds		; Going to use the previous stack
 23205 00002E68 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 23206 00002E6A 8EC0                    	mov	es,ax
 23207 00002E6C 8ED8                    	mov	ds,ax
 23208 00002E6E E85D20                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 23209 00002E71 BA[2395]                	mov	dx,INTERNATVARS
 23210 00002E74 B80038                  	mov	ax,3800h
 23211                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 23212 00002E77 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23213                                  			; get current-country info
 23214                                  			; DS:DX	-> buffer for returned info
 23215                                  	; 20/10/2018
 23216 00002E79 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 23217 00002E7F C606[2489]80            	mov	byte [COMBUF],128 ; Init COMBUF
 23218 00002E84 C706[2589]010D          	mov	word [COMBUF+1],0D01h
 23219 00002E8A E80600                  	call	DATE
 23220 00002E8D E86200                  	call	CTIME
 23221 00002E90 1F                      	pop	ds
 23222 00002E91 07                      	pop	es
 23223 00002E92 CB                      	retf	; far return
 23224                                  
 23225                                  ; =============== S U B	R O U T	I N E =======================================
 23226                                  
 23227                                  ; MSDOS 6.0
 23228                                  
 23229                                  ; ****************************************************************
 23230                                  ; *
 23231                                  ; * ROUTINE:	 DATE - Set system date
 23232                                  ; *
 23233                                  ; * FUNCTION:	 If a date is specified, set the system date,
 23234                                  ; *		 otherwise display the current system date and
 23235                                  ; *		 prompt the user for a new date.  If an invalid
 23236                                  ; *		 date is specified, issue an error message and
 23237                                  ; *		 prompt for a new date.  If the user enters
 23238                                  ; *		 nothing when prompted for a date, terminate.
 23239                                  ; *
 23240                                  ; * INPUT:	 command line at offset 81H
 23241                                  ; *
 23242                                  ; * OUTPUT:	 none
 23243                                  ; *
 23244                                  ; ****************************************************************
 23245                                  
 23246                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23247                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 23248                                  	; 11/06/2023
 23249                                  DATE:
 23250 00002E93 BE8100                  	mov	si,81h			; Accepting argument for date inline
 23251 00002E96 BF[D184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23252 00002E99 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23253 00002E9B 31D2                    	xor	dx,dx			;AN000;
 23254 00002E9D E87E14                  	call	cmd_parse		;AC000; call parser
 23255                                  	
 23256                                  	; 27/02/2023
 23257                                  	;cmp	ax,-1
 23258                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23259                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 23260                                  	;;cmp	ax,0
 23261                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23262                                  	;;jne	short DATERR		;AN000; yes - go issue message
 23263                                  	; 26/04/2023
 23264                                  	;or	ax,ax ; ax = 0 ?
 23265                                  	;jnz	short DATERR
 23266                                  	;;jmp	short COMDAT		;AC000; we have a date
 23267                                  	; 11/06/2023
 23268 00002EA0 40                      	inc	ax  ; cmp ax,-1
 23269 00002EA1 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 23270 00002EA3 48                      	dec	ax  ; cmp ax,0
 23271 00002EA4 7541                    	jnz	short DATERR ; 1 -> 0
 23272                                  	; ax = 0
 23273                                  	
 23274                                  	; 27/02/2023
 23275                                  COMDAT:
 23276 00002EA6 8B0E[8095]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 23277 00002EAA 8A36[8295]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 23278 00002EAE 8A16[8395]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 23279 00002EB2 51                      	push	cx			;AC000; save date
 23280 00002EB3 52                      	push	dx			;AC000;
 23281 00002EB4 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 23282 00002EB7 31D2                    	xor	dx,dx			;AN029;
 23283 00002EB9 E86214                  	call	cmd_parse		;AN029; call parser
 23284 00002EBC 3CFF                    	cmp	al,0FFh ; -1
 23285                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23286 00002EBE 5A                      	pop	dx			;AC000; retrieve date
 23287 00002EBF 59                      	pop	cx			;AC000;
 23288 00002EC0 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 23289                                  	; 26/04/2023
 23290                                  	;mov	ah,SET_DATE		;yes - set date
 23291 00002EC2 B42B                    	mov	ah,2Bh
 23292 00002EC4 CD21                    	int	21h
 23293                                  			; DOS - SET CURRENT DATE
 23294                                  			; DL = day, DH = month, CX = year
 23295                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 23296 00002EC6 08C0                    	or	al,al
 23297 00002EC8 751D                    	jnz	short DATERR
 23298                                  date_end:
 23299 00002ECA C3                      	retn
 23300                                  
 23301                                  PRMTDAT:
 23302                                  	; Print "Current date is
 23303                                  
 23304 00002ECB E81608                  	call	GetDate 		;AN000; get date for output
 23305 00002ECE 86F2                    	xchg	dh,dl			;AN000; switch month & day
 23306 00002ED0 890E[C97F]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 23307 00002ED4 8916[CB7F]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 23308 00002ED8 BA[B97F]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 23309 00002EDB E8111F                  	call	std_printf
 23310                                  
 23311                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 23312                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 23313                                  
 23314                                  GET_NEW_DATE:				;AN000;
 23315 00002EDE E8BC00                  	call	GETDAT			;AC000; prompt user for date
 23316                                  	
 23317                                  	; 11/06/2023
 23318                                  	;cmp	ax,0FFFFh ; -1
 23319                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23320                                  	;je	short date_end		;AC000; yes - exit
 23321                                  	; 26/04/2023
 23322                                  	;;cmp	ax,0
 23323                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23324                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 23325                                  	;; 27/02/2023
 23326                                  	;;jz	short COMDAT
 23327                                  	; 26/04/2023
 23328                                  	;and	ax,ax ; 0 ?
 23329                                  	;jz	short COMDAT
 23330                                  
 23331                                  	; 11/06/2023
 23332 00002EE1 40                      	inc	ax  ; cmp ax,-1
 23333 00002EE2 74E6                    	jz	short date_end ; 0FFFFh -> 0
 23334 00002EE4 48                      	dec	ax  ; cmp ax,0
 23335 00002EE5 74BF                    	jz	short COMDAT ; 1 -> 0
 23336                                  	; ax > 0
 23337                                  
 23338                                  ;COMDAT:
 23339                                  ;	....
 23340                                  DATERR:
 23341 00002EE7 E8E7F6                  	call	CRLF2			;AN028; print out a blank line
 23342 00002EEA BA[B67F]                	mov	dx,BADDAT_PTR
 23343 00002EED E8FF1E                  	call	std_printf
 23344 00002EF0 EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 23345                                  
 23346                                  ; =============== S U B	R O U T	I N E =======================================
 23347                                  
 23348                                  ; MSDOS 6.0
 23349                                  
 23350                                  ; TIME gets and sets the time
 23351                                  
 23352                                  ; ****************************************************************
 23353                                  ; *
 23354                                  ; * ROUTINE:	 TIME - Set system time
 23355                                  ; *
 23356                                  ; * FUNCTION:	 If a time is specified, set the system time,
 23357                                  ; *		 otherwise display the current system time and
 23358                                  ; *		 prompt the user for a new time.  If an invalid
 23359                                  ; *		 time is specified, issue an error message and
 23360                                  ; *		 prompt for a new time.  If the user enters
 23361                                  ; *		 nothing when prompted for a time, terminate.
 23362                                  ; *
 23363                                  ; * INPUT:	 command line at offset 81H
 23364                                  ; *
 23365                                  ; * OUTPUT:	 none
 23366                                  ; *
 23367                                  ; ****************************************************************
 23368                                  
 23369                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23370                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23371                                  	; 11/06/2023
 23372                                  CTIME:
 23373 00002EF2 BE8100                  	mov	si,81h			; Accepting argument for time inline
 23374 00002EF5 BF[E384]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23375 00002EF8 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23376 00002EFA 31D2                    	xor	dx,dx			;AN000;
 23377 00002EFC E81F14                  	call	cmd_parse		;AC000; call parser
 23378                                  	
 23379                                  	; 27/02/2023
 23380                                  	;cmp	ax,-1
 23381                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23382                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 23383                                  	;;cmp	ax,0
 23384                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23385                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23386                                  	;and	ax,ax ; ax = 0 ?
 23387                                  	;jnz	short TIMERR
 23388                                  	;;jmp	short COMTIM		;AC000; we have a time
 23389                                  	; 11/06/2023
 23390 00002EFF 40                      	inc	ax  ; cmp ax,-1
 23391 00002F00 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 23392 00002F02 48                      	dec	ax  ; cmp ax,0
 23393 00002F03 7548                    	jnz	short TIMERR ; 1 -> 0
 23394                                  	; ax = 0
 23395                                  	
 23396                                  	; 27/02/2023
 23397                                  COMTIM:
 23398 00002F05 8A2E[8895]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23399 00002F09 8A0E[8995]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23400 00002F0D 8A36[8A95]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23401 00002F11 8A16[8B95]              	mov	dl,[TIME_FRACTION]	;AC000;
 23402 00002F15 51                      	push	cx			;AC000; save time
 23403 00002F16 52                      	push	dx			;AC000;
 23404 00002F17 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23405 00002F1A 31D2                    	xor	dx,dx			;AN029;
 23406 00002F1C E8FF13                  	call	cmd_parse		;AN029; call parser
 23407 00002F1F 3CFF                    	cmp	al, -1
 23408                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23409 00002F21 5A                      	pop	dx			;AC000; retieve time
 23410 00002F22 59                      	pop	cx			;AC000;
 23411 00002F23 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23412                                  SAVTIM:
 23413                                  	;mov	ah,SET_TIME
 23414 00002F25 B42D                    	mov	ah,2Dh
 23415 00002F27 CD21                    	int	21h
 23416 00002F29 08C0                    	or	al,al
 23417 00002F2B 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23418                                  time_end:
 23419 00002F2D C3                      	retn
 23420                                  
 23421                                  PRMTTIM:
 23422                                  	;Printf "Current time is ... "
 23423                                  
 23424                                  	;mov	ah,Get_Time		;AC000; get the current time
 23425 00002F2E B42C                    	mov	ah,2Ch
 23426 00002F30 CD21                    	int	21h			;AC000;   Get time in CX:DX
 23427 00002F32 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23428 00002F34 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23429 00002F36 890E[EB7F]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23430 00002F3A 8916[ED7F]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23431 00002F3E BA[E67F]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23432 00002F41 E8AB1E                  	call	std_printf
 23433                                  
 23434                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23435                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23436                                  
 23437                                  GET_NEW_TIME:
 23438 00002F44 E8AE00                  	call	GETTIM			;AC000;
 23439                                  	
 23440                                  	; 11/06/2023
 23441                                  	;cmp	ax,-1
 23442                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23443                                  	;je	short time_end		;AC000;
 23444                                  	;;cmp	ax,0
 23445                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23446                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23447                                  	;or	ax,ax  ; ax = 0 ?
 23448                                  	;;jnz	short TIMERR
 23449                                  	; 27/02/2023
 23450                                  	;jz	short COMTIM
 23451                                  
 23452                                  	; 11/06/2023
 23453 00002F47 40                      	inc	ax  ; cmp ax,-1
 23454 00002F48 74E3                    	jz	short time_end ; 0FFFFh -> 0
 23455 00002F4A 48                      	dec	ax  ; cmp ax,0
 23456 00002F4B 74B8                    	jz	short COMTIM ; 1 -> 0
 23457                                  	; ax > 0
 23458                                  
 23459                                  ;COMTIM:
 23460                                  ;	....
 23461                                  TIMERR:
 23462 00002F4D E881F6                  	call	CRLF2			;AN028; print out a blank line
 23463 00002F50 BA[E37F]                	mov	dx,BadTim_Ptr
 23464 00002F53 E8991E                  	call	std_printf		; Print error message
 23465 00002F56 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23466                                  
 23467                                  ; =============== S U B	R O U T	I N E =======================================
 23468                                  
 23469                                  ; MSDOS 6.0
 23470                                  
 23471                                  ; Set the special flag in the INIT flag to the value in CX.
 23472                                  
 23473                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23474                                  SetInitFlag:
 23475 00002F58 8E1E[C58A]              	mov	ds,[RESSEG]
 23476                                  
 23477 00002F5C 8026[FF01]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23478                                  	;and	byte [InitFlag],0FDh
 23479 00002F61 080E[FF01]              	or	byte [InitFlag],cl
 23480 00002F65 0E                      	push	cs
 23481 00002F66 1F                      	pop	ds
 23482 00002F67 C3                      	retn
 23483                                  
 23484                                  ; =============== S U B	R O U T	I N E =======================================
 23485                                  
 23486                                  ; MSDOS 6.0
 23487                                  
 23488                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23489                                  PipeOff:
 23490 00002F68 1E                      	push	ds
 23491 00002F69 50                      	push	ax
 23492 00002F6A 2E8E1E[C58A]            	mov	ds,[cs:RESSEG]
 23493 00002F6F 30C0                    	xor	al,al
 23494 00002F71 8606[0002]              	xchg	[PipeFlag],al
 23495 00002F75 08C0                    	or	al,al
 23496 00002F77 7404                    	jz	short PipeOffDone
 23497 00002F79 D02E[8801]              	shr	byte [EchoFlag],1
 23498                                  PipeOffDone:
 23499 00002F7D 58                      	pop	ax
 23500 00002F7E 1F                      	pop	ds
 23501 00002F7F C3                      	retn
 23502                                  
 23503                                  ; =============== S U B	R O U T	I N E =======================================
 23504                                  
 23505                                  ; MSDOS 6.0
 23506                                  
 23507                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23508                                  PRINT_TIME:
 23509                                  	;mov	ah,Get_Time
 23510 00002F80 B42C                    	mov	ah,2Ch
 23511 00002F82 CD21                    	int	21h			; Get time in CX:DX
 23512                                  
 23513 00002F84 06                      	push	es
 23514 00002F85 0E                      	push	cs
 23515 00002F86 07                      	pop	es
 23516 00002F87 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23517 00002F89 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23518 00002F8B 2E890E[2481]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23519 00002F90 2E8916[2681]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23520 00002F95 BA[1F81]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23521 00002F98 E8541E                  	call	std_printf
 23522                                  
 23523                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23524                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23525                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23526                                  					;AC000;  pointers in control block
 23527 00002F9B 07                      	pop	es
 23528 00002F9C C3                      	retn
 23529                                  
 23530                                  ; =============== S U B	R O U T	I N E =======================================
 23531                                  
 23532                                  ; MSDOS 6.0
 23533                                  
 23534                                  ; ****************************************************************
 23535                                  ; *
 23536                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23537                                  ; *
 23538                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23539                                  ; *		 INFORMATION and issues the "Enter new date"
 23540                                  ; *		 message with the proper date format. COMBUF
 23541                                  ; *		 is reset to get a date from the command line.
 23542                                  ; *		 The PARSE_DATE blocks are then reset and the
 23543                                  ; *		 PARSE function call is issued.
 23544                                  ; *
 23545                                  ; * INPUT:	 NONE
 23546                                  ; *
 23547                                  ; * OUTPUT:	 COMBUF
 23548                                  ; *		 PARSER RETURN CODES
 23549                                  ; *
 23550                                  ; ****************************************************************
 23551                                  
 23552                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23553                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23554                                  GETDAT:
 23555                                  	;mov	ax,(International SHL 8)
 23556 00002F9D B80038                  	mov	ax,3800h
 23557                                  					; Determine what format the date
 23558 00002FA0 BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23559 00002FA3 CD21                    	int	21h			;  print a message describing it
 23560                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23561                                  			; get current-country info
 23562                                  			; DS:DX -> buffer for returned info
 23563 00002FA5 89D6                    	mov	si,dx
 23564 00002FA7 AD                      	lodsw
 23565 00002FA8 2E8B16[FD80]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23566 00002FAD 48                      	dec	ax
 23567 00002FAE 780C                    	js	short printformat
 23568 00002FB0 2E8B16[0081]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23569 00002FB5 7405                    	jz	short printformat
 23570 00002FB7 2E8B16[0381]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23571                                  printformat:
 23572 00002FBC 89D0                    	mov	ax,dx			;AN000; get message number of format
 23573                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23574 00002FBE B6FF                    	mov	dh,-1 ; 0FFh
 23575 00002FC0 E8111F                  	call	TSYSGETMSG		;AN000; get the address of the message
 23576 00002FC3 2E8936[DA7F]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23577 00002FC8 BA[D57F]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23578 00002FCB E8211E                  	call	std_printf
 23579                                  	;mov	word [cs:NewDat_Format],no_subst
 23580                                  					;AN000; reset subst block
 23581 00002FCE 2EC706[DA7F]0000        	mov	word [cs:NewDat_Format],0
 23582                                  
 23583                                  	; 28/02/2023
 23584 00002FD5 BF[D184]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23585                                  ; 28/02/2023
 23586                                  gettim_p:	
 23587                                  	;mov	ah,Std_Con_String_Input
 23588 00002FD8 B40A                    	mov	ah,0Ah
 23589 00002FDA BA[2489]                	mov	dx,COMBUF
 23590 00002FDD B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23591 00002FE0 E875FF                  	call	SetInitFlag		;  prompting for date.
 23592 00002FE3 CD21                    	int	21h			; Get input line
 23593 00002FE5 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23594 00002FE7 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23595 00002FEA E8E4F5                  	call	CRLF2
 23596                                  	; 28/02/2023
 23597                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23598                                  ;gettim_p: ; 28/02/2023
 23599 00002FED BE[2689]                	mov	si,COMBUF+2
 23600                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23601 00002FF0 31D2                    	xor	dx,dx			;AN000;
 23602                                  	;call	cmd_parse		;AC000; call parser
 23603                                  	;retn
 23604                                  	; 28/02/2023
 23605 00002FF2 E92913                  	jmp	cmd_parse
 23606                                  
 23607                                  ; =============== S U B	R O U T	I N E =======================================
 23608                                  
 23609                                  ; MSDOS 6.0
 23610                                  
 23611                                  ; ****************************************************************
 23612                                  ; *
 23613                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23614                                  ; *
 23615                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23616                                  ; *		 INFORMATION and issues the "Enter new time"
 23617                                  ; *		 message. COMBUF is reset to get a time from the
 23618                                  ; *		 command line. The PARSE_TIME blocks are then
 23619                                  ; *		 reset and the PARSE function call is issued.
 23620                                  ; *
 23621                                  ; * INPUT:	 NONE
 23622                                  ; *
 23623                                  ; * OUTPUT:	 COMBUF
 23624                                  ; *		 PARSER RETURN CODES
 23625                                  ; *
 23626                                  ; ****************************************************************
 23627                                  
 23628                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23629                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23630                                  GETTIM:
 23631 00002FF5 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23632 00002FF7 BA[F47F]                	mov	dx,NewTim_Ptr
 23633 00002FFA E8F21D                  	call	std_printf
 23634                                  
 23635                                  	; 28/02/2023
 23636 00002FFD BF[E384]                	mov	di,PARSE_TIME
 23637 00003000 EBD6                    	jmp	short gettim_p
 23638                                  
 23639                                  ; 28/02/2023
 23640                                  ;	;mov	ah,Std_Con_String_Input
 23641                                  ;	mov	ah,0Ah
 23642                                  ;	mov	dx,COMBUF
 23643                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23644                                  ;	call	SetInitFlag		;  prompting for time.
 23645                                  ;	int	21h			; Get input line
 23646                                  ;	; 28/02/2023
 23647                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23648                                  ;	call	SetInitFlag		;  prompting for time.
 23649                                  ;	call	CRLF2
 23650                                  ;	; 28/02/2023
 23651                                  ;	;mov	si,COMBUF+2
 23652                                  ;	; 28/02/2023
 23653                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23654                                  ;	; 28/02/2023
 23655                                  ;	jmp	short gettim_p	
 23656                                  ;	; 28/02/2023
 23657                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23658                                  ;	;xor	dx,dx			;AN000;
 23659                                  ;	;call	cmd_parse		;AC000; call parser
 23660                                  ;	;retn
 23661                                  
 23662                                  
 23663                                  ; =============== S U B	R O U T	I N E =======================================
 23664                                  
 23665                                  ; MSDOS 6.0
 23666                                  
 23667                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23668                                  ;the '=' sign in the environment variable before the actual path.
 23669                                  ;
 23670                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23671                                  ;
 23672                                  ;	EXIT:	ds:si = start of the path
 23673                                  ;
 23674                                  ;	REGISTERS AFFECTED: ax
 23675                                  
 23676                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23677                                  skip_white:
 23678 00003002 FC                      	cld
 23679                                  skw_lp:
 23680 00003003 AC                      	lodsb
 23681 00003004 3C20                    	cmp	al,' '			;blank char?
 23682 00003006 74FB                    	jz	short skw_lp		;yes, skip it
 23683 00003008 3C09                    	cmp	al,9			;tab char?
 23684 0000300A 74F7                    	jz	short skw_lp		;yes, skip it
 23685 0000300C 4E                      	dec	si			;point at first non-white
 23686 0000300D C3                      	retn
 23687                                  
 23688                                  ; =============== S U B	R O U T	I N E =======================================
 23689                                  
 23690                                  ; MSDOS 6.0
 23691                                  
 23692                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23693                                  ;variable into the path buffers Pipe1 & Pipe2.
 23694                                  ;
 23695                                  ;	ENTRY:	ds:si = path to be copied
 23696                                  ;		es = RESGROUP
 23697                                  ;
 23698                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23699                                  ;
 23700                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23701                                  
 23702                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23703                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23704                                  
 23705                                  copy_pipe_path:
 23706 0000300E B9FFFF                  	mov	cx,0FFFFh ; 65535
 23707 00003011 30C0                    	xor	al,al
 23708                                  
 23709 00003013 89F7                    	mov	di,si
 23710 00003015 06                      	push	es			;save es
 23711 00003016 1E                      	push	ds
 23712 00003017 07                      	pop	es			;es:di = path to be copied
 23713                                  	
 23714 00003018 FC                      	cld
 23715 00003019 57                      	push	di
 23716 0000301A F2AE                    	repnz	scasb			;look for the null char
 23717 0000301C 5F                      	pop	di
 23718                                  
 23719 0000301D 07                      	pop	es			;es = RESGROUP again
 23720                                  
 23721 0000301E F7D1                    	not	cx			;length including the null
 23722                                  
 23723                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23724                                  	;mov	di,offset DATARES:Pipe1
 23725 00003020 BF[0202]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23726 00003023 57                      	push	di
 23727 00003024 51                      	push	cx			
 23728 00003025 F3A4                    	rep	movsb			;copy path into Pipe1
 23729 00003027 59                      	pop	cx
 23730 00003028 5F                      	pop	di
 23731                                  
 23732 00003029 1E                      	push	ds
 23733 0000302A 06                      	push	es
 23734 0000302B 1F                      	pop	ds			;ds:si = Pipe1
 23735 0000302C 89FE                    	mov	si,di
 23736                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23737                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23738 0000302E BF[5102]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23739 00003031 F3A4                    	rep	movsb			;copy path into Pipe2
 23740 00003033 1F                      	pop	ds
 23741 00003034 C3                      	retn
 23742                                  
 23743                                  ; 28/02/2023
 23744                                  %if 0
 23745                                  
 23746                                  ;============================================================================
 23747                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23748                                  ;============================================================================
 23749                                  ; 05/10/2018 - Retro DOS v3.0
 23750                                  
 23751                                  ; DATE - Gets and sets the time
 23752                                  
 23753                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23754                                  
 23755                                  ; =============== S U B	R O U T	I N E =======================================
 23756                                  
 23757                                  DATE_CXDX:
 23758                                  	mov	bx,cx
 23759                                  
 23760                                  ; =============== S U B	R O U T	I N E =======================================
 23761                                  
 23762                                  P_DATE:
 23763                                  	mov	ax,bx
 23764                                  	mov	cx,dx
 23765                                  	mov	dl,100
 23766                                  	div	dl
 23767                                  	xchg	al,ah
 23768                                  	xchg	ax,dx
 23769                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23770                                  	;mov	ax,[INTERNATVARS]
 23771                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23772                                  	or	ax,ax
 23773                                  	jz	short USPDAT
 23774                                  	dec	ax
 23775                                  	jz	short EUPDAT
 23776                                  	mov	bh,0	 ; Disable leading zero suppression	
 23777                                  	call	P_YR
 23778                                  	call	P_DSEP
 23779                                  	call	P_MON
 23780                                  	call	P_DSEP
 23781                                  	call	P_DAY
 23782                                  	retn
 23783                                  
 23784                                  USPDAT:
 23785                                  	call	P_MON
 23786                                  	call	P_DSEP
 23787                                  	call	P_DAY
 23788                                  PLST:
 23789                                  	call	P_DSEP
 23790                                  	call	P_YR
 23791                                  	retn
 23792                                  
 23793                                  EUPDAT:
 23794                                  	call	P_DAY
 23795                                  	call	P_DSEP
 23796                                  	call	P_MON
 23797                                  	jmp	short PLST
 23798                                  
 23799                                  ; ---------------------------------------------------------------------------
 23800                                  
 23801                                  P_MON:
 23802                                  	mov	al,ch
 23803                                  	call	OUT2
 23804                                  	retn
 23805                                  
 23806                                  ; ---------------------------------------------------------------------------
 23807                                  
 23808                                  P_DSEP:
 23809                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23810                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23811                                  	stosb
 23812                                  	retn
 23813                                  
 23814                                  ; ---------------------------------------------------------------------------
 23815                                  
 23816                                  P_DAY:
 23817                                  	mov	al,cl
 23818                                  	call	OUT2
 23819                                  	retn
 23820                                  
 23821                                  ; ---------------------------------------------------------------------------
 23822                                  
 23823                                  P_YR:
 23824                                  	mov	al,dh
 23825                                  	or	al,al
 23826                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23827                                  	call	OUT2
 23828                                  TWODIGYR:
 23829                                  	mov	al,dl
 23830                                  	call	OUT2
 23831                                  DATE_RETN:
 23832                                  	retn
 23833                                  
 23834                                  ; =============== S U B	R O U T	I N E =======================================
 23835                                  
 23836                                  DATE:				 ; Accepting argument for date inline
 23837                                  	mov	si,81h
 23838                                  	call	SCANOFF
 23839                                  	cmp	al,0Dh
 23840                                  	jz	short PRMTDAT
 23841                                  	jmp	short COMDAT
 23842                                  
 23843                                  	;nop
 23844                                  PRMTDAT:
 23845                                  	; MSDOS 3.3
 23846                                  	mov	dx,CURDATPTR
 23847                                  	call	STD_PRINTF	; Print "Current date is "	
 23848                                  	call	PRINT_DATE
 23849                                  GETDAT:	
 23850                                  	mov	dx,NEWDATPTR
 23851                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23852                                  
 23853                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23854                                  				; Determine what format the date
 23855                                  	mov	dx,5Ch		;  should be entered in and
 23856                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23857                                  			; get current-country info
 23858                                  			; DS:DX	-> buffer for returned info
 23859                                  	mov	si,dx		;  print a message describing it
 23860                                  	lodsw
 23861                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23862                                  	dec	ax
 23863                                  	js	short PRINTFORMAT
 23864                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23865                                  	jz	short PRINTFORMAT
 23866                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23867                                  PRINTFORMAT:
 23868                                  	call	STD_PRINTF
 23869                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23870                                  	mov	dx,COMBUF
 23871                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23872                                  	call	SETINITFLAG	;  prompting for date.
 23873                                  	int	21h		; Get input line
 23874                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23875                                  	call	SETINITFLAG	;  prompting for date.
 23876                                  	call	CRLF2
 23877                                  	mov	si,COMBUF+2
 23878                                  	cmp	byte [si],0Dh
 23879                                  	jz	short DATE_RETN
 23880                                  COMDAT:
 23881                                  	;mov	ax,[INTERNATVARS]
 23882                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23883                                  	or	ax,ax
 23884                                  	jz	short USSDAT
 23885                                  	dec	ax
 23886                                  	jz	short EUSDAT
 23887                                  	call	GET_YR
 23888                                  	jc	short DATERRJ
 23889                                  	call	GET_DSEP
 23890                                  	jc	short DATERRJ
 23891                                  	call	GET_MON
 23892                                  	jc	short DATERRJ
 23893                                  	call	GET_DSEP
 23894                                  	jc	short DATERRJ
 23895                                  	call	GET_DAY
 23896                                  DAT_SET:
 23897                                  	jnc	short DATSET
 23898                                  	jmp	DATERR
 23899                                  
 23900                                  ; ---------------------------------------------------------------------------
 23901                                  
 23902                                  DATSET:
 23903                                  	lodsb
 23904                                  	cmp	al,' '
 23905                                  	jz	short DATSET
 23906                                  	cmp	al,9
 23907                                  	jz	short DATSET
 23908                                  	cmp	al,0Dh
 23909                                  	jnz	short DATERR
 23910                                  	mov	ah,SET_DATE ; 2Bh
 23911                                  	int	21h	; DOS -	SET CURRENT DATE
 23912                                  			; DL = day,DH = month,	CX = year
 23913                                  			; Return: AL = 00h if no error 
 23914                                  			; 	     = FFh if bad value sent to routine
 23915                                  	or	al,al
 23916                                  	jnz	short DATERR
 23917                                  DAT_SET_RETN:
 23918                                  	retn
 23919                                  
 23920                                  ; ---------------------------------------------------------------------------
 23921                                  
 23922                                  USSDAT:
 23923                                  	call	GET_MON
 23924                                  	jb	short DATERR
 23925                                  	call	GET_DSEP
 23926                                  DATERRJ:
 23927                                  	jc	short DATERR
 23928                                  	call	GET_DAY
 23929                                  TGET:
 23930                                  	jc	short DATERR
 23931                                  	call	GET_DSEP
 23932                                  	jc	short DATERR
 23933                                  	call	GET_YR
 23934                                  	jmp	short DAT_SET
 23935                                  
 23936                                  ; ---------------------------------------------------------------------------
 23937                                  
 23938                                  EUSDAT:
 23939                                  	call	GET_DAY
 23940                                  	jc	short DATERR
 23941                                  	call	GET_DSEP
 23942                                  	jc	short DATERR
 23943                                  	call	GET_MON
 23944                                  	jmp	short TGET
 23945                                  
 23946                                  ; =============== S U B	R O U T	I N E =======================================
 23947                                  
 23948                                  GET_MON:
 23949                                  	call	GETNUM		; Get one or two digit number
 23950                                  	jc	short DAT_SET_RETN
 23951                                  	mov	dh,ah		; Put in position
 23952                                  	retn
 23953                                  
 23954                                  
 23955                                  ; =============== S U B	R O U T	I N E =======================================
 23956                                  
 23957                                  GET_DAY:
 23958                                  		call	GETNUM
 23959                                  		mov	dl,ah		; Put in position
 23960                                  GET_DAY_RETN:
 23961                                  		retn
 23962                                  
 23963                                  ; =============== S U B	R O U T	I N E =======================================
 23964                                  
 23965                                  GET_YR:
 23966                                  	call	GETNUM
 23967                                  	jc	short GET_DAY_RETN
 23968                                  	mov	cx,1900
 23969                                  	call	GET_DSEP
 23970                                  	pushf
 23971                                  	dec	si
 23972                                  	popf
 23973                                  	jz	short BIAS
 23974                                  	cmp	byte [si],0Dh
 23975                                  	je	short BIAS
 23976                                  	cmp	byte [si],' '
 23977                                  	je	short BIAS
 23978                                  	cmp	byte [si],9
 23979                                  	je	short BIAS
 23980                                  	push	bx
 23981                                  	mov	bl,100
 23982                                  	mov	al,ah
 23983                                  	mul	bl
 23984                                  	pop	bx
 23985                                  	mov	cx,ax
 23986                                  	call	GETNUM
 23987                                  	jc	short GET_DAY_RETN
 23988                                  BIAS:
 23989                                  	mov	al,ah
 23990                                  	mov	ah,0
 23991                                  	add	cx,ax
 23992                                  BIAS_RETN:
 23993                                  	retn
 23994                                  
 23995                                  ; ---------------------------------------------------------------------------
 23996                                  
 23997                                  DATERR:
 23998                                  	mov	dx,BADDATPTR
 23999                                  	call	STD_PRINTF
 24000                                  	jmp	GETDAT
 24001                                  
 24002                                  ; =============== S U B	R O U T	I N E =======================================
 24003                                  
 24004                                  GET_DSEP:
 24005                                  	lodsb
 24006                                  	cmp	al,'/'
 24007                                  	je	short BIAS_RETN
 24008                                  	;cmp	al,'.'
 24009                                  	cmp	al,[DOT_CHR]
 24010                                  	je	short BIAS_RETN
 24011                                  	;cmp	al,'-'
 24012                                  	cmp	al,[CHAR_SUB]
 24013                                  	je	short BIAS_RETN
 24014                                  	stc
 24015                                  	retn
 24016                                  
 24017                                  ; =============== S U B	R O U T	I N E =======================================
 24018                                  
 24019                                  ; TIME gets and sets the time
 24020                                  
 24021                                  CTIME:
 24022                                  	mov	si,81h		; Accepting argument for time inline
 24023                                  	call	SCANOFF
 24024                                  	cmp	al,0Dh
 24025                                  	je	short PRMTTIM
 24026                                  	mov	bx,2E3Ah ; ":."
 24027                                  	call	INLINE
 24028                                  	jmp	COMTIM
 24029                                  
 24030                                  ; =============== S U B	R O U T	I N E =======================================
 24031                                  
 24032                                  PRINT_TIME:
 24033                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 24034                                  	int	21h	; DOS -	GET CURRENT TIME
 24035                                  			; Return: CH = hours,CL = minutes,DH = seconds
 24036                                  			; DL = hundredths of seconds
 24037                                  	push	di
 24038                                  	push	es
 24039                                  	push	cs
 24040                                  	pop	es
 24041                                  	mov	di,CHARBUF
 24042                                  	mov	bl,1	; Always 24 hour time
 24043                                  	call	P_TIME
 24044                                  	xor	ax,ax
 24045                                  	stosb
 24046                                  	mov	dx,CHARBUF
 24047                                  	mov	[STRING_PTR_2],dx
 24048                                  	mov	dx,STRINGBUF2PTR
 24049                                  	call	STD_PRINTF
 24050                                  	pop	es
 24051                                  	pop	di
 24052                                  P_TIME_RETN:
 24053                                  	retn
 24054                                  
 24055                                  ; =============== S U B	R O U T	I N E =======================================
 24056                                  
 24057                                  P_TIME:
 24058                                  	mov	al,ch	
 24059                                  	test	bl,7Fh		; Ignore high bit
 24060                                  	jnz	short T24	; 24 hr time?
 24061                                  	mov	bh,'a'		; Assume A.M.
 24062                                  	cmp	al,12		; In the afternoon?
 24063                                  	jb	short MORN
 24064                                  	mov	bh,'p'
 24065                                  	jz	short MORN
 24066                                  	sub	al,12		; Keep it to 12 hours or less
 24067                                  MORN:
 24068                                  	or	al,al		; Before 1 am?
 24069                                  	jnz	short T24
 24070                                  	mov	al,12
 24071                                  T24:
 24072                                  	push	bx
 24073                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 24074                                  	call	OUT2
 24075                                  	call	P_TSEP
 24076                                  	mov	al,cl
 24077                                  	call	OUT2
 24078                                  	pop	bx
 24079                                  	push	bx
 24080                                  	test	bl,80h
 24081                                  	jnz	short PAP	; If from DIR, go directly to am pm
 24082                                  	mov	bh,0		; Disable leading zero suppression
 24083                                  	call	P_TSEP
 24084                                  	mov	al,dh
 24085                                  	call	OUT2
 24086                                  	;mov	al,'.'
 24087                                  	mov	al,[DECIMAL_SEP]
 24088                                  	stosb
 24089                                  	mov	al,dl
 24090                                  	call	OUT2
 24091                                  PAP:
 24092                                  	pop	bx
 24093                                  	test	bl,7Fh		; Ignore high bit
 24094                                  	jnz	short P_TIME_RETN
 24095                                  	mov	al,bh
 24096                                  	stosb
 24097                                  	retn
 24098                                  
 24099                                  ; =============== S U B	R O U T	I N E =======================================
 24100                                  
 24101                                  P_TSEP:
 24102                                  	;mov	al,[TIME_SEP]
 24103                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 24104                                  	stosb
 24105                                  P_TSEP_RETN:
 24106                                  	retn
 24107                                  
 24108                                  ; ---------------------------------------------------------------------------
 24109                                  
 24110                                  PRMTTIM:
 24111                                  	mov	dx,CURTIMPTR
 24112                                  	call	STD_PRINTF	; Print "Current time is "
 24113                                  	call	PRINT_TIME
 24114                                  GETTIM:
 24115                                  	xor	cx,cx		; Initialize hours and minutes to zero
 24116                                  	mov	dx,NEWTIMPTR
 24117                                  	call	STD_PRINTF
 24118                                  	;mov	bx,':.'
 24119                                  	mov	bx,[TIMECHARS] 
 24120                                  	call	GETBUF
 24121                                  COMTIM:
 24122                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 24123                                  	jc	short TIMEERR
 24124                                  	mov	cx,dx
 24125                                  	xor	dx,dx
 24126                                  	lodsb
 24127                                  	cmp	al,0Dh
 24128                                  	je	short SAVTIM
 24129                                  	cmp	al,' '
 24130                                  	je	short GOTSEC2
 24131                                  	cmp	al,9
 24132                                  	je	short GOTSEC2
 24133                                  	cmp	al,bl
 24134                                  	je	short GOTSEC
 24135                                  	cmp	al,bh
 24136                                  	jne	short TIMEERR
 24137                                  GOTSEC:
 24138                                  	call	GETNUM
 24139                                  	jc	short TIMEERR
 24140                                  	mov	dh,ah		; Position seconds
 24141                                  	lodsb
 24142                                  	cmp	al,0Dh
 24143                                  	je	short SAVTIM
 24144                                  	cmp	al,' '
 24145                                  	je	short GOTSEC2
 24146                                  	cmp	al,9
 24147                                  	je	short GOTSEC2
 24148                                  	;cmp	al,'.'
 24149                                  	cmp	al,[DECIMAL_SEP]
 24150                                  	jne	short TIMEERR
 24151                                  	call	GETNUM
 24152                                  	jc	short TIMEERR
 24153                                  	mov	dl,ah
 24154                                  GOTSEC2:
 24155                                  	lodsb
 24156                                  	cmp	al,' '
 24157                                  	je	short GOTSEC2
 24158                                  	cmp	al,9
 24159                                  	je	short GOTSEC2
 24160                                  	cmp	al,0Dh
 24161                                  	jne	short TIMEERR
 24162                                  SAVTIM:
 24163                                  	mov	ah,SET_TIME ; 2Dh
 24164                                  	int	21h	; DOS -	SET CURRENT TIME
 24165                                  			; CH = hours,CL = minutes,DH = seconds,
 24166                                  			;		DL = hundredths of seconds
 24167                                  			; Return: AL = 00h if no error 
 24168                                  			;	     = FFh if bad value sent to routine
 24169                                  	or	al,al
 24170                                  P_TSEP_JRETN:
 24171                                  	jz	short P_TSEP_RETN ; Error in time?
 24172                                  TIMEERR:
 24173                                  	mov	dx,BADTIMPTR
 24174                                  	call	STD_PRINTF	; Print "Enter new time: "
 24175                                  	jmp	short GETTIM
 24176                                  
 24177                                  ; =============== S U B	R O U T	I N E =======================================
 24178                                  
 24179                                  GETBUF:
 24180                                  	mov	ah,Std_Con_String_Input ; 0Ah
 24181                                  	mov	dx,COMBUF
 24182                                  	mov	cx,2
 24183                                  	call	SETINITFLAG
 24184                                  	int	21h		; Get input line
 24185                                  	xor	cx,cx
 24186                                  	call	SETINITFLAG
 24187                                  	call	CRLF2
 24188                                  	mov	si,COMBUF+2
 24189                                  	cmp	byte [si],0Dh	; Check if new time entered
 24190                                  	jz	short P_TSEP_JRETN
 24191                                  
 24192                                  ; =============== S U B	R O U T	I N E =======================================
 24193                                  
 24194                                  INLINE:
 24195                                  	call	GETNUM		; Get one or two digit number
 24196                                  	jnb	short INLINE1
 24197                                  	retn
 24198                                  INLINE1:
 24199                                  	mov	dh,ah		; Put in position
 24200                                  	lodsb
 24201                                  	cmp	al,bl
 24202                                  	jz	short NEXT
 24203                                  	cmp	al,bh
 24204                                  	jz	short NEXT
 24205                                  	dec	si		; Clears zero flag
 24206                                  	clc
 24207                                  	mov	dl,0
 24208                                  	retn			; Time may have only an hour specified
 24209                                  NEXT:
 24210                                  	call	GETNUM
 24211                                  	mov	dl,ah		; Put in position
 24212                                  INLINE_RETN:
 24213                                  	retn
 24214                                  
 24215                                  ;============================================================================
 24216                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 24217                                  ;============================================================================
 24218                                  ; 05/10/2018 - Retro DOS v3.0
 24219                                  
 24220                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 24221                                  
 24222                                  ; =============== S U B	R O U T	I N E =======================================
 24223                                  
 24224                                  GETNUM:
 24225                                  	call	INDIG
 24226                                  	jb	short INLINE_RETN
 24227                                  	mov	ah,al		; Save first digit
 24228                                  	call	INDIG		; Another digit?
 24229                                  	jb	short OKRET
 24230                                  	aad			; Convert unpacked BCD to decimal
 24231                                  	mov	ah,al
 24232                                  OKRET:
 24233                                  	or	al,1
 24234                                  GETNUM_RETN:
 24235                                  	retn
 24236                                  
 24237                                  ; =============== S U B	R O U T	I N E =======================================
 24238                                  
 24239                                  INDIG:
 24240                                  	mov	al,[si]
 24241                                  	sub	al,'0'
 24242                                  	jc	short GETNUM_RETN
 24243                                  	cmp	al,10
 24244                                  	cmc
 24245                                  	jc	short GETNUM_RETN
 24246                                  	inc	si
 24247                                  	retn
 24248                                  
 24249                                  ; =============== S U B	R O U T	I N E =======================================
 24250                                  
 24251                                  OUT2:				; Output binary number as two ASCII digits
 24252                                  	aam			; Convert binary to unpacked BCD
 24253                                  	xchg	al,ah
 24254                                  	or	ax,3030h	; Add "0" bias to both digits
 24255                                  	cmp	al,'0'		; Is MSD zero?
 24256                                  	jnz	short NOSUP
 24257                                  	sub	al,bh		; Suppress leading zero if enabled
 24258                                  NOSUP:
 24259                                  	mov	bh,0		; Disable zero suppression
 24260                                  	stosw
 24261                                  	retn
 24262                                  
 24263                                  ; ---------------------------------------------------------------------------
 24264                                  	;stosb
 24265                                  	;retn
 24266                                  
 24267                                  ;============================================================================
 24268                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 24269                                  ;============================================================================
 24270                                  ; 03/10/2018 - Retro DOS v3.0
 24271                                  
 24272                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 24273                                  
 24274                                  ; =============== S U B	R O U T	I N E =======================================
 24275                                  
 24276                                  ; Set the special flag in the INIT flag to the value in CX.
 24277                                  
 24278                                  SETINITFLAG:
 24279                                  	mov	ds,[RESSEG]
 24280                                  	;and	byte [INITFLAG],0FDh
 24281                                  	and	byte [INITFLAG],~INITSPECIAL
 24282                                  	or	byte [INITFLAG],cl
 24283                                  	push	cs
 24284                                  	pop	ds
 24285                                  	retn
 24286                                  
 24287                                  ; =============== S U B	R O U T	I N E =======================================
 24288                                  
 24289                                  PIPEOFF:
 24290                                  	push	ds
 24291                                  	push	ax
 24292                                  	mov	ds,[cs:RESSEG]
 24293                                  	xor	al,al
 24294                                  	xchg	al,byte [PIPEFLAG]
 24295                                  	or	al,al
 24296                                  	jz	short PIPEOFFDONE
 24297                                  	shr	byte [ECHOFLAG],1
 24298                                  PIPEOFFDONE:
 24299                                  	pop	ax
 24300                                  	pop	ds
 24301                                  	retn
 24302                                  
 24303                                  ; ---------------------------------------------------------------------------
 24304                                  	;db    0,0,0,0,0
 24305                                  	;times 5 db 0
 24306                                  
 24307                                  align 16
 24308                                  
 24309                                  %endif
 24310                                  
 24311                                  ;============================================================================
 24312                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24313                                  ;============================================================================
 24314                                  ; 03/10/2018 - Retro DOS v3.0
 24315                                  
 24316                                  ;----------------------------------------------------------------------------
 24317                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24318                                  ; argv[argvcnt] array. The most important difference between this array and
 24319                                  ; the tradition UNIX format is the extra cparse information included with
 24320                                  ; each argument element.
 24321                                  ;---------------
 24322                                  ; ENTRY:
 24323                                  ;	BL	     special delimiter for cparse -- not implemented)
 24324                                  ;---------------
 24325                                  ; EXIT:
 24326                                  ;	CF	    set if error
 24327                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24328                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24329                                  ;	argvcnt     argument count
 24330                                  ;---------------
 24331                                  ; NOTE(S):
 24332                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24333                                  ;	*   Parseflags record contains cparse flags, as follows:
 24334                                  ;		sw_flag 	--	was this arg a switch?
 24335                                  ;		wildcard	--	whether or not it contained a * or ?
 24336                                  ;		path_sep	--	maybe it was a pathname
 24337                                  ;		unused		--	for future expansion
 24338                                  ;		special_delim	--	was there an initial special delimiter?
 24339                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24340                                  ;	*   Relationship between input, cparse output, and comtail can be
 24341                                  ;	    found in the following chart. Despite the claim of the cparse
 24342                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24343                                  ;	    tokens", such is not the case (see column two, row two).
 24344                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24345                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24346                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24347                                  ;	    documentation error.
 24348                                  ;	*   cparse also returns a switch code in BP for each switch it
 24349                                  ;	    recognizes on the command line.
 24350                                  ;	*   arglen for each token does NOT include the terminating null.
 24351                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24352                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24353                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24354                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24355                                  ;	    line parsing may result in slightly different behavior than
 24356                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24357                                  ;
 24358                                  ;	    Input		    Cparse		Command Line (80H)
 24359                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24360                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24361                                  ;	foo.bat 		foo.bat 		foo.bat
 24362                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24363                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24364                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24365                                  
 24366                                  ; =============== S U B	R O U T	I N E =======================================
 24367                                  
 24368                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24369                                  
 24370                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24371                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24372                                  
 24373                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24374                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24375                                  
 24376                                  ; 27/07/2024 - Retro DOS v4.0-v4.1-v4.2-v5.0 COMMAND.COM (PARSELINE)
 24377                                  ; PCDOS 7.1 - COMMAND.COM, transient portion/segment offset 35F5h
 24378                                  
 24379                                  PARSELINE:
 24380 00003035 50                      	push	ax			; most of these are clobbered
 24381 00003036 53                      	push	bx			; by cparse...
 24382 00003037 51                      	push	cx
 24383 00003038 52                      	push	dx
 24384 00003039 57                      	push	di
 24385 0000303A 56                      	push	si
 24386 0000303B 9C                      	pushf
 24387                                  	;mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24388 0000303C C706[9A93]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24389 00003042 31C0                    	xor	ax,ax
 24390                                  	;;mov	cx,1348
 24391                                  	; 27/07/2024
 24392                                  	;mov	cx,1092  ; PCDOS 7.1 COMMAND.COM
 24393 00003044 B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092
 24394 00003047 A2[398C]                	mov	[cpyflag],al ; 0 ; 27/07/2024
 24395 0000304A BF[D48D]                	mov	di,ARG
 24396 0000304D F3AA                    	rep	stosb
 24397                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24398 0000304F C706[1893][9890]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24399                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24400                                  	;mov	word [ARG+ARG_UNIT.argswinfo],0
 24401 00003055 A3[9690]                	mov	[ARG+ARG_UNIT.argswinfo],ax ; 0 ; 27/07/2024
 24402                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24403                                  	;mov	word [ARG+ARG_UNIT.argvcnt],0
 24404 00003058 A3[9490]                	mov	[ARG+ARG_UNIT.argvcnt],ax ; 0 ; 27/07/2024 
 24405 0000305B BE[2689]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24406                                  
 24407                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24408                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24409                                  ; otherwise. This is done so that commands can get arg pointers into their
 24410                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24411                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24412                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24413                                  ; the command to be repeated or the transient part of command has been
 24414                                  ; reloaded.
 24415                                  
 24416 0000305E 1E                      	push	ds
 24417 0000305F 8E1E[C58A]              	mov	ds,[RESSEG]
 24418                                  	;cmp	byte [ForFlag],0
 24419 00003063 3806[9401]              	cmp	[ForFlag],al ; 0 ; 27/07/2024
 24420 00003067 1F                      	pop	ds
 24421 00003068 7510                    	jnz	short PCONT
 24422                                  	;mov	di,ARG_ARGFORCOMBUF
 24423 0000306A BF[9891]                	mov	di,ARG+ARG_UNIT.argforcombuf
 24424 0000306D 30ED                    	xor	ch,ch
 24425 0000306F 8A0E[2589]              	mov	cl,[COMBUF+1]
 24426 00003073 FEC1                    	inc	cl
 24427 00003075 F3A4                    	rep	movsb
 24428                                  	;mov	si,ARG_ARGFORCOMBUF
 24429 00003077 BE[9891]                	mov	si,ARG+ARG_UNIT.argforcombuf
 24430                                  PCONT:
 24431 0000307A BF[1A93]                	mov	di,TPBUF	; destination is temporary token buffer
 24432 0000307D B320                    	mov	bl,' '		; no special delimiter, for now
 24433                                  PARSELOOP:
 24434 0000307F 8936[9C93]              	mov	[COMPTR],si	; save ptr into original command buffer
 24435 00003083 31ED                    	xor	bp,bp		; switch information put here by cparse
 24436 00003085 C606[B68D]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24437 0000308A E851F5                  	call	scanoff		; skip leading blanks...
 24438 0000308D E8C910                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24439 00003090 730B                    	jnb	short MORE_PRSE
 24440 00003092 09ED                    	or	bp,bp		; Check for trailing switch character
 24441 00003094 7403                    	jz	short PARSEDONE
 24442 00003096 E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24443                                  				;   typical cause of this is that a
 24444                                  				;   switch char IMMEDIATELY preceeds
 24445                                  				;   the CR. We have an argument, but it
 24446                                  				;   is sort of an error.
 24447                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24448                                  	; 01/03/2023
 24449                                  PARSEDONE:
 24450 00003099 9D                      	popf
 24451 0000309A F8                      	clc
 24452 0000309B EB0C                    	jmp	short PARSE_EXIT
 24453                                  
 24454                                  MORE_PRSE:
 24455 0000309D C606[398C]02            	mov	byte [cpyflag],2
 24456                                  				; tell CPARSE that 1st token is done
 24457 000030A2 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24458 000030A5 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24459                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24460                                  	; 01/03/2023
 24461                                  ;PARSEDONE:
 24462                                  	;popf
 24463                                  	;clc
 24464                                  	;jmp	short PARSE_EXIT
 24465                                  
 24466                                  PARSE_ERROR:			; error entry (er, exit) point
 24467 000030A7 9D                      	popf
 24468 000030A8 F9                      	stc
 24469                                  PARSE_EXIT:			; depend on not changing CF
 24470 000030A9 5E                      	pop	si
 24471 000030AA 5F                      	pop	di
 24472 000030AB 5A                      	pop	dx
 24473 000030AC 59                      	pop	cx
 24474 000030AD 5B                      	pop	bx
 24475 000030AE 58                      	pop	ax
 24476 000030AF C3                      	retn
 24477                                  
 24478                                  ; =============== S U B	R O U T	I N E =======================================
 24479                                  
 24480                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24481                                  ;
 24482                                  ; ENTRY:
 24483                                  ;   BH			argflags
 24484                                  ;   CX			character count in argstring
 24485                                  ;   DI			pointer to argstring
 24486                                  ;   comptr		ptr to starting loc of current token in original command
 24487                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24488                                  ; EXIT:
 24489                                  ;   argbufptr		points to next free section of argbuffer
 24490                                  ;   arg.argbuf		contains null-terminated argument strings
 24491                                  ;   arg.argvcnt 	argument count
 24492                                  ;   arg.argv[]		array of flags and pointers
 24493                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24494                                  ;   CF			set if error
 24495                                  ;   AL			carry set:  error code; otherwise, zero
 24496                                  
 24497                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24498                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24499                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM 
 24500                                  	;	     & Retro DOS v4.1 COMMAND.COM (2024 modification)
 24501                                  newarg:
 24502 000030B0 53                      	push	bx
 24503 000030B1 51                      	push	cx
 24504 000030B2 52                      	push	dx
 24505 000030B3 57                      	push	di
 24506 000030B4 56                      	push	si
 24507 000030B5 9C                      	pushf
 24508 000030B6 E86200                  	call	arg_switch		; if it's a switch, record switch info
 24509                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24510                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24511                                  
 24512                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24513 000030B9 833E[9490]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24514 000030BE 7D50                    	jge	short to_many_args	; exceeded array limits
 24515 000030C0 88FE                    	mov	dh,bh			
 24516                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24517 000030C2 8B1E[9490]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24518                                  	;inc	word [ARG_ARGVCNT]
 24519 000030C6 FF06[9490]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24520                                  	;mov	ax,ARG_ARGV
 24521 000030CA B8[D48D]                	mov	ax,ARG+ARG_UNIT.argv
 24522 000030CD E87E00                  	call	argv_calc		; convert offset to pointer
 24523                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24524                                  	;mov	word [bx+7],0
 24525 000030D0 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24526                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24527                                  	;mov	[bx+5],cx
 24528 000030D5 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24529                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24530                                  	;mov	[bx+2],dh
 24531 000030D8 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24532 000030DB 8B36[1893]              	mov	si,[ARGBUF_PTR]
 24533                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24534                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24535 000030DF 8937                    	mov	[bx],si			
 24536 000030E1 0336[7B8D]              	add	si,[STARTEL]		; save startel from new location
 24537 000030E5 29FE                    	sub	si,di			; form pointer into argbuf
 24538                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24539                                  	;mov	[bx+3],si
 24540 000030E7 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24541 000030EA 8B36[9C93]              	mov	si,[COMPTR]
 24542                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24543                                  	;mov	[bx+9],si
 24544 000030EE 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24545 000030F1 89FE                    	mov	si,di			; now save argstring in argbuffer
 24546 000030F3 8B3E[1893]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24547                                  
 24548                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24549                                  ; PCDOS 7.1 COMMAND.COM
 24550                                  %if 0
 24551                                  	add	di,cx			; sure we're not about to run off
 24552                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24553                                  	;;cmp	di,ARG_ARGBUF+255
 24554                                  	;cmp	di,ARG+ARG_UNIT.argbuf+127
 24555                                  	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24556                                  	jge	short buf_oflow		; the end of the buffer (plus null byte)
 24557                                  	sub	di,cx
 24558                                  %else
 24559                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24560                                  	;mov	bx,ARG_ARGBUF+127
 24561 000030F7 BB[1791]                	mov	bx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24562 000030FA 29FB                    	sub	bx,di	; sure we're not about to run off
 24563 000030FC 39CB                    	cmp	bx,cx
 24564 000030FE 7302                    	jnb	short newarg_@
 24565 00003100 89D9                    	mov	cx,bx	
 24566                                  %endif
 24567                                  
 24568                                  newarg_@:	; 27/07/2024
 24569 00003102 FC                      	cld
 24570 00003103 F3A4                    	rep	movsb
 24571 00003105 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24572 00003107 AA                      	stosb
 24573 00003108 893E[1893]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24574                                  newarg_done:
 24575 0000310C 9D                      	popf
 24576 0000310D F8                      	clc
 24577 0000310E EB05                    	jmp	short newarg_exit
 24578                                  
 24579                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24580                                  ; PCDOS 7.1 COMMAND.COM
 24581                                  %if 0
 24582                                  to_many_args:
 24583                                  	mov	ax,1
 24584                                  	jmp	short newarg_error
 24585                                  buf_oflow:
 24586                                  	mov	ax,2
 24587                                  %else
 24588                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 24589                                  ;buf_oflow:
 24590                                  ;	; 27/07/2024
 24591                                  ;	; PCDOS 7.1 COMMAND.COM
 24592                                  ;	sub	di,cx
 24593                                  ;	;mov	cx,ARG_ARGBUF+7Fh
 24594                                  ;	mov	cx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24595                                  ;	sub	cx,di
 24596                                  ;	jmp     short newarg_@
 24597                                  to_many_args:
 24598 00003110 B80100                  	mov	ax,1
 24599                                  %endif
 24600                                  
 24601                                  newarg_error:
 24602 00003113 9D                      	popf
 24603 00003114 F9                      	stc
 24604                                  newarg_exit:
 24605 00003115 5E                      	pop	si
 24606 00003116 5F                      	pop	di
 24607 00003117 5A                      	pop	dx
 24608 00003118 59                      	pop	cx
 24609 00003119 5B                      	pop	bx
 24610 0000311A C3                      	retn
 24611                                  
 24612                                  ; =============== S U B	R O U T	I N E =======================================
 24613                                  
 24614                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24615                                  ; event that it is, and we can recognize
 24616                                  ;
 24617                                  ; ENTRY:
 24618                                  ;   As in <newarg>.
 24619                                  ; EXIT:
 24620                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24621                                  ; NOTE(S):
 24622                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24623                                  ;	on the order of definition in the <switch_list> variable and the
 24624                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24625                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24626                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24627                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24628                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24629                                  ;   *	An ugly routine.
 24630                                  
 24631                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24632                                  arg_switch:
 24633 0000311B 50                      	push	ax
 24634 0000311C 53                      	push	bx
 24635 0000311D 51                      	push	cx
 24636 0000311E 57                      	push	di
 24637 0000311F 9C                      	pushf
 24638 00003120 F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24639 00003123 741C                    	jz	short arg_no_switch0
 24640 00003125 833E[9A93]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24641 0000312A 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24642 0000312C 8B1E[9A93]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24643                                  	;mov	ax,offset TRANGROUP:arg.argv
 24644                                  	;mov	ax,ARG_ARGV
 24645 00003130 B8[D48D]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24646 00003133 E81800                  	call	argv_calc
 24647                                  	;or	[BX].argsw_word,BP
 24648                                  	;or	[bx+7],bp
 24649 00003136 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24650                                  	;or	arg.argswinfo,BP
 24651                                  	;or	[ARG_ARGSWINFO],bp
 24652 00003139 092E[9690]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24653                                  arg_yes_switch:
 24654 0000313D 9D                      	popf
 24655 0000313E F9                      	stc
 24656 0000313F EB08                    	jmp	short arg_switch_exit
 24657                                  
 24658                                  arg_no_switch0:
 24659                                  	;mov	ax,[ARG_ARGVCNT]
 24660 00003141 A1[9490]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24661 00003144 A3[9A93]                	mov	[LASTARG],ax
 24662                                  arg_no_switch1:
 24663 00003147 9D                      	popf
 24664 00003148 F8                      	clc
 24665                                  arg_switch_exit:
 24666 00003149 5F                      	pop	di
 24667 0000314A 59                      	pop	cx
 24668 0000314B 5B                      	pop	bx
 24669 0000314C 58                      	pop	ax
 24670 0000314D C3                      	retn
 24671                                  
 24672                                  ; =============== S U B	R O U T	I N E =======================================
 24673                                  
 24674                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24675                                  ; the supplied array.  Method used for computing the address is:
 24676                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24677                                  ; ENTRY:
 24678                                  ;   AX	    --	    base of array
 24679                                  ;   BX	    --	    array index
 24680                                  ; EXIT:
 24681                                  ;   BX	    --	    byte offset
 24682                                  
 24683                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24684                                  argv_calc:
 24685 0000314E 50                      	push	ax		; Save base
 24686 0000314F 88D8                    	mov	al,bl		; al = array index
 24687                                  	;mov	bl,11
 24688 00003151 B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24689 00003153 F6E3                    	mul	bl		; ax = base offset
 24690 00003155 5B                      	pop	bx		; Get base
 24691 00003156 01D8                    	add	ax,bx		; Add in base offset
 24692 00003158 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24693 00003159 C3                      	retn
 24694                                  
 24695                                  ; ---------------------------------------------------------------------------
 24696                                  	
 24697                                  	;db 0Ah dup(0)
 24698                                  	;times 10 db 0
 24699                                  
 24700 0000315A 90<rep 6h>              align 16
 24701                                  
 24702                                  ;============================================================================
 24703                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24704                                  ;============================================================================
 24705                                  ; 03/10/2018 - Retro DOS v3.0
 24706                                  
 24707                                  ;----------------------------------------------------------------------------
 24708                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24709                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24710                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24711                                  ;    file on disk. Directories specified in the user's search path will be
 24712                                  ;    searched for a matching file, if a match is not found in the current
 24713                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24714                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24715                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24716                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24717                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24718                                  ;    (easily) modified to make no assumptions about where its input is found.
 24719                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24720                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24721                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24722                                  ;    else that wants to save the whole shebang and then process other command
 24723                                  ;    lines.
 24724                                  ;
 24725                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24726                                  ;
 24727                                  ; ENTRY:
 24728                                  ;   <Path_Search>:	    argv[0].
 24729                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24730                                  ; EXIT:
 24731                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24732                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24733                                  ; NOTE(S):
 24734                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24735                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24736                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24737                                  ;	does not function as specified; see <Parseline> for more details.
 24738                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24739                                  ;	need to know about. This extra information is stored in a switch_flag
 24740                                  ;	word with each command-line argument; the switches themselves will not
 24741                                  ;	appear in the resulting arg structure.
 24742                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24743                                  ;----------------------------------------------------------------------------
 24744                                  
 24745                                  ; =============== S U B	R O U T	I N E =======================================
 24746                                  
 24747                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24748                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24749                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24750                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24751                                  ; have a match, either in the current working directory if we were handed
 24752                                  ; a filename, or in the specified directory, given a pathname. If this call
 24753                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24754                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24755                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24756                                  ; either the first invocation of search or on one of the succeeding calls
 24757                                  ; sets up the appropriate information for copying the successful pathname
 24758                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24759                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24760                                  ;
 24761                                  ; ENTRY:
 24762                                  ;   argv[0]		--	command name and associated information
 24763                                  ; EXIT:
 24764                                  ;   AX			--	non-zero indicates type of file found
 24765                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24766                                  ; NOTE(S):
 24767                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24768                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24769                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24770                                  ;	if search returns an .exe or .bat.
 24771                                  ;   5)	Clobbers dma address.
 24772                                  
 24773                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24774                                  PATH_SEP_CHAR	EQU	';'
 24775                                  
 24776                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24777                                  
 24778                                  	;special_delim equ 128
 24779                                  	;path_sep equ 4
 24780                                  	;wildcard equ 2
 24781                                  	;sw_flag  equ 1
 24782                                  
 24783                                  ;----------------------------------------------------------------------------
 24784                                  
 24785                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24786                                  
 24787                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24788                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24789                                  
 24790                                  path_search:
 24791 00003160 53                      	push	bx
 24792 00003161 51                      	push	cx
 24793 00003162 52                      	push	dx		; could use a "stack 'em" instruction
 24794 00003163 56                      	push	si
 24795 00003164 57                      	push	di
 24796 00003165 55                      	push	bp
 24797 00003166 9C                      	pushf
 24798                                  
 24799                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24800                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24801 00003167 F606[D68D]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24802 0000316C 7403                    	jz	short path_search_ok
 24803                                  path_failure_jmp:
 24804 0000316E E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24805                                  
 24806                                  path_search_ok:
 24807 00003171 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24808 00003174 BA[9E93]                	mov	dx,FBUF		; clobber old dma value with
 24809 00003177 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24810 0000317A CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24811                                  			; DS:DX	-> disk	transfer buffer
 24812 0000317C 06                      	push	es
 24813 0000317D E88DF1                  	call	find_path	; get a handle (ES:DI) on user path
 24814 00003180 8C06[C993]              	mov	[pathinfo+0],es	; and squirrel it away
 24815 00003184 893E[CB93]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24816 00003188 893E[CD93]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24817 0000318C 07                      	pop	es
 24818                                  	
 24819 0000318D BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24820 00003190 BE[ED89]                	mov	si,EXECPATH
 24821 00003193 E88002                  	call	STRIP
 24822 00003196 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24823                                  		
 24824 00003198 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24825 0000319A C706[1E94][777F]        	mov	word [search_error],baddrv_ptr
 24826 000031A0 E89F01                  	call	PSEARCH		; must do at least one search
 24827 000031A3 09C0                    	or	ax,ax		; find anything?
 24828 000031A5 7469                    	jz	short path_noinit
 24829                                  				; failure ... search farther
 24830 000031A7 89C5                    	mov	bp,ax		; success... save filetype code
 24831 000031A9 BF[ED89]                	mov	di,EXECPATH
 24832                                  	;mov	si,ds:arg.argv[0].argpointer
 24833                                  	;mov	si,[ARG_ARGV]
 24834 000031AC 8B36[D48D]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24835                                  	;mov	cx,ds:arg.argv[0].argstartel
 24836                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24837 000031B0 8B0E[D78D]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24838 000031B4 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24839                                  
 24840                                  ; We have the number of bytes in the prefix (up to the final component).
 24841                                  ; We need to form the complete pathname including leading drive and current
 24842                                  ; directory.
 24843                                  ;
 24844                                  ; Is there a drive letter present?
 24845                                  
 24846 000031B6 B43A                    	mov	ah,':'
 24847 000031B8 83F902                  	cmp	cx,2		; room for drive letter?
 24848 000031BB 7205                    	jb	short adddrive	; no, stick it in
 24849 000031BD 386401                  	cmp	[si+1],	ah	; colon present?
 24850 000031C0 7408                    	je	short movedrive	; yes, just move it
 24851                                  adddrive:
 24852 000031C2 A0[D98A]                	mov	al,[CURDRV]	; get current drive
 24853 000031C5 0441                    	add	al,'A'		; convert to uppercase letter
 24854 000031C7 AB                      	stosw			; store d:
 24855 000031C8 EB05                    	jmp	short checkpath
 24856                                  
 24857                                  movedrive:
 24858 000031CA AD                      	lodsw			; move d:
 24859 000031CB AB                      	stosw
 24860 000031CC 83E902                  	sub	cx,2		; 2 bytes less to move
 24861                                  checkpath:
 24862 000031CF 0C20                    	or	al,20h
 24863 000031D1 88C2                    	mov	dl,al
 24864                                  	;sub	dl,60h
 24865 000031D3 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24866                                  
 24867                                  ; Stick in beginning path char
 24868                                  
 24869 000031D6 A0[CF93]                	mov	al,[psep_char]
 24870 000031D9 AA                      	stosb
 24871                                  
 24872                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24873                                  ; Otherwise, get current dir for DL.
 24874                                  
 24875 000031DA 83F901                  	cmp	cx,1		; is there room for path char?
 24876 000031DD 720A                    	jb	short addpath	; no, go add path
 24877 000031DF AC                      	lodsb
 24878 000031E0 49                      	dec	cx
 24879 000031E1 3A06[CF93]              	cmp	al,[psep_char]	; is there a path separator?
 24880 000031E5 741C                    	je	short movepath	; yes, go move remainder of path
 24881 000031E7 41                      	inc	cx
 24882 000031E8 4E                      	dec	si		; undo the lodsb
 24883                                  addpath:
 24884 000031E9 56                      	push	si
 24885 000031EA 89FE                    	mov	si,di		; remainder of buffer
 24886 000031EC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24887 000031EF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24888                                  			; DL = drive (0=default,1=A,etc.)
 24889                                  			; DS:SI	points to 64-byte buffer area
 24890                                  
 24891                                  ; The previous current dir will succeed a previous find_first already worked.
 24892                                  ;
 24893                                  ; Find end of string.
 24894                                  
 24895 000031F1 89F7                    	mov	di,si
 24896 000031F3 5E                      	pop	si
 24897 000031F4 A0[CF93]                	mov	al,[psep_char]
 24898 000031F7 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24899 000031FA 7407                    	jz	short movepath	; yes, no need for path char
 24900                                  scanend:
 24901                                  	;cmp	byte [di],0	; end of string?
 24902                                  	;jz	short foundend
 24903                                  	;inc	di
 24904                                  	;jmp	short scanend
 24905                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24906 000031FC 47                      	inc	di
 24907 000031FD 803D00                  	cmp	byte [di],0
 24908 00003200 75FA                    	jnz	short scanend
 24909                                  
 24910                                  ; Stick in a trailing path char.
 24911                                  
 24912                                  foundend:
 24913 00003202 AA                      	stosb
 24914                                  
 24915                                  ; Move remaining part of path. Skip leading path char if present.
 24916                                  
 24917                                  movepath:
 24918 00003203 3804                    	cmp	[si],al		; first char a path char?
 24919 00003205 7502                    	jne	short copypath
 24920                                  	; 26/04/2023
 24921 00003207 46                      	inc	si		; move past leading char
 24922 00003208 49                      	dec	cx		; drop from count
 24923                                  copypath:
 24924 00003209 E302                    	jcxz	_copydone	; no chars to move!
 24925 0000320B F3A4                    	rep	movsb
 24926                                  _copydone:
 24927 0000320D E9A100                  	jmp	path_success
 24928                                  				; run off and form complete pathname
 24929                                  path_noinit:
 24930                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24931                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24932 00003210 F606[D68D]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24933 00003215 751B                    	jnz	short path_failure
 24934                                  				; complete pathname specified ==> fail
 24935                                  	;mov	bh,';'
 24936 00003217 B73B                    	mov	bh,PATH_SEP_CHAR
 24937                                  				; semicolon terminates pathstring
 24938                                  	;mov	dx,ds:arg.argv[0].argstartel
 24939                                  				; this is where the last element starts
 24940                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24941 00003219 8B16[D78D]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24942                                  	;sub	dx,ds:arg.argv[0].argpointer
 24943                                  				; form pointer into EXECPATH,
 24944                                  	;sub	dx,[ARG_ARGV]
 24945 0000321D 2B16[D48D]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24946 00003221 81C2[ED89]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24947                                  path_loop:
 24948 00003225 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24949 00003228 89C5                    	mov	bp,ax		; save filetype code
 24950 0000322A 9F                      	lahf			; save flags, just in case
 24951 0000322B 09ED                    	or	bp,bp		; did path_crunch find anything?
 24952 0000322D 7508                    	jnz	short path_found
 24953 0000322F 9E                      	sahf			; see? needed those flags, after all!
 24954 00003230 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24955                                  path_failure:
 24956 00003232 31C0                    	xor	ax,ax
 24957 00003234 E98700                  	jmp	path_exit
 24958                                  
 24959                                  path_found:				; pathinfo[] points to winner
 24960 00003237 BF[ED89]                	mov	di,EXECPATH
 24961                                  	;mov	cx,pathinfo[4]
 24962 0000323A 8B0E[CD93]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24963                                  	;mov	si,pathinfo[2]
 24964 0000323E 8B36[CB93]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24965                                  
 24966                                  ;	BAS Nov 20/84
 24967                                  ;   Look at the pathname and expand . and .. if they are the first element
 24968                                  ;   in the pathname (after the drive letter)
 24969                                  
 24970 00003242 06                      	push	es
 24971                                  	;push	pathinfo[0]
 24972 00003243 FF36[C993]              	push	word [pathinfo+0]
 24973 00003247 07                      	pop	es
 24974                                  ;SR;
 24975                                  ; Oops! Gets fooled if path= \;..
 24976                                  ; We should also check if a drive letter is really present
 24977                                  ;
 24978 00003248 26807C022E              	cmp	byte [es:si+2],'.'
 24979                                  				; Look for Current dir at start of path
 24980 0000324D 7534                    	jne	short path_cpy
 24981                                  
 24982                                  	; 18/03/2023
 24983                                  	; MSDOS 6.0
 24984 0000324F 26807C013A              	cmp	byte [es:si+1],':'
 24985                                  				; does path have drive letter?
 24986 00003254 752D                    	jne	short path_cpy	; no, copy the path string
 24987                                  
 24988 00003256 51                      	push	cx		; Save pointer to end of string
 24989                                  	;mov	al,[es:si]
 24990                                  	;mov	[di],al		; Copy drive letter, :, and root char
 24991                                  	;mov	al,[es:si+1]	; to EXECPATH
 24992                                  	;mov	[di+1],al
 24993                                  	; 05/05/2023
 24994 00003257 268B04                  	mov	ax,[es:si]
 24995 0000325A 8905                    	mov	[di],ax
 24996 0000325C A0[CF93]                	mov	al,[psep_char]
 24997 0000325F 884502                  	mov	[di+2],al
 24998 00003262 56                      	push	si		; Save pointer to begining of string
 24999 00003263 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25000 00003266 80CA20                  	or	dl,20h
 25001                                  	;sub	dl,60h
 25002 00003269 80EA60                  	sub	dl,'a'-1
 25003 0000326C 89FE                    	mov	si,di		; pointer to EXECPATH
 25004 0000326E 83C603                  	add	si,3		; Don't wipe out drive and root info
 25005 00003271 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25006 00003274 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25007                                  			; DL = drive (0=default,1=A,etc.)
 25008                                  			; DS:SI	points to 64-byte buffer area
 25009 00003276 E8F3F9                  	call	dstrlen		; Determine length of present info
 25010 00003279 01CE                    	add	si,cx		; Don't copy over drive and root info
 25011 0000327B 4E                      	dec	si
 25012 0000327C 89F7                    	mov	di,si		; Point to end of target string
 25013 0000327E 5E                      	pop	si		; Restore pointer to begining of string
 25014 0000327F 83C603                  	add	si,3		; Point past drive letter, :, .
 25015 00003282 59                      	pop	cx		; Restore pointer to end of string
 25016                                  path_cpy:
 25017 00003283 07                      	pop	es
 25018 00003284 29F1                    	sub	cx,si		; yields character count
 25019 00003286 1E                      	push	ds		; time to switch segments
 25020 00003287 FF36[C993]              	push	word [pathinfo+0]
 25021                                  				; string lives in this segment
 25022 0000328B 1F                      	pop	ds
 25023 0000328C FC                      	cld
 25024                                  
 25025                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25026                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25027                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25028                                  kloop:
 25029 0000328D AC                      	lodsb			;AN000;  3/3/KK
 25030 0000328E AA                      	stosb			;AN000;  3/3/KK
 25031 0000328F E82DF1                  	call	testkanj	;AN000;  3/3/KK
 25032 00003292 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25033 00003294 49                      	dec	cx		;AN000;  3/3/KK
 25034 00003295 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25035 00003297 A4                      	movsb			;AN000;  3/3/KK
 25036 00003298 49                      	dec	cx		;AN000;  3/3/KK
 25037 00003299 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25038 0000329C 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25039                                  popdone:			;AN000;  3/3/KK
 25040 0000329E 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25041 0000329F A0[CF93]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25042 000032A2 EB0C                    	jmp	short path_store
 25043                                  				;AN000;  3/3/KK
 25044                                  _notkanj1:
 25045                                  	; 26/04/2023
 25046 000032A4 E2E7                    	loop	kloop
 25047 000032A6 1F                      	pop	ds		; return to our segment
 25048 000032A7 4F                      	dec	di		; overwrite terminator
 25049 000032A8 A0[CF93]                	mov	al,[psep_char]	; with a pathname separator
 25050 000032AB 3A45FF                  	cmp	al,[di-1]
 25051 000032AE 7401                    	je	short path_success
 25052                                  path_store:
 25053 000032B0 AA                      	stosb
 25054                                  path_success:
 25055 000032B1 BE[D193]                	mov	si,search_best_buf
 25056 000032B4 31C9                    	xor	cx,cx
 25057                                  path_succ_loop:
 25058 000032B6 AC                      	lodsb			; append winning filename to path
 25059 000032B7 AA                      	stosb			; (including terminating null)
 25060 000032B8 08C0                    	or	al,al
 25061 000032BA 75FA                    	jnz	short path_succ_loop
 25062 000032BC 89E8                    	mov	ax,bp		; retrieve filetype code
 25063                                  path_exit:
 25064 000032BE 9D                      	popf
 25065 000032BF 5D                      	pop	bp
 25066 000032C0 5F                      	pop	di
 25067 000032C1 5E                      	pop	si		; chill out...
 25068 000032C2 5A                      	pop	dx
 25069 000032C3 59                      	pop	cx
 25070 000032C4 5B                      	pop	bx
 25071 000032C5 C3                      	retn
 25072                                  
 25073                                  ; =============== S U B	R O U T	I N E =======================================
 25074                                  
 25075                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25076                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25077                                  ;
 25078                                  ; ENTRY:
 25079                                  ; EXIT:
 25080                                  ; NOTE(S):
 25081                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25082                                  
 25083                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25084                                  STORE_PCHAR:
 25085 000032C6 50                      	push	ax
 25086 000032C7 B02F                    	mov	al,'/'		; is the pathname-element separator
 25087 000032C9 E8A0F3                  	call	pathchrcmp	; a regular slash?
 25088 000032CC 7402                    	jz	short STORE_SLASH
 25089                                  				; if yes, remember slash
 25090 000032CE B05C                    	mov	al,'\'
 25091                                  	; 18/03/2023
 25092                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25093                                  	;pop	ax
 25094                                  	;retn
 25095                                  STORE_SLASH:
 25096 000032D0 A2[CF93]                	mov	[psep_char],al
 25097 000032D3 58                      	pop	ax
 25098 000032D4 C3                      	retn
 25099                                  
 25100                                  ; =============== S U B	R O U T	I N E =======================================
 25101                                  
 25102                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25103                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25104                                  ; additional separator to use for breaking up the path-string. Null is the
 25105                                  ; default. Once the user-string has been formed, search is invoked to see
 25106                                  ; what's out there.
 25107                                  ;
 25108                                  ; ENTRY:
 25109                                  ;   BH			--	additional terminator character
 25110                                  ;   SI			--	pointer into pathstring to be dissected
 25111                                  ;   DX			--	pointer to stripped filename
 25112                                  ; EXIT:
 25113                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25114                                  ;   SI			--	moves along pathstring from call to call
 25115                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25116                                  ;   [tpbuf]		--	clobbered
 25117                                  ; NOTE(S):
 25118                                  ;   *	Implicit in this code is the ability to specify when to search
 25119                                  ;	the current directory (if at all) through the PATH defined by
 25120                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25121                                  ;	current directory before the bin and etc directories of drive c).
 25122                                  
 25123                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25124                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25125                                  
 25126                                  path_crunch:
 25127 000032D5 53                      	push	bx
 25128 000032D6 51                      	push	cx
 25129 000032D7 52                      	push	dx
 25130 000032D8 57                      	push	di
 25131 000032D9 56                      	push	si
 25132                                  	;pushf	; ** ; 18/03/2023
 25133 000032DA E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25134 000032DD BF[1A93]                	mov	di,TPBUF	; destination of concatenated string
 25135 000032E0 8B36[CD93]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25136 000032E4 8936[CB93]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25137 000032E8 1E                      	push	ds		; save old segment pointer
 25138 000032E9 FF36[C993]              	push	word [pathinfo+0]
 25139                                  				; replace with pointer to userpath's
 25140 000032ED 1F                      	pop	ds		; segment
 25141                                  	; 26/04/2023
 25142 000032EE 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK
 25143                                  path_cr_copy:
 25144 000032F0 AC                      	lodsb			; get a pathname byte
 25145 000032F1 08C0                    	or	al,al		; check for terminator(s)
 25146 000032F3 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25147 000032F5 38F8                    	cmp	al,bh
 25148 000032F7 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25149                                  	;
 25150                                  	; 18/03/2023
 25151                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25152 000032F9 E8C3F0                  	call	testkanj	;AN000; 3/3/KK
 25153 000032FC 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25154 000032FE AA                      	stosb			;AN000; 3/3/KK
 25155 000032FF A4                      	movsb			;AN000; 3/3/KK
 25156 00003300 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK
 25157 00003302 EBEC                    	jmp	short path_cr_copy
 25158                                  _notkanj2:
 25159 00003304 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25160                                  	;
 25161 00003306 AA                      	stosb
 25162 00003307 EBE7                    	jmp	short path_cr_copy
 25163                                  
 25164                                  path_seg:
 25165 00003309 1F                      	pop	ds		; restore old data segment
 25166 0000330A 8936[CD93]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25167 0000330E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25168                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25169 00003310 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25170 00003312 81FF[1A93]              	cmp	di,TPBUF	; was there really anything in pathstr?
 25171 00003316 7421                    	je	short path_cr_leave
 25172                                  				; if nothing was copied, pathstr empty
 25173                                  path_cr_look:
 25174 00003318 A0[CF93]                	mov	al,[psep_char]	; form complete pathname
 25175                                  	;
 25176                                  	; 18/03/2023
 25177                                  	; MSDOS 6.0
 25178 0000331B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25179 0000331D 7505                    	jnz	short path_cr_store
 25180                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25181                                  	;
 25182 0000331F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25183 00003322 7401                    	je	short path_cr_l1
 25184                                  path_cr_store:
 25185 00003324 AA                      	stosb
 25186                                  path_cr_l1:
 25187 00003325 89D6                    	mov	si,dx
 25188                                  path_cr_l2:
 25189 00003327 AC                      	lodsb			; tack the stripped filename onto
 25190 00003328 AA                      	stosb			; the end of the path, up to and
 25191 00003329 08C0                    	or	al,al		; including the terminating null
 25192 0000332B 75FA                    	jnz	short path_cr_l2
 25193 0000332D BA[1A93]                	mov	dx,TPBUF	; and look for an appropriate file...
 25194 00003330 C706[1E94][7380]        	mov	word [search_error],BADPMES_PTR
 25195                                  	;invoke search
 25196 00003336 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25197                                  
 25198                                  	; 18/03/2023
 25199                                  ;path_cr_leave:
 25200                                  	;or	bl,bl		; did we finish off the pathstring?
 25201                                  	;jz	short path_cr_empty
 25202                                  	;			; null in BL means all gone...
 25203                                  	;popf	; **		; otherwise, plenty left
 25204                                  	;clc
 25205                                  	;jmp	short path_cr_exit
 25206                                  ;path_cr_empty:
 25207                                  	;popf	; **
 25208                                  	;stc
 25209                                  ;path_cr_exit:
 25210                                  
 25211                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25212                                  path_cr_leave:
 25213                                  	;popf ; ** ; 18/03/2023
 25214 00003339 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25215                                  
 25216                                  path_cr_exit:
 25217 0000333C 5E                      	pop	si
 25218 0000333D 5F                      	pop	di
 25219 0000333E 5A                      	pop	dx
 25220 0000333F 59                      	pop	cx
 25221 00003340 5B                      	pop	bx
 25222 00003341 C3                      	retn
 25223                                  
 25224                                  ;============================================================================
 25225                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25226                                  ;============================================================================
 25227                                  ; 02/10/2018 - Retro DOS v3.0
 25228                                  
 25229                                  ;----------------------------------------------------------------------------
 25230                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25231                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25232                                  ; lowest priority). Where conflicts arise, the extension with
 25233                                  ; the highest priority is favored.
 25234                                  ; ENTRY:
 25235                                  ;   DX		--	pointer to null-terminated pathname
 25236                                  ;   fbuf	--	dma buffer for findfirst/next
 25237                                  ; EXIT:
 25238                                  ;   AX		--	8)  file found with .com extension
 25239                                  ;			4)  file found with .exe extension
 25240                                  ;			2)  file found with .bat extension
 25241                                  ;			0)  no such file to be found
 25242                                  ;   (if AX is non-zero:)
 25243                                  ;   [search_best]	identical to AX
 25244                                  ;   [search_best_buf]	null-terminated filename
 25245                                  ; NOTES:
 25246                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25247                                  ;---------------
 25248                                  ; CONSTANTS:
 25249                                  ;---------------
 25250                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25251                                  SEARCH_COM		EQU	8
 25252                                  SEARCH_EXE		EQU	4
 25253                                  SEARCH_BAT		EQU	2
 25254                                  FNAME_LEN		EQU	8
 25255                                  FNAME_MAX_LEN		EQU	13
 25256                                  DOT			EQU	'.'
 25257                                  WILDCHAR		EQU	'?'
 25258                                  
 25259                                  
 25260                                  ; =============== S U B	R O U T	I N E =======================================
 25261                                  
 25262                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25263                                  
 25264                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25265                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25266                                  	
 25267                                  PSEARCH:
 25268 00003342 51                      	push	cx
 25269 00003343 52                      	push	dx
 25270 00003344 57                      	push	di
 25271 00003345 56                      	push	si
 25272                                  	;pushf	; ** ; 18/03/2023
 25273 00003346 52                      	push	dx		; check drivespec (save pname ptr)
 25274 00003347 89D7                    	mov	di,dx		; working copy of pathname
 25275 00003349 BE[DE93]                	mov	si,search_curdir_buf
 25276 0000334C 31D2                    	xor	dx,dx		; zero means current drive
 25277 0000334E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25278 00003352 7508                    	jne	short SEARCH_DIR_CHECK
 25279 00003354 8A15                    	mov	dl,[di]		; get the drive byte
 25280 00003356 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25281 00003359 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25282                                  SEARCH_DIR_CHECK:
 25283 0000335C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25284 0000335F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25285                                  			; DL = drive (0=default,1=A,etc.)
 25286                                  			; DS:SI	points to 64-byte buffer area
 25287 00003361 5A                      	pop	dx		; directory? If we can't we'll
 25288 00003362 724C                    	jc	short SEARCH_INVALID_DRIVE
 25289                                  				; assume it's a bad drive...
 25290 00003364 B91300                  	mov	cx,search_attr	; 13h
 25291                                  				; filetypes to search for
 25292 00003367 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25293 0000336A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25294                                  			; CX = search attributes
 25295                                  			; DS:DX	-> ASCIZ filespec
 25296                                  			; (drive,path, and wildcards allowed)
 25297 0000336C 7249                    	jc	short SEARCH_NO_FILE
 25298 0000336E C606[D093]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25299 00003373 C606[D193]00            	mov	byte [search_best_buf],ANULL
 25300                                  				; 0 ; nothing's been found, yet
 25301                                  SEARCH_LOOP:
 25302 00003378 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25303 0000337B 3A06[D093]              	cmp	al,[search_best]
 25304                                  				; better than what we've found so far?
 25305 0000337F 7E13                    	jle	short SEARCH_NEXT
 25306                                  				; no, look for another
 25307 00003381 A2[D093]                	mov	[search_best],al
 25308                                  				; found something... save its code
 25309                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25310                                  	;mov	si,FBUF_PNAME
 25311 00003384 BE[BC93]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25312 00003387 BF[D193]                	mov	di,search_best_buf
 25313 0000338A B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25314 0000338D FC                      	cld
 25315 0000338E F3A4                    	rep	movsb		; save complete pathname representation
 25316 00003390 3C08                    	cmp	al,SEARCH_COM	; 8
 25317                                  				; have we found the best of all?
 25318 00003392 740A                    	je	short SEARCH_DONE
 25319                                  SEARCH_NEXT:			; keep on looking
 25320 00003394 B91300                  	mov	cx,search_attr ; 13h
 25321 00003397 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25322 0000339A CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25323                                  			; [DTA]	= data block from
 25324                                  			; last AH = 4Eh/4Fh call
 25325 0000339C 73DA                    	jnc	short SEARCH_LOOP
 25326                                  SEARCH_DONE:			; it's all over with...
 25327 0000339E A0[D093]                	mov	al,[search_best]
 25328                                  				; pick best to return with
 25329                                  	; 18/03/2023
 25330                                  	; MSDOS 6.0
 25331 000033A1 803E[8A8D]01            	cmp	byte [ext_entered],1
 25332                                  				;AN005; Did user request a specific ext?
 25333 000033A6 7411                    	je	short SEARCH_EXIT
 25334                                  				;AN005; no - exit
 25335 000033A8 A0[8A8D]                	mov	al,[ext_entered]
 25336                                  				;AN005; yes - get the real file type back
 25337 000033AB A2[D093]                	mov	[search_best],al
 25338                                  				;AN005; save the real file type
 25339                                  	;
 25340 000033AE EB09                    	jmp	short SEARCH_EXIT
 25341                                  
 25342                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25343 000033B0 8B16[1E94]              	mov	dx,[search_error]
 25344                                  				; appropriate error message
 25345 000033B4 E8381A                  	call	std_printf	; and pretend no file found
 25346                                  
 25347                                  SEARCH_NO_FILE:			; couldn't find a match
 25348                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25349                                  	; 18/03/2023
 25350 000033B7 31C0                    	xor	ax,ax
 25351                                  SEARCH_EXIT:
 25352                                  	;popf	; ** ; 18/03/2023
 25353 000033B9 5E                      	pop	si
 25354 000033BA 5F                      	pop	di
 25355 000033BB 5A                      	pop	dx
 25356 000033BC 59                      	pop	cx
 25357 000033BD C3                      	retn
 25358                                  
 25359                                  ; =============== S U B	R O U T	I N E =======================================
 25360                                  
 25361                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25362                                  ;
 25363                                  ; ENTRY:
 25364                                  ;   fbuf    --	dma buffer containing filename
 25365                                  ; EXIT:
 25366                                  ;   AX	    --	file code, as given in search header
 25367                                  ; NOTE(S):
 25368                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25369                                  
 25370                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25371                                  
 25372                                  SEARCH_FTYPE:
 25373 000033BE 57                      	push	di
 25374 000033BF 56                      	push	si
 25375                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25376                                  	; 18/02/2023
 25377 000033C0 31C0                    	xor	ax,ax ; ax = 0		
 25378                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25379                                  	;mov	di,FBUF_PNAME
 25380 000033C2 BF[BC93]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25381 000033C5 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25382 000033C8 FC                      	cld
 25383 000033C9 F2AE                    	repnz	scasb		; search for the terminating null
 25384 000033CB 7535                    	jnz	short FTYPE_EXIT
 25385                                  				; weird... no null byte at end
 25386 000033CD 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25387                                  
 25388                                  	; Compare .COM
 25389                                  
 25390 000033D0 BE[4584]                	mov	si,comext ; ".COM"
 25391 000033D3 89F8                    	mov	ax,di
 25392 000033D5 A7                      	cmpsw
 25393 000033D6 7508                    	jnz	short FTYPE_EXE
 25394 000033D8 A7                      	cmpsw
 25395 000033D9 7505                    	jnz	short FTYPE_EXE
 25396                                  	;mov	ax,8
 25397 000033DB B80800                  	mov	ax,SEARCH_COM	; success!
 25398 000033DE EB22                    	jmp	short FTYPE_EXIT
 25399                                  
 25400                                  	; Compare .EXE
 25401                                  FTYPE_EXE:			; still looking... now for '.exe'
 25402 000033E0 89C7                    	mov	di,ax
 25403 000033E2 BE[4984]                	mov	si,exeext ; ".EXE"
 25404 000033E5 A7                      	cmpsw
 25405 000033E6 7508                    	jnz	short FTYPE_BAT
 25406 000033E8 A7                      	cmpsw
 25407 000033E9 7505                    	jnz	short FTYPE_BAT
 25408                                  	;mov	ax,4
 25409 000033EB B80400                  	mov	ax,SEARCH_EXE	; success!
 25410 000033EE EB12                    	jmp	short FTYPE_EXIT
 25411                                  
 25412                                  	; Compare .BAT
 25413                                  FTYPE_BAT:			; still looking... now for '.bat'
 25414 000033F0 89C7                    	mov	di,ax
 25415 000033F2 BE[4D84]                	mov	si,batext ; ".BAT"
 25416 000033F5 A7                      	cmpsw
 25417 000033F6 7508                    	jnz	short FTYPE_FAIL
 25418 000033F8 A7                      	cmpsw
 25419 000033F9 7505                    	jnz	short FTYPE_FAIL
 25420                                  	;mov	ax,2
 25421 000033FB B80200                  	mov	ax,SEARCH_BAT	; success!
 25422 000033FE EB02                    	jmp	short FTYPE_EXIT
 25423                                  
 25424                                  FTYPE_FAIL:			; file doesn't match what we need
 25425                                  	;mov	ax,ANULL ; 0
 25426                                  	; 18/03/2023
 25427 00003400 29C0                    	sub	ax,ax  ; ax = 0
 25428                                  FTYPE_EXIT:
 25429                                  	; 18/03/2023
 25430                                  	; MSDOS 6.0
 25431 00003402 803E[8A8D]01            	cmp	byte [ext_entered],1
 25432                                  				;AN005; was an extension entered?
 25433 00003407 740A                    	jz	short FTYPE_DONE
 25434                                  				;AN005; no - exit
 25435                                  	;cmp	ax,ANULL	;AN005; was any match found
 25436 00003409 21C0                    	and	ax,ax  ; ax = 0 ?
 25437 0000340B 7406                    	jz	short FTYPE_DONE
 25438                                  				;AN005; no - exit
 25439 0000340D A2[8A8D]                	mov	[ext_entered],al
 25440                                  				;AN005; save the match type found
 25441 00003410 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25442                                  FTYPE_DONE:
 25443 00003413 5E                      	pop	si
 25444 00003414 5F                      	pop	di
 25445 00003415 C3                      	retn
 25446                                  
 25447                                  ; =============== S U B	R O U T	I N E =======================================
 25448                                  
 25449                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25450                                  ; replacing any extension with wildcards.
 25451                                  ;
 25452                                  ; ENTRY:
 25453                                  ;	BX	--	maximum length of destination buffer
 25454                                  ;	DS:SI	--	address of destination buffer
 25455                                  ;	argv[0] --	command name to be stripped
 25456                                  ; EXIT:
 25457                                  ;	CF	--	set if failure, clear if successful
 25458                                  ; NOTE(S):
 25459                                  
 25460                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25461                                  
 25462                                  STRIP:
 25463 00003416 50                      	push	ax
 25464 00003417 53                      	push	bx
 25465 00003418 51                      	push	cx
 25466 00003419 52                      	push	dx
 25467 0000341A 57                      	push	di
 25468 0000341B 56                      	push	si
 25469                                  	;pushf	; ** ; 18/03/2023
 25470                                  		
 25471                                  	; 05/05/2023
 25472                                  	; MSDOS 6.0
 25473 0000341C C606[8A8D]01            	mov	byte [ext_entered],1
 25474                                  				;AN005; assume no extension on file name
 25475                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25476                                  	;mov	dx,[ARG_ARGV]
 25477                                  	;mov	dx,ds:arg.argv[0].argpointer
 25478                                  				; save pointer to beginning of argstring
 25479                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25480 00003421 8B16[D48D]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25481                                  	;mov	di,ds:arg.argv[0].argstartel
 25482                                  				; beginning of last pathname element
 25483                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25484 00003425 8B3E[D78D]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25485 00003429 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25486 0000342C 743D                    	je	short STRIP_ERROR
 25487 0000342E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25488                                  	;add	cx,ds:arg.argv[0].arglen
 25489                                  	;add	cx,[ARGV0_ARGLEN]
 25490 00003430 030E[D98D]              	add	cx,[ARG+ARGV_ELE.arglen]
 25491 00003434 29F9                    	sub	cx,di		; and then find length of last element
 25492 00003436 41                      	inc	cx		; include null as well
 25493 00003437 B02E                    	mov	al,'.'
 25494                                  	;mov	al,DOT		; let's find the filetype extension
 25495 00003439 FC                      	cld
 25496 0000343A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25497                                  
 25498                                  	; 18/03/2023
 25499                                  	; MSDOS 6.0
 25500 0000343C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25501 0000343E B000                    	mov	al,0 ; 18/03/2023
 25502                                  	;mov	byte [ext_entered],0
 25503 00003440 A2[8A8D]                	mov	[ext_entered],al
 25504                                  				;AN005; we found an extension
 25505                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25506                                  	;mov	al,0
 25507 00003443 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25508                                  PROCESS_EXT:
 25509                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25510 00003445 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25511 00003447 29D1                    	sub	cx,dx		; number of bytes to be copied
 25512 00003449 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25513 0000344C 39D9                    	cmp	cx,bx
 25514 0000344E 7F1B                    	jg	short STRIP_ERROR
 25515                                  				; if not, we must have a bad pathname
 25516 00003450 89F7                    	mov	di,si		; destination buffer
 25517 00003452 89D6                    	mov	si,dx		; source is beginning of pathname
 25518 00003454 FC                      	cld
 25519 00003455 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25520                                  
 25521                                  	; 18/03/2023
 25522                                  	; MSDOS 6.0
 25523 00003457 803E[8A8D]01            	cmp	byte [ext_entered],1
 25524                                  				;AN005; if an extension was entered
 25525 0000345C 750A                    	jne	short SKIP_WILDS
 25526                                  				;AN005;    don't set up wildcard ext.
 25527                                  
 25528                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25529 0000345E 4F                      	dec	di		; overwrite null or dot
 25530 0000345F AA                      	stosb			; with a dot
 25531 00003460 B03F                    	mov	al,'?'
 25532                                  	;mov	al,WILDCHAR	; now add wildcards
 25533 00003462 AA                      	stosb
 25534 00003463 AA                      	stosb
 25535 00003464 AA                      	stosb
 25536 00003465 B000                    	mov	al,0
 25537                                  	;mov	al,ANULL	; and a terminating null	
 25538 00003467 AA                      	stosb
 25539                                  SKIP_WILDS:
 25540                                  	;popf	; ** ; 18/03/2023
 25541 00003468 F8                      	clc
 25542 00003469 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25543                                  
 25544                                  STRIP_ERROR:
 25545                                  	;popf	; ** ; 18/03/2023
 25546 0000346B F9                      	stc
 25547                                  STRIP_EXIT:
 25548 0000346C 5E                      	pop	si
 25549 0000346D 5F                      	pop	di
 25550 0000346E 5A                      	pop	dx
 25551 0000346F 59                      	pop	cx
 25552 00003470 5B                      	pop	bx
 25553 00003471 58                      	pop	ax
 25554 00003472 C3                      	retn
 25555                                  
 25556                                  ; =============== S U B	R O U T	I N E =======================================
 25557                                  
 25558                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25559                                  ;
 25560                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25561                                  ; beginning of this area. The caller indicates how much extra space is
 25562                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25563                                  ; an offset into that area, indicating where the caller may preserve its own
 25564                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25565                                  ; ENTRY:
 25566                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25567                                  ; EXIT:
 25568                                  ;   AX	    --	segment of new area.
 25569                                  ;   CF	    --	set if unable to save a copy.
 25570                                  ; NOTE(S):
 25571                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25572                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25573                                  ;	paragraphs.
 25574                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25575                                  ;	as the caller of Save_Args requests.
 25576                                  ;   3)	AX is undefined if CF indicates an error.
 25577                                  
 25578                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25579                                  
 25580                                  SAVE_ARGS:
 25581 00003473 53                      	push	bx
 25582 00003474 51                      	push	cx
 25583 00003475 52                      	push	dx
 25584 00003476 57                      	push	di
 25585 00003477 56                      	push	si
 25586 00003478 55                      	push	bp
 25587                                  	; 01/05/2023
 25588                                  	; 26/04/2023
 25589                                  	;pushf ; **
 25590                                  	;add	bx,1363		; space for arg structure, round up
 25591 00003479 81C35304                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25592                                  			; 1092+15 ; 31/07/2024
 25593 0000347D B104                    	mov	cl,4		; to paragraph size and convert
 25594 0000347F D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25595 00003481 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25596 00003484 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25597                                  			; BX = number of 16-byte paragraphs desired
 25598 00003486 7242                    	jc	short SAVE_ERROR ; ***
 25599 00003488 89C5                    	mov	bp,ax		; save segment id
 25600 0000348A 06                      	push	es		; save TRANGROUP address
 25601 0000348B 8EC0                    	mov	es,ax		; switch to new memory segment
 25602                                  	; assume es:nothing
 25603                                  	;mov	cx,1348		; get back structure size
 25604 0000348D B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092 ; 31/07/2024
 25605 00003490 31FF                    	xor	di,di		; destination is new memory area
 25606                                  	;mov	si,ARG_ARGV
 25607 00003492 BE[D48D]                	mov	si,ARG		; source is arg structure
 25608 00003495 F3A4                    	rep	movsb		; move that sucker!
 25609                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25610                                  	;mov	cx,[ARG_ARGVCNT]
 25611 00003497 8B0E[9490]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25612 0000349B 31C0                    	xor	ax,ax		; base address for argv_calc
 25613                                  
 25614                                  ;	Bugbug:	What did they mean by this?
 25615                                  ;	Note that the replacement line produces exactly the same code.
 25616                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25617                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25618                                  
 25619                                  	;mov	si,ARG_ARGV
 25620 0000349D BE[D48D]                	mov	si,ARG	
 25621                                  SAVE_PTR_LOOP:
 25622 000034A0 49                      	dec	cx		; exhausted all args?
 25623 000034A1 7C24                    	jl	short SAVE_DONE
 25624 000034A3 89CB                    	mov	bx,cx		; get arg index and
 25625 000034A5 E8A6FC                  	call	argv_calc	; convert to a pointer
 25626                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25627                                  	;mov	dx,[ARG_ARGV+bx]
 25628 000034A8 8B97[D48D]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25629 000034AC 29F2                    	sub	dx,si		; adjust argpointer
 25630                                  	;mov	es:argv[BX].argpointer,dx
 25631                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25632 000034AE 268917                  	mov	[es:bx],dx
 25633                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25634                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25635 000034B1 8B97[D78D]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25636 000034B5 29F2                    	sub	dx,si		; and adjust argstartel
 25637                                  	;mov	es:argv[bx].argstartel,dx
 25638                                  	;mov	[es:bx+3],dx
 25639 000034B7 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25640                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25641                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25642 000034BB 8B97[DD8D]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25643 000034BF 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25644                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25645                                  	;mov	[es:bx+9],dx
 25646 000034C1 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25647 000034C5 EBD9                    	jmp	short SAVE_PTR_LOOP
 25648                                  SAVE_DONE:
 25649 000034C7 07                      	pop	es		; back we go to TRANGROUP
 25650                                  	; assume es:nothing
 25651 000034C8 89E8                    	mov	ax,bp		; restore segment id
 25652                                  	; 26/04/2023
 25653                                  	; cf = 0 ; *
 25654                                  	;jmp	short SAVE_OK
 25655                                  
 25656                                  	; 26/04/2023
 25657                                  ;SAVE_ERROR:
 25658                                  ;	; 26/04/2023
 25659                                  ;	;popf ; **
 25660                                  ;	stc
 25661                                  ;	jmp	short SAVE_EXIT
 25662                                  
 25663                                  SAVE_OK:
 25664                                  	; 26/04/2023
 25665                                  	;popf ; **
 25666                                  	; 26/04/2023
 25667                                  	; cf = 0 ; *
 25668                                  	;clc
 25669                                  SAVE_EXIT:
 25670                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25671 000034CA 5D                      	pop	bp
 25672 000034CB 5E                      	pop	si
 25673 000034CC 5F                      	pop	di
 25674 000034CD 5A                      	pop	dx
 25675 000034CE 59                      	pop	cx
 25676 000034CF 5B                      	pop	bx
 25677                                  answ_no:	; 26/04/2023
 25678 000034D0 C3                      	retn
 25679                                  
 25680                                  ;============================================================================
 25681                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25682                                  ;============================================================================
 25683                                  ; 02/10/2018 - Retro DOS v3.0
 25684                                  
 25685                                  ; Title	COMMAND Language midifiable Code Transient
 25686                                  
 25687                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25688                                  
 25689                                  ; =============== S U B	R O U T	I N E =======================================
 25690                                  
 25691                                  ; ****************************************************************
 25692                                  ; *
 25693                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25694                                  ; *
 25695                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25696                                  ; *		 user for Y/N if necessary. If an error occurs,
 25697                                  ; *		 set up an error message and go to CERROR.
 25698                                  ; *
 25699                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25700                                  ; *		 Current directory set to entered directory
 25701                                  ; *
 25702                                  ; * OUTPUT:	 none
 25703                                  ; *
 25704                                  ; ****************************************************************
 25705                                  ;
 25706                                  ; ARE YOU SURE prompt when deleting *.*
 25707                                  
 25708                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25709                                  
 25710                                  notest2:
 25711 000034D1 B90B00                  	mov	cx,11
 25712 000034D4 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25713                                  ambspec:
 25714 000034D7 AC                      	lodsb
 25715 000034D8 3C3F                    	cmp	al,'?'
 25716 000034DA 7502                    	jne	short allfil
 25717 000034DC E2F9                    	loop	ambspec
 25718                                  allfil:
 25719                                  	; 19/03/2023
 25720                                  	;cmp	cx,0
 25721 000034DE 09C9                    	or	cx,cx
 25722 000034E0 752E                    	jnz	short noprmpt
 25723                                  askagn:	
 25724 000034E2 BA[FA7F]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25725 000034E5 E80719                  	call	std_printf
 25726 000034E8 BE8000                  	mov	si,80h
 25727 000034EB 89F2                    	mov	dx,si
 25728 000034ED C7047800                	mov	word [si],120	; zero length
 25729                                  	;mov	ax,0C0Ah
 25730 000034F1 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25731 000034F4 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25732                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25733 000034F6 AD                      	lodsw
 25734 000034F7 08E4                    	or	ah,ah
 25735 000034F9 74E7                    	jz	short askagn
 25736 000034FB E8E0F0                  	call	scanoff
 25737                                  	; 19/03/2023
 25738                                  	; MSDOS 6.0
 25739 000034FE E80C02                  	call	char_in_xlat	; Convert to upper case
 25740                                  	;retc			; return if function not supported
 25741                                  	; 19/03/2023
 25742                                  	;jnc	short check_yn
 25743                                  ;answ_no:
 25744                                  	;retn
 25745 00003501 72CD                    	jc	short answ_no
 25746                                  
 25747                                  	; 19/03/2023
 25748                                  	; AL = 0 if it was (country depended) NO character
 25749                                  	; AL = 1 if it was (country depenced) YES character
 25750                                  
 25751                                  	; MSDOS 3.3
 25752                                  	;call	UPCONV
 25753                                  
 25754                                  	; 19/03/2023	
 25755                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25756                                  	;cmp	al,[CAPITAL_N]
 25757                                  	;jne	short CHECK_Y
 25758                                  	;retn
 25759                                  ;CHECK_Y:
 25760                                  	;cmp	al,[CAPITAL_Y]
 25761                                  	;pushf
 25762                                  	;call	CRLF2
 25763                                  	;popf
 25764                                  	;jne	short ASKAGN
 25765                                  
 25766                                  check_yn:
 25767                                  	; 19/03/2023
 25768                                  	;cmp	al,0	; NO character
 25769 00003503 08C0                    	or	al,al
 25770 00003505 74C9                    	jz	short answ_no
 25771                                  	;cmp	al,1	 ;YES character
 25772 00003507 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25773 00003509 9C                      	pushf
 25774 0000350A E8C4F0                  	call	CRLF2
 25775 0000350D 9D                      	popf
 25776 0000350E 75D2                    	jnz	short askagn
 25777                                  noprmpt:
 25778 00003510 B413                    	mov	ah,FCB_Delete ; 13h
 25779 00003512 BA5C00                  	mov	dx,FCB ; 5Ch
 25780 00003515 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25781                                  			; DS:DX	-> FCB with filename field filled with
 25782                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25783                                  			; Return: AL = 00h file	found,FFh file	not found
 25784 00003517 FEC0                    	inc	al
 25785 00003519 7403                    	jz	short eraerr
 25786                                  	; 26/04/2023
 25787                                  	;call	RestUDir
 25788                                  ;answ_no:
 25789                                  	;retn
 25790 0000351B E970EF                  	jmp	RestUDir ; 26/04/2023
 25791                                  
 25792                                  	; 19/03/2023
 25793                                  	; MSDOS 6.0
 25794                                  eraerr:
 25795                                  	;invoke	set_ext_error_msg
 25796                                  				;AN022; set up the extended error
 25797 0000351E E8BFE7                  	call	Set_Ext_Error_Msg
 25798 00003521 52                      	push	dx		;AN022; save message
 25799                                  	;invoke	RESTUDIR
 25800 00003522 E869EF                  	call	RestUDir
 25801 00003525 5A                      	pop	dx		;AN022; restore message
 25802                                  	
 25803 00003526 833E[1B7F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25804                                  				;AN022; convert no more files to
 25805 0000352B 7506                    	jne	short cerrorj2	;AN022;  file not found
 25806 0000352D C706[1B7F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25807                                  				;AN000; get message number in control block
 25808                                  cerrorj2:
 25809 00003533 E91CF4                  	jmp	cerror
 25810                                  	
 25811                                  	; 19/03/2023
 25812                                  	; MSDOS 3.3
 25813                                  ;ERAERR:	
 25814                                  	;mov	ah,Set_DMA ; 1Ah
 25815                                  	;mov	dx,FCB ; 5Ch
 25816                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25817                                  	;			; DS:DX	-> disk	transfer buffer
 25818                                  	;mov	ah,Dir_Search_First ; 11h
 25819                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25820                                  	;			; DS:DX	-> FCB
 25821                                  	;push	ax
 25822                                  	;call	RESTUDIR
 25823                                  	;pop	ax
 25824                                  	;mov	dx,FNOTFOUNDPTR
 25825                                  	;inc	al
 25826                                  	;jz	short CERRORJ
 25827                                  	;mov	dx,ACCDENPTR
 25828                                  	;jmp	CERROR
 25829                                  
 25830                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25831                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25832                                  
 25833                                  ; ****************************************************************
 25834                                  ; *
 25835                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25836                                  ; *
 25837                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25838                                  ; *		 user for Y/N where necessary. If an error occurs
 25839                                  ; *		 set up and error message and transfer control
 25840                                  ; *		 to CERROR.
 25841                                  ; *
 25842                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25843                                  ; *		 Current directory set to entered directory
 25844                                  ; *
 25845                                  ; * OUTPUT:	 none
 25846                                  ; *
 25847                                  ; ****************************************************************
 25848                                  
 25849                                  	; 19/03/2023
 25850                                  slashp_erase:				;AN000; entry point
 25851                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25852 00003536 E813E9                  	call	build_dir_string
 25853                                  
 25854 00003539 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25855                                  	;mov	dx,offset trangroup:destdir
 25856 0000353B BA[8B8B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25857 0000353E CD21                    	int	21h			;AN000;
 25858                                  
 25859                                  	;mov	ah,11h
 25860 00003540 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25861 00003542 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25862 00003545 CD21                    	int	21h			;AN000;
 25863 00003547 FEC0                    	inc	al			;AN000; did an error occur
 25864                                  	;jz	short eraerr		;AN022; go to error exit
 25865                                  	; 26/04/2023
 25866 00003549 7502                    	jnz	short delete_prompt_loop
 25867                                  
 25868                                  	; 26/04/2023
 25869                                  stop_del:
 25870 0000354B EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25871                                  
 25872                                  delete_prompt_loop:			;AN000;
 25873                                  	;mov	si,offset trangroup:destdir+1
 25874 0000354D BE[8C8B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25875                                  	;mov	di,offset trangroup:dest
 25876 00003550 BF[5B8B]                	mov	di,DEST			;AN000; set up dest as target
 25877 00003553 A0[CA8A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25878 00003556 AA                      	stosb				;AN000;   of DEST
 25879                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25880 00003557 E8A3F0                  	call	FCB_TO_ASCZ
 25881                                  
 25882                                  slashp_askagn:				;AN000;
 25883 0000355A E874F0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25884                                  	;mov	dx,offset trangroup:bwdbuf
 25885 0000355D BA[CE8B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25886 00003560 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25887 00003562 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25888                                  					;AN000; see if only D:\,0
 25889 00003566 7504                    	jnz	short not_del_root	;AN000; no continue
 25890 00003568 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25891                                  					;AN000; yes, get rid of \ ;
 25892                                  not_del_root:				;AN000;
 25893 0000356C 8916[358C]              	mov	[string_ptr_2],dx 	;AN000;
 25894                                  	;mov	dx,offset trangroup:string_buf_ptr
 25895 00003570 BA[E280]                	mov	dx,string_buf_ptr	;AN000;
 25896                                  	;invoke	std_printf		;AN000;
 25897 00003573 E87918                  	call	std_printf
 25898                                  	;mov	dx,offset trangroup:dest
 25899 00003576 BA[5B8B]                	mov	dx,DEST			;AN000; print out file name string
 25900 00003579 8916[358C]              	mov	[string_ptr_2],dx 	;AN000;
 25901                                  	;mov	dx,offset trangroup:string_buf_ptr
 25902 0000357D BA[E280]                	mov	dx,string_buf_ptr	;AN000;
 25903                                  	;invoke	std_printf		;AN000;
 25904 00003580 E86C18                  	call	std_printf
 25905                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25906 00003583 BA[F77F]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25907                                  	;invoke	std_printf		;AN000;
 25908 00003586 E86618                  	call	std_printf
 25909                                  
 25910                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25911                                  ;;M029	mov	dx,si			;AN000;
 25912                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25913                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25914                                  ;;M029	int	21h			;AN000; get input from the user
 25915                                  ;;M029	lodsw				;AN000;
 25916                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25917                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25918                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25919                                  
 25920                                  ;	Get a single character input.
 25921                                  
 25922                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25923                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25924 00003589 B8010C                  	mov	ax,0C01h
 25925 0000358C CD21                    	int	21h			;M029
 25926                                  
 25927 0000358E E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25928                                  	;retc				;AN000; return if function not supported
 25929                                  	; 19/03/2023
 25930 00003591 7301                    	jnc	short slashp_check_yn
 25931                                  slashp_ans_no:
 25932 00003593 C3                      	retn
 25933                                  
 25934                                  slashp_check_yn:
 25935                                  	; 19/03/2023
 25936                                  	; AL = 0 if it was (country depended) NO character
 25937                                  	; AL = 1 if it was (country depenced) YES character
 25938                                  
 25939                                  	;cmp	al,capital_n		;AN000; was it no?
 25940                                  	;cmp	al,0
 25941 00003594 20C0                    	and	al,al ; 0
 25942 00003596 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25943                                  	;cmp	al,capital_y		;AN000; was it yes?
 25944                                  	;cmp	al,1
 25945 00003598 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25946                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25947                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25948                                  	; 19/03/2023
 25949 0000359A 75BE                    	jnz	short slashp_askagn
 25950                                  
 25951                                  delete_this_file:			;AN000;
 25952 0000359C B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25953                                  	;mov	dx,offset trangroup:destdir
 25954 0000359E BA[8B8B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25955 000035A1 CD21                    	int	21h			;AN000;
 25956 000035A3 FEC0                    	inc	al			;AN000; did an error occur?
 25957 000035A5 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25958                                  ;
 25959                                  ;M041; Begin changes
 25960                                  ; We got an error deleting the file. If this is access denied, we can go on
 25961                                  ;to the next file after printing an error message.
 25962                                  ;
 25963                                  	;invoke	Get_ext_error_number	;see what error we got
 25964 000035A7 E846E7                  	call	get_ext_error_number
 25965 000035AA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25966                                  					;is it access denied?
 25967 000035AD 759C                    	jne	short stop_del		;no, some other error
 25968                                  	;invoke	CrLf2			;print a CR-LF
 25969 000035AF E81FF0                  	call	CRLF2
 25970                                  	;invoke set_ext_error_msg	;error message
 25971 000035B2 E82BE7                  	call	Set_Ext_Error_Msg
 25972                                  	;invoke	std_eprintf		;"Access denied"
 25973 000035B5 E82F18                  	call	std_eprintf
 25974                                  	; 26/04/2023
 25975                                  	;jmp	short next_del_file	;try next file
 25976                                  	; 26/04/2023
 25977                                  ;stop_del:
 25978                                  ;;
 25979                                  ;;M041; End changes
 25980                                  ;;
 25981                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 25982                                  
 25983                                  next_del_file:				;AN000;
 25984                                  ;
 25985                                  ; M050 - begin
 25986                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 25987                                  ;       with /protect+ and /light+ makes it intercept all
 25988                                  ;       deletes. This hook does not save and restore the DTA correctly.
 25989                                  ;       They save the DWORD in a WORD by mistake! They save both the
 25990                                  ;       segment and the offset in the SAME variable (WORD)!!!
 25991                                  ;
 25992 000035B8 B41A                    	mov	ah,Set_DMA ; 1Ah
 25993                                  	;mov	dx,offset trangroup:destdir
 25994 000035BA BA[8B8B]                	mov	dx,DESTDIR
 25995 000035BD CD21                    	int	21h
 25996                                  ;
 25997                                  ; M050 - end
 25998                                  
 25999 000035BF B412                    	mov	ah,Dir_Search_Next ; 12h
 26000                                  					;AN000; search for another file
 26001 000035C1 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26002 000035C4 CD21                    	int	21h			;AN000;
 26003 000035C6 FEC0                    	inc	al			;AN000; was a file found?
 26004                                  	;jz	short slash_p_exit	;AN000; no - exit
 26005                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26006                                  	; 26/04/2023
 26007 000035C8 7583                    	jnz	short delete_prompt_loop
 26008                                  
 26009                                  slash_p_exit:
 26010                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26011 000035CA E823E7                  	call	get_ext_error_number
 26012 000035CD 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26013 000035D0 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26014 000035D2 E95EE4                  	jmp	extend_setup		;AN022; go issue error message
 26015                                  
 26016                                  good_erase_exit:
 26017                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26018 000035D5 E8B6EE                  	call	RestUDir
 26019                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26020                                  	;retn				;AN000; exit
 26021                                  	; 19/03/2023
 26022 000035D8 E9F6EF                  	jmp	CRLF2
 26023                                  
 26024                                  ; =============== S U B	R O U T	I N E =======================================
 26025                                  
 26026                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26027                                  
 26028                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26029                                  _ECHO:
 26030 000035DB E89900                  	call	ON_OFF
 26031 000035DE 7212                    	jb	short DOEMES
 26032 000035E0 8E1E[C58A]              	mov	ds,[RESSEG]
 26033 000035E4 7506                    	jnz	short ECH_OFF
 26034 000035E6 800E[8801]01            	or	byte [EchoFlag],1
 26035 000035EB C3                      	retn
 26036                                  
 26037                                  ECH_OFF:
 26038 000035EC 8026[8801]FE            	and	byte [EchoFlag],0FEh
 26039 000035F1 C3                      	retn
 26040                                  
 26041                                  	; 19/03/2023
 26042                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26043                                  ;CERRORJ:
 26044                                  	;jmp	cerror
 26045                                  
 26046                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26047                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26048                                  
 26049                                  DOEMES:
 26050                                  	; 19/03/2023
 26051                                  	; MSDOS 6.0
 26052                                  	;cmp	cl,0		;AC000; was anything on the line?
 26053 000035F2 20C9                    	and	cl,cl
 26054 000035F4 7409                    	jz	short PECHO	; just display current state.
 26055 000035F6 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26056 000035F9 E82EF0                  	call	CRPRINT
 26057 000035FC E9D2EF                  	jmp	CRLF2
 26058                                  
 26059                                  	; 19/03/2023
 26060                                  	; MSDOS 3.3
 26061                                  	;call	MOVE_TO_FIRST_ARG
 26062                                  	;jz	short PECHO
 26063                                  	;mov	dx,82h
 26064                                  	;call	CRPRINT
 26065                                  	;jmp	CRLF2
 26066                                  
 26067                                  PECHO:
 26068                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26069 000035FF 8E1E[C58A]              	mov	ds,[RESSEG]
 26070 00003603 8A1E[8801]              	mov	bl,[EchoFlag]
 26071 00003607 0E                      	push	cs
 26072 00003608 1F                      	pop	ds
 26073 00003609 80E301                  	and	bl,1
 26074 0000360C BA[9E80]                	mov	dx,EchoMes_Ptr
 26075 0000360F EB24                    	jmp	short PYN
 26076                                  
 26077                                  ; ---------------------------------------------------------------------------
 26078                                  
 26079                                  	; 19/03/2023
 26080                                  	; MSDOS 3.3
 26081                                  CERRORJ:
 26082 00003611 E93EF3                  	jmp	cerror
 26083                                  
 26084                                  ; =============== S U B	R O U T	I N E =======================================
 26085                                  
 26086                                  	; 19/03/2023
 26087                                  	; MSDOS 3.3
 26088                                  ;MOVE_TO_FIRST_ARG:
 26089                                  	;mov	si,81h
 26090                                  	;call	SCANOFF
 26091                                  	;cmp	al,0Dh
 26092                                  	;retn
 26093                                  
 26094                                  ; =============== S U B	R O U T	I N E =======================================
 26095                                  
 26096                                  CNTRLC:
 26097 00003614 E86000                  	call	ON_OFF
 26098 00003617 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26099 0000361A 720C                    	jc	short PCNTRLC
 26100 0000361C 7505                    	jnz	short CNTRLC_OFF
 26101 0000361E B201                    	mov	dl,1
 26102 00003620 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26103                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26104                                  			; DL = 00h for OFF or 01h for ON
 26105 00003622 C3                      	retn
 26106                                  
 26107                                  ; ---------------------------------------------------------------------------
 26108                                  
 26109                                  CNTRLC_OFF:
 26110 00003623 30D2                    	xor	dl,dl
 26111 00003625 CD21                    	int	21h		; Turn off ^C check
 26112 00003627 C3                      	retn
 26113                                  
 26114                                  ; ---------------------------------------------------------------------------
 26115                                  
 26116                                  PCNTRLC:
 26117                                  	; 19/03/2023
 26118                                  	; MSDOS 6.0
 26119                                  	;cmp	cl,0		;AC000; rest of line blank?
 26120 00003628 08C9                    	or	cl,cl
 26121 0000362A 75E5                    	jnz	short CERRORJ 	; no, oops!
 26122                                  
 26123                                  	; 19/03/2023
 26124                                  	; MSDOS 3.3
 26125                                  	;call	MOVE_TO_FIRST_ARG
 26126                                  	;jnz	short CERRORJ
 26127                                  ;pccont:
 26128                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26129 0000362C 30C0                    	xor	al,al
 26130 0000362E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26131 00003630 88D3                    	mov	bl,dl
 26132 00003632 BA[8280]                	mov	dx,CtrlcMes_Ptr
 26133                                  
 26134                                  ; ---------------------------------------------------------------------------
 26135                                  
 26136                                  PYN:	; write "ON" or "OFF" state 
 26137                                  
 26138                                  	; 26/04/2023
 26139                                  	; 19/03/2023
 26140                                  	; MSDOS 3.3
 26141                                  	;call	STD_PRINTF
 26142                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26143                                  	;or	bl,bl
 26144                                  	;jnz	short PRINTVAL
 26145                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26146                                  	
 26147                                  	; 26/04/2023
 26148                                  	; 19/03/2023
 26149                                  	; MSDOS 6.0
 26150 00003635 BE[AF80]                	mov	si,ONMES_PTR
 26151 00003638 08DB                    	or	bl,bl
 26152 0000363A 7503                    	jnz	short PRINTVAL
 26153 0000363C BE[AC80]                	mov	si,OFFMES_PTR
 26154                                  PRINTVAL:
 26155                                  	; 19/03/2023
 26156                                  	; MSDOS 3.3
 26157                                  	;jmp	STD_PRINTF
 26158                                  
 26159                                  	; 19/03/2023
 26160                                  	; MSDOS 6.0
 26161 0000363F 52                      	push	dx		;AN000; save offset of message block
 26162 00003640 89D3                    	mov	bx,dx		;AN000; save offset value
 26163 00003642 AD                      	lodsw			;AN000; get message number of on or off
 26164 00003643 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26165                                  				;AN000; this is a utility message
 26166 00003645 E88C18                  	call	TSYSGETMSG	;AN000; get the address of the message
 26167                                  	;add	bx,5
 26168 00003648 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26169                                  	
 26170 0000364B 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26171 0000364D 5A                      	pop	dx		;AN000; get message back
 26172 0000364E E89E17                  	call	std_printf	;AC000; go print message
 26173 00003651 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26174 00003655 C3                      	retn			;AN000; exit
 26175                                  
 26176                                  ; =============== S U B	R O U T	I N E =======================================
 26177                                  
 26178                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26179                                  VERIFY:
 26180 00003656 E81E00                  	call	ON_OFF
 26181 00003659 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26182 0000365C 720A                    	jc	short PVERIFY
 26183 0000365E 7503                    	jnz	short VER_OFF
 26184 00003660 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26185                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26186 00003662 C3                      	retn
 26187                                  
 26188                                  ; ---------------------------------------------------------------------------
 26189                                  
 26190                                  VER_OFF:
 26191 00003663 FEC8                    	dec	al
 26192 00003665 CD21                    	int	21h		; Turn off verify after write
 26193 00003667 C3                      	retn
 26194                                  
 26195                                  ; ---------------------------------------------------------------------------
 26196                                  
 26197                                  PVERIFY:
 26198                                  	; 19/03/2023
 26199                                  	; MSDOS 6.0
 26200                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26201 00003668 20C9                    	and	cl,cl
 26202 0000366A 75A5                    	jnz	short CERRORJ 	; nope...
 26203                                  
 26204                                  	 ;19/03/2023
 26205                                  	; MSDOS 3.3
 26206                                  	;call	MOVE_TO_FIRST_ARG
 26207                                  	;jnz	short CERRORJ
 26208                                  
 26209 0000366C B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26210 0000366E CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26211                                  				; Return: AL = 00h if flag OFF
 26212                                  				; AL = 01h if flag ON
 26213 00003670 88C3                    	mov	bl,al
 26214 00003672 BA[9080]                	mov	dx,VeriMes_Ptr
 26215 00003675 EBBE                    	jmp	short PYN
 26216                                  
 26217                                  ; =============== S U B	R O U T	I N E =======================================
 26218                                  
 26219                                  ; ****************************************************************
 26220                                  ; *
 26221                                  ; * ROUTINE:	 ON_OFF
 26222                                  ; *
 26223                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26224                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26225                                  ; *		 routines.
 26226                                  ; *
 26227                                  ; * INPUT:	 command line at offset 81H
 26228                                  ; *		 PARSE_BREAK control block
 26229                                  ; *
 26230                                  ; * OUTPUT:	 If carry is clear
 26231                                  ; *		    If ON is found
 26232                                  ; *		       Zero flag set
 26233                                  ; *		    If OFF is found
 26234                                  ; *		       Zero flag clear
 26235                                  ; *		 If carry set
 26236                                  ; *		    If nothing on command line
 26237                                  ; *		       CL set to zero
 26238                                  ; *		    If error
 26239                                  ; *		       CL contains error value from parse
 26240                                  ; *
 26241                                  ; ****************************************************************
 26242                                  
 26243                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26244                                  ON_OFF:
 26245 00003677 BE8100                  	mov	si,81h
 26246                                  
 26247                                  	; 19/03/2023
 26248                                  	; MSDOS 3.3
 26249                                  	;call	SCANOFF		; scan off leading blanks & equal
 26250                                  	;cmp	al,0Dh		; are we at end of line?
 26251                                  	;je	short BAD_ONF	; yes, return error
 26252                                  	;lodsw
 26253                                  	;or	ax,2020h	; convert to lowercase
 26254                                  	;cmp	ax,6E6Fh ;'on'
 26255                                  	;je	short ON_CHECK
 26256                                  	;cmp	ax,666Fh ;'of'
 26257                                  	;jne	short BAD_ONF
 26258                                  	;lodsb
 26259                                  	;or	al,20h		; convert to lowercase		
 26260                                  	;cmp	al,66h	 ; 'f'
 26261                                  	;jne	short BAD_ONF	
 26262                                  	;or	al,66h ; or al,'f'
 26263                                  	;jmp	short OFF_CHECK
 26264                                  ;ON_CHECK:
 26265                                  	;xor	al,al
 26266                                  ;OFF_CHECK:
 26267                                  	;lahf
 26268                                  	;mov	bx,ax
 26269                                  	;call	SCANOFF		; scan off leading blanks & equal
 26270                                  	;cmp	al,0Dh		; are we at end of line?	
 26271                                  	;jne	short BAD_ONF	; no, return error
 26272                                  	;mov	ax,bx
 26273                                  	;sahf
 26274                                  	;clc
 26275                                  	;retn
 26276                                  
 26277                                  	; 19/03/2023
 26278                                  	; MSDOS 6.0
 26279                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26280 0000367A AC                      	lodsb			;AN032; get a char
 26281                                  	;cmp	al,blank	;AN032; if whitespace
 26282 0000367B 3C20                    	cmp	al,20h
 26283 0000367D 74FB                    	je	short scan_on_off
 26284                                  				;AN032;    keep scanning
 26285 0000367F 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26286                                  	;cmp	al,09h
 26287 00003681 74F7                    	je	short scan_on_off
 26288                                  				;AN032;    keep scanning
 26289                                  	;cmp	al,equal_chr	;AN032; if equal char
 26290 00003683 3C3D                    	cmp	al,'=' ; 3Dh
 26291 00003685 7401                    	je	short parse_on_off
 26292                                  				;AN032;    start parsing
 26293 00003687 4E                      	dec	si		;AN032; if none of above - back up
 26294                                  
 26295                                  parse_on_off:			;AN032;    and start parsing
 26296 00003688 BF[8F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26297 0000368B 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26298 0000368D 31D2                    	xor	dx,dx		;AN000;
 26299 0000368F E88C0C                  	call	cmd_parse	;AC000; call parser
 26300                                  	;cmp	ax,-1 ; 0FFFFh
 26301 00003692 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26302 00003695 742E                    	je	short BADONF	;AC000; yes, return error
 26303                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26304                                  	;cmp	ax,0
 26305 00003697 21C0                    	and	ax,ax ; ax = 0 ?
 26306 00003699 7404                    	jz	short on_off_there
 26307                                  				;AN000; no - continue
 26308 0000369B 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26309 0000369D EB26                    	jmp	short BADONF	;AN000; return error
 26310                                  
 26311                                  on_off_there:
 26312 0000369F 803E[7595]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26313                                  				;AN014; was a valid positional present?
 26314 000036A4 7505                    	jnz	short good_on_off
 26315                                  				;AN014; yes - continue
 26316 000036A6 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26317                                  	;mov	cx,10 ; 0Ah
 26318 000036A9 EB1A                    	jmp	short BADONF	;AN014; return error
 26319                                  
 26320                                  good_on_off:				;AN014;
 26321 000036AB 31C0                    	xor	ax,ax		;AC000; set up return code for
 26322 000036AD 0A06[7595]              	or	al,[PARSE1_CODE]
 26323                                  				;AC000;    ON or OFF in AX
 26324 000036B1 9C                      	pushf			;AN000; save flags
 26325 000036B2 BF[8F84]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26326 000036B5 31D2                    	xor	dx,dx		;AN000;
 26327 000036B7 E8640C                  	call	cmd_parse	;AN000; call parser
 26328 000036BA 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26329                                  	;cmp	ax,-1 ; 0FFFFh
 26330 000036BD 7503                    	jne	short BADONF_flags
 26331                                  				;AN000; NO, return error
 26332 000036BF 9D                      	popf			;AN000; restore flags
 26333 000036C0 F8                      	clc			;AC000; no error
 26334                                  	;jmp	short on_off_end
 26335                                  				;AN000; return to caller
 26336                                  	; 26/04/2023
 26337 000036C1 C3                      	retn
 26338                                  
 26339                                  BADONF_flags:
 26340 000036C2 89C1                    	mov	cx,ax
 26341 000036C4 9D                      	popf
 26342                                  
 26343                                  ; ---------------------------------------------------------------------------
 26344                                  
 26345                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26346                                  ; and return the error
 26347                                  
 26348                                  BADONF:
 26349 000036C5 BA[5F80]                	mov	dx,bad_on_off_ptr
 26350 000036C8 F9                      	stc
 26351                                  on_off_end:
 26352 000036C9 C3                      	retn
 26353                                  
 26354                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26355                                  %if 0
 26356                                  
 26357                                  ;============================================================================
 26358                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 26359                                  ;============================================================================
 26360                                  ; 02/10/2018 - Retro DOS v3.0
 26361                                  
 26362                                  ; Print volume ID info
 26363                                  
 26364                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 26365                                  
 26366                                  ; ---------------------------------------------------------------------------
 26367                                  
 26368                                  PRINTVOL:
 26369                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 26370                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 26371                                  	add	al,'@'
 26372                                  	cmp	al,'@'
 26373                                  	jnz	short DRVOK
 26374                                  	mov	al,[CURDRV]
 26375                                  	add	al,[CAPITAL_A]
 26376                                  DRVOK:
 26377                                  	mov	[VOL_DRV],al	; get drive letter into argument
 26378                                  	pop	ax		; get return code back
 26379                                  	mov	dx,NOVOL ; "has	no label" 
 26380                                  	or	al,al		; volume label found?
 26381                                  	jnz	short PRINTVOL2	; print no volume message
 26382                                  GOODVOL:
 26383                                  	; MSDOS 3.3
 26384                                  	mov	di,CHARBUF
 26385                                  	mov	dx,di
 26386                                  	mov	si,IS	; "is "
 26387                                  	call	STRCPY
 26388                                  	dec	di
 26389                                  	mov	si,DIRBUF+8
 26390                                  	mov	cx,11
 26391                                  	rep	movsb
 26392                                  	xor	ax,ax
 26393                                  	;xor	al,al  ; MSDOS 6.0
 26394                                  	stosb			; store a zero to terminate the string
 26395                                  PRINTVOL2:
 26396                                  	mov	[VOLNAME_ADDR],dx
 26397                                  	mov	dx,VOLMESPTR
 26398                                  	jmp	PRINTF_CRLF
 26399                                  
 26400                                  	; MSDOS 6.0
 26401                                  ;drvok:
 26402                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 26403                                  ;	pop	ax		;AC000; get return code back
 26404                                  ;	or	al,al		;AC000; volume label found?
 26405                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 26406                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 26407                                  ;				;AC000; set up no volume message
 26408                                  ;	jmp	short print_serial ;AC000; go print it
 26409                                  ;
 26410                                  ;Get_vol_name:
 26411                                  ;	mov	di,offset trangroup:charbuf
 26412                                  ;	mov	dx,di
 26413                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 26414                                  ;	mov	cx,11				;AN000;  3/3/KK
 26415                                  ;	rep	movsb				;AN000;  3/3/KK
 26416                                  ;
 26417                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 26418                                  ;	stosb
 26419                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 26420                                  ;
 26421                                  ;PRINT_SERIAL:
 26422                                  ;
 26423                                  ;; Attempt to get the volume serial number from the disk.  If an error
 26424                                  ;; occurs, do not print volume serial number.
 26425                                  ;
 26426                                  ;	push	dx		;AN000; save message offset
 26427                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 26428                                  ;				;AC036; Get the volume serial info
 26429                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 26430                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 26431                                  ;	int	21h		;AN000; do the call
 26432                                  ;	pop	dx		;AN000; get message offset back
 26433                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26434                                  ;	call	std_printf	;AC000; go print volume message
 26435                                  ;	mov	al,blank	;AN051; Print out a blank
 26436                                  ;	invoke	print_char	;AN051;   before volume message
 26437                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26438                                  ;				;AN000; get serial number message
 26439                                  ;printvol_end:
 26440                                  ;	jmp	std_printf	;AC000; go print and exit
 26441                                  
 26442                                  %endif
 26443                                  
 26444                                  ;============================================================================
 26445                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26446                                  ;============================================================================
 26447                                  ; 02/10/2018 - Retro DOS v3.0
 26448                                  
 26449                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26450                                  
 26451                                  ; =============== S U B	R O U T	I N E =======================================
 26452                                  
 26453                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26454                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26455                                  	
 26456                                  PRINT_DATE:
 26457                                  	; 20/03/2023
 26458                                  	; MSDOS 3.3
 26459                                  	;push	es
 26460                                  	;push	di
 26461                                  	;push	cs
 26462                                  	;pop	es
 26463                                  	;mov	di,ARG_BUF
 26464                                  	;mov	ah,Get_Date ; 2Ah
 26465                                  	;int	21h	; DOS -	GET CURRENT DATE
 26466                                  	;		; Return: DL = day,DH = month,	CX = year
 26467                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26468                                  	;cbw
 26469                                  	;call	GETDATE
 26470                                  	;call	P_DATE
 26471                                  	;xor	al,al
 26472                                  	;stosb
 26473                                  	;mov	dx,ARG_BUF_PTR
 26474                                  	;call	STD_PRINTF
 26475                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26476                                  	;pop	es ; !!??!! 
 26477                                  	;pop	di
 26478                                  	;retn
 26479                                  
 26480                                  	; 20/03/2023
 26481                                  	; MSDOS 6.0
 26482 000036CA 06                      	push	es
 26483 000036CB 57                      	push	di
 26484 000036CC 0E                      	push	cs
 26485 000036CD 07                      	pop	es
 26486 000036CE E81300                  	call	GetDate 		; get date
 26487 000036D1 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26488 000036D3 890E[1681]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26489 000036D7 8916[1881]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26490 000036DB BA[0681]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26491 000036DE E80E17                  	call	std_printf
 26492                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26493                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26494 000036E1 5F                      	pop	di			;AC000; restore di,es
 26495 000036E2 07                      	pop	es			;AC000;
 26496 000036E3 C3                      	retn
 26497                                  
 26498                                  ; ---------------------------------------------------------------------------
 26499                                  
 26500                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26501                                  
 26502                                  ;GETDATE:
 26503                                  	; 21/03/2023
 26504                                  	; MSDOS 3.3
 26505                                  	;mov	si,ax
 26506                                  	;shl	si,1
 26507                                  	;add	si,ax
 26508                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26509                                  	;mov	bx,cx
 26510                                  	;mov	cx,3
 26511                                  	;rep	movsb
 26512                                  	;mov	al,' '
 26513                                  	;stosb
 26514                                  	;retn
 26515                                  
 26516                                  	; 21/03/2023
 26517                                  	; MSDOS 6.0
 26518                                  
 26519                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26520                                  ; for output. Date will be returned in CX,DX.
 26521                                  
 26522                                  GetDate:
 26523 000036E4 BF[1A93]                	mov	di,Arg_Buf		;AC000; target for day of week
 26524 000036E7 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26525 000036E9 CD21                    	int	21h			;AC000; Get date in CX:DX
 26526 000036EB 98                      	cbw				;AC000;
 26527 000036EC 51                      	push	cx			;AN000; save date returned in
 26528 000036ED 52                      	push	dx			;AN000;  CX:DX
 26529 000036EE 89C6                    	mov	si,ax
 26530 000036F0 D1E6                    	shl	si,1
 26531 000036F2 01C6                    	add	si,ax			; SI=AX*3
 26532 000036F4 89F1                    	mov	cx,si			;AN000; save si
 26533 000036F6 A1[D27F]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26534 000036F9 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26535 000036FB 57                      	push	di			;AN000; save argument buffer
 26536 000036FC E8D517                  	call	TSYSGETMSG		;AN000; get the address of the message
 26537 000036FF 5F                      	pop	di			;AN000; retrieve argument buffer
 26538 00003700 01CE                    	add	si,cx			;AC000; get day of week
 26539 00003702 B90300                  	mov	cx,3
 26540 00003705 F3A4                      	rep	movsb
 26541 00003707 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26542 00003709 AA                      	stosb
 26543 0000370A 5A                      	pop	dx			;AN000; get back date
 26544 0000370B 59                      	pop	cx			;AN000;
 26545 0000370C C3                      	retn
 26546                                  
 26547                                  ; =============== S U B	R O U T	I N E =======================================
 26548                                  
 26549                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26550                                  
 26551                                  	; MSDOS 6.0
 26552                                  
 26553                                  ; This routine determines whether the character in AL is a
 26554                                  ; Yes or No character. On return, if AL=0, the character is
 26555                                  ; No, if AL=1, the character is Yes.
 26556                                  
 26557                                  ;	assume	ds:trangroup
 26558                                  
 26559                                  char_in_xlat:	; proc	near
 26560                                  	; 21/03/2023
 26561 0000370D 88C2                    	mov	dl,al			;AC000; get character into DX
 26562 0000370F 30F6                    	xor	dh,dh			;AC000;
 26563                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26564 00003711 B82365                  	mov	ax,6523h
 26565 00003714 CD21                    	int	21h			;AC000;
 26566 00003716 C3                      	retn
 26567                                  
 26568                                  ;char_in_xlat	endp
 26569                                  
 26570                                  ;============================================================================
 26571                                  ; TENV.ASM, MSDOS 6.0, 1991
 26572                                  ;============================================================================
 26573                                  ; 02/10/2018 - Retro DOS v3.0
 26574                                  
 26575                                  ;	Environment utilities and misc. routines
 26576                                  
 26577                                  ; MSDOS 6.0
 26578                                  ; ****************************************************************
 26579                                  ; *
 26580                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26581                                  ; *
 26582                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26583                                  ; *		 the character in AL from the file upper case table
 26584                                  ; *		 in DOS if character if above  ascii 128, else
 26585                                  ; *		 subtracts 20H if between "a" and "z".
 26586                                  ; *
 26587                                  ; * INPUT:	 AL	      char to be upper cased
 26588                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26589                                  ; *
 26590                                  ; * OUTPUT:	 AL	      upper cased character
 26591                                  ; *
 26592                                  ; ****************************************************************
 26593                                  ;
 26594                                  ;assume	ds:trangroup				;AN000;
 26595                                  ;
 26596                                  ;upconv	proc	near				;AN000;
 26597                                  ;
 26598                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26599                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26600                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26601                                  ;	push	ds				;AN000;
 26602                                  ;	push	bx				;AN000;
 26603                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26604                                  ;assume	ds:resgroup				;AN000;
 26605                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26606                                  ;	add	bx,2				;AN000;  skip over first word
 26607                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26608                                  ;	pop	bx				;AN000;
 26609                                  ;	pop	ds				;AN000;
 26610                                  ;assume	ds:trangroup				;AN000;
 26611                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26612                                  ;
 26613                                  ;oth_fucase:					;AN000;
 26614                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26615                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26616                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26617                                  ;	ja	upconv_end			;AC000;
 26618                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26619                                  ;
 26620                                  ;upconv_end:					;AN000;
 26621                                  ;	ret
 26622                                  ;
 26623                                  ;upconv	endp					;AN000;
 26624                                  
 26625                                  
 26626                                  ; =============== S U B	R O U T	I N E =======================================
 26627                                  
 26628                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26629                                  
 26630                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26631                                  %if 0
 26632                                  
 26633                                  UPCONV:
 26634                                  	cmp	al,80h
 26635                                  	jb	short OTH_UCASE
 26636                                  	sub	al,80h
 26637                                  	push	ds
 26638                                  	push	bx
 26639                                  	mov	ds,[RESSEG]
 26640                                  	lds	bx,[UPPERCASETBL]
 26641                                  	add	bx,2
 26642                                  	xlat
 26643                                  	pop	bx
 26644                                  	pop	ds
 26645                                  	jmp	short UPCONV_RETN
 26646                                  
 26647                                  OTH_UCASE:
 26648                                  	cmp	al,'a'
 26649                                  	jb	short UPCONV_RETN
 26650                                  	cmp	al,'z'
 26651                                  	ja	short UPCONV_RETN
 26652                                  	sub	al,20h
 26653                                  
 26654                                  UPCONV_RETN:
 26655                                  	retn
 26656                                  
 26657                                  %endif
 26658                                  
 26659                                  ;============================================================================
 26660                                  ; COPY.ASM, MSDOS 6.0, 1991
 26661                                  ;============================================================================
 26662                                  ; 01/10/2018 - Retro DOS v3.0
 26663                                  
 26664                                  ;	title	COMMAND COPY routines.
 26665                                  
 26666                                  ;/*
 26667                                  ; *                      Microsoft Confidential
 26668                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26669                                  ; *                      All Rights Reserved.
 26670                                  ; */
 26671                                  
 26672                                  ;***	COPY.ASM
 26673                                  
 26674                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26675                                  
 26676                                  
 26677                                  ;***	MODIFICATION HISTORY
 26678                                  
 26679                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26680                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26681                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26682                                  ;	     to tokens which begin with path characters so that PARSELINE
 26683                                  ;	     will work correctly.
 26684                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26685                                  ;	     individual tokens. That distinction is no longer needed for
 26686                                  ;	     FOR loop processing.
 26687                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26688                                  ;	     1 when Cparse is called from COPY.
 26689                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26690                                  ;	     mod. It now is conditional on flag like previous mod.
 26691                                  ;11/21/83 NP  Added printf
 26692                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26693                                  ;	     be added to a token.
 26694                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26695                                  ;	     NOTE: DestHand is the destination handle. There are two
 26696                                  ;	     special values: -1 meaning destination was never opened and
 26697                                  ;	     0 which means that the destination has been openned and
 26698                                  ;	     closed.
 26699                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26700                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26701                                  ;	     lost on large and multiple file (wildcard) copies.
 26702                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26703                                  ;	     destination are not equal.
 26704                                  ;
 26705                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26706                                  ;	     first source file AND we run out of disk space before
 26707                                  ;	     completing the concatenation, restore the first source
 26708                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26709                                  ;
 26710                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26711                                  ;		instead of compatibility mode. This gives lesser sharing
 26712                                  ;		violations when files are opened for read on a copy.
 26713                                  
 26714                                  ; ---------------------------------------------------------------------------
 26715                                  ;***	COPY CODE
 26716                                  ; ---------------------------------------------------------------------------
 26717                                  
 26718                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26719                                  
 26720                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26721                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26722                                  
 26723                                  COPY:
 26724                                  	; 	Initialize internal variables.
 26725                                  
 26726 00003717 31C0                    	xor	ax,ax		; AX = 0
 26727 00003719 A3[378C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26728 0000371C A3[658D]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26729 0000371F A3[B18C]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26730 00003722 A2[E48A]                	mov	[CFLAG],al	; 'destination file created' = false
 26731 00003725 A3[E88A]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26732 00003728 A3[E08A]                	mov	[DestSwitch],ax	; destination switches = none
 26733 0000372B A3[7B8D]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26734 0000372E A3[4E8C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26735 00003731 A2[E58A]                	mov	[DestClosed],al	; 'destination file closed' = false
 26736 00003734 A2[4D8C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26737 00003737 A2[B08C]                	mov	[SrcSiz],al	; length of source pathname = 0
 26738 0000373A A2[508C]                	mov	[DestInfo],al	; destination pathname flags = none
 26739 0000373D A2[B38C]                	mov	[SrcInfo],al	; source pathname flags = none
 26740 00003740 A2[678D]                	mov	[INEXACT],al	; 'inexact copy' = false
 26741 00003743 A2[4C8C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26742 00003746 A2[AF8C]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26743 00003749 A2[A789]                	mov	[USERDIR1],al	; saved working directory = null
 26744 0000374C A2[688D]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26745 0000374F A2[D88A]                	mov	[RDEOF],al	; 'read end of file' = false
 26746 00003752 A3[0B8D]                	mov	[SRCHAND],ax	; source handle = 0
 26747 00003755 A3[708D]                	mov	[CPDATE],ax	; copy date = 0
 26748 00003758 A3[728D]                	mov	[CPTIME],ax	; copy time = 0
 26749 0000375B A2[0D8D]                	mov	[SRCISDEV],al	; 'source is device' = false
 26750                                  	; 23/03/2023
 26751                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26752 0000375E A2[788D]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26753 00003761 A3[748D]                	mov	[OFilePtr_Lo],ax
 26754 00003764 A3[768D]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26755 00003767 A2[6C8D]                	mov	[TERMREAD],al	; 'terminate read' = false
 26756 0000376A A2[2A8C]                	mov	[comma],al	; '"+,," found' = false
 26757 0000376D A2[2B8C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26758 00003770 A2[B78D]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26759 00003773 A3[E28A]                	mov	[AllSwitch],ax	; all switches = none
 26760 00003776 A2[DB8A]                	mov	[ArgC],al	; source/dest argument count = 0
 26761 00003779 A2[6E8D]                	mov	[PLUS],al	; '"+" in command line' = false
 26762 0000377C A2[698D]                	mov	[BINARY],al	; 'binary copy' = false
 26763 0000377F A2[6D8D]                	mov	[ASCII],al	; 'ascii copy' = false
 26764 00003782 A3[F18A]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26765 00003785 A3[6A8D]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26766 00003788 A2[DA8A]                	mov	[Concat],al	; 'concatenating' = false
 26767 0000378B A2[AC8C]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26768 0000378E A3[AD8C]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 26769                                  
 26770                                  	;	Initialize buffers with double-nulls.
 26771                                  
 26772 00003791 A3[0E8D]                	mov	[ScanBuf],ax
 26773 00003794 A3[518C]                	mov	[DestBuf],ax
 26774 00003797 A3[B48C]                	mov	[SrcBuf],ax
 26775 0000379A A3[148C]                	mov	[SDIRBUF],ax
 26776 0000379D A3[CE8B]                	mov	[DIRBUF],ax
 26777 000037A0 A3[8B8B]                	mov	[DestFcb],ax
 26778                                  
 26779 000037A3 A2[6F8D]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26780                                  		
 26781 000037A6 48                      	dec	ax ; -1		; AX = 0FFFFh
 26782 000037A7 A3[A88C]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26783 000037AA A2[EA8A]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26784 000037AD A2[AB8C]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26785 000037B0 A2[4C8C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26786                                  		
 26787 000037B3 BE8100                  	mov	si,81h		; SI = ptr to command line
 26788                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26789                                  	; 23/03/2023
 26790 000037B6 B32B                    	mov	bl,'+'
 26791 000037B8 FE06[B68D]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26792 000037BC C606[398C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26793                                  
 26794                                  	;*	Scan the command line for destination information.
 26795                                  
 26796                                  DESTSCAN:
 26797 000037C1 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26798 000037C3 BF[0E8D]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26799                                  	; 23/03/2023
 26800 000037C6 8936[2D8C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26801 000037CA E88C09                  	call	cparse			; parse next object
 26802 000037CD 9C                      	pushf				; save CParse flags
 26803 000037CE FE06[6F8D]              	inc	byte [objcnt]		; count object
 26804 000037D2 F6C780                  	test	bh,80h
 26805 000037D5 7405                    	jz	short NOCOPY		; no "+" delimiter
 26806 000037D7 C606[6E8D]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26807                                  NOCOPY:
 26808 000037DC F6C701                  	test	bh,1
 26809 000037DF 742E                    	jz	short TESTP2		; not a switch
 26810                                  
 26811                                  	;	Found a switch.
 26812                                  
 26813                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26814                                  	; MSDOS 6.0
 26815 000037E1 F7C51000                	test	bp,10h
 26816                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26817 000037E5 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26818 000037E7 F606[E28A]10            	test	byte [AllSwitch],10h
 26819                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26820 000037EC 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26821                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26822                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26823 000037EE 81CD0040                	or	bp,4000h
 26824                                  NOT_SLASHV:
 26825 000037F2 092E[E08A]              	or	[DestSwitch],bp		; assume destination
 26826 000037F6 092E[E28A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26827                                  
 26828                                  	; 23/03/2023
 26829                                  	; MSDOS 6.0
 26830                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26831 000037FA F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26832 000037FE 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26833 00003800 9D                      	popf				;AN018; fix up stack
 26834 00003801 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26835 00003804 E8C1E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26836 00003807 E948F1                  	jmp	cerror			;AC018; exit
 26837                                  NOT_BAD_SWITCH:
 26838 0000380A 9D                      	popf				; restore CParse flags
 26839 0000380B 7233                    	jc	short CHECKDONE		; found CR
 26840 0000380D EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26841                                  TESTP2:
 26842 0000380F 9D                      	popf				; restore CParse flags
 26843 00003810 722E                    	jc	short CHECKDONE		; found CR
 26844 00003812 F6C780                  	test	bh,80h
 26845 00003815 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26846 00003817 FE06[DB8A]              	inc	byte [ArgC]		; count independent pathname args
 26847                                  GOTPLUS:
 26848 0000381B 56                      	push	si			; save cmd line ptr
 26849 0000381C A1[7B8D]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26850 0000381F BE[0E8D]                	mov	si,ScanBuf		; SI = ptr to path string
 26851 00003822 29F0                    	sub	ax,si			; AX = offset of last element
 26852 00003824 BF[518C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26853 00003827 01F8                    	add	ax,di			; AX = ptr to last element in
 26854                                  					;  destination path buffer
 26855 00003829 A3[4E8C]                	mov	[DestTail],ax		; save ptr to last element
 26856 0000382C 880E[4D8C]              	mov	[DestSiz],cl		; save path string length
 26857 00003830 41                      	inc	cx			; CX = mov length (incl null)
 26858 00003831 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26859 00003833 883E[508C]              	mov	[DestInfo],bh		; save CParse info flags
 26860 00003837 C706[E08A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26861 0000383D 5E                      	pop	si			; SI = ptr into cmd line again
 26862 0000383E EB81                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26863                                  
 26864                                  CHECKDONE:
 26865                                  	;	We reached the CR. The destination scan is finished.
 26866                                  
 26867                                  	;	Disallow "copy file1+" as file overwriting itself.
 26868                                  	;
 26869                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26870                                  	;	equivalent to "copy file1+file2".)
 26871                                  
 26872                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26873                                  	;	through this check, since the switch would count
 26874                                  	;	as another object in ObjCnt.
 26875                                  
 26876 00003840 803E[6E8D]01            	cmp	byte [PLUS],1		; "+" with
 26877 00003845 7514                    	jnz	short CDCONT
 26878 00003847 803E[DB8A]01            	cmp	byte [ArgC],1		; one arg,
 26879 0000384C 750D                    	jnz	short CDCONT
 26880 0000384E 803E[6F8D]02            	cmp	byte [objcnt],2		; two objects..
 26881 00003853 7506                    	jnz	short CDCONT
 26882 00003855 BA[447F]                	mov	dx,OVERWR_PTR
 26883 00003858 E91A06                  	jmp	COPYERR			; is file overwrite
 26884                                  
 26885                                  CDCONT:
 26886 0000385B A0[6E8D]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26887 0000385E A2[DA8A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26888 00003861 D0E0                    	shl	al,1
 26889 00003863 D0E0                    	shl	al,1
 26890 00003865 A2[678D]                	mov	[INEXACT],al		; therefore making an inexact copy
 26891                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26892 00003868 A0[DB8A]                	mov	al,[ArgC]		; AL = # independent arguments
 26893                                  
 26894                                  	; 23/03/2023
 26895                                  	; MSDOS 3.3		
 26896                                  	;or	al,al
 26897                                  	;jz	short CERROR4J
 26898                                  	; MSDOS 6.0
 26899 0000386B 08C0                    	or	al,al
 26900 0000386D 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26901                                  		
 26902 0000386F BA[1B7F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26903 00003872 C706[1B7F]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26904                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26905 00003878 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26906                                  
 26907                                  	; more than 0 args; check if too many
 26908                                  TRY_TOO_MANY:
 26909 0000387A 3C02                    	cmp	al,2
 26910 0000387C 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26911                                  
 26912                                  	; 23/03/2023
 26913                                  	; MSDOS 6.0
 26914 0000387E BA[1B7F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26915 00003881 C706[1B7F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26916                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26917                                  CERROR_PARSEJ:
 26918 00003887 C606[197F]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26919                                  					; parse error message	
 26920                                  CERROR4J:
 26921 0000388C E9C3F0                  	jmp	cerror
 26922                                  
 26923                                  ACOUNTOK:
 26924 0000388F BD[4C8C]                	mov	bp,DestVars		; BP = base of dest variables
 26925                                  
 26926 00003892 3C01                    	cmp	al,1
 26927 00003894 7520                    	jnz	short GOT2ARGS
 26928                                  
 26929                                  	;	Only one independent pathname argument on command line.
 26930                                  	;	Set destination to d:*.*, where d: is current drive.
 26931                                  
 26932                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26933                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26934                                  
 26935 00003896 A0[D98A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26936                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26937                                  	; 23/03/2023
 26938 00003899 0441                    	add	al,'A'
 26939 0000389B B43A                    	mov	ah,':'			; AX = "d:"
 26940                                  	;mov	byte [bp+1],2
 26941 0000389D C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26942                                  
 26943 000038A1 BF[518C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26944 000038A4 AB                      	stosw				; store "d:"
 26945                                  		
 26946 000038A5 C706[E08A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26947                                  	;mov	byte [bp+4],2		
 26948 000038AB C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26949                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26950                                  	;mov	byte [bp+0],0		
 26951 000038AF C6460000                	mov	byte [bp],0
 26952 000038B3 E87408                  	call	SETSTARS		; add wildcards
 26953                                  GOT2ARGS:
 26954                                  	;	If destination pathname is "d:", add full wildcard filename
 26955                                  
 26956                                  	;cmp	byte [bp+1],2
 26957 000038B6 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26958 000038BA 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26959 000038BC B03A                    	mov	al,':'  ; 3Ah
 26960 000038BE 3806[528C]              	cmp	byte [DestBuf+1],al
 26961 000038C2 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26962                                  	;or	byte [bp+4],2
 26963 000038C4 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26964 000038C8 BF[538C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26965                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26966                                  	;mov	byte [bp+0],0		
 26967 000038CB C6460000                	mov	byte [bp],0
 26968 000038CF E85808                  	call	SETSTARS		; add wildcards
 26969                                  NOTSHORTDEST:
 26970                                  	;	If destination pathname ends with "\", try to make
 26971                                  	;	sure it's "d:\".
 26972                                  
 26973                                  	;mov	di,[bp+2]
 26974 000038D2 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 26975 000038D5 803D00                  	cmp	byte [di],0
 26976 000038D8 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 26977                                  
 26978 000038DA BA[5680]                	mov	dx,badcd_ptr
 26979 000038DD B03A                    	mov	al,':'
 26980 000038DF 3845FE                  	cmp	[di-2],al
 26981 000038E2 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 26982                                  	;mov	byte [bp+0],2
 26983                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 26984 000038E4 C6460002                	mov	byte [bp],2
 26985                                  	;or	byte [bp+4],6
 26986 000038E8 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 26987                                  					  ;  path character
 26988 000038EC E83B08                  	call	SETSTARS		; add wildcards
 26989                                  CHKSWTCHES:
 26990                                  	;	We have enough information about the destination for now.
 26991                                  
 26992                                  	;	Turn on verify if requested. Save the current verify flag.
 26993                                  
 26994                                  	; 23/03/2023
 26995                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 26996                                  	;mov	dx,BADPARMPTR
 26997                                  	
 26998 000038EF A1[E28A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 26999                                  
 27000                                  	; 23/03/2023
 27001                                  	; MSDOS 3.3
 27002                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27003                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27004                                  	;jnz	short CERROR4J
 27005                                  	
 27006                                  	; 23/03/2023
 27007                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27008                                  	;test	ax,SwitchV ; 10h
 27009                                  	; 18/04/2023
 27010                                  	;test	ax,10h
 27011 000038F2 A810                    	test	al,10h  ; test al,SwitchV
 27012 000038F4 7414                    	jz	short NOVERIF		; no /v, no verify
 27013                                  
 27014 000038F6 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27015 000038F8 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27016                                  				; Return: AL = 00h if flag OFF
 27017                                  				; AL = 01h if flag ON
 27018 000038FA 1E                      	push	ds
 27019 000038FB 8E1E[C58A]              	mov	ds,[RESSEG]
 27020 000038FF 30E4                    	xor	ah,ah
 27021 00003901 A3[9001]                	mov	[VerVal],ax		; save current verify flag
 27022 00003904 1F                      	pop	ds
 27023 00003905 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27024 00003908 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27025                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27026                                  NOVERIF:
 27027                                  	;*	Scan for first source.
 27028                                  
 27029 0000390A 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27030 0000390C BE8100                  	mov	si,81h			; SI = ptr into command line
 27031                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27032                                  	; 23/03/2023
 27033 0000390F B32B                    	mov	bl,'+' ; 2Bh
 27034                                  SCANFSRC:
 27035 00003911 BF[0E8D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27036 00003914 E84208                  	call	cparse			; parse first source pathname
 27037 00003917 F6C701                  	test	bh,1			; switch?
 27038 0000391A 75F5                    	jnz	short SCANFSRC		; yes, try again
 27039 0000391C 092E[E08A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27040                                  
 27041                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27042                                  
 27043                                  	; 23/03/2023
 27044 00003920 F7C50800                	test	bp,8
 27045                                  	;test	bp,SWITCHB
 27046 00003924 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27047 00003926 803E[DA8A]00            	cmp	byte [Concat],0
 27048 0000392B 7405                    	jz	short NOSETCASC		; we're not concatenating
 27049 0000392D C606[6D8D]04            	mov	byte [ASCII],4
 27050                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27051                                  NOSETCASC:
 27052 00003932 E8B503                  	call	SOURCE_SET		; set source variables
 27053 00003935 E84400                  	call	FRSTSRC			; set up first source copy
 27054 00003938 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27055                                  
 27056                                  ; ---------------------------------------------------------------------------
 27057                                  
 27058                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27059                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27060                                  ENDCOPY:
 27061                                  	;*	End of the road. Close destination, display # files
 27062                                  	;	copied (meaning # destinations), and go back to main
 27063                                  	;	transient COMMAND code.
 27064                                  
 27065 0000393B E8C102                  	call	CLOSEDEST
 27066                                  ENDCOPY2:
 27067 0000393E BA[4D7F]                	mov	dx,copied_ptr
 27068 00003941 8B36[F18A]              	mov	si,[FileCnt]
 27069 00003945 8936[378C]              	mov	[Copy_num],si
 27070 00003949 E8A314                  	call	std_printf
 27071 0000394C E9B5C7                  	jmp	TCOMMAND		; stack could be messed up
 27072                                  
 27073                                  ; ---------------------------------------------------------------------------
 27074                                  
 27075                                  SRCNONEXIST:
 27076                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27077                                  	;	Otherwise, say 'file not found' and quit.
 27078                                  
 27079 0000394F 803E[DA8A]00            	cmp	byte [Concat],0
 27080 00003954 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27081                                  
 27082                                  	; 24/03/2023
 27083                                  	; MSDOS 3.3
 27084                                  	;mov	dx,SRCBUF
 27085                                  	;mov	[STRING_PTR_1],dx
 27086                                  	;mov	dx,STRINGBUF1PTR
 27087                                  	;call	STD_PRINTF
 27088                                  	;mov	dx,FNOTFOUNDPTR
 27089                                  	;jmp	COPYERR
 27090                                  
 27091                                  	; 24/*03/2023
 27092                                  	; MSDOS 6.0
 27093                                  	;	Set up error message.
 27094 00003956 C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27095                                  				  	; extended error msg
 27096 0000395B BA[1B7F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27097 0000395E C706[1B7F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27098                                  					; 'file not found' msg#
 27099 00003964 C706[358C][B48C]        	mov	word [string_ptr_2],SrcBuf
 27100                                  					; point at bad pathname
 27101 0000396A C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27102                                  					; 1 substitution
 27103 0000396F E90305                  	jmp	COPYERR			; print msg and clean up
 27104                                  
 27105                                  ; ---------------------------------------------------------------------------
 27106                                  
 27107                                  SOURCEPROC:
 27108                                  
 27109                                  	;*	Preparatory processing for each source file.
 27110                                  	;	Called at FrstSrc for first source file.
 27111                                  
 27112 00003972 E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 27113 00003975 803E[DA8A]00            	cmp	byte [Concat],0
 27114 0000397A 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27115                                  
 27116                                  ; ---------------------------------------------------------------------------
 27117                                  
 27118                                  FRSTSRC:
 27119 0000397C 31C0                    	xor	ax,ax
 27120 0000397E A2[E48A]                	mov	[CFLAG],al		; 'destination not created'
 27121 00003981 A3[E88A]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27122 00003984 A2[E58A]                	mov	[DestClosed],al		; 'destination not closed'
 27123                                  
 27124                                  LEAVECFLAG:
 27125 00003987 8936[658D]              	mov	[SRCPT],si		; save cmd-line ptr
 27126 0000398B BF[A789]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27127                                  						;   current dir
 27128 0000398E BD[AF8C]                	mov	bp,SrcVars		; BP = base of source variables
 27129 00003991 E84606                  	call	BUILDPATH		; cd to source dir, figure
 27130                                  						;   out stuff about source
 27131 00003994 8B36[B18C]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27132 00003998 C3                      	retn
 27133                                  
 27134                                  ; ---------------------------------------------------------------------------
 27135                                  
 27136                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27137                                  NEXTSRC:
 27138                                  	;*	Next source. Come here after handling each pathname.
 27139                                  	;	We're done unless there are additional source pathnames
 27140                                  	;	to be appended.
 27141                                  	;
 27142                                  	;	Note that all files matching an ambiguous pathname
 27143                                  	;	are processed before coming here.
 27144                                  
 27145 00003999 803E[6E8D]00            	cmp	byte [PLUS],0
 27146                                  	;jne	short MORECP		; copying "+" sources - keep going
 27147                                  	; 26/04/2023
 27148                                  ;ENDCOPYJ2:
 27149                                  	;jmp	short ENDCOPY
 27150 0000399E 749B                    	je	short ENDCOPY
 27151                                  MORECP:
 27152 000039A0 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27153 000039A2 8B36[658D]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27154                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27155 000039A6 B32B                    	mov	bl,'+' ; 2Bh
 27156                                  SCANSRC:
 27157 000039A8 BF[0E8D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27158 000039AB E8AB07                  	call	cparse			; parse first source name
 27159                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27160                                  	; 26/04/2023
 27161 000039AE 728B                    	jb	short ENDCOPY
 27162                                  
 27163 000039B0 F6C780                  	test	bh,80h
 27164                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27165                                  	; 26/04/2023
 27166 000039B3 7486                    	jz	short ENDCOPY
 27167                                  
 27168 000039B5 F6C701                  	test	bh,1
 27169 000039B8 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27170                                  
 27171                                  	;	ScanBuf contains the next source pathname.
 27172                                  
 27173 000039BA E8B5FF                  	call	SOURCEPROC		; prepare this source
 27174 000039BD 803E[2A8C]01            	cmp	byte [comma],1		; was +,, found last time?
 27175 000039C2 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27176 000039C4 C606[2B8C]01            	mov	byte [plus_comma],1	; yes - set flag
 27177 000039C9 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27178                                  
 27179                                  NOSTAMP:
 27180 000039CB C606[2B8C]00            	mov	byte [plus_comma],0	; reset +,, flag
 27181                                  
 27182                                  ; ---------------------------------------------------------------------------
 27183                                  
 27184                                  FIRSTENT:
 27185                                  
 27186                                  ;M047
 27187                                  ; The only case we need to worry about is when the source is wildcarded and
 27188                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27189                                  ;concatenation. We check for this case.
 27190                                  ;
 27191                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27192                                  ;right place to do this check.
 27193                                  
 27194                                  	;	This is where we enter the loop with the first source.
 27195                                  
 27196 000039D0 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27197 000039D3 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27198 000039D6 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27199                                  				; DS:SI	-> string to parse
 27200                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27201                                  				; AL = bit mask	to control parsing
 27202 000039D8 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27203 000039DB 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27204 000039DD A1[B48C]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27205 000039E0 80FC3A                  	cmp	ah,':'
 27206 000039E3 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27207 000039E5 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27208                                  DRVSPEC1:
 27209 000039E7 0C20                    	or	al,20h			; AL = lowercase drive letter
 27210 000039E9 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27211                                  	;mov	[5Ch],al
 27212 000039EB A25C00                  	mov	[FCB],al		; put drive id in FCB
 27213                                  
 27214                                  	;	FCB contains drive and filename to search.
 27215                                  		
 27216 000039EE B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 27217 000039F0 E8FC00                  	call	SEARCH
 27218                                  SRCHDONE:
 27219 000039F3 9C                      	pushf				; save flags from Search
 27220 000039F4 E88AEA                  	call	RestUDir1		; restore users current directory
 27221 000039F7 9D                      	popf				; restore flags from search
 27222 000039F8 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27223 000039FA E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27224                                  
 27225                                  NEXTAMBIG0:
 27226 000039FD 30C0                    	xor	al,al
 27227 000039FF 8606[EA8A]              	xchg	al,[FRSTSRCH]
 27228 00003A03 08C0                    	or	al,al
 27229 00003A05 740B                    	jz	short NEXTAMBIG
 27230                                  SETNMEL:
 27231 00003A07 B90C00                  	mov	cx,12
 27232 00003A0A BF[148C]                	mov	di,SDIRBUF
 27233 00003A0D BE[CE8B]                	mov	si,DIRBUF
 27234 00003A10 F3A4                    	rep	movsb			; save very first source name
 27235                                  NEXTAMBIG:
 27236 00003A12 30C0                    	xor	al,al
 27237 00003A14 A2[688D]                	mov	[NOWRITE],al		; turn off nowrite
 27238 00003A17 8B3E[B18C]              	mov	di,[SrcTail]
 27239 00003A1B BE[CF8B]                	mov	si,DIRBUF+1
 27240 00003A1E E8DCEB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27241                                  MELDO:
 27242 00003A21 803E[DA8A]00            	cmp	byte [Concat],0
 27243 00003A26 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27244 00003A28 F606[B38C]02            	test	byte [SrcInfo],2	; wildcard - show name
 27245 00003A2D 7409                    	jz	short DOREAD
 27246                                  SHOWCPNAM:
 27247                                  	; 25/03/2023
 27248                                  	; MSDOS 3.3
 27249                                  	;mov	dx,SRCBUF
 27250                                  	;mov	[STRING_PTR_2],dx
 27251                                  	;mov	dx,STRINGBUF2PTR
 27252                                  	;call	STD_PRINTF
 27253                                  	;call	CRLF2
 27254                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27255                                  	; MSDOS 6.0 (& MSDOS 5.0
 27256 00003A2F BA[C680]                	mov	dx,file_name_ptr
 27257 00003A32 E8BA13                  	call	std_printf
 27258 00003A35 E899EB                  	call	CRLF2
 27259                                  DOREAD:
 27260 00003A38 E8C500                  	call	DOCOPY
 27261 00003A3B 803E[DA8A]00            	cmp	byte [Concat],0
 27262 00003A40 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27263                                  
 27264 00003A42 E8BA01                  	call	CLOSEDEST		; close current destination
 27265 00003A45 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27266                                  
 27267 00003A47 C606[E48A]00            	mov	byte [CFLAG],0		; 'destination not created'
 27268                                  NODCLOSE:
 27269 00003A4C 803E[DA8A]00            	cmp	byte [Concat],0		
 27270 00003A51 740A                    	jz	short NOFLUSH
 27271                                  
 27272                                  ;	Concatenating - flush output between source files so LostErr
 27273                                  ;	stuff works correctly.
 27274                                  
 27275                                  	;invoke	FlshFil  ; MSDOS 6.0
 27276                                  	; 25/03/2023
 27277 00003A53 E8E202                  	call	FlshFil
 27278                                  	;call	FLUSHFIL ; MSDOS 3.3
 27279                                  
 27280 00003A56 F606[AC8C]FF            	test	byte [MELCOPY],0FFh
 27281                                  	;jz	short NOFLUSH
 27282                                  	;jmp	short DOMELCOPY
 27283                                  	; 25/03/2023
 27284 00003A5B 750C                    	jnz	short DOMELCOPY
 27285                                  NOFLUSH:
 27286 00003A5D E88300                  	call	SEARCHNEXT		; try next match
 27287 00003A60 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 27288                                  					;   this source spec
 27289 00003A62 C606[E58A]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27290 00003A67 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 27291                                  
 27292                                  DOMELCOPY:
 27293 00003A69 803E[AC8C]FF            	cmp	byte [MELCOPY],0FFh
 27294 00003A6E 740D                    	je	short CONTMEL
 27295 00003A70 8B36[658D]              	mov	si,[SRCPT]
 27296 00003A74 8936[AD8C]              	mov	[MELSTART],si
 27297 00003A78 C606[AC8C]FF            	mov	byte [MELCOPY],0FFh
 27298                                  
 27299                                  CONTMEL:
 27300 00003A7D 31ED                    	xor	bp,bp
 27301 00003A7F 8B36[658D]              	mov	si,[SRCPT]
 27302                                  	;mov	bl,[PLUS_CHR]
 27303                                  	; 25/03/2023
 27304 00003A83 B32B                    	mov	bl,'+'
 27305                                  SCANSRC2:
 27306 00003A85 BF[0E8D]                	mov	di,ScanBuf
 27307 00003A88 E8CE06                  	call	cparse
 27308 00003A8B F6C780                  	test	bh,80h
 27309 00003A8E 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 27310 00003A90 F6C701                  	test	bh,1
 27311 00003A93 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27312 00003A95 E8DAFE                  	call	SOURCEPROC
 27313 00003A98 E8E6E9                  	call	RestUDir1
 27314 00003A9B BF[4F8B]                	mov	di,DESTFCB2
 27315 00003A9E B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27316 00003AA1 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27317                                  				; DS:SI	-> string to parse
 27318                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27319                                  				; AL = bit mask	to control parsing
 27320 00003AA3 BB[158C]                	mov	bx,SDIRBUF+1
 27321 00003AA6 BE[508B]                	mov	si,DESTFCB2+1
 27322 00003AA9 8B3E[B18C]              	mov	di,[SrcTail]
 27323                                  
 27324 00003AAD E8FB04                  	call	BUILDNAME
 27325                                  
 27326 00003AB0 803E[DA8A]00            	cmp	byte [Concat],0
 27327 00003AB5 7405                    	je	short MELDOJ		; not concatenating - continue
 27328                                  
 27329                                  	;	Yes, turn off nowrite because this part of the code 
 27330                                  	;	is only reached after the first file has been dealt with.
 27331                                  
 27332 00003AB7 C606[688D]00            	mov	byte [NOWRITE],0
 27333                                  MELDOJ:
 27334 00003ABC E962FF                  	jmp	MELDO
 27335                                  NEXTSRCJ:
 27336 00003ABF E9D7FE                  	jmp	NEXTSRC
 27337                                  
 27338                                  NEXTMEL:
 27339 00003AC2 E83A01                  	call	CLOSEDEST
 27340 00003AC5 31C0                    	xor	ax,ax
 27341 00003AC7 A2[E48A]                	mov	[CFLAG],al
 27342 00003ACA A3[E88A]                	mov	[NXTADD],ax
 27343 00003ACD A2[E58A]                	mov	[SPECDRV],al
 27344 00003AD0 8B36[AD8C]              	mov	si,[MELSTART]
 27345 00003AD4 8936[658D]              	mov	[SRCPT],si
 27346 00003AD8 E80800                  	call	SEARCHNEXT
 27347 00003ADB 7403                    	jz	short SETNMELJ
 27348 00003ADD E95EFE                  	jmp	ENDCOPY2
 27349                                  SETNMELJ:
 27350 00003AE0 E924FF                  	jmp	SETNMEL
 27351                                  
 27352                                  ; ---------------------------------------------------------------------------
 27353                                  
 27354                                  SEARCHNEXT:
 27355 00003AE3 B412                    	mov	ah,Dir_Search_Next ; 12h
 27356 00003AE5 F606[B38C]02            	test	byte [SrcInfo],2
 27357 00003AEA 7503                    	jnz	short SEARCH		; do search-next if ambig
 27358 00003AEC 08E4                    	or	ah,ah			; reset zero flag
 27359 00003AEE C3                      	retn
 27360                                  
 27361                                  ; ---------------------------------------------------------------------------
 27362                                  
 27363                                  SEARCH:
 27364 00003AEF 50                      	push	ax
 27365 00003AF0 B41A                    	mov	ah,Set_DMA ; 1Ah
 27366 00003AF2 BA[CE8B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27367 00003AF5 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27368                                  			; DS:DX	-> disk	transfer buffer
 27369 00003AF7 58                      	pop	ax		; restore search first/next command
 27370 00003AF8 BA5C00                  	mov	dx,FCB ; 5Ch
 27371 00003AFB CD21                    	int	21h		; Do the search
 27372 00003AFD 08C0                    	or	al,al
 27373 00003AFF C3                      	retn
 27374                                  
 27375                                  ; ---------------------------------------------------------------------------
 27376                                  
 27377                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27378                                  DOCOPY:
 27379 00003B00 BE[B48C]                	mov	si,SrcBuf	; do name translate of source
 27380 00003B03 BF[F387]                	mov	di,SRCXNAME	; save for name comparison
 27381 00003B06 B460                    	mov	ah,xNameTrans ; 60h
 27382 00003B08 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27383                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27384                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27385 00003B0A C606[D88A]00            	mov	byte [RDEOF],0	; no EOF yet
 27386                                  
 27387                                  	; MSDOS 6.0
 27388                                  	;mov	ax,ExtOpen shl 8	; open the file
 27389                                  	; 26/03/2023
 27390 00003B0F B8006C                  	mov	ax,6C00h
 27391                                  ;M046
 27392                                  ; For reads, the sharing mode should be deny none so that any process can
 27393                                  ;open this file again in any other sharing mode. This is mainly to allow
 27394                                  ;multiple command.com's to access the same file without getting sharing
 27395                                  ;violations
 27396                                  ;
 27397                                  	;mov	bx,deny_none|read_open_mode
 27398 00003B12 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27399 00003B15 31C9                    	xor	cx,cx			; no special files
 27400                                  	;mov	dx,read_open_flag	; set up open flags
 27401 00003B17 BA0101                  	mov	dx,101h
 27402 00003B1A CD21                    	int	21h
 27403                                  	; 26/03/2023
 27404 00003B1C 7230                    	jc	short Error_On_Source
 27405                                  	;jnc	short OPENOK
 27406                                  
 27407                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27408                                  	;	They asked for it...
 27409                                  
 27410                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27411                                  
 27412                                  	; 26/03/2023
 27413                                  	; MSDOS 3.3
 27414                                  	;mov	dx,SRCBUF
 27415                                  	;mov	ax,OPEN*256 ; 3D00h
 27416                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27417                                  	;			; DS:DX	-> ASCIZ filename
 27418                                  	;			; AL = access mode
 27419                                  	;			; 0 - read
 27420                                  	;jnc	short OPENOK
 27421                                  	;call	GET_EXT_ERR_NUMBER
 27422                                  	;pushf
 27423                                  	;cmp	ax,65
 27424                                  	;jnz	short DOCOPY_ERR
 27425                                  	;mov	dx,ACCDENPTR
 27426                                  	;call	STD_PRINTF
 27427                                  ;DOCOPY_ERR:
 27428                                  	;popf
 27429                                  	;retn
 27430                                  
 27431                                  	; 26/03/2023
 27432                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27433                                  OPENOK:
 27434 00003B1E 89C3                    	mov	bx,ax
 27435 00003B20 891E[0B8D]              	mov	[SRCHAND],bx		; save handle
 27436 00003B24 B80057                  	mov	ax,File_Times*256 ; 5700h
 27437 00003B27 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27438                                  				; BX = file handle
 27439                                  
 27440 00003B29 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 27441                                  
 27442 00003B2B 8916[708D]              	mov	[CPDATE],dx		; save date
 27443 00003B2F 890E[728D]              	mov	[CPTIME],cx		; save time
 27444                                  
 27445                                  	; MSDOS 6.0
 27446                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27447                                  	; 26/04/2023
 27448                                  No_Copy_Xa:
 27449                                  	; 26/03/2023
 27450                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27451                                  
 27452                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27453 00003B33 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27454 00003B36 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27455                                  				; BX = file or device handle
 27456                                  	;and	dl,devid_ISDEV ; 80h
 27457                                  	; 18/04/2023
 27458 00003B38 80E280                  	and	dl,80h ; devid_ISDEV
 27459 00003B3B 8816[0D8D]              	mov	[SRCISDEV],dl		; set source info
 27460 00003B3F 7436                    	jz	short COPYLP		; source not a device
 27461 00003B41 803E[698D]00            	cmp	byte [BINARY],0
 27462 00003B46 742F                    	je	short COPYLP		; ascii device ok
 27463 00003B48 BA[7F80]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27464 00003B4B E92703                  	jmp	COPYERR
 27465                                  
 27466                                  Error_On_Source:			;AN022; we have a BAD error
 27467 00003B4E E88FE1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27468 00003B51 C706[358C][B48C]        	mov	word [string_ptr_2],SrcBuf
 27469                                  				;AN022; get address of failed string
 27470 00003B57 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27471                                  				;AN022; put number of subst in control block
 27472 00003B5C E88812                  	call	std_eprintf		;AN022; print it
 27473                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27474 00003B5F 8B1E[0B8D]              	mov	bx,[SRCHAND]
 27475                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27476                                  	;je	short No_Close_Src	;AN022; no - don't close
 27477 00003B63 09DB                    	or	bx,bx
 27478 00003B65 7403                    	jz	short No_Close_Src
 27479                                  	;call	CLOSESRC		;AN022; clean up
 27480                                  	; 26/03/2023
 27481 00003B67 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27482                                  No_Close_Src:				;AN022;
 27483 00003B6A 803E[E48A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27484 00003B6F 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27485 00003B71 E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27486                                  EndCopyJ3:				;AN022;
 27487 00003B74 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27488                                  
 27489                                  	; 26/04/2023
 27490                                  ;No_Copy_Xa:
 27491                                  ;	; 26/03/2023
 27492                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27493                                  ;
 27494                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27495                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27496                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27497                                  ;				; BX = file or device handle
 27498                                  ;	;and	dl,devid_ISDEV ; 80h
 27499                                  ;	; 18/04/2023
 27500                                  ;	and	dl,80h ; devid_ISDEV
 27501                                  ;	mov	[SRCISDEV],dl		; set source info
 27502                                  ;	jz	short COPYLP		; source not a device
 27503                                  ;	cmp	byte [BINARY],0
 27504                                  ;	je	short COPYLP		; ascii device ok
 27505                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27506                                  ;	jmp	COPYERR
 27507                                  
 27508                                  COPYLP:
 27509                                  	; 26/03/2023
 27510 00003B77 8B1E[0B8D]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27511 00003B7B 8B0E[E68A]              	mov	cx,[BYTCNT]
 27512 00003B7F 8B16[E88A]              	mov	dx,[NXTADD]
 27513 00003B83 29D1                    	sub	cx,dx			; compute available space
 27514 00003B85 750E                    	jnz	short GOTROOM
 27515 00003B87 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27516                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27517 00003B8A 803E[6C8D]00            	cmp	byte [TERMREAD],0
 27518 00003B8F 7565                    	jne	short CLOSESRC		; give up
 27519 00003B91 8B0E[E68A]              	mov	cx,[BYTCNT]
 27520                                  GOTROOM:
 27521 00003B95 1E                      	push	ds
 27522 00003B96 8E1E[C78A]              	mov	ds,[TPA]
 27523 00003B9A B43F                    	mov	ah,READ ; 3Fh
 27524 00003B9C CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27525                                  				; BX = file handle,CX = number of bytes to read
 27526                                  				; DS:DX	-> buffer
 27527 00003B9E 1F                      	pop	ds
 27528                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27529                                  	; 26/03/2023
 27530 00003B9F 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27531 00003BA1 89C1                    	mov	cx,ax			; get count
 27532 00003BA3 E351                    	jcxz	CLOSESRC		; no more to read
 27533 00003BA5 803E[0D8D]00            	cmp	byte [SRCISDEV],0
 27534 00003BAA 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27535 00003BAC 803E[6D8D]00            	cmp	byte [ASCII],0
 27536 00003BB1 741B                    	je	short BINREAD
 27537                                  NOTESTA:
 27538 00003BB3 89CA                    	mov	dx,cx
 27539 00003BB5 8B3E[E88A]              	mov	di,[NXTADD]
 27540 00003BB9 B01A                    	mov	al,1Ah
 27541 00003BBB 06                      	push	es
 27542 00003BBC 8E06[C78A]              	mov	es,[TPA]		; scan for EOF
 27543 00003BC0 F2AE                    	repne	scasb
 27544 00003BC2 07                      	pop	es
 27545 00003BC3 7505                    	jnz	short USEALL
 27546 00003BC5 FE06[D88A]              	inc	byte [RDEOF]
 27547 00003BC9 41                      	inc	cx
 27548                                  USEALL:
 27549 00003BCA 29CA                    	sub	dx,cx
 27550 00003BCC 89D1                    	mov	cx,dx
 27551                                  BINREAD:
 27552 00003BCE 030E[E88A]              	add	cx,[NXTADD]
 27553 00003BD2 890E[E88A]              	mov	[NXTADD],cx
 27554 00003BD6 3B0E[E68A]              	cmp	cx,[BYTCNT]		; is buffer full?
 27555 00003BDA 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27556                                  	; 26/03/2023
 27557 00003BDC E85901                  	call	FlshFil
 27558                                  	;call	FLUSHFIL
 27559 00003BDF 803E[6C8D]00            	cmp	byte [TERMREAD],0
 27560 00003BE4 7510                    	jne	short CLOSESRC		; give up
 27561 00003BE6 EB8F                    	jmp	short COPYLP
 27562                                  TESTDEV:
 27563 00003BE8 803E[0D8D]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27564 00003BED 7407                    	je	short CLOSESRC
 27565 00003BEF 803E[D88A]00            	cmp	byte [RDEOF],0
 27566 00003BF4 7481                    	je	short COPYLP		; on device, go till ^Z
 27567                                  CLOSESRC:
 27568 00003BF6 8B1E[0B8D]              	mov	bx,[SRCHAND]
 27569                                  CLOSESRC2:
 27570 00003BFA B43E                    	mov	ah,CLOSE ; 3Eh
 27571 00003BFC CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27572                                  				; BX = file handle
 27573                                  CLOSESRCDEST_RETN:
 27574 00003BFE C3                      	retn
 27575                                  
 27576                                  ; ---------------------------------------------------------------------------
 27577                                  
 27578                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27579                                  CLOSEDEST:
 27580                                  
 27581                                  	;	We are called to close the destination.
 27582                                  	;	We need to note whether or not there is any internal data left
 27583                                  	;	to be flushed out.
 27584                                  
 27585 00003BFF 803E[E58A]00            	cmp	byte [DestClosed],0
 27586 00003C04 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27587 00003C06 A0[E08A]                	mov	al,[DestSwitch]
 27588 00003C09 E8C502                  	call	SETASC			; check for b or a switch
 27589 00003C0C 742E                    	jz	short BINCLOS		;   on destination
 27590 00003C0E 8B1E[E88A]              	mov	bx,[NXTADD]
 27591                                  ;
 27592                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27593                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27594                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27595                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27596                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27597                                  ;performance overhead on single ASCII file copies which now always involve
 27598                                  ;2 writes instead of 1 before. Is this really that important?
 27599                                  ;
 27600                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27601                                  ;M048;	jne	short PutZ
 27602                                  
 27603                                  	; 26/03/2023
 27604                                  	; MSDOS 3.3
 27605                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27606                                  	;jne	short PUTZ
 27607                                  
 27608                                  	; 26/03/2023
 27609 00003C12 E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27610 00003C15 7402                    	jz	short NOCONC
 27611                                  CONCHNG:
 27612 00003C17 F9                      	stc
 27613 00003C18 C3                      	retn
 27614                                  
 27615                                  NOCONC:	
 27616 00003C19 31DB                    	xor	bx,bx
 27617                                  PUTZ:
 27618 00003C1B 1E                      	push	ds
 27619 00003C1C 8E1E[C78A]              	mov	ds,[TPA]
 27620 00003C20 C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27621 00003C24 1F                      	pop	ds
 27622 00003C25 FF06[E88A]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27623 00003C29 C606[688D]00            	mov	byte [NOWRITE],0
 27624 00003C2E A1[6A8D]                	mov	ax,[WRITTEN]
 27625 00003C31 0306[E88A]              	add	ax,[NXTADD]
 27626 00003C35 7205                    	jc	short BINCLOS	; > 1
 27627 00003C37 83F801                  	cmp	ax,1
 27628 00003C3A 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27629                                  BINCLOS:
 27630 00003C3C E8EC00                  	call	TRYFLUSH
 27631 00003C3F 75D6                    	jnz	short CONCHNG
 27632                                  
 27633                                  	; 26/04/2023
 27634 00003C41 833E[6A8D]00            	cmp	word [WRITTEN],0
 27635                                  	; 26/03/2023
 27636 00003C46 7503                    	jnz	short NO_FORGET
 27637                                  FORGETITJ:
 27638                                  	;jz	short FORGETIT	; never wrote nothing
 27639                                  	; 26/03/2023
 27640 00003C48 E98500                  	jmp	FORGETIT ; 18/04/2023
 27641                                  NO_FORGET:			; wrote something
 27642 00003C4B 8B1E[A88C]              	mov	bx,[DESTHAND]
 27643 00003C4F 8B0E[728D]              	mov	cx,[CPTIME]
 27644 00003C53 8B16[708D]              	mov	dx,[CPDATE]
 27645 00003C57 803E[678D]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27646 00003C5C 7431                    	je	short DODCLOSE	; if no, copy date & time
 27647 00003C5E B42C                    	mov	ah,Get_Time ; 2Ch
 27648 00003C60 CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27649                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27650                                  				; DL = hundredths of seconds
 27651 00003C62 D0E1                    	shl	cl,1
 27652 00003C64 D0E1                    	shl	cl,1		; left justify min in cl
 27653 00003C66 D1E1                    	shl	cx,1
 27654 00003C68 D1E1                    	shl	cx,1
 27655 00003C6A D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27656 00003C6C D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27657 00003C6E 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27658 00003C70 51                      	push	cx		; save packed time
 27659 00003C71 B42A                    	mov	ah,Get_Date ; 2Ah
 27660 00003C73 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27661                                  				; Return: DL = day,DH = month,	CX = year
 27662                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27663 00003C75 81E9BC07                	sub	cx,1980
 27664 00003C79 86E9                    	xchg	ch,cl
 27665 00003C7B D1E1                    	shl	cx,1		; year to high 7 bits
 27666 00003C7D D0E6                    	shl	dh,1		; month to high 3 bits
 27667 00003C7F D0E6                    	shl	dh,1
 27668 00003C81 D0E6                    	shl	dh,1
 27669 00003C83 D0E6                    	shl	dh,1
 27670 00003C85 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27671 00003C87 80D500                  	adc	ch,0		; put that bit next to year
 27672 00003C8A 08F2                    	or	dl,dh		; or low three of month into day
 27673 00003C8C 88EE                    	mov	dh,ch		; get year and high bit of month
 27674 00003C8E 59                      	pop	cx
 27675                                  DODCLOSE:
 27676 00003C8F 83FB00                  	cmp	bx,0
 27677 00003C92 7E36                    	jle	short CLOSEDONE
 27678 00003C94 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27679 00003C97 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27680                                  				; BX = file handle,CX = time to be set
 27681                                  				; DX = date to be set
 27682                                  	; 26/03/2023
 27683                                  	; MSDOS 6.0
 27684 00003C99 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27685                                  
 27686                                  	;	See if the destination has *anything* in it.
 27687                                  	;	If not, just close and delete it.
 27688                                  
 27689 00003C9B B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27690 00003C9E 31D2                    	xor	dx,dx
 27691 00003CA0 89D1                    	mov	cx,dx
 27692 00003CA2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27693                                  			; AL = method: offset from end of file
 27694                                  	;	DX:AX is file size
 27695                                  
 27696 00003CA4 09C2                    	or	dx,ax
 27697 00003CA6 9C                      	pushf
 27698 00003CA7 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27699 00003CAA CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27700                                  			; BX = file or device handle
 27701 00003CAC 52                      	push	dx		; save them away
 27702 00003CAD B43E                    	mov	ah,CLOSE ; 3Eh
 27703 00003CAF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27704                                  			; BX = file handle
 27705 00003CB1 5A                      	pop	dx
 27706                                  
 27707                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27708                                  	; MSDOS 6.0
 27709 00003CB2 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27710 00003CB4 9D                      	popf			;AN022; get the flags back
 27711                                  Cleanup_Err: 			;AN022;
 27712 00003CB5 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27713                                  	; 26/03/2023
 27714                                  	;call	DestDelete	;AN022; attempt to delete the target
 27715                                  	;jmp	short FILECLOSED
 27716                                  	;			;AN022; close the file
 27717                                  	; 26/03/2023
 27718                                  DestDel_fclosed:
 27719 00003CB8 E82700                  	call	DestDelete
 27720                                  FILECLOSED:
 27721 00003CBB FE06[E58A]              	inc	byte [DestClosed]
 27722                                  RET50:
 27723 00003CBF F8                      	clc
 27724 00003CC0 C3                      	retn
 27725                                  	
 27726                                  Close_Cont:			;AN022; no error - co
 27727                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27728 00003CC1 9D                      	popf
 27729 00003CC2 7506                    	jnz	short CLOSEDONE
 27730 00003CC4 F7C28000                	test	dx,80h		; is the destination a device?
 27731                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27732                                  	;call	DestDelete
 27733                                  	;jmp	short FILECLOSED
 27734                                  	; 26/03/2023
 27735 00003CC8 74EE                    	jz	short DestDel_fclosed
 27736                                  CLOSEDONE:
 27737 00003CCA FF06[F18A]              	inc	word [FileCnt]
 27738                                  	; 26/03/2023
 27739 00003CCE EBEB                    	jmp	short FILECLOSED
 27740                                  	
 27741                                  ;FILECLOSED:
 27742                                  ;	inc	byte [DestClosed]
 27743                                  ;RET50:
 27744                                  	;clc
 27745                                  	;retn
 27746                                  
 27747                                  FORGETIT:
 27748 00003CD0 8B1E[A88C]              	mov	bx,[DESTHAND]
 27749 00003CD4 E8B8FF                  	call	DODCLOSE	 ; close the dest	
 27750 00003CD7 E80800                  	call	DestDelete
 27751 00003CDA C706[F18A]0000          	mov	word [FileCnt],0 ; no files transferred
 27752 00003CE0 EBDD                    	jmp	short RET50
 27753                                  
 27754                                  ; ---------------------------------------------------------------------------
 27755                                  
 27756                                  	; 26/03/2023
 27757                                  DestDelete:
 27758 00003CE2 BA[518C]                	mov	dx,DestBuf
 27759 00003CE5 B441                    	mov	ah,Unlink ; 41h
 27760 00003CE7 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27761                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27762                                  			;		(no wildcards allowed)
 27763 00003CE9 C3                      	retn
 27764                                  
 27765                                  ; ---------------------------------------------------------------------------
 27766                                  
 27767                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27768                                  SOURCE_SET:
 27769 00003CEA 56                      	push	si
 27770 00003CEB A1[7B8D]                	mov	ax,[STARTEL]
 27771 00003CEE BE[0E8D]                	mov	si,ScanBuf	; adjust to copy
 27772 00003CF1 29F0                    	sub	ax,si
 27773 00003CF3 BF[B48C]                	mov	di,SrcBuf
 27774 00003CF6 01F8                    	add	ax,di
 27775 00003CF8 A3[B18C]                	mov	[SrcTail],ax
 27776 00003CFB 880E[B08C]              	mov	[SrcSiz],cl	; save its size
 27777 00003CFF 41                      	inc	cx		; include the nul
 27778 00003D00 F3A4                    	rep	movsb		; save this source
 27779 00003D02 883E[B38C]              	mov	[SrcInfo],bh	; save info about it
 27780 00003D06 5E                      	pop	si
 27781 00003D07 89E8                    	mov	ax,bp		; switches so far
 27782 00003D09 E8C501                  	call	SETASC		; set a,b switches accordingly
 27783 00003D0C E86DEA                  	call	SWITCH		; get any more switches on this arg
 27784                                  	;call	SETASC		; set
 27785                                  	;retn
 27786                                  	; 26/03/2023
 27787 00003D0F E9BF01                  	jmp	SETASC
 27788                                  
 27789                                  ; =============== S U B	R O U T	I N E =======================================
 27790                                  
 27791                                  ; MSDOS 6.0
 27792                                  
 27793                                  ;****************************************************************
 27794                                  ;*
 27795                                  ;* ROUTINE:	CleanupErr
 27796                                  ;*
 27797                                  ;* FUNCTION:	Issues extended error message for destination
 27798                                  ;*		if not alreay issued
 27799                                  ;*
 27800                                  ;* INPUT:	return from INT 21
 27801                                  ;*
 27802                                  ;* OUTPUT:	none
 27803                                  ;*
 27804                                  ;****************************************************************
 27805                                  
 27806                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27807                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27808                                  CleanUpErr:	; proc	near		;AN022;
 27809                                  
 27810 00003D12 803E[B78D]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27811 00003D17 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27812 00003D19 E8C4DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27813 00003D1C C706[358C][518C]        	mov	word [string_ptr_2],DestBuf 
 27814                                  					;AN022; get address of failed string
 27815 00003D22 C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27816                                  					;AN022; put number of subst in control block
 27817 00003D27 E8BD10                  	call	std_eprintf		;AN022; issue the error message
 27818                                  CleanupErr_Cont:			;AN022;
 27819 00003D2A C3                      	retn				;AN022; return to caller
 27820                                  
 27821                                  ;CleanUpErr	endp			;AN022;
 27822                                  
 27823                                  ;============================================================================
 27824                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27825                                  ;============================================================================
 27826                                  ; 01/10/2018 - Retro DOS v3.0
 27827                                  
 27828                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27829                                  
 27830                                  ; =============== S U B	R O U T	I N E =======================================
 27831                                  
 27832                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27833                                  ;
 27834                                  ;	EXIT	ZR set if concatenate flag unchanged
 27835                                  
 27836                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27837                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27838                                  TRYFLUSH:
 27839 00003D2B A0[DA8A]                	mov	al,[Concat]
 27840 00003D2E 50                      	push	ax
 27841                                  	;call	FLUSHFIL
 27842 00003D2F E80600                  	call	FlshFil
 27843 00003D32 58                      	pop	ax
 27844 00003D33 3A06[DA8A]              	cmp	al,[Concat]
 27845 00003D37 C3                      	retn
 27846                                  
 27847                                  ; =============== S U B	R O U T	I N E =======================================
 27848                                  
 27849                                  	; 26/03/2023
 27850                                  	; MSDOS 3.3
 27851                                  ;FLUSHFIL:
 27852                                  	;mov	al,[BINARY]
 27853                                  	;mov	ah,[ASCII]
 27854                                  	;push	ax
 27855                                  	;call	FLSHFIL
 27856                                  	;pop	ax
 27857                                  	;mov	[ASCII],ah
 27858                                  	;mov	[BINARY],al
 27859                                  	;retn
 27860                                  
 27861                                  ; =============== S U B	R O U T	I N E =======================================
 27862                                  
 27863                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27864                                  ;
 27865                                  ;	Inputs:
 27866                                  ;	  [NXTADD] = No. of bytes to write
 27867                                  ;	  [CFLAG] <> 0 if file has been created
 27868                                  ;	Outputs:
 27869                                  ;	  [NXTADD] = 0
 27870                                  
 27871                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27872                                  FlshFil:
 27873 00003D38 C606[6C8D]00            	mov	byte [TERMREAD],0
 27874 00003D3D 803E[E48A]00            	cmp	byte [CFLAG],0
 27875 00003D42 7403                    	jz	short NotExists
 27876 00003D44 E99600                  	jmp	Exists
 27877                                  NotExists:
 27878 00003D47 E8A101                  	call	BUILDDEST		; find out all about the destination
 27879 00003D4A E8F903                  	call	COMPNAME		; source and dest. the same?
 27880 00003D4D 7519                    	jnz	short ProcDest		; if not, go ahead
 27881 00003D4F 803E[0D8D]00            	cmp	byte [SRCISDEV],0
 27882 00003D54 7512                    	jnz	short ProcDest		; same name on device ok
 27883 00003D56 803E[DA8A]00            	cmp	byte [Concat],0		; concatenation?
 27884 00003D5B BA[447F]                	mov	dx,OVERWR_PTR
 27885                                  	;je	short COPERR		; not concatenating - overwrite error
 27886                                  	; 26/03/2023
 27887 00003D5E 7503                    	jne	short No_Concat_Err
 27888 00003D60 E91201                  	jmp	COPYERR
 27889                                  	
 27890                                  No_Concat_Err:	; concatenating
 27891 00003D63 C606[688D]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27892                                  ProcDest:
 27893                                  	; MSDOS 6.0
 27894                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27895                                  	; 26/03/2023
 27896 00003D68 B8006C                  	mov	ax,6C00h
 27897 00003D6B BE[518C]                	mov	si,DestBuf		; get file name
 27898                                  ;M046
 27899                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27900                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27901                                  ;writing to the same file. Also, because we opened the source file with
 27902                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27903                                  ;would happen when we append to an existing file.
 27904                                  
 27905                                  	; 26/03/2023
 27906                                  	;mov	bx,deny_write|write_open_mode
 27907 00003D6E BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27908 00003D71 31C9                    	xor	cx,cx			; no special files
 27909                                  	;mov	dx,write_open_flag	; set up open flags
 27910 00003D73 BA0101                  	mov	dx,101h	
 27911                                  
 27912 00003D76 803E[688D]00            	cmp	byte [NOWRITE],0
 27913 00003D7B 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27914                                  	;mov	dx,creat_open_flag	; set up create flags
 27915 00003D7D BA1201                  	mov	dx,112h
 27916                                  
 27917                                  	; 26/03/2023
 27918                                  	; MSDOS 3.3
 27919                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27920                                  	;cmp	byte [NOWRITE],0
 27921                                  	;jne	short DODESTOPEN
 27922                                  	;mov	ah,CREAT ; 3Ch
 27923                                  	;xor	cx,cx
 27924                                  ;DODESTOPEN:
 27925                                  	;mov	dx,DESTBUF
 27926                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27927                                  	;		; CX = attributes for file
 27928                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27929                                  
 27930                                  ; 26/03/2023
 27931                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27932                                  ;	;mov	dx,FULDIRPTR
 27933                                  ;	;call	GET_EXT_ERR_NUMBER
 27934                                  ;	;jc	short COPERR
 27935                                  ;
 27936                                  ;	; 01/10/2018
 27937                                  ;	;jnc	short DEST_OPEN_OKAY
 27938                                  ;		
 27939                                  ;	;mov	dx,FULDIRPTR
 27940                                  ;	;call	GET_EXT_ERR_NUMBER
 27941                                  ;	;jmp	short COPERR
 27942                                  ;
 27943                                  ;	jc	short DEST_OPEN_ERROR
 27944                                  
 27945                                  	; 26/03/2023
 27946                                  DoDestOpen:
 27947 00003D80 CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27948                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27949                                  			; BH = flags
 27950                                  			; CX = create attribute
 27951                                  			; DL = action if file exists/does not exists
 27952                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27953                                  
 27954                                  ;	We assume that the error is normal.
 27955                                  ;	TriageError will correct the DX value appropriately.
 27956                                  	
 27957 00003D82 7311                    	jnc	short Dest_Open_Okay
 27958                                  Xa_Set_Error:				;AN030; error occurred on XA
 27959 00003D84 E859DF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27960                                  
 27961                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27962                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27963                                  Ext_Err_Set:				;AN030;
 27964 00003D87 C706[358C][518C]        	mov	word [string_ptr_2],DestBuf
 27965                                  					;AN000; get address of failed string
 27966 00003D8D C606[1D7F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27967                                  					;AN030; put number of subst in control block
 27968                                  CopErrJ2:				;AN030;
 27969 00003D92 E9E000                  	jmp	COPYERR			;AN030; go issue message
 27970                                  
 27971                                  ;DEST_OPEN_OKAY:
 27972                                  	; 26/03/2023
 27973                                  Dest_Open_Okay:
 27974 00003D95 A3[A88C]                	mov	[DESTHAND],ax		; save handle
 27975 00003D98 C606[E48A]01            	mov	byte [CFLAG],1		; destination now exists
 27976 00003D9D 89C3                    	mov	bx,ax
 27977 00003D9F B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 27978 00003DA2 CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 27979                                  			   	; BX = file or device handle
 27980                                  
 27981 00003DA4 8816[AA8C]              	mov	[DESTISDEV],dl		; set dest info
 27982                                  	; 18/04/2023
 27983 00003DA8 F6C280                  	test	dl,80h
 27984                                  	;test	dl,devid_ISDEV
 27985 00003DAB 7430                    	jz	short Exists		; Dest not a device
 27986                                  
 27987                                  ;	Destination is device.
 27988                                  
 27989 00003DAD A0[E08A]                	mov	al,[DestSwitch]
 27990                                  	; 26/03/2023
 27991 00003DB0 240C                    	and	al,0Ch
 27992                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 27993 00003DB2 7509                    	jnz	short TestBoth
 27994 00003DB4 A0[6D8D]                	mov	al,[ASCII]		; neither set, use current setting
 27995 00003DB7 0A06[698D]              	or	al,[BINARY]
 27996 00003DBB 7416                    	jz	short ExSetA		; neither set, default to ascii
 27997                                  TestBoth:
 27998 00003DBD 7A1E                    	jpe	short Exists		; both are set, ignore
 27999 00003DBF A808                    	test	al,8
 28000                                  	;test	al,SWITCHB
 28001 00003DC1 741A                    	jz	short Exists
 28002                                  	;mov	ax,(IOCTL shl 8) or 1
 28003 00003DC3 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28004 00003DC6 30F6                    	xor	dh,dh
 28005                                  	; 18/04/2023
 28006 00003DC8 80CA20                  	or	dl,20h
 28007                                  	;or	dl,devid_RAW
 28008 00003DCB 8816[AA8C]              	mov	[DESTISDEV],dl
 28009 00003DCF CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28010                                  			; BX = device handle,DH = 0
 28011                                  			; DL = device information to set (bits 0-7 from	function 0)
 28012 00003DD1 EB0A                    	jmp	short Exists
 28013                                  
 28014                                  	; 26/03/2023
 28015                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28016                                  ;DEST_OPEN_ERROR:
 28017                                  	;mov	dx,FULDIRPTR
 28018                                  	;call	GET_EXT_ERR_NUMBER
 28019                                  ;COPERR:
 28020                                  	; 26/03/2023
 28021                                  ;CopyErrj:
 28022                                  	;jmp	short COPYERR
 28023                                  
 28024                                  ExSetA:
 28025                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28026                                  
 28027 00003DD3 C606[6D8D]04            	mov	byte [ASCII],4
 28028                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28029 00003DD8 800E[678D]04            	or	byte [INEXACT],4
 28030                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28031                                  Exists:
 28032 00003DDD 803E[688D]00            	cmp	byte [NOWRITE],0
 28033 00003DE2 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28034 00003DE4 803E[2B8C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28035 00003DE9 741D                    	jz	short NoChecking
 28036 00003DEB E85803                  	call	COMPNAME		; source and dest. the same?
 28037 00003DEE 7518                    	jnz	short NoChecking	; if not, go ahead
 28038 00003DF0 803E[0D8D]00            	cmp	byte [SRCISDEV],0
 28039 00003DF5 7511                    	jne	short NoChecking	; same name on device ok
 28040                                  
 28041                                  ;	At this point we know in append (would have gotten overwrite error
 28042                                  ;	on first destination create otherwise), and user trying to specify
 28043                                  ;	destination which has been scribbled already (if dest had been named
 28044                                  ;	first, NoWrite would be set).
 28045                                  
 28046 00003DF7 BA[477F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28047                                  	;invoke	Std_EprintF		;ac022;
 28048                                  	; 26/03/2023
 28049 00003DFA E8EA0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28050                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28051 00003DFD C706[E88A]0000          	mov	word [NXTADD],0		; set return
 28052 00003E03 FE06[6C8D]              	inc	byte [TERMREAD]		; tell read to give up
 28053                                  Ret60:
 28054 00003E07 C3                      	retn
 28055                                  
 28056                                  NoChecking:
 28057 00003E08 8B1E[A88C]              	mov	bx,[DESTHAND]		; get handle
 28058 00003E0C 31C9                    	xor	cx,cx
 28059 00003E0E 870E[E88A]              	xchg	cx,[NXTADD]
 28060 00003E12 E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28061 00003E14 FF06[6A8D]              	inc	word [WRITTEN]		; flag that we wrote something
 28062 00003E18 803E[688D]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28063 00003E1D 7514                    	jnz	short SeekEnd
 28064 00003E1F 31D2                    	xor	dx,dx
 28065 00003E21 1E                      	push	ds
 28066 00003E22 8E1E[C78A]              	mov	ds,[TPA]
 28067 00003E26 B440                    	mov	ah,Write ; 40h
 28068 00003E28 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28069                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28070 00003E2A 1F                      	pop	ds
 28071 00003E2B BA[2F7F]                	mov	dx,NOSPACE_PTR
 28072                                  	;jc	short COPERRP		; failure
 28073                                  	; 26/03/2023
 28074                                  	; MSDOS 6.0
 28075 00003E2E 7326                    	jnc	short NoChecking2
 28076 00003E30 E951FF                  	jmp	Xa_Set_Error
 28077                                  
 28078                                  	; 18/04/2023
 28079                                  	; 26/03/2023
 28080                                  SeekEnd:
 28081 00003E33 31D2                    	xor	dx,dx
 28082 00003E35 87D1                    	xchg	dx,cx
 28083                                  	;mov	ax,(LSEEK shl 8) or 1
 28084 00003E37 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28085 00003E3A CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28086                                  				; AL = method: offset from present location
 28087                                  
 28088                                  	; 26/03/2023
 28089                                  	; MSDOS 6.0
 28090                                  
 28091                                  ;	Save the file pointer in DX:AX to restore the file
 28092                                  ;	with in case the copy should fail.
 28093                                  
 28094 00003E3C A3[748D]                	mov	[OFilePtr_Lo],ax
 28095 00003E3F 8916[768D]              	mov	[OFilePtr_Hi],dx
 28096                                  
 28097                                  	; 26/03/2023
 28098                                  	; MSDOS 3.3  MSDOS 6.0
 28099                                  
 28100 00003E43 803E[D88A]00            	cmp	byte [RDEOF],0
 28101 00003E48 740B                    	jz	short Retz60
 28102                                  
 28103                                  ;	^Z has been read - we must set the file size to the current
 28104                                  ;	file pointer location
 28105                                  
 28106 00003E4A B440                    	mov	ah,Write ; 40h
 28107 00003E4C CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28108                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28109                                  
 28110                                  	; 26/03/2023
 28111                                  	; MSDOS 6.0
 28112 00003E4E 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28113                                  
 28114                                  ;	Make note that ^Z was removed, in case the
 28115                                  ;	copy should fail and we need to restore the file.
 28116                                  
 28117 00003E50 C606[788D]1A            	mov	byte [OCtrlZ],1Ah
 28118                                  Retz60:
 28119 00003E55 C3                      	retn
 28120                                  
 28121                                  NoChecking2:
 28122 00003E56 29C1                    	sub	cx,ax
 28123 00003E58 74AD                    	jz	short Ret60		; wrote all supposed to
 28124                                  	; 18/04/2023
 28125 00003E5A F606[AA8C]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28126                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28127 00003E5F 7414                    	jz	short COPYERR		; is a file, error
 28128 00003E61 F606[AA8C]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28129                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28130 00003E66 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28131 00003E68 803E[678D]00            	cmp	byte [INEXACT],0
 28132 00003E6D 7598                    	jnz	short Ret60		; inexact so ok
 28133 00003E6F 49                      	dec	cx
 28134                                  ;Retz60:
 28135 00003E70 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 28136                                  
 28137                                  DevWrtErr:
 28138 00003E72 BA[B280]                	mov	dx,DEVWMES_PTR
 28139                                  	; 26/03/2023
 28140                                  COPYERR:
 28141                                  	;invoke	Std_EPrintF		;AC022;
 28142 00003E75 E86F0F                  	call	std_eprintf  ; MSDOS 6.0
 28143                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28144                                  CopErrP:
 28145 00003E78 FE06[E58A]              	inc	byte [DestClosed]
 28146 00003E7C 803E[E48A]00            	cmp	byte [CFLAG],0
 28147 00003E81 7448                    	jz	short EndCopyJ		; never actually got it open
 28148 00003E83 8B1E[A88C]              	mov	bx,[DESTHAND]
 28149 00003E87 83FB00                  	cmp	bx,0
 28150 00003E8A 7E33                    	jle	short NoClose
 28151                                  
 28152                                  ;	Check to see if we should save part of the destination file.
 28153                                  
 28154                                  	; 26/03/2023
 28155                                  	; MSDOS 6.0
 28156 00003E8C 8B0E[768D]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 28157 00003E90 8B16[748D]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 28158                                  			
 28159 00003E94 89C8                    	mov	ax,cx
 28160 00003E96 09D0                    	or	ax,dx
 28161 00003E98 7421                    	jz	short ceClose		; null file ptr means nothing to save
 28162                                  
 28163                                  ;	Destination was also the first source. Do the best we can to
 28164                                  ;	restore it. Truncate it back to the size we took from it (which
 28165                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 28166                                  ;	file). If a Ctrl-Z was originally read, put it back.
 28167                                  
 28168 00003E9A B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 28169 00003E9D CD21                    	int	21h
 28170                                  
 28171 00003E9F 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 28172 00003EA1 B440                    	mov	ah,Write ; 40h
 28173 00003EA3 CD21                    	int	21h			; truncate file
 28174                                  
 28175 00003EA5 803E[788D]00            	cmp	byte [OCtrlZ],0
 28176 00003EAA 7408                    	je	short ceClose0		; no ctrl-z removed from original
 28177 00003EAC 41                      	inc	cx			; CX = # bytes to write = 1
 28178 00003EAD BA[788D]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 28179 00003EB0 B440                    	mov	ah,Write ; 40h
 28180 00003EB2 CD21                    	int	21h			; write ctrl-z
 28181                                  ceClose0:
 28182 00003EB4 B43E                    	mov	ah,CLOSE ; 3Eh
 28183 00003EB6 CD21                    	int	21h			; close it
 28184                                  ;;	;mov	byte [CFLAG],0
 28185 00003EB8 E980FA                  	jmp	ENDCOPY			; and go home
 28186                                  
 28187                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28188                                  ceClose:
 28189 00003EBB B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 28190 00003EBD CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28191                                  				; BX = file handle
 28192                                  NoClose:
 28193 00003EBF BA[518C]                	mov	dx,DestBuf
 28194 00003EC2 B441                    	mov	ah,Unlink ; 41h 	; and delete it
 28195 00003EC4 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 28196                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 28197 00003EC6 C606[E48A]00            	mov	byte [CFLAG],0
 28198                                  EndCopyJ:
 28199 00003ECB E96DFA                  	jmp	ENDCOPY
 28200                                  
 28201                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 28202 00003ECE E9B3FE                  	jmp	Xa_Set_Error
 28203                                  
 28204                                  ;============================================================================
 28205                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 28206                                  ;============================================================================
 28207                                  ; 01/10/2018 - Retro DOS v3.0
 28208                                  
 28209                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 28210                                  
 28211                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28212                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 28213                                  
 28214                                  ; =============== S U B	R O U T	I N E =======================================
 28215                                  
 28216                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 28217                                  ;
 28218                                  ;	Given switch vector in AX,
 28219                                  ;	  Set Ascii flag if /a is set
 28220                                  ;	  Clear Ascii flag if /b is set
 28221                                  ;	  Binary set if /b specified
 28222                                  ;	  Leave Ascii unchanged if neither or both are set
 28223                                  ; 	Also sets Inexact if Ascii is ever set. 
 28224                                  ;	AL = Ascii on exit, flags set
 28225                                  
 28226                                  	; 26/03/2023
 28227                                  SETASC:
 28228                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 28229 00003ED1 240C                    	and	al,0Ch ; 4+8
 28230 00003ED3 7A10                    	jpe	short LOADSW	; even parity - both or neither
 28231 00003ED5 50                      	push	ax
 28232                                  	;and	al,SWITCHB  ; 8
 28233 00003ED6 2408                    	and	al,8
 28234 00003ED8 A2[698D]                	mov	[BINARY],al
 28235 00003EDB 58                      	pop	ax
 28236                                  	;and	al,SWITCHA
 28237 00003EDC 2404                    	and	al,4	
 28238 00003EDE A2[6D8D]                	mov	[ASCII],al
 28239 00003EE1 0806[678D]              	or	[INEXACT],al
 28240                                  LOADSW:
 28241 00003EE5 A0[6D8D]                	mov	al,[ASCII]
 28242 00003EE8 08C0                    	or	al,al
 28243 00003EEA C3                      	retn
 28244                                  
 28245                                  ; =============== S U B	R O U T	I N E =======================================
 28246                                  
 28247                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28248                                  BUILDDEST:
 28249 00003EEB 803E[4C8C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 28250 00003EF0 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 28251 00003EF2 BF[A789]                	mov	di,USERDIR1
 28252 00003EF5 BD[4C8C]                	mov	bp,DestVars
 28253 00003EF8 E8DF00                  	call	BUILDPATH
 28254 00003EFB E883E5                  	call	RestUDir1
 28255                                  
 28256                                  ;	We now know all about the destination
 28257                                  
 28258                                  KNOWABOUTDEST:
 28259 00003EFE 30C0                    	xor	al,al
 28260 00003F00 8606[AB8C]              	xchg	al,[FIRSTDEST]
 28261 00003F04 08C0                    	or	al,al
 28262 00003F06 7503                    	jnz	short FIRSTDST
 28263 00003F08 E98C00                  	jmp	NOFIRSTDEST
 28264                                  
 28265                                  FIRSTDST:
 28266                                  ;	Create an fcb of the original dest.
 28267                                  
 28268 00003F0B 8B36[4E8C]              	mov	si,[DestTail]
 28269 00003F0F BF[8B8B]                	mov	di,DestFcb
 28270 00003F12 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 28271 00003F15 CD21                    	int	21h		; DOS -	PARSE FILENAME
 28272                                  				; DS:SI	-> string to parse
 28273                                  				; ES:DI	-> buffer to fill with unopened	FCB
 28274                                  				; AL = bit mask	to control parsing
 28275 00003F17 803C00                  	cmp	byte [si],0
 28276 00003F1A 7406                    	jz	short GOODPARSE
 28277                                  
 28278                                  	; 27/03/2023	
 28279                                  	; MSDOS 6.0
 28280                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 28281                                  	
 28282 00003F1C BA[357F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 28283 00003F1F E953FF                  	jmp	COPYERR			;AN052;
 28284                                  GOODPARSE:
 28285 00003F22 A1[518C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 28286 00003F25 80FC3A                  	cmp	ah,':'
 28287 00003F28 7402                    	jz	short DRVSPEC4
 28288 00003F2A B040                    	mov	al,'@'  ; 40h
 28289                                  DRVSPEC4:
 28290                                  ;	AX = "d:" for following FCB drive computation
 28291                                  
 28292 00003F2C 8A0E[6D8D]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 28293 00003F30 0C20                    	or	al,20h
 28294 00003F32 2C60                    	sub	al,60h
 28295 00003F34 A2[8B8B]                	mov	[DestFcb],al		; store drive # in FCB
 28296                                  
 28297                                  ;*	Figure out what copy mode we're in.
 28298                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 28299                                  ;	+n stands for additional sources delimited by +'s.
 28300                                  ;
 28301                                  ;	copy a b	not concatenating
 28302                                  ;	copy a *	not concatenating
 28303                                  ;	copy * a	concatenating
 28304                                  ;	copy * *	not concatenating
 28305                                  ;	copy a+n b	concatenating
 28306                                  ;	copy *+n a	concatenating
 28307                                  ;	copy *+n *	concatenating, Mel Hallerman style
 28308                                  
 28309                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28310                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28311                                  
 28312 00003F37 A0[508C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28313 00003F3A 8A26[B38C]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28314 00003F3E 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28315 00003F41 08C0                    	or	al,al
 28316 00003F43 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28317                                  
 28318                                  ;	Destination is wildcarded.
 28319                                  	
 28320 00003F45 38E0                    	cmp	al,ah
 28321 00003F47 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28322                                  
 28323                                  ;	Source and destination are both wildcarded.
 28324                                  
 28325 00003F49 803E[6E8D]00            	cmp	byte [PLUS],0
 28326 00003F4E 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28327                                  
 28328                                  ;	Source and destination are wildcarded, and source includes +'s.
 28329                                  ;	It's Mel Hallorman copy time.
 28330                                  
 28331 00003F50 FE06[AC8C]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28332 00003F54 30C0                    	xor	al,al
 28333 00003F56 EB06                    	jmp	short SETCONC
 28334                                  
 28335                                  NOTMELCOPY:
 28336 00003F58 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28337 00003F5A 20E0                    	and	al,ah
 28338 00003F5C D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28339                                  					;   (implies concatenation)
 28340                                  SETCONC:
 28341 00003F5E 0A06[6E8D]              	or	al,[PLUS]		; "+" always infers concatenation
 28342                                  
 28343                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28344                                  
 28345 00003F62 A2[DA8A]                	mov	[Concat],al
 28346 00003F65 D0E0                    	shl	al,1
 28347 00003F67 D0E0                    	shl	al,1
 28348 00003F69 A2[678D]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28349 00003F6C 803E[698D]00            	cmp	byte [BINARY],0
 28350 00003F71 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 28351                                  
 28352 00003F73 A2[6D8D]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode	
 28353 00003F76 08C9                    	or	cl,cl
 28354 00003F78 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 28355 00003F7A 08C0                    	or	al,al
 28356 00003F7C 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28357                                  
 28358                                  ;	At this point there may already be binary read data in the read
 28359                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28360                                  ;	amount of data in the buffer correctly.
 28361                                  
 28362 00003F7E 8B0E[E88A]              	mov	cx,[NXTADD]
 28363 00003F82 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28364 00003F84 B01A                    	mov	al,1Ah
 28365 00003F86 06                      	push	es
 28366 00003F87 31FF                    	xor	di,di
 28367 00003F89 8E06[C78A]              	mov	es,[TPA]
 28368 00003F8D F2AE                    	repne	scasb			; scan for EOF
 28369 00003F8F 07                      	pop	es
 28370 00003F90 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28371 00003F92 4F                      	dec	di			; point at ^z
 28372 00003F93 893E[E88A]              	mov	[NXTADD],di		; new buffer length
 28373                                  
 28374                                  NOFIRSTDEST:
 28375 00003F97 BB[CF8B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28376 00003F9A 803E[DA8A]00            	cmp	byte [Concat],0
 28377 00003F9F 7403                    	jz	short GOTCHRSRC		; Not a concat
 28378 00003FA1 BB[158C]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28379                                  GOTCHRSRC:
 28380 00003FA4 BE[8C8B]                	mov	si,DestFcb+1		; Original dest name
 28381 00003FA7 8B3E[4E8C]              	mov	di,[DestTail]		; Where to put result
 28382                                  
 28383                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28384                                  
 28385                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28386                                  BUILDNAME:
 28387 00003FAB B90800                  	mov	cx,8
 28388                                  BUILDMAIN:
 28389 00003FAE AC                      	lodsb
 28390 00003FAF 3C3F                    	cmp	al,'?'
 28391 00003FB1 7502                    	jne	short NOTAMBIG
 28392 00003FB3 8A07                    	mov	al,[bx]
 28393                                  NOTAMBIG:
 28394 00003FB5 3C20                    	cmp	al,' '
 28395 00003FB7 7401                    	je	short NOSTORE
 28396 00003FB9 AA                      	stosb
 28397                                  NOSTORE:
 28398 00003FBA 43                      	inc	bx
 28399 00003FBB E2F1                    	loop	BUILDMAIN
 28400 00003FBD B103                    	mov	cl,3
 28401                                  	;mov	al,' ' ; 20h
 28402                                  	;cmp	[si],al
 28403                                  	; 27/03/2023
 28404 00003FBF 803C20                  	cmp	byte [si],20h ; ' '
 28405 00003FC2 7412                    	je	short ENDDEST		; No extension
 28406                                  	;mov	al,[DOT_CHR]
 28407                                  	; 27/03/2023
 28408 00003FC4 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28409 00003FC6 AA                      	stosb
 28410                                  BUILDEXT:
 28411 00003FC7 AC                      	lodsb
 28412 00003FC8 3C3F                    	cmp	al,'?'
 28413 00003FCA 7502                    	jne	short NOTAMBIGE
 28414 00003FCC 8A07                    	mov	al,[bx]
 28415                                  NOTAMBIGE:
 28416 00003FCE 3C20                    	cmp	al,' '
 28417 00003FD0 7401                    	je	short NOSTOREE
 28418 00003FD2 AA                      	stosb
 28419                                  NOSTOREE:
 28420 00003FD3 43                      	inc	bx
 28421 00003FD4 E2F1                    	loop	BUILDEXT
 28422                                  ENDDEST:
 28423 00003FD6 30C0                    	xor	al,al
 28424 00003FD8 AA                      	stosb				; NUL terminate
 28425 00003FD9 C3                      	retn
 28426                                  
 28427                                  ; =============== S U B	R O U T	I N E =======================================
 28428                                  	
 28429                                  	; 28/03/2023
 28430                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28431                                  BUILDPATH:
 28432 00003FDA F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 28433 00003FDE 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28434 00003FE0 89EA                    	mov	dx,bp			; Set DX to spec
 28435 00003FE2 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28436                                  
 28437                                  	; 27/03/2023
 28438                                  	; MSDOS 6.0
 28439 00003FE5 57                      	push	di			;AN000;
 28440 00003FE6 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28441                                  	;mov	bx,deny_none|read_open_mode
 28442 00003FE9 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28443 00003FEC 31C9                    	xor	cx,cx			;AN000; no special files
 28444 00003FEE 89D6                    	mov	si,dx			;AN030; get file name offset
 28445                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28446 00003FF0 BA0101                  	mov	dx,101h
 28447 00003FF3 CD21                    	INT	21h
 28448 00003FF5 5F                      	pop	di			;AN000;
 28449 00003FF6 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28450 00003FF8 E8F5DC                  	call	get_ext_error_number	;AN022; get the extended error
 28451                                  	;cmp	ax,2
 28452 00003FFB 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28453 00003FFE 7423                    	jz	short NOTPFILE		;AN022;
 28454                                  	;cmp	ax,3
 28455 00004000 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28456 00004003 741E                    	jz	short NOTPFILE		;AN022;
 28457                                  	;cmp	ax,5
 28458 00004005 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28459 00004008 7419                    	jz	short NOTPFILE		;AN022;
 28460 0000400A E926DA                  	jmp	extend_setup		;AN022; exit with error
 28461                                  
 28462                                  	; 27/03/2023
 28463                                  	; MSDOS 3.3
 28464                                  	;mov	ax,OPEN*256 ; 3D00h
 28465                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28466                                  	;			; DS:DX	-> ASCIZ filename
 28467                                  	;			; AL = access mode
 28468                                  	;			; 0 - read
 28469                                  	;jc	short NOTPFILE
 28470                                  
 28471                                  PURE_FILE:
 28472 0000400D 89C3                    	mov	bx,ax
 28473 0000400F B80044                  	mov	ax,IOCTL*256 ; 4400h
 28474 00004012 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28475                                  				; BX = file or device handle
 28476 00004014 B43E                    	mov	ah,CLOSE ;3Eh
 28477 00004016 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28478                                  				; BX = file handle
 28479                                  	; 18/04/2023
 28480 00004018 F6C280                  	test	dl,80h
 28481                                  	;test	dl,devid_ISDEV ; test dl,80h
 28482 0000401B 7553                    	jnz	short ISADEV
 28483 0000401D F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28484 00004021 744D                    	jz	short ISADEV
 28485                                  NOTPFILE:
 28486 00004023 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28487                                  	
 28488                                  	; 27/03/2023	
 28489                                  	; MSDOS 6.0
 28490 00004026 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28491 00004029 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28492                                  
 28493 0000402B 80FE3A                  	cmp	dh,':'
 28494 0000402E 7402                    	je	short DRVSPEC5
 28495                                  SET_DRIVE_SPEC:
 28496 00004030 B240                    	mov	dl,'@' ; 40h
 28497                                  DRVSPEC5:
 28498 00004032 80CA20                  	or	dl,20h
 28499 00004035 80EA60                  	sub	dl,60h		; A = 1
 28500 00004038 E873E5                  	call	SAVUDIR1
 28501                                  	
 28502                                  	; 27/03/2023
 28503                                  	; MSDOS 6.0
 28504 0000403B 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28505 0000403D E8B0DC                  	call	get_ext_error_number	;AN022; get the extended error
 28506 00004040 E9F0D9                  	jmp	extend_setup		;AN022; exit with error
 28507                                  
 28508                                  CURDIR_OK:
 28509 00004043 89EA                    	mov	dx,bp
 28510                                  	;add	dx,5
 28511 00004045 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28512                                  	;mov	bh,[bp+4]
 28513 00004048 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28514 0000404B 80E706                  	and	bh,6
 28515 0000404E 80FF06                  	cmp	bh,6			; Ambig and path ?
 28516 00004051 7518                    	jne	short CHECKAMB		; jmp if no
 28517                                  	;mov	si,[bp+2]
 28518 00004053 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28519 00004056 B33A                    	mov	bl,':'
 28520 00004058 385CFE                  	cmp	[si-2],bl
 28521 0000405B 7506                    	jne	short KNOWNOTSPEC
 28522                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28523                                  					; Know is d:/file
 28524                                  	;mov	byte [bp+0],2
 28525 0000405D C6460002                	mov	byte [bp],2
 28526 00004061 EB05                    	jmp	short DOPCDJ
 28527                                  KNOWNOTSPEC:
 28528                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28529                                  					; Know is path/file
 28530                                  	;mov	byte [bp+0],1		
 28531 00004063 C6460001                	mov	byte [bp],1
 28532 00004067 4E                      	dec	si
 28533                                  DOPCDJ:
 28534 00004068 E98300                  	jmp	DOPCD
 28535                                  CHECKAMB:
 28536 0000406B 80FF02                  	cmp	bh,2
 28537 0000406E 7505                    	jnz	short CHECKCD
 28538                                  ISSIMPFILE:
 28539                                  ISADEV:
 28540                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28541                                  	;mov	byte [bp+0],0		
 28542 00004070 C6460000                	mov	byte [bp],0
 28543 00004074 C3                      	retn
 28544                                  CHECKCD:
 28545 00004075 E869EC                  	call	SetRest1
 28546 00004078 B43B                    	mov	ah,CHDir ; 3Bh
 28547 0000407A CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28548                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28549 0000407C 7239                    	jb	short NOTPDIR
 28550 0000407E 89D7                    	mov	di,dx
 28551 00004080 31C0                    	xor	ax,ax
 28552 00004082 89C1                    	mov	cx,ax
 28553 00004084 49                      	dec	cx
 28554                                  	; 14/06/2023
 28555                                  	;repne	scasb	 ; MSDOS 3.3
 28556                                  
 28557                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28558                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28559                                  	; MSDOS 6.0
 28560                                  Kloop:					;AN000;  3/3/KK
 28561 00004085 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28562 00004088 47                      	inc	di			;AN000;  3/3/KK
 28563 00004089 08C0                    	or	al,al			;AN000;  3/3/KK
 28564 0000408B 740C                    	jz	short DONE		;AN000;  3/3/KK
 28565 0000408D 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28566 0000408F E82DE3                  	call	testkanj		;AN000;  3/3/KK
 28567 00004092 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28568 00004094 47                      	inc	di			;AN000;  3/3/KK
 28569 00004095 FEC4                    	inc	ah			;AN000;  3/3/KK
 28570 00004097 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28571                                  DONE:
 28572 00004099 4F                      	dec	di
 28573 0000409A A0[CA8A]                	mov	al,[DIRCHAR]
 28574                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28575                                  	;mov	byte [bp+0],2
 28576 0000409D C6460002                	mov	byte [bp],2
 28577                                  	; 27/03/2023
 28578                                  	; MSDOS 6.0
 28579 000040A1 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28580 000040A3 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 28581                                  	;
 28582 000040A5 3A45FF                  	cmp	al,[di-1]
 28583 000040A8 7405                    	jz	short GOTSRCSLSH
 28584                                  _STORE_PCHAR:
 28585 000040AA AA                      	stosb
 28586                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28587                                  	;mov	byte [bp+0],1
 28588 000040AB C6460001                	mov	byte [bp],1
 28589                                  GOTSRCSLSH:
 28590                                  	;or	byte [bp+4],6
 28591 000040AF 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 28592 000040B3 E87400                  	call	SETSTARS
 28593                                  NOTPDIR_RETN:
 28594 000040B6 C3                      	retn
 28595                                  
 28596                                  	; 28/03/2023
 28597                                  NOTPDIR:
 28598                                  	; MSDOS 6.0
 28599 000040B7 E836DC                  	call	get_ext_error_number	;AN022; get the extended error
 28600                                  	;cmp	ax,3
 28601 000040BA 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28602 000040BD 7405                    	je	short NOTPDIR_TRY	;AN022;
 28603                                  	;cmp	ax,5
 28604 000040BF 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28605 000040C2 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28606                                  NOTPDIR_TRY:
 28607                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28608                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28609                                  	;mov	byte [bp+0],0
 28610 000040C4 C6460000                	mov	byte [bp],0
 28611                                  	;mov	bh,[bp+4]
 28612 000040C8 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28613 000040CB F6C704                  	test	bh,4
 28614 000040CE 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28615                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28616                                  	;mov	byte [bp+0],2		
 28617 000040D0 C6460002                	mov	byte [bp],2
 28618                                  	;mov	si,[bp+2]
 28619 000040D4 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28620 000040D7 803C00                  	cmp	byte [si],0
 28621 000040DA 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 28622                                  	;mov	bl,[DOT_CHR]
 28623                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28624                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28625 000040DC B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28626 000040DE 381C                    	cmp	[si],bl
 28627 000040E0 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28628 000040E2 B33A                    	mov	bl,':'  ; 3Ah
 28629 000040E4 385CFE                  	cmp	[si-2],bl
 28630 000040E7 7405                    	je	short DOPCD		; Know d:/file
 28631                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 28632                                  					; Know path/file
 28633                                  	;mov	byte [bp+0],1
 28634 000040E9 C6460001                	mov	byte [bp],1
 28635 000040ED 4E                      	dec	si			; Point at last '/'
 28636                                  DOPCD:
 28637 000040EE 30DB                    	xor	bl,bl
 28638 000040F0 861C                    	xchg	bl,[si]			; Stick in a NUL
 28639 000040F2 E8ECEB                  	call	SetRest1
 28640                                  
 28641                                  	; 28/03/2023
 28642                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28643 000040F5 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28644 000040F7 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28645 000040F9 56                      	push	si			;AN000;  3/3/KK
 28646 000040FA 51                      	push	cx			;AN000;  3/3/KK
 28647 000040FB 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28648 000040FD 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28649                                  Kloop2: 				;AN000;  3/3/KK
 28650 000040FF AC                      	lodsb				;AN000;  3/3/KK
 28651 00004100 E8BCE2                  	call	testkanj		;AN000;  3/3/KK
 28652 00004103 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28653 00004105 AC                      	lodsb				;AN000;  3/3/KK
 28654 00004106 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28655 00004108 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28656 0000410A 59                      	pop	cx			;AN000;  3/3/KK
 28657 0000410B 5E                      	pop	si			;AN000;  3/3/KK
 28658 0000410C EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28659                                  					;		 trailing path sep
 28660                                  NotKanj4:				;AN000;  3/3/KK
 28661 0000410E 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28662 00004110 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28663 00004112 59                      	pop	cx			;AN000;  3/3/KK
 28664 00004113 5E                      	pop	si			;AN000;  3/3/KK
 28665                                  LookBack:				;AN000;  3/3/KK
 28666                                  	; 28/03/2023
 28667                                  	; MSDOS 3.3 & MSDOS 6.0
 28668 00004114 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28669 00004117 740E                    	je	short BADCDERRJ2
 28670                                  DoCdr:
 28671 00004119 B43B                    	mov	ah,CHDir ; 3Bh
 28672 0000411B CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28673                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28674 0000411D 861C                    	xchg	bl,[si]
 28675 0000411F 7395                    	jnc	short NOTPDIR_RETN
 28676                                  	
 28677                                  	; 28/03/2023
 28678                                  	; MSDOS 3.3
 28679                                  ;BADCDERRJ2:
 28680                                  	;stc
 28681                                  	;jmp	BADCDERR
 28682                                  
 28683                                  	; 28/03/2023
 28684                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28685 00004121 E8CCDB                  	call	get_ext_error_number	;AN022; get the extended error
 28686                                  EXTEND_SETUPJ:					;AN022;
 28687 00004124 E90CD9                  	jmp	extend_setup		;AN022; go issue the error message
 28688                                  BADCDERRJ2:
 28689 00004127 E906D9                  	jmp	badpath_err		;AC022; go issue path not found message
 28690                                  
 28691                                  ; =============== S U B	R O U T	I N E =======================================
 28692                                  
 28693                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28694                                  SETSTARS:
 28695                                  	;mov	[bp+2],di
 28696 0000412A 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28697                                  	;add	byte [bp+1],12
 28698 0000412D 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28699                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28700                                  	; 28/03/2023
 28701                                  	; MSDOS 6.0
 28702 00004131 B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28703                                  	;mov	ax,'?.' ; dot_qmark
 28704                                  
 28705 00004134 B90800                  	mov	cx,8
 28706 00004137 F3AA                    	rep	stosb
 28707 00004139 86C4                    	xchg	al,ah
 28708 0000413B AA                      	stosb
 28709 0000413C 86C4                    	xchg	al,ah
 28710 0000413E B103                    	mov	cl,3
 28711 00004140 F3AA                    	rep	stosb
 28712 00004142 30C0                    	xor	al,al
 28713 00004144 AA                      	stosb
 28714 00004145 C3                      	retn
 28715                                  
 28716                                  ; =============== S U B	R O U T	I N E =======================================
 28717                                  
 28718                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28719                                  COMPNAME:
 28720 00004146 BE[518C]                	mov	si,DestBuf	; do name translate of target
 28721 00004149 BF[4A88]                	mov	di,TRGXNAME	; save for name comparison
 28722 0000414C B460                    	mov	ah,xNameTrans ; 60h
 28723 0000414E CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28724                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28725                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28726 00004150 BE[F387]                	mov	si,SRCXNAME	; get name translate of source
 28727 00004153 BF[4A88]                	mov	di,TRGXNAME	; get name translate of target
 28728                                  	;call	STRCOMP
 28729                                  	;retn
 28730                                  	; 28/03/2023
 28731 00004156 E9C7E4                  	jmp	STRCOMP
 28732                                  
 28733                                  ;============================================================================
 28734                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28735                                  ;============================================================================
 28736                                  ; 30/09/2018 - Retro DOS v3.0
 28737                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28738                                  
 28739                                  ;-----------------------------------------------------------------------;
 28740                                  ; ENTRY:								;
 28741                                  ;	DS:SI	Points input buffer					;
 28742                                  ;	ES:DI	Points to the token buffer				;
 28743                                  ;	BL	Special delimiter for this call 			;
 28744                                  ;		    Always checked last 				;
 28745                                  ;		    set it to space if there is no special delimiter	;
 28746                                  ; EXIT: 								;
 28747                                  ;	DS:SI	Points to next char in the input buffer 		;
 28748                                  ;	ES:DI	Points to the token buffer				;
 28749                                  ;	[STARTEL] Points to start of last element of path in token	;
 28750                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28751                                  ;	CX	Character count 					;
 28752                                  ;	BH	Condition Code						;
 28753                                  ;			Bit 1H of BH set if switch character		;
 28754                                  ;				Token buffer contains char after	;
 28755                                  ;				switch character			;
 28756                                  ;				BP has switch bits set (ORing only)	;
 28757                                  ;			Bit 2H of BH set if ? or * in token		;
 28758                                  ;				if * found element ? filled		;
 28759                                  ;			Bit 4H of BH set if path sep in token		;
 28760                                  ;			Bit 80H of BH set if the special delimiter	;
 28761                                  ;			   was skipped at the start of this token	;
 28762                                  ;		Token buffer always starts d: for non switch tokens	;
 28763                                  ;	CARRY SET							;
 28764                                  ;	    if CR on input						;
 28765                                  ;		token buffer not altered				;
 28766                                  ;									;
 28767                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28768                                  ; MODIFIES:								;
 28769                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28770                                  ;									;
 28771                                  ;-----------------------------------------------------------------------;
 28772                                  
 28773                                  ; Modifications to cparse: recognition of right and left parentheses
 28774                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28775                                  ;
 28776                                  ; Both modifications were installed in the course of adding a coherent
 28777                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28778                                  ; structure for command-line arguments. This parser relies on cparse to
 28779                                  ; recognize individual tokens.
 28780                                  ;
 28781                                  ; To process for-loops correctly, parentheses must therefore be
 28782                                  ; recognized as tokens. The upper-case conversion code was removed so
 28783                                  ; that commands (such as for and echo) would be able to use the "original"
 28784                                  ; text of the command line.
 28785                                  ;
 28786                                  ; Note also the modification to prevent the automatic conversion of colons
 28787                                  ; into spaces WITHIN THE SOURCE TEXT!
 28788                                  ;
 28789                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28790                                  ; on the command line.
 28791                                  ;
 28792                                  ; Alan L, OS/MSDOS				    14 August 1983
 28793                                  
 28794                                  ; ---------------------------------------------------------------------------
 28795                                  
 28796                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28797                                  
 28798                                  ;FSWITCH	EQU	8000h
 28799                                  ;FBADSWITCH	EQU	4000h
 28800                                  
 28801                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28802                                  
 28803                                  ; =============== S U B	R O U T	I N E =======================================
 28804                                  		
 28805                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28806                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28807                                  
 28808                                  cparse:
 28809 00004159 31C0                    	xor	ax,ax
 28810 0000415B 893E[7B8D]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28811 0000415F A2[7E8D]                	mov	[ELPOS],al		; Start in 8 char prefix
 28812                                  	; MSDOS 3.3
 28813                                  	;mov	[SOURCE],al		
 28814                                  	; MSDOS 6.0
 28815 00004162 A2[7F8D]                	mov	[SKPDEL], al		; No skip delimiter yet
 28816 00004165 88C7                    	mov	bh,al			; Init nothing
 28817 00004167 9C                      	pushf				; save flags
 28818 00004168 57                      	push	di			; save the token buffer addrss
 28819 00004169 31C9                    	xor	cx,cx			; no chars in token buffer
 28820 0000416B 880E[2A8C]              	mov	[comma],cl		; reset comma flag
 28821                                  moredelim:
 28822 0000416F AC                      	lodsb
 28823 00004170 E873E4                  	call	DELIM
 28824 00004173 751D                    	jnz	short SCANCDONE
 28825 00004175 3C20                    	cmp	al,' '
 28826 00004177 74F6                    	jz	short moredelim
 28827 00004179 3C09                    	cmp	al,9
 28828 0000417B 74F2                    	jz	short moredelim
 28829                                  	;xchg	al,[SOURCE]
 28830                                  	; 28/03/2023
 28831 0000417D 8606[7F8D]              	xchg	al,[SKPDEL]
 28832 00004181 08C0                    	or	al,al
 28833 00004183 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28834 00004185 F6C780                  	test	bh,80h			; has a special char been found?
 28835 00004188 7405                    	jz	short no_comma		; no - just exit
 28836 0000418A C606[2A8C]01            	mov	byte [comma],1		; set comma flag
 28837                                  no_comma:
 28838 0000418F E92A01                  	jmp	x_done			; Nul argument
 28839                                  
 28840                                  SCANCDONE:
 28841                                  	; 28/03/2023
 28842                                  	; MSDOS 6.0
 28843                                  	; -----------------------------------
 28844                                  	; Mod to avoid upper-case conversion.
 28845                                  	; -----------------------------------
 28846                                  	; MSDOS 3.3
 28847                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28848                                  	;jnz	short cpcont1		; 3/3/KK
 28849                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28850                                  cpcont1:
 28851                                  	; -----------------------------------
 28852                                  	; 28/03/2023
 28853 00004192 38D8                    	cmp	al,bl			; Special delimiter?
 28854 00004194 7505                    	jne	short nospec
 28855 00004196 80CF80                  	or	bh,80h
 28856 00004199 EBD4                    	jmp	short moredelim
 28857                                  nospec:
 28858 0000419B 3C0D                    	cmp	al,0Dh			; a CR?
 28859 0000419D 7503                    	jne	short ncperror
 28860 0000419F E91501                  	jmp	cperror
 28861                                  ncperror:
 28862 000041A2 3A06[C98A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28863 000041A6 7503                    	jne	short na_switch		; yes, process...
 28864 000041A8 E91401                  	jmp	a_switch
 28865                                  na_switch:
 28866 000041AB B23A                    	mov	dl,':'
 28867 000041AD 3814                    	cmp	[si],dl
 28868 000041AF 751D                    	jne	short anum_chard	; Drive not specified
 28869                                  	; 28/03/2023
 28870                                  	; MSDOS 6.0 
 28871 000041B1 803E[398C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28872 000041B6 7503                    	jne	short cpcont2		; 3/3/KK
 28873 000041B8 E82EE2                  	call	UPCONV			; 3/3/KK
 28874                                  cpcont2:
 28875 000041BB E85901                  	call	move_char
 28876 000041BE AC                      	lodsb				; Get the ':'
 28877 000041BF E85501                  	call	move_char
 28878 000041C2 893E[7B8D]              	mov	[STARTEL],di
 28879 000041C6 C606[7D8D]00            	mov	byte [ELCNT],0
 28880 000041CB E9B300                  	jmp	anum_test
 28881                                  anum_chard:
 28882 000041CE 893E[7B8D]              	mov	[STARTEL],di
 28883 000041D2 C606[7D8D]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28884 000041D7 803E[398C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28885 000041DC 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28886 000041DE E88BE4                  	call	pathchrcmp		; Starts with a pathchar?
 28887 000041E1 7518                    	jnz	short anum_char		; no
 28888 000041E3 50                      	push	ax
 28889 000041E4 A0[D98A]                	mov	al,[CURDRV]		; Insert drive spec
 28890                                  	;add	al,[CAPITAL_A]
 28891                                  	; 28/03/2023
 28892                                  	; MSDOS 6.0
 28893 000041E7 0441                    	add	al,'A' ; 41h
 28894 000041E9 E82B01                  	call	move_char
 28895 000041EC B03A                    	mov	al,':' ; 3Ah
 28896 000041EE E82601                  	call	move_char
 28897 000041F1 58                      	pop	ax
 28898 000041F2 893E[7B8D]              	mov	[STARTEL],di
 28899 000041F6 C606[7D8D]00            	mov	byte [ELCNT],0
 28900                                  anum_char:
 28901                                  	; 28/03/2023
 28902                                  	; MSDOS 6.0
 28903 000041FB E8C1E1                  	call	testkanj		;AC048			
 28904 000041FE 7406                    	jz	short NOTKANJ		;AC048;
 28905 00004200 E81401                  	call	move_char
 28906 00004203 AC                      	lodsb
 28907 00004204 EB78                    	jmp	short notspecial
 28908                                  
 28909                                  NOTKANJ:				;AN048; If not kanji
 28910 00004206 803E[398C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28911 0000420B 7503                    	jne	short TESTDOT 		;AN048;
 28912 0000420D E8D9E1                  	call	UPCONV			;AN048; upper case the char
 28913                                  TESTDOT:
 28914                                  	; 28/03/2023
 28915                                  	;cmp	al,dot_chr  ; 2Eh
 28916 00004210 3C2E                    	cmp	al,'.'
 28917 00004212 7509                    	jne	short testquest
 28918 00004214 FE06[7E8D]              	inc	byte [ELPOS] 		; flag in extension
 28919 00004218 C606[7D8D]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28920                                  testquest:
 28921 0000421D 3C3F                    	cmp	al,'?'  ; 3Fh
 28922 0000421F 7503                    	jnz	short testsplat
 28923 00004221 80CF02                  	or	bh,2
 28924                                  testsplat:
 28925                                  	;cmp	al,[STAR]
 28926 00004224 3C2A                    	cmp	al,star	; 2Ah
 28927                                  	; 27/04/2023
 28928                                  	;cmp	al,'*' 
 28929 00004226 7530                    	jne	short testpath
 28930 00004228 80CF02                  	or	bh,2
 28931 0000422B 803E[B68D]00            	cmp	byte [expand_star],0
 28932 00004230 7504                    	jne	short expand_filename
 28933 00004232 EB24                    	jmp	short testpath
 28934                                  
 28935                                  BADPERR2J:
 28936                                  	;jmp	BADPERR2
 28937                                  	; 28/03/2023
 28938                                  	; MSDOS 6.0
 28939 00004234 EB75                    	jmp	short BADPERR2
 28940                                  
 28941                                  expand_filename:
 28942 00004236 B407                    	mov	ah,7
 28943 00004238 803E[7E8D]00            	cmp	byte [ELPOS],0
 28944 0000423D 7402                    	jz	short gotelcnt
 28945 0000423F B402                    	mov	ah,2
 28946                                  gotelcnt:
 28947 00004241 B03F                    	mov	al,'?'
 28948 00004243 2A26[7D8D]              	sub	ah,[ELCNT]
 28949 00004247 72EB                    	jb	short BADPERR2J
 28950 00004249 86E1                    	xchg	ah,cl
 28951 0000424B E309                    	jcxz	testpathx
 28952                                  qmove:
 28953 0000424D 86E1                    	xchg	ah,cl
 28954 0000424F E8C500                  	call	move_char
 28955 00004252 86E1                    	xchg	ah,cl
 28956 00004254 E2F7                    	loop	qmove
 28957                                  testpathx:
 28958 00004256 86E1                    	xchg	ah,cl
 28959                                  testpath:
 28960 00004258 E811E4                  	call	pathchrcmp
 28961 0000425B 7521                    	jnz	short notspecial
 28962 0000425D 80CF04                  	or	bh,4
 28963 00004260 803E[B68D]00            	cmp	byte [expand_star],0
 28964 00004265 7405                    	jz	short no_err_check
 28965 00004267 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28966 0000426A 7545                    	jnz	short BADPERR
 28967                                  no_err_check:
 28968 0000426C 893E[7B8D]              	mov	[STARTEL],di	  	; New element
 28969 00004270 FF06[7B8D]              	inc	word [STARTEL]	  	; Point to char after /
 28970 00004274 C606[7D8D]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 28971 00004279 C606[7E8D]00            	mov	byte [ELPOS],0
 28972                                  notspecial:
 28973 0000427E E89600                  	call	move_char		; just an alphanum string
 28974                                  anum_test:
 28975 00004281 AC                      	lodsb
 28976                                  
 28977                                  	; 28/03/2023
 28978                                  	; MSDOS 6.0
 28979                                  	; -----------------------------------
 28980                                  	; Mod to avoid upper-case conversion.
 28981                                  	; -----------------------------------
 28982                                  	; MSDOS 3.3
 28983                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28984                                  	;jnz	short cpcont3		; 3/3/KK
 28985                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28986                                  cpcont3:
 28987                                  	; -----------------------------------
 28988                                  
 28989 00004282 E861E3                  	call	DELIM
 28990 00004285 7435                    	jz	short x_done
 28991 00004287 3C0D                    	cmp	al,0Dh
 28992 00004289 7431                    	je	short x_done
 28993 0000428B 3A06[C98A]              	cmp	al,[SWITCHAR]
 28994 0000428F 742B                    	je	short x_done
 28995 00004291 38D8                    	cmp	al,bl
 28996 00004293 7427                    	je	short x_done
 28997 00004295 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 28998                                  	; 28/03/2023
 28999                                  	; MSDOS 3.3
 29000                                  	;jnz	short ANUM_CHARJ 
 29001                                  	; MSDOS 6.0
 29002 00004297 7403                    	je	short FOO15
 29003 00004299 E95FFF                  	jmp	anum_char
 29004                                  
 29005                                  ; Modification made for parseline.
 29006                                  ; Why would it be necessary to change colons to spaces? In this
 29007                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29008                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29009                                  
 29010                                  FOO15:
 29011 0000429C 803E[398C]02            	cmp	byte [cpyflag],2
 29012 000042A1 7505                    	jnz	short cpcont4
 29013 000042A3 E87100                  	call	move_char
 29014 000042A6 EBD9                    	jmp	short anum_test
 29015                                  cpcont4:
 29016 000042A8 46                      	inc	si			; Skip the ':'
 29017 000042A9 EB11                    	jmp	short x_done
 29018                                  
 29019                                  	; 28/03/2023
 29020                                  ;ANUM_CHARJ:
 29021                                  	;jmp	anum_char
 29022                                  
 29023                                  BADPERR2:
 29024 000042AB BA[2C7F]                	mov	dx,BADCPMES_PTR
 29025 000042AE E9A1E6                  	jmp	cerror
 29026                                  
 29027                                  BADPERR:
 29028                                  	; 28/03/2023
 29029                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29030                                  BADCDERR:
 29031                                  	; MSDOS 6.0
 29032 000042B1 BA[5680]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29033 000042B4 E99BE6                  	jmp	cerror			;AC022;  message
 29034                                  	
 29035                                  cperror:
 29036 000042B7 4E                      	dec	si			; adjust the pointer
 29037 000042B8 5F                      	pop	di			; retrive token buffer address
 29038 000042B9 9D                      	popf				; restore flags
 29039 000042BA F9                      	stc				; set the carry bit
 29040 000042BB C3                      	retn
 29041                                  
 29042                                  x_done:
 29043 000042BC 4E                      	dec	si			; adjust for next round
 29044                                  
 29045                                  ; Mod to recognize right and left parens as integral tokens.
 29046                                  ;x_done2:
 29047 000042BD EB51                    	jmp	short out_token
 29048                                  
 29049                                  a_switch:
 29050 000042BF 80CF01                  	or	bh,1			; Indicate switch
 29051                                  	;or	bp,FSWITCH ; 8000h
 29052                                  	; 28/03/2023
 29053 000042C2 81CD0080                	or	bp,8000h
 29054 000042C6 E815E3                  	call	scanoff
 29055 000042C9 46                      	inc	si
 29056                                  	; 28/03/2023
 29057                                  	; MSDOS 6.0
 29058 000042CA E8F2E0                  	call	testkanj		;AN057; See if DBCS lead byte
 29059 000042CD 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29060 000042CF E84500                  	call	move_char		;AN057; DBCS - store first byte
 29061 000042D2 AC                      	lodsb				;AN057; get second byte
 29062 000042D3 E84100                  	call	move_char		;AN057; store second byte
 29063                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29064 000042D6 81CD0040                	or	bp,4000h
 29065 000042DA EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29066                                  a_switch_notkanj:			;AN057;
 29067 000042DC 3C0D                    	cmp	al,0Dh
 29068 000042DE 7509                    	jne	short Store_swt
 29069 000042E0 B000                    	mov	al,0
 29070 000042E2 AA                      	stosb
 29071                                  	;or	bp,FBADSWITCH ; 4000h
 29072 000042E3 81CD0040                	or	bp,4000h
 29073 000042E7 EBCE                    	jmp	short cperror		; Trailing switch character error
 29074                                  					;   BP = fSwitch but no switch
 29075                                  					;   bit is set (unknown switch)
 29076                                  Store_swt:
 29077 000042E9 E82B00                  	call	move_char		; store the character
 29078                                  
 29079                                  ; This upconv call must stay. It is used to identify copy-switches
 29080                                  ; on the command line, and won't store anything into the output buffer.
 29081                                  
 29082                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29083                                  	; 28/03/2023
 29084 000042EC E8FAE0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29085                                  	
 29086 000042EF 06                      	push	es
 29087 000042F0 57                      	push	di
 29088 000042F1 51                      	push	cx
 29089 000042F2 0E                      	push	cs
 29090 000042F3 07                      	pop	es
 29091                                  	; 28/03/2023
 29092                                  	; MSDOS 3.3
 29093                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 29094                                  	; MSDOS 6.0
 29095 000042F4 BF[5184]                	mov	di,switch_list ; "?VBAPW"
 29096                                  	; MSDOS 3.3
 29097                                  	;mov	cx,SWCOUNT ; 5
 29098                                  	; MSDOS 6.0
 29099 000042F7 B90600                  	mov	cx,6  ; SWCOUNT = 6
 29100                                  	;or	bp,FBADSWITCH  ; 4000h
 29101 000042FA 81CD0040                	or	bp,4000h
 29102 000042FE F2AE                    	repne	scasb
 29103 00004300 750B                    	jnz	short out_tokenp
 29104                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29105 00004302 81E5FFBF                	and	bp,0BFFFh
 29106 00004306 B80100                  	mov	ax,1
 29107 00004309 D3E0                    	shl	ax,cl
 29108 0000430B 09C5                    	or	bp,ax
 29109                                  out_tokenp:
 29110 0000430D 59                      	pop	cx
 29111 0000430E 5F                      	pop	di
 29112 0000430F 07                      	pop	es
 29113                                  out_token:
 29114 00004310 B000                    	mov	al,0			; null at the end
 29115 00004312 AA                      	stosb
 29116 00004313 5F                      	pop	di			; restore token buffer pointer	
 29117 00004314 9D                      	popf
 29118 00004315 F8                      	clc				; clear carry flag
 29119 00004316 C3                      	retn
 29120                                  
 29121                                  ; =============== S U B	R O U T	I N E =======================================
 29122                                  
 29123                                  	; 28/03/2023
 29124                                  move_char:
 29125 00004317 AA                      	stosb				; store char in token buffer
 29126 00004318 41                      	inc	cx			; increment char count
 29127 00004319 FE06[7D8D]              	inc	byte [ELCNT]		; increment element count for * substi
 29128 0000431D C3                      	retn
 29129                                  
 29130                                  ;============================================================================
 29131                                  ; PARSE.ASM, MSDOS 6.0, 1991
 29132                                  ;============================================================================
 29133                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29134                                  
 29135                                  ; -----------------------------
 29136                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 29137                                  ; -----------------------------
 29138                                  
 29139                                  ;**** Equation field
 29140                                  ;-------- Character code definition
 29141                                  
 29142                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 29143                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 29144                                  $P_Period	   equ	"."             ;AN020;
 29145                                  $P_Slash	   equ	"/"             ;AN020;
 29146                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 29147                                  $P_Comma	   equ	","             ;AN000;
 29148                                  $P_Switch	   equ	"/"             ;AN000;
 29149                                  $P_Keyword	   equ	"="             ;AN000;
 29150                                  $P_Colon	   equ	":"             ;AN000;
 29151                                  $P_Plus 	   equ	"+"             ;AN000;
 29152                                  $P_Minus	   equ	"-"             ;AN000;
 29153                                  $P_Rparen	   equ	")"             ;AN000;
 29154                                  $P_Lparen	   equ	"("             ;AN000;
 29155                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 29156                                  $P_DQuote	   equ	'"'             ;AN000;
 29157                                  $P_NULL 	   equ	0		;AN000;
 29158                                  $P_TAB		   equ	9		;AN000;
 29159                                  $P_CR		   equ	0Dh		;AN000;
 29160                                  $P_LF		   equ	0Ah		;AN000;
 29161                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 29162                                  
 29163                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 29164                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 29165                                  
 29166                                  $P_error_filespec  equ  1
 29167                                  
 29168                                  ;----------------------------------------------------------------------------
 29169                                  ; PARMS LABEL	BYTE
 29170                                  ;	DW	PARMSX
 29171                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 29172                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29173                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 29174                                  ;				; TYPICAL ARE ";", "="
 29175                                  ;				; "," & WHITESPACE ALWAYS
 29176                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29177                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 29178                                  ;----------------------------------------------------------------------------
 29179                                  
 29180                                  struc $P_PARMS_BLK			;AN000;
 29181 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 29182 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 29183 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 29184                                  endstruc 				;AN000;
 29185                                  
 29186                                  $P_Len_PARMS	   equ	4		;AN000;
 29187                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 29188                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 29189                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 29190                                  
 29191                                  ;----------------------------------------------------------------------------
 29192                                  ; PARMSX LABEL	BYTE
 29193                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 29194                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 29195                                  ;	:				; REPEATS maxp-1 TIMES
 29196                                  ;	DB	maxs			; # OF SWITCHES
 29197                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 29198                                  ;	:				; REPEATS maxs-1 TIMES
 29199                                  ;	DB	maxk			; # OF KEYWORD
 29200                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 29201                                  ;	:				; REPEATS maxk-1 TIMES
 29202                                  ;----------------------------------------------------------------------------
 29203                                  
 29204                                  struc $P_PARMSX_BLK			;AN000;
 29205 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 29206 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 29207 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 29208                                  endstruc				;AN000;
 29209                                  
 29210                                  ; 31/03/2023
 29211                                  ;----------------------------------------------------------------------------
 29212                                  ; << Control field definition >>
 29213                                  ;
 29214                                  ;CONTROL   LABEL   BYTE
 29215                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 29216                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 29217                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 29218                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 29219                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 29220                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 29221                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 29222                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 29223                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 29224                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 29225                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 29226                                  ;				; 0002H=REPEATS ALLOWED
 29227                                  ;				; 0001H=OPTIONAL
 29228                                  ;	   DW FUNCTION_FLAGS
 29229                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 29230                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 29231                                  ;				; 0010H=REMOVE ":" AT END
 29232                                  ; (tm10)			; 0020H=colon is not necessary for switch
 29233                                  ;
 29234                                  ;	   DW RESULT		; RESULT BUFFER
 29235                                  ;	   DW VALUES		; VALUE LISTS
 29236                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 29237                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 29238                                  ;	   :
 29239                                  ;
 29240                                  ;Note:
 29241                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 29242                                  ;      DATE bit simalteniously.
 29243                                  ;
 29244                                  ;      The parser examins each bit along with the following priority.
 29245                                  ;
 29246                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 29247                                  ;      FILE SPEC -> SIMPLE STRING.
 29248                                  ;
 29249                                  ;
 29250                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 29251                                  ;      in the result buffer is capitalized.
 29252                                  ;
 29253                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 29254                                  ;
 29255                                  ;
 29256                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 29257                                  ;      switch, for example, '/A', then STRING points to;
 29258                                  ;
 29259                                  ;		DB    1 	; number of following synonyms
 29260                                  ;		DB   '/A',0
 29261                                  ;
 29262                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 29263                                  ;
 29264                                  ;		DB    1 	; number of following synonyms
 29265                                  ;		DB   'CODEPAGE=',0
 29266                                  ;
 29267                                  ;
 29268                                  ;    - "..." must consist of upper case characters only because the parser
 29269                                  ;      performs pattern matching after converting input to upper case (by
 29270                                  ;      using the current country upper case table)
 29271                                  ;
 29272                                  ;
 29273                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 29274                                  ;      example /A and /B, the format will be;
 29275                                  ;
 29276                                  ;		DB    2 	; number of following synonyms
 29277                                  ;		DB    '/A',0
 29278                                  ;		DB    '/B',0
 29279                                  ;----------------------------------------------------------------------------
 29280                                  
 29281                                  ;**** Match_Flags
 29282                                  
 29283                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 29284                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 29285                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 29286                                  $P_Date_S	   equ	1000h		;AN000; Date string
 29287                                  $P_Time_S	   equ	0800h		;AN000; Time string
 29288                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 29289                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 29290                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 29291                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 29292                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 29293                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 29294                                  $P_Optional	   equ	0001h		;AN000; Optional
 29295                                  
 29296                                  ;**** Function flags
 29297                                  
 29298                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 29299                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 29300                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 29301                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 29302                                  
 29303                                  ;-------------------------------- Control block structure
 29304                                  struc $P_CONTROL_BLK
 29305 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 29306 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 29307 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 29308 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 29309 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 29310 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29311                                  endstruc
 29312                                  
 29313                                  ; 31/03/2023
 29314                                  ;----------------------------------------------------------------------------
 29315                                  ;
 29316                                  ;VALUES LABEL	BYTE
 29317                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29318                                  ;	+-
 29319                                  ;	| DB	nrng		; NUMBER OF RANGES
 29320                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29321                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29322                                  ;	|	:
 29323                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29324                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29325                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29326                                  ;	|	:
 29327                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29328                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29329                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29330                                  ;	+-	:
 29331                                  ;
 29332                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29333                                  ;
 29334                                  ;Note:
 29335                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29336                                  ;      when no choice lists are provided.
 29337                                  ;
 29338                                  ;    - STRING must consist of upper case characters only because the parser
 29339                                  ;      performs pattern matching after converting input to upper case (by
 29340                                  ;      using the current country upper case table)
 29341                                  ;----------------------------------------------------------------------------
 29342                                  
 29343                                  $P_nval_None	equ 0		;AN000; no value list ID
 29344                                  $P_nval_Range	equ 1		;AN000; range list ID
 29345                                  $P_nval_Value	equ 2		;AN000; value list ID
 29346                                  $P_nval_String	equ 3		;AN000; string list ID
 29347                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29348                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29349                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29350                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29351                                  
 29352                                  struc $P_VAL_LIST
 29353 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29354 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29355 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29356 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29357 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29358                                  endstruc
 29359                                  
 29360                                  ; 31/03/2023
 29361                                  ;----------------------------------------------------------------------------
 29362                                  ;
 29363                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29364                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29365                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29366                                  ;					;	3=STRING, 4=COMPLEX,
 29367                                  ;					;	5=FILESPEC, 6=DRIVE
 29368                                  ;					;	7=DATE, 8=TIME
 29369                                  ;					;	9=QUOTED STRING
 29370                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29371                                  ;
 29372                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29373                                  ;
 29374                                  ;       +-
 29375                                  ;       | DD	n			; VALUE IF NUMBER
 29376                                  ;       | or
 29377                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29378                                  ;       |				; (ES presents Segment address)
 29379                                  ;       | or
 29380                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29381                                  ;       | or
 29382                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29383                                  ;       | or
 29384                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29385                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29386                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29387                                  ;       | or
 29388                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29389                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29390                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29391                                  ;       |	DB HUNDREDTHS ;(0-99)
 29392                                  ;       +-
 29393                                  ;
 29394                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29395                                  ;      list.
 29396                                  ;
 29397                                  ;      YEAR: If the input value for the year is less than 100, parser
 29398                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 29399                                  ;	     the year value, he returns 1987.
 29400                                  ;----------------------------------------------------------------------------
 29401                                  
 29402                                  ;-------------------------------- Result block structure
 29403                                  struc $P_RESULT_BLK;
 29404 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 29405 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 29406 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 29407 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 29408                                  endstruc
 29409                                  
 29410                                  ;**** values for the type field in the result block
 29411                                  
 29412                                  $P_EOL		 equ 0		;AN000; End of line
 29413                                  $P_Number	 equ 1		;AN000; Number
 29414                                  $P_List_Idx	 equ 2		;AN000; List Index
 29415                                  $P_String	 equ 3		;AN000; String
 29416                                  $P_Complex	 equ 4		;AN000; Complex
 29417                                  $P_File_Spec	 equ 5		;AN000; File Spec
 29418                                  $P_Drive	 equ 6		;AN000; Drive
 29419                                  $P_Date_F	 equ 7		;AN000; Date
 29420                                  $P_Time_F	 equ 8		;AN000; Time
 29421                                  $P_Quoted_String equ 9		;AN000; Quoted String
 29422                                  
 29423                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 29424                                  
 29425                                  ;**** Return code
 29426                                  ;
 29427                                  ; following return code will be returned in the AX register.
 29428                                  
 29429                                  $P_No_Error	 equ 0		;AN000; No error
 29430                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 29431                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 29432                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 29433                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 29434                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29435                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29436                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29437                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29438                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29439                                  
 29440                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29441                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29442                                  $P_Neg		 equ 02h	;AN000; Negative value
 29443                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29444                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29445                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29446                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29447                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29448                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29449                                  
 29450                                  ;-------- Masks
 29451                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29452                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29453                                  
 29454                                  ;-------------
 29455                                  
 29456                                  struc $P_DOS_TBL
 29457 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29458 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29459 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29460                                  endstruc
 29461                                  
 29462                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29463                                  				;AN000; following parameters are set
 29464                                  				;AN000; to get casemap table.
 29465                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29466                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29467                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29468                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29469                                  				; By this call following information
 29470                                  				; is returned.
 29471                                  
 29472                                  ; 03/04/2023
 29473                                  ;-------------------------------- country dependent information
 29474                                  
 29475                                  $P_DOS_Get_CDI	equ 3800h
 29476                                  
 29477                                  struc $P_CDI
 29478 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29479 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29480 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29481 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29482 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29483 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29484 0000000E ??                      		resb 1		;AN000;
 29485 0000000F ??                      		resb 1		;AN000;
 29486 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29487 00000011 ????????                		resw 2		;AN000;
 29488 00000015 ????                    		resb 2		;AN000;
 29489 00000017 <res Ah>                		resw 5		;AN000;
 29490                                  endstruc
 29491                                  
 29492                                  $P_Date_MDY	equ 0		;AN000;
 29493                                  $P_Date_DMY	equ 1		;AN000;
 29494                                  $P_Date_YMD	equ 2		;AN000;
 29495                                  
 29496                                  ; ----------------------------
 29497                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29498                                  ; ----------------------------
 29499                                  
 29500                                  ;***********************************************************************
 29501                                  ; SysParse;
 29502                                  ;
 29503                                  ;  Function : Parser Entry
 29504                                  ;
 29505                                  ;  Input: DS:SI -> command line
 29506                                  ;	  ES:DI -> parameter block
 29507                                  ;	  psdata_seg -> psdata.inc
 29508                                  ;	  CX = operand ordinal
 29509                                  ;
 29510                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29511                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29512                                  ;		 is in DS.
 29513                                  ;
 29514                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29515                                  ;		    invalid value list. But this parser does NOT implement
 29516                                  ;		    this feature. Therefore CY always zero.
 29517                                  ;
 29518                                  ;	   CY = 0   AX = return code
 29519                                  ;		    BL = terminated delimiter code
 29520                                  ;		    CX = new operand ordinal
 29521                                  ;		    SI = set past scaned operand
 29522                                  ;		    DX = selected result buffer
 29523                                  ;
 29524                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29525                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29526                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29527                                  ;
 29528                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29529                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29530                                  ;
 29531                                  ;-------- Modification History -----------------------------------------
 29532                                  ;
 29533                                  ;  4/04/87 : Created by K. K,
 29534                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29535                                  ;	   : JMP SHORT assemble error (tm02)
 29536                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29537                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29538                                  ;	     DateSW equ 1)	      (tm04)
 29539                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29540                                  ;				      (tm05) in PSDATA.INC
 29541                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29542                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29543                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29544                                  ;	     value-list block	      (tm07)
 29545                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29546                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29547                                  ;	     (tm08)
 29548                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29549                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29550                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29551                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29552                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29553                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29554                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29555                                  ;					  (tm12)
 29556                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29557                                  ;					  (tm13)
 29558                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29559                                  ;					  (tm14)
 29560                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29561                                  ;					  (tm15)
 29562                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29563                                  ;
 29564                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29565                                  ;
 29566                                  ;  7/28/87 : Kerry S (;AN018;)
 29567                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29568                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29569                                  ;	     affected: $P_Chk_SW_Control.
 29570                                  ;
 29571                                  ;  7/29/87 : Kerry S (;AN019;)
 29572                                  ;	     Now allow the optional bit in match flags for switches.  This
 29573                                  ;	     allows the switch to be encountered with a value or without a
 29574                                  ;	     value and no error is returned.
 29575                                  ;
 29576                                  ;
 29577                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29578                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29579                                  ;	     within a date response, instead of checking just for the one
 29580                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29581                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29582                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29583                                  ;
 29584                                  ;  9/1/87  : Kerry S (;AN021)
 29585                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29586                                  ;	     the command line with the string in the control block the
 29587                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29588                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29589                                  ;	     string on the command line than in the synonym list in the control
 29590                                  ;	     block.  I put in a test for a null in the control block so the
 29591                                  ;	     string in the control block must be the same length as the string
 29592                                  ;	     preceeding the colon or equal on the command line.
 29593                                  ;
 29594                                  ;  8/28/87 : Kerry S (;AN022;)
 29595                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29596                                  ;	     problems for people who included it themselves in a segment other
 29597                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29598                                  ;	     segment.
 29599                                  ;
 29600                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29601                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29602                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29603                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29604                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29605                                  ;	     BL be used if TIME is being parsed.
 29606                                  ;
 29607                                  ;  9/24/87 : Ed K
 29608                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29609                                  ;	     invocations with their normally expanded code; made comments
 29610                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29611                                  ;
 29612                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29613                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29614                                  ;	     pointed to by non-existant CONTROL.
 29615                                  ;
 29616                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29617                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29618                                  ;	     support to frame quoted text string with single quote.
 29619                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29620                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29621                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29622                                  ;
 29623                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29624                                  ;	     quote chars within a quoted string is supposed to be reported as
 29625                                  ;	     one quote character, but is reported as two quotes.  This changed
 29626                                  ;	     two instructions in PROC $P_Quoted_Str.
 29627                                  ;
 29628                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29629                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29630                                  ;
 29631                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29632                                  ;
 29633                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29634                                  ;	     psdata buffer should have psdata_seg.
 29635                                  ;
 29636                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29637                                  ;	     positional missing.
 29638                                  ;
 29639                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29640                                  ;	     as a line delimiter, should use carriage return.
 29641                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29642                                  ;
 29643                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29644                                  ;
 29645                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29646                                  ;	     endless loop since SI is returned still pointing to start
 29647                                  ;	     of that parm.
 29648                                  ;
 29649                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29650                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29651                                  ;	     when tried to fix it on previous version, changed similar
 29652                                  ;	     but wrong place.
 29653                                  ;
 29654                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29655                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29656                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29657                                  ;
 29658                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29659                                  ;	     in a filespec, then flag an error.
 29660                                  ;
 29661                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29662                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29663                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29664                                  ;  -->	     local parser data. Why were some references to local data changed
 29665                                  ;	     to do this before, but not all ?????
 29666                                  ;
 29667                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29668                                  ;
 29669                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29670                                  ;
 29671                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29672                                  ;
 29673                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29674                                  ;
 29675                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29676                                  ;	     separator in TIME before hundredths field.
 29677                                  ;
 29678                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29679                                  ;			strings as keywords.
 29680                                  ;
 29681                                  ;***********************************************************************
 29682                                  
 29683                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29684                                  cmd_parse:
 29685                                  	;call	sysparse
 29686                                  	;retn
 29687                                  
 29688                                  ; -----------------------------------
 29689                                  
 29690                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29691                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29692                                  
 29693                                  sysparse:
 29694 0000431E 2EC706[1D86]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29695 00004325 2E890E[A786]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29696 0000432A 2E8926[A986]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29697 0000432F 2E8936[AB86]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29698                                  $P_Redo_Time:				;AN039; try to parse time again
 29699 00004334 FC                      	cld				;AN000; confirm forward direction
 29700 00004335 2E890E[1086]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29701                                  	;mov	word [cs:$P_RC],$P_No_Error
 29702 0000433A 2EC706[1286]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29703 00004341 2EC706[2586]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29704                                  					;AC034; initalize synonym pointer
 29705 00004348 2EC706[1686]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29706                                  
 29707                                  ;M029 -- Begin changes
 29708                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29709                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29710                                  ;corrupts this table but does not corrupt the checksum region will leave
 29711                                  ;command.com parsing in an inconsistent state.
 29712                                  ; NB: The special characters string has been hardcoded here. If any change
 29713                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29714                                  
 29715 0000434F 2EC706[E286]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29716 00004356 2EC706[E486]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29717 0000435D 2EC706[E686]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29718 00004364 2EC706[E886]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29719                                  
 29720                                  ;M029 -- End of changes
 29721                                  
 29722 0000436B E83609                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29723 0000436E 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29724                                  
 29725                                  ;--------------------------- End of Line
 29726                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29727 00004370 B8FFFF                  	mov	ax,0FFFFh
 29728 00004373 53                      	push	bx			;AN000;
 29729                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29730 00004374 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29731                                  	
 29732                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29733 00004377 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29734 0000437A 7304                    	jae	short $P_Fin		;AN000; positional found.
 29735                                  
 29736                                  	;mov	ax,2
 29737 0000437C B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29738                                  	; 27/04/2023
 29739 0000437F F8                      	clc
 29740                                  $P_Fin: 				;AN000;
 29741 00004380 5B                      	pop	bx			;AN000;
 29742                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29743                                  	; 27/04/2023
 29744                                  	; cf = 0
 29745                                  	;clc
 29746 00004381 C3                      	retn
 29747                                  
 29748                                  ;---------------------------
 29749                                  $P_Start:				;AN000;
 29750 00004382 2E8936[1F86]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 29751 00004387 53                      	push	bx			;AN000; quoted string or file spec.
 29752 00004388 57                      	push	di			;AN000;
 29753 00004389 55                      	push	bp			;AN000;
 29754 0000438A 8D1E[2786]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29755 0000438E 2EF606[1E86]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29756                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29757 00004394 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29758                                  $P_Pack_Loop:				;AN000;
 29759 00004396 AC                      	lodsb				;AN000; Pick a operand from buffer
 29760 00004397 E8BF09                  	call	$P_Chk_Switch		;AN000; Check switch character
 29761 0000439A 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29762                                  
 29763 0000439C E82709                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29764 0000439F 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29765                                  
 29766 000043A1 E85409                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29767 000043A4 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29768                                  
 29769 000043A6 2EF606[1E86]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29770                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29771 000043AC 7505                    	jnz	short $P_Pack_End_backup_si
 29772                                  					;AN000; (tm08)
 29773 000043AE E8F308                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29774 000043B1 EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29775                                  
 29776                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29777 000043B3 2EF606[1E86]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29778                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29779 000043B9 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29780                                  
 29781 000043BB 4E                      	dec	si			;AN000; (tm08)
 29782 000043BC EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29783                                  $P_PL01:				;AN000;
 29784 000043BE 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29785                                  	;cmp	al,'='
 29786 000043C1 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29787 000043C3 7506                    	jne	short $P_PL00 		;AN000; then
 29788                                  
 29789 000043C5 2E800E[1E86]01          	or	byte [cs:$P_Flags2],$P_equ
 29790                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29791                                  $P_PL00:				;AN000;
 29792 000043CB 43                      	inc	bx			;AN000; ready to see next byte
 29793 000043CC E8B509                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29794 000043CF 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29795                                  
 29796 000043D1 AC                      	lodsb				;AN000; if yes, store
 29797 000043D2 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29798 000043D5 43                      	inc	bx			;AN000; update pointer
 29799 000043D6 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29800                                  
 29801                                  $P_Pack_End_BY_EOL:			;AN000;
 29802 000043D8 4E                      	dec	si			;AN000; backup si pointer
 29803                                  $P_Pack_End:				;AN000;
 29804 000043D9 2E8936[1486]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29805                                  	;mov	byte [cs:bx],0
 29806 000043DE 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29807 000043E2 2E891E[2386]            	mov	[cs:$P_Save_EOB],bx
 29808                                  					;AC034; 3/17/87 keep the address for later use of complex
 29809                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29810 000043E7 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29811 000043EA 8D36[2786]              	lea	si,$P_STRING_BUF	;AC034;
 29812                                  	;cmp	byte [cs:si],'/'
 29813 000043EE 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29814 000043F2 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29815                                  
 29816 000043F4 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29817 000043F8 7408                    	je	short $P_Positional_Manager
 29818                                  					;M005;if so, process as one!
 29819 000043FA 2EF606[1E86]01          	test	byte [cs:$P_Flags2],$P_equ
 29820                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29821 00004400 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29822                                  
 29823                                  $P_Positional_Manager:			;AN000; else process as positional
 29824                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29825 00004402 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29826 00004406 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29827 00004408 2E3906[1086]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29828 0000440D 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29829                                  
 29830 0000440F 2EA1[1086]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29831 00004413 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29832 00004415 43                      	inc	bx			;AC035; add '2' to
 29833 00004416 43                      	inc	bx			;AC035;  BX reg
 29834                                  					;AN000; now bx points to 1st CONTROL
 29835 00004417 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29836 00004419 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29837 0000441C E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29838 0000441F EB69                    	jmp	short $P_Return_to_Caller
 29839                                  					;AN000; and return to the caller
 29840                                  $P_Too_Many_Error:			;AN000;
 29841                                  	;mov	word [cs:$P_RC],1
 29842 00004421 2EC706[1286]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29843                                  					;AC034; set exit code
 29844 00004428 EB60                    	jmp	short $P_Return_to_Caller
 29845                                  					;AN000; and return to the caller
 29846                                  $P_SW_Manager:				;AN000;
 29847                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29848 0000442A 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29849 0000442E 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29850 00004430 40                      	inc	ax			;AN000;
 29851 00004431 D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29852 00004433 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29853 00004435 268A0F                  	mov	cl,[es:bx]		;AN000;
 29854 00004438 30ED                    	xor	ch,ch			;AN000; cx = maxs
 29855 0000443A 09C9                    	or	cx,cx			;AN000; at least one switch ?
 29856 0000443C 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 29857 0000443E 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 29858                                  $P_SW_Mgr_Loop: 			;AN000;
 29859 0000443F 53                      	push	bx			;AN000;
 29860 00004440 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29861 00004443 E8C100                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29862 00004446 5B                      	pop	bx			;AN000;
 29863 00004447 7341                    	jnc	short $P_Return_to_Caller
 29864                                  					;AN000; if the CONTROL is for the switch, exit
 29865 00004449 43                      	inc	bx			;AC035; add '2' to
 29866 0000444A 43                      	inc	bx			;AC035;  BX reg
 29867                                  					;AN000; else bx points to the next CONTROL
 29868 0000444B E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29869                                  $P_SW_Not_Found:			;AN000;
 29870                                  	;mov	word [cs:$P_RC],3
 29871 0000444D 2EC706[1286]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29872                                  					;AC034; here no CONTROL for the switch has
 29873 00004454 EB34                    	jmp	short $P_Return_to_Caller0
 29874                                  					;AN000; not been found, means error.
 29875                                  $P_Key_Manager: 			;AN000;
 29876                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29877 00004456 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29878 0000445A 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29879 0000445C 40                      	inc	ax			;AN000;
 29880 0000445D D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29881 0000445F 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29882 00004461 268A07                  	mov	al,[es:bx]		;AN000;
 29883 00004464 30E4                    	xor	ah,ah			;AN000; ax = maxs
 29884 00004466 D1E0                    	shl	ax,1			;AN000;
 29885 00004468 40                      	inc	ax			;AN000; ax = ax*2+1
 29886 00004469 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 29887 0000446B 268A0F                  	mov	cl,[es:bx]		;AN000;
 29888 0000446E 30ED                    	xor	ch,ch			;AN000; cx = maxk
 29889 00004470 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 29890 00004472 740F                    	jz	short $P_Key_Not_Found	;AN000;
 29891 00004474 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 29892                                  $P_Key_Mgr_Loop:			;AN000;
 29893 00004475 53                      	push	bx			;AN000;
 29894 00004476 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29895 00004479 E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29896 0000447C 5B                      	pop	bx			;AN000;
 29897 0000447D 730B                    	jnc	short $P_Return_to_Caller
 29898                                  					;AN000; if the CONTROL is for the keyword, exit
 29899 0000447F 43                      	inc	bx			;AC035; add '2' to
 29900 00004480 43                      	inc	bx			;AC035;  BX reg
 29901                                  					;AN000; else bx points to the next CONTROL
 29902 00004481 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29903                                  $P_Key_Not_Found:			;AN000;
 29904                                  	;mov	word [cs:$P_RC],4
 29905 00004483 2EC706[1286]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29906                                  					;AC034; here no CONTROL for the keyword has
 29907                                  $P_Return_to_Caller0:
 29908                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29909 0000448A 5D                      	pop	bp			;AN000;
 29910 0000448B 5F                      	pop	di			;AN000;
 29911 0000448C 5B                      	pop	bx			;AN000;
 29912 0000448D 2E8B0E[1086]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29913 00004492 2EA1[1286]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29914 00004496 2E8B36[1486]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29915 0000449B 2E8B16[1686]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29916 000044A0 2E8A1E[1886]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29917                                  $P_Single_Exit: 			;AN000;
 29918 000044A5 F8                      	clc				;AN000;
 29919 000044A6 C3                      	retn				;AN000;
 29920                                  
 29921                                  ;***********************************************************************
 29922                                  ; $P_Chk_Pos_Control
 29923                                  ;
 29924                                  ; Function: Parse CONTROL block for a positional
 29925                                  ;
 29926                                  ; Input:     ES:BX -> CONTROL block
 29927                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29928                                  ;
 29929                                  ; Output:    None
 29930                                  ;
 29931                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 29932                                  ;
 29933                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 29934                                  ;***********************************************************************
 29935                                  
 29936                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29937                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 29938                                  
 29939                                  $P_Chk_Pos_Control:
 29940 000044A7 50                      	push	ax			;AN000;
 29941                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29942 000044A8 268B07                  	mov	ax,[es:bx]		;AN000;
 29943                                  	;test	ax,2
 29944 000044AB A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 29945 000044AE 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 29946                                  
 29947 000044B0 2EFF06[1086]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 29948                                  $P_CPC00:				;AN000;
 29949                                  	;cmp	byte [cs:si],0
 29950 000044B5 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 29951 000044B9 7516                    	jne	short $P_CPC01		;AN000;
 29952                                  
 29953                                  	;test	ax,1
 29954 000044BB A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 29955 000044BE 7509                    	jnz	short $P_CPC02		;AN000;
 29956                                  
 29957 000044C0 2EC706[1286]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29958                                  					;AC034; no, then error	 3/17/87
 29959 000044C7 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 29960                                  $P_CPC02:				;AN000;
 29961                                  	; 27/04/2023
 29962                                  	;push	ax ; *			;AN000;
 29963                                  	;
 29964                                  	;;mov	al,3
 29965                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 29966                                  	;;mov	ah,0FFh
 29967                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 29968                                  	;31/03/2023
 29969 000044C9 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29970 000044CC E89500                  	call	$P_Fill_Result		;AN000;
 29971                                  	; 27/04/2023
 29972                                  	;pop	ax ; *			;AN000;
 29973 000044CF EB03                    	jmp	short $P_CPC_Exit	;AN000;
 29974                                  $P_CPC01:				;AN000;
 29975 000044D1 E81101                  	call	$P_Check_Match_Flags	;AN000;
 29976                                  $P_CPC_Exit:				;AN000;
 29977 000044D4 58                      	pop	ax			;AN000;
 29978 000044D5 C3                      	retn				;AN000;
 29979                                  
 29980                                  ;***********************************************************************
 29981                                  ; $P_Chk_Key_Control
 29982                                  ;
 29983                                  ; Function: Parse CONTROL block for a keyword
 29984                                  ;
 29985                                  ; Input:     ES:BX -> CONTROL block
 29986                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29987                                  ;
 29988                                  ; Output:    CY = 1 : not match
 29989                                  ;
 29990                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29991                                  ;
 29992                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29993                                  ;***********************************************************************
 29994                                  
 29995                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29996                                  $P_Chk_Key_Control:			;AN000;
 29997 000044D6 F9                      	stc				;AN000;this logic works when the KeySW
 29998 000044D7 C3                      	retn				;AN000;is reset.
 29999                                  
 30000                                  ;***********************************************************************
 30001                                  ; $P_Search_KEYorSW:
 30002                                  ;
 30003                                  ; Function: Seach specified keyword or switch from CONTROL
 30004                                  ;
 30005                                  ; Input:     ES:BX -> CONTROL block
 30006                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30007                                  ;
 30008                                  ; Output:    CY = 1 : not match
 30009                                  ;
 30010                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30011                                  ;***********************************************************************
 30012                                  
 30013                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30014                                  	; 14/06/2023
 30015                                  $P_Search_KEYorSW:
 30016 000044D8 55                      	push	bp			;AN000;
 30017 000044D9 51                      	push	cx			;AN000;
 30018 000044DA 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30019                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30020                                  	; 14/06/2023
 30021                                  	;xor	ch,ch			;AN000; and set it to cx
 30022                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30023 000044DE 08C9                    	or	cl,cl
 30024 000044E0 740E                    	jz	short $P_KEYorSW_Not_Found
 30025                                  					;AN000; then indicate not found by CY
 30026 000044E2 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30027                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30028                                  $P_KEYorSW_Loop:			;AN000;
 30029 000044E6 E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30030 000044E9 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30031 000044EB E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30032 000044EE E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30033                                  $P_KEYorSW_Not_Found:			;AN000;
 30034 000044F0 F9                      	stc				;AN000; indicate not found in synonym list
 30035 000044F1 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30036                                  $P_KEYorSW_Found:			;AN000;
 30037 000044F3 2E892E[2586]            	mov	[cs:$P_Found_SYNONYM],bp
 30038                                  					;AC034; set synonym pointer
 30039                                  	; 27/04/2023
 30040                                  	; cf = 0
 30041                                  	;clc				;AN000; indicate found
 30042                                  $P_KEYorSW_Exit:			;AN000;
 30043 000044F8 59                      	pop	cx			;AN000;
 30044 000044F9 5D                      	pop	bp			;AN000;
 30045 000044FA C3                      	retn				;AN000;
 30046                                  
 30047                                  ;***********************************************************************
 30048                                  ; $P_MoveBP_NUL
 30049                                  ;***********************************************************************
 30050                                  
 30051                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30052                                  
 30053                                  $P_MoveBP_NUL:
 30054                                  $P_MBP_Loop:				;AN000;
 30055                                  	;cmp	byte [es:bp+0],0
 30056 000044FB 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30057 00004500 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30058 00004502 45                      	inc	bp			;AN000; until
 30059 00004503 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30060                                  $P_MBP_Exit:				;AN000;
 30061 00004505 45                      	inc	bp			;AN000; bp points to next to NULL
 30062 00004506 C3                      	retn				;AN000;
 30063                                  
 30064                                  ;***********************************************************************
 30065                                  ; $P_Chk_SW_Control
 30066                                  ;
 30067                                  ; Function: Parse CONTROL block for a switch
 30068                                  ;
 30069                                  ; Input:     ES:BX -> CONTROL block
 30070                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30071                                  ;
 30072                                  ; Output:    CY = 1 : not match
 30073                                  ;
 30074                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30075                                  ;
 30076                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30077                                  ;***********************************************************************
 30078                                  
 30079                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30080                                  
 30081                                  $P_Chk_SW_Control:
 30082 00004507 2E800E[1E86]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 30083                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 30084 0000450D E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 30085 00004510 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 30086                                  
 30087 00004512 2E8026[1E86]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 30088                                  	;and	byte [cs:$P_Flags2],0EFh
 30089                                  					;AC034; reset the indicator previously set
 30090 00004518 50                      	push	ax			;AN000;       /switch:
 30091 00004519 2EA1[2186]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 30092 0000451D 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 30093 0000451F 2E0106[1F86]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 30094 00004524 58                      	pop	ax			;AN000;
 30095                                  
 30096 00004525 2E8B36[2186]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 30097                                  	;cmp	byte [cs:si],0
 30098 0000452A 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 30099 0000452E 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 30100                                  
 30101                                  	;cmp	byte [cs:si],':'
 30102 00004530 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 30103                                  					;AN000; if no, the switch terminated by colon ?
 30104 00004535 7509                    	jne	short $P_Chk_if_data_required
 30105                                  					;AN000; if yes,
 30106                                  
 30107 00004537 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax
 30108                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 30109 0000453E EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 30110                                  
 30111                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 30112                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 30113                                  	; 27/04/2023
 30114 00004540 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 30115 00004544 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 30116                                  
 30117                                  	;;test	word [es:bx],1 ; $P_Optional
 30118                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 30119 00004546 26F60701                	test	byte [es:bx],$P_Optional
 30120                                  					;AN019; see if no value is valid
 30121 0000454A 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 30122                                  
 30123 0000454C 2EC706[1286]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30124                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 30125 00004553 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 30126                                  
 30127                                  $P_CSW00:				;AN000;
 30128 00004555 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 30129 00004558 F8                      	clc				;AN000; indicate match
 30130                                  	;jmp	short $P_Chk_SW_Single_Exit
 30131 00004559 C3                      	retn	; 31/03/2023		;AN000;
 30132                                  	; 31/03/2023
 30133                                  ;$P_Chk_SW_Err0: 			;AN000;
 30134                                  ;	stc				;AN000; not found in switch synonym list
 30135                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 30136                                  ;	retn	; 31/03/2023		;AN000;
 30137                                  	
 30138                                  $P_Chk_SW_Exit: 			;AN000;
 30139 0000455A 50                      	push	ax			;AN000;
 30140                                  	; 31/03/2023
 30141 0000455B B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30142                                  	;;mov	al,3
 30143                                  	;;mov	ah,0FFh
 30144                                  	;mov	al,$P_String		;AN000; set
 30145                                  	;mov	ah,$P_No_Tag		;AN000;    result
 30146 0000455E E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 30147 00004561 58                      	pop	ax			;AN000;
 30148 00004562 F8                      	clc				;AN000;
 30149                                  	; 31/03/2023
 30150                                  $P_Chk_SW_Err0:
 30151                                  $P_Chk_SW_Single_Exit:			;AN000;
 30152 00004563 C3                      	retn				;AN000;
 30153                                  
 30154                                  ;***********************************************************************
 30155                                  ; $P_Fill_Result
 30156                                  ;
 30157                                  ; Function: Fill the result buffer
 30158                                  ;
 30159                                  ; Input:    AH = Item tag
 30160                                  ;	    AL = type
 30161                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 30162                                  ;		  AL = 2: DX has index(offset) into value list
 30163                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 30164                                  ;		  AL = 7: DX has year, CL has month and CH has date
 30165                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 30166                                  ;			  amd CH has hundredths
 30167                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 30168                                  ;	    ES:BX -> CONTROL block
 30169                                  ;
 30170                                  ; Output:   None
 30171                                  ;
 30172                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 30173                                  ;
 30174                                  ; Vars: $P_DX(W)
 30175                                  ;***********************************************************************
 30176                                  
 30177                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30178                                  
 30179                                  $P_Fill_Result:
 30180 00004564 57                      	push	di			;AN000;
 30181 00004565 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 30182                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 30183 00004569 2E893E[1686]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 30184                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 30185                                  	;;mov	[es:di],al		;AN000; store type
 30186                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 30187                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 30188                                  	; 31/03/2023
 30189 0000456E 268905                  	mov	[es:di],ax
 30190 00004571 50                      	push	ax			;AN000;
 30191 00004572 2EA1[2586]              	mov	ax,[cs:$P_Found_SYNONYM]
 30192                                  					;AC034; if yes,
 30193 00004576 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 30194                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 30195 0000457A 58                      	pop	ax			;AN000;
 30196                                  $P_RLT04:				;AN000;
 30197                                  	;cmp	al,1
 30198 0000457B 3C01                    	cmp	al,$P_Number		;AN000; if number
 30199 0000457D 750A                    	jne	short $P_RLT00		;AN000;
 30200                                  $P_RLT02:				;AN000;
 30201 0000457F 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30202                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 30203 00004583 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 30204                                  	;mov	[es:di+6],cx		;AN000;	number
 30205 00004587 EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 30206                                  $P_RLT00:				;AN000;
 30207                                  	;cmp	al,2
 30208 00004589 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 30209 0000458B 7506                    	jne	short $P_RLT01		;AN000;
 30210 0000458D 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30211                                  	;mov	[es:di+4],dx		;AN000; then store list index
 30212 00004591 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 30213                                  $P_RLT01:				;AN000;
 30214                                  	;cmp	al,7
 30215 00004593 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 30216 00004595 74E8                    	je	short $P_RLT02		;AN000;
 30217                                  	;cmp	al,8
 30218 00004597 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 30219 00004599 74E4                    	je	short $P_RLT02		;AN000;
 30220                                  	;cmp	al,6
 30221 0000459B 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 30222 0000459D 7506                    	jne	short $P_RLT03		;AN000;
 30223                                  
 30224 0000459F 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 30225                                  	;mov	[es:di+4],dl		;AN000; store drive number
 30226 000045A3 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 30227                                  
 30228                                  $P_RLT03:				;AN000;
 30229                                  	;cmp	al,4
 30230 000045A5 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 30231 000045A7 750F                    	jne	short $P_RLT05		;AN000;
 30232                                  
 30233 000045A9 2EA1[1F86]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 30234 000045AD 40                      	inc	ax			;AN000; skip left Parentheses
 30235 000045AE 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 30236                                  	;mov	[es:di+4],ax		;AN000; store offset
 30237 000045B2 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 30238                                  	;mov	[es:di+6],ds		;AN000; store segment
 30239 000045B6 EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 30240                                  
 30241                                  $P_RLT05:				;AN000;
 30242                                  ;------------------------  AL = 3, 5, or 9
 30243 000045B8 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 30244                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 30245 000045BC 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 30246                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 30247                                  
 30248 000045C0 50                      	push	ax			;AN000;
 30249 000045C1 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 30250                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 30251 000045C6 7404                    	jz	short $P_RLT_CAP00	;AN000;
 30252                                  
 30253                                  	;mov	al,4
 30254 000045C8 B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 30255 000045CA EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 30256                                  
 30257                                  $P_RLT_CAP00:				;AN000;
 30258 000045CC 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 30259                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 30260 000045D1 7405                    	jz	short $P_RLT_CAP01	;AN000;
 30261                                  
 30262                                  	;mov	al,2
 30263 000045D3 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 30264                                  $P_RLT_CAP02:				;AN000;
 30265 000045D5 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 30266                                  $P_RLT_CAP01:				;AN000;
 30267 000045D8 58                      	pop	ax			;AN000;
 30268 000045D9 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 30269                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 30270 000045DE 7403                    	jz	short $P_RLT_Exit	;AN000;
 30271                                  
 30272 000045E0 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 30273                                  $P_RLT_Exit:				;AN000;
 30274 000045E3 5F                      	pop	di			;AN000;
 30275 000045E4 C3                      	retn				;AN000;
 30276                                  
 30277                                  ;***********************************************************************
 30278                                  ; $P_Check_Match_Flags
 30279                                  ;
 30280                                  ; Function:  Check the mutch_flags and make the exit code and set the
 30281                                  ;	     result buffer
 30282                                  ;
 30283                                  ;	    Check for types in this order:
 30284                                  ;		Complex
 30285                                  ;		Date
 30286                                  ;		Time
 30287                                  ;		Drive
 30288                                  ;		Filespec
 30289                                  ;		Quoted String
 30290                                  ;		Simple String
 30291                                  ;
 30292                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30293                                  ;	     ES:BX -> CONTROL block
 30294                                  ;
 30295                                  ; Output:    None
 30296                                  ;
 30297                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 30298                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 30299                                  ;	     $P_Drive_Format
 30300                                  ;***********************************************************************
 30301                                  
 30302                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30303                                  
 30304                                  $P_Check_Match_Flags:
 30305 000045E5 2EC606[EB86]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 30306                                  					;AN033;AC034;; clear filespec error flag.
 30307 000045EB 50                      	push	ax			;AN000;
 30308                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30309 000045EC 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 30310 000045EF 09C0                    	or	ax,ax			;AC035; test ax for zero
 30311 000045F1 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 30312 000045F3 50                      	push	ax			;AN000; (tm12)
 30313 000045F4 53                      	push	bx			;AN000; (tm12)
 30314 000045F5 52                      	push	dx			;AN000; (tm12)
 30315 000045F6 57                      	push	di			;AN000; (tm12)
 30316 000045F7 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax
 30317                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30318                                  	; 31/03/2023
 30319 000045FE B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30320                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30321                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30322 00004601 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30323 00004604 5F                      	pop	di			;AN000; (tm12)
 30324 00004605 5A                      	pop	dx			;AN000; (tm12)
 30325 00004606 5B                      	pop	bx			;AN000; (tm12)
 30326 00004607 58                      	pop	ax			;AN000; (tm12)
 30327                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30328                                  	; 31/03/2023
 30329                                  $P_Bridge:	; 18/04/2023		;AN000;
 30330 00004608 E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30331                                  $P_Mat: 				;AN000; (tm12)
 30332                                  $P_Match01:				;AN000;
 30333                                  	;test	ax,1000h
 30334 0000460B A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30335 0000460E 7412                    	jz	short $P_Match02	;AN000;
 30336 00004610 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30337                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30338 00004617 E86503                  	call	$P_Date_Format		;AN000; do process
 30339 0000461A 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30340                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30341                                  	; 18/04/2023
 30342 00004620 75E6                    	jne	short $P_Bridge		;AN000;
 30343                                  $P_Match02:				;AN000;
 30344                                  	;test	ax,800h
 30345 00004622 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30346 00004625 7412                    	jz	short $P_Match03	;AN000;
 30347 00004627 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30348                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30349 0000462E E86004                  	call	$P_Time_Format		;AN000; do process
 30350 00004631 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30351                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30352                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30353                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30354                                  	; 31/03/2023
 30355 00004637 756E                    	jne	short $P_Match_Exit
 30356                                  ;$P_Bridge:				;AN000;
 30357                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30358                                  $P_Match03:				;AN000;
 30359                                  	;test	ax,8000h
 30360 00004639 A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30361 0000463C 7412                    	jz	short $P_Match04	;AN000;
 30362 0000463E 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30363                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30364 00004645 E82C01                  	call	$P_Value		;AN000; do process
 30365 00004648 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30366                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30367 0000464E 7557                    	jne	short $P_Match_Exit	;AN000;
 30368                                  $P_Match04:				;AN000;
 30369                                  	;test	ax,4000h
 30370 00004650 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30371 00004653 7412                    	jz	short $P_Match05	;AN000;
 30372 00004655 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30373                                  					;AC034; assume no error
 30374 0000465C E8F100                  	call	$P_SValue		;AN000; do process
 30375 0000465F 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30376                                  					;AC034; if error, examine the next type
 30377 00004665 7540                    	jne	short $P_Match_Exit	;AN000;
 30378                                  $P_Match05:				;AN000;
 30379                                  	;test	ax,100h
 30380 00004667 A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30381 0000466A 7415                    	jz	short $P_Match06	;AN000;
 30382 0000466C 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30383                                  					;AC034; assume no error
 30384 00004673 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 30385 00004676 E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30386 00004679 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30387                                  					;AC034; if error, examinee the next type
 30388 0000467F 7526                    	jne	short $P_Match_Exit	;AN000;
 30389                                  $P_Match06:				;AN000;
 30390                                  	;test	ax,200h
 30391 00004681 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 30392 00004684 7412                    	jz	short $P_Match07	;AN000;
 30393 00004686 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30394                                  					;AC034; assume no error
 30395 0000468D E84E05                  	call	$P_File_Format		;AN000; do process
 30396 00004690 2E833E[1286]09          	cmp	word [cs:$P_RC],$P_Syntax
 30397                                  					;AC034; if error, examine the next type
 30398 00004696 750F                    	jne	short $P_Match_Exit	;AN000;
 30399                                  $P_Match07:				;AN000;
 30400                                  $P_Match08:				;AN000;
 30401                                  	;test	ax,2000h
 30402 00004698 A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 30403 0000469B 740A                    	jz	short $P_Match09	;AN000;
 30404 0000469D 2EC706[1286]0000        	mov	word [cs:$P_RC],$P_No_Error
 30405                                  					;AC034; assume no error
 30406 000046A4 E8D601                  	call	$P_Simple_String	;AN000; do process
 30407                                  $P_Match09:				;AN000;
 30408                                  $P_Match_Exit:				;AN000;
 30409 000046A7 2E833E[EB86]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 30410                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 30411 000046AD 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30412 000046AF 2E833E[1286]00          	cmp	word [cs:$P_RC],$P_No_Error
 30413                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 30414 000046B5 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30415 000046B7 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax
 30416                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 30417                                  $P_Match2_Exit: 			;AN033;
 30418 000046BE 58                      	pop	ax			;AN000;
 30419 000046BF C3                      	retn
 30420                                  
 30421                                  ;***********************************************************************
 30422                                  ; $P_Remove_Colon;
 30423                                  ;
 30424                                  ; Function: Remove colon at end
 30425                                  ;
 30426                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 30427                                  ;
 30428                                  ; Output:   None
 30429                                  ;
 30430                                  ; Use:	$P_Chk_DBCS
 30431                                  ;***********************************************************************
 30432                                  
 30433                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30434                                  
 30435                                  $P_Remove_Colon:
 30436 000046C0 50                      	push	ax			;AN000;
 30437 000046C1 56                      	push	si			;AN000;
 30438                                  $P_RCOL_Loop:				;AN000;
 30439 000046C2 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30440 000046C5 08C0                    	or	al,al			;AN000; end of string ?
 30441 000046C7 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30442                                  
 30443 000046C9 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30444 000046CB 750E                    	jne	short $P_RCOL00		;AN000;
 30445                                  
 30446                                  	;cmp	byte [cs:si+1],0
 30447 000046CD 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30448 000046D2 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30449                                  
 30450 000046D4 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30451                                  	; 31/03/2023
 30452                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30453                                  $P_RCOL_Exit:
 30454 000046D8 5E                      	pop	si
 30455 000046D9 58                      	pop	ax
 30456 000046DA C3                      	retn
 30457                                  
 30458                                  $P_RCOL00:				;AN000;
 30459 000046DB E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30460 000046DE 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30461                                  
 30462 000046E0 46                      	inc	si			;AN000; if yes, skip trailing byte
 30463                                  $P_RCOL01:				;AN000;
 30464 000046E1 46                      	inc	si			;AN000; si points to next byte
 30465 000046E2 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30466                                  
 30467                                  	; 31/03/2023
 30468                                  ;$P_RCOL_Exit:				;AN000;
 30469                                  	;pop	si			;AN000;
 30470                                  	;pop	ax			;AN000;
 30471                                  	;retn
 30472                                  
 30473                                  ;***********************************************************************
 30474                                  ; $P_Do_CAPS_String;
 30475                                  ;
 30476                                  ; Function: Perform capitalization along with the file case map table
 30477                                  ;	    or character case map table.
 30478                                  ;
 30479                                  ; Input:    AL = 2 : Use character table
 30480                                  ;	    AL = 4 : Use file table
 30481                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30482                                  ;
 30483                                  ; Output:   None
 30484                                  ;
 30485                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30486                                  ;***********************************************************************
 30487                                  
 30488                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30489                                  
 30490                                  $P_Do_CAPS_String:
 30491 000046E4 56                      	push	si			;AN000;
 30492 000046E5 52                      	push	dx			;AN000;
 30493 000046E6 88C2                    	mov	dl,al			;AN000; save info id
 30494                                  $P_DCS_Loop:				;AN000;
 30495 000046E8 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30496 000046EB E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30497 000046EE 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30498                                  
 30499 000046F0 08C0                    	or	al,al			;AN000; end of string ?
 30500 000046F2 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30501                                  
 30502 000046F4 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30503 000046F7 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30504 000046FA EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30505                                  $P_DCS00:				;AN000;
 30506 000046FC 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30507                                  $P_DCS01:				;AN000;
 30508 000046FD 46                      	inc	si			;AN000; si point to next byte
 30509 000046FE EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30510                                  $P_DCS_Exit:				;AN000;
 30511 00004700 5A                      	pop	dx			;AN000;
 30512 00004701 5E                      	pop	si			;AN000;
 30513 00004702 C3                      	retn
 30514                                  
 30515                                  ;***********************************************************************
 30516                                  ; $P_Do_CAPS_Char;
 30517                                  ;
 30518                                  ; Function: Perform capitalization along with the file case map table
 30519                                  ;	    or character case map table.
 30520                                  ;
 30521                                  ; Input:    DL = 2 : Use character table
 30522                                  ;	    DL = 4 : Use file table
 30523                                  ;	    AL = character to be capitalized
 30524                                  ;
 30525                                  ; Output:   None
 30526                                  ;
 30527                                  ; Use:	INT 21h /w AH=65h
 30528                                  ;***********************************************************************
 30529                                  
 30530                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30531                                  
 30532                                  $P_Do_CAPS_Char:
 30533 00004703 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30534 00004705 730B                    	jae	short $P_DCC_Go		;AN000;
 30535                                  
 30536 00004707 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30537 00004709 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30538                                  
 30539 0000470B 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30540 0000470D 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30541                                  
 30542 0000470F 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30543                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30544                                  	; 18/04/2023
 30545 00004711 C3                      	retn
 30546                                  
 30547                                  $P_DCC_Go:				;AN000;
 30548 00004712 53                      	push	bx			;AN000;
 30549 00004713 06                      	push	es			;AN000;
 30550 00004714 57                      	push	di			;AN000;
 30551                                  	; 18/04/2023
 30552 00004715 8D3E[DD86]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30553 00004719 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30554 0000471C 7404                    	je	short $P_DCC00		;AN000;
 30555                                  	; 27/04/2023
 30556 0000471E 8D3E[D886]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 30557                                  $P_DCC00:				;AN000;
 30558 00004722 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30559 00004725 7417                    	je	short $P_DCC01		;AN000; if no,
 30560                                  
 30561                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30562                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30563                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30564                                  
 30565 00004727 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30566 00004728 51                      	push	cx			;AN000;
 30567 00004729 52                      	push	dx			;AN000;
 30568 0000472A 0E                      	push	cs			;AC036; pass current base seg into
 30569                                  					;(Note: this used to push CS. BUG...
 30570 0000472B 07                      	pop	es			;AN000;   ES reg, required for
 30571                                  					;get extended country information
 30572                                  	; 31/03/2023
 30573 0000472C B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30574                                  	;mov	ah,65h
 30575 0000472E 88D0                    	mov	al,dl			;AN000; upper case table
 30576                                  	;mov	bx,-1 ; 0FFFFh
 30577                                  	;mov	cx,5
 30578                                  	;mov	dx,-1
 30579 00004730 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30580 00004733 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30581 00004736 BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30582                                  					;DI already set to point to buffer
 30583 00004739 CD21                    	int	21h			;AN000; es:di point to buffer that
 30584                                  					;now has been filled in with info
 30585 0000473B 5A                      	pop	dx			;AN000;
 30586 0000473C 59                      	pop	cx			;AN000;
 30587 0000473D 58                      	pop	ax			;AN000;
 30588                                  
 30589                                  $P_DCC01:				;AN000;
 30590                                  
 30591                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30592                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30593                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30594                                  
 30595 0000473E 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30596                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 30597 00004742 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30598                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 30599 00004746 43                      	inc	bx			;AC035; add '2' to
 30600 00004747 43                      	inc	bx			;AC035;  BX reg
 30601                                  					;AN000; skip length field
 30602 00004748 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30603                                  	;xlat	es:[bx] 		;AN000; perform case map
 30604                                  	; 31/03/2023
 30605 0000474A 26D7                    	es	xlat
 30606                                  
 30607 0000474C 5F                      	pop	di			;AN000;
 30608 0000474D 07                      	pop	es			;AN000;
 30609 0000474E 5B                      	pop	bx			;AN000;
 30610                                  $P_CAPS_Ret:				;AN000;
 30611 0000474F C3                      	retn
 30612                                  
 30613                                  ;***********************************************************************
 30614                                  ; $P_Value / $P_SValue
 30615                                  ;
 30616                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30617                                  ;	     and make result buffer.
 30618                                  ;	     $P_SValue is an entry point for the signed value
 30619                                  ;	     and this will simply call $P_Value after the handling
 30620                                  ;	     of the sign character, "+" or "-"
 30621                                  ;
 30622                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30623                                  ;	     ES:BX -> CONTROL block
 30624                                  ;
 30625                                  ; Output:    None
 30626                                  ;
 30627                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30628                                  ;
 30629                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30630                                  ;***********************************************************************
 30631                                  
 30632                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30633                                  $P_SValue:
 30634 00004750 50                      	push	ax			;AN000;
 30635                                  	;or	byte [cs:$P_Flags2],80h
 30636 00004751 2E800E[1E86]80          	or	byte [cs:$P_Flags2],$P_Signed
 30637                                  					;AC034; indicate a signed numeric
 30638                                  	;and	byte [cs:$P_Flags2],0FDh
 30639 00004757 2E8026[1E86]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30640                                  					;AC034; assume positive value
 30641 0000475D 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30642 00004760 3C2B                    	cmp	al,'+' ; 2Bh
 30643                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30644 00004762 740A                    	je	short $P_SVal00		;AN000;
 30645                                  
 30646 00004764 3C2D                    	cmp	al,'-' ; 2Dh
 30647                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30648 00004766 7507                    	jne	short $P_Sval01		;AN000; else
 30649                                  
 30650 00004768 2E800E[1E86]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30651                                  					;AC034; set this is negative value
 30652                                  $P_SVal00:				;AN000;
 30653 0000476E 46                      	inc	si			;AN000; skip sign char
 30654                                  $P_Sval01:				;AN000;
 30655 0000476F E80200                  	call	$P_Value		;AN000; and process value
 30656 00004772 58                      	pop	ax			;AN000;
 30657 00004773 C3                      	retn				;AN000;
 30658                                  
 30659                                  ;***********************************************************************
 30660                                  
 30661                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30662                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30663                                  
 30664                                  $P_Value:
 30665 00004774 50                      	push	ax			;AN000;
 30666 00004775 51                      	push	cx			;AN000;
 30667 00004776 52                      	push	dx			;AN000;
 30668 00004777 56                      	push	si			;AN000;
 30669 00004778 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30670 0000477A 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30671 0000477C 53                      	push	bx			;AN000; save control pointer
 30672                                  $P_Value_Loop:				;AN000;
 30673 0000477D 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30674 00004780 08C0                    	or	al,al			;AN000; end of line ?
 30675 00004782 7442                    	jz	short $P_Value00	;AN000;
 30676                                  
 30677 00004784 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30678 00004787 7239                    	jc	short $P_Value_Err0	;AN000;
 30679                                  
 30680 00004789 30E4                    	xor	ah,ah			;AN000;
 30681 0000478B 89C5                    	mov	bp,ax			;AN000; save binary number
 30682 0000478D D1E2                    	shl	dx,1			;AN000; to have 2*x
 30683 0000478F D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30684 00004791 E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30685 00004794 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30686                                  
 30687 00004796 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 30688 00004798 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 30689 0000479A D1E2                    	shl	dx,1			;AN000; to have 4*x
 30690 0000479C D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30691 0000479E E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30692 000047A1 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30693                                  
 30694 000047A3 D1E2                    	shl	dx,1			;AN000; to have 8*x
 30695 000047A5 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30696 000047A7 E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30697 000047AA 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30698                                  
 30699 000047AC 01DA                    	add	dx,bx			;AN000; now have 10*x
 30700 000047AE 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 30701 000047B0 E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30702 000047B3 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30703                                  
 30704 000047B5 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 30705 000047B7 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30706 000047BA E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30707 000047BD 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30708                                  
 30709 000047BF 46                      	inc	si			;AN000; update pointer
 30710 000047C0 EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30711                                  
 30712                                  $P_Value_Err0:				;AN000;
 30713 000047C2 5B                      	pop	bx			;AN000;
 30714 000047C3 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30715                                  
 30716                                  $P_Value00:				;AN000;
 30717 000047C6 5B                      	pop	bx			;AN000; restore control pointer
 30718 000047C7 2EF606[1E86]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30719                                  					;AC034; here cx,dx = 32bit value
 30720 000047CD 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30721                                  
 30722 000047CF F7D1                    	not	cx			;AN000; +
 30723 000047D1 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30724 000047D3 83C201                  	add	dx,1			;AN000; |
 30725 000047D6 83D100                  	adc	cx,0			;AN000; +
 30726                                  $P_Value01:				;AN000; / nval =0
 30727 000047D9 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30728                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30729 000047DD 268A04                  	mov	al,[es:si]		;AN000; get nval
 30730 000047E0 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30731 000047E2 7505                    	jne	short $P_Value02	;AN000;
 30732                                  
 30733                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30734                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30735                                  	; 31/03/2023
 30736 000047E4 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30737 000047E7 EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30738                                  
 30739                                  $P_Value02:				;AN000; / nval = 1
 30740 000047E9 46                      	inc	si			;AN000;
 30741 000047EA 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30742 000047ED 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30743 000047EF 745D                    	je	short $P_Value03	;AN000; (tm07)
 30744                                  
 30745 000047F1 46                      	inc	si			;AN000; si points to 1st item_tag
 30746                                  $P_Val02_Loop:				;AN000;
 30747 000047F2 2EF606[1E86]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30748                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30749 000047F8 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30750                                  
 30751 000047FA 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30752                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30753 000047FE 723B                    	jb	short $P_Val02_Next	;AN000;
 30754 00004800 7706                    	ja	short $P_Val_In		;AN000;
 30755                                  
 30756 00004802 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30757                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30758 00004806 7233                    	jb	short $P_Val02_Next	;AN000;
 30759                                  
 30760                                  $P_Val_In:				;AN000;
 30761 00004808 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30762                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30763 0000480C 772D                    	ja	short $P_Val02_Next	;AN000;
 30764 0000480E 7224                    	jb	short $P_Val_Found	;AN000;
 30765                                  
 30766 00004810 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30767                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30768 00004814 7725                    	ja	short $P_Val02_Next	;AN000;
 30769                                  
 30770 00004816 EB1C                    	jmp	short $P_Val_Found	;AN000;
 30771                                  
 30772                                  $P_Val02_Sign:				;AN000;
 30773 00004818 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30774                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30775 0000481C 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30776 0000481E 7F06                    	jg	short $P_SVal_In	;AN000;
 30777                                  
 30778 00004820 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30779                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30780 00004824 7C15                    	jl	short $P_Val02_Next	;AN000;
 30781                                  
 30782                                  $P_SVal_In:				;AN000;
 30783 00004826 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30784                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30785 0000482A 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30786 0000482C 7C06                    	jl	short $P_Val_Found	;AN000;
 30787                                  
 30788 0000482E 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30789                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30790 00004832 7F07                    	jg	short $P_Val02_Next	;AN000;
 30791                                  
 30792                                  	;jmp	short $P_Val_Found	;AN000;
 30793                                  	; 27/04/2023
 30794                                  $P_Val_Found:				;AN000;
 30795 00004834 B001                    	mov	al,$P_Number ; 1	;AN000;
 30796 00004836 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30797 00004839 EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30798                                  
 30799                                  $P_Val02_Next:				;AN000;
 30800 0000483B 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30801 0000483E FEC8                    	dec	al			;AN000; loop nrng times in AL
 30802 00004840 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30803                                  					; / Not found
 30804 00004842 2EC706[1286]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30805                                  	;mov	word [cs:$P_RC],6	;AC034;
 30806                                  	
 30807                                  	;mov	al,$P_Number ; 1	;AN000;
 30808                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30809                                  	; 31/03/2023
 30810 00004849 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30811 0000484C EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30812                                  
 30813                                  	; 27/04/2023
 30814                                  ;$P_Val_Found:				;AN000;
 30815                                  	;mov	al,$P_Number ; 1	;AN000;
 30816                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30817                                  	;jmp	short $P_Value_Exit	;AN000;
 30818                                  
 30819                                  $P_Value03:				;AN000; / nval = 2
 30820                                  $P_Value04:				;AN000; / nval = 3 or else
 30821                                  $P_Value_Err:				;AN000;
 30822 0000484E 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30823                                  					;AC034;
 30824                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30825                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30826                                  	; 31/03/2023
 30827 00004855 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30828                                  $P_Value_Exit:				;AN000;
 30829 00004858 E809FD                  	call	$P_Fill_Result		;AN000;
 30830 0000485B 5E                      	pop	si			;AN000;
 30831 0000485C 5A                      	pop	dx			;AN000;
 30832 0000485D 59                      	pop	cx			;AN000;
 30833 0000485E 58                      	pop	ax			;AN000;
 30834 0000485F C3                      	retn				;AN000;
 30835                                  
 30836                                  ;***********************************************************************
 30837                                  ; $P_Check_OVF
 30838                                  ;
 30839                                  ; Function:  Check if overflow is occurred with consideration of
 30840                                  ;	     signed or un-signed numeric value
 30841                                  ;
 30842                                  ; Input:     Flag register
 30843                                  ;
 30844                                  ; Output:    CY = 1  :	Overflow
 30845                                  ;
 30846                                  ; Vars:     $P_Flags(R)
 30847                                  ;***********************************************************************
 30848                                  
 30849                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30850                                  $P_Check_OVF:
 30851 00004860 9C                      	pushf				;AN000;
 30852 00004861 2EF606[1E86]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30853                                  					;AC034; is it negative value ?
 30854 00004867 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30855 00004869 9D                      	popf				;AN000; by the CY bit
 30856 0000486A C3                      	retn				;AN000;
 30857                                  $P_COVF:				;AN000;
 30858 0000486B 9D                      	popf				;AN000; else,
 30859 0000486C 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30860 0000486E F8                      	clc				;AN000; indicate it with CY bit
 30861 0000486F C3                      	retn				;AN000; CY=0 means no overflow
 30862                                  $P_0099Err:	; 31/03/2023
 30863                                  $P_COVF00:				;AN000;
 30864 00004870 F9                      	stc				;AN000; and CY=1 means overflow
 30865                                  $P_0099Err2:	; 31/03/2023
 30866 00004871 C3                      	retn				;AN000;
 30867                                  
 30868                                  ;***********************************************************************
 30869                                  ; $P_0099;
 30870                                  ;
 30871                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30872                                  ;
 30873                                  ; Input:     AL = character code
 30874                                  ;
 30875                                  ; Output:    CY = 1 : AL is not number
 30876                                  ;	     CY = 0 : AL contains binary value
 30877                                  ;***********************************************************************
 30878                                  
 30879                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30880                                  $P_0099:
 30881 00004872 3C30                    	cmp	al,"0"                  ;AN000;
 30882                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30883                                  	; 31/03/2023
 30884 00004874 72FB                    	jb	short $P_0099Err2
 30885                                  
 30886 00004876 3C39                    	cmp	al,"9"                  ;AN000;
 30887 00004878 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30888                                  
 30889 0000487A 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 30890                                  	; 31/03/2023
 30891                                  	;clc				;AN000; indicate no error
 30892 0000487C C3                      	retn				;AN000;
 30893                                  	 ;31/03/2023
 30894                                  ;$P_0099Err:				;AN000;
 30895                                  ;	stc				;AN000; indicate error
 30896                                  ;	retn				;AN000;
 30897                                  
 30898                                  ;***********************************************************************
 30899                                  ; $P_Simple_String
 30900                                  ;
 30901                                  ; Function:  See value list for the simple string
 30902                                  ;	     and make result buffer.
 30903                                  ;
 30904                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30905                                  ;	     ES:BX -> CONTROL block
 30906                                  ;
 30907                                  ; Output:    None
 30908                                  ;
 30909                                  ; Use:	$P_Fill_Result, $P_String_Comp
 30910                                  ;
 30911                                  ; Vars: $P_RC(W)
 30912                                  ;***********************************************************************
 30913                                  
 30914                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30915                                  
 30916                                  $P_Simple_String:
 30917 0000487D 50                      	push	ax			;AN000;
 30918 0000487E 53                      	push	bx			;AN000;
 30919 0000487F 52                      	push	dx			;AN000;
 30920 00004880 57                      	push	di			;AN000;
 30921 00004881 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30922                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 30923 00004885 268A05                  	mov	al,[es:di]		;AN000; get nval
 30924 00004888 08C0                    	or	al,al			;AN000; no value list ?
 30925 0000488A 7502                    	jnz	short $P_Sim00		;AN000; then
 30926                                  	; 31/03/2023
 30927                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30928 0000488C EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 30929                                  $P_Sim00:				;AN000;
 30930 0000488E 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 30931 00004890 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 30932                                  
 30933 00004892 47                      	inc	di			;AN000;
 30934 00004893 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 30935 00004896 B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 30936 00004898 F6E4                    	mul	ah			;AN000;  Skip nrng field
 30937 0000489A 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 30938 0000489B 01C7                    	add	di,ax			;AN000; di points to nnval
 30939 0000489D 268A05                  	mov	al,[es:di]		;AN000; get nnval
 30940 000048A0 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 30941 000048A2 F6E4                    	mul	ah			;AN000; Skip nnval field
 30942 000048A4 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 30943 000048A5 01C7                    	add	di,ax			;AN000; di points to nstrval
 30944 000048A7 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 30945 000048AA 47                      	inc	di			;AC035; add '2' to
 30946 000048AB 47                      	inc	di			;AC035;  DI reg
 30947                                  					;AN000; di points to 1st string in list
 30948                                  $P_Sim_Loop:				;AN000;
 30949 000048AC 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 30950 000048AF E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 30951 000048B2 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 30952                                  
 30953 000048B4 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 30954 000048B7 FEC8                    	dec	al			;AN000; loop nstval times in AL
 30955 000048B9 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 30956                                  					;AN000; / Not found
 30957 000048BB 2EC706[1286]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 30958                                  	;mov	[cs:$P_RC],8		;AC034;
 30959                                  	; 31/03/2023
 30960                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30961 000048C2 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 30962                                  $P_Sim_Found:				;AN000;
 30963 000048C4 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 30964 000048C8 B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 30965 000048CA 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 30966 000048CD EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 30967                                  $P_Sim01:				;AN000;
 30968 000048CF 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax
 30969                                  	;mov	word [cs:$P_RC],9	;AC034;
 30970                                  $P_Sim_Exit:
 30971                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30972                                  ;$P_Sim_Exit:				;AN000;
 30973                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30974                                  	; 31/03/2023
 30975 000048D6 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30976                                  $P_Sim_Exit0:				;AN000;
 30977 000048D9 E888FC                  	call	$P_Fill_Result		;AN000;
 30978 000048DC 5F                      	pop	di			;AN000;
 30979 000048DD 5A                      	pop	dx			;AN000;
 30980 000048DE 5B                      	pop	bx			;AN000;
 30981 000048DF 58                      	pop	ax			;AN000;
 30982 000048E0 C3                      	retn				;AN000;
 30983                                  
 30984                                  ;***********************************************************************
 30985                                  ; $P_String_Comp:
 30986                                  ;
 30987                                  ; Function:  Compare two string
 30988                                  ;
 30989                                  ; Input:     psdata_seg:SI -> 1st string
 30990                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 30991                                  ;	     ES:BX -> CONTROL block
 30992                                  ;
 30993                                  ; Output:    CY = 1 if not match
 30994                                  ;
 30995                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 30996                                  ;
 30997                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 30998                                  ;***********************************************************************
 30999                                  
 31000                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31001                                  
 31002                                  $P_String_Comp:
 31003 000048E1 50                      	push	ax			;AN000;
 31004 000048E2 55                      	push	bp			;AN000;
 31005 000048E3 52                      	push	dx			;AN000;
 31006 000048E4 56                      	push	si			;AN000;
 31007 000048E5 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31008                                  $P_SCOM_Loop:				;AN000;
 31009 000048E7 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31010 000048EA E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31011 000048ED 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31012                                  
 31013 000048EF E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31014                                  	
 31015 000048F2 2EF606[1E86]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31016                                  					;AC034; keyword search ?
 31017 000048F8 740D                    	jz	short $P_SCOM04		;AN000;
 31018                                  
 31019                                  	;cmp	al,'=' ; 3Dh
 31020 000048FA 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31021 000048FC 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31022                                  
 31023 000048FE 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31024 00004903 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31025                                  
 31026 00004905 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31027                                  
 31028                                  $P_SCOM04:				;AN000;
 31029 00004907 2EF606[1E86]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31030                                  					;AC034; switch search ?
 31031 0000490D 740E                    	jz	short $P_SCOM03		;AN000;
 31032                                  
 31033 0000490F 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 31034 00004911 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 31035                                  
 31036 00004913 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 31037 00004918 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 31038                                  
 31039                                  $P_SCOM05:				;AN000;   found a match
 31040 0000491A 46                      	inc	si			;AN000; si points to just after "=" or ":"
 31041 0000491B EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 31042                                  
 31043                                  $P_SCOM03:				;AN000;
 31044 0000491D 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 31045 00004921 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 31046                                  
 31047 00004923 08C0                    	or	al,al			;AN000; end of line
 31048 00004925 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 31049                                  
 31050 00004927 46                      	inc	si			;AN000; update operand pointer
 31051 00004928 45                      	inc	bp			;AN000;    and synonym pointer
 31052 00004929 EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 31053                                  
 31054                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 31055 0000492B 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 31056 0000492F 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 31057                                  
 31058 00004931 46                      	inc	si			;AN000; else, load next byte
 31059 00004932 2E8A04                  	mov	al,[cs:si]		;AN000; and
 31060 00004935 45                      	inc	bp			;AN000;
 31061 00004936 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 31062 0000493A 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 31063                                  
 31064 0000493C 46                      	inc	si			;AN000; else update operand pointer
 31065 0000493D 45                      	inc	bp			;AN000; 	and synonym pointer
 31066                                  $P_SCOM01:				;AN000;
 31067 0000493E EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 31068                                  
 31069                                  $P_SCOM_Differ0:			;AN000;
 31070 00004940 2EF606[1E86]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 31071                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 31072 00004946 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 31073                                  
 31074                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31075                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 31076                                  	; 03/04/2023
 31077 00004948 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 31078 0000494D 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 31079                                  
 31080 0000494F 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 31081 00004954 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 31082                                  
 31083                                  $P_not_applicable:			;AN000;(tm10)
 31084                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31085                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 31086                                  	; 03/04/2023
 31087 00004956 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31088 0000495A 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 31089                                  
 31090 0000495C 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 31091 0000495E 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 31092                                  
 31093 00004960 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 31094                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 31095                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 31096                                  	; 01/04/2023
 31097 00004965 740E                    	je	short $P_SCOM_Same
 31098                                  $P_SCOM_Differ:
 31099 00004967 F9                      	stc
 31100 00004968 EB10                    	jmp	short $P_SCOM_Exit
 31101                                  
 31102                                  $P_SCOM02:				;AN000;
 31103 0000496A 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 31104 0000496C 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 31105                                  
 31106                                  	;cmp	byte [es:bp],':'
 31107 0000496E 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 31108                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 31109                                  	; 01/04/2023
 31110 00004973 75F2                    	jne	short $P_SCOM_Differ
 31111                                  ;$P_SCOM_Differ: 			;AN000;
 31112                                  	;stc				;AN000; indicate not found
 31113                                  	;jmp	short $P_SCOM_Exit	;AN000;
 31114                                  
 31115                                  $P_SCOM_Same:				;AN000;
 31116 00004975 2E8936[2186]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 31117                                  	; 01/04/2023
 31118                                  	;clc
 31119                                  	; cf = 0			;AN000; indicate found
 31120                                  $P_SCOM_Exit:				;AN000;
 31121 0000497A 5E                      	pop	si			;AN000;
 31122 0000497B 5A                      	pop	dx			;AN000;
 31123 0000497C 5D                      	pop	bp			;AN000;
 31124 0000497D 58                      	pop	ax			;AN000;
 31125 0000497E C3                      	retn				;AN000;
 31126                                  
 31127                                  ;***********************************************************************
 31128                                  ; $P_Date_Format
 31129                                  ;
 31130                                  ; Function:  Convert a date string to DOS date format for int 21h
 31131                                  ;	     with format validation.
 31132                                  ;
 31133                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31134                                  ;	     ES:BX -> CONTROL block
 31135                                  ;
 31136                                  ; Output:    None
 31137                                  ;
 31138                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 31139                                  ;
 31140                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 31141                                  ;***********************************************************************
 31142                                  
 31143                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31144                                  
 31145                                  $P_Date_Format:
 31146 0000497F 50                      	push	ax			;AN000;
 31147 00004980 51                      	push	cx			;AN000;
 31148 00004981 52                      	push	dx			;AN000;
 31149 00004982 56                      	push	si			;AN000;
 31150 00004983 53                      	push	bx			;AN000;
 31151 00004984 56                      	push	si			;AN000;
 31152 00004985 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 31153                                  	; 03/04/2023
 31154                                  	;pop	si			;AN000;
 31155                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31156                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31157                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31158 00004988 31F6                    	xor	si,si
 31159 0000498A 2E8936[D086]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 31160 0000498F 2E8936[D286]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 31161                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 31162 00004994 5E                      	pop	si
 31163 00004995 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 31164 00004998 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 31165 0000499A 2EA3[D086]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 31166 0000499E 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31167 000049A0 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31168 000049A2 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 31169 000049A5 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 31170 000049A7 2EA3[D286]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 31171 000049AB 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31172 000049AD 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31173 000049AF E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 31174                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 31175 000049B2 7260                    	jc	short $P_DateF_Error	;AN000;
 31176 000049B4 2EA3[D486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31177 000049B8 08DB                    	or	bl,bl			;AN000; end of line ?
 31178 000049BA 7558                    	jnz	short $P_DateF_Error	;AN000;
 31179                                  $P_DateF_YMD:				;AN000;
 31180 000049BC 2E8B1E[AE86]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 31181                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 31182 000049C1 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 31183 000049C4 7422                    	je	short $P_DateF00	;AN000;
 31184 000049C6 2EA1[D086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31185 000049CA 08E4                    	or	ah,ah			;AN000;
 31186 000049CC 7546                    	jnz	short $P_DateF_Error	;AN000;
 31187 000049CE 88C1                    	mov	cl,al			;AN000; set month
 31188 000049D0 2EA1[D286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31189 000049D4 08E4                    	or	ah,ah			;AN000; if overflow, error.
 31190 000049D6 753C                    	jnz	short $P_DateF_Error	;AN000;
 31191 000049D8 88C5                    	mov	ch,al			;AN000; set date
 31192 000049DA 2E8B16[D486]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 31193 000049DF 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 31194 000049E2 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 31195 000049E4 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 31196                                  $P_DateF01:				;AN000;
 31197 000049E6 EB19                    	jmp	short $P_DateF02	;AN000;
 31198                                  $P_DateF00:				;AN000; / here format = YMD
 31199 000049E8 2E8B16[D086]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 31200 000049ED 2EA1[D286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31201 000049F1 08E4                    	or	ah,ah			;AN000; if overflow, error
 31202 000049F3 751F                    	jnz	short $P_DateF_Error	;AN000;
 31203                                  
 31204 000049F5 88C1                    	mov	cl,al			;AN000; set month
 31205 000049F7 2EA1[D486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31206 000049FB 08E4                    	or	ah,ah			;AN000; if overflow, error
 31207 000049FD 7515                    	jnz	short $P_DateF_Error	;AN000;
 31208 000049FF 88C5                    	mov	ch,al			;AN000; set date
 31209                                  $P_DateF02:				;AN000;
 31210 00004A01 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 31211 00004A04 7304                    	jae	short $P_DateF03	;AN000;
 31212 00004A06 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 31213                                  $P_DateF03:				;AN000;
 31214 00004A0A 5B                      	pop	bx			;AN000; recover CONTROL block
 31215 00004A0B 5E                      	pop	si			;AN000; recover string pointer
 31216                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31217                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 31218                                  	; 03/04/2023
 31219 00004A0C B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 31220 00004A0F E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 31221 00004A12 EB0F                    	jmp	short $P_Date_Format_Exit
 31222                                  					;AN000;	to Date
 31223                                  $P_DateF_Error: 			;AN000;
 31224 00004A14 5B                      	pop	bx			;AN000; recover CONTROL block
 31225 00004A15 5E                      	pop	si			;AN000; recover string pointer
 31226                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31227                                  	;mov	al,$P_String ; 3	;AN000;   result
 31228                                  	; 03/04/2023
 31229 00004A16 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31230 00004A19 E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 31231                                  					;AN000; to string
 31232 00004A1C 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31233                                  					;AC034; indicate syntax error
 31234                                  $P_Date_Format_Exit:			;AN000;
 31235 00004A23 5A                      	pop	dx			;AN000;
 31236 00004A24 59                      	pop	cx			;AN000;
 31237 00004A25 58                      	pop	ax			;AN000;
 31238 00004A26 C3                      	retn				;AN000;
 31239                                  
 31240                                  ;***********************************************************************
 31241                                  ; $P_Set_CDI:
 31242                                  ;
 31243                                  ; Function: Read CDI from DOS if it has not been read yet
 31244                                  ;
 31245                                  ; Input:    None
 31246                                  ;
 31247                                  ; Output:   psdata_seg:SI -> CDI
 31248                                  ;
 31249                                  ; Use:	INT 21h w/ AH = 38h
 31250                                  ;***********************************************************************
 31251                                  
 31252                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31253                                  $P_Set_CDI:
 31254                                  	; 18/04/2023
 31255 00004A27 8D36[AE86]              	lea	si,$P_Country_Info	;AC034;
 31256                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 31257 00004A2B 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 31258                                  					;AN000; already read ?
 31259                                  	;je	short $P_Read_CDI	;AN000;
 31260                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 31261                                  	; 03/04/2023
 31262 00004A2F 750F                    	jne	short $P_Set_CDI_Exit
 31263                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 31264 00004A31 1E                      	push	ds			;AN000;
 31265 00004A32 52                      	push	dx			;AN000;
 31266 00004A33 50                      	push	ax			;AN000;
 31267 00004A34 0E                      	push	cs			;AC023;
 31268 00004A35 1F                      	pop	ds			;AN000; set segment register
 31269                                  	;mov	ax,3800h
 31270 00004A36 B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 31271 00004A39 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 31272 00004A3B CD21                    	int	21h			;AN000;
 31273 00004A3D 58                      	pop	ax			;AN000;
 31274 00004A3E 5A                      	pop	dx			;AN000;
 31275 00004A3F 1F                      	pop	ds			;AN000;
 31276                                  $P_Set_CDI_Exit:			;AN000;
 31277 00004A40 C3                      	retn				;AN000;
 31278                                  
 31279                                  ;***********************************************************************
 31280                                  ; $P_Get_DecNum:
 31281                                  ;
 31282                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 31283                                  ;	     or NULL encountered. And make a decimal number.
 31284                                  ;
 31285                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31286                                  ;
 31287                                  ; Output:    BL = delimiter code or NULL
 31288                                  ;	     AX = Decimal number
 31289                                  ;	     SI advanced to the next number
 31290                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 31291                                  ;
 31292                                  ; Use:	$P_0099
 31293                                  ;***********************************************************************
 31294                                  
 31295                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31296                                  $P_Get_DecNum:
 31297 00004A41 51                      	push	cx			;AN000;
 31298 00004A42 52                      	push	dx			;AN000;
 31299 00004A43 31C9                    	xor	cx,cx			;AN000; cx will have final value
 31300                                  $P_GetNum_Loop: 			;AN000;
 31301 00004A45 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31302 00004A48 08C0                    	or	al,al			;AN000; end of line ?
 31303 00004A4A 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 31304 00004A4C 2E803E[AD86]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 31305 00004A52 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 31306                                  
 31307                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 31308                                  	;cmp	bl,$P_colon_period
 31309 00004A54 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 31310 00004A57 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 31311                                  
 31312 00004A59 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31313 00004A5B 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31314                                  
 31315                                  	; 03/04/2023
 31316 00004A5D EB08                    	jmp	short $P_Do_Time_Delim1
 31317                                  ;$P_Do_Time_Delim1:			;AN000;
 31318                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31319                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31320                                  	;
 31321                                  	;jmp	short $P_Neither_Delims ;AN023;
 31322                                  
 31323                                  $P_Do_Date_Delims:			;AN000;
 31324                                  ;Regardless of the date delimiter character specified in the country
 31325                                  ;dependent information, check for the presence of any one of these
 31326                                  ;three field delimiters: "-", "/", or ".".
 31327 00004A5F 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31328 00004A61 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31329                                  
 31330 00004A63 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31331 00004A65 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31332                                  
 31333                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31334 00004A67 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31335 00004A69 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31336                                  
 31337                                  $P_Neither_Delims:			;AN023;
 31338 00004A6B E804FE                  	call	$P_0099 		;AN000; convert it to binary
 31339 00004A6E 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31340                                  
 31341 00004A70 B400                    	mov	ah,0			;AN000;
 31342 00004A72 91                      	xchg	ax,cx			;AN000;
 31343 00004A73 BA0A00                  	mov	dx,10			;AN000;
 31344 00004A76 F7E2                    	mul	dx			;AN000; ax = ax * 10
 31345 00004A78 09D2                    	or	dx,dx			;AN000; overflow
 31346 00004A7A 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31347                                  
 31348 00004A7C 01C8                    	add	ax,cx			;AN000;
 31349 00004A7E 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31350                                  
 31351 00004A80 91                      	xchg	ax,cx			;AN000;
 31352 00004A81 46                      	inc	si			;AN000;
 31353 00004A82 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31354                                  
 31355                                  $P_GetNum00:				;AN000;
 31356 00004A84 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31357                                  	;03/04/2023
 31358                                  	; cf=0
 31359                                  	;clc				;AN000; indicate no error
 31360 00004A86 EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31361                                  
 31362                                  $P_GetNum01:				;AN000;
 31363 00004A88 46                      	inc	si			;AN000; si points to next number
 31364                                  	;03/04/2023
 31365                                  	; cf=0
 31366                                  	;clc				;AN000; indicate no error
 31367 00004A89 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31368                                  
 31369                                  $P_GetNum02:				;AN000;
 31370 00004A8B F9                      	stc				;AN000; indicate error
 31371                                  $P_GetNum_Exit: 			;AN000;
 31372 00004A8C 89C8                    	mov	ax,cx			;AN000;return value
 31373 00004A8E 5A                      	pop	dx			;AN000;
 31374 00004A8F 59                      	pop	cx			;AN000;
 31375 00004A90 C3                      	retn				;AN000;
 31376                                  
 31377                                  ;***********************************************************************
 31378                                  ; $P_Time_Format
 31379                                  ;
 31380                                  ; Function:  Convert a time string to DOS time format for int 21h
 31381                                  ;	     with format validation.
 31382                                  ;
 31383                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31384                                  ;	     ES:BX -> CONTROL block
 31385                                  ;
 31386                                  ; Output:    None
 31387                                  ;
 31388                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 31389                                  ;
 31390                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 31391                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 31392                                  ;***********************************************************************
 31393                                  
 31394                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31395                                  
 31396                                  $P_Time_Format:				;AN000;
 31397 00004A91 50                      	push	ax			;AN000;
 31398 00004A92 51                      	push	cx			;AN000;
 31399 00004A93 52                      	push	dx			;AN000;
 31400 00004A94 56                      	push	si			;AN000;
 31401 00004A95 53                      	push	bx			;AN000;
 31402 00004A96 56                      	push	si			;AN000;
 31403 00004A97 E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 31404                                  					; information before process
 31405                                  	;test	byte [cs:si+11h], 1
 31406 00004A9A 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 31407                                  					;AN000; 24 hour system
 31408 00004A9F 5E                      	pop	si			;AN000;
 31409 00004AA0 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 31410 00004AA2 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 31411                                  $P_TimeF00:				;AN000;
 31412                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31413                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31414                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31415                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 31416                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 31417                                  	; 03/04/2023
 31418 00004AA5 31DB                    	xor	bx,bx
 31419 00004AA7 2E891E[D086]            	mov	[cs:$P_1st_Val],bx ; 0
 31420 00004AAC 2E891E[D286]            	mov	[cs:$P_2nd_Val],bx ; 0
 31421 00004AB1 2E891E[D486]            	mov	[cs:$P_3rd_Val],bx ; 0
 31422 00004AB6 2E891E[D686]            	mov	[cs:$P_4th_Val],bx ; 0
 31423                                  	;inc	bl
 31424                                  	;mov	[cs:$P_Got_Time],bl ; 1
 31425                                  
 31426                                  	;mov	bl,$P_colon_period
 31427                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 31428                                  					; delimiters between hours,
 31429                                  					;  minutes,seconds
 31430                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 31431 00004ABB FEC3                    	inc	bl ; bl = 1
 31432 00004ABD 2E881E[AD86]            	mov	[cs:$P_Got_Time],bl ; 1
 31433                                  	;
 31434 00004AC2 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 31435 00004AC5 725D                    	jc	short $P_TimeF_Err0	;AN000;
 31436 00004AC7 2EA3[D086]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31437 00004ACB 08DB                    	or	bl,bl			;AN000; end of line ?
 31438 00004ACD 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 31439 00004ACF E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31440 00004AD2 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 31441 00004AD4 2EA3[D286]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31442 00004AD8 08DB                    	or	bl,bl			;AN000; end of line ?
 31443 00004ADA 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 31444 00004ADC B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31445 00004ADE E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31446 00004AE1 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31447 00004AE3 2EA3[D486]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31448 00004AE7 08DB                    	or	bl,bl			;AN000; end of line ?
 31449 00004AE9 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31450                                  					;AN039;   GO TO 4TH NUMBER
 31451                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31452 00004AEB 2EF606[1D86]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31453                                  					;AN039;    BEEN REPEATED?
 31454 00004AF1 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31455                                  					;AN039;   the end of line
 31456                                  					;AN039; no, time has not been repeated
 31457 00004AF3 2E8B36[1486]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31458                                  					;AN039;   in command line
 31459 00004AF8 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31460                                  					;AN039; look at delimiter
 31461                                  					;AN039;   from command line
 31462 00004AFC 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31463                                  					;AN039;  really end of line
 31464                                  					;AN039; is comma before hundredths,
 31465                                  					;AN039;   redo TIME
 31466 00004AFE C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31467                                  					;AN039; change that ambiguous
 31468                                  					;AN039;    comma to a decimal point
 31469                                  					;AN039;     parse can understand
 31470 00004B02 2EC706[1D86]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31471                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31472 00004B09 2E800E[1D86]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31473                                  					;AN039; is being repeated
 31474 00004B0F 2E8B0E[A786]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31475 00004B14 2E8B26[A986]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31476                                  					;AN039;   OF STACK FROM SP
 31477 00004B19 2E8B36[AB86]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31478                                  					;AN039;   PARSE POINTER FROM SI
 31479 00004B1E E913F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31480                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31481 00004B21 E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31482                                  $P_TimeF_Err0:				;AN000; Bridge
 31483 00004B24 725E                    	jc	short $P_TimeF_Error	;AN000;
 31484                                  	;
 31485 00004B26 2EA3[D686]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31486 00004B2A 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31487 00004B2C 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31488                                  $P_TimeF_Rlt:				;AN000;
 31489 00004B2E 2EA1[D086]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31490 00004B32 08E4                    	or	ah,ah			;AN000; if overflow then error
 31491 00004B34 754E                    	jnz	short $P_TimeF_Err	;AN000;
 31492                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31493 00004B36 2EF606[1D86]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31494 00004B3C 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31495                                  					;since "AM" was specified,
 31496 00004B3E 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31497 00004B40 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31498 00004B42 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31499 00004B44 30C0                    	xor	al,al			;AN038; set hour = zero
 31500                                  $P_Time_notAM:				;AN038;
 31501                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31502 00004B46 2EF606[1E86]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31503 00004B4C 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31504 00004B4E 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31505 00004B50 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31506 00004B52 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31507 00004B54 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31508 00004B56 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31509 00004B58 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31510                                  $P_TimeSkip00:				;AN000;
 31511 00004B5A 88C2                    	mov	dl,al			;AN000; set hour
 31512 00004B5C 2EA1[D286]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31513 00004B60 08E4                    	or	ah,ah			;AN000; if overflow then error
 31514 00004B62 7520                    	jnz	short $P_TimeF_Err	;AN000;
 31515 00004B64 88C6                    	mov	dh,al			;AN000; set minute
 31516 00004B66 2EA1[D486]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31517 00004B6A 08E4                    	or	ah,ah			;AN000; if overflow then error
 31518 00004B6C 7516                    	jnz	short $P_TimeF_Err	;AN000;
 31519 00004B6E 88C1                    	mov	cl,al			;AN000; set second
 31520 00004B70 2EA1[D686]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31521 00004B74 08E4                    	or	ah,ah			;AN000; if overflow then error
 31522 00004B76 750C                    	jnz	short $P_TimeF_Err	;AN000;
 31523 00004B78 88C5                    	mov	ch,al			;AN000; set hundredth
 31524 00004B7A 5B                      	pop	bx			;AN000; recover CONTROL block
 31525 00004B7B 5E                      	pop	si			;AN000; recover string pointer
 31526                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31527                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31528                                  	; 03/04/2023
 31529 00004B7C B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31530 00004B7F E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 31531 00004B82 EB0F                    	jmp	short $P_Time_Format_Exit
 31532                                  					;AN000; to time
 31533                                  $P_TimeF_Error: 			;AN000;
 31534                                  $P_TimeF_Err:				;AN000;
 31535 00004B84 5B                      	pop	bx			;AN000; recover CONTROL block
 31536 00004B85 5E                      	pop	si			;AN000; recover string pointer
 31537                                  	;mov	ah,$P_No_Tag		;AN000; set
 31538                                  	;mov	al,$P_String		;AN000;     result
 31539                                  	; 03/04/2023
 31540 00004B86 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31541 00004B89 E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 31542                                  					;AN000; to string
 31543 00004B8C 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31544                                  					;AC034; return syntax error
 31545                                  $P_Time_Format_Exit:			;AN000;
 31546 00004B93 2EC606[AD86]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31547 00004B99 5A                      	pop	dx			;AN000;
 31548 00004B9A 59                      	pop	cx			;AN000;
 31549 00004B9B 58                      	pop	ax			;AN000;
 31550 00004B9C C3                      	retn
 31551                                  
 31552                                  ;***********************************************************************
 31553                                  ; $P_Time_2412:
 31554                                  ;
 31555                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31556                                  ;
 31557                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31558                                  ;
 31559                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31560                                  ;	     or "pm"
 31561                                  ;
 31562                                  ; Vars:  $P_Flags(W)
 31563                                  ;***********************************************************************
 31564                                  
 31565                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31566                                  
 31567                                  $P_Time_2412:				;AN000;
 31568 00004B9D 50                      	push	ax			;AN000;
 31569 00004B9E 56                      	push	si			;AN000;
 31570                                  $P_T12_Loop:				;AN000;
 31571 00004B9F 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31572 00004BA2 46                      	inc	si			;AN000;     si
 31573 00004BA3 08C0                    	or	al,al			;AN000;       to
 31574 00004BA5 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31575                                  
 31576 00004BA7 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31577                                  	;or	al,20h
 31578 00004BAB 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31579 00004BAD 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31580 00004BAF 7425                    	je	short $P_T1200		;AN000;
 31581                                  
 31582 00004BB1 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31583 00004BB3 7413                    	je	short $P_T1201		;AN000;
 31584                                  
 31585 00004BB5 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31586 00004BB7 751A                    	jne	short $P_T12_Exit	;AN000;
 31587                                  
 31588 00004BB9 4E                      	dec	si			;AN000;
 31589 00004BBA 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31590                                  	;or	al,20h
 31591 00004BBE 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31592 00004BC0 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31593 00004BC2 7412                    	je	short $P_T1200		;AN000;
 31594                                  
 31595 00004BC4 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31596                                  	;je	short $P_T1201		;AN000; go process "a"
 31597                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31598                                  	; 05/04/2023
 31599 00004BC6 750B                    	jne	short $P_T12_Exit
 31600                                  
 31601                                  ;$P_T1200:				;AN000; "P" found
 31602                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31603                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31604                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31605                                  
 31606                                  $P_T1201:				;AN000; "A" found
 31607                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31608 00004BC8 2E800E[1D86]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31609                                  $P_Tclr_chr:				;AN038;
 31610 00004BCE 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31611                                  $P_T12_Exit:				;AN000;
 31612 00004BD3 5E                      	pop	si			;AN000;
 31613 00004BD4 58                      	pop	ax			;AN000;
 31614 00004BD5 C3                      	retn				;AN000;
 31615                                  
 31616                                  	; 05/04/2023
 31617                                  $P_T1200:				;AN000; "P" found
 31618                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31619 00004BD6 2E800E[1E86]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31620 00004BDC EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31621                                  
 31622                                  ;***********************************************************************
 31623                                  ; $P_File_Format;
 31624                                  ;
 31625                                  ; Function:  Check if the input string is valid file spec format.
 31626                                  ;	     And set the result buffer.
 31627                                  ;
 31628                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31629                                  ;	     ES:BX -> CONTROL block
 31630                                  ;
 31631                                  ; Output:    None
 31632                                  ;
 31633                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31634                                  ;
 31635                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31636                                  ;	$P_SaveSI_Cmpx(R)
 31637                                  ;***********************************************************************
 31638                                  
 31639                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31640                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31641                                  $P_File_Format:
 31642 00004BDE 50                      	push	ax			;AN000;
 31643 00004BDF 57                      	push	di			;AN000;
 31644 00004BE0 56                      	push	si			;AN000;
 31645 00004BE1 2E8B3E[1F86]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31646 00004BE6 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31647 00004BE9 08C0                    	or	al,al			;AN000; end of line ?
 31648 00004BEB 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31649 00004BED E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31650 00004BF0 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31651 00004BF2 2EC606[EB86]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31652                                  					;AN033;AC034;; set error flag- bad char.
 31653 00004BF8 5E                      	pop	si			;AN033;
 31654 00004BF9 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31655 00004BFD 5F                      	pop	di			;AN033;
 31656 00004BFE EB3E                    	jmp	short $P_FileF02	;AN033;
 31657                                  $P_FileF_Err:				;AN000;
 31658 00004C00 5E                      	pop	si			;AN000;
 31659 00004C01 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31660 00004C05 5F                      	pop	di			;AN000;
 31661                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31662                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31663 00004C06 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31664 00004C0A 7532                    	jnz	short $P_FileF02	;AN000;
 31665 00004C0C 2EC706[1286]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31666                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31667 00004C13 EB29                    	jmp	short $P_FileF02	;AN000;
 31668                                  $P_FileF03:				;AN000;
 31669 00004C15 58                      	pop	ax			;AN000; discard save si
 31670 00004C16 56                      	push	si			;AN000; save new si
 31671                                  $P_FileF_Loop1: 			;AN000;
 31672 00004C17 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31673 00004C1A 08C0                    	or	al,al			;AN000; end of line ?
 31674 00004C1C 741E                    	jz	short $P_FileF_RLT	;AN000;
 31675 00004C1E E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31676 00004C21 740B                    	jz	short $P_FileF00	;AN000;
 31677 00004C23 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31678 00004C26 7302                    	jnc	short $P_FileF01	;AN000;
 31679 00004C28 47                      	inc	di			;AN000; if yes, skip next byte
 31680 00004C29 46                      	inc	si			;AN000;
 31681                                  $P_FileF01:				;AN000;
 31682 00004C2A 47                      	inc	di			;AN000;
 31683 00004C2B 46                      	inc	si			;AN000;
 31684 00004C2C EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31685                                  $P_FileF00:				;AN000;
 31686 00004C2E 2EA2[1886]              	mov	[cs:$P_Terminator],al	;AC034;
 31687 00004C32 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31688 00004C36 47                      	inc	di			;AN000;
 31689 00004C37 2E893E[1486]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31690                                  $P_FileF_RLT:				;AN000;
 31691 00004C3C 5E                      	pop	si			;AN000;
 31692 00004C3D 5F                      	pop	di			;AN000;
 31693                                  $P_FileF02:				;AN000;
 31694 00004C3E 58                      	pop	ax			;AN000; (tm14)
 31695                                  	;;test	ax,200h
 31696                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31697                                  	; 05/04/2023
 31698 00004C3F F6C402                  	test	ah,($P_File_Spc>>8)
 31699 00004C42 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31700 00004C44 50                      	push	ax			;AN000; (tm14)
 31701                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31702                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31703                                  	; 05/04/2023
 31704 00004C45 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31705 00004C48 E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31706 00004C4B 58                      	pop	ax			;AN000;
 31707                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31708 00004C4C C3                      	retn				;AN000;
 31709                                  
 31710                                  ;***********************************************************************
 31711                                  ; $P_FileSp_Chk
 31712                                  ;
 31713                                  ; Function:  Check if the input byte is one of file special characters
 31714                                  ;
 31715                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31716                                  ;	     AL = character code to be examineed
 31717                                  ;
 31718                                  ; Output:    ZF = 1 , AL is one of special characters
 31719                                  ;***********************************************************************
 31720                                  
 31721                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31722                                  $P_FileSp_Chk:
 31723 00004C4D 53                      	push	bx			;AN000;
 31724 00004C4E 51                      	push	cx			;AN000;
 31725                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31726 00004C4F 8D1E[E286]              	lea	bx,$P_FileSp_Char
 31727 00004C53 B90900                  	mov	cx,$P_FileSp_Len ; 9
 31728                                  	;mov	cx,9			;AN000; load length of it
 31729                                  $P_FileSp_Loop: 			;AN000;
 31730 00004C56 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31731 00004C59 7404                    	je	short $P_FileSp_Exit	;AN000;
 31732 00004C5B 43                      	inc	bx			;AN000;
 31733 00004C5C E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31734 00004C5E 41                      	inc	cx			;AN000; reset ZF
 31735                                  $P_FileSp_Exit: 			;AN000;
 31736 00004C5F 59                      	pop	cx			;AN000;
 31737 00004C60 5B                      	pop	bx			;AN000;
 31738 00004C61 C3                      	retn				;AN000;
 31739                                  
 31740                                  ;***********************************************************************
 31741                                  ; $P_Drive_Format;
 31742                                  ;
 31743                                  ; Function:  Check if the input string is valid drive only format.
 31744                                  ;	     And set the result buffer.
 31745                                  ;
 31746                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31747                                  ;	     ES:BX -> CONTROL block
 31748                                  ;
 31749                                  ; Output:    None
 31750                                  ;
 31751                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31752                                  ;
 31753                                  ; Vars: $P_RC(W)
 31754                                  ;***********************************************************************
 31755                                  
 31756                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31757                                  $P_Drive_Format:
 31758 00004C62 50                      	push	ax			;AN000;
 31759 00004C63 52                      	push	dx			;AN000;
 31760 00004C64 2E8A04                  	mov	al,[cs:si]		;AN000;
 31761 00004C67 08C0                    	or	al,al			;AN000; if null string
 31762 00004C69 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31763 00004C6B E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31764 00004C6E 722A                    	jc	short $P_Drv_Err	;AN000;
 31765                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31766 00004C70 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31767 00004C75 740D                    	je	short $P_DrvF00		;AN000;
 31768                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31769                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31770 00004C77 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31771 00004C7B 741D                    	jz	short $P_Drv_Err	;AN000;
 31772 00004C7D 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31773 00004C82 7516                    	jne	short $P_Drv_Err	;AN000;
 31774                                  $P_DrvF00:				;AN000;
 31775 00004C84 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31776 00004C86 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31777 00004C88 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31778 00004C8A 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31779 00004C8C 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31780 00004C8E 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31781 00004C90 88C2                    	mov	dl,al			;AN000; set
 31782                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31783                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31784                                  	; 05/04/2023
 31785 00004C92 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31786 00004C95 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31787 00004C98 EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31788                                  $P_Drv_Err:				;AN000;
 31789 00004C9A 2EC706[1286]0900        	mov	word [cs:$P_RC],$P_Syntax
 31790                                  	;mov	word [cs:$P_RC],9	;AC034;
 31791                                  $P_Drv_Exit:				;AN000;
 31792 00004CA1 5A                      	pop	dx			;AN000;
 31793 00004CA2 58                      	pop	ax			;AN000;
 31794 00004CA3 C3                      	retn				;AN000;
 31795                                  
 31796                                  ;***********************************************************************
 31797                                  ; $P_Skip_Delim;
 31798                                  ;
 31799                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31800                                  ;	    and comma.
 31801                                  ;
 31802                                  ; Input:    DS:SI -> Command String
 31803                                  ;	    ES:DI -> Parameter List
 31804                                  ;
 31805                                  ; Output:   CY = 1 if the end of line encounterd
 31806                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31807                                  ;	    AL = Last examineed character
 31808                                  ;
 31809                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31810                                  ;
 31811                                  ; Vars:     $P_Flags(R)
 31812                                  ;***********************************************************************
 31813                                  
 31814                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31815                                  
 31816                                  $P_Skip_Delim:				;AN000;
 31817                                  $P_Skip_Delim_Loop:			;AN000;
 31818 00004CA4 AC                      	lodsb				;AN000;
 31819 00004CA5 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31820 00004CA8 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31821                                  
 31822 00004CAA E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31823 00004CAD 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31824                                  
 31825 00004CAF 2EF606[1E86]20          	test	byte [cs:$P_Flags2],$P_Extra
 31826                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31827 00004CB5 74ED                    	jz	short $P_Skip_Delim_Loop
 31828                                  					;AN000; if no, loop
 31829 00004CB7 2EF606[1E86]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31830                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31831                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31832                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31833                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31834                                  	; 05/04/2023
 31835 00004CBD 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31836                                  $P_Exit_At_Extra:			;AN000;
 31837                                  	; cf = 0
 31838                                  	;clc				;AN000; indicate extra delim
 31839 00004CBF C3                      	retn				;AN000;
 31840                                  
 31841                                  $P_Skip_Delim_CY:			;AN000;
 31842 00004CC0 F9                      	stc				;AN000; indicate EOL
 31843 00004CC1 EB01                    	jmp	short $P_Skip_Delim_Exit
 31844                                  					;AN000;
 31845                                  $P_Skip_Delim_NCY:			;AN000;
 31846 00004CC3 F8                      	clc				;AN000; indicate non delim
 31847                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31848 00004CC4 4E                      	dec	si ; *			;AN000;  backup index pointer
 31849 00004CC5 C3                      	retn				;AN000;
 31850                                  	; 05/04/2023
 31851                                  ;$P_Exit_At_Extra:			;AN000;
 31852                                  	;clc				;AN000; indicate extra delim
 31853                                  	;retn				;AN000;
 31854                                  
 31855                                  ;***********************************************************************
 31856                                  ; $P_Chk_EOL;
 31857                                  ;
 31858                                  ; Function: Check if AL is one of End of Line characters.
 31859                                  ;
 31860                                  ; Input:    AL = character code
 31861                                  ;	    ES:DI -> Parameter List
 31862                                  ;
 31863                                  ; Output:   ZF = 1 if one of End of Line characters
 31864                                  ;***********************************************************************
 31865                                  
 31866                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31867                                  
 31868                                  $P_Chk_EOL:
 31869 00004CC6 53                      	push	bx			;AN000;
 31870 00004CC7 51                      	push	cx			;AN000;
 31871 00004CC8 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31872 00004CCA 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31873 00004CCC 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 31874 00004CCE 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31875 00004CD0 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 31876                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 31877 00004CD5 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 31878 00004CD7 31DB                    	xor	bx,bx			;AN000;
 31879 00004CD9 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31880                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 31881 00004CDD 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 31882 00004CE0 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 31883                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 31884 00004CE4 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 31885 00004CE6 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 31886 00004CE8 268A09                  	mov	cl,[es:bx+di]		;AN000;
 31887                                  $P_Chk_EOL_Loop:			;AN000;
 31888 00004CEB 43                      	inc	bx			;AN000;
 31889 00004CEC 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 31890 00004CEF 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31891 00004CF1 E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 31892                                  $P_Chk_EOL_NZ:				;AN000;
 31893 00004CF3 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 31894                                  $P_Chk_EOL_Exit:			;AN000;
 31895 00004CF5 59                      	pop	cx			;AN000;
 31896 00004CF6 5B                      	pop	bx			;AN000;
 31897 00004CF7 C3                      	retn				;AN000;
 31898                                  
 31899                                  ;***********************************************************************
 31900                                  ; $P_Chk_Delim;
 31901                                  ;
 31902                                  ; Function: Check if AL is one of delimiter characters.
 31903                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 31904                                  ;	    blanks.
 31905                                  ;
 31906                                  ; Input:    AL = character code
 31907                                  ;	    DS:SI -> Next Character
 31908                                  ;	    ES:DI -> Parameter List
 31909                                  ;
 31910                                  ; Output:   ZF = 1 if one of delimiter characters
 31911                                  ;	    SI points to the next character
 31912                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 31913                                  ;***********************************************************************
 31914                                  
 31915                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31916                                  
 31917                                  $P_Chk_Delim:
 31918 00004CF8 53                      	push	bx			;AN000;
 31919 00004CF9 51                      	push	cx			;AN000;
 31920 00004CFA 2EC606[1886]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 31921                                  					;AC034; Assume terminated by space
 31922 00004D00 2E8026[1E86]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 31923                                  					;AC034;
 31924 00004D06 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 31925 00004D08 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 31926                                  
 31927 00004D0A 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 31928 00004D0C 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 31929                                  
 31930 00004D0E 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 31931 00004D10 7431                    	je	short $P_Chk_Delim_Exit0
 31932                                  					;AN000;
 31933                                  $P_Chk_Delim00: 			;AN000;
 31934 00004D12 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 31935 00004D14 750C                    	jne	short $P_Chk_Delim01	;AN000;
 31936 00004D16 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 31937                                  					;AN000; 2nd byte of DBCS Space ?
 31938 00004D19 7507                    	jne	short $P_Chk_Delim01	;AN000;
 31939 00004D1B B020                    	mov	al,$P_Space ; 20h	;AN000;
 31940 00004D1D 46                      	inc	si			;AN000; make si point to next character
 31941 00004D1E 38C0                    	cmp	al,al			;AN000; Set ZF
 31942 00004D20 EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31943                                  
 31944                                  $P_Chk_Delim01: 			;AN000;
 31945                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 31946 00004D22 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 31947                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 31948 00004D27 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 31949                                  
 31950 00004D29 31C9                    	xor	cx,cx			;AN000;
 31951 00004D2B 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31952                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 31953 00004D2F 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 31954 00004D31 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 31955                                  
 31956 00004D33 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 31957                                  $P_Chk_Delim_Loop:			;AN000;
 31958 00004D36 43                      	inc	bx			;AN000;
 31959 00004D37 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 31960 00004D3A 7407                    	je	short $P_Chk_Delim_Exit0
 31961                                  					;AN000;
 31962 00004D3C E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 31963                                  
 31964                                  $P_Chk_Delim_NZ:			;AN000;
 31965 00004D3E 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 31966                                  $P_Chk_Delim_Exit:			;AN000;
 31967 00004D40 59                      	pop	cx			;AN000;
 31968 00004D41 5B                      	pop	bx			;AN000;
 31969 00004D42 C3                      	retn				;AN000;
 31970                                  
 31971                                  $P_Chk_Delim_Exit0:			;AN000;
 31972 00004D43 2EA2[1886]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 31973 00004D47 2EF606[1E86]01          	test	byte [cs:$P_Flags2],$P_equ
 31974                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 31975 00004D4D 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 31976                                  
 31977 00004D4F 2E800E[1E86]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 31978                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 31979                                  $P_No_Set_Extra:			;AN027;
 31980 00004D55 38C0                    	cmp	al,al			;AN000; set ZF
 31981 00004D57 EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31982                                  
 31983                                  ;***********************************************************************
 31984                                  ; $P_Chk_Switch;
 31985                                  ;
 31986                                  ; Function: Check if AL is the switch character not in first position of
 31987                                  ;	    $P_STRING_BUF
 31988                                  ;
 31989                                  ; Input:    AL = character code
 31990                                  ;	    BX = current pointer within $P_String_Buf
 31991                                  ;	    SI =>next char on command line (following the one in AL)
 31992                                  ;
 31993                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 31994                                  ;		 position, and has no chance of being part of a date string,
 31995                                  ;		 i.e. should be treated as a delimiter.
 31996                                  ;
 31997                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 31998                                  ;		 position, or is a slash but may be part of a date string, i.e.
 31999                                  ;		 should not be treated as a delimiter.
 32000                                  ;
 32001                                  ; Vars:  $P_Terminator(W)
 32002                                  ;
 32003                                  ; Use:	 $P_0099
 32004                                  ;***********************************************************************
 32005                                  
 32006                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32007                                  
 32008                                  $P_Chk_Switch:
 32009                                  	; 18/04/2023
 32010 00004D59 8D2E[2786]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 32011                                  
 32012 00004D5D 39EB                    	cmp	bx,bp			;AN000;
 32013 00004D5F 7418                    	je	short $P_STRUC_L2	;AN000;
 32014                                  
 32015 00004D61 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32016 00004D63 7512                    	jne	short $P_STRUC_L5	;AN000;
 32017                                  
 32018 00004D65 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 32019 00004D66 50                      	push	ax			;AN020;save input char
 32020 00004D67 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 32021 00004D6B E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 32022 00004D6E 7205                    	jc	short $P_STRUC_L7	;AN000;
 32023                                  
 32024 00004D70 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 32025 00004D72 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 32026                                  $P_STRUC_L7:				;AN000;
 32027 00004D75 58                      	pop	ax			;AN020;restore AL to input char
 32028                                  	;jmp	short $P_STRUC_L1	;AN000;
 32029                                  	; 18/04/2023
 32030 00004D76 C3                      	retn
 32031                                  
 32032                                  $P_STRUC_L5:				;AN000;
 32033 00004D77 F8                      	clc				;AN020;not a slash
 32034                                  	;jmp	short $P_STRUC_L1	;AN000;
 32035                                  	 ;18/04/2023
 32036 00004D78 C3                      	retn
 32037                                  
 32038                                  $P_STRUC_L2:				;AN000;
 32039 00004D79 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32040                                  	;jne	short $P_STRUC_L12	;AN000;
 32041                                  	; 18/04/2023
 32042 00004D7B 75FA                    	jne	short $P_STRUC_L5
 32043                                  
 32044 00004D7D 2E800E[1E86]40          	or	byte [cs:$P_Flags2],$P_SW
 32045                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 32046                                  	; 18/04/2023
 32047                                  ;$P_STRUC_L12:				;AN000;
 32048                                  	;clc				;AN020;CF=0 indicating first char
 32049                                  $P_STRUC_L1:				;AN000;
 32050 00004D83 C3                      	retn				;AN000;
 32051                                  
 32052                                  ;**************************************************************************
 32053                                  ; $P_Chk_DBCS:
 32054                                  ;
 32055                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 32056                                  ;
 32057                                  ;  Input:
 32058                                  ;	  AL	= Code to be examineed
 32059                                  ;
 32060                                  ;  Output:
 32061                                  ;	  If CF is on then a lead byte of DBCS
 32062                                  ;
 32063                                  ; Use: INT 21h w/AH=63
 32064                                  ;
 32065                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 32066                                  ;***************************************************************************
 32067                                  
 32068                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32069                                  
 32070                                  $P_Chk_DBCS:
 32071 00004D84 1E                      	push	ds			;AN000;
 32072 00004D85 56                      	push	si			;AN000;
 32073 00004D86 53                      	push	bx			;AN000; (tm11)
 32074 00004D87 2E833E[1B86]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 32075                                  					;AC034; ALREADY SET ?
 32076 00004D8D 7527                    	jne	short $P_DBCS00		;AN000;
 32077 00004D8F 50                      	push	ax			;AN000;
 32078 00004D90 1E                      	push	ds			;AN000; (tm11)
 32079 00004D91 51                      	push	cx			;AN000;
 32080 00004D92 52                      	push	dx			;AN000;
 32081 00004D93 57                      	push	di			;AN000;
 32082 00004D94 55                      	push	bp			;AN000;
 32083 00004D95 06                      	push	es			;AN000;
 32084 00004D96 31F6                    	xor	si,si			;AN000;
 32085 00004D98 8EDE                    	mov	ds,si			;AN000;
 32086                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 32087 00004D9A B80063                  	mov	ax,6300h
 32088 00004D9D CD21                    	int	21h			;AN000;
 32089 00004D9F 8CDB                    	mov	bx,ds			;AN000; (tm11)
 32090 00004DA1 09DB                    	or	bx,bx			;AN000; (tm11)
 32091 00004DA3 07                      	pop	es			;AN000;
 32092 00004DA4 5D                      	pop	bp			;AN000;
 32093 00004DA5 5F                      	pop	di			;AN000;
 32094 00004DA6 5A                      	pop	dx			;AN000;
 32095 00004DA7 59                      	pop	cx			;AN000;
 32096 00004DA8 1F                      	pop	ds			;AN000; (tm11)
 32097 00004DA9 58                      	pop	ax			;AN000;
 32098 00004DAA 7429                    	jz	short $P_NON_DBCS	;AN000;
 32099                                  $P_DBCS02:				;AN000;
 32100 00004DAC 2E8936[1986]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 32101 00004DB1 2E891E[1B86]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 32102                                  $P_DBCS00:				;AN000;
 32103 00004DB6 2E8B36[1986]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 32104 00004DBB 2E8E1E[1B86]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 32105                                  $P_DBCS_LOOP:				;AN000;
 32106 00004DC0 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 32107 00004DC3 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 32108 00004DC5 3A04                    	cmp	al,[si] 		;AN000;
 32109 00004DC7 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 32110 00004DC9 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 32111 00004DCC 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 32112 00004DCE F9                      	stc				;AN000; if yes, indicate DBCS and exit
 32113 00004DCF EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 32114                                  $P_DBCS01:				;AN000;
 32115 00004DD1 46                      	inc	si			;AC035; add '2' to
 32116 00004DD2 46                      	inc	si			;AC035;  SI reg
 32117                                  					;AN000; get next vector
 32118 00004DD3 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 32119                                  
 32120                                  $P_NON_DBCS:				;AN000;
 32121                                  	; 18/04/2023
 32122                                  	; cf=0
 32123                                  	;clc				;AN000; indicate SBCS
 32124                                  $P_DBCS_EXIT:				;AN000;
 32125 00004DD5 5B                      	pop	bx			;AN000; (tm11)
 32126 00004DD6 5E                      	pop	si			;AN000;
 32127 00004DD7 1F                      	pop	ds			;AN000;
 32128 00004DD8 C3                      	retn				;AN000;
 32129                                  
 32130                                  ;============================================================================
 32131                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 32132                                  ;============================================================================
 32133                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32134                                  
 32135                                  ; ****************************************************************
 32136                                  ; *
 32137                                  ; * ROUTINE:	 CMD_PARSE
 32138                                  ; *
 32139                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 32140                                  ; *		 SYSPARSE.
 32141                                  ; *
 32142                                  ; * INPUT:	 inputs to SYSPARSE
 32143                                  ; *
 32144                                  ; * OUTPUT:	 outputs from SYSPARSE
 32145                                  ; *
 32146                                  ; ****************************************************************
 32147                                  
 32148                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32149                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 32150                                  ;cmd_parse:
 32151                                  	;call	sysparse		;AN000;
 32152                                  	;retn				;AN000;
 32153                                  	; 06/04/2023
 32154                                  	;jmp	sysparse
 32155                                  
 32156                                  append_parse:
 32157 00004DD9 E842F5                  	call	sysparse		;AN010;
 32158 00004DDC CB                      	retf				;AN010;
 32159                                  
 32160                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32161                                  %if 0
 32162                                  
 32163                                  ;============================================================================
 32164                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 32165                                  ;============================================================================
 32166                                  ; 30/09/2018 - Retro DOS v3.0
 32167                                  
 32168                                  ; BREAK	<Message Printing Routine>
 32169                                  
 32170                                  ;
 32171                                  ;	MSDOS V3.00 PRINT
 32172                                  ;
 32173                                  ;	Message Printing Routine
 32174                                  ;
 32175                                  
 32176                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 32177                                  ;
 32178                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 32179                                  ;
 32180                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 32181                                  ;
 32182                                  ; Characters are output to PFHandle according to the
 32183                                  ; specifications contained in the Control String.
 32184                                  ;
 32185                                  ; The conversion characters are as follow:
 32186                                  ;
 32187                                  ;               %c - output the next argument as a character
 32188                                  ;               %s - output the next argument as a string
 32189                                  ;               %x - output the next argument as a hexidecimal number
 32190                                  ;                    using abcedf
 32191                                  ;               %X - output the next argument as a hexidecimal number
 32192                                  ;                    using ABCDEF
 32193                                  ;               %d - output the next argument as a decimal number
 32194                                  ;
 32195                                  ;
 32196                                  ; Other format specifiers that may precede the conversion character are:
 32197                                  ;
 32198                                  ;               - (minus sign) - causes the field to be left-adjusted
 32199                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 32200                                  ;               n - digit specifing the minimum field width (default to 1)
 32201                                  ;               L - specifing a long integer
 32202                                  ;
 32203                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 32204                                  ;   to an argument list.
 32205                                  ;
 32206                                  ;   ____________________
 32207                                  ;   |   Ret Addr       |      <= SP
 32208                                  ;   --------------------
 32209                                  ;   |  Ptr to Arg List |
 32210                                  ;   --------------------
 32211                                  ;
 32212                                  ;   And the argument list contains the following:
 32213                                  ;
 32214                                  ;       String_ptr                  (a pointer to the control string)
 32215                                  ;       Arg 1
 32216                                  ;       Arg 2
 32217                                  ;         .
 32218                                  ;         .
 32219                                  ;         .
 32220                                  ;       Arg n-1
 32221                                  ;       Arg n
 32222                                  ;
 32223                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 32224                                  ;   or character.
 32225                                  ;
 32226                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 32227                                  
 32228                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 32229                                  
 32230                                  ; =============== S U B	R O U T	I N E =======================================
 32231                                  
 32232                                  PRINTF_INIT:
 32233                                  	call	STD_PRINTF
 32234                                  	retf
 32235                                  
 32236                                  ; =============== S U B	R O U T	I N E =======================================
 32237                                  
 32238                                  PRINTF_CRLF:
 32239                                  	call	STD_PRINTF
 32240                                  	;call	CRLF2
 32241                                  	;retn
 32242                                  	; 07/04/2023
 32243                                  	jmp	CRLF2
 32244                                  
 32245                                  ; =============== S U B	R O U T	I N E =======================================
 32246                                  
 32247                                  STD_EPRINTF:
 32248                                  	mov	word [cs:PRINTF_HANDLE],2
 32249                                  	jmp	short new_printf
 32250                                  
 32251                                  ; =============== S U B	R O U T	I N E =======================================
 32252                                  
 32253                                  STD_PRINTF:
 32254                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 32255                                  
 32256                                  	mov	word [cs:PRINTF_HANDLE],1
 32257                                  NEW_PRINTF:				;Save the callers' registers
 32258                                  	cld
 32259                                  	push	dx
 32260                                  	push	bp
 32261                                  	mov	bp,sp
 32262                                  	push	cx
 32263                                  	push	bx
 32264                                  	push	ax
 32265                                  	push	di
 32266                                  	push	si
 32267                                  	push	es
 32268                                  	push	ds
 32269                                  	push	cs
 32270                                  	pop	es		;ES points to Printf segment
 32271                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 32272                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 32273                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 32274                                  	mov	si,[ds:bp] ; bp
 32275                                  	add	bp,2
 32276                                  	xor	bx,bx
 32277                                  	call	CLEAR_FLAGS	; initialize the world
 32278                                  
 32279                                  GET_CHAR:
 32280                                  	lodsb			;Get a character
 32281                                  	cmp	al,'%'		;Is it a conversion specifier?
 32282                                  	jz	short CONV_CHAR	;Yes - find out which one
 32283                                  	or	al,al		;Is it the end of the control string?
 32284                                  	jz	short PRINTF_DONE ;Yes - then we're done
 32285                                  PRINTF_PERCENT:				
 32286                                  	call	OUTCHR		;Otherwise store the character
 32287                                  	jmp	short GET_CHAR	;And go get another
 32288                                  
 32289                                  PRINTF_DONE:
 32290                                  	call	FLUSH
 32291                                  	pop	ds
 32292                                  	pop	es
 32293                                  	pop	si
 32294                                  	pop	di
 32295                                  	pop	ax
 32296                                  	pop	bx
 32297                                  	pop	cx
 32298                                  	pop	bp
 32299                                  	pop	dx
 32300                                  	retn
 32301                                  
 32302                                  CONV_CHAR:
 32303                                  	mov	byte [cs:PRINTF_LEFT],0
 32304                                  
 32305                                  NXT_CONV_CHAR:	
 32306                                  	;Look for any format specifiers preceeding the conversion character
 32307                                  	lodsb
 32308                                  	cmp	al,'%'			;Just print the %
 32309                                  	jz	short PRINTF_PERCENT
 32310                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 32311                                  	jz	short LEFT_ADJ
 32312                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 32313                                  	jz	short CONV_CHAR
 32314                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 32315                                  	jz	short LONG_INT
 32316                                  	cmp	al,[cs:char_l]	 ; "l"		
 32317                                  	jz	short LONG_INT
 32318                                  	cmp	al,'0'			;Is it a precision specification
 32319                                  	jb	short LOOK_CONV_CHAR
 32320                                  	cmp	al,'9'
 32321                                  	ja	short LOOK_CONV_CHAR
 32322                                  	cmp	al,'0'
 32323                                  	jnz	short NOT_PAD
 32324                                  	cmp	word [cs:PRINTF_WIDTH],0
 32325                                  	jnz	short NOT_PAD
 32326                                  	mov	ah,'0'
 32327                                  	mov	[cs:PAD_CHAR],ah
 32328                                  NOT_PAD:					;Adjust decimal place on precision
 32329                                  	push	ax
 32330                                  	mov	ax,[cs:PRINTF_WIDTH]
 32331                                  	mov	cx,10
 32332                                  	mul	cx
 32333                                  	pop	dx
 32334                                  	xor	dh,dh
 32335                                  	sub	dl,'0'
 32336                                  	add	ax,dx
 32337                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 32338                                  	jmp	short NXT_CONV_CHAR
 32339                                  
 32340                                  LEFT_ADJ:
 32341                                  	mov	byte [cs:PRINTF_LEFT],1
 32342                                  	jmp	short NXT_CONV_CHAR
 32343                                  
 32344                                  LONG_INT:
 32345                                  	or	byte [cs:PRINTF_LONG],1
 32346                                  	jmp	short NXT_CONV_CHAR
 32347                                  
 32348                                  LOOK_CONV_CHAR:
 32349                                  	and	al,0DFh
 32350                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 32351                                  	jz	short HEX_UP
 32352                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 32353                                  	jz	short DECIMAL
 32354                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 32355                                  	jz	short C_PUT_CHAR
 32356                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 32357                                  	jz	short S_PUT_STRG
 32358                                  	call	CLEAR_FLAGS
 32359                                  	jmp	GET_CHAR
 32360                                  
 32361                                  HEX_UP:
 32362                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 32363                                  	jmp	short CONV_TO_NUM
 32364                                  DECIMAL:
 32365                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 32366                                  	jmp	short CONV_TO_NUM
 32367                                  
 32368                                  C_PUT_CHAR:
 32369                                  	call	NEXT_CHRS
 32370                                  	mov	al,dl
 32371                                  	call	OUTCHR
 32372                                  	call	CLEAR_FLAGS
 32373                                  	jmp	GET_CHAR
 32374                                  
 32375                                  S_PUT_STRG:
 32376                                  	push	si			;Save pointer to control string
 32377                                  	call	NEXT_CHRS
 32378                                  	mov	si,dx
 32379                                  S_PUT_1:
 32380                                  	mov	cx,[cs:PRINTF_WIDTH]
 32381                                  	or	cx,cx
 32382                                  	jz	short S_PUT_2
 32383                                  	cmp	byte [cs:PRINTF_LEFT],0
 32384                                  	jnz	short S_PUT_2
 32385                                  	call	PAD_STRING
 32386                                  S_PUT_2:
 32387                                  	push	si
 32388                                  S_PUT_3:
 32389                                  	lodsb
 32390                                  	or	al,al
 32391                                  	jz	short S_PUT_4
 32392                                  	call	OUTCHR			;Put it into our buffer
 32393                                  	jmp	short S_PUT_3
 32394                                  S_PUT_4:
 32395                                  	pop	si
 32396                                  	cmp	byte [cs:PRINTF_LEFT],0
 32397                                  	jz	short C_S_END
 32398                                  	mov	cx,[cs:PRINTF_WIDTH]
 32399                                  	or	cx,cx
 32400                                  	jz	short C_S_END
 32401                                  	call	PAD_STRING
 32402                                  C_S_END:
 32403                                  	pop	si			;Restore control string pointer
 32404                                  	call	CLEAR_FLAGS
 32405                                  	jmp	GET_CHAR		;Go get another character	
 32406                                  
 32407                                  
 32408                                  ; =============== S U B	R O U T	I N E =======================================
 32409                                  
 32410                                  PAD_STRING:
 32411                                  	xor	dx,dx
 32412                                  	push	si
 32413                                  
 32414                                  COUNT_LOOP:
 32415                                  	lodsb
 32416                                  	or	al,al
 32417                                  	jz	short COUNT_DONE
 32418                                  	inc	dx
 32419                                  	jmp	short COUNT_LOOP
 32420                                  
 32421                                  COUNT_DONE:
 32422                                  	pop	si
 32423                                  	sub	cx,dx
 32424                                  	jbe	short COUNT_RET
 32425                                  	call	PAD
 32426                                  
 32427                                  COUNT_RET:
 32428                                  	retn
 32429                                  
 32430                                  ; ---------------------------------------------------------------------------
 32431                                  
 32432                                  CONV_TO_NUM:
 32433                                  	call	NEXT_CHRS
 32434                                  	mov	ax,dx
 32435                                  	xor	dx,dx
 32436                                  	cmp	byte [cs:PRINTF_LONG],0 
 32437                                  			;Is this is a short or long integer?
 32438                                  	jz	short NOT_LONG_INT
 32439                                  	call	NEXT_CHRS
 32440                                  
 32441                                  NOT_LONG_INT:
 32442                                  	push	bx
 32443                                  	push	si
 32444                                  	mov	si,[cs:PRINTF_BASE]
 32445                                  	mov	cx,[cs:PRINTF_WIDTH]
 32446                                  	call	PNUM
 32447                                  	pop	si
 32448                                  	pop	bx
 32449                                  	call	PAD
 32450                                  	call	CLEAR_FLAGS
 32451                                  	jmp	GET_CHAR
 32452                                  
 32453                                  
 32454                                  ; =============== S U B	R O U T	I N E =======================================
 32455                                  
 32456                                  PNUM:
 32457                                  	dec	cx
 32458                                  	push	ax
 32459                                  	mov	ax,dx
 32460                                  	xor	dx,dx
 32461                                  	div	si
 32462                                  	mov	bx,ax
 32463                                  	pop	ax
 32464                                  	div	si
 32465                                  	xchg	bx,dx
 32466                                  	push	ax
 32467                                  	or	ax,dx
 32468                                  	pop	ax
 32469                                  	jz	short DO_PAD
 32470                                  	push	bx
 32471                                  	call	PNUM
 32472                                  	pop	bx
 32473                                  	jmp	short REM
 32474                                  
 32475                                  DO_PAD:
 32476                                  	cmp	byte [cs:PRINTF_LEFT],0
 32477                                  	jnz	short REM
 32478                                  	call	PAD
 32479                                  REM:
 32480                                  	cmp	bl,10
 32481                                  	jb	short NOT_HEX
 32482                                  	add	bx,6
 32483                                  NOT_HEX:
 32484                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32485                                  	push	cx
 32486                                  	call	OUTCHR
 32487                                  	pop	cx
 32488                                  	retn
 32489                                  
 32490                                  ; =============== S U B	R O U T	I N E =======================================
 32491                                  
 32492                                  PAD:
 32493                                  	or	cx,cx
 32494                                  	jle	short PAD_DONE
 32495                                  	mov	al,[cs:PAD_CHAR]
 32496                                  PAD_LOOP:
 32497                                  	push	cx
 32498                                  	call	OUTCHR
 32499                                  	pop	cx
 32500                                  	loop	PAD_LOOP
 32501                                  PAD_DONE:
 32502                                  	retn
 32503                                  
 32504                                  ; =============== S U B	R O U T	I N E =======================================
 32505                                  
 32506                                  OUTCHR:
 32507                                  	stosb
 32508                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32509                                  	je	short FLUSH
 32510                                  OUTCHR_RETN:
 32511                                  	retn
 32512                                  
 32513                                  ; =============== S U B	R O U T	I N E =======================================
 32514                                  
 32515                                  FLUSH:
 32516                                  	mov	cx,PRINTF_BUF
 32517                                  	xchg	cx,di
 32518                                  	sub	cx,di
 32519                                  	jz	short OUTCHR_RETN
 32520                                  WRITE_CHARS:
 32521                                  	push	bx
 32522                                  	mov	bx,[cs:PRINTF_HANDLE]
 32523                                  	push	ds
 32524                                  	push	cs
 32525                                  	pop	ds
 32526                                  	mov	dx,PRINTF_BUF
 32527                                  	mov	ah,Write ; 40h
 32528                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32529                                  				; BX = file handle, CX = number	of bytes to write,
 32530                                  				; DS:DX -> buffer
 32531                                  	jnb	short FOOB2_1
 32532                                  	call	GET_EXT_ERR_NUMBER
 32533                                  	cmp	ax,6
 32534                                  	jz	short FOOB2_4
 32535                                  	jmp	short FOOB2_2
 32536                                  
 32537                                  FOOB2_1:
 32538                                  	cmp	cx,ax
 32539                                  	jz	short FOOB2_4
 32540                                  FOOB2_2:
 32541                                  	mov	bx,dx
 32542                                  	add	bx,ax
 32543                                  	cmp	byte [bx],1Ah
 32544                                  	jz	short FOOB2_4
 32545                                  	pop	ds
 32546                                  	pop	bx
 32547                                  	mov	es,[cs:RESSEG]
 32548                                  	mov	dx,NOSPACEPTR
 32549                                  	test	byte [es:PIPEFLAG],0FFh
 32550                                  	jz	short PRINT_ERR_EXIT
 32551                                  	call	PIPEOFF
 32552                                  	mov	dx,PIPEEMESPTR
 32553                                  PRINT_ERR_EXIT:	
 32554                                  	jmp	CERROR
 32555                                  
 32556                                  FOOB2_4:
 32557                                  	pop	ds
 32558                                  	pop	bx
 32559                                  	retn
 32560                                  
 32561                                  ; =============== S U B	R O U T	I N E =======================================
 32562                                  
 32563                                  NEXT_CHRS:
 32564                                  	push	si		;Save pointer to control string
 32565                                  	mov	si,bx		;Get index into argument list
 32566                                  	add	bx,2		;Increment the index
 32567                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32568                                  	mov	dx,[si]		; Get (address of the) next argument			
 32569                                  	pop	si
 32570                                  	retn
 32571                                  
 32572                                  ; =============== S U B	R O U T	I N E =======================================
 32573                                  
 32574                                  CLEAR_FLAGS:
 32575                                  	xor	ax,ax
 32576                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32577                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32578                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32579                                  	mov	al,' '			
 32580                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32581                                  	retn
 32582                                  
 32583                                  ; ---------------------------------------------------------------------------
 32584                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32585                                  
 32586                                  	; times 7 db 0
 32587                                  
 32588                                  %endif
 32589                                  
 32590                                  ;============================================================================
 32591                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32592                                  ;============================================================================
 32593                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32594                                  
 32595                                  ; ----------------------------
 32596                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32597                                  ; ----------------------------
 32598                                  
 32599                                  ;; Replacable parameters are described by a sublist structure
 32600                                  
 32601                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32602 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32603 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32604 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32605 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32606 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32607 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32608 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32609 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32610                                  endstruc
 32611                                  
 32612                                  ; ---------------------------------------------------------------------------
 32613                                  ; ---------------------------------------------------------------------------
 32614                                  
 32615                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32616                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32617                                  
 32618                                  Printf_Init:
 32619 00004DDD E80F00                  	call	std_printf
 32620 00004DE0 CB                      	retf
 32621                                  
 32622                                  Printf_Crlf:
 32623 00004DE1 E80B00                  	call	std_printf
 32624                                  	;call	CRLF2
 32625                                  	;retn
 32626                                  	; 07/04/2023
 32627 00004DE4 E9EAD7                  	jmp	CRLF2
 32628                                  
 32629                                  
 32630                                  ;****************************************************************
 32631                                  ;*
 32632                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32633                                  ;*
 32634                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32635                                  ;*		Set up substitutions if utility message.  Make
 32636                                  ;*		sure any changes to message variables in TDATA
 32637                                  ;*		are reset to avoid reloading the transient.
 32638                                  ;*
 32639                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32640                                  ;*		Msg_Cont_Flag	-  set to control flags
 32641                                  ;*		DS	points to transient segment
 32642                                  ;*
 32643                                  ;*		if utility message:
 32644                                  ;*		DX	points to a block with message number
 32645                                  ;*			(word), number of substitutions (byte),
 32646                                  ;*			followed by substitution list if there
 32647                                  ;*			are substitutions.  If substitutions
 32648                                  ;*			are not in transient segment they must
 32649                                  ;*			be set.
 32650                                  ;*		else
 32651                                  ;*		AX	set to message number
 32652                                  ;*
 32653                                  ;* OUTPUT:	none
 32654                                  ;*
 32655                                  ;****************************************************************
 32656                                  
 32657                                  std_eprintf:
 32658 00004DE7 C706[F187]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32659 00004DED EB06                    	jmp	short new_printf		;AC000;
 32660                                  
 32661                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32662                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32663                                  	; 15/06/2023
 32664                                  std_printf:
 32665 00004DEF C706[F187]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32666                                  
 32667                                  new_printf:
 32668 00004DF5 50                      	push	ax				;AN000;save registers
 32669 00004DF6 53                      	push	bx				;AN000;
 32670 00004DF7 51                      	push	cx				;AN000;
 32671 00004DF8 06                      	push	es				;AN000;get local ES
 32672 00004DF9 1E                      	push	ds				;AN000;
 32673 00004DFA 07                      	pop	es				;AN000;
 32674 00004DFB 57                      	push	di				;AN000;
 32675 00004DFC 56                      	push	si				;AN000;
 32676 00004DFD 52                      	push	dx				;AN000;
 32677                                  
 32678                                  	; 07/04/2023
 32679                                  	;mov	word [print_err_flag],0		;AN000;
 32680 00004DFE 31C9                    	xor	cx,cx
 32681 00004E00 890E[BB8D]              	mov	[print_err_flag],cx ; 0
 32682                                  
 32683 00004E04 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32684 00004E06 AD                      	lodsw					;AN000;load message number
 32685                                  	; 15/06/2023
 32686                                  	;push	ax				;AN000;save it
 32687                                  	;lodsb					;AN000;get number of substitutions
 32688                                  	;mov	cl,al				;AN000;set up CX as # of subst
 32689                                  	;; 07/04/2023
 32690                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 32691                                  	;pop	ax				;AN000;get message number back
 32692                                  	; 15/06/2023
 32693 00004E07 8A0C                    	mov	cl,[si]
 32694 00004E09 46                      	inc	si
 32695                                  	
 32696                                  	;cmp	cx,0				;AN000;Any substitutions?
 32697                                  	; 07/04/2023
 32698 00004E0A 21C9                    	and	cx,cx
 32699 00004E0C 745C                    	jz	short ready_to_print		;AN000;No - continue
 32700                                  
 32701 00004E0E BF[BD8D]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32702 00004E11 57                      	push	di				;AN061; save it
 32703 00004E12 51                      	push	cx				;AN061; save number of subst
 32704                                  
 32705                                  move_subst:
 32706 00004E13 51                      	push	cx				;AN061;save number of subst
 32707 00004E14 89F3                    	mov	bx,si				;AN061;save start of sublist
 32708                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32709                                  	; 07/04/2023
 32710 00004E16 B10B                    	mov	cl,parm_block_size ; 11
 32711 00004E18 F3A4                    	rep	movsb				;AN061;move sublist
 32712                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32713 00004E1A F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32714                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32715 00004E1E 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32716                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32717                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32718 00004E20 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32719                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32720                                  	;mov	word [bx+4],0			;AN061;
 32721 00004E23 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32722                                  
 32723                                  move_subst_cont:				;AN061;
 32724 00004E26 59                      	pop	cx				;AN061;get number of subst back
 32725 00004E27 E2EA                    	loop	move_subst			;AN061;move cx sublists
 32726                                  
 32727 00004E29 59                      	pop	cx				;AN061;get number of subst
 32728 00004E2A 50                      	push	ax				;AN061;save message number
 32729 00004E2B 803E[197F]FF            	cmp	byte [msg_disp_class],util_msg_class
 32730                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32731 00004E30 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32732                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32733 00004E32 C606[B78D]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32734 00004E37 BF[1B7F]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32735 00004E3A 31C0                    	xor	ax,ax				;AN061;clear ax register
 32736 00004E3C AB                      	stosw					;AN061;clear out message number
 32737 00004E3D AA                      	stosb					;AN061;clear out subst count
 32738                                  
 32739                                  check_fix:					;AN061;
 32740 00004E3E 58                      	pop	ax				;AN061;get message number back
 32741 00004E3F 5F                      	pop	di				;AN061;get start of sublists
 32742 00004E40 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32743 00004E42 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32744 00004E44 51                      	push	cx				;AN061;save number of subst
 32745                                  
 32746                                  set_subst:					;AN061;store the segment of the subst
 32747 00004E45 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32748                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32749 00004E49 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32750 00004E4B F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32751                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32752                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32753 00004E4F 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32754 00004E51 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32755                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32756                                  
 32757                                  subst_seg_set:					;AN061;
 32758 00004E54 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32759 00004E57 E2EC                    	loop	set_subst			;AN061;loop CX times
 32760 00004E59 59                      	pop	cx				;AN061;get number of subst back
 32761                                  
 32762 00004E5A 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32763 00004E5C 817F02[358C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32764                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32765 00004E61 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32766                                  	; 01/05/2023
 32767 00004E63 8B16[358C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32768 00004E67 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32769                                  						;AN061;put it into the subst block
 32770                                  	;mov	[bx+2],dx
 32771                                  
 32772                                  ready_to_print:
 32773 00004E6A 8B1E[F187]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32774 00004E6E 8A16[1A7F]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32775 00004E72 8A36[197F]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32776 00004E76 C606[1A7F]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32777                                  						;AN061;reset flags to avoid
 32778 00004E7B C606[197F]FF            	mov	byte [msg_disp_class],util_msg_class
 32779                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32780                                  
 32781 00004E80 1E                      	push	ds				;AN026;
 32782 00004E81 06                      	push	es				;AN026;
 32783                                  
 32784 00004E82 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32785                                  
 32786 00004E85 07                      	pop	es				;AN026; restore registers
 32787 00004E86 1F                      	pop	ds				;AN026;
 32788                                  
 32789 00004E87 7303                    	jnc	short print_success		;AN000; everything went okay
 32790 00004E89 A3[BB8D]                	mov	[print_err_flag],ax		;AN000;
 32791                                  
 32792                                  print_success:
 32793 00004E8C 5A                      	pop	dx				;AN061;restore dx
 32794 00004E8D 5E                      	pop	si				;AN000;restore registers
 32795 00004E8E 5F                      	pop	di				;AN000;
 32796 00004E8F 07                      	pop	es				;AN000;restore registers
 32797 00004E90 59                      	pop	cx				;AN000;
 32798 00004E91 5B                      	pop	bx				;AN000;
 32799 00004E92 58                      	pop	ax				;AN000;
 32800 00004E93 833E[BB8D]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32801 00004E98 7501                    	jnz	short print_err			;AN000;
 32802                                  
 32803 00004E9A C3                      	retn					;AC000;
 32804                                  
 32805                                  print_err:
 32806 00004E9B 0E                      	push	cs
 32807 00004E9C 07                      	pop	es
 32808 00004E9D 833E[F187]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32809 00004EA2 7503                    	jne	short not_stderr		;AN026;no - continue
 32810 00004EA4 E95DB2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32811                                  
 32812                                  not_stderr:
 32813 00004EA7 A1[BB8D]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32814 00004EAA 8E06[C58A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32815                                  						;  right error msg, and jmp to cerror.
 32816 00004EAE 26F606[0002]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32817 00004EB4 7408                    	jz	short _go_to_error
 32818 00004EB6 E8AFE0                  	call	PipeOff
 32819 00004EB9 BA[7C80]                	mov	dx,PIPEEMES_PTR
 32820 00004EBC EB0B                    	jmp	short print_err_exit			;AC000;
 32821                                  
 32822                                  _go_to_error:
 32823 00004EBE C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class
 32824                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32825 00004EC3 BA[1B7F]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32826 00004EC6 A3[1B7F]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32827                                  
 32828                                  print_err_exit: 				;AC000;
 32829 00004EC9 0E                      	push	cs
 32830 00004ECA 07                      	pop	es
 32831 00004ECB E984DA                  	jmp	cerror
 32832                                  
 32833                                  ;****************************************************************
 32834                                  ;*
 32835                                  ;* ROUTINE:	TSYSLOADMSG
 32836                                  ;*
 32837                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32838                                  ;*		names since these routines are also used in the
 32839                                  ;*		resident.
 32840                                  ;*
 32841                                  ;* INPUT:	Inputs to SYSLOADMSG
 32842                                  ;*
 32843                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32844                                  ;*
 32845                                  ;****************************************************************
 32846                                  
 32847                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32848                                  TSYSLOADMSG:
 32849 00004ECE 53                      	push	bx				;AN000;
 32850 00004ECF E80800                  	call	SYSLOADMSG			;AN000; call routine
 32851 00004ED2 5B                      	pop	bx				;AN000;
 32852 00004ED3 C3                      	retn					;AN000; exit
 32853                                  
 32854                                  ;****************************************************************
 32855                                  ;*
 32856                                  ;* ROUTINE:	TSYSGETMSG
 32857                                  ;*
 32858                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32859                                  ;*		names since these routines are also used in the
 32860                                  ;*		resident.
 32861                                  ;*
 32862                                  ;* INPUT:	Inputs to SYSGETMSG
 32863                                  ;*
 32864                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32865                                  ;*
 32866                                  ;****************************************************************
 32867                                  
 32868                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32869                                  TSYSGETMSG:
 32870 00004ED4 51                      	push	cx				;AN000;
 32871 00004ED5 E8B500                  	call	SYSGETMSG			;AN000; call routine
 32872 00004ED8 59                      	pop	cx				;AN000;
 32873 00004ED9 C3                      	retn					;AN000; exit
 32874                                  
 32875                                  ;============================================================================
 32876                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 32877                                  ;============================================================================
 32878                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32879                                  
 32880                                  ; ---------------------------------------------------------------------------
 32881                                  ; MODULE NAME: MSGSERV.SAL
 32882                                  ;
 32883                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 32884                                  ;
 32885                                  ; FUNCTION: This module incorporates all the messages services and
 32886                                  ;	    is called upon at build time to INCLUDE the code requested
 32887                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 32888                                  ;
 32889                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 32890                                  ;	    requested procedure.
 32891                                  ;
 32892                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 32893                                  ;	    function requested.
 32894                                  ;
 32895                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 32896                                  ;
 32897                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 32898                                  ;
 32899                                  ; INTERNAL REFERENCES: (list of included subroutines)
 32900                                  ;
 32901                                  ;	- SYSLOADMSG
 32902                                  ;	- SYSDISPMSG
 32903                                  ;	- SYSGETMSG
 32904                                  ;
 32905                                  ; EXTERNAL REFERENCES: None
 32906                                  ;
 32907                                  ; NOTES: At build time, some modules must be included. These are only included
 32908                                  ;	 once using assembler switches. Other logic is included at the request
 32909                                  ;	 of the utility.
 32910                                  ;
 32911                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 32912                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 32913                                  ;	 storage and multiple EQUates.
 32914                                  ;
 32915                                  ; REVISION HISTORY: Created MAY 1987
 32916                                  ;
 32917                                  ;     Label: DOS - - Message Retriever
 32918                                  ;	     (c) Copyright 1988 Microsoft
 32919                                  ; ---------------------------------------------------------------------------
 32920                                  
 32921                                  ;	Revision History
 32922                                  ;	================
 32923                                  ;
 32924                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 32925                                  ;				$M_DISPLAY_H_STRING to properly
 32926                                  ;				handle Ctrl-Z being passed
 32927                                  ;
 32928                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 32929                                  ;				these routines are no longer assembled.
 32930                                  ;
 32931                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 32932                                  ;				CR-LF string also gets reinitialized
 32933                                  ;				on every cycle.
 32934                                  ;
 32935                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 32936                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 32937                                  
 32938                                  ; ---------------------------------------------------------------------------
 32939                                  
 32940                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32941                                  
 32942                                  ;;; Replacable parameters are described by a sublist structure
 32943                                  ;
 32944                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 32945                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32946                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32947                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32948                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 32949                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32950                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32951                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32952                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32953                                  ;endstruc
 32954                                  
 32955                                  ;; Each class will be defined by this structure.
 32956                                  
 32957                                  struc $M_CLASS_ID		;;AN000;;
 32958 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 32959 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 32960 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 32961                                   .size:
 32962                                  endstruc
 32963                                  
 32964                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 32965                                  
 32966                                  ;; Each message will be defined by this structure.
 32967                                  
 32968                                  struc $M_ID			;;AN000;;
 32969 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 32970 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 32971                                   .size:	
 32972                                  endstruc
 32973                                  
 32974                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 32975                                  
 32976                                  ; ---------------------------
 32977                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 32978                                  ; ---------------------------
 32979                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 32980                                  
 32981                                  ; --------------------------- 
 32982                                  
 32983                                  ; 07/04/2023
 32984                                  $M_NUM_CLS equ 3
 32985                                  
 32986                                  ;; Resident data area definition of variables
 32987                                  
 32988                                  struc $M_RES_ADDRS			;;AN000;;
 32989 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 32990 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 32991 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 32992 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 32993 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 32994 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 32995 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 32996 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 32997 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 32998 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 32999 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33000 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33001 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33002 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33003 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33004 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33005 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33006 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33007 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33008 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33009 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33010 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33011 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33012                                   .size:
 33013                                  endstruc				;;AN000;;
 33014                                  
 33015                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33016                                  
 33017                                  ;; Important fields of the Get Country Information call
 33018                                  
 33019                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33020 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33021                                  					;;AN000;; Go past first part of struc
 33022 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33023 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33024 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33025 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33026 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33027 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33028 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33029 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33030 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33031                                  endstruc				;;AN000;;
 33032                                  
 33033                                  ; ---------------------------------------------------------------------------
 33034                                  
 33035                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33036                                  ;;
 33037                                  ;;	PROC NAME: SYSLOADMSG
 33038                                  ;;
 33039                                  ;;	FUNCTION:
 33040                                  ;;	INPUTS:
 33041                                  ;;
 33042                                  ;;	OUTPUTS:
 33043                                  ;;
 33044                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33045                                  
 33046                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33047                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33048                                  
 33049                                  SYSLOADMSG:
 33050 00004EDA 50                      	push	ax				;;AN000;
 33051 00004EDB 53                      	push	bx				;;AN000;
 33052 00004EDC 52                      	push	dx				;;AN000;
 33053 00004EDD 06                      	push	es				;;AN000;
 33054 00004EDE 57                      	push	di				;;AN000;
 33055 00004EDF 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33056 00004EE1 8EC1                    	mov	es,cx				;;AN000;
 33057 00004EE3 31FF                    	xor	di,di				;;AN000;
 33058 00004EE5 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33059 00004EE8 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33060 00004EEA CD2F                    	int	2Fh				;;AN000;; Private interface
 33061                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33062                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33063                                  		; Return: ES:DI -> error table
 33064                                  	
 33065 00004EEC 8C06[F686]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33066                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33067 00004EF0 893E[F486]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33068                                  	;mov	[$M_RT+8],di			;;AN000;;
 33069                                  
 33070 00004EF4 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33071 00004EF7 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33072 00004EF9 CD2F                    	int	2Fh				;;AN000;; Private interface
 33073                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33074                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33075                                  		; ES:DI -> error table
 33076                                  
 33077 00004EFB 8C06[FE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33078                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33079 00004EFF 893E[FC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33080                                  	;mov	[$M_RT+16],di			;;AN000;;
 33081                                  
 33082 00004F03 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33083 00004F06 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33084 00004F08 CD2F                    	int	2Fh				;;AN000;; Private interface
 33085                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33086                                  		; DL = subfunction - get ??? error table
 33087                                  		; ES:DI -> error table
 33088                                  
 33089 00004F0A 8C06[0E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33090                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33091 00004F0E 893E[0C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33092                                  	;mov	[$M_RT+32],di			;;AN000;;
 33093                                  
 33094 00004F12 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33095 00004F15 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33096 00004F17 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33097                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33098                                  		; DL = subfunction - get ??? error table
 33099                                  		; ES:DI -> error table
 33100                                  
 33101 00004F19 8C06[F286]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33102                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33103 00004F1D 893E[F086]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33104                                  	;mov	[$M_RT+4],di			;;AN001;;
 33105                                  
 33106 00004F21 E8D02F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33107                                  						;;AN000;;
 33108 00004F24 8C06[EE86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33109                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33110 00004F28 893E[EC86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33111                                  	;mov	[$M_RT+0],di			;;AN000;;
 33112 00004F2C 8C06[0A87]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33113                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33114 00004F30 893E[0887]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33115                                  	;mov	[$M_RT+28],di			;;AN000;;
 33116                                  
 33117 00004F34 E8DB2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33118                                  
 33119 00004F37 8C06[0287]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33120                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33121 00004F3B 893E[0087]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33122                                  	;mov	[$M_RT+20],di			;;AN000;;
 33123                                  
 33124 00004F3F B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33125 00004F42 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33126 00004F44 CD2F                    	int	2Fh				;;AN001;; Private interface
 33127                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33128                                  		; DL = subfunction - get ??? error table
 33129                                  		; ES:DI -> error table
 33130                                  
 33131 00004F46 8C06[1687]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33132                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33133 00004F4A 893E[1487]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33134                                  	;mov	[$M_RT+40],di			;;AN001;;
 33135                                  
 33136                                  ;M016; M020
 33137                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33138                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33139                                  
 33140 00004F4E C706[2F87]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33141                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33142 00004F54 C606[7887]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33143                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33144 00004F59 C706[3487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33145                                  	;mov	word [$M_RT+72],0		; M020
 33146 00004F5F C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33147                                  	;mov	word [$M_RT+74],10		; M020
 33148                                  
 33149                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33150                                  	; --------------------------
 33151                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33152                                  	; --------------------------
 33153                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33154                                  
 33155                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33156 00004F65 E82D2F                  	call    $M_CLS_3			; Get addressibility to class F
 33157 00004F68 893E[1887]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33158                                  	;mov	[$M_RT+44],di
 33159                                  	
 33160 00004F6C E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33161                                  
 33162                                  	; 15/04/2023
 33163                                  	;clc					;;AN000;; Make sure carry is clear
 33164                                  	;jc	short $MIF20
 33165                                  	
 33166 00004F6F 5F                      	pop	di				;;AN000;; Restore REGS
 33167 00004F70 07                      	pop	es				;;AN000;;
 33168 00004F71 5A                      	pop	dx				;;AN000;;
 33169 00004F72 5B                      	pop	bx				;;AN000;;
 33170 00004F73 58                      	pop	ax				;;AN000;;
 33171                                  	;jmp	short $MEN20
 33172                                  	; 15/04/2023
 33173 00004F74 C3                      	retn
 33174                                  
 33175                                  	; 15/04/2023
 33176                                  ;$MIF20:
 33177                                  	;add	sp,10				;;AN000;;
 33178                                  	;stc					;;AN000;; Reset carry flag
 33179                                  ;$MEN20:
 33180                                  	;retn					;;AN000;;
 33181                                  
 33182                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33183                                  ;;
 33184                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33185                                  ;;
 33186                                  ;;  Function:	Get the DBCS vector and save it for later use
 33187                                  ;;
 33188                                  ;;  Inputs:	None
 33189                                  ;;
 33190                                  ;;  Outputs:	None
 33191                                  ;;
 33192                                  ;;  Regs Changed:
 33193                                  ;;
 33194                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33195                                  
 33196                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33197                                  
 33198                                  $M_GET_DBCS_VEC:
 33199 00004F75 50                      	push	ax				;;AN000;; Save character to check
 33200 00004F76 56                      	push	si				;;AN000;;
 33201 00004F77 1E                      	push	ds				;;AN000;;
 33202 00004F78 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33203 00004F7B CD21                    	int	21h				;;AN000;; Get environment pointer
 33204 00004F7D 1E                      	push	ds				;;AN000;; Get environment pointer
 33205 00004F7E 07                      	pop	es				;;AN000;; Get environment pointer
 33206 00004F7F 1F                      	pop	ds				;;AN000;; Get environment pointer
 33207 00004F80 7208                    	jc	short $MIF23
 33208                                  	
 33209 00004F82 8936[2887]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33210                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33211 00004F86 8C06[2A87]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33212                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33213                                  $MIF23:
 33214 00004F8A 5E                      	pop	si				;;AN000;;
 33215 00004F8B 58                      	pop	ax				;;AN000;; Retrieve character to check
 33216 00004F8C C3                      	retn					;;AN000;; Return
 33217                                  
 33218                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33219                                  ;;
 33220                                  ;;  Proc Name:	SYSGETMSG
 33221                                  ;;
 33222                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33223                                  ;;		message text to the caller based on a message number.
 33224                                  ;;		The GET function will not display the message thus assumes
 33225                                  ;;		caller will handle replaceable parameters.
 33226                                  ;;
 33227                                  ;;  Inputs:
 33228                                  ;;
 33229                                  ;;  Outputs:
 33230                                  ;;
 33231                                  ;;  Psuedocode:
 33232                                  ;;		Call $M_GET_MSG_ADDRESS
 33233                                  ;;		IF MSG_NUM exists THEN
 33234                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33235                                  ;;		   CARRY_FLAG = 0
 33236                                  ;;		ELSE
 33237                                  ;;		   CARRY_FLAG = 1
 33238                                  ;;		ENDIF
 33239                                  ;;
 33240                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33241                                  
 33242                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33243                                  	; 15/06/2023
 33244                                  
 33245                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33246                                  
 33247                                  SYSGETMSG:
 33248                                  	;; Save registers needed later
 33249 00004F8D 50                      	push	ax				;;AN000;; Save changed regs
 33250 00004F8E 06                      	push	es				;;AN000;;
 33251 00004F8F 57                      	push	di				;;AN000;;
 33252 00004F90 55                      	push	bp				;;AN000;;
 33253                                  
 33254 00004F91 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33255 00004F94 720D                    	jc	short $MIF31
 33256                                  	
 33257 00004F96 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33258                                  	;clc					;;AN000;;
 33259 00004F99 7404                    	je	short $MIF32			;;AN000;;
 33260                                  	; 15/06/2023
 33261 00004F9B F8                      	clc	
 33262                                  
 33263 00004F9C 06                      	push	es				;;AN000;;
 33264                                  	;pop	ds				;;AN000;;
 33265 00004F9D EB01                    	jmp	short $MEN32
 33266                                  $MIF32:
 33267 00004F9F 0E                      	push	cs				;;AN000;;			
 33268                                  	;pop	ds				;;AN000;;
 33269                                  $MEN32:
 33270                                  	; 07/04/2023
 33271 00004FA0 1F                      	pop	ds
 33272 00004FA1 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33273                                  $MIF31:
 33274 00004FA3 5D                      	pop	bp				;;AN000;; Restore changed regs
 33275 00004FA4 5F                      	pop	di				;;AN000;;
 33276 00004FA5 07                      	pop	es				;;AN000;;
 33277 00004FA6 58                      	pop	ax				;;AN000;;
 33278 00004FA7 C3                      	retn					;;AN000;; Return
 33279                                  
 33280                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33281                                  ;;
 33282                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33283                                  ;;
 33284                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33285                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33286                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33287                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33288                                  ;;	REGS CHANGED: ES,DI,CX
 33289                                  ;;
 33290                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33291                                  
 33292                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33293                                  
 33294                                  $M_GET_MSG_ADDRESS:
 33295 00004FA8 56                      	push	si				;;AN000;;
 33296 00004FA9 53                      	push	bx				;;AN000;;
 33297 00004FAA 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33298 00004FAC 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33299                                  $MDO36:
 33300 00004FAE 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33301 00004FB1 7508                    	jne	short $MIF37			;;AN000;; No			
 33302                                  	
 33303                                  	; 07/04/2023
 33304                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33305 00004FB3 8BBC[1887]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33306                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33307 00004FB7 89FB                    	mov	bx,di				;;AN000;;
 33308 00004FB9 EB21                    	jmp	short $MEN37
 33309                                  $MIF37:
 33310 00004FBB F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33311 00004FBE 7406                    	jz	short $MIF39
 33312                                  	
 33313                                  	; 07/04/2023
 33314                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33315 00004FC0 C4BC[FC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33316                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33317                                  	
 33318                                  	; 07/04/2023
 33319                                  	;mov	bx,es ; *			;;AN000;;
 33320 00004FC4 EB14                    	jmp	short $MEN39
 33321                                  $MIF39:
 33322 00004FC6 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33323 00004FC9 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33324                                  
 33325 00004FCB 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33326 00004FCE 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33327                                  
 33328                                  	; 07/04/2023
 33329                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33330 00004FD0 C4BC[0887]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33331                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33332                                  	
 33333                                  	; 07/04/2023
 33334                                  	;mov	bx,es ; *			;;AN000;;
 33335 00004FD4 EB04                    	jmp	short $MEN41
 33336                                  $MIF41:
 33337                                  	; 07/04/2023
 33338                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33339 00004FD6 C4BC[EC86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33340                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33341                                  	
 33342                                  	; 07/04/2023
 33343                                  	;mov	bx,es ; *			;;AN000;;
 33344                                  $MEN41:
 33345                                  $MEN39:
 33346                                  	; 07/04/2023
 33347 00004FDA 8CC3                    	mov	bx,es ; *
 33348                                  $MEN37:						;;AN000;;
 33349 00004FDC 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33350 00004FDF 7515                    	jne	short $MIF46			;;AN000;; No
 33351                                  
 33352 00004FE1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33353 00004FE4 7503                    	jne	short $MIF47			;;AN000;; No
 33354 00004FE6 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33355                                  	; 07/04/2023
 33356                                  	;jmp	short $MEN47 ; **-
 33357 00004FE7 EB1B                    	jmp	short $MEN36 ; **-
 33358                                  $MIF47:
 33359 00004FE9 A3[3487]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 33360                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33361 00004FEC B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33362 00004FEF BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33363 00004FF2 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33364                                  	; 28/04/2023
 33365                                  	; 07/04/2023
 33366                                  	;clc	; **+				;;AN000;;
 33367                                  ;$MEN47:
 33368                                  	;jmp	short $MEN46 ; ***
 33369 00004FF4 EB0A                    	jmp	short $MEN47 ; ***
 33370                                  $MIF46:
 33371                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33372 00004FF6 21DB                    	and	bx,bx ; 0 ?
 33373 00004FF8 7403                    	jz	short $MIF51			;;AN000;; No
 33374                                  	
 33375 00004FFA E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33376                                  $MIF51:
 33377 00004FFD 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33378                                  	; 07/04/2023
 33379                                  	;clc					;;AN000;;
 33380                                  ;$MEN46:
 33381                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33382                                  $MEN47:	; 07/04/2023	; **+
 33383 00005000 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33384                                  	;jnz	short $MXL2			;;AN000;; Yes
 33385                                  	;jmp	short $MDO36
 33386                                  	; 07/04/2023
 33387 00005002 74AA                    	jz	short $MDO36	
 33388                                  $MXL2:
 33389                                  $MEN36:
 33390 00005004 9C                      	pushf 					;;AN006;; Save the flag state
 33391                                  	
 33392 00005005 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33393                                  	;jne	short $MIF56			;;AN006;; No
 33394                                  	; 28/04/2023
 33395 00005008 752A                    	jne	short $M_MYRET	
 33396                                  
 33397 0000500A 52                      	push	dx				;;AN006;; Save all needed registers
 33398 0000500B 55                      	push	bp				;;AN006;;
 33399 0000500C 51                      	push	cx				;;AN006;;
 33400 0000500D 06                      	push	es				;;AN006;;
 33401 0000500E 57                      	push	di				;;AN006;;
 33402 0000500F 50                      	push	ax				;;AN006;;
 33403                                  
 33404 00005010 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33405 00005013 CD2F                    	int	2Fh				;;AN006;;
 33406                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33407                                  		; Return: AL = 00h not installed, OK to install
 33408                                  		; 01h not installed, can't install
 33409                                  		; FFh installed
 33410                                  
 33411 00005015 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33412 00005017 58                      	pop	ax				;;AN006;; Restore msg number
 33413 00005018 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33414                                  
 33415 0000501A 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33416 0000501C B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33417 0000501F CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33418                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33419                                  
 33420                                  	;jmp	short $MEN57			;;AN006;;
 33421                                  	; 28/04/2023
 33422 00005021 720B                    	jc	short $MEN57
 33423                                  $MIF60:
 33424 00005023 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33425 00005026 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33426                                  $MEN60:
 33427 00005029 5D                      	pop	bp				;;AN006;; Restore other Regs
 33428 0000502A 5A                      	pop	dx				;;AN006;;
 33429                                  $MIF56:
 33430                                  	; 07/04/2023
 33431                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33432 0000502B EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33433                                  
 33434                                  $MIF57:
 33435 0000502D F9                      	stc					;;AN006;; Carry conditon
 33436                                  $MEN57:
 33437                                  	; 28/04/2023
 33438                                  	;jnc	short $MIF60			;;AN006;;
 33439                                  
 33440 0000502E 5F                      	pop	di				;;AN006;;
 33441 0000502F 07                      	pop	es				;;AN006;; Restore old pointer
 33442 00005030 59                      	pop	cx				;;AN006;;
 33443 00005031 EBF6                    	jmp	short $MEN60
 33444                                  
 33445                                  ;$MIF60:
 33446                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33447                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33448                                  ;$MEN60:
 33449                                  ;	pop	bp				;;AN006;; Restore other Regs
 33450                                  ;	pop	dx				;;AN006;;
 33451                                  ;$MIF56:
 33452                                  ;	; 07/04/2023
 33453                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33454                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33455                                  
 33456                                  ; 07/04/2023
 33457                                  ; ---------------------------
 33458                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33459                                  ; ---------------------------
 33460                                  	; $M_POPF macro
 33461                                  	;jmp	short $+3
 33462                                  m_popf_iret:
 33463 00005033 CF                      	iret
 33464                                  $M_MYRET:
 33465 00005034 0E                      	push	cs
 33466 00005035 E8FBFF                  	call	m_popf_iret
 33467                                  	;;; end macro	
 33468                                  ; ---------------------------
 33469                                  
 33470 00005038 5B                      	pop	bx				;;AN000;;
 33471 00005039 5E                      	pop	si				;;AN000;;
 33472 0000503A C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33473                                  
 33474                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33475                                  
 33476                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33477                                  $M_SET_LEN_IN_CX:			
 33478 0000503B 57                      	push	di				;;AN006;; Save position
 33479 0000503C 50                      	push	ax				;;AN006;;
 33480 0000503D B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33481 00005040 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33482 00005042 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33483 00005044 F7D1                    	not	cx				;;AN006;; Change decrement into number
 33484 00005046 49                      	dec	cx				;;AN006;; Don't include the zero
 33485 00005047 58                      	pop	ax				;;AN006;;
 33486 00005048 5F                      	pop	di				;;AN006;; Restore position
 33487 00005049 C3                      	retn					;;AN006;;
 33488                                  
 33489                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33490                                  ;;
 33491                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33492                                  ;;
 33493                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33494                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33495                                  ;;		   CX contains the number of messages in class
 33496                                  ;;		   DH contains the message class
 33497                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33498                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33499                                  ;;
 33500                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33501                                  
 33502                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33503                                  	; 15/06/2023
 33504                                  $M_FIND_SPECIFIED_MSG:
 33505 0000504A 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33506 0000504D 751F                    	jne	short $MIF64
 33507 0000504F 833E[1487]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33508                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33509                                  	; 15/06/2023 (BugFix)
 33510 00005054 7418                    	je	short $MIF64
 33511                                  
 33512 00005056 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33513 00005059 750B                    	jne	short $MIF65
 33514                                  	
 33515 0000505B 50                      	push	ax				;;AN004;; Reset the special message number
 33516 0000505C A1[3487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33517                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33518 0000505F FF1E[1487]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33519                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33520 00005063 58                      	pop	ax				;;AN004;; Reset the special message number
 33521                                  	; 28/04/2023
 33522 00005064 EB04                    	jmp	short $MEN65
 33523                                  	; 18/04/2023
 33524                                  	;jmp	short $MEN64
 33525                                  $MIF65:
 33526 00005066 FF1E[1487]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33527                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33528                                  $MEN65:
 33529                                  	; 28/04/2023
 33530 0000506A 7344                    	jnc	short $MIF75
 33531                                  	;
 33532 0000506C EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33533                                  $MIF64:
 33534 0000506E 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33535 00005070 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33536 00005073 7406                    	je	short $MIF69
 33537                                  	
 33538 00005075 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33539                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33540 00005079 EB09                    	jmp	short $MEN69
 33541                                  $MIF69:
 33542                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33543                                  	;cmp	[cs:di+0],dh
 33544 0000507B 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33545 0000507E 7504                    	jne	short $MIF71
 33546                                  
 33547 00005080 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33548                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33549                                  $MIF71:						;;AN001;;
 33550                                  $MEN69:
 33551 00005084 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33552                                  	; 02/05/2023
 33553                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33554                                  $MEN64:
 33555                                  	;jnc	short $MIF75
 33556                                  	; 28/04/2023
 33557                                  	; (or instruction clears carry flag)
 33558                                  	;clc					;;AN004;; No, reset carry
 33559                                  $MDO76:
 33560 00005087 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33561 00005089 7417                    	jz	short $MEN76
 33562                                  
 33563 0000508B 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33564 0000508E 7405                    	je	short $MIF78
 33565                                  
 33566                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33567 00005090 263B05                  	cmp	ax,[es:di]
 33568 00005093 EB03                    	jmp	short $MEN78
 33569                                  $MIF78:
 33570                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33571 00005095 2E3B05                  	cmp	ax,[cs:di]
 33572                                  $MEN78:
 33573                                  	;jne	short $MIF76
 33574                                  	;jmp	short $MSR76
 33575                                  	; 07/04/2023
 33576 00005098 740B                    	je	short $MSR76 ; *
 33577                                  $MIF76:
 33578 0000509A 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33579 0000509B 7405                    	jz	short $MEN76
 33580                                  
 33581 0000509D 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33582 000050A0 EBE5                    	jmp	short $MDO76			;;AN000;;
 33583                                  $MEN76:
 33584 000050A2 F9                      	stc					;;AN000;;
 33585                                  ;$MSR76:	; 07/04/2023
 33586                                  	;jc	short $MIF86			;;AN000;;
 33587                                  	; 07/04/2023
 33588                                  	;jc	short $MIF91
 33589 000050A3 EB11                    	jmp	short $MIF91 ;*
 33590                                  $MSR76:	; 07/04/2023 ; *	
 33591 000050A5 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33592                                  	; 07/04/2023
 33593                                  	;clc					;;AN001;;
 33594 000050A8 7502                    	jne	short $MIF87
 33595                                  
 33596 000050AA 0E                      	push	cs				;;AN000;;
 33597 000050AB 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33598                                  $MIF87:
 33599                                  	;add	di,[es:di+2]
 33600 000050AC 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33601                                  $MIF86:
 33602                                  ;$MIF75:
 33603                                  	; 02/05/2023
 33604                                  	;jc	short $MIF91
 33605                                  $MIF75:	; 28/04/2023
 33606 000050B0 30ED                    	xor	ch,ch				;;AN000;;
 33607 000050B2 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33608 000050B5 47                      	inc	di				;;AN000;; Increment past length
 33609                                  $MIF91:
 33610 000050B6 C606[2E87]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33611                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33612 000050BB C3                      	retn					;;AN000;; Return
 33613                                  
 33614                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33615                                  ;;
 33616                                  ;;  Proc Name:	SYSDISPMSG
 33617                                  ;;
 33618                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33619                                  ;;		requested by the caller. It also provides function to display
 33620                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33621                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33622                                  ;;		defined previous to entry.
 33623                                  ;;
 33624                                  ;;		It is assumes that a PRELOAD function has already determined
 33625                                  ;;		the addressibilty internally to the message retriever services.
 33626                                  ;;  Inputs:
 33627                                  ;;
 33628                                  ;;  Outputs:
 33629                                  ;;
 33630                                  ;;  Psuedocode:
 33631                                  ;;		Save registers needed later
 33632                                  ;;		Get address of the message requested
 33633                                  ;;		IF Message number exists THEN
 33634                                  ;;		  IF replacable parameters were specified THEN
 33635                                  ;;		     Display message with replacable parms
 33636                                  ;;		  ELSE
 33637                                  ;;		     Display string without replacable parms
 33638                                  ;;		  ENDIF
 33639                                  ;;		  IF character input was requested THEN
 33640                                  ;;		     Wait for character input
 33641                                  ;;		  ENDIF
 33642                                  ;;		  Clear CARRY FLAG
 33643                                  ;;		ELSE
 33644                                  ;;		   Set CARRY FLAG
 33645                                  ;;		ENDIF
 33646                                  ;;		Return
 33647                                  ;;
 33648                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33649                                  
 33650                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33651                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33652                                  
 33653                                  SYSDISPMSG:
 33654                                  	;; Save registers and values needed later
 33655 000050BC 50                      	push	ax				;;AN000;; Save changed REGs
 33656 000050BD 53                      	push	bx				;;AN000;;
 33657 000050BE 51                      	push	cx				;;AN000;;
 33658 000050BF 55                      	push	bp				;;AN000;;
 33659 000050C0 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33660 000050C1 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33661 000050C2 52                      	push	dx				;;AN000;; Save Input/Class request
 33662                                  
 33663 000050C3 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33664 000050C5 891E[2C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33665                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33666 000050C9 8836[3187]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33667                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33668                                  
 33669                                  	;; Get address of the message requested
 33670 000050CD E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33671 000050D0 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33672 000050D2 7420                    	jz	short $MIF93
 33673                                  						;;AN000;; Yes, Message address in ES:DI
 33674                                  	
 33675                                  	;; Test if replacable parameters were specified
 33676 000050D4 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33677 000050D6 7505                    	jnz	short $MIF94
 33678                                  
 33679                                  	;; Display string without replacable parms
 33680 000050D8 E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33681 000050DB EB03                    	jmp	short $MEN94
 33682                                  $MIF94:
 33683                                  	;; Display message with replacable parms
 33684 000050DD E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33685                                  $MEN94:
 33686 000050E0 720D                    	jc	short $MIF97
 33687 000050E2 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33688 000050E3 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33689 000050E6 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33690 000050E7 5F                      	pop	di				;;AN000;;
 33691                                  	;jmp	short $MEN97 ; ***
 33692                                  	; 08/04/2023
 33693                                  	;jmp	short $MEN93 ; **
 33694                                  
 33695                                  	; 08/04/2023
 33696                                  ;$MEN93:
 33697 000050E8 720D                    	jc	short $MIF104
 33698                                  ;$MEN97:
 33699 000050EA 5D                      	pop	bp				;;AN000;;
 33700 000050EB 59                      	pop	cx				;;AN000;;
 33701 000050EC 5B                      	pop	bx				;;AN000;;
 33702 000050ED 58                      	pop	ax				;;AN000;;
 33703 000050EE C3                      	retn
 33704                                   
 33705                                  $MIF97:
 33706                                  	; 08/04/2023
 33707                                  	;add	sp,6				;;AN000;;
 33708                                  	;stc					;;AN000;; Reset carry flag
 33709                                  ;$MEN97: ; ***
 33710                                  	;jmp	short $MEN93
 33711                                  	; 08/04/2023
 33712                                  	;jmp	short $MIF104
 33713                                  	; 08/04/2023
 33714 000050EF 83C40E                  	add	sp,14 ; 6+8
 33715 000050F2 F9                      	stc
 33716 000050F3 C3                      	retn
 33717                                  $MIF93:
 33718                                  	; 08/04/2023
 33719                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33720                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33721 000050F4 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33722 000050F5 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33723 000050F6 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33724                                  	;stc	; * 				;;AN000;; Set carry flag
 33725                                  	; 08/04/2023
 33726                                  	;jmp short $MIF104 ; *
 33727                                  
 33728                                  ;$MEN93: ; **
 33729                                  ;	jc	short $MIF104
 33730                                  ;$MEN97: ; 08/04/2023
 33731                                  ;	pop	bp				;;AN000;;
 33732                                  ;	pop	cx				;;AN000;;
 33733                                  ;	pop	bx				;;AN000;;
 33734                                  ;	pop	ax				;;AN000;;
 33735                                  ;	;jmp	short $MEN104
 33736                                  ;	; 08/04/2023
 33737                                  ;	retn
 33738                                  
 33739                                  $MIF104: ; *
 33740 000050F7 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33741 000050FA F9                      	stc					;;AN000;;
 33742                                  $MEN104:
 33743 000050FB C3                      	retn					;;AN000;; Return
 33744                                  
 33745                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33746                                  ;;
 33747                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33748                                  ;;
 33749                                  ;;	FUNCTION:  Will display or write string
 33750                                  ;;	INPUTS:    ES:DI points to beginning of message
 33751                                  ;;		   CX contains the length of string to write (if applicable)
 33752                                  ;;	OUTPUTS:   None
 33753                                  ;;	REGS Revised: None
 33754                                  ;;
 33755                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33756                                  
 33757                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33758                                  
 33759                                  $M_DISPLAY_STRING:
 33760 000050FC 50                      	push	ax				;;AN000;;
 33761 000050FD 53                      	push	bx				;;AN000;;
 33762 000050FE 52                      	push	dx				;;AN000;;
 33763 000050FF 8B1E[2C87]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33764                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33765                                  	
 33766 00005103 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33767 00005106 7505                    	jne	short $MIF107
 33768                                  
 33769 00005108 E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33770 0000510B EB03                    	jmp	short $MEN107
 33771                                  $MIF107:
 33772 0000510D E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33773                                  $MEN107:
 33774 00005110 730D                    	jnc	short $MIF110
 33775                                  	
 33776 00005112 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33777                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33778                                  	; 08/04/2023
 33779 00005114 31DB                    	xor	bx,bx
 33780 00005116 CD21                    	int	21h				;;AN000;;
 33781                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33782                                  		; BX = version code (0000h for DOS 3.x)
 33783 00005118 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33784                                  $MEN110: ; 08/04/2023 ; ***
 33785 0000511A 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33786 0000511D F9                      	stc					;;AN000;; Flag that there was an error
 33787                                  	;jmp	short $MEN110 ; ****
 33788                                  	; 08/04/2023
 33789 0000511E C3                      	retn
 33790                                  $MIF110:
 33791                                  	;cmp	bx,$M_NO_HANDLE
 33792 0000511F 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33793 00005122 7409                    	je	short $MIF112 ; *  ; cf = 0
 33794 00005124 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33795 00005126 7405                    	je	short $MIF113 ; ** ; cf = 0
 33796 00005128 E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33797                                  	;add	sp,6				;;AN001;; Clean up stack
 33798                                  	;stc					;;AN001;; Flag that there was an error
 33799                                  	; 08/04/2023
 33800 0000512B EBED                    	jmp	short $MEN110 ; ***
 33801                                  	; 08/04/2023
 33802                                  ;$MIF112:
 33803                                  ;$MEN110: ; ****
 33804                                  	;jc	short $MIF117
 33805                                  $MIF112: ; 08/04/2023	; *
 33806                                  $MIF113:	; **
 33807 0000512D 5A                      	pop	dx				;;AN000;; Restore regs
 33808 0000512E 5B                      	pop	bx				;;AN000;;
 33809 0000512F 58                      	pop	ax				;;AN000;;
 33810                                  $MIF117:
 33811 00005130 C3                      	retn
 33812                                  
 33813                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33814                                  ;;
 33815                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33816                                  ;;
 33817                                  ;;	FUNCTION:  Will display a $ terminated string
 33818                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33819                                  ;;	OUTPUTS:   None
 33820                                  ;;	REGS USED: AX,DX
 33821                                  ;;
 33822                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33823                                  
 33824                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33825                                  
 33826                                  $M_DISPLAY_$_STRING:
 33827 00005131 1E                      	push	ds				;;AN000;;
 33828 00005132 06                      	push	es				;;AN000;;
 33829 00005133 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33830                                  
 33831                                  	; 08/04/2023
 33832 00005134 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33833                                  
 33834                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33835 00005136 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33836 00005139 7518                    	jne	short $MIF119			;;AN000;; No
 33837                                  	
 33838                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33839 0000513B 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33840 0000513E CD21                    	int	21h				;;AN000;; Write character
 33841                                  		; DOS - DISPLAY OUTPUT
 33842                                  		; DL = character to send to standard output
 33843 00005140 1F                      	pop	ds				;;AN000;;
 33844 00005141 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33845 00005143 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33846 00005146 1E                      	push	ds				;;AN000;;
 33847 00005147 06                      	push	es				;;AN000;;
 33848 00005148 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33849 00005149 7316                    	jnc	short $MIF120 ; *
 33850                                  
 33851 0000514B 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33852 0000514F CD21                    	int	21h				;;AN000;; Write character
 33853                                  		; DOS - DISPLAY OUTPUT
 33854                                  		; DL = character to send to standard output
 33855                                  	; 08/04/2023
 33856                                  	;clc					;;AN000;; Clear the DBCS indicator
 33857                                  ;$MIF120:
 33858 00005151 EB0D                    	jmp	short $MEN119
 33859                                  $MIF119:
 33860                                  	; 08/04/2023
 33861                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33862                                  ;$MDO123:
 33863 00005153 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33864                                  	;jz	short $MEN123
 33865                                  	; 18/04/2023
 33866 00005155 740A                    	jz	short $MIF120 ; cf = 0
 33867                                  $MDO123: ; 08/04/2023
 33868 00005157 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 33869 0000515A CD21                    	int	21h				;;AN002;; Display the character
 33870                                  		; DOS - DISPLAY OUTPUT
 33871                                  		; DL = character to send to standard output
 33872 0000515C 47                      	inc	di				;;AN002;; Set pointer to next character
 33873 0000515D 49                      	dec	cx				;;AN002;; Count this character
 33874 0000515E 75F7                    	jnz	short $MDO123
 33875                                  ;$MEN123:
 33876                                  $MEN119:
 33877 00005160 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 33878                                  $MIF120: ; 08/04/2023 ; *
 33879 00005161 1F                      	pop	ds				;;AN000;;
 33880 00005162 C3                      	retn
 33881                                  
 33882                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33883                                  ;;
 33884                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 33885                                  ;; truncates it at the Ctrl-Z if any present.
 33886                                  ;;
 33887                                  ;;	ENTRY:	ds:dx = String to be displayed
 33888                                  ;;		cx = number of chars to be displayed
 33889                                  ;;
 33890                                  ;;	EXIT:	cx = number of chars to be displayed
 33891                                  ;;
 33892                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33893                                  
 33894                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33895                                  scan_ctrlz:
 33896 00005163 57                      	push	di
 33897 00005164 50                      	push	ax
 33898 00005165 06                      	push	es
 33899 00005166 53                      	push	bx
 33900                                  
 33901 00005167 89D7                    	mov	di,dx
 33902 00005169 1E                      	push	ds
 33903 0000516A 07                      	pop	es   			;es:di points at string
 33904                                  
 33905 0000516B 89CB                    	mov	bx,cx			;save current count
 33906                                  
 33907 0000516D B01A                    	mov	al,1Ah	; Ctrl-Z
 33908 0000516F FC                      	cld
 33909 00005170 F2AE                    	repne	scasb			;find first Ctrl-Z
 33910 00005172 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 33911                                  
 33912 00005174 29CB                    	sub	bx,cx
 33913 00005176 4B                      	dec	bx			;bx = new count to display
 33914                                  noCtrlZ:
 33915 00005177 89D9                    	mov	cx,bx			;cx = actual display count
 33916                                  
 33917 00005179 5B                      	pop	bx
 33918 0000517A 07                      	pop	es
 33919 0000517B 58                      	pop	ax
 33920 0000517C 5F                      	pop	di
 33921                                  $MIF127:	; 08/04/2023
 33922 0000517D C3                      	retn
 33923                                  
 33924                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33925                                  ;;
 33926                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 33927                                  ;;
 33928                                  ;;	FUNCTION:  Will display a string to a specified handle
 33929                                  ;;	INPUTS:    ES:DI points to beginning of message
 33930                                  ;;		   CX contains the number of bytes to write
 33931                                  ;;		   BX contains the handle to write to
 33932                                  ;;	OUPUTS:    None
 33933                                  ;;	REGS USED: AX,DX
 33934                                  ;;
 33935                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33936                                  
 33937                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33938                                  
 33939                                  $M_DISPLAY_H_STRING:
 33940 0000517E 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 33941 00005180 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 33942 00005182 74F9                    	jz	short $MIF127
 33943                                  	
 33944 00005184 1E                      	push	ds			;;AN000;;
 33945 00005185 06                      	push	es			;;AN000;;
 33946 00005186 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33947                                  	
 33948 00005187 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33949 00005189 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 33950                                  
 33951 0000518B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 33952 0000518E 7528                    	jne	short $MIF128		;;AN000;; No
 33953                                  
 33954 00005190 CD21                    	int	21h			;;AN000;; Write character
 33955                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33956                                  		; BX = file handle, CX = number of bytes to writ
 33957                                  
 33958 00005192 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33959 00005193 50                      	push	ax			;;AN000;;
 33960 00005194 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 33961 00005197 E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 33962 0000519A 58                      	pop	ax			;;AN000;;
 33963 0000519B 1E                      	push	ds			;;AN000;;
 33964 0000519C 06                      	push	es			;;AN000;;
 33965 0000519D 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33966 0000519E 7306                    	jnc	short $MIF129
 33967                                  	
 33968 000051A0 F8                      	clc				;;AN000;; Clear the DBCS indicator
 33969 000051A1 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33970 000051A3 42                      	inc	dx			;;AN000;; Point to next character
 33971 000051A4 CD21                    	int	21h			;;AN000;; Write character
 33972                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33973                                  		; BX = file handle, CX = number of bytes to write, 
 33974                                  $MIF129:
 33975                                  ;SR;
 33976                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 33977                                  ;0 chars written making the caller think there was an error writing. To 
 33978                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 33979                                  ;the char was written, thus fooling the caller.
 33980                                  
 33981 000051A6 9C                      	pushf				;save flags
 33982 000051A7 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 33983 000051AB 7502                    	jne	short m_popf_j		;no, continue
 33984                                  
 33985 000051AD 89C8                    	mov	ax,cx			;yes, fake as if it was written
 33986                                  m_popf_j:
 33987                                  	; 08/04/2023
 33988                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33989 000051AF EB01                    	jmp	short m_popf		;restore flags
 33990                                  
 33991                                  ; 07/04/2023
 33992                                  ; ---------------------------
 33993                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33994                                  ; ---------------------------
 33995                                  	; $M_POPF macro
 33996                                  	;jmp	short $+3
 33997                                  intret:
 33998 000051B1 CF                      	iret
 33999                                  m_popf:
 34000 000051B2 0E                      	push	cs
 34001 000051B3 E8FBFF                  	call	intret
 34002                                  	;;; end macro	
 34003                                  ; ---------------------------
 34004                                  
 34005 000051B6 EB18                    	jmp	short $MEN128
 34006                                  
 34007                                  $MIF128:
 34008                                  ;SR;
 34009                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34010                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34011                                  
 34012 000051B8 55                      	push	bp			; M007
 34013 000051B9 51                      	push	cx
 34014 000051BA E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34015 000051BD 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34016 000051BF 59                      	pop	cx			;get old count back ;M007
 34017                                  	
 34018 000051C0 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34019                                  	;jnc	short chk_count		;no error, adjust return count
 34020                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34021                                  	; 08/04/2023
 34022 000051C2 720B                    	jc	short m_cnt_ok 
 34023                                  ;M007
 34024                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34025                                  ;return count will be much less and if this returns to the caller we can get
 34026                                  ;spurious error messages. We check here if the count returned is same as
 34027                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34028                                  ;case, we fake it as if all bytes have been written. If the return count
 34029                                  ;does not match either count, then we had some other disk error (such as
 34030                                  ;insufficient disk space) and we pass it through
 34031                                  
 34032                                  chk_count:
 34033 000051C4 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34034 000051C6 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34035 000051C8 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34036 000051CA F8                      	clc				;no error either way ;M007
 34037 000051CB 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34038 000051CD 89C8                    	mov	ax,cx			;return old count ;M007
 34039                                  m_cnt_ok:				; M007
 34040 000051CF 5D                      	pop	bp			; M007
 34041                                  $MEN128:
 34042 000051D0 1F                      	pop	ds			;;AN000;;
 34043                                  ;$MIF127: ; 08/04/2023
 34044 000051D1 C3                      	retn
 34045                                  
 34046                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34047                                  ;;
 34048                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34049                                  ;;
 34050                                  ;;	FUNCTION:  Will set registers for extended error #39
 34051                                  ;;	INPUTS:    None
 34052                                  ;;	OUPUTS:    AX,BX,CX set
 34053                                  ;;	REGS USED:
 34054                                  ;;
 34055                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34056                                  
 34057                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34058                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34059                                  $M_GET_EXT_ERR_39:
 34060 000051D2 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34061                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34062 000051D5 BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34063                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34064 000051D8 B501                    	mov	ch,1			;AN001;
 34065 000051DA C3                      	retn				;AN001;
 34066                                  
 34067                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34068                                  ;;
 34069                                  ;;	PROC NAME: $M_ADD_CRLF
 34070                                  ;;
 34071                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34072                                  ;;	INPUTS:    DX contains the Input/Class requested
 34073                                  ;;	OUTPUTS:   None
 34074                                  ;;	REGS Revised: CX,ES,DI
 34075                                  ;;
 34076                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34077                                  
 34078                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34079                                  
 34080                                  $M_ADD_CRLF:
 34081                                  	;cmp	dh,0FFh
 34082 000051DB 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34083 000051DE 7411                    	je	short $MIF134		;;AN004;; Yes
 34084 000051E0 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 34085 000051E3 750C                    	jnz	short $MIF135
 34086                                  					;;AN004;; No	
 34087 000051E5 1E                      	push	ds			;;AN004;;
 34088 000051E6 07                      	pop	es			;;AN004;; Set ES to data segment
 34089 000051E7 8D3E[2F87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34090                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34091 000051EB B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34092 000051EE E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34093                                  $MIF135:
 34094                                  $MIF134:
 34095 000051F1 C3                      	retn				;;AN004;; Return
 34096                                  
 34097                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34098                                  ;;
 34099                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34100                                  ;;
 34101                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34102                                  ;;	INPUTS:    AL contains the byte to be checked
 34103                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34104                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34105                                  ;;	REGS USED: All restored
 34106                                  ;;
 34107                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34108                                  
 34109                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34110                                  
 34111                                  $M_IS_IT_DBCS:
 34112 000051F2 06                      	push	es			;;AN000;; Save Extra Segment register
 34113 000051F3 57                      	push	di			;;AN000;; Save DI register
 34114                                  
 34115 000051F4 C43E[2887]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34116                                  	;les	di,[$M_RT+60]		;;AN000;;
 34117 000051F8 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34118 000051FA 7417                    	jz	short $MIF138		;;AN000;; No
 34119                                  $MDO139:
 34120 000051FC 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34121                                  					;;AN000;; Is this the terminating flag?
 34122 00005200 F8                      	clc				;;AN000;;
 34123 00005201 7410                    	jz	short $MEN139
 34124                                  					;;AN000;; No
 34125 00005203 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34126 00005206 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34127 00005208 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34128 0000520C 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34129                                  					;;AN000;; Yes
 34130 0000520E F9                      	stc				;;AN000;; Set carry flag
 34131                                  $MIF141:
 34132 0000520F 47                      	inc	di			;;AN000;;
 34133 00005210 47                      	inc	di			;;AN000;;
 34134 00005211 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34135                                  $MEN139:
 34136                                  $MIF138:
 34137 00005213 5F                      	pop	di			;;AN000;; Restore DI register
 34138 00005214 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34139 00005215 C3                      	retn				;;AN000;; Return
 34140                                  
 34141                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34142                                  ;;
 34143                                  ;;	PROC NAME: $M_CONVERT2ASC
 34144                                  ;;
 34145                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34146                                  ;;	INPUTS: DX:AX contains the number to be converted
 34147                                  ;;		$M_RT_DIVISOR contains the divisor
 34148                                  ;;	OUTPUTS: CX contains the number of characters
 34149                                  ;;		Top of stack  --> Last character
 34150                                  ;;				     . . .
 34151                                  ;;		Bot of stack  --> First character
 34152                                  ;;	REGS USED:
 34153                                  ;;
 34154                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34155                                  
 34156                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34157                                  	; 15/06/2023
 34158                                  $M_CONVERT2ASC:
 34159 00005216 8F06[3287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34160                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34161                                  	
 34162 0000521A 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34163 0000521C 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34164 0000521D 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34165                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34166 0000521E F736[3687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34167                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34168 00005222 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34169                                  						;;AN000;;  and save reduced High Word in BX
 34170 00005223 F736[3687]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34171                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34172                                  
 34173 00005227 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34174 0000522A 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34175 0000522C 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34176 0000522F EB03                    	jmp	short $MEN146
 34177                                  $MIF146:
 34178 00005231 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34179                                  $MEN146:
 34180 00005234 52                      	push	dx				;;AN000;; Save the digit on the stack
 34181 00005235 41                      	inc	cx				;;AN000;; Count that digit
 34182 00005236 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34183 00005238 7504                    	jnz	short $MLL149			;;AN000;; No
 34184 0000523A 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34185 0000523C 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34186                                  $MLL149:
 34187 0000523E 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34188                                  ; 28/04/2023
 34189 00005241 740A                    	je	short $MIF153
 34190                                  ;	jne	short $MIF150			;;AN000;; No
 34191                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34192                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34193                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34194                                  ;	;jne	short $MIF151
 34195                                  ;	; 09/04/2023
 34196                                  ;	jne	short $MEN150
 34197                                  ;						;;AN000;; Yes
 34198                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34199                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34200                                  ;	inc	cx				;;AN000;;
 34201                                  ;$MIF151:
 34202                                  ;	jmp	short $MEN150
 34203                                  
 34204                                  $MIF150:
 34205                                  	; 15/06/2023 (6)
 34206                                  	; MSDOS 6.0
 34207                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34208                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34209                                  	; 15/06/2023 (7)
 34210                                  	; MSDOS 6.22
 34211                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34212 00005243 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark	
 34213                                  
 34214                                  ; 28/04/2023
 34215 00005246 7405                    	je	short $MIF153
 34216                                  ;	jne	short $MIF154			;;AN000;; No
 34217                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34218                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34219                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34220                                  ;	;jne	short $MIF155			;;AN000;; No
 34221                                  ;	; 09/04/2023
 34222                                  ;	jne	short $MEN154
 34223                                  ;						;;AN000;; Yes				
 34224                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34225                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34226                                  ;	inc	cx				;;AN000;;
 34227                                  ;$MIF155:
 34228                                  ;	jmp	short $MEN154
 34229                                  
 34230                                  $MIF154:
 34231                                  	; 15/06/2023 (9)
 34232                                  	; MSDOS 6.0
 34233                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh 
 34234                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34235                                  	; 15/06/2023 (11)
 34236                                  	; MSDOS 6.22
 34237                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah 
 34238 00005248 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34239 0000524B 750B                    	jne	short $MIF158			;;AN000;; No  
 34240                                  ; 28/04/2023
 34241                                  $MIF153:
 34242                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34243 0000524D 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34244                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34245 00005251 7505                    	jne	short $MIF159			;;AN000;; No
 34246                                  						;;AN000;; Yes
 34247 00005253 FF36[3F87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34248                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34249 00005257 41                      	inc	cx				;;AN000;;
 34250                                  $MIF159:
 34251                                  $MIF158:
 34252                                  $MEN154:
 34253                                  $MEN150:					;;AN000;;
 34254 00005258 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34255                                  						;;AN000;;  and Revised Low Word
 34256 00005259 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34257                                  	; 28/04/2023
 34258 0000525B EBC1                    	jmp	short $MDO145
 34259                                  ;$MEN145:
 34260                                  	; 28/04/2023
 34261                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34262                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34263 0000525D 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34264 0000525F FF36[3287]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34265                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34266 00005263 C3                      	retn					;;AN000;; Return
 34267                                  
 34268                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34269                                  ;;
 34270                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34271                                  ;;
 34272                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34273                                  ;;	INPUTS:    ES:DI points to beginning of message
 34274                                  ;;		   DS:SI points to first sublist structure in chain
 34275                                  ;;		   BX contains the handle to write to (if applicable)
 34276                                  ;;		   CX contains the length of string to write (before substitutions)
 34277                                  ;;		   BP contains the count of replacables
 34278                                  ;;
 34279                                  ;;	OUTPUTS:
 34280                                  ;;	REGS USED: All
 34281                                  ;;
 34282                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34283                                  
 34284                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34285                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34286                                  
 34287                                  $M_DISPLAY_MESSAGE:
 34288                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34289                                  $MDO165:
 34290 00005264 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34291 00005266 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34292                                  ;; $IF NZ					;;AN000;; No
 34293 00005268 7421                    	jz	short $MIF166			;;AN000;; Yes
 34294 0000526A B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 34295 0000526C B000                    	mov	al,0				;;AN004;;
 34296                                  ;; $DO						;;AN000;; Scan through string until %
 34297                                  $MDO167:
 34298 0000526E 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34299                                  ;; $LEAVE E,AND					;;AN000;; No
 34300 00005271 750A                    	jne	short $MLL168
 34301 00005273 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34302                                  ;; $LEAVE NE,AND				;;AN000;; No
 34303 00005277 7404                    	je	short $MLL168
 34304                                  
 34305 00005279 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34306                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34307 0000527B 750E                    	jne	short MEN167
 34308                                  $MLL168:
 34309 0000527D 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34310 00005280 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34311                                  ;;; $IF C					;;AN004;; Yes
 34312 00005283 7301                    	jnc	short $MIF169
 34313 00005285 47                      	inc	di				;;AN004;; Increment past second part
 34314                                  ;;; $ENDIF					;;AN004;;
 34315                                  $MIF169:
 34316 00005286 47                      	inc	di				;;AN000;; Next character in string
 34317 00005287 42                      	inc	dx				;;AN000;; Size = Size + 1
 34318 00005288 49                      	dec	cx				;;AN000;; Decrement total size
 34319                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34320 00005289 75E3                    	jnz	short $MDO167
 34321                                  $MEN167:
 34322                                  ;; $ENDIF					;;AN000;;
 34323                                  $MIF166:
 34324 0000528B 56                      	push	si				;;AN000;; Save beginning of sublists
 34325 0000528C 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34326 0000528E 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34327                                  ;; $IF NZ					;;AN000;; Yes
 34328 00005290 7431                    	jz	short $MIF173
 34329 00005292 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34330                                  
 34331                                  ;; Search through sublists to find applicable one
 34332                                  
 34333 00005293 833E[3487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34334                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34335                                  ;;; $IF E					;;AN000;; No
 34336 00005298 7529                    	jne	short $MIF174
 34337                                  ;;; $SEARCH					;;AN000;;
 34338                                  $MDO175:
 34339                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34340 0000529A 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34341                                  	;mov	al,[si+6]
 34342 0000529D 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34343                                  	; 28/04/2023					
 34344 0000529F 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34345                                  ;;; $EXITIF E					;;AN000;;
 34346                                  	;jne	short $MIF175
 34347                                  ;;; $ORELSE					;;AN000;; No
 34348                                  	;jmp	short $MSR175
 34349                                  	; 28/04/2023
 34350 000052A3 741E                    	je	short $MSR175
 34351                                  $MIF175:
 34352 000052A5 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34353                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34354 000052A7 7504                    	jne	short $MLL178
 34355 000052A9 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34356                                  ;;; $LEAVE Z					;;AN000;; No
 34357 000052AB 7404                    	jz	short $MEN175
 34358                                  $MLL178:
 34359                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34360                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34361                                  	;;add	si,[si+0]
 34362 000052AD 0334                    	add	si,[si]
 34363                                  ;;; ENDLOOP					;;AN000;; Yes
 34364 000052AF EBE9                    	jmp	short $MDO175
 34365                                  $MEN175:
 34366 000052B1 803E[3187]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34367                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34368                                  ;;;; $IF E					;;AN004;; Yes
 34369 000052B6 7508                    	jne	short $MIF180
 34370 000052B8 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34371 000052B9 42                      	inc	dx				;;AN000;;  at the end of the message
 34372 000052BA 49                      	dec	cx				;;AN000;; Adjust message length
 34373 000052BB 49                      	dec	cx				;;AN000;;
 34374 000052BC 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34375 000052BD 4F                      	dec	di				;;AN000;;
 34376                                  ;;;; $ELSE					;;AN004;; No
 34377 000052BE EB03                    	jmp	short $MEN180
 34378                                  $MIF180:
 34379 000052C0 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34380                                  ;;;; $ENDIF					;;AN004;;
 34381                                  $MEN180:
 34382                                  ;;; $ENDSRCH					;;AN000;;
 34383                                  $MSR175:
 34384                                  ;; $ENDIF					;;AN000;;
 34385                                  $MIF174:
 34386                                  ; $ENDIF					;;AN000;;
 34387                                  $MIF173:
 34388                                  ;; Prepare and display this part of message
 34389                                  
 34390 000052C3 57                      	push	di				;;AN000;; Save pointer to replace number
 34391 000052C4 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34392 000052C6 E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34393 000052C9 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34394 000052CA 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34395                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34396                                  	;jnc	short $MXL3
 34397                                  	;jmp	$MEN165
 34398                                  	; 02/05/2023
 34399 000052CB 7214                    	jc	short $MEN165
 34400                                  $MXL3:
 34401 000052CD 51                      	push	cx				;;AN000;;
 34402                                  
 34403                                  ;; Save and reset pointer registers
 34404                                  
 34405 000052CE 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34406                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34407 000052D0 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34408                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34409                                  ; $IF NE					;;AN000;; No
 34410 000052D4 7412                    	je	short $MIF187			;;AN000;; Yes			
 34411 000052D6 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34412                                  ;; $IF NZ					;;AN000;; No
 34413 000052D8 7406                    	jz	short $MIF188			;;AN000;; Yes
 34414 000052DA 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34415 000052DB 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34416 000052DC 47                      	inc	di				;;AN000;; Go past %
 34417 000052DD 47                      	inc	di				;;AN000;; Go past replace number
 34418                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34419                                  	;jmp	short $MEN188
 34420                                  	; 28/04/2023
 34421 000052DE EB15                    	jmp	short $MEN187
 34422                                  $MIF188:
 34423 000052E0 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34424                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34425                                  $MEN188:
 34426                                  ; $ELSE 					;;AN000;;
 34427                                  	;jmp	short $MEN187
 34428                                  	; 28/04/2023
 34429                                  	; zf = 1
 34430                                  	;jmp	short $MEN165 
 34431                                  
 34432                                  ; 28/04/2023
 34433                                  $MXL4:
 34434                                  $MLL214:
 34435                                  $MEN165:
 34436 000052E1 C706[3487]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34437                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34438                                  						;;AN000;; Reset message number to null
 34439 000052E7 C3                      	retn					;;AN000;; Return
 34440                                  
 34441                                  $MIF187:
 34442 000052E8 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34443                                  ;; $IF Z					;;AN004;; No
 34444                                  	;jnz	short $MIF192
 34445                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34446                                  ;; $ELSE					;;AN000;; No
 34447                                  	;jmp	short $MEN192
 34448                                  	; 28/04/2023
 34449 000052EA 74F4                    	jz	short $MIF188
 34450                                  $MIF192:
 34451 000052EC 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34452                                  ;;; $IF Z					;;AN004;; No
 34453 000052EF 7502                    	jnz	short $MIF194
 34454 000052F1 31C9                    	xor	cx,cx				;;AN004;;
 34455                                  ;;; $ENDIF					;;AN000;;
 34456                                  $MIF194:
 34457 000052F3 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34458                                  ;; $ENDIF					;;AN000;;
 34459                                  $MEN192:
 34460                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34461                                  $MEN187:
 34462                                  ; $LEAVE Z					;;AN000;;
 34463 000052F5 74EA                    	jz	short $MEN165
 34464                                  	;
 34465 000052F7 55                      	push	bp				;;AN000;; Save the replace count
 34466 000052F8 57                      	push	di				;;AN000;; Save location to complete message
 34467 000052F9 06                      	push	es				;;AN000;;
 34468 000052FA 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34469 000052FB 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34470                                  
 34471                                  ;; Determine what action is required on parameter
 34472                                  
 34473 000052FD 833E[3487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34474                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34475                                  ; $IF E						;;AN000;;
 34476 00005302 753B                    	jne	short $MIF199
 34477                                  
 34478                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34479 00005304 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34480                                  	;test	byte [si+7],0Fh			;;AN000;;
 34481                                  ;; $IF Z					;;AN000;;
 34482 00005308 7508                    	jnz	short $MIF200
 34483                                  
 34484                                  ;; Character type requested
 34485                                  
 34486                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34487 0000530A C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34488                                  	;les	di,[si+2]
 34489 0000530D E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34490                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34491 00005310 EB28                    	jmp	short $MEN200
 34492                                  $MIF200:
 34493                                  ;; ENDIF					;;AN000;;
 34494                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34495 00005312 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34496                                  	;test	byte [si+7],0Dh			;;AN000;;
 34497                                  ;; $IF Z,OR					;;AN000;;
 34498 00005316 740C                    	jz	short $MLL202
 34499                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34500 00005318 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34501                                  	;test	byte [si+7],0Eh			;;AN000;;
 34502                                  ;;; $IF Z,OR					;;AN000;;
 34503 0000531C 7406                    	jz	short $MLL202
 34504                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34505 0000531E F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34506                                  	;test	byte [si+7],0Ch			;;AN000;;
 34507                                  ;;;; $IF Z 					;;AN000;;
 34508 00005322 7508                    	jnz	short $MIF202
 34509                                  $MLL202:
 34510                                  
 34511                                  ;; Numeric type requested
 34512                                  
 34513                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34514 00005324 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34515 00005327 E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34516                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34517 0000532A EB0E                    	jmp	short $MEN202
 34518                                  $MIF202:
 34519                                  ;;;; ENDIF					;;AN000;;
 34520                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34521 0000532C F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34522                                  	;test	byte [si+7],0Bh			;;AN000;;
 34523                                  ;;;; $IF E					;;AN000;;
 34524 00005330 7505                    	jnz	short $MIF204
 34525                                  
 34526                                  ;; Date type requested
 34527                                  
 34528 00005332 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34529                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34530 00005335 EB03                    	jmp	short $MEN204
 34531                                  $MIF204:					;;AN000;;
 34532                                  
 34533                                  ;; Time type requested (Default if we have not matched until here)
 34534                                  
 34535 00005337 E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34536                                  
 34537                                  ;;;; $ENDIF					;;AN000;;
 34538                                  $MEN204:
 34539                                  ;;; $ENDIF					;;AN000;;
 34540                                  $MEN202:
 34541                                  ;; $ENDIF					;;AN000;;
 34542                                  $MEN200:
 34543                                  
 34544                                  ;; With the replace information of the Stack, display the replaceable field
 34545                                  
 34546 0000533A E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34547                                  
 34548                                  ;; None of the above - Extended/Parse replace
 34549                                  ; $ELSE 					;;AN000;;
 34550 0000533D EB03                    	jmp	short $MEN199
 34551                                  $MIF199:
 34552 0000533F E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34553                                  ; $ENDIF					;;AN000;;
 34554                                  $MEN199:
 34555                                  
 34556                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34557                                  
 34558                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34559 00005342 7207                    	jc	short $MIF211
 34560                                  	;
 34561 00005344 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34562 00005345 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34563 00005346 5F                      	pop	di				;;AN000;;
 34564 00005347 5D                      	pop	bp				;;AN000;; Get replacment count
 34565 00005348 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34566                                  ; $ELSE						;;AN000;;
 34567 00005349 EB03                    	jmp	short $MEN211
 34568                                  $MIF211:
 34569 0000534B 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34570                                  	; 28/04/2023
 34571                                  	;stc					;;AN000;;
 34572                                  ; $ENDIF					;;AN000;;
 34573                                  $MEN211:
 34574 0000534E 833E[3487]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34575                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34576                                  ; $ENDDO NE,OR					;;AN000;;
 34577 00005353 758C                    	jne	short $MLL214
 34578                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34579                                  	; 10/04/2023
 34580                                  	;jc	short $MXL4
 34581 00005355 E90CFF                  	jmp	$MDO165
 34582                                  
 34583                                  ; 28/04/2023
 34584                                  ;$MXL4:
 34585                                  ;$MLL214:
 34586                                  ;$MEN165:
 34587                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34588                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34589                                  ;						;;AN000;; Reset message number to null
 34590                                  ;	retn					;;AN000;; Return
 34591                                  
 34592                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34593                                  ;;
 34594                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34595                                  ;;
 34596                                  ;;	FUNCTION:
 34597                                  ;;	INPUTS:
 34598                                  ;;	OUPUTS:
 34599                                  ;;
 34600                                  ;;	REGS USED:
 34601                                  ;;
 34602                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34603                                  
 34604                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34605                                  
 34606                                  $M_EXT_PAR_REPLACE:
 34607 00005358 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34608 0000535A A1[3487]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34609                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34610 0000535D C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34611                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34612 00005363 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34613                                  $MDO215:
 34614 00005366 58                      	pop	ax				;;AN000;; Get character in register
 34615 00005367 8887[3887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34616                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34617 0000536B 43                      	inc	bx				;;AN000;; Increase buffer count
 34618 0000536C 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34619 0000536F 7503                    	jne	short $MIF216			;;AN000;; No
 34620 00005371 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34621                                  $MIF216:
 34622 00005374 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34623 00005376 75EE                    	jnz	short $MDO215
 34624                                  
 34625 00005378 B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34626 0000537B 8987[3887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34627                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34628 0000537F 43                      	inc	bx				;;AN000;; Increase buffer count
 34629 00005380 43                      	inc	bx				;;AN000;; Increase buffer count
 34630                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34631                                  	;retn					;;AN000::
 34632                                  	; 11/04/2023
 34633                                  	;jmp	$M_FLUSH_BUF
 34634                                  
 34635                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34636                                  ;;
 34637                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34638                                  ;;
 34639                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34640                                  ;;	INPUTS: DI contains the number of bytes to display
 34641                                  ;;	OUTPUTS: BX reset to zero
 34642                                  ;;
 34643                                  ;;	REGS USED:
 34644                                  ;;
 34645                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34646                                  	
 34647                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34648                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34649                                  
 34650                                  $M_FLUSH_BUF:
 34651 00005381 51                      	push	cx				;;AN000;; Save changed regs
 34652 00005382 06                      	push	es				;;AN000;;
 34653 00005383 57                      	push	di				;;AN000;;
 34654 00005384 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34655 00005385 07                      	pop	es				;;AN000;;
 34656 00005386 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34657 00005388 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34658 0000538A 8D3E[3887]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34659                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34660 0000538E E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34661 00005391 7204                    	jc	short $MIF314
 34662 00005393 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34663 00005394 07                      	pop	es				;;AN000;;
 34664 00005395 59                      	pop	cx				;;AN000;;
 34665                                  	;jmp	short $MEN314
 34666                                  	; 11/04/2023
 34667 00005396 C3                      	retn
 34668                                  $MIF314:
 34669 00005397 83C406                  	add	sp,6				;;AN000;; Fix stack
 34670 0000539A F9                      	stc					;;AN000;;
 34671                                  $MEN314:
 34672 0000539B C3                      	retn					;;AN000;; Return
 34673                                  
 34674                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34675                                  ;;
 34676                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34677                                  
 34678                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34679                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34680                                  
 34681                                  $M_DISPLAY_REPLACE:
 34682 0000539C 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34683                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34684 0000539E 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34685                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34686 000053A2 7511                    	jne	short $MIF276
 34687                                  	
 34688 000053A4 C787[3887]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34689                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34690                                  	
 34691 000053AA 43                      	inc	bx				;;AN000;; Increment count
 34692 000053AB 43                      	inc	bx				;;AN000;; Increment count
 34693                                  	
 34694 000053AC C687[3887]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34695                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34696                                  	
 34697 000053B1 43                      	inc	bx				;;AN000;; Increment count
 34698 000053B2 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34699                                  $MIF276:
 34700 000053B5 5D                      	pop	bp				;;AN000;; Remember the return address
 34701 000053B6 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34702 000053B8 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34703                                  
 34704 000053BA 880E[2E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34705                                  	;mov	[$M_RT+66],cl
 34706                                  	
 34707                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34708 000053BE 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34709                                  	;mov	al,[si+9]
 34710                                  	
 34711 000053C1 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34712 000053C3 761E                    	jna	short $MIF278
 34713 000053C5 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34714 000053C7 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34715                                  	
 34716                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34717 000053C9 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34718                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34719 000053CD 7414                    	jz	short $MIF279			;;AN000;; No
 34720                                  $MDO280:
 34721                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34722 000053CF 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34723                                  	;mov	al,[si+0Ah]
 34724 000053D2 8887[3887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34725                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34726                                  	
 34727 000053D6 43                      	inc	bx				;;AN000;;
 34728 000053D7 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34729 000053DA 7503                    	jne	short $MIF281
 34730 000053DC E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34731                                  $MIF281:
 34732 000053DF FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34733 000053E1 75EC                    	jnz	short $MDO280
 34734                                  $MIF279:
 34735                                  $MIF278:
 34736                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34737 000053E3 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34738                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34739 000053E7 740C                    	je	short $MIF286
 34740                                  	
 34741                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34742 000053E9 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34743                                  	;;cmp	byte [si+8],cl
 34744 000053EC 7307                    	jnb	short $MIF287
 34745                                  
 34746                                  	; 03/05/2023
 34747                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34748                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34749                                  	;;sub	cl,[si+8]
 34750 000053EE 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34751                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34752                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34753                                  	;;mov	cl,[si+8]
 34754                                  	; 03/05/2023
 34755 000053F0 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34756 000053F3 28CA                    	sub	dl,cl
 34757                                  $MIF287:
 34758                                  $MIF286:
 34759 000053F5 09C9                    	or	cx,cx				;;AN000;;
 34760 000053F7 7424                    	jz	short $MIF290			;;AN000;;
 34761                                  $MDO291:
 34762                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34763 000053F9 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34764                                  	;test	byte [si+7],0Fh			;;AN000;;
 34765 000053FD 750C                    	jnz	short $MIF292
 34766                                  
 34767                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34768 000053FF F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34769                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34770 00005403 7406                    	jz	short $MIF292			;;AN000;; No
 34771                                  
 34772 00005405 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34773 00005408 47                      	inc	di				;;AN000;; Next character in string
 34774 00005409 EB01                    	jmp	short $MEN292
 34775                                  $MIF292:
 34776 0000540B 58                      	pop	ax				;;AN000;; Get character in register
 34777                                  $MEN292:
 34778                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34779 0000540C 8887[3887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34780                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34781                                  	; 03/05/2023
 34782 00005410 43                      	inc	bx				;;AN000;; Increase buffer count
 34783 00005411 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34784 00005414 7503                    	jne	short $MIF295			;;AN000;;
 34785 00005416 E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34786                                  $MIF295:
 34787 00005419 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34788 0000541B 75DC                    	jnz	short $MDO291
 34789                                  $MIF290:
 34790                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34791 0000541D F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34792                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34793 00005421 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34794 00005423 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34795 00005425 7414                    	jz	short $MIF300
 34796                                  $MDO301:
 34797                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34798 00005427 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34799                                  	;mov	al,[si+0Ah]
 34800                                  
 34801                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34802 0000542A 8887[3887]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34803                                  	; 03/05/2023
 34804                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34805                                  
 34806 0000542E 43                      	inc	bx				;;AN000;;
 34807 0000542F 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34808 00005432 7503                    	jne	short $MIF302			;;AN000;; No
 34809                                  						;;AN000;; Yes
 34810 00005434 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34811                                  $MIF302:
 34812 00005437 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34813 00005439 75EC                    	jnz	short $MDO301			;;AN000;;
 34814                                  $MIF300:
 34815                                  $MIF299:
 34816                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34817 0000543B F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34818                                  	;test	byte [si+7],0Fh			;;AN000;;
 34819 0000543F 7506                    	jnz	short $MIF307
 34820                                  	
 34821                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34822 00005441 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34823                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34824                                  	; 11/04/2023
 34825                                  	;jz	short $MIF307			;;AN000;;
 34826                                  	;jmp	short $MEN307			;;AN000;;
 34827 00005445 750C                    	jnz	short $MEN307
 34828                                  $MIF307:
 34829 00005447 08D2                    	or	dl,dl				;;AN000;;
 34830 00005449 7408                    	jz	short $MIF309			;;AN000;;
 34831                                  $MDO310:
 34832 0000544B 8F06[3287]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34833                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34834 0000544F FECA                    	dec	dl				;;AN000;; Are we done?
 34835 00005451 75F8                    	jnz	short $MDO310
 34836                                  $MIF309:
 34837                                  $MEN307:
 34838 00005453 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34839 00005456 55                      	push	bp				;;AN000;; Restore the return address
 34840 00005457 C3                      	retn					;;AN000;;
 34841                                  
 34842                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34843                                  ;;
 34844                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34845                                  ;;
 34846                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34847                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34848                                  ;;		ES:DI contains the VALUE from SUBLIST
 34849                                  ;;	OUTPUTS: CX contains number of characters on stack
 34850                                  ;;		 Top of stack  --> Last character
 34851                                  ;;					. . .
 34852                                  ;;		 Bot of stack  --> First character
 34853                                  ;;
 34854                                  ;;	OTHER REGS Revised: AX
 34855                                  ;;
 34856                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34857                                  
 34858                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34859                                  
 34860                                  $M_CHAR_REPLACE:
 34861 00005458 5D                      	pop	bp				;;AN000;; Save return address
 34862                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 34863 00005459 F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 34864                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 34865 0000545D 7512                    	jnz	short $MIF317			;;AN000;; No
 34866 0000545F 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34867 00005462 50                      	push	ax				;;AN000;; Put it on the stack
 34868 00005463 41                      	inc	cx				;;AN000;; Increase the count
 34869 00005464 E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 34870 00005467 7306                    	jnc	short $MIF318
 34871 00005469 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 34872 0000546D 50                      	push	ax				;;AN000;; Put it on the stack
 34873 0000546E F8                      	clc					;;AN000;; Clear the carry
 34874                                  $MIF318:
 34875 0000546F EB0D                    	jmp	short $MEN317
 34876                                  $MIF317:
 34877                                  $MDO321:
 34878 00005471 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34879 00005474 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 34880 00005476 7404                    	jz	short $MEN321			;;AN000;; Yes
 34881 00005478 47                      	inc	di				;;AN000;; Next character
 34882 00005479 41                      	inc	cx				;;AN000;; Increment the count
 34883 0000547A EBF5                    	jmp	short $MDO321
 34884                                  $MEN321:
 34885 0000547C 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 34886                                  $MEN317:
 34887 0000547E 55                      	push	bp				;;AN000;; Restore return address
 34888 0000547F C3                      	retn					;;AN000;;	
 34889                                  
 34890                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34891                                  ;;
 34892                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 34893                                  ;;
 34894                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 34895                                  ;;		  and prepare to display
 34896                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34897                                  ;;		ES:DI contains the VALUE from SUBLIST
 34898                                  ;;	OUTPUTS: CX contains number of characters on stack
 34899                                  ;;		 Top of stack  --> Last character
 34900                                  ;;					. . .
 34901                                  ;;		 Bot of stack  --> First character
 34902                                  ;;	OTHER REGS Revised: BX,DX,AX
 34903                                  ;;
 34904                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34905                                  
 34906                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34907                                  
 34908                                  $M_BIN2ASC_REPLACE:
 34909 00005480 5D                      	pop	bp				;;AN000;; Save return address
 34910 00005481 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34911 00005483 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 34912 00005485 C706[3687]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 34913                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 34914                                  
 34915 0000548B 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 34916                                  
 34917                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 34918 0000548D F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34919                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 34920 00005491 7511                    	jnz	short $MIF325			;;AN000;; No
 34921                                  	
 34922 00005493 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 34923                                  
 34924                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34925 00005496 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34926                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 34927 0000549A 753D                    	jnz	short $MIF326			;;AN000;; No
 34928                                  			 
 34929 0000549C A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 34930 0000549E 7433                    	jz	short $MIF327			;;AN000;; No
 34931                                  						;;AN000;; Yes				
 34932                                  	; 12/04/2023
 34933                                  	;inc	bx				;;AN000;; Remember that it was negative
 34934 000054A0 247F                    	and	al,01111111b			;;AN000;; Make it positive
 34935                                  
 34936                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 34937                                  	;jmp	short $MIF327
 34938 000054A2 EB2E                    	jmp	short $MIF350 ; inc bx
 34939                                  
 34940                                  ; 12/04/2023
 34941                                  %if 0
 34942                                  
 34943                                  $MIF327:
 34944                                  $MIF335:	; 12/04/2023
 34945                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34946                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34947                                  $MIF326:
 34948                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34949                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34950                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34951                                  	jnz	short $MIF330			;;AN000;; No
 34952                                  						;;AN000;; Yes
 34953                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34954                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34955                                  $MIF330:
 34956                                  	jmp	short $MEN325
 34957                                  
 34958                                  %endif
 34959                                  
 34960                                  $MIF325:
 34961                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 34962 000054A4 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34963                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 34964 000054A8 7513                    	jnz	short $MIF333			;;AN000;; No
 34965                                  						;;AN000;; Yes
 34966 000054AA 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 34967                                  
 34968                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34969 000054AD F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34970                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34971 000054B1 7526                    	jnz	short $MIF334			;;AN000;; No
 34972                                  						;;AN000;; Yes
 34973 000054B3 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 34974 000054B6 741B                    	jz	short $MIF335			;;AN000;; No
 34975                                  						;;AN000;; Yes
 34976                                  	; 12/04/2023
 34977                                  	;inc	bx				;;AN000;; Remember that it was negative
 34978 000054B8 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 34979                                  
 34980                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34981                                  	;jmp	short $MIF335
 34982 000054BB EB15                    	jmp	short $MIF350 ; inc bx
 34983                                  
 34984                                  ; 12/04/2023
 34985                                  %if 0
 34986                                  
 34987                                  $MIF335:
 34988                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34989                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34990                                  $MIF334:
 34991                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 34992                                  	jnz	short $MIF338
 34993                                  
 34994                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34995                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34996                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34997                                  	jnz	short $MIF338			;;AN000;; No
 34998                                  						;;AN000;; Yes
 34999                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35000                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35001                                  $MIF338:
 35002                                  	jmp	short $MEN333			;;AN000;;
 35003                                  %endif
 35004                                  
 35005                                  $MIF333:
 35006 000054BD 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35007 000054C0 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35008                                  
 35009                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35010 000054C4 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35011                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35012 000054C8 750F                    	jnz	short $MIF341			;;AN000;; No
 35013                                  						;;AN000;; Yes
 35014 000054CA F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35015 000054CD 7404                    	jz	short $MIF342			;;AN000;; No
 35016                                  						;;AN000;; Yes
 35017                                  	; 12/04/2023
 35018                                  	;inc	bx				;;AN000;; Remember that it was negative
 35019 000054CF 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35020                                  	
 35021                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35022                                  $MIF350:
 35023 000054D2 43                      	inc	bx
 35024                                  $MIF342:
 35025                                  	; 12/04/2023
 35026                                  $MIF327:
 35027                                  $MIF335:
 35028 000054D3 C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35029                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35030                                  $MIF341:
 35031                                  $MIF326:
 35032                                  	; 18/04/2023
 35033                                  $MIF334:
 35034                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35035 000054D9 F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35036                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35037 000054DD 7506                    	jnz	short $MIF345			;;AN000;; No
 35038                                  						;;AN000;; Yes
 35039 000054DF C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35040                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35041                                  $MIF345:
 35042                                  $MEN333:
 35043                                  $MEN325:
 35044 000054E5 E82EFD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35045                                  
 35046 000054E8 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35047 000054EA 7405                    	jz	short $MIF349			;;AN000;; No
 35048                                  						;;AN000;; Yes
 35049 000054EC 31D2                    	xor	dx,dx				;;AN000;;
 35050 000054EE B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35051 000054F0 52                      	push	dx				;;AN000;;
 35052                                  $MIF349:
 35053 000054F1 55                      	push	bp				;;AN000;; Restore return address
 35054 000054F2 C3                      	retn					;;AN000;; Return
 35055                                  
 35056                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35057                                  ;;
 35058                                  ;;	PROC NAME: $M_DATE_REPLACE
 35059                                  ;;
 35060                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35061                                  ;;		  country format and prepare to display
 35062                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35063                                  ;;		ES:DI points at VALUE from SUBLIST
 35064                                  ;;	OUTPUTS: CX contains number of characters on stack
 35065                                  ;;		 Top of stack  --> Last character
 35066                                  ;;					. . .
 35067                                  ;;		 Bot of stack  --> First character
 35068                                  ;;	OTHER REGS Revised: DX,AX
 35069                                  ;;
 35070                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35071                                  
 35072                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35073                                  $M_DATE_REPLACE:
 35074 000054F3 5D                      	pop	bp				;;AN000;; Save return address
 35075                                  
 35076 000054F4 C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35077                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35078                                  	
 35079 000054FA E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35080                                  						;;AN000;; All O.K.?
 35081 000054FD 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35082                                  	; 12/04/2023
 35083                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35084                                  	
 35085                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35086                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35087                                  	;jne	short $MIF351
 35088                                  	; 12/04/2023
 35089 000054FF A1[3887]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35090 00005502 09C0                    	or	ax,ax
 35091 00005504 751D                    	jnz	short $MIF351
 35092                                  
 35093 00005506 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35094 00005509 E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35095                                  
 35096 0000550C FF36[4387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35097                                  	;push	word [$M_RT+87]			;;AN000;;
 35098                                  	
 35099 00005510 41                      	inc	cx				;;AN000;; Increment count
 35100 00005511 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35101                                  
 35102 00005513 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35103                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35104 00005516 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35105                                  	
 35106 00005519 FF36[4387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35107                                  	;push	word [$M_RT+87]			;;AN000;;
 35108                                  
 35109 0000551D 41                      	inc	cx				;;AN000;; Increment count
 35110 0000551E 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35111                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35112                                  	; 12/04/2023
 35113                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35114 00005521 EB3C                    	jmp	short $MIF354 ; **
 35115                                  $MIF351:
 35116                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35117                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35118                                  	;jne	short $MIF353
 35119                                  	; 12/04/2023
 35120                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35121 00005523 48                      	dec	ax 
 35122 00005524 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35123                                  
 35124 00005526 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35125 00005529 E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35126                                  
 35127 0000552C FF36[4387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35128                                  	;push	word [$M_RT+87]			;;AN000;;
 35129                                  	
 35130 00005530 41                      	inc	cx				;;AN000;; Increment count
 35131 00005531 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35132                                  
 35133 00005533 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35134                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35135 00005536 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35136                                  
 35137 00005539 FF36[4387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35138                                  	;push	word [$M_RT+87]			;;AN000;;
 35139                                  
 35140 0000553D 41                      	inc	cx				;;AN000;;
 35141                                  	      
 35142 0000553E 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35143                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35144                                  
 35145                                  	; 12/04/2023
 35146                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35147 00005541 EB1C                    	jmp	short $MIF354 ; **
 35148                                  	; 12/04/2023
 35149                                  $MIF352:
 35150                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35151 00005543 48                      	dec	ax
 35152                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35153                                  	;xor	ax,ax
 35154                                  	;jmp	short $MIF355
 35155                                  	; 12/04/2023
 35156 00005544 751C                    	jnz	short $MIF355
 35157                                  $MIF353:
 35158                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35159                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35160                                  	;jne	short $MIF355
 35161                                  
 35162 00005546 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35163                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35164 00005549 E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35165                                  	
 35166 0000554C FF36[4387]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35167                                  	;push	word [$M_RT+87]			;;AN000;;
 35168                                  
 35169 00005550 41                      	inc	cx				;;AN000;;
 35170                                  
 35171 00005551 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35172                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35173 00005554 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35174                                  	
 35175 00005557 FF36[4387]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35176                                  	;push	word [$M_RT+87]			;;AN000;;
 35177                                  	
 35178 0000555B 41                      	inc	cx				;;AN000;;
 35179                                  
 35180 0000555C E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35181                                  	; 12/04/2023
 35182                                  $MIF354:
 35183 0000555F E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35184                                  $MIF355:
 35185 00005562 55                      	push	bp				;;AN000;; Restore return address
 35186 00005563 C3                      	retn					;;AN000;; Return
 35187                                  
 35188                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35189                                  ;;
 35190                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35191                                  
 35192                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35193                                  $M_GET_DATE:
 35194                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35195                                  	;mov	al,0 				;;AN000;; Get current country info
 35196                                  	; 12/04/2023
 35197 00005564 B80038                  	mov	ax,3800h
 35198                                  	;
 35199 00005567 8D16[3887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35200                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35201 0000556B CD21                    	int	21h				;;AN000;;
 35202 0000556D 730B                    	jnc	short $MIF357
 35203                                  	;
 35204 0000556F C706[3887]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35205                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35206 00005575 C606[4387]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35207                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35208                                  $MIF357:
 35209 0000557A C3                      	retn					;;AN000;;
 35210                                  
 35211                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35212                                  ;;
 35213                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35214                                  
 35215                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35216                                  $M_YEAR:
 35217 0000557B 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35218                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35219                                  
 35220                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35221 0000557E F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35222                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35223 00005582 7508                    	jnz	short $MIF359			;;AN000;; No
 35224                                  						;;AN000;; Yes
 35225 00005584 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35226 00005587 7603                    	jna	short $MIF360			;;AN000;;
 35227 00005589 B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35228                                  $MIF360:
 35229                                  $MIF359:
 35230 0000558C C3                      	retn					;;AN000;;
 35231                                  
 35232                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35233                                  ;;
 35234                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35235                                  
 35236                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35237                                  $M_CONVERTDATE:
 35238                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35239 0000558D 8F06[3887]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35240                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35241 00005591 880E[2E87]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35242                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35243 00005595 E87EFC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35244 00005598 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35245 00005599 3A0E[2E87]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35246 0000559D 7505                    	jne	short $MIF363			;;AN000;; No
 35247 0000559F B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35248 000055A2 50                      	push	ax				;;AN000;; Save it
 35249 000055A3 41                      	inc	cx				;;AN000;; Count it
 35250                                  $MIF363:
 35251 000055A4 41                      	inc	cx				;;AN000;; Restore CX
 35252 000055A5 FF36[3887]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35253                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35254 000055A9 C3                      	retn
 35255                                  
 35256                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35257                                  ;;
 35258                                  ;;	PROC NAME: $M_TIME_REPLACE
 35259                                  ;;
 35260                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35261                                  ;;		  and prepare to display
 35262                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35263                                  ;;		ES:DI points at VALUE from SUBLIST
 35264                                  ;;	OUTPUTS: CX contains number of characters on stack
 35265                                  ;;		 Top of stack  --> Last character
 35266                                  ;;					. . .
 35267                                  ;;		 Bot of stack  --> First character
 35268                                  ;;	REGS USED: BP,CX,AX
 35269                                  ;;
 35270                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35271                                  
 35272                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM							     ;;
 35273                                  $M_TIME_REPLACE:
 35274 000055AA 5D                      	pop	bp				;;AN000;; Save return address
 35275                                  
 35276 000055AB C706[3687]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35277                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35278                                  
 35279 000055B1 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35280                                  
 35281                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35282 000055B4 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35283                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35284 000055B8 741A                    	jz	short $MIF365			;;AN000;; No
 35285                                  						;;AN000;; Yes
 35286 000055BA 803E[4987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35287                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35288 000055BF 7513                    	jne	short $MIF366			;;AN000;; No
 35289                                  						;;AN000;; Yes
 35290 000055C1 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35291                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35292 000055C4 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35293 000055C6 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35294 000055C8 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35295 000055CA 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35296                                  $MLL367:
 35297 000055CC B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35298                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35299                                  	;inc	cx				;;AN000;;
 35300                                  	;jmp	short $MEN367			;;AN000;;
 35301                                  	; 12/04/2023
 35302 000055CE EB02                    	jmp	short $MEN367 ; *
 35303                                  $MIF367:
 35304 000055D0 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35305                                  $MEN367:	; * ; 12/04/2023
 35306 000055D2 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35307 000055D3 41                      	inc	cx				;;AN000;;
 35308                                  ;$MEN367:
 35309                                  $MIF366:
 35310                                  $MIF365:					;;AN000;;
 35311 000055D4 31C0                    	xor	ax,ax				;;AN000;;
 35312 000055D6 31D2                    	xor	dx,dx				;;AN000;;
 35313                                  	
 35314                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35315 000055D8 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35316                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35317 000055DC 740B                    	jz	short $MIF372			;;AN000;;
 35318                                  
 35319 000055DE 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35320                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35321 000055E1 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 35322                                  
 35323 000055E4 FF36[4187]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35324                                  	;push	word [$M_RT+85]			;;AN000;;
 35325 000055E8 41                      	inc	cx				;;AN000;;
 35326                                  $MIF372:
 35327                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35328 000055E9 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35329                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35330 000055ED 7506                    	jnz	short $MLL374			;;AN000;; No
 35331                                  
 35332                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35333 000055EF F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35334                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35335 000055F3 740B                    	jz	short $MIF374			;;AN000;; No
 35336                                  $MLL374:
 35337 000055F5 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35338                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35339 000055F8 E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 35340                                  
 35341 000055FB FF36[4587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35342                                  	;push	word [$M_RT+89]			;;AN000;;
 35343 000055FF 41                      	inc	cx				;;AN000;;
 35344                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35345 00005600 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35346                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35347 00005603 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 35348                                  
 35349 00005606 FF36[4587]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35350                                  	;push	word [$M_RT+89]			;;AN000;;
 35351 0000560A 41                      	inc	cx				;;AN000;;
 35352                                  
 35353 0000560B 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35354                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35355                                  
 35356                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35357 0000560E F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35358                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35359 00005612 7413                    	jz	short $MIF376			;;AN000;; No
 35360                                  
 35361 00005614 803E[4987]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35362                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35363 00005619 750C                    	jne	short $MIF377			;;AN000;; No
 35364                                  
 35365 0000561B 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35366 0000561D 7C02                    	jnge	short $MIF378 ; jl
 35367 0000561F 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35368                                  $MIF378:
 35369                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35370                                  	;jne	short $MIF380			;;AN000;; No
 35371                                  	; 12/04/2023
 35372 00005621 20C0                    	and	al,al
 35373 00005623 7502                    	jnz	short $MIF380	
 35374 00005625 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35375                                  $MIF380:
 35376                                  $MIF377:
 35377                                  $MIF376:
 35378 00005627 E8ECFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35379 0000562A 55                      	push	bp				;;AN000;; Restore return address
 35380 0000562B C3                      	retn					;;AN000;; Return
 35381                                  
 35382                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35383                                  ;;
 35384                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35385                                  
 35386                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35387                                  $M_GET_TIME:
 35388                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35389                                  	;mov	al,0 				;;AN000;; Get current country info
 35390                                  	; 12/04/2023
 35391 0000562C B80038                  	mov	ax,3800h
 35392                                  	;
 35393 0000562F 8D16[3887]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35394                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35395 00005633 CD21                    	int	21h				;;AN000;;
 35396 00005635 7310                    	jnc	short $MIF384
 35397                                  
 35398 00005637 C706[4987]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35399                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35400 0000563D C606[4587]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35401                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35402 00005642 C606[4187]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35403                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35404                                  $MIF384:
 35405 00005647 C3                      	retn					;;AN000;;
 35406                                  
 35407                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35408                                  ;;
 35409                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35410                                  
 35411                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35412                                  
 35413                                  ; 12/04/2023 
 35414                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35415                                  %if 0
 35416                                  $M_CONVERTTIME:
 35417                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35418                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35419                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35420                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35421                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35422                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35423                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35424                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35425                                  	jne	short $MIF386			;;AN000;; No
 35426                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35427                                  	push	ax				;;AN000;; Save it
 35428                                  	inc	cx				;;AN000;; Count itount it
 35429                                  $MIF386:
 35430                                  	inc	cx				;;AN000;; Restore CX
 35431                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35432                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35433                                  	retn
 35434                                  %endif
 35435                                  
 35436                                  ; ----------------------------
 35437                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35438                                  ; ----------------------------
 35439                                  ; include msgdcl.inc
 35440                                  ; ----------------------------
 35441                                  
 35442                                  ;============================================================================
 35443                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 35444                                  ;============================================================================
 35445                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35446                                  
 35447                                  ; This is a new module added to support loading programs into UMBs provided
 35448                                  ; by DOS 5.0. 
 35449                                  ; ---------------------------------------------------------------------------
 35450                                  ; Usage:
 35451                                  ;
 35452                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 35453                                  ;
 35454                                  ; <filespec> has to be a filename that is not wildcarded.
 35455                                  
 35456                                  ; ---------------------------------------------------------------------------
 35457                                  ;
 35458                                  ;	Revision History
 35459                                  ;	================
 35460                                  ;
 35461                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35462                                  ;				loading and high and also remember
 35463                                  ;				current UMB state.
 35464                                  ;
 35465                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35466                                  ;				to loadhigh batch files and invalid
 35467                                  ;				filename on Loadhigh command line.
 35468                                  ;
 35469                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35470                                  ;				after the program name also as part
 35471                                  ;				of the command line being passed to
 35472                                  ;				the program to be invoked.
 35473                                  ;
 35474                                  ; ---------------------------------------------------------------------------
 35475                                  
 35476                                  ; ---------------------------------------------------------------------------
 35477                                  ;
 35478                                  ;	include highload.inc		; Grab code for ParseVar and such
 35479                                  
 35480                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35481                                  
 35482                                  ;
 35483                                  ; ---------------------------------------------------------------------------
 35484                                  
 35485                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35486                                  ;
 35487                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35488                                  ;		CS = DS = SS = TRANGROUP
 35489                                  ;
 35490                                  ;	EXIT	None
 35491                                  ;
 35492                                  ;	USED	ax, bx, cx, dx, si, di, es
 35493                                  ;
 35494                                  ;	ERROR EXITS
 35495                                  ;		Message pointers are setup at the error locations and then
 35496                                  ;	we jump back to CERROR which is the transient error recycle point.
 35497                                  ;	Apart from parse errors, the other errors handled are too many
 35498                                  ;	switches anf invalid filenames.
 35499                                  ;
 35500                                  ;	EFFECTS
 35501                                  ;		The allocation strategy and the state of the arena chain are
 35502                                  ;	put in the requested state according to the given options. If a 
 35503                                  ;	filename is also given, it is executed as well.
 35504                                  ; ---------------------------------------------------------------------------
 35505                                  
 35506                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35507                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35508                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35509                                  LoadHigh:
 35510 00005648 1E                      	push	ds
 35511 00005649 07                      	pop	es
 35512                                  
 35513 0000564A E86700                  	call	SkipLhDelims
 35514                                  
 35515                                  ;Get command tail to be passed to the program. This includes any whitespace
 35516                                  ;chars between the program name and its parameters as well.
 35517                                  ;On return, ds:si points at the start of the command tail.
 35518                                  
 35519 0000564D 56                      	push	si
 35520 0000564E E81400                  	call	ParseLhCmd
 35521 00005651 5E                      	pop	si
 35522 00005652 720E                    	jc	short LhErr
 35523                                  	
 35524 00005654 E87500                  	call	SetupCmdLine		;setup pgm's command line
 35525                                  
 35526 00005657 E8C800                  	call	SetupPath		;setup path for file
 35527 0000565A 7206                    	jc	short LhErr		;file not found
 35528                                  
 35529                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35530                                  ;be reset after return from the Exec
 35531                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35532                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35533                                  
 35534 0000565C E8A600                  	call	HideUMBs		;prepare upper-memory for load
 35535                                  
 35536 0000565F E99DD2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35537                                  
 35538                                  LhErr:
 35539                                  ;The error message has been setup at this stage
 35540                                  
 35541 00005662 E9EDD2                  	jmp	cerror			;print error message and recycle 
 35542                                  
 35543                                  ; ---------------------------------------------------------------------------
 35544                                  					
 35545                                  ;*** 	ParseLhCmd - parses any command-line options
 35546                                  ;
 35547                                  ;	ENTRY	None
 35548                                  ;
 35549                                  ;	EXIT	Carry clear -- command line parsed successfully
 35550                                  ;		Carry set -- appropriate error message setup
 35551                                  ;
 35552                                  ;	USED	ax, si
 35553                                  ;
 35554                                  ;	EFFECTS
 35555                                  ;		Options set up (see highvar.inc)
 35556                                  ;		Filename to be executed setup
 35557                                  ;
 35558                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35559                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35560                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35561                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35562                                  ;	prepare the command-line for that program.
 35563                                  ; ---------------------------------------------------------------------------
 35564                                  
 35565                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35566                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35567                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35568                                  	; 11/06/2023
 35569                                  ParseLhCmd:
 35570                                  	;mov	si,81h
 35571 00005665 BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35572                                  
 35573 00005668 C706[DC8A]0000          	mov	word [COMSW],0
 35574 0000566E BF[D085]                	mov	di,Parse_LoadHi
 35575 00005671 31C9                    	xor	cx,cx
 35576 00005673 E843CB                  	call	Parse_With_Msg
 35577                                  
 35578                                  	; 11/06/2023
 35579                                  	;cmp	ax,0FFFFh ; -1
 35580                                  	;jz	short PLhCmd2
 35581                                  	;cmp	ax,0
 35582                                  	;jnz	short PLhCmd1
 35583                                  	; 11/06/2023
 35584 00005676 40                      	inc	ax ; cmp ax,-1
 35585 00005677 7408                    	jz	short PLhCmd2 ; 0FFFFh -> 0
 35586 00005679 48                      	dec	ax ; cmp ax,0
 35587 0000567A 7504                    	jnz	short PLhCmd1 ; 1 -> 0
 35588                                  	; ax = 0
 35589                                  
 35590 0000567C 89D3                    	mov	bx,dx
 35591                                  	; 14/04/2023
 35592                                  	;call	LhCopyFilename
 35593                                  	;; 13/04/2023
 35594                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35595                                  	;;jmp	short PLhCmd2
 35596                                  	;retn
 35597                                  	; 14/04/2023
 35598 0000567E EB02                    	jmp	short LhCopyFilename
 35599                                  PLhCmd1:
 35600 00005680 F9                      	stc
 35601                                  PLhCmd2:
 35602 00005681 C3                      	retn
 35603                                  
 35604                                  ; ---------------------------------------------------------------------------
 35605                                  
 35606                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35607                                  
 35608                                  ; ---------------------------------------------------------------------------
 35609                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35610                                  ; ---------------------------------------------------------------------------
 35611                                  
 35612                                  	; 13/04/2023
 35613                                  	; MSDOS 5.0 COMMAND.COM only !
 35614                                  	; (Procedure names are not from original Microsoft source code!)
 35615                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35616                                  ;set_strategy:
 35617                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35618                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35619                                  	;		; AL = function code: get allocation strategy
 35620                                  	;mov	bx,ax
 35621                                  	;or	bx,80h
 35622                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35623                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35624                                  	;		; AL = function code: set allocation strategy
 35625                                  	;retn
 35626                                  
 35627                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35628                                  ;set_umblink:
 35629                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35630                                  	;mov	bx,1
 35631                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35632                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35633                                  	;retn
 35634                                  
 35635                                  ; ---------------------------------------------------------------------------
 35636                                  
 35637                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35638                                  ;
 35639                                  ;	ENTRY	ds:si points at primary argument (filename)
 35640                                  ;
 35641                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35642                                  ;				already contain an appropriate error number.
 35643                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35644                                  ;				points to first character (most likely space)
 35645                                  ;				after filename.
 35646                                  ;
 35647                                  ;	USED	ax, si
 35648                                  ;
 35649                                  ;	EFFECTS
 35650                                  ;		ExecPath contains the filename
 35651                                  ;
 35652                                  ; If there are any wildcards in the filename, then we have an error
 35653                                  ; ---------------------------------------------------------------------------
 35654                                  
 35655                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35656                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35657                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35658                                  LhCopyFilename:
 35659 00005682 1E                      	push	ds
 35660 00005683 56                      	push	si
 35661 00005684 57                      	push	di
 35662 00005685 C57704                  	lds	si,[bx+4]
 35663 00005688 BF[ED89]                	mov	di,EXECPATH
 35664                                  lhcpfn1:
 35665 0000568B AC                      	lodsb
 35666 0000568C 3C2A                    	cmp	al,2Ah ; '*'
 35667 0000568E 740D                    	jz	short lhfilerr
 35668 00005690 3C3F                    	cmp	al,3Fh ; '?'
 35669 00005692 7409                    	jz	short lhfilerr
 35670 00005694 AA                      	stosb
 35671 00005695 08C0                    	or	al,al
 35672 00005697 75F2                    	jnz	short lhcpfn1
 35673                                  	; 14/04/2023
 35674                                  	; cf = 0
 35675                                  	;clc
 35676                                  lhfilerr2:
 35677 00005699 5F                      	pop	di
 35678 0000569A 5E                      	pop	si
 35679 0000569B 1F                      	pop	ds
 35680 0000569C C3                      	retn
 35681                                  lhfilerr:
 35682 0000569D BA[8581]                	mov	dx,LhInvFil_Ptr
 35683 000056A0 F9                      	stc
 35684 000056A1 EBF6                    	jmp	short lhfilerr2
 35685                                  
 35686                                  ; ---------------------------------------------------------------------------
 35687                                  	
 35688                                  	; 14/04/2023
 35689                                  	; 13/04/2023
 35690                                  	; MSDOS 5.0 COMMAND.COM only !
 35691                                  	; (Procedure name is not from original Microsoft source code!)
 35692                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35693                                  set_strategy:
 35694 000056A3 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35695 000056A6 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35696                                  			; AL = function code: get allocation strategy
 35697 000056A8 89C3                    	mov	bx,ax
 35698 000056AA 81CB8000                	or	bx,80h
 35699 000056AE B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35700 000056B1 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35701                                  			; AL = function code: set allocation strategy
 35702 000056B3 C3                      	retn
 35703                                  
 35704                                  ; ---------------------------------------------------------------------------
 35705                                  
 35706                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35707                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35708                                  	; MSDOS 5.0 COMMAND.COM only !
 35709                                  	; (Procedure name is not from original Microsoft source code!)
 35710                                  SkipLhDelims:
 35711 000056B4 BE8100                  	mov	si,81h
 35712 000056B7 E824CF                  	call	scanoff
 35713                                  stfn1:
 35714 000056BA AC                      	lodsb
 35715 000056BB E828CF                  	call	DELIM
 35716 000056BE 740A                    	jz	short stfn2
 35717 000056C0 3C0D                    	cmp	al,0Dh
 35718 000056C2 7406                    	jz	short stfn2
 35719 000056C4 3A06[C98A]              	cmp	al,[SWITCHAR]
 35720 000056C8 75F0                    	jnz	short stfn1
 35721                                  stfn2:
 35722 000056CA 4E                      	dec	si
 35723 000056CB C3                      	retn
 35724                                  
 35725                                  ; ---------------------------------------------------------------------------
 35726                                  
 35727                                  ;***	SetupCmdLine -- prepare command line for the program
 35728                                  ;
 35729                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35730                                  ;
 35731                                  ;	EXIT	None
 35732                                  ;
 35733                                  ;	USED
 35734                                  ;
 35735                                  ;	EFFECTS		
 35736                                  ;		The rest of the command line following the pgm name is 
 35737                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35738                                  ;	and a new command line length is put in
 35739                                  ; ---------------------------------------------------------------------------
 35740                                  
 35741                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35742                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35743                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35744                                  SetupCmdLine:
 35745                                  	;mov	di,81h
 35746 000056CC BF8100                  	mov	di,iCmdLine
 35747 000056CF 30C9                    	xor	cl,cl
 35748 000056D1 FEC9                    	dec	cl			;just CR means count = 0
 35749                                  SetCmdL1:
 35750 000056D3 AC                      	lodsb
 35751 000056D4 AA                      	stosb
 35752 000056D5 FEC1                    	inc	cl			;update count
 35753                                  	; 14/04/2023
 35754                                  	; * ; MSDOS 6.0 only !
 35755                                  	;or	al,al	; *
 35756                                  	;jz	short SetCmdL2 ; *
 35757 000056D7 3C0D                    	cmp	al,0Dh			;carriage return?
 35758 000056D9 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35759                                  SetCmdL2:
 35760 000056DB 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35761 000056E0 C3                      	retn
 35762                                  
 35763                                  ; ---------------------------------------------------------------------------
 35764                                  
 35765                                  ;***	LhSetupErrMsg -- Sets up error messages
 35766                                  ;
 35767                                  ;	ENTRY	ax = error message number
 35768                                  ;
 35769                                  ;	EXIT	None
 35770                                  ;
 35771                                  ;	USED	dx
 35772                                  ;
 35773                                  ;	EFFECTS
 35774                                  ;		Everything setup to display error message
 35775                                  ; ---------------------------------------------------------------------------
 35776                                  	
 35777                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35778                                  LhSetupErrMsg:
 35779 000056E1 C606[197F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35780 000056E6 BA[1B7F]                	mov	dx,extend_buf_ptr
 35781 000056E9 A3[1B7F]                	mov	[extend_buf_ptr],ax
 35782 000056EC C3                      	retn
 35783                                  
 35784                                  ; ---------------------------------------------------------------------------
 35785                                  
 35786                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35787                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35788                                  	; MSDOS 5.0 COMMAND.COM only !
 35789                                  	; (Procedure name is not from original Microsoft source code!)
 35790                                  check_umblink:
 35791 000056ED B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35792 000056F0 CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35793                                  			 ; AL = function code: get allocation strategy
 35794 000056F2 88C3                    	mov	bl,al
 35795 000056F4 B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35796 000056F7 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35797                                  			; AL = function code: (DOS 5beta) get UMB link state
 35798 000056F9 88C7                    	mov	bh,al
 35799 000056FB 93                      	xchg	ax,bx
 35800 000056FC D0C0                    	rol	al,1
 35801 000056FE 2401                    	and	al,1
 35802 00005700 D0E4                    	shl	ah,1
 35803 00005702 08E0                    	or	al,ah
 35804 00005704 C3                      	retn
 35805                                  
 35806                                  ; ---------------------------------------------------------------------------
 35807                                  
 35808                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35809                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35810                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35811                                  HideUMBs:
 35812 00005705 1E                      	push	ds
 35813 00005706 E8E4FF                  	call	check_umblink
 35814 00005709 8E1E[C58A]              	mov	ds,[RESSEG]
 35815 0000570D A2[2204]                	mov	[fInHigh],al
 35816 00005710 800E[2204]80            	or	byte [fInHigh],80h
 35817 00005715 1F                      	pop	ds
 35818 00005716 E88AFF                  	call	set_strategy
 35819                                  	;call	set_umblink
 35820                                  	;retn
 35821                                  	; 14/04/023
 35822                                  	;jmp	short set_umblink
 35823                                  
 35824                                  ; ---------------------------------------------------------------------------
 35825                                  
 35826                                  	; 14/04/2023
 35827                                  	; 13/04/2023
 35828                                  	; MSDOS 5.0 COMMAND.COM only !
 35829                                  	; (Procedure name is not from original Microsoft source code!)
 35830                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35831                                  set_umblink:
 35832 00005719 B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35833 0000571C BB0100                  	mov	bx,1
 35834 0000571F CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35835                                  			; AL = function code: (DOS 5beta) set UMB link state
 35836 00005721 C3                      	retn
 35837                                  
 35838                                  ; ---------------------------------------------------------------------------
 35839                                  
 35840                                  ;***	SetupPath -- Do path search for the file to be executed
 35841                                  ;
 35842                                  ;	ENTRY	None
 35843                                  ;
 35844                                  ;	EXIT	Carry set if file not found or not executable file
 35845                                  ;
 35846                                  ;	EFFECTS
 35847                                  ;		ExecPath contains the full path of the file to be executed
 35848                                  ; ---------------------------------------------------------------------------
 35849                                  
 35850                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35851                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35852                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35853                                  SetupPath:
 35854                                  
 35855                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35856                                  ;because the path search routine that we are about to invoke expects the
 35857                                  ;filename to search for to be argv[0].
 35858                                  ;
 35859                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 35860                                  ;over it by doing the whole move again (smaller, of course, this time).
 35861                                  
 35862                                  
 35863                                  	;mov	ax,arg.argvcnt		;total number of arguments
 35864                                  	; 14/04/2023
 35865                                  	;mov	ax,[ARG_ARGVCNT]
 35866 00005722 A1[9490]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 35867                                  
 35868 00005725 48                      	dec	ax			;less one - skip "LoadHigh"
 35869                                  	;mov	bx,SIZE Argv_ele
 35870 00005726 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 35871                                  	;mov	bx,11
 35872 00005729 F7E3                    	mul	bx			;dx:ax = size of argument lists
 35873                                  
 35874                                  	; 14/04/2023
 35875 0000572B 89C1                    	mov	cx,ax			;size to move
 35876                                  
 35877                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 35878                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 35879 0000572D BF[D48D]                	mov	di,ARG	
 35880 00005730 89FE                    	mov	si,di			;
 35881                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 35882 00005732 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 35883                                  	
 35884                                  	; 14/04/2023
 35885                                  	;mov	cx,ax
 35886                                  
 35887 00005735 FC                      	cld
 35888 00005736 F3A4                    	rep	movsb			;Move the argument list
 35889                                  	
 35890                                  	;dec	arg.argvcnt		;Fake one less argument, and
 35891                                  	;dec	word [ARG_ARGVCNT]
 35892 00005738 FF0E[9490]              	dec	word [ARG+ARG_UNIT.argvcnt]
 35893                                  	
 35894                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 35895                                  
 35896 0000573C E821DA                  	call	path_search		;look in the path
 35897                                  
 35898                                  ;ax = 0, no file found
 35899                                  ;ax < 4, batch file found -- cant be executed
 35900                                  ;ax = 4,8 => .com or .exe file found
 35901                                  
 35902 0000573F 09C0                    	or	ax,ax			;any file found?
 35903 00005741 740B                    	jz	short no_exec_file	;no, error
 35904                                  
 35905 00005743 83F804                  	cmp	ax,4			;executable file?
 35906                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 35907                                  	;clc
 35908                                  	;retn
 35909                                  	; 14/04/2023
 35910 00005746 7201                    	jb	short no_exec_bat
 35911 00005748 C3                      	retn 
 35912                                  
 35913                                  no_exec_bat:
 35914 00005749 BA[8281]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 35915 0000574C EB06                    	jmp	short lhsp_errret	;return error; M016
 35916                                  
 35917                                  no_exec_file:
 35918 0000574E B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 35919 00005751 E88DFF                  	call	LhSetupErrMsg		;setup error message
 35920                                  lhsp_errret:				; M016
 35921 00005754 F9                      	stc
 35922 00005755 C3                      	retn
 35923                                  
 35924                                  ;============================================================================
 35925                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 35926                                  ;============================================================================
 35927                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35928                                  
 35929                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 35930                                  
 35931                                  ; ---------------------------------------------------------------------------
 35932                                  ; Class 3 message table/structure
 35933                                  ; ---------------------------------------------------------------------------
 35934                                  
 35935                                  $M_CLASS_3_STRUC:
 35936 00005756 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 35937 00005757 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 35938 00005759 A2                      	db 162			; Total number of messages
 35939                                  $M_ID_3_1:
 35940                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 35941 0000575A FC03                    	dw 1020			; Message Number = 1020
 35942 0000575C 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 35943                                  $M_ID_3_2:
 35944 0000575E F703                    	dw 1015			; Message Number = 1015
 35945 00005760 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 35946                                  $M_ID_3_3:	; 26/04/2023
 35947 00005762 EC03B402                	dw 1004,MSG_1004-$ ; 692
 35948 00005766 0204CA02                	dw 1026,MSG_1026-$ ; 714
 35949 0000576A 0704DA02                	dw 1031,MSG_1031-$ ; 730
 35950 0000576E 0B04E502                	dw 1035,MSG_1035-$ ; 741
 35951 00005772 2604F002                	dw 1062,MSG_1062-$ ; 752
 35952 00005776 0404FB02                	dw 1028,MSG_1028-$ ; 763
 35953 0000577A 15041903                	dw 1045,MSG_1045-$ ; 793
 35954 0000577E 11043203                	dw 1041,MSG_1041-$ ; 818
 35955 00005782 12045003                	dw 1042,MSG_1042-$ ; 848
 35956                                  $M_ID_3_12:
 35957 00005786 13046703                	dw 1043,MSG_1043-$ ; 871
 35958 0000578A EA038303                	dw 1002,MSG_1002-$ ; 899
 35959 0000578E EB03A703                	dw 1003,MSG_1003-$ ; 935
 35960 00005792 EF03BF03                	dw 1007,MSG_1007-$ ; 959
 35961 00005796 F003D603                	dw 1008,MSG_1008-$ ; 982
 35962 0000579A F103E803                	dw 1009,MSG_1009-$ ; 1000
 35963 0000579E F203F903                	dw 1010,MSG_1010-$ ; 1017
 35964 000057A2 F3031504                	dw 1011,MSG_1011-$ ; 1045
 35965 000057A6 F6032C04                	dw 1014,MSG_1014-$ ; 1068
 35966 000057AA F8033904                	dw 1016,MSG_1016-$ ; 1081
 35967 000057AE F9035F04                	dw 1017,MSG_1017-$ ; 1119
 35968 000057B2 FA038004                	dw 1018,MSG_1018-$ ; 1152
 35969                                  $M_ID_3_24:
 35970 000057B6 FB039004                	dw 1019,MSG_1019-$ ; 1168
 35971 000057BA FD039804                	dw 1021,MSG_1021-$ ; 1176
 35972 000057BE FE03B204                	dw 1022,MSG_1022-$ ; 1202
 35973 000057C2 FF03D504                	dw 1023,MSG_1023-$ ; 1237
 35974 000057C6 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 35975 000057CA 01041005                	dw 1025,MSG_1025-$ ; 1296
 35976 000057CE 03042405                	dw 1027,MSG_1027-$ ; 1316
 35977 000057D2 05044105                	dw 1029,MSG_1029-$ ; 1345
 35978 000057D6 06044F05                	dw 1030,MSG_1030-$ ; 1359
 35979 000057DA 08045A05                	dw 1032,MSG_1032-$ ; 1370
 35980 000057DE 09046E05                	dw 1033,MSG_1033-$ ; 1390
 35981 000057E2 0A048005                	dw 1034,MSG_1034-$ ; 1408
 35982 000057E6 0C049205                	dw 1036,MSG_1036-$ ; 1426
 35983 000057EA 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 35984 000057EE 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 35985 000057F2 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 35986                                  $M_ID_3_40:
 35987 000057F6 1004F805                	dw 1040,MSG_1040-$ ; 1528
 35988 000057FA 14040906                	dw 1044,MSG_1044-$ ; 1545
 35989 000057FE 16041906                	dw 1046,MSG_1046-$ ; 1561
 35990 00005802 17044C06                	dw 1047,MSG_1047-$ ; 1612
 35991 00005806 18046106                	dw 1048,MSG_1048-$ ; 1633
 35992 0000580A 19046F06                	dw 1049,MSG_1049-$ ; 1647
 35993 0000580E 1A047506                	dw 1050,MSG_1050-$ ; 1653
 35994 00005812 1B049006                	dw 1051,MSG_1051-$ ; 1680
 35995 00005816 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 35996 0000581A 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 35997 0000581E 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 35998                                  $M_ID_3_51:
 35999 00005822 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 36000 00005826 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 36001 0000582A 21040A07                	dw 1057,MSG_1057-$ ; 1802
 36002 0000582E 23041307                	dw 1059,MSG_1059-$ ; 1811
 36003 00005832 24041407                	dw 1060,MSG_1060-$ ; 1812
 36004 00005836 25041407                	dw 1061,MSG_1061-$ ; 1812
 36005 0000583A 27042A07                	dw 1063,MSG_1063-$ ; 1834
 36006 0000583E 28042907                	dw 1064,MSG_1064-$ ; 1833
 36007 00005842 29042807                	dw 1065,MSG_1065-$ ; 1832
 36008 00005846 2A042707                	dw 1066,MSG_1066-$ ; 1831
 36009 0000584A 2B042607                	dw 1067,MSG_1067-$ ; 1830
 36010 0000584E 2C042407                	dw 1068,MSG_1068-$ ; 1828
 36011 00005852 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 36012 00005856 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 36013 0000585A 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 36014 0000585E 30042907                	dw 1072,MSG_1072-$ ; 1833
 36015                                  $M_ID_3_67:
 36016 00005862 31042E07                	dw 1073,MSG_1073-$ ; 1838
 36017 00005866 32043307                	dw 1074,MSG_1074-$ ; 1843
 36018 0000586A 33043807                	dw 1075,MSG_1075-$ ; 1848
 36019 0000586E 34043A07                	dw 1076,MSG_1076-$ ; 1850
 36020 00005872 35043907                	dw 1077,MSG_1077-$ ; 1849
 36021 00005876 36043D07                	dw 1078,MSG_1078-$ ; 1853
 36022 0000587A 37045407                	dw 1079,MSG_1079-$ ; 1876
 36023 0000587E 38045B07                	dw 1080,MSG_1080-$ ; 1883
 36024 00005882 39046D07                	dw 1081,MSG_1081-$ ; 1901
 36025 00005886 3C049407                	dw 1084,MSG_1084-$ ; 1940
 36026 0000588A 4204A007                	dw 1090,MSG_1090-$ ; 1952
 36027 0000588E 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 36028 00005892 4404B407                	dw 1092,MSG_1092-$ ; 1972
 36029 00005896 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 36030 0000589A 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 36031 0000589E 4704E807                	dw 1095,MSG_1095-$ ; 2024
 36032 000058A2 48040108                	dw 1096,MSG_1096-$ ; 2049
 36033                                  $M_ID_3_84:
 36034 000058A6 B0042E08                	dw 1200,MSG_1200-$ ; 2094
 36035 000058AA 14052B08                	dw 1300,MSG_1300-$ ; 2091
 36036 000058AE 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 36037 000058B2 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 36038 000058B6 3C055709                	dw 1340,MSG_1340-$ ; 2391
 36039 000058BA 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 36040 000058BE 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 36041 000058C2 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 36042 000058C6 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 36043 000058CA 7905420B                	dw 1401,MSG_1401-$ ; 2882
 36044 000058CE 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 36045 000058D2 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 36046 000058D6 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 36047 000058DA 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 36048 000058DE A005630D                	dw 1440,MSG_1440-$ ; 3427
 36049 000058E2 A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 36050                                  $M_ID_3_100:
 36051 000058E6 B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 36052 000058EA B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 36053 000058EE B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 36054 000058F2 C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 36055 000058F6 C905D90F                	dw 1481,MSG_1481-$ ; 4057
 36056 000058FA CA053310                	dw 1482,MSG_1482-$ ; 4147
 36057 000058FE CB059110                	dw 1483,MSG_1483-$ ; 4241
 36058 00005902 CC050811                	dw 1484,MSG_1484-$ ; 4360
 36059 00005906 CD05C411                	dw 1485,MSG_1485-$ ; 4548
 36060 0000590A CE055C12                	dw 1486,MSG_1486-$ ; 4700
 36061 0000590E CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 36062 00005912 D0055213                	dw 1488,MSG_1488-$ ; 4946
 36063                                  $M_ID_3_112:
 36064 00005916 DC05E113                	dw 1500,MSG_1500-$ ; 5089
 36065 0000591A F0051C14                	dw 1520,MSG_1520-$ ; 5148
 36066 0000591E 04065614                	dw 1540,MSG_1540-$ ; 5206
 36067 00005922 0506B014                	dw 1541,MSG_1541-$ ; 5296
 36068 00005926 06061815                	dw 1542,MSG_1542-$ ; 5400
 36069 0000592A 18065015                	dw 1560,MSG_1560-$ ; 5456
 36070 0000592E 19068415                	dw 1561,MSG_1561-$ ; 5508
 36071 00005932 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 36072 00005936 1B062916                	dw 1563,MSG_1563-$ ; 5673
 36073 0000593A 1C065016                	dw 1564,MSG_1564-$ ; 5712
 36074 0000593E 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 36075 00005942 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 36076 00005946 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 36077 0000594A 20065A17                	dw 1568,MSG_1568-$ ; 5978
 36078 0000594E 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 36079                                  $M_ID_3_127:
 36080 00005952 4006E717                	dw 1600,MSG_1600-$ ; 6119
 36081 00005956 41060018                	dw 1601,MSG_1601-$ ; 6144
 36082 0000595A 42065018                	dw 1602,MSG_1602-$ ; 6224
 36083 0000595E 54069A18                	dw 1620,MSG_1620-$ ; 6298
 36084 00005962 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 36085 00005966 56066C19                	dw 1622,MSG_1622-$ ; 6508
 36086 0000596A 6806B419                	dw 1640,MSG_1640-$ ; 6580
 36087 0000596E 6906E519                	dw 1641,MSG_1641-$ ; 6629
 36088 00005972 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 36089 00005976 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 36090 0000597A A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 36091 0000597E B806781B                	dw 1720,MSG_1720-$ ; 7032
 36092 00005982 CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 36093 00005986 CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 36094 0000598A E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 36095 0000598E F406D71C                	dw 1780,MSG_1780-$ ; 7383
 36096                                  $M_ID_3_143:
 36097 00005992 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 36098 00005996 0907891D                	dw 1801,MSG_1801-$ ; 7561
 36099 0000599A 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 36100 0000599E 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 36101 000059A2 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 36102 000059A6 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 36103 000059AA 4507461F                	dw 1861,MSG_1861-$ ; 8006
 36104 000059AE 4607891F                	dw 1862,MSG_1862-$ ; 8073
 36105 000059B2 47070320                	dw 1863,MSG_1863-$ ; 8195
 36106 000059B6 4807A220                	dw 1864,MSG_1864-$ ; 8354
 36107 000059BA 49070521                	dw 1865,MSG_1865-$ ; 8453
 36108 000059BE 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 36109 000059C2 5807D021                	dw 1880,MSG_1880-$ ; 8656
 36110 000059C6 59074422                	dw 1881,MSG_1881-$ ; 8772
 36111 000059CA 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 36112 000059CE 5B071123                	dw 1883,MSG_1883-$ ; 8977
 36113 000059D2 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 36114 000059D6 8007C423                	dw 1920,MSG_1920-$ ; 9156
 36115 000059DA 8107F023                	dw 1921,MSG_1921-$ ; 9200
 36116                                  $M_ID_3_162:
 36117 000059DE 8207                    	dw 1922			; Message Number = 1922
 36118 000059E0 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 36119                                  
 36120                                  ; ---------------------------------------------------------------------------
 36121                                  ; Class 3 messages
 36122                                  ; ---------------------------------------------------------------------------
 36123                                  	
 36124                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36125                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 36126                                  
 36127                                  MSG_1020:	; COMMON4
 36128 000059E2 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 36129 000059E3 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 36129 000059EC 667265650D0A       
 36130                                  MSG_1015:	; COMMON18
 36131 000059F2 23                      	db 35
 36132 000059F3 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 36132 000059FC 6F7420626520636F70-
 36132 00005A05 696564206F6E746F20-
 36132 00005A0E 697473656C660D0A   
 36133                                  MSG_1004:	; COMMON20
 36134 00005A16 19                      	db 25
 36135 00005A17 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 36135 00005A20 656E74206469736B20-
 36135 00005A29 73706163650D0A     
 36136                                  MSG_1026:	; COMMON22
 36137 00005A30 13                      	db 19
 36138 00005A31 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 36138 00005A3A 6F646520706167650D-
 36138 00005A43 0A                 
 36139                                  MSG_1031:	; COMMON23
 36140 00005A44 0E                      	db 14
 36141 00005A45 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 36141 00005A4E 6174650D0A         
 36142                                  MSG_1035:	; COMMON24
 36143 00005A53 0E                      	db 14
 36144 00005A54 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 36144 00005A5D 696D650D0A         
 36145                                  MSG_1062:	; COMMON25
 36146 00005A62 0E                      	db 14
 36147 00005A63 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 36147 00005A6C 6174680D0A         
 36148                                  MSG_1028:	; COMMON28
 36149 00005A71 21                      	db 33
 36150 00005A72 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 36150 00005A7B 206B657920746F2063-
 36150 00005A84 6F6E74696E7565202E-
 36150 00005A8D 202E202E0D0A       
 36151                                  MSG_1045:	; COMMON32
 36152 00005A93 1C                      	db 28
 36153 00005A94 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 36153 00005A9D 206372656174652064-
 36153 00005AA6 69726563746F72790D-
 36153 00005AAF 0A                 
 36154                                  MSG_1041:	; COMMON33
 36155 00005AB0 21                      	db 33
 36156 00005AB1 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 36156 00005ABA 206472697665202531-
 36156 00005AC3 20686173206E6F206C-
 36156 00005ACC 6162656C0D0A       
 36157                                  MSG_1042:	; COMMON34
 36158 00005AD2 1A                      	db 26
 36159 00005AD3 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 36159 00005ADC 206472697665202531-
 36159 00005AE5 2069732025320D0A   
 36160                                  MSG_1043:	; COMMON36
 36161 00005AED 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 36162 00005AEE 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 36162 00005AF7 7269616C204E756D62-
 36162 00005B00 65722069732025312D-
 36162 00005B09 25320D0A           
 36163                                  MSG_1002:
 36164 00005B0D 27                              db 39
 36165 00005B0E 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 36165 00005B17 2066696C65206E616D-
 36165 00005B20 65206F722066696C65-
 36165 00005B29 206E6F7420666F756E-
 36165 00005B32 640D0A             
 36166                                  MSG_1003:
 36167 00005B35 1B                      	db 27
 36168 00005B36 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 36168 00005B3F 617468206F72206669-
 36168 00005B48 6C65206E616D650D0A 
 36169                                  MSG_1007:
 36170 00005B51 1A                      	db 26
 36171 00005B52 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 36171 00005B5B 7669726F6E6D656E74-
 36171 00005B64 2073706163650D0A   
 36172                                  MSG_1008:
 36173 00005B6C 15                      	db 21
 36174 00005B6D 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 36174 00005B76 74696F6E206572726F-
 36174 00005B7F 720D0A             
 36175                                  MSG_1009:
 36176 00005B82 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 36177 00005B83 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 36177 00005B8C 65206D697373696E67-
 36177 00005B95 0D0A               
 36178                                  MSG_1010:
 36179 00005B97 1F                      	db 31
 36180 00005B98 0D0A                    	db 0Dh,0Ah
 36181 00005B9A 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 36181 00005BA3 736B20776974682062-
 36181 00005BAC 617463682066696C65-
 36181 00005BB5 0D0A               
 36182                                  MSG_1011:
 36183 00005BB7 1A                      	db 26
 36184 00005BB8 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 36184 00005BC1 6E64206F722066696C-
 36184 00005BCA 65206E616D650D0A   
 36185                                  MSG_1014:	; EXTEND5
 36186 00005BD2 10                      	db 16
 36187 00005BD3 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 36187 00005BDC 6E696564200D0A     
 36188                                  MSG_1016:
 36189 00005BE3 29                      	db 41
 36190 00005BE4 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 36190 00005BED 662064657374696E61-
 36190 00005BF6 74696F6E206C6F7374-
 36190 00005BFF 206265666F72652063-
 36190 00005C08 6F70790D0A         
 36191                                  MSG_1017:
 36192 00005C0D 24                      	db 36
 36193 00005C0E 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 36193 00005C17 696C656E616D65206F-
 36193 00005C20 722066696C65206E6F-
 36193 00005C29 7420666F756E640D0A 
 36194                                  MSG_1018:
 36195 00005C32 13                      	db 19
 36196 00005C33 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 36196 00005C3C 2920636F706965640D-
 36196 00005C45 0A                 
 36197                                  MSG_1019:
 36198 00005C46 0B                      	db 11
 36199 00005C47 25312066696C652873-     	db '%1 file(s) '
 36199 00005C50 2920               
 36200                                  MSG_1021:	; EXTEND15
 36201 00005C52 1D                      	db 29
 36202 00005C53 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 36202 00005C5C 726976652073706563-
 36202 00005C65 696669636174696F6E-
 36202 00005C6E 0D0A               
 36203                                  MSG_1022:
 36204 00005C70 26                      	db 38
 36205 00005C71 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 36205 00005C7A 202531206E6F742070-
 36205 00005C83 726570617265642066-
 36205 00005C8C 6F722073797374656D-
 36205 00005C95 0D0A               
 36206                                  MSG_1023:
 36207 00005C97 2B                      	db 43
 36208 00005C98 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 36208 00005CA1 202531206E6F742070-
 36208 00005CAA 726570617265642066-
 36208 00005CB3 6F7220616C6C206465-
 36208 00005CBC 76696365730D0A     
 36209                                  MSG_1024:
 36210 00005CC3 16                      	db 22
 36211 00005CC4 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 36211 00005CCD 646520706167653A20-
 36211 00005CD6 25310D0A           
 36212                                  MSG_1025:
 36213 00005CDA 17                      	db 23
 36214 00005CDB 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 36214 00005CE4 6F7420696E7374616C-
 36214 00005CED 6C65640D0A         
 36215                                  MSG_1027:
 36216 00005CF2 20                      	db 32
 36217 00005CF3 43757272656E742064-     	db 'Current drive is no longer valid'
 36217 00005CFC 72697665206973206E-
 36217 00005D05 6F206C6F6E67657220-
 36217 00005D0E 76616C6964         
 36218                                  MSG_1029:
 36219 00005D13 11                      	db 17
 36220 00005D14 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 36220 00005D1D 20666F756E640D0A   
 36221                                  MSG_1030:
 36222 00005D25 0E                      	db 14
 36223 00005D26 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 36223 00005D2F 726F720D0A         
 36224                                  MSG_1032:
 36225 00005D34 17                      	db 23
 36226 00005D35 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 36226 00005D3E 617465206973202531-
 36226 00005D47 2025320D0A         
 36227                                  MSG_1033:
 36228 00005D4C 15                      	db 21
 36229 00005D4D 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 36229 00005D56 576564546875467269-
 36229 00005D5F 536174             
 36230                                  MSG_1034:
 36231 00005D62 15                      	db 21
 36232 00005D63 456E746572206E6577-     	db 'Enter new date (%1): '
 36232 00005D6C 206461746520282531-
 36232 00005D75 293A20             
 36233                                  MSG_1036:
 36234 00005D78 14                      	db 20
 36235 00005D79 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 36235 00005D82 696D65206973202531-
 36235 00005D8B 0D0A               
 36236                                  MSG_1037:
 36237 00005D8D 10                      	db 16
 36238 00005D8E 456E746572206E6577-     	db 'Enter new time: '
 36238 00005D97 2074696D653A20     
 36239                                  MSG_1038:
 36240 00005D9E 12                              db 18
 36241 00005D9F 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 36241 00005DA8 74652028592F4E293F 
 36242                                  MSG_1039:
 36243 00005DB1 3C                              db 60
 36244 00005DB2 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 36244 00005DBB 20696E206469726563-
 36244 00005DC4 746F72792077696C6C-
 36244 00005DCD 2062652064656C6574-
 36244 00005DD6 6564210D0A         
 36245 00005DDB 41726520796F752073-     	db 'Are you sure (Y/N)?'
 36245 00005DE4 7572652028592F4E29-
 36245 00005DED 3F                 
 36246                                  MSG_1040:
 36247 00005DEE 14                      	db 20
 36248 00005DEF 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 36248 00005DF8 7273696F6E2025312E-
 36248 00005E01 2532               
 36249                                  MSG_1044:
 36250 00005E03 13                      	db 19
 36251 00005E04 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 36251 00005E0D 69726563746F72790D-
 36251 00005E16 0A                 
 36252                                  MSG_1046:
 36253 00005E17 36                      	db 54
 36254 00005E18 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 36254 00005E21 6174682C206E6F7420-
 36254 00005E2A 6469726563746F7279-
 36254 00005E33 2C0D0A             
 36255 00005E36 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 36255 00005E3F 6F7279206E6F742065-
 36255 00005E48 6D7074790D0A       
 36256                                  MSG_1047:
 36257 00005E4E 18                      	db 24
 36258 00005E4F 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 36258 00005E58 696679204F4E206F72-
 36258 00005E61 204F46460D0A       
 36259                                  MSG_1048:
 36260 00005E67 11                      	db 17
 36261 00005E68 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 36261 00005E71 206F662025310D0A   
 36262                                  MSG_1049:
 36263 00005E79 09                      	db 9
 36264 00005E7A 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 36265                                  MSG_1050:
 36266 00005E83 1E                      	db 30
 36267 00005E84 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 36267 00005E8D 7269766520696E2073-
 36267 00005E96 656172636820706174-
 36267 00005E9F 680D0A             
 36268                                  MSG_1051:
 36269 00005EA2 10                      	db 16
 36270 00005EA3 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 36270 00005EAC 65766963650D0A     
 36271                                  MSG_1052:
 36272 00005EB3 16                      	db 22
 36273 00005EB4 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 36273 00005EBD 74206265206E657374-
 36273 00005EC6 65640D0A           
 36274                                  MSG_1053:
 36275 00005ECA 25                      	db 37
 36276 00005ECB 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 36276 00005ED4 6174652066696C6520-
 36276 00005EDD 6572726F7220647572-
 36276 00005EE6 696E6720706970650D-
 36276 00005EEF 0A                 
 36277                                  MSG_1054:
 36278 00005EF0 26                      	db 38
 36279 00005EF1 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 36279 00005EFA 2062696E6172792072-
 36279 00005F03 656164732066726F6D-
 36279 00005F0C 206120646576696365-
 36279 00005F15 0D0A               
 36280                                  
 36281                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 36282                                  MSG_1055:
 36283 00005F17 0D                      	db 13
 36284 00005F18 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 36284 00005F21 25310D0A           
 36285                                  MSG_1056:
 36286 00005F25 0E                      	db 14
 36287 00005F26 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 36287 00005F2F 2025310D0A         
 36288                                  MSG_1057:
 36289 00005F34 0C                      	db 12
 36290 00005F35 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 36290 00005F3E 310D0A             
 36291                                  MSG_1059:
 36292 00005F41 04                      	db 4
 36293 00005F42 6F666600                	db 'off',0
 36294                                  MSG_1060:
 36295 00005F46 03                      	db 3
 36296 00005F47 6F6E00                  	db 'on',0
 36297                                  MSG_1061:
 36298 00005F4A 19                      	db 25
 36299 00005F4B 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 36299 00005F54 74696E6720746F2064-
 36299 00005F5D 65766963650D0A     
 36300                                  MSG_1063:
 36301 00005F64 02                      	db 2
 36302 00005F65 2531                    	db '%1'
 36303                                  MSG_1064:
 36304 00005F67 02                      	db 2
 36305 00005F68 2531                    	db '%1'
 36306                                  MSG_1065:
 36307 00005F6A 02                      	db 2
 36308 00005F6B 2531                    	db '%1'
 36309                                  MSG_1066:
 36310 00005F6D 02                      	db 2
 36311 00005F6E 2531                    	db '%1'
 36312                                  MSG_1067:
 36313 00005F70 01                      	db 1
 36314 00005F71 09                      	db 9
 36315                                  MSG_1068:
 36316 00005F72 0A                      	db 10
 36317 00005F73 203C4449523E202020-     	db ' <DIR>    '
 36317 00005F7C 20                 
 36318                                  MSG_1069:
 36319 00005F7D 03                      	db 3
 36320 00005F7E 082008                  	db 8, 20h, 8
 36321                                  MSG_1070:	; CRLF		
 36322 00005F81 02                      	db 2
 36323 00005F82 0D                      	db 0Dh
 36324 00005F83 0A                      	db 0Ah
 36325                                  MSG_1071:
 36326 00005F84 02                      	db 2
 36327 00005F85 2531                    	db '%1'
 36328                                  MSG_1072:
 36329 00005F87 08                      	db 8
 36330 00005F88 6D6D2D64642D7979        	db 'mm-dd-yy'
 36331                                  MSG_1073:
 36332 00005F90 08                      	db 8
 36333 00005F91 64642D6D6D2D7979        	db 'dd-mm-yy'
 36334                                  MSG_1074:
 36335 00005F99 08                      	db 8
 36336 00005F9A 79792D6D6D2D6464        	db 'yy-mm-dd'
 36337                                  MSG_1075:
 36338 00005FA2 05                      	db 5
 36339 00005FA3 2531202532              	db '%1 %2'
 36340                                  MSG_1076:
 36341 00005FA8 02                      	db 2
 36342 00005FA9 2531                    	db '%1'
 36343                                  MSG_1077:
 36344 00005FAB 07                      	db 7
 36345 00005FAC 20253120202532          	db ' %1  %2'
 36346                                  MSG_1078:
 36347 00005FB3 1A                      	db 26
 36348 00005FB4 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 36348 00005FBD 20616C726561647920-
 36348 00005FC6 6578697374730D0A   
 36349                                  MSG_1079:
 36350 00005FCE 0A                      	db 10
 36351 00005FCF 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 36351 00005FD8 0A                 
 36352                                  MSG_1080:
 36353 00005FD9 15                      	db 21
 36354 00005FDA 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 36354 00005FE3 6573206C6973746564-
 36354 00005FEC 3A0D0A             
 36355                                  MSG_1081:
 36356 00005FEF 2A                      	db 42
 36357 00005FF0 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 36357 00005FF9 63757272656420696E-
 36357 00006002 20656E7669726F6E6D-
 36357 0000600B 656E74207661726961-
 36357 00006014 626C65290D0A       
 36358                                  MSG_1084:
 36359 0000601A 0F                      	db 15
 36360 0000601B 28636F6E74696E7569-     	db '(continuing %1)'
 36360 00006024 6E6720253129       
 36361                                  MSG_1090:
 36362 0000602A 0D                      	db 13
 36363 0000602B 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 36363 00006034 25310D0A           
 36364                                  MSG_1091:
 36365 00006038 0D                      	db 13
 36366 00006039 444F5320697320696E-     	db 'DOS is in ROM'
 36366 00006042 20524F4D           
 36367                                  MSG_1092:
 36368 00006046 0D                      	db 13
 36369 00006047 444F5320697320696E-     	db 'DOS is in HMA'
 36369 00006050 20484D41           
 36370                                  MSG_1093:
 36371 00006054 14                      	db 20
 36372 00006055 444F5320697320696E-     	db 'DOS is in low memory'
 36372 0000605E 206C6F77206D656D6F-
 36372 00006067 7279               
 36373                                  MSG_1094:
 36374 00006069 1C                      	db 28
 36375 0000606A 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 36375 00006073 616468696768206261-
 36375 0000607C 7463682066696C650D-
 36375 00006085 0A                 
 36376                                  MSG_1095:
 36377 00006086 1C                      	db 28
 36378 00006087 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 36378 00006090 20496E76616C696420-
 36378 00006099 66696C656E616D650D-
 36378 000060A2 0A                 
 36379                                  MSG_1096:
 36380 000060A3 30                      	db 48
 36381 000060A4 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 36381 000060AD 656E20737065636966-
 36381 000060B6 69656420636F756E74-
 36381 000060BF 727920696E666F726D-
 36381 000060C8 6174696F6E2066696C-
 36381 000060D1 650D0A             
 36382                                  
 36383                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 36384                                  MSG_1200:
 36385 000060D4 00                      	db 0	; /? unimplemented
 36386                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 36387                                  MSG_1300:
 36388 000060D5 86                      	db 134
 36389 000060D6 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 36389 000060DF 6C6561727320657874-
 36389 000060E8 656E64656420435452-
 36389 000060F1 4C2B4320636865636B-
 36389 000060FA 696E672E0D0A       
 36390 00006100 0D0A                    	db 0Dh,0Ah
 36391 00006102 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 36391 0000610B 207C204F46465D0D0A 
 36392 00006114 0D0A                    	db 0Dh,0Ah
 36393 00006116 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 36393 0000611F 4B20776974686F7574-
 36393 00006128 206120706172616D65-
 36393 00006131 74657220746F206469-
 36393 0000613A 73706C617920746865-
 36393 00006143 2063757272656E7420-
 36393 0000614C 425245414B20736574-
 36393 00006155 74696E672E0D0A     
 36394                                  MSG_1320:
 36395 0000615C 3F                      	db 63
 36396 0000615D 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 36396 00006166 6F7220736574732074-
 36396 0000616F 686520616374697665-
 36396 00006178 20636F646520706167-
 36396 00006181 65206E756D6265722E-
 36396 0000618A 0D0A               
 36397 0000618C 0D0A                    	db 0Dh,0Ah
 36398 0000618E 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 36398 00006197 5D0D0A             
 36399 0000619A 0D0A                    	db 0Dh,0Ah
 36400                                  MSG_1321:
 36401 0000619C 70                      	db 112
 36402 0000619D 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 36402 000061A6 706563696669657320-
 36402 000061AF 6120636F6465207061-
 36402 000061B8 6765206E756D626572-
 36402 000061C1 2E0D0A             
 36403 000061C4 0D0A                    	db 0Dh,0Ah
 36404 000061C6 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 36404 000061CF 20776974686F757420-
 36404 000061D8 6120706172616D6574-
 36404 000061E1 657220746F20646973-
 36404 000061EA 706C61792074686520-
 36404 000061F3 61637469766520636F-
 36404 000061FC 64652070616765206E-
 36404 00006205 756D6265722E0D0A   
 36405                                  MSG_1340:
 36406 0000620D 5B                      	db 91
 36407 0000620E 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 36407 00006217 746865206E616D6520-
 36407 00006220 6F66206F7220636861-
 36407 00006229 6E6765732074686520-
 36407 00006232 63757272656E742064-
 36407 0000623B 69726563746F72792E-
 36407 00006244 0D0A               
 36408 00006246 0D0A                    	db 0Dh,0Ah
 36409 00006248 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 36409 00006251 6976653A5D5B706174-
 36409 0000625A 685D0D0A           
 36410 0000625E 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 36410 00006267 0D0A               
 36411                                  MSG_1341:
 36412 00006269 62                      	db 98
 36413 0000626A 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 36413 00006273 3A5D5B706174685D0D-
 36413 0000627C 0A                 
 36414 0000627D 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 36415 00006285 0D0A                    	db 0Dh,0Ah
 36416 00006287 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 36416 00006290 656369666965732074-
 36416 00006299 68617420796F752077-
 36416 000062A2 616E7420746F206368-
 36416 000062AB 616E676520746F2074-
 36416 000062B4 686520706172656E74-
 36416 000062BD 206469726563746F72-
 36416 000062C6 792E               
 36417 000062C8 0D0A                    	db 0Dh,0Ah
 36418 000062CA 0D0A                    	db 0Dh,0Ah
 36419                                  MSG_1342:
 36420 000062CC 91                      	db 145
 36421 000062CD 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 36421 000062D6 726976653A20746F20-
 36421 000062DF 646973706C61792074-
 36421 000062E8 68652063757272656E-
 36421 000062F1 74206469726563746F-
 36421 000062FA 727920696E20746865-
 36421 00006303 207370656369666965-
 36421 0000630C 6420               
 36422 0000630E 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 36423 00006316 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 36423 0000631F 6974686F7574207061-
 36423 00006328 72616D657465727320-
 36423 00006331 746F20646973706C61-
 36423 0000633A 792074686520637572-
 36423 00006343 72656E742064726976-
 36423 0000634C 6520616E6420646972-
 36423 00006355 6563746F72792E0D0A 
 36424                                  MSG_1360:
 36425 0000635E 1B                      	db 27
 36426 0000635F 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 36426 00006368 652073637265656E2E-
 36426 00006371 0D0A               
 36427 00006373 0D0A                    	db 0Dh,0Ah
 36428 00006375 434C530D0A              	db 'CLS',0Dh,0Ah
 36429                                  MSG_1400:
 36430 0000637A 91                      	db 145
 36431 0000637B 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 36431 00006384 65206F72206D6F7265-
 36431 0000638D 2066696C657320746F-
 36431 00006396 20616E6F7468657220-
 36431 0000639F 6C6F636174696F6E2E-
 36431 000063A8 0D0A               
 36432 000063AA 0D0A                    	db 0Dh,0Ah
 36433 000063AC 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 36433 000063B5 7C202F425D20736F75-
 36433 000063BE 726365205B2F41207C-
 36433 000063C7 202F425D205B2B2073-
 36433 000063D0 6F75726365205B2F41-
 36433 000063D9 207C202F425D205B2B-
 36433 000063E2 202E2E2E5D5D205B64-
 36433 000063EB 657374696E6174696F-
 36433 000063F4 6E0D0A             
 36434 000063F7 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 36434 00006400 425D5D205B2F565D0D-
 36434 00006409 0A                 
 36435 0000640A 0D0A                    	db 0Dh,0Ah
 36436                                  MSG_1401:
 36437 0000640C 68                      	db 104
 36438 0000640D 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 36438 00006416 202020202020537065-
 36438 0000641F 636966696573207468-
 36438 00006428 652066696C65206F72-
 36438 00006431 2066696C657320746F-
 36438 0000643A 20626520636F706965-
 36438 00006443 642E0D0A           
 36439 00006447 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 36439 00006450 202020202020496E64-
 36439 00006459 69636174657320616E-
 36439 00006462 204153434949207465-
 36439 0000646B 78742066696C652E0D-
 36439 00006474 0A                 
 36440                                  MSG_1402:
 36441 00006475 76                      	db 118
 36442 00006476 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 36442 0000647F 202020202020496E64-
 36442 00006488 696361746573206120-
 36442 00006491 62696E617279206669-
 36442 0000649A 6C652E0D0A         
 36443 0000649F 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 36443 000064A8 74696F6E2020537065-
 36443 000064B1 636966696573207468-
 36443 000064BA 65206469726563746F-
 36443 000064C3 727920616E642F6F72-
 36443 000064CC 2066696C656E616D65-
 36443 000064D5 20666F722074686520-
 36443 000064DE 6E65772066696C6528-
 36443 000064E7 73292E0D0A         
 36444                                  MSG_1403:	
 36445 000064EC 41                      	db 65
 36446 000064ED 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 36446 000064F6 202020202020566572-
 36446 000064FF 696669657320746861-
 36446 00006508 74206E65772066696C-
 36446 00006511 657320617265207772-
 36446 0000651A 697474656E20636F72-
 36446 00006523 726563746C792E0D0A 
 36447 0000652C 0D0A                    	db 0Dh,0Ah
 36448                                  MSG_1404:
 36449 0000652E 87                      	db 135
 36450 0000652F 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 36450 00006538 2066696C65732C2073-
 36450 00006541 706563696679206120-
 36450 0000654A 73696E676C65206669-
 36450 00006553 6C6520666F72206465-
 36450 0000655C 7374696E6174696F6E-
 36450 00006565 2C20627574206D756C-
 36450 0000656E 7469706C652066696C-
 36450 00006577 65730D0A           
 36451 0000657B 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 36451 00006584 6520287573696E6720-
 36451 0000658D 77696C646361726473-
 36451 00006596 206F722066696C6531-
 36451 0000659F 2B66696C65322B6669-
 36451 000065A8 6C653320666F726D61-
 36451 000065B1 74292E0D0A         
 36452                                  MSG_1420:
 36453 000065B6 8A                      	db 138
 36454 000065B7 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 36454 000065C0 6865207465726D696E-
 36454 000065C9 616C20646576696365-
 36454 000065D2 207573656420746F20-
 36454 000065DB 636F6E74726F6C2079-
 36454 000065E4 6F7572207379737465-
 36454 000065ED 6D2E0D0A           
 36455 000065F1 0D0A                    	db 0Dh,0Ah
 36456 000065F3 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 36456 000065FC 63650D0A           
 36457 00006600 0D0A                    	db 0Dh,0Ah
 36458 00006602 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 36458 0000660B 202054686520746572-
 36458 00006614 6D696E616C20646576-
 36458 0000661D 69636520796F752077-
 36458 00006626 616E7420746F207573-
 36458 0000662F 652C20737563682061-
 36458 00006638 7320434F4D312E0D0A 
 36459                                  MSG_1440:
 36460 00006641 2D                      	db 45
 36461 00006642 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 36461 0000664B 6F7220736574732074-
 36461 00006654 686520646174652E0D-
 36461 0000665D 0A                 
 36462 0000665E 0D0A                    	db 0Dh,0Ah
 36463 00006660 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 36463 00006669 655D0D0A           
 36464 0000666D 0D0A                    	db 0Dh,0Ah
 36465                                  MSG_1441:
 36466 0000666F 83                      	db 131
 36467 00006670 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 36467 00006679 20776974686F757420-
 36467 00006682 706172616D65746572-
 36467 0000668B 7320746F2064697370-
 36467 00006694 6C6179207468652063-
 36467 0000669D 757272656E74206461-
 36467 000066A6 74652073657474696E-
 36467 000066AF 6720616E640D0A     
 36468 000066B6 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 36468 000066BF 666F722061206E6577-
 36468 000066C8 206F6E652E20205072-
 36468 000066D1 65737320454E544552-
 36468 000066DA 20746F206B65657020-
 36468 000066E3 7468652073616D6520-
 36468 000066EC 646174652E0D0A     
 36469                                  MSG_1460:	
 36470 000066F3 64                      	db 100
 36471 000066F4 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36471 000066FD 6E65206F72206D6F72-
 36471 00006706 652066696C65732E0D-
 36471 0000670F 0A                 
 36472 00006710 0D0A                    	db 0Dh,0Ah
 36473 00006712 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36473 0000671B 653A5D5B706174685D-
 36473 00006724 66696C656E616D6520-
 36473 0000672D 5B2F505D0D0A       
 36474 00006733 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36474 0000673C 6976653A5D5B706174-
 36474 00006745 685D66696C656E616D-
 36474 0000674E 65205B2F505D0D0A   
 36475 00006756 0D0A                    	db 0Dh,0Ah
 36476                                  MSG_1461:
 36477 00006758 83                      	db 131
 36478 00006759 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36478 00006762 5D5B706174685D6669-
 36478 0000676B 6C656E616D65202053-
 36478 00006774 706563696669657320-
 36478 0000677D 7468652066696C6528-
 36478 00006786 732920746F2064656C-
 36478 0000678F 6574652E2020537065-
 36478 00006798 63696679206D756C74-
 36478 000067A1 69706C650D0A       
 36479 000067A7 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36479 000067B0 202020202020202020-
 36479 000067B9 202020202020202066-
 36479 000067C2 696C65732062792075-
 36479 000067CB 73696E672077696C64-
 36479 000067D4 63617264732E0D0A   
 36480                                  MSG_1462:
 36481 000067DC 4F                      	db 79
 36482 000067DD 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36482 000067E6 202020202020202020-
 36482 000067EF 202020202020202050-
 36482 000067F8 726F6D70747320666F-
 36482 00006801 7220636F6E6669726D-
 36482 0000680A 6174696F6E20626566-
 36482 00006813 6F72652064656C6574-
 36482 0000681C 696E67206561636820-
 36482 00006825 66696C652E0D0A     
 36483                                  MSG_1480:
 36484 0000682C A2                      	db 162
 36485 0000682D 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36485 00006836 61206C697374206F66-
 36485 0000683F 2066696C657320616E-
 36485 00006848 642073756264697265-
 36485 00006851 63746F726965732069-
 36485 0000685A 6E2061206469726563-
 36485 00006863 746F72792E0D0A     
 36486 0000686A 0D0A                    	db 0Dh,0Ah
 36487 0000686C 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36487 00006875 653A5D5B706174685D-
 36487 0000687E 5B66696C656E616D65-
 36487 00006887 5D205B2F505D205B2F-
 36487 00006890 575D205B2F415B5B3A-
 36487 00006899 5D6174747269627574-
 36487 000068A2 65735D5D0D0A       
 36488 000068A8 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36488 000068B1 736F72746F72646572-
 36488 000068BA 5D5D205B2F535D205B-
 36488 000068C3 2F425D205B2F4C5D0D-
 36488 000068CC 0A                 
 36489 000068CD 0D0A                    	db 0Dh,0Ah
 36490                                  MSG_1481:
 36491 000068CF 5D                      	db 93
 36492 000068D0 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36492 000068D9 5D5B706174685D5B66-
 36492 000068E2 696C656E616D655D0D-
 36492 000068EB 0A                 
 36493 000068EC 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36493 000068F5 202020202053706563-
 36493 000068FE 696669657320647269-
 36493 00006907 76652C206469726563-
 36493 00006910 746F72792C20616E64-
 36493 00006919 2F6F722066696C6573-
 36493 00006922 20746F206C6973742E-
 36493 0000692B 0D0A               
 36494                                  MSG_1482:
 36495 0000692D 61                      	db 97
 36496 0000692E 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36496 00006937 202020202050617573-
 36496 00006940 657320616674657220-
 36496 00006949 656163682073637265-
 36496 00006952 656E66756C206F6620-
 36496 0000695B 696E666F726D617469-
 36496 00006964 6F6E2E0D0A         
 36497 00006969 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36497 00006972 202020202055736573-
 36497 0000697B 2077696465206C6973-
 36497 00006984 7420666F726D61742E-
 36497 0000698D 0D0A               
 36498                                  MSG_1483:	
 36499 0000698F 7A                      	db 122
 36500 00006990 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36500 00006999 202020202044697370-
 36500 000069A2 6C6179732066696C65-
 36500 000069AB 732077697468207370-
 36500 000069B4 656369666965642061-
 36500 000069BD 747472696275746573-
 36500 000069C6 2E0D0A             
 36501 000069C9 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36501 000069D2 746573202020442020-
 36501 000069DB 4469726563746F7269-
 36501 000069E4 657320202020202020-
 36501 000069ED 202020202020202020-
 36501 000069F6 522020526561642D6F-
 36501 000069FF 6E6C792066696C6573-
 36501 00006A08 0D0A               
 36502                                  MSG_1484:
 36503 00006A0A BF                      	db 191
 36504 00006A0B 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36504 00006A14 202020202020482020-
 36504 00006A1D 48696464656E206669-
 36504 00006A26 6C6573202020202020-
 36504 00006A2F 202020202020202020-
 36504 00006A38 41202046696C657320-
 36504 00006A41 726561647920666F72-
 36504 00006A4A 20617263686976696E-
 36504 00006A53 670D0A             
 36505 00006A56 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36505 00006A5F 202020202020532020-
 36505 00006A68 53797374656D206669-
 36505 00006A71 6C6573202020202020-
 36505 00006A7A 202020202020202020-
 36505 00006A83 2D2020507265666978-
 36505 00006A8C 206D65616E696E6720-
 36505 00006A95 226E6F74220D0A     
 36506 00006A9C 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36506 00006AA5 20202020204C697374-
 36506 00006AAE 2062792066696C6573-
 36506 00006AB7 20696E20736F727465-
 36506 00006AC0 64206F726465722E0D-
 36506 00006AC9 0A                 
 36507                                  MSG_1485:
 36508 00006ACA 9B                      	db 155
 36509 00006ACB 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36509 00006AD4 6572202020204E2020-
 36509 00006ADD 4279206E616D652028-
 36509 00006AE6 616C70686162657469-
 36509 00006AEF 632920202020202020-
 36509 00006AF8 53202042792073697A-
 36509 00006B01 652028736D616C6C65-
 36509 00006B0A 737420666972737429-
 36509 00006B13 0D0A               
 36510 00006B15 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36510 00006B1E 202020202020452020-
 36510 00006B27 427920657874656E73-
 36510 00006B30 696F6E2028616C7068-
 36510 00006B39 616265746963292020-
 36510 00006B42 442020427920646174-
 36510 00006B4B 6520262074696D6520-
 36510 00006B54 286561726C69657374-
 36510 00006B5D 206669727374290D0A 
 36511                                  MSG_1486:
 36512 00006B66 96                      	db 150
 36513 00006B67 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36513 00006B70 202020202020472020-
 36513 00006B79 47726F757020646972-
 36513 00006B82 6563746F7269657320-
 36513 00006B8B 666972737420202020-
 36513 00006B94 2D2020507265666978-
 36513 00006B9D 20746F207265766572-
 36513 00006BA6 7365206F726465720D-
 36513 00006BAF 0A                 
 36514 00006BB0 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36514 00006BB9 202020202044697370-
 36514 00006BC2 6C6179732066696C65-
 36514 00006BCB 7320696E2073706563-
 36514 00006BD4 696669656420646972-
 36514 00006BDD 6563746F727920616E-
 36514 00006BE6 6420616C6C20737562-
 36514 00006BEF 6469726563746F7269-
 36514 00006BF8 65732E0D0A         
 36515                                  MSG_1487:
 36516 00006BFD 66                      	db 102
 36517 00006BFE 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36517 00006C07 202020202055736573-
 36517 00006C10 206261726520666F72-
 36517 00006C19 6D617420286E6F2068-
 36517 00006C22 656164696E6720696E-
 36517 00006C2B 666F726D6174696F6E-
 36517 00006C34 206F722073756D6D61-
 36517 00006C3D 7279292E0D0A       
 36518 00006C43 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36518 00006C4C 202020202055736573-
 36518 00006C55 206C6F776572636173-
 36518 00006C5E 652E0D0A           
 36519 00006C62 0D0A                    	db 0Dh,0Ah
 36520                                  MSG_1488:
 36521 00006C64 92                      	db 146
 36522 00006C65 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36522 00006C6E 6D6179206265207072-
 36522 00006C77 6573657420696E2074-
 36522 00006C80 686520444952434D44-
 36522 00006C89 20656E7669726F6E6D-
 36522 00006C92 656E74207661726961-
 36522 00006C9B 626C652E20204F7665-
 36522 00006CA4 72726964650D0A     
 36523 00006CAB 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36523 00006CB4 697463686573206279-
 36523 00006CBD 20707265666978696E-
 36523 00006CC6 6720616E7920737769-
 36523 00006CCF 746368207769746820-
 36523 00006CD8 2D202868797068656E-
 36523 00006CE1 292D2D666F72206578-
 36523 00006CEA 616D706C652C202F2D-
 36523 00006CF3 572E0D0A           
 36524                                  MSG_1500:
 36525 00006CF7 3E                      	db 62
 36526 00006CF8 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36526 00006D01 20434F4D4D414E442E-
 36526 00006D0A 434F4D2070726F6772-
 36526 00006D13 616D2028636F6D6D61-
 36526 00006D1C 6E6420696E74657270-
 36526 00006D25 7265746572292E0D0A 
 36527 00006D2E 0D0A                    	db 0Dh,0Ah
 36528 00006D30 455849540D0A            	db 'EXIT',0Dh,0Ah
 36529                                  MSG_1520:
 36530 00006D36 3D                      	db 61
 36531 00006D37 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36531 00006D40 206469726563746F72-
 36531 00006D49 792E0D0A           
 36532 00006D4D 0D0A                    	db 0Dh,0Ah
 36533 00006D4F 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36533 00006D58 6976653A5D70617468-
 36533 00006D61 0D0A               
 36534 00006D63 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36534 00006D6C 3A5D706174680D0A   
 36535                                  MSG_1540:
 36536 00006D74 5D                      	db 93
 36537 00006D75 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36537 00006D7E 6F7220736574732061-
 36537 00006D87 207365617263682070-
 36537 00006D90 61746820666F722065-
 36537 00006D99 786563757461626C65-
 36537 00006DA2 2066696C65732E0D0A 
 36538 00006DAB 0D0A                    	db 0Dh,0Ah
 36539 00006DAD 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36539 00006DB6 6976653A5D70617468-
 36539 00006DBF 5B3B2E2E2E5D5D0D0A 
 36540 00006DC8 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36541 00006DD0 0D0A                    	db 0Dh,0Ah
 36542                                  MSG_1541:
 36543 00006DD2 6B                      	db 107
 36544 00006DD3 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36544 00006DDC 203B20746F20636C65-
 36544 00006DE5 617220616C6C207365-
 36544 00006DEE 617263682D70617468-
 36544 00006DF7 2073657474696E6773-
 36544 00006E00 20616E642064697265-
 36544 00006E09 6374204D532D444F53-
 36544 00006E12 20746F207365617263-
 36544 00006E1B 680D0A             
 36545 00006E1E 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36545 00006E27 68652063757272656E-
 36545 00006E30 74206469726563746F-
 36545 00006E39 72792E0D0A         
 36546                                  MSG_1542:	
 36547 00006E3E 3B                      	db 59
 36548 00006E3F 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36548 00006E48 20776974686F757420-
 36548 00006E51 706172616D65746572-
 36548 00006E5A 7320746F2064697370-
 36548 00006E63 6C6179207468652063-
 36548 00006E6C 757272656E74207061-
 36548 00006E75 74682E0D0A         
 36549                                  MSG_1560:
 36550 00006E7A 37                      	db 55
 36551 00006E7B 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36551 00006E84 6865204D532D444F53-
 36551 00006E8D 20636F6D6D616E6420-
 36551 00006E96 70726F6D70742E0D0A 
 36552 00006E9F 0D0A                    	db 0Dh,0Ah
 36553 00006EA1 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36553 00006EAA 6578745D0D0A       
 36554 00006EB0 0D0A                    	db 0Dh,0Ah
 36555                                  MSG_1561:	
 36556 00006EB2 7C                      	db 124
 36557 00006EB3 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36557 00006EBC 205370656369666965-
 36557 00006EC5 732061206E65772063-
 36557 00006ECE 6F6D6D616E64207072-
 36557 00006ED7 6F6D70742E0D0A     
 36558 00006EDE 0D0A                    	db 0Dh,0Ah
 36559 00006EE0 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36559 00006EE9 6E206265206D616465-
 36559 00006EF2 207570206F66206E6F-
 36559 00006EFB 726D616C2063686172-
 36559 00006F04 61637465727320616E-
 36559 00006F0D 642074686520666F6C-
 36559 00006F16 6C6F77696E67207370-
 36559 00006F1F 656369616C20636F64-
 36559 00006F28 65733A0D0A         
 36560 00006F2D 0D0A                    	db 0Dh,0Ah
 36561                                  MSG_1562:
 36562 00006F2F 2F                      	db 47
 36563 00006F30 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36563 00006F39 28657175616C207369-
 36563 00006F42 676E290D0A         
 36564 00006F47 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36564 00006F50 28646F6C6C61722073-
 36564 00006F59 69676E290D0A       
 36565                                  MSG_1563:
 36566 00006F5F 2A                      	db 42
 36567 00006F60 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36567 00006F69 7272656E742074696D-
 36567 00006F72 650D0A             
 36568 00006F75 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36568 00006F7E 7272656E7420646174-
 36568 00006F87 650D0A             
 36569                                  MSG_1564:
 36570 00006F8A 3D                      	db 61
 36571 00006F8B 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36571 00006F94 7272656E7420647269-
 36571 00006F9D 766520616E64207061-
 36571 00006FA6 74680D0A           
 36572 00006FAA 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36572 00006FB3 2D444F532076657273-
 36572 00006FBC 696F6E206E756D6265-
 36572 00006FC5 720D0A             
 36573                                  MSG_1565:
 36574 00006FC8 34                      	db 52
 36575 00006FC9 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36575 00006FD2 7272656E7420647269-
 36575 00006FDB 76650D0A           
 36576 00006FDF 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36576 00006FE8 28677265617465722D-
 36576 00006FF1 7468616E207369676E-
 36576 00006FFA 290D0A             
 36577                                  MSG_1566:
 36578 00006FFD 2C                      	db 44
 36579 00006FFE 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36579 00007007 286C6573732D746861-
 36579 00007010 6E207369676E290D0A 
 36580 00007019 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36580 00007022 2870697065290D0A   
 36581                                  MSG_1567:
 36582 0000702A 79                      	db 121
 36583 0000702B 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36583 00007034 636B73706163652028-
 36583 0000703D 657261736573207072-
 36583 00007046 6576696F7573206368-
 36583 0000704F 61726163746572290D-
 36583 00007058 0A                 
 36584 00007059 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36584 00007062 6361706520636F6465-
 36584 0000706B 202841534349492063-
 36584 00007074 6F6465203237290D0A 
 36585 0000707D 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36585 00007086 727269616765207265-
 36585 0000708F 7475726E20616E6420-
 36585 00007098 6C696E65666565640D-
 36585 000070A1 0A                 
 36586 000070A2 0D0A                    	db 0Dh,0Ah
 36587                                  MSG_1568:
 36588 000070A4 4C                      	db 76
 36589 000070A5 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36589 000070AE 505420776974686F75-
 36589 000070B7 7420706172616D6574-
 36589 000070C0 65727320746F207265-
 36589 000070C9 736574207468652070-
 36589 000070D2 726F6D707420746F20-
 36589 000070DB 746865206465666175-
 36589 000070E4 6C742073657474696E-
 36589 000070ED 672E0D0A           
 36590                                  MSG_1580:
 36591 000070F1 47                      	db 71
 36592 000070F2 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36592 000070FB 64656C657465732920-
 36592 00007104 61206469726563746F-
 36592 0000710D 72792E0D0A         
 36593 00007112 0D0A                    	db 0Dh,0Ah
 36594 00007114 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36594 0000711D 6976653A5D70617468-
 36594 00007126 0D0A               
 36595 00007128 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36595 00007131 3A5D706174680D0A   
 36596                                  MSG_1600:
 36597 00007139 1C                      	db 28
 36598 0000713A 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36598 00007143 2066696C65206F7220-
 36598 0000714C 66696C65732E0D0A   
 36599 00007154 0D0A                    	db 0Dh,0Ah
 36600                                  MSG_1601:
 36601 00007156 53                      	db 83
 36602 00007157 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36602 00007160 726976653A5D5B7061-
 36602 00007169 74685D66696C656E61-
 36602 00007172 6D65312066696C656E-
 36602 0000717B 616D65320D0A       
 36603 00007181 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36603 0000718A 653A5D5B706174685D-
 36603 00007193 66696C656E616D6531-
 36603 0000719C 2066696C656E616D65-
 36603 000071A5 320D0A             
 36604 000071A8 0D0A                    	db 0Dh,0Ah
 36605                                  MSG_1602:
 36606 000071AA 4D                      	db 77
 36607 000071AB 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36607 000071B4 20796F752063616E6E-
 36607 000071BD 6F7420737065636966-
 36607 000071C6 792061206E65772064-
 36607 000071CF 72697665206F722070-
 36607 000071D8 61746820666F722079-
 36607 000071E1 6F7572206465737469-
 36607 000071EA 6E6174696F6E206669-
 36607 000071F3 6C652E0D0A         
 36608                                  MSG_1620:
 36609 000071F8 57                      	db 87
 36610 000071F9 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36610 00007202 20736574732C206F72-
 36610 0000720B 2072656D6F76657320-
 36610 00007214 4D532D444F5320656E-
 36610 0000721D 7669726F6E6D656E74-
 36610 00007226 207661726961626C65-
 36610 0000722F 732E0D0A           
 36611 00007233 0D0A                    	db 0Dh,0Ah
 36612 00007235 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36612 0000723E 61626C653D5B737472-
 36612 00007247 696E675D5D0D0A     
 36613 0000724E 0D0A                    	db 0Dh,0Ah
 36614                                  MSG_1621:
 36615 00007250 81                      	db 129
 36616 00007251 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36616 0000725A 652020537065636966-
 36616 00007263 696573207468652065-
 36616 0000726C 6E7669726F6E6D656E-
 36616 00007275 742D7661726961626C-
 36616 0000727E 65206E616D652E0D0A 
 36617 00007287 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36617 00007290 202020537065636966-
 36617 00007299 696573206120736572-
 36617 000072A2 696573206F66206368-
 36617 000072AB 617261637465727320-
 36617 000072B4 746F2061737369676E-
 36617 000072BD 20746F207468652076-
 36617 000072C6 61726961626C652E0D-
 36617 000072CF 0A                 
 36618 000072D0 0D0A                    	db 0Dh,0Ah
 36619                                  MSG_1622:
 36620 000072D2 4B                      	db 75
 36621 000072D3 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36621 000072DC 776974686F75742070-
 36621 000072E5 6172616D6574657273-
 36621 000072EE 20746F20646973706C-
 36621 000072F7 617920746865206375-
 36621 00007300 7272656E7420656E76-
 36621 00007309 69726F6E6D656E7420-
 36621 00007312 7661726961626C6573-
 36621 0000731B 2E0D0A             
 36622                                  MSG_1640:
 36623 0000731E 34                      	db 52
 36624 0000731F 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36624 00007328 6F7220736574732074-
 36624 00007331 68652073797374656D-
 36624 0000733A 2074696D652E0D0A   
 36625 00007342 0D0A                    	db 0Dh,0Ah
 36626 00007344 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36626 0000734D 655D0D0A           
 36627 00007351 0D0A                    	db 0Dh,0Ah
 36628                                  MSG_1641:
 36629 00007353 83                      	db 131
 36630 00007354 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36630 0000735D 2077697468206E6F20-
 36630 00007366 706172616D65746572-
 36630 0000736F 7320746F2064697370-
 36630 00007378 6C6179207468652063-
 36630 00007381 757272656E74207469-
 36630 0000738A 6D652073657474696E-
 36630 00007393 6720616E6420612070-
 36630 0000739C 726F6D70740D0A     
 36631 000073A3 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36631 000073AC 206F6E652E20205072-
 36631 000073B5 65737320454E544552-
 36631 000073BE 20746F206B65657020-
 36631 000073C7 7468652073616D6520-
 36631 000073D0 74696D652E0D0A     
 36632                                  MSG_1660:
 36633 000073D7 46                      	db 70
 36634 000073D8 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36634 000073E1 74686520636F6E7465-
 36634 000073EA 6E7473206F66206120-
 36634 000073F3 746578742066696C65-
 36634 000073FC 2E0D0A             
 36635 000073FF 0D0A                    	db 0Dh,0Ah
 36636 00007401 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36636 0000740A 76653A5D5B70617468-
 36636 00007413 5D66696C656E616D65-
 36636 0000741C 0D0A               
 36637                                  MSG_1680:
 36638 0000741E 25                      	db 37
 36639 0000741F 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36639 00007428 746865204D532D444F-
 36639 00007431 532076657273696F6E-
 36639 0000743A 2E0D0A             
 36640 0000743D 0D0A                    	db 0Dh,0Ah
 36641 0000743F 5645520D0A              	db 'VER',0Dh,0Ah
 36642                                  MSG_1700:
 36643 00007444 B1                      	db 177
 36644 00007445 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36644 0000744E 444F53207768657468-
 36644 00007457 657220746F20766572-
 36644 00007460 696679207468617420-
 36644 00007469 796F75722066696C65-
 36644 00007472 732061726520777269-
 36644 0000747B 7474656E20636F7272-
 36644 00007484 6563746C7920746F20-
 36644 0000748D 610D0A             
 36645 00007490 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36646 00007497 0D0A                    	db 0Dh,0Ah
 36647 00007499 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36647 000074A2 4E207C204F46465D0D-
 36647 000074AB 0A                 
 36648 000074AC 0D0A                    	db 0Dh,0Ah
 36649 000074AE 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36649 000074B7 465920776974686F75-
 36649 000074C0 74206120706172616D-
 36649 000074C9 6574657220746F2064-
 36649 000074D2 6973706C6179207468-
 36649 000074DB 652063757272656E74-
 36649 000074E4 205645524946592073-
 36649 000074ED 657474696E672E0D0A 
 36650                                  MSG_1720:              
 36651 000074F6 52                      	db 82
 36652 000074F7 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36652 00007500 746865206469736B20-
 36652 00007509 766F6C756D65206C61-
 36652 00007512 62656C20616E642073-
 36652 0000751B 657269616C206E756D-
 36652 00007524 6265722C2069662074-
 36652 0000752D 686579206578697374-
 36652 00007536 2E0D0A             
 36653 00007539 0D0A                    	db 0Dh,0Ah
 36654 0000753B 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36654 00007544 653A5D0D0A         
 36655                                  MSG_1740:
 36656 00007549 5B                      	db 91
 36657 0000754A 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36657 00007553 206261746368207072-
 36657 0000755C 6F6772616D2066726F-
 36657 00007565 6D20616E6F74686572-
 36657 0000756E 2E0D0A             
 36658 00007571 0D0A                    	db 0Dh,0Ah
 36659 00007573 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36659 0000757C 76653A5D5B70617468-
 36659 00007585 5D66696C656E616D65-
 36659 0000758E 205B62617463682D70-
 36659 00007597 6172616D6574657273-
 36659 000075A0 5D0D0A             
 36660 000075A3 0D0A                    	db 0Dh,0Ah
 36661                                  MSG_1741:
 36662 000075A5 72                      	db 114
 36663 000075A6 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36663 000075AF 6172616D6574657273-
 36663 000075B8 202020537065636966-
 36663 000075C1 69657320616E792063-
 36663 000075CA 6F6D6D616E642D6C69-
 36663 000075D3 6E6520696E666F726D-
 36663 000075DC 6174696F6E20726571-
 36663 000075E5 756972656420627920-
 36663 000075EE 7468650D0A         
 36664 000075F3 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36664 000075FC 202020202020202020-
 36664 00007605 202020626174636820-
 36664 0000760E 70726F6772616D2E0D-
 36664 00007617 0A                 
 36665                                  MSG_1760:	
 36666 00007618 4C                      	db 76
 36667 00007619 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36667 00007622 6F6D6D656E74732028-
 36667 0000762B 72656D61726B732920-
 36667 00007634 696E20612062617463-
 36667 0000763D 682066696C65206F72-
 36667 00007646 20434F4E4649472E53-
 36667 0000764F 59532E0D0A         
 36668 00007654 0D0A                    	db 0Dh,0Ah
 36669 00007656 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36669 0000765F 656E745D0D0A       
 36670                                  MSG_1780:
 36671 00007665 6B                      	db 107
 36672 00007666 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36672 0000766F 70726F63657373696E-
 36672 00007678 67206F662061206261-
 36672 00007681 7463682070726F6772-
 36672 0000768A 616D20616E64206469-
 36672 00007693 73706C617973207468-
 36672 0000769C 65206D657373616765-
 36672 000076A5 2022               
 36673 000076A7 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36673 000076B0 0D0A               
 36674 000076B2 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36674 000076BB 6E74696E75652E2E2E-
 36674 000076C4 2E220D0A           
 36675 000076C8 0D0A                    	db 0Dh,0Ah
 36676 000076CA 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36677                                  MSG_1800:
 36678 000076D1 4D                      	db 77
 36679 000076D2 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36679 000076DB 6D657373616765732C-
 36679 000076E4 206F72207475726E73-
 36679 000076ED 20636F6D6D616E642D-
 36679 000076F6 6563686F696E67206F-
 36679 000076FF 6E206F72206F66662E-
 36679 00007708 0D0A               
 36680 0000770A 0D0A                    	db 0Dh,0Ah
 36681 0000770C 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36681 00007715 4E207C204F46465D0D-
 36681 0000771E 0A                 
 36682                                  MSG_1801:
 36683 0000771F 57                      	db 87
 36684 00007720 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36684 00007729 6573736167655D0D0A 
 36685 00007732 0D0A                    	db 0Dh,0Ah
 36686 00007734 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36686 0000773D 20776974686F757420-
 36686 00007746 706172616D65746572-
 36686 0000774F 7320746F2064697370-
 36686 00007758 6C6179207468652063-
 36686 00007761 757272656E74206563-
 36686 0000776A 686F2073657474696E-
 36686 00007773 672E               
 36687 00007775 0D0A                    	db 0Dh,0Ah
 36688                                  MSG_1820:
 36689 00007777 47                      	db 71
 36690 00007778 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36690 00007781 532D444F5320746F20-
 36690 0000778A 61206C6162656C6C65-
 36690 00007793 64206C696E6520696E-
 36690 0000779C 206120626174636820-
 36690 000077A5 70726F6772616D2E0D-
 36690 000077AE 0A                 
 36691 000077AF 0D0A                    	db 0Dh,0Ah
 36692 000077B1 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36692 000077BA 6C0D0A             
 36693 000077BD 0D0A                    	db 0Dh,0Ah
 36694                                  MSG_1821:
 36695 000077BF 8A                      	db 138
 36696 000077C0 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36696 000077C9 205370656369666965-
 36696 000077D2 732061207465787420-
 36696 000077DB 737472696E67207573-
 36696 000077E4 656420696E20746865-
 36696 000077ED 206261746368207072-
 36696 000077F6 6F6772616D20617320-
 36696 000077FF 61206C6162656C2E0D-
 36696 00007808 0A                 
 36697 00007809 0D0A                    	db 0Dh,0Ah
 36698 0000780B 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36698 00007814 61206C6162656C206F-
 36698 0000781D 6E2061206C696E6520-
 36698 00007826 627920697473656C66-
 36698 0000782F 2C20626567696E6E69-
 36698 00007838 6E6720776974682061-
 36698 00007841 20636F6C6F6E2E0D0A 
 36699                                  MSG_1840:
 36700 0000784A 4A                      	db 74
 36701 0000784B 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36701 00007854 686520706F73697469-
 36701 0000785D 6F6E206F6620726570-
 36701 00007866 6C61636561626C6520-
 36701 0000786F 706172616D65746572-
 36701 00007878 7320696E2061206261-
 36701 00007881 7463682066696C652E-
 36701 0000788A 0D0A               
 36702 0000788C 0D0A                    	db 0Dh,0Ah
 36703 0000788E 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36704                                  MSG_1860:
 36705 00007895 5A                      	db 90
 36706 00007896 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36706 0000789F 636F6E646974696F6E-
 36706 000078A8 616C2070726F636573-
 36706 000078B1 73696E6720696E2062-
 36706 000078BA 617463682070726F67-
 36706 000078C3 72616D732E0D0A     
 36707 000078CA 0D0A                    	db 0Dh,0Ah
 36708 000078CC 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36708 000078D5 4552524F524C455645-
 36708 000078DE 4C206E756D62657220-
 36708 000078E7 636F6D6D616E640D0A 
 36709                                  MSG_1861:
 36710 000078F0 46                      	db 70
 36711 000078F1 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36711 000078FA 737472696E67313D3D-
 36711 00007903 737472696E67322063-
 36711 0000790C 6F6D6D616E640D0A   
 36712 00007914 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36712 0000791D 45584953542066696C-
 36712 00007926 656E616D6520636F6D-
 36712 0000792F 6D616E640D0A       
 36713 00007935 0D0A                    	db 0Dh,0Ah
 36714                                  MSG_1862:
 36715 00007937 7D                      	db 125
 36716 00007938 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36716 00007941 202020202020202020-
 36716 0000794A 202053706563696669-
 36716 00007953 65732074686174204D-
 36716 0000795C 532D444F532073686F-
 36716 00007965 756C64206361727279-
 36716 0000796E 206F75742074686520-
 36716 00007977 636F6D6D616E64206F-
 36716 00007980 6E6C790D0A         
 36717 00007985 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36717 0000798E 202020202020202020-
 36717 00007997 202069662074686520-
 36717 000079A0 636F6E646974696F6E-
 36717 000079A9 2069732066616C7365-
 36717 000079B2 2E0D0A             
 36718                                  MSG_1863:
 36719 000079B5 A2                      	db 162
 36720 000079B6 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36720 000079BF 56454C206E756D6265-
 36720 000079C8 722053706563696669-
 36720 000079D1 657320612074727565-
 36720 000079DA 20636F6E646974696F-
 36720 000079E3 6E2069662074686520-
 36720 000079EC 6C6173742070726F67-
 36720 000079F5 72616D2072756E2072-
 36720 000079FE 657475726E65640D0A 
 36721 00007A07 202020202020202020-     	db '                    '
 36721 00007A10 202020202020202020-
 36721 00007A19 2020               
 36722 00007A1B 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36722 00007A24 6F646520657175616C-
 36722 00007A2D 20746F206F72206772-
 36722 00007A36 656174657220746861-
 36722 00007A3F 6E20746865206E756D-
 36722 00007A48 626572207370656369-
 36722 00007A51 666965642E0D0A     
 36723                                  MSG_1864:
 36724 00007A58 66                      	db 102
 36725 00007A59 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36725 00007A62 202020202020202020-
 36725 00007A6B 202053706563696669-
 36725 00007A74 65732074686520636F-
 36725 00007A7D 6D6D616E6420746F20-
 36725 00007A86 6361727279206F7574-
 36725 00007A8F 206966207468652063-
 36725 00007A98 6F6E646974696F6E20-
 36725 00007AA1 69730D0A           
 36726 00007AA5 202020202020202020-     	db '                    met.',0Dh,0Ah
 36726 00007AAE 202020202020202020-
 36726 00007AB7 20206D65742E0D0A   
 36727                                  MSG_1865:
 36728 00007ABF 6A                      	db 106
 36729 00007AC0 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36729 00007AC9 3D3D737472696E6732-
 36729 00007AD2 202053706563696669-
 36729 00007ADB 657320612074727565-
 36729 00007AE4 20636F6E646974696F-
 36729 00007AED 6E2069662074686520-
 36729 00007AF6 737065636966696564-
 36729 00007AFF 207465787420737472-
 36729 00007B08 696E67730D0A       
 36730 00007B0E 202020202020202020-     	db '                    match.',0Dh,0Ah
 36730 00007B17 202020202020202020-
 36730 00007B20 20206D617463682E0D-
 36730 00007B29 0A                 
 36731                                  MSG_1866:
 36732 00007B2A 67                      	db 103
 36733 00007B2B 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36733 00007B34 696C656E616D652020-
 36733 00007B3D 202053706563696669-
 36733 00007B46 657320612074727565-
 36733 00007B4F 20636F6E646974696F-
 36733 00007B58 6E2069662074686520-
 36733 00007B61 737065636966696564-
 36733 00007B6A 2066696C656E616D65-
 36733 00007B73 0D0A               
 36734 00007B75 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36734 00007B7E 202020202020202020-
 36734 00007B87 20206578697374732E-
 36734 00007B90 0D0A               
 36735                                  MSG_1880:
 36736 00007B92 77                      	db 119
 36737 00007B93 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36737 00007B9C 656369666965642063-
 36737 00007BA5 6F6D6D616E6420666F-
 36737 00007BAE 722065616368206669-
 36737 00007BB7 6C6520696E20612073-
 36737 00007BC0 6574206F662066696C-
 36737 00007BC9 65732E0D0A         
 36738 00007BCE 0D0A                    	db 0Dh,0Ah
 36739 00007BD0 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36739 00007BD9 61626C6520494E2028-
 36739 00007BE2 7365742920444F2063-
 36739 00007BEB 6F6D6D616E64205B63-
 36739 00007BF4 6F6D6D616E642D7061-
 36739 00007BFD 72616D65746572735D-
 36739 00007C06 0D0A               
 36740 00007C08 0D0A                    	db 0Dh,0Ah
 36741                                  MSG_1881:
 36742 00007C0A 7D                      	db 125
 36743 00007C0B 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36743 00007C14 6C6520205370656369-
 36743 00007C1D 666965732061207265-
 36743 00007C26 706C61636561626C65-
 36743 00007C2F 20706172616D657465-
 36743 00007C38 722E0D0A           
 36744 00007C3C 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36744 00007C45 202020205370656369-
 36744 00007C4E 666965732061207365-
 36744 00007C57 74206F66206F6E6520-
 36744 00007C60 6F72206D6F72652066-
 36744 00007C69 696C65732E20205769-
 36744 00007C72 6C646361726473206D-
 36744 00007C7B 617920626520757365-
 36744 00007C84 642E0D0A           
 36745                                  MSG_1882:
 36746 00007C88 56                      	db 86
 36747 00007C89 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36747 00007C92 202020205370656369-
 36747 00007C9B 666965732074686520-
 36747 00007CA4 636F6D6D616E642074-
 36747 00007CAD 6F206361727279206F-
 36747 00007CB6 757420666F72206561-
 36747 00007CBF 63682066696C652E0D-
 36747 00007CC8 0A                 
 36748 00007CC9 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36748 00007CD2 2D706172616D657465-
 36748 00007CDB 72730D0A           
 36749                                  MSG_1883:
 36750 00007CDF A2                      	db 162
 36751 00007CE0 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36751 00007CE9 202020205370656369-
 36751 00007CF2 666965732070617261-
 36751 00007CFB 6D6574657273206F72-
 36751 00007D04 207377697463686573-
 36751 00007D0D 20666F722074686520-
 36751 00007D16 737065636966696564-
 36751 00007D1F 20636F6D6D616E642E-
 36751 00007D28 0D0A               
 36752 00007D2A 0D0A                    	db 0Dh,0Ah
 36753 00007D2C 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36753 00007D35 6520464F5220636F6D-
 36753 00007D3E 6D616E6420696E2061-
 36753 00007D47 206261746368207072-
 36753 00007D50 6F6772616D2C207370-
 36753 00007D59 656369667920252576-
 36753 00007D62 61726961626C652069-
 36753 00007D6B 6E7374656164206F66-
 36753 00007D74 0D0A               
 36754 00007D76 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36754 00007D7F 2E0D0A             
 36755                                  MSG_1900:
 36756 00007D82 17                      	db 23
 36757 00007D83 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36757 00007D8C 636F6D6D616E64206E-
 36757 00007D95 616D650D0A         
 36758                                  MSG_1920:
 36759 00007D9A 2F                      	db 47
 36760 00007D9B 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36760 00007DA4 726F6772616D20696E-
 36760 00007DAD 746F20746865207570-
 36760 00007DB6 706572206D656D6F72-
 36760 00007DBF 7920617265612E0D0A 
 36761 00007DC8 0D0A                    	db 0Dh,0Ah
 36762                                  MSG_1921:
 36763 00007DCA 58                      	db 88
 36764 00007DCB 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36764 00007DD4 5B64726976653A5D5B-
 36764 00007DDD 706174685D66696C65-
 36764 00007DE6 6E616D65205B706172-
 36764 00007DEF 616D65746572735D0D-
 36764 00007DF8 0A                 
 36765 00007DF9 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36765 00007E02 3A5D5B706174685D66-
 36765 00007E0B 696C656E616D65205B-
 36765 00007E14 706172616D65746572-
 36765 00007E1D 735D0D0A           
 36766 00007E21 0D0A                    	db 0Dh,0Ah
 36767                                  MSG_1922:
 36768 00007E23 71                      	db 113
 36769 00007E24 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36769 00007E2D 657273202020537065-
 36769 00007E36 63696669657320616E-
 36769 00007E3F 7920636F6D6D616E64-
 36769 00007E48 2D6C696E6520696E66-
 36769 00007E51 6F726D6174696F6E20-
 36769 00007E5A 726571756972656420-
 36769 00007E63 6279207468650D0A   
 36770 00007E6B 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36770 00007E74 20202020202070726F-
 36770 00007E7D 6772616D20796F7520-
 36770 00007E86 77616E7420746F206C-
 36770 00007E8F 6F61642E0D0A       
 36771                                  
 36772                                  ; ---------------------------------------------------------------------------
 36773                                  
 36774                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36775                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36776                                  
 36777                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36778                                  
 36779                                  $M_CLS_3:
 36780 00007E95 0E                      	push	cs		; CLASS_F
 36781 00007E96 07                      	pop	es
 36782 00007E97 8D3E[5657]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36783                                  	; 15/04/2023
 36784                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36785 00007E9B C3                      	retn
 36786                                  
 36787                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36788                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36789                                  
 36790                                  ; ---------------------------------------------------------------------------
 36791                                  ; Class 1 messages
 36792                                  ; ---------------------------------------------------------------------------
 36793                                  	
 36794                                  $M_CLASS_1_STRUC:
 36795 00007E9C 01                      	db 1			; $M_CLASS_ID
 36796 00007E9D 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36797 00007E9F 04                      	db 4			; Class_1_MessageCount
 36798                                  $M_ID_1_1:
 36799 00007EA0 0200                    	dw 2			; Message Number = 2
 36800 00007EA2 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36801                                  $M_ID_1_2:
 36802 00007EA4 0300                    	dw 3			; Message Number = 3
 36803 00007EA6 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36804                                  $M_ID_1_3:
 36805 00007EA8 0800                    	dw 8			; Message Number = 8
 36806 00007EAA 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36807                                  $M_ID_1_4:
 36808 00007EAC FFFF                    	dw 0FFFFh		; Message Number = -1
 36809 00007EAE 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36810                                  
 36811                                  ; ---------------------------------------------------------------------------
 36812                                  
 36813                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36814                                  EXTEND2:
 36815 00007EB0 0E                      	db 14
 36816 00007EB1 46696C65206E6F7420-     	db 'File not found'
 36816 00007EBA 666F756E64         
 36817                                  EXTEND3:
 36818 00007EBF 0E                      	db 14
 36819 00007EC0 50617468206E6F7420-     	db 'Path not found'
 36819 00007EC9 666F756E64         
 36820                                  EXTEND8:
 36821 00007ECE 13                      	db 19
 36822 00007ECF 496E73756666696369-     	db 'Insufficient memory'
 36822 00007ED8 656E74206D656D6F72-
 36822 00007EE1 79                 
 36823                                  EXTEND999:
 36824 00007EE2 11                      	db 17
 36825 00007EE3 457874656E64656420-     	db 'Extended Error %1'
 36825 00007EEC 4572726F72202531   
 36826                                  
 36827                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36828                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36829                                  
 36830                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36831                                  $M_MSGSERV_1:
 36832 00007EF4 0E                      	push	cs
 36833 00007EF5 07                      	pop	es
 36834 00007EF6 8D3E[9C7E]              	lea	di,$M_CLASS_1_STRUC
 36835                                  	; 15/04/2023
 36836                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36837 00007EFA C3                      	retn
 36838                                  
 36839                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36840                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36841                                  
 36842                                  ; ---------------------------------------------------------------------------
 36843                                  ; Class 2 messages
 36844                                  ; ---------------------------------------------------------------------------
 36845                                  	
 36846                                  $M_CLASS_2_STRUC:
 36847 00007EFB 02                      	db 2			; $M_CLASS_ID
 36848 00007EFC 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36849 00007EFE 01                      	db 1			; Class_2_MessageCount
 36850                                  $M_ID_2_1:
 36851 00007EFF FFFF                    	dw 0FFFFh		; Message Number = -1
 36852 00007F01 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36853                                  ; ---------------------------------------------------------------------------
 36854                                  
 36855                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36856                                  PARSE999:
 36857 00007F03 0E                      	db 14
 36858 00007F04 506172736520457272-     	db 'Parse Error %1'
 36858 00007F0D 6F72202531         
 36859                                  
 36860                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 36862                                  
 36863                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36864                                  $M_MSGSERV_2:
 36865 00007F12 0E                      	push	cs
 36866 00007F13 07                      	pop	es
 36867 00007F14 8D3E[FB7E]              	lea	di,$M_CLASS_2_STRUC
 36868                                  	; 15/04/2023
 36869                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 36870 00007F18 C3                      	retn
 36871                                  
 36872                                  ;============================================================================
 36873                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 36874                                  ;============================================================================
 36875                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36876                                  
 36877                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 36878                                  
 36879                                  ;****************************************************
 36880                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 36881                                  ;****************************************************
 36882                                  
 36883                                  msg_disp_class:
 36884 00007F19 FF                      	db	util_msg_class ; 0FFh
 36885                                  msg_cont_flag:
 36886 00007F1A 00                      	db	no_cont_flag ; 0
 36887                                  
 36888                                  ;  extended error string output
 36889                                  extend_buf_ptr:
 36890 00007F1B 0000                    	dw	0			;AN000;set to no message
 36891                                  extend_buf_sub:
 36892 00007F1D 00                      	db	0			;AN000;set to no substitutions
 36893 00007F1E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36894 00007F1F 00                      	db	0			;AN000;reserved
 36895                                  extend_buf_off:
 36896 00007F20 [358C]                  	dw	string_ptr_2		;AN000;offset of arg
 36897                                  extend_buf_seg:
 36898 00007F22 0000                    	dw	0			;AN000;segment of arg
 36899 00007F24 00                      	db	0			;AN000;first subst
 36900 00007F25 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36901 00007F26 80                      	db	128			;AN000;maximum width
 36902 00007F27 00                      	db	0			;AN000;minimum width
 36903 00007F28 20                      	db	blank ; 20h		;AN000;pad character
 36904                                  
 36905                                  ;  "Duplicate file name or file not found"
 36906                                  RENERR_PTR:
 36907 00007F29 EA03                    	dw	1002			;AN000;message number
 36908 00007F2B 00                      	db	no_subst ; 0		;AN000;number of subst
 36909                                  
 36910                                  ;  "Invalid path or file name"
 36911                                  BADCPMES_PTR:
 36912 00007F2C EB03                    	dw	1003			;AN000;message number
 36913 00007F2E 00                      	db	no_subst ; 0		;AN000;number of subst
 36914                                  
 36915                                  ;  "Insufficient disk space"
 36916                                  NOSPACE_PTR:
 36917 00007F2F EC03                    	dw	1004			;AN000;message number
 36918 00007F31 00                      	db	no_subst ; 0		;AN000;number of subst
 36919                                  
 36920                                  ;  "Out of environment space"
 36921                                  ENVERR_PTR:
 36922 00007F32 EF03                    	dw	1007			;AN000;message number
 36923 00007F34 00                      	db	no_subst ; 0		;AN000;number of subst
 36924                                  
 36925                                  ;  "File creation error"
 36926                                  FULLDIR_PTR:
 36927 00007F35 F003                    	dw	1008			;AN000;message number
 36928 00007F37 00                      	db	no_subst ; 0		;AN000;number of subst
 36929                                  
 36930                                  ;  "Batch file missing",13,10
 36931                                  BADBAT_PTR:
 36932 00007F38 F103                    	dw	1009			;AN000;message number
 36933 00007F3A 00                      	db	no_subst ; 0		;AN000;number of subst
 36934                                  
 36935                                  ;  "Insert disk with batch file",13,10
 36936                                  NEEDBAT_PTR:
 36937 00007F3B F203                    	dw	1010			;AN000;message number
 36938 00007F3D 00                      	db	no_subst ; 0		;AN000;number of subst
 36939                                  
 36940                                  ;  "Bad command or file name",13,10
 36941                                  BADNAM_PTR:
 36942 00007F3E F303                    	dw	1011			;AN000;message number
 36943 00007F40 00                      	db	no_subst ; 0		;AN000;number of subst
 36944                                  
 36945                                  ;  "Access denied",13,10
 36946                                  ACCDEN_PTR:
 36947 00007F41 F603                    	dw	1014			;AN000;message number
 36948 00007F43 00                      	db	no_subst ; 0		;AN000;number of subst
 36949                                  
 36950                                  ;  "File cannot be copied onto itself",13,10
 36951                                  OVERWR_PTR:
 36952 00007F44 F703                    	dw	1015			;AN000;message number
 36953 00007F46 00                      	db	no_subst ; 0		;AN000;number of subst
 36954                                  
 36955                                  ;  "Content of destination lost before copy",13,10
 36956                                  LOSTERR_PTR:
 36957 00007F47 F803                    	dw	1016			;AN000;message number
 36958 00007F49 00                      	db	no_subst ; 0		;AN000;number of subst
 36959                                  
 36960                                  ;  "Invalid filename or file not found",13,10
 36961                                  INORNOT_PTR:
 36962 00007F4A F903                    	dw	1017			;AN000;message number
 36963 00007F4C 00                      	db	no_subst		;AN000;number of subst
 36964                                  
 36965                                  ;  "%1 File(s) copied",13,10
 36966                                  copied_ptr:
 36967 00007F4D FA03                    	dw	1018			;AN000;message number
 36968 00007F4F 01                      	db	1			;AN000;number of subst
 36969 00007F50 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36970 00007F51 00                      	db	0			;AN000;reserved
 36971 00007F52 [378C]                  	dw	Copy_num		;AN000;offset of arg
 36972 00007F54 0000                    	dw	0			;AN000;segment of arg
 36973 00007F56 01                      	db	1			;AN000;first subst
 36974 00007F57 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36975                                  					;AN000;binary to decimal
 36976 00007F58 09                      	db	9			;AN000;maximum width
 36977 00007F59 09                      	db	9			;AN000;minimum width
 36978 00007F5A 20                      	db	blank ; 20h		;AN000;pad character
 36979                                  
 36980                                  ;  "%1 File(s) "
 36981                                  dirmes_ptr:
 36982 00007F5B FB03                    	dw	1019			;AN000;message number
 36983 00007F5D 01                      	db	1			;AN000;number of subst
 36984 00007F5E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36985 00007F5F 00                      	db	0			;AN000;reserved
 36986 00007F60 [3A8C]                  	dw	Dir_Num			;AN000;offset of arg
 36987 00007F62 0000                    	dw	0			;AN000;segment of arg
 36988 00007F64 01                      	db	1			;AN000;first subst
 36989 00007F65 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36990                                  					;AN000;binary to decimal
 36991 00007F66 09                      	db	9			;AN000;maximum width
 36992 00007F67 09                      	db	9			;AN000;minimum width
 36993 00007F68 20                      	db	blank ; 20h		;AN000;pad character
 36994                                  
 36995                                  ;  "%1 bytes free",13,10
 36996                                  bytmes_ptr:
 36997 00007F69 FC03                    	dw	1020			;AN000;message number
 36998 00007F6B 01                      	db	1			;AN000;number of subst
 36999 00007F6C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37000 00007F6D 00                      	db	0			;AN000;reserved
 37001 00007F6E [3C8C]                  	dw	Bytes_Free		;AN000;offset of arg
 37002 00007F70 0000                    	dw	0			;AN000;segment of arg
 37003 00007F72 01                      	db	1			;AN000;first subst
 37004 00007F73 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37005                                  					;AN000;long binary to decimal
 37006 00007F74 1C                      	db	28			;AN000;maximum width
 37007 00007F75 1C                      	db	28			;AN000;minimum width
 37008 00007F76 20                      	db	blank ; 20h		;AN000;pad character
 37009                                  
 37010                                  ;  "Invalid drive specification",13,10
 37011                                  baddrv_ptr:
 37012 00007F77 FD03                    	dw	1021			;AN000;message number
 37013 00007F79 00                      	db	no_subst ; 0		;AN000;number of subst
 37014                                  
 37015                                  ;  "Code page %1 not prepared for system",13,10
 37016                                  cp_not_set_ptr:
 37017 00007F7A FE03                    	dw	1022			;AN000;message number
 37018 00007F7C 01                      	db	1			;AN000;number of subst
 37019 00007F7D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37020 00007F7E 00                      	db	0			;AN000;reserved
 37021 00007F7F [2F8C]                  	dw	system_cpage		;AN000;offset of arg
 37022 00007F81 0000                    	dw	0			;AN000;segment of arg
 37023 00007F83 01                      	db	1			;AN000;first subst
 37024 00007F84 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37025                                  					;AN000;binary to decimal
 37026 00007F85 05                      	db	5			;AN000;maximum width
 37027 00007F86 01                      	db	1			;AN000;minimum width
 37028 00007F87 20                      	db	blank ; 20h		;AN000;pad character
 37029                                  
 37030                                  ;  "Code page %1 not prepared for all devices",13,10
 37031                                  cp_not_all_ptr:
 37032 00007F88 FF03                    	dw	1023			;AN000;message number
 37033 00007F8A 01                      	db	1			;AN000;number of subst
 37034 00007F8B 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37035 00007F8C 00                      	db	0			;AN000;reserved
 37036 00007F8D [2F8C]                  	dw	system_cpage		;AN000;offset of arg
 37037 00007F8F 0000                    	dw	0			;AN000;segment of arg
 37038 00007F91 01                      	db	1			;AN000;first subst
 37039 00007F92 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37040                                  					;AN000;binary to decimal
 37041 00007F93 05                      	db	5			;AN000;maximum width
 37042 00007F94 01                      	db	1			;AN000;minimum width
 37043 00007F95 20                      	db	blank ; 20h		;AN000;pad character
 37044                                  
 37045                                  ;  "Active code page: %1",13,10
 37046                                  cp_active_ptr:
 37047 00007F96 0004                    	dw	1024			;AN000;message number
 37048 00007F98 01                      	db	1			;AN000;number of subst
 37049 00007F99 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37050 00007F9A 00                      	db	0			;AN000;reserved
 37051 00007F9B [2F8C]                  	dw	system_cpage		;AN000;offset of arg
 37052 00007F9D 0000                    	dw	0			;AN000;segment of arg
 37053 00007F9F 01                      	db	1			;AN000;first subst
 37054 00007FA0 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37055                                  					;AN000;binary to decimal
 37056 00007FA1 05                      	db	5			;AN000;maximum width
 37057 00007FA2 01                      	db	1			;AN000;minimum width
 37058 00007FA3 20                      	db	blank ; 20h		;AN000;pad character
 37059                                  
 37060                                  ;  "NLSFUNC not installed",13,10
 37061                                  NLSFUNC_PTR:
 37062 00007FA4 0104                    	dw	1025			;AN000;message number
 37063 00007FA6 00                      	db	no_subst ; 0		;AN000;number of subst
 37064                                  
 37065                                  ;  "Invalid code page",13,10
 37066                                  INV_CODE_PAGE:
 37067 00007FA7 0204                    	dw	1026			;AN000;message number
 37068 00007FA9 00                      	db	no_subst ; 0		;AN000;number of subst
 37069                                  
 37070                                  ;  "Current drive is no longer valid"
 37071                                  BADCURDRV:
 37072 00007FAA 0304                    	dw	1027			;AN000;message number
 37073 00007FAC 00                      	db	no_subst ; 0		;AN000;number of subst
 37074                                  
 37075                                  ;  "Press any key to continue"
 37076                                  PAUSEMES_PTR:
 37077 00007FAD 0404                    	dw	1028			;AN000;message number
 37078 00007FAF 00                      	db	no_subst ; 0		;AN000;number of subst
 37079                                  
 37080                                  ;  "Label not found",13,10
 37081                                  BADLAB_PTR:
 37082 00007FB0 0504                    	dw	1029			;AN000;message number
 37083 00007FB2 00                      	db	no_subst ; 0		;AN000;number of subst
 37084                                  
 37085                                  ;  "Syntax error",13,10
 37086                                  SYNTMES_PTR:
 37087 00007FB3 0604                    	dw	1030			;AN000;message number
 37088 00007FB5 00                      	db	no_subst ; 0		;AN000;number of subst
 37089                                  
 37090                                  ;  "Invalid date",13,10
 37091                                  BADDAT_PTR:
 37092 00007FB6 0704                    	dw	1031			;AN000;message number
 37093 00007FB8 00                      	db	no_subst ; 0		;AN000;number of subst
 37094                                  
 37095                                  ;  "Current date is %1 %2",13,10
 37096                                  CurDat_Ptr:
 37097 00007FB9 0804                    	dw	1032			;AN000;message number
 37098 00007FBB 02                      	db	2			;AN000;number of subst
 37099 00007FBC 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37100 00007FBD 00                      	db	0			;AN000;reserved
 37101 00007FBE [1A93]                  	dw	Arg_Buf			;AN000;offset of arg
 37102 00007FC0 0000                    	dw	0			;AN000;segment of arg
 37103 00007FC2 01                      	db	1			;AN000;first subst
 37104 00007FC3 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37105 00007FC4 03                      	db	3			;AN000;maximum width
 37106 00007FC5 03                      	db	3			;AN000;minimum width
 37107 00007FC6 20                       	db	blank ; 20h		;AN000;pad character
 37108 00007FC7 0B                      	db	parm_block_size 	;AN000;size of sublist
 37109 00007FC8 00                      	db	0			;AN000;reserved
 37110                                  CurDat_yr:
 37111 00007FC9 0000                    	dw	0			;AN000;year
 37112                                  CurDat_mo_day:
 37113 00007FCB 0000                    	dw	0			;AN000;month,day
 37114 00007FCD 02                      	db	2			;AN000;second subst
 37115 00007FCE 34                      	db	34h ; DATE_MDY_4	;AN000;date
 37116 00007FCF 0A                      	db	10			;AN000;maximum width
 37117 00007FD0 0A                      	db	10			;AN000;minimum width
 37118 00007FD1 20                      	db	blank ; 20h		;AN000;pad character
 37119                                  
 37120                                  ;  "SunMonTueWedThuFriSat"
 37121                                  WeekTab:
 37122 00007FD2 0904                    	dw	1033			;AN000;message number
 37123 00007FD4 00                      	db	no_subst ; 0		;AN000;number of subst
 37124                                  
 37125                                  ;  "Enter new date (%1):"
 37126                                  
 37127                                  NewDat_Ptr:
 37128 00007FD5 0A04                    	dw	1034			;AN000;message number
 37129 00007FD7 01                      	db	1			;AN000;number of subst
 37130 00007FD8 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37131 00007FD9 00                      	db	0			;AN000;reserved
 37132                                  NewDat_Format:
 37133 00007FDA 0000                    	dw	0			;AN000;offset of replacement
 37134 00007FDC 0000                    	dw	0			;AN000;segment of arg
 37135 00007FDE 01                      	db	1			;AN000;first subst
 37136 00007FDF 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37137 00007FE0 08                      	db	8			;AN000;maximum width
 37138 00007FE1 08                      	db	8			;AN000;minimum width
 37139 00007FE2 20                      	db	blank ; 20h		;AN000;pad character
 37140                                  
 37141                                  ;  "Invalid time",13,10
 37142                                  
 37143                                  BadTim_Ptr:
 37144 00007FE3 0B04                    	dw	1035			;AN000;message number
 37145 00007FE5 00                      	db	no_subst ; 0		;AN000;number of subst
 37146                                  
 37147                                  ;  "Current time is %1",13,10
 37148                                  CurTim_Ptr:
 37149 00007FE6 0C04                    	dw	1036			;AN000;message number
 37150 00007FE8 01                      	db	1			;AN000;number of subst
 37151 00007FE9 0B                      	db	parm_block_size 	;AN000;size of sublist
 37152 00007FEA 00                      	db	0			;AN000;reserved
 37153                                  CurTim_hr_min:
 37154 00007FEB 0000                    	dw	0			;AN000;hours,minutes
 37155                                  CurTim_Sec_hn:
 37156 00007FED 0000                    	dw	0			;AN000;seconds,hundredths
 37157 00007FEF 01                      	db	1			;AN000;first subst
 37158 00007FF0 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 37159                                  					;AC059;time
 37160 00007FF1 0C                      	db	12			;AC059;maximum width
 37161 00007FF2 0C                      	db	12			;AC059;minimum width
 37162 00007FF3 20                      	db	blank ; 20h		;AN000;pad character
 37163                                  
 37164                                  ;  "Enter new time:"
 37165                                  NewTim_Ptr:
 37166 00007FF4 0D04                    	dw	1037			;AN000;message number
 37167 00007FF6 00                      	db	no_subst ; 0		;AN000;number of subst
 37168                                  
 37169                                  ;  ",    Delete (Y/N)?",13,10
 37170                                  Del_Y_N_Ptr:
 37171 00007FF7 0E04                    	dw	1038			;AN000;message number
 37172 00007FF9 00                      	db	no_subst ; 0		;AN000;number of subst
 37173                                  
 37174                                  ;  "All files in directory will be deleted!",13,10
 37175                                  ;  "Are you sure (Y/N)?",13,10
 37176                                  SureMes_Ptr:
 37177 00007FFA 0F04                    	dw	1039			;AN000;message number
 37178 00007FFC 00                      	db	no_subst ; 0		;AN000;number of subst
 37179                                  
 37180                                  ;  "Microsoft DOS Version %1.%2",13,10
 37181                                  VerMes_Ptr:
 37182 00007FFD 1004                    	dw	1040			;AN000;message number
 37183 00007FFF 02                      	db	2			;AN000;number of subst
 37184 00008000 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37185 00008001 00                      	db	0			;AN000;reserved
 37186 00008002 [408C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 37187 00008004 0000                    	dw	0			;AN000;segment of arg
 37188 00008006 01                      	db	1			;AN000;first subst
 37189 00008007 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37190                                  					;AN000;binary to decimal
 37191 00008008 01                      	db	1			;AN000;maximum width
 37192 00008009 01                      	db	1			;AN000;minimum width
 37193 0000800A 20                      	db	blank ; 20h		;AN000;pad character
 37194 0000800B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37195 0000800C 00                      	db	0			;AN000;reserved
 37196 0000800D [428C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 37197 0000800F 0000                    	dw	0			;AN000;segment of arg
 37198 00008011 02                      	db	2			;AN000;second subst
 37199 00008012 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 37200                                  					;AN000;binary to decimal
 37201 00008013 02                      	db	2			;AN000;maximum width
 37202 00008014 02                      	db	2			;AN000;minimum width
 37203 00008015 30                      	db	'0' ; 30h		;AN000;pad character
 37204                                  
 37205                                  ;  "Volume in drive %1 has no label",13,10
 37206                                  VolMes_Ptr_2:
 37207 00008016 1104                    	dw	1041			;AN000;message number
 37208 00008018 01                      	db	1			;AN000;number of subst
 37209 00008019 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37210 0000801A 00                      	db	0			;AN000;reserved
 37211 0000801B [468C]                  	dw	vol_drv			;AN000;offset of drive
 37212 0000801D 0000                    	dw	0			;AN000;segment of arg
 37213 0000801F 01                      	db	1			;AN000;first subst
 37214 00008020 00                      	db	0 ; Char_field_Char 	;AN000;character
 37215 00008021 80                      	db	128			;AN000;maximum width
 37216 00008022 01                      	db	1			;AN000;minimum width
 37217 00008023 20                      	db	blank ; 20h		;AN000;pad character
 37218                                  
 37219                                  ;  "Volume in drive %1 is %2",13,10
 37220                                  VolMes_Ptr:
 37221 00008024 1204                    	dw	1042			;AN000;message number
 37222 00008026 02                      	db	2			;AN000;number of subst
 37223 00008027 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37224 00008028 00                      	db	0			;AN000;reserved
 37225 00008029 [468C]                  	dw	vol_drv			;AN000;offset of drive
 37226 0000802B 0000                    	dw	0			;AN000;segment of arg
 37227 0000802D 01                      	db	1			;AN000;first subst
 37228 0000802E 00                      	db	00000000b		;AN000;character
 37229 0000802F 80                      	db	128			;AN000;maximum width
 37230 00008030 01                      	db	1			;AN000;minimum width
 37231 00008031 20                      	db	blank ; 20h		;AN000;pad character
 37232 00008032 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37233 00008033 00                      	db	0			;AN000;reserved
 37234 00008034 [FF8A]                  	dw	CHARBUF			;AN000;offset of string
 37235 00008036 0000                    	dw	0			;AN000;segment of arg
 37236 00008038 02                      	db	2			;AN000;second subst
 37237 00008039 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37238 0000803A 80                      	db	128			;AN000;maximum width
 37239 0000803B 01                      	db	1			;AN000;minimum width
 37240 0000803C 20                      	db	blank ; 20h		;AN000;pad character
 37241                                  
 37242                                  ;  "Volume Serial Number is %1-%2",13,10
 37243                                  VolSerMes_Ptr:
 37244 0000803D 1304                    	dw	1043			;AN000;message number
 37245 0000803F 02                      	db	2			;AN000;number of subst
 37246 00008040 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37247 00008041 00                      	db	0			;AN000;reserved
 37248 00008042 [A18D]                  	dw	vol_serial+2		;AN000;offset of serial
 37249 00008044 0000                    	dw	0			;AN000;segment of arg
 37250 00008046 01                      	db	1			;AN000;first subst
 37251 00008047 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 37252                                  					;AN000;binary to hex
 37253 00008048 04                      	db	4			;AN000;maximum width
 37254 00008049 04                      	db	4			;AN000;minimum width
 37255 0000804A 30                      	db	'0' ; 30h		;AN000;pad character
 37256 0000804B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37257 0000804C 00                      	db	0			;AN000;reserved
 37258 0000804D [9F8D]                  	dw	vol_serial		;AN000;offset of serial
 37259 0000804F 0000                    	dw	0			;AN000;segment of arg
 37260 00008051 02                      	db	2			;AN000;second subst
 37261 00008052 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 37262                                  					;AN000;binary to hex
 37263 00008053 04                      	db	4			;AN000;maximum width
 37264 00008054 04                      	db	4			;AN000;minimum width
 37265 00008055 30                      	db	'0' ; 30h		;AN000;pad character
 37266                                  
 37267                                  ;  "Invalid directory",13,10
 37268                                  badcd_ptr:
 37269 00008056 1404                    	dw	1044			;AN000;message number
 37270 00008058 00                      	db	no_subst ; 0		;AN000;number of subst
 37271                                  
 37272                                  ;  "Unable to create directory",13,10
 37273                                  badmkd_ptr:
 37274 00008059 1504                    	dw	1045			;AN000;message number
 37275 0000805B 00                      	db	no_subst ; 0		;AN000;number of subst
 37276                                  
 37277                                  ;  "Invalid path, not directory,",13,10
 37278                                  ;  "or directory not empty",13,10
 37279                                  badrmd_ptr:
 37280 0000805C 1604                    	dw	1046			;AN000;message number
 37281 0000805E 00                      	db	no_subst ; 0		;AN000;number of subst
 37282                                  
 37283                                  ;  "Must specify ON or OFF",13,10
 37284                                  bad_on_off_ptr:
 37285 0000805F 1704                    	dw	1047			;AN000;message number
 37286 00008061 00                      	db	no_subst ; 0		;AN000;number of subst
 37287                                  
 37288                                  ;  "Directory of %1",13,10
 37289                                  dirhead_ptr:
 37290 00008062 1804                    	dw	1048			;AN000;message number
 37291 00008064 01                      	db	1			;AN000;number of subst
 37292 00008065 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37293 00008066 00                      	db	0			;AN000;reserved
 37294 00008067 [CE8B]                  	dw	BWDBUF			;AN000;offset of arg
 37295 00008069 0000                    	dw	0			;AN000;segment of arg
 37296 0000806B 01                      	db	1			;AN000;first subst
 37297 0000806C 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37298 0000806D 80                      	db	128			;AN000;maximum width
 37299 0000806E 00                      	db	0			;AN000;minimum width
 37300 0000806F 20                      	db	blank ; 20h		;AN000;pad character
 37301                                  
 37302                                  ;  "No Path",13,10
 37303                                  NULLPATH_PTR:
 37304 00008070 1904                    	dw	1049			;AN000;message number
 37305 00008072 00                      	db	no_subst ; 0		;AN000;number of subst
 37306                                  
 37307                                  ;  "Invalid drive in search path",13,10
 37308                                  BADPMES_PTR:
 37309 00008073 1A04                    	dw	1050			;AN000;message number
 37310 00008075 00                      	db	no_subst ; 0		;AN000;number of subst
 37311                                  
 37312                                  ;  "Invalid device",13,10
 37313                                  BADDEV_PTR:
 37314 00008076 1B04                    	dw	1051			;AN000;message number
 37315 00008078 00                      	db	no_subst ; 0		;AN000;number of subst
 37316                                  
 37317                                  ;  "FOR cannot be nested",13,10
 37318                                  FORNESTMES_PTR:
 37319 00008079 1C04                    	dw	1052			;AN000;message number
 37320 0000807B 00                      	db	no_subst ; 0		;AN000;number of subst
 37321                                  
 37322                                  ;  "Intermediate file error during pipe",13,10
 37323                                  PIPEEMES_PTR:
 37324 0000807C 1D04                    	dw	1053			;AN000;message number
 37325 0000807E 00                      	db	no_subst ; 0		;AN000;number of subst
 37326                                  
 37327                                  ;  "Cannot do binary reads from a device",13,10
 37328                                  INBDEV_PTR:
 37329 0000807F 1E04                    	dw	1054			;AN000;message number
 37330 00008081 00                      	db	no_subst ; 0		;AN000;number of subst
 37331                                  
 37332                                  ;  "BREAK is %1",13,10
 37333                                  CtrlcMes_Ptr:
 37334 00008082 1F04                    	dw	1055			;AN000;message number
 37335 00008084 01                      	db	1			;AN000;number of subst
 37336 00008085 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37337 00008086 00                      	db	0			;AN000;reserved
 37338 00008087 0000                    	dw	0			;AN000;offset of on/off (new)
 37339 00008089 0000                    	dw	0			;AN000;segment of arg
 37340 0000808B 01                      	db	1			;AN000;first subst
 37341 0000808C 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37342 0000808D 80                      	db	128			;AN000;maximum width
 37343 0000808E 01                      	db	1			;AN000;minimum width
 37344 0000808F 20                      	db	blank ; 20h		;AN000;pad character
 37345                                  
 37346                                  ;  "VERIFY is %1",13,10
 37347                                  VeriMes_Ptr:
 37348 00008090 2004                    	dw	1056			;AN000;message number
 37349 00008092 01                      	db	1			;AN000;number of subst
 37350 00008093 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37351 00008094 00                      	db	0			;AN000;reserved
 37352 00008095 0000                    	dw	0			;AN000;offset of on/off (new)
 37353 00008097 0000                    	dw	0			;AN000;segment of arg
 37354 00008099 01                      	db	1			;AN000;first subst
 37355 0000809A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37356 0000809B 80                      	db	128			;AN000;maximum width
 37357 0000809C 01                      	db	1			;AN000;minimum width
 37358 0000809D 20                      	db	blank ; 20h		;AN000;pad character
 37359                                  
 37360                                  ;  "ECHO is %1",13,10
 37361                                  EchoMes_Ptr:
 37362 0000809E 2104                    	dw	1057			;AN000;message number
 37363 000080A0 01                      	db	1			;AN000;number of subst
 37364 000080A1 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37365 000080A2 00                      	db	0			;AN000;reserved
 37366 000080A3 0000                    	dw	0			;AN000;offset of on/off (new)
 37367 000080A5 0000                    	dw	0			;AN000;segment of arg
 37368 000080A7 01                      	db	1			;AN000;first subst
 37369 000080A8 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37370 000080A9 80                      	db	128			;AN000;maximum width
 37371 000080AA 01                      	db	1			;AN000;minimum width
 37372 000080AB 20                      	db	blank ; 20h		;AN000;pad character
 37373                                  
 37374                                  ;  "off"
 37375                                  OFFMES_PTR:
 37376 000080AC 2304                    	dw	1059			;AN000;message number
 37377 000080AE 00                      	db	no_subst		;AN000;number of subst
 37378                                  
 37379                                  ;  "on"
 37380                                  ONMES_PTR:
 37381 000080AF 2404                    	dw	1060			;AN000;message number
 37382 000080B1 00                      	db	no_subst ; 0		;AN000;number of subst
 37383                                  
 37384                                  ;  "Error writing to device",13,10
 37385                                  DEVWMES_PTR:
 37386 000080B2 2504                    	dw	1061			;AN000;message number
 37387 000080B4 00                      	db	no_subst ; 0		;AN000;number of subst
 37388                                  
 37389                                  ;  "Invalid path",13,10
 37390                                  INVAL_PATH_PTR:
 37391 000080B5 2604                    	dw	1062			;AN000;message number
 37392 000080B7 00                      	db	no_subst ; 0		;AN000;number of subst
 37393                                  
 37394                                  ;  unformatted string output
 37395                                  arg_buf_ptr:
 37396 000080B8 2704                    	dw	1063			;AN000;message number
 37397 000080BA 01                      	db	1			;AN000;number of subst
 37398 000080BB 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37399 000080BC 00                      	db	0			;AN000;reserved
 37400 000080BD [1A93]                  	dw	Arg_Buf 		;AN000;offset of arg
 37401 000080BF 0000                    	dw	0			;AN000;segment of arg
 37402 000080C1 01                      	db	1			;AN000;first subst
 37403 000080C2 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37404 000080C3 80                      	db	128			;AN000;maximum width
 37405 000080C4 00                      	db	0			;AN000;minimum width
 37406 000080C5 20                      	db	blank ; 20h		;AN000;pad character
 37407                                  
 37408                                  ;  file name output
 37409                                  file_name_ptr:
 37410 000080C6 2804                    	dw	1064			;AN000;message number
 37411 000080C8 01                      	db	1			;AN000;number of subst
 37412 000080C9 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37413 000080CA 00                      	db	0			;AN000;reserved
 37414 000080CB [B48C]                  	dw	SrcBuf			;AN000;offset of arg
 37415 000080CD 0000                    	dw	0			;AN000;segment of arg
 37416 000080CF 01                      	db	1			;AN000;first subst
 37417 000080D0 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37418 000080D1 80                      	db	128			;AN000;maximum width
 37419 000080D2 00                      	db	0			;AN000;minimum width
 37420 000080D3 20                      	db	blank ; 20h		;AN000;pad character
 37421                                  
 37422                                  ;  file size output for dir
 37423                                  disp_file_size_ptr:
 37424 000080D4 2904                    	dw	1065			;AN000;message number
 37425 000080D6 01                      	db	1			;AN000;number of subst
 37426 000080D7 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37427 000080D8 00                      	db	0			;AN000;reserved
 37428 000080D9 [318C]                  	dw	File_Size_Low		;AN000;offset of arg
 37429 000080DB 0000                    	dw	0			;AN000;segment of arg
 37430 000080DD 01                      	db	1			;AN000;first subst
 37431 000080DE B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37432                                  					;AN000;long binary to decimal
 37433 000080DF 0A                      	db	10			;AN000;maximum width
 37434 000080E0 0A                      	db	10			;AN000;minimum width
 37435 000080E1 20                      	db	blank ; 20h		;AN000;pad character
 37436                                  
 37437                                  ;  unformatted string output
 37438                                  ; %s
 37439                                  string_buf_ptr:
 37440 000080E2 2A04                    	dw	1066			;AN000;message number
 37441 000080E4 01                      	db	1			;AN000;number of subst
 37442 000080E5 0B                      	db	parm_block_size 	;AN000;size of sublist
 37443 000080E6 00                      	db	0			;AN000;reserved
 37444 000080E7 [358C]                  	dw	string_ptr_2		;AN000;offset of arg
 37445 000080E9 0000                    	dw	0			;AN000;segment of arg
 37446 000080EB 01                      	db	1			;AN000;first subst
 37447 000080EC 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37448 000080ED 80                      	db	128			;AN000;maximum width
 37449 000080EE 00                      	db	0			;AN000;minimum width
 37450 000080EF 20                      	db	blank ; 20h		;AN000;pad character
 37451 000080F0 00                      	db	0			;AN000;
 37452                                  
 37453                                  ;  tab character
 37454                                  tab_ptr:
 37455 000080F1 2B04                    	dw	1067			;AN000;message number
 37456 000080F3 00                      	db	no_subst ; 0		;AN000;number of subst
 37457                                  
 37458                                  ;  " <DIR>   "
 37459                                  dmes_ptr:
 37460 000080F4 2C04                    	dw	1068			;AN000;message number
 37461 000080F6 00                      	db	no_subst ; 0		;AN000;number of subst
 37462                                  
 37463                                  ;  destructive back space
 37464                                  dback_ptr:
 37465 000080F7 2D04                    	dw	1069			;AN000;message number
 37466 000080F9 00                      	db	no_subst ; 0		;AN000;number of subst
 37467                                  
 37468                                  ;  carriage return / line feed
 37469                                  acrlf_ptr:
 37470 000080FA 2E04                    	dw	1070			;AN000;message number
 37471 000080FC 00                      	db	no_subst ; 0		;AN000;number of subst
 37472                                  
 37473                                  ;  "mm-dd-yy"
 37474                                  usadat_ptr:
 37475 000080FD 3004                    	dw	1072			;AN000;message number
 37476 000080FF 00                      	db	no_subst ; 0		;AN000;number of subst
 37477                                  
 37478                                  ;  "dd-mm-yy"
 37479                                  eurdat_ptr:
 37480 00008100 3104                    	dw	1073			;AN000;message number
 37481 00008102 00                      	db	no_subst ; 0		;AN000;number of subst
 37482                                  
 37483                                  ;  "yy-mm-dd"
 37484                                  japdat_ptr:
 37485 00008103 3204                    	dw	1074			;AN000;message number
 37486 00008105 00                      	db	no_subst ; 0		;AN000;number of subst
 37487                                  
 37488                                  ;  date string for prompt
 37489                                  promptdat_ptr:
 37490 00008106 3304                    	dw	1075			;AN000;message number
 37491 00008108 02                      	db	2			;AN000;number of subst
 37492 00008109 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37493 0000810A 00                      	db	0			;AN000;reserved
 37494 0000810B [1A93]                  	dw	Arg_Buf			;AN000;offset of arg
 37495 0000810D 0000                    	dw	0			;AN000;segment of arg
 37496 0000810F 01                      	db	1			;AN000;first subst
 37497 00008110 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37498 00008111 03                      	db	3			;AN000;maximum width
 37499 00008112 03                      	db	3			;AN000;minimum width
 37500 00008113 20                       	db	blank ; 20h		;AN000;pad character
 37501 00008114 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37502 00008115 00                      	db	0			;AN000;reserved
 37503                                  promptDat_yr:
 37504 00008116 0000                    	dw	0			;AN000;year
 37505                                  promptDat_moday:
 37506 00008118 0000                    	dw	0			;AN000;month,day
 37507 0000811A 02                      	db	2			;AN000;second subst
 37508 0000811B 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37509 0000811C 0A                      	db	10			;AN000;maximum width
 37510 0000811D 08                      	db	8			;AN000;minimum width
 37511 0000811E 20                      	db	blank ; 20h		;AN000;pad character
 37512                                  
 37513                                  ;  Time for prompt
 37514                                  promtim_ptr:
 37515 0000811F 3404                    	dw	1076			;AN000;message number
 37516 00008121 01                      	db	1			;AN000;number of subst
 37517 00008122 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37518 00008123 00                      	db	0			;AN000;reserved
 37519                                  PromTim_hr_min:
 37520 00008124 0000                    	dw	0			;AN000;hours,minutes
 37521                                  PromTim_Sec_hn:
 37522 00008126 0000                    	dw	0			;AN000;seconds,hundredths
 37523 00008128 01                      	db	1			;AN000;first subst
 37524 00008129 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37525                                  					;AC013;time
 37526 0000812A 0B                      	db	11			;AN000;maximum width
 37527 0000812B 0B                      	db	11			;AC013;minimum width
 37528 0000812C 20                      	db	blank ; 20h		;AN000;pad character
 37529                                  
 37530                                  ;  Date and time for DIR
 37531                                  dirdattim_ptr:
 37532 0000812D 3504                    	dw	1077			;AN000;message number
 37533 0000812F 02                      	db	2			;AN000;number of subst
 37534 00008130 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37535 00008131 00                      	db	0			;AN000;reserved
 37536                                  DirDat_Yr:
 37537 00008132 0000                    	dw	0			;AN000;year
 37538                                  DirDat_Mo_Day:
 37539 00008134 0000                    	dw	0			;AN000;month,day
 37540 00008136 01                      	db	1			;AN000;first subst
 37541 00008137 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37542                                  					;AN000;date
 37543 00008138 0A                      	db	10			;AN000;maximum width
 37544 00008139 08                      	db	8			;AN000;minimum width
 37545 0000813A 20                      	db	blank ; 20h		;AN000;pad character
 37546 0000813B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37547 0000813C 00                      	db	0			;AN000;reserved
 37548                                  DirTim_Hr_Min:
 37549 0000813D 0000                    	dw	0			;AN000;hours,minutes
 37550                                  DirTim_Sec_hn:
 37551 0000813F 0000                    	dw	0			;AN000;seconds,hundredths
 37552 00008141 02                      	db	2			;AN000;second subst
 37553 00008142 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37554                                  					;AN000;time
 37555 00008143 06                      	db	6			;AN000;maximum width
 37556 00008144 06                      	db	6			;AN000;minimum width
 37557 00008145 20                      	db	blank ; 20h		;AN000;pad character
 37558                                  
 37559                                  ;  "Directory already exists"
 37560                                  MD_EXISTS_PTR:
 37561 00008146 3604                    	dw	1078			;AN000;message number
 37562 00008148 00                      	db	no_subst		;AN000;number of subst
 37563                                  
 37564                                  ;  "%1 bytes",13,10
 37565                                  bytes_ptr:
 37566 00008149 3704                    	dw	1079			; message number
 37567 0000814B 01                      	db	1			; number of subst
 37568 0000814C 0B                              db	parm_block_size ; 11	; size of sublist
 37569 0000814D 00                              db	0			; reserved
 37570 0000814E [F38A]                          dw	FileSiz			; offset of arg
 37571 00008150 0000                            dw	0			; segment of arg
 37572 00008152 01                              db	1			; first subst
 37573 00008153 B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37574                                  					; long binary to decimal
 37575 00008154 0A                              db	10			; maximum width
 37576 00008155 0A                              db	10			; minimum width
 37577 00008156 20                              db	blank ; 20h		; pad character
 37578                                  
 37579                                  ;  "Total:",13,10
 37580                                  total_ptr:
 37581 00008157 3804                    	dw	1080			; message number
 37582 00008159 00                      	db	no_subst ; 0		; number of subst
 37583                                  
 37584                                  ;  "Error parsing environment variable:",13,10
 37585                                  errparsenv_ptr:
 37586 0000815A 3904                    	dw	1081			; message number
 37587 0000815C 00                      	db	no_subst ; 0		; number of subst
 37588                                  
 37589                                  ;  "(continuing %1)",13,10
 37590                                  dircont_ptr:
 37591 0000815D 3C04                    	dw	1084			;AN000;message number
 37592 0000815F 01                      	db	1			;AN000;number of subst
 37593 00008160 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37594 00008161 00                      	db	0			;AN000;reserved
 37595 00008162 [CE8B]                  	dw	BWDBUF			;AN000;offset of arg
 37596 00008164 0000                    	dw	0			;AN000;segment of arg
 37597 00008166 01                      	db	1			;AN000;first subst
 37598 00008167 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37599 00008168 80                      	db	128			;AN000;maximum width
 37600 00008169 00                      	db	0			;AN000;minimum width
 37601 0000816A 20                      	db	blank ; 20h		;AN000;pad character
 37602                                  
 37603                                  ;  "Revision %1",CR,LF
 37604                                  dosrev_ptr:
 37605 0000816B 4204                    	dw	1090
 37606 0000816D 01                      	db	1			; one substitution
 37607 0000816E 0B                      	db	parm_block_size ; 11
 37608 0000816F 00                      	db	0
 37609 00008170 [448C]                  	dw	One_Char_Val		; ptr to char
 37610 00008172 0000                    	dw	0			; segment addr?
 37611 00008174 01                      	db	1			; 1st substitution
 37612 00008175 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37613 00008176 01                      	db	1			; max width
 37614 00008177 01                      	db	1			; min width
 37615 00008178 20                      	db	blank ; 20h		; pad char
 37616                                  
 37617                                  ;  "DOS is in ROM"
 37618                                  DosRom_Ptr:
 37619 00008179 4304                    	dw	1091
 37620 0000817B 00                      	db	no_subst ; 0		
 37621                                  
 37622                                  ;  "DOS is in HMA"
 37623                                  DosHma_Ptr:
 37624 0000817C 4404                    	dw	1092
 37625 0000817E 00                      	db	no_subst ; 0		
 37626                                  
 37627                                  ;  "DOS is in low memory"
 37628                                  DosLow_Ptr:
 37629 0000817F 4504                    	dw	1093
 37630 00008181 00                      	db	no_subst ; 0		
 37631                                  
 37632                                  ;  "Cannot Loadhigh batch file" ;M016
 37633                                  NoExecBat_Ptr:
 37634 00008182 4604                    	dw	1094			; M016
 37635 00008184 00                      	db	no_subst ; 0		; M016
 37636                                  
 37637                                  ;  "LoadHigh: Invalid filename" ; M016
 37638                                  LhInvFil_Ptr:
 37639 00008185 4704                    	dw	1095			; M016
 37640 00008187 00                      	db	no_subst ; 0		; M016
 37641                                  
 37642                                  ;  "Could not open specified country information file" ; M045
 37643                                  NoCntry_Ptr:
 37644 00008188 4804                    	dw	1096			; M045
 37645 0000818A 00                      	db	no_subst ; 0		; M045
 37646                                  
 37647                                  ; 15/04/2023
 37648                                  ; MSDOS 6.0 COMMAND.COM only !
 37649                                  %if 0
 37650                                  
 37651                                  ;* The next four errors emulate those reported by the normal parse
 37652                                  ;  mechanism, with a little more accurate wording; that parser has been
 37653                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37654                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37655                                  ;  parser, so they've been added here.
 37656                                  
 37657                                  ;  "LoadHigh: Invalid argument"
 37658                                  LhInvArg_Ptr:
 37659                                  	dw	1097
 37660                                  	db	no_subst ; 0		
 37661                                  
 37662                                  ;  "Required parameter missing"
 37663                                  ReqParmMiss:
 37664                                  	dw	1098
 37665                                  	db	no_subst ; 0		
 37666                                  
 37667                                  ;  "Unrecognized switch"
 37668                                  LhInvSwt_Ptr:
 37669                                  	dw	1099
 37670                                  	db	no_subst ; 0		
 37671                                  
 37672                                  ;  "A bad UMB number has been specified"
 37673                                  LhBadUMB_Ptr:
 37674                                  	dw	1100
 37675                                  	db	no_subst ; 0
 37676                                  %endif		
 37677                                  
 37678                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37679                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37680                                  ; ---------------------------------------------------------------------------
 37681                                  
 37682                                  PATH_TEXT:
 37683 0000818B 504154483D              	db	"PATH="
 37684                                  PROMPT_TEXT:
 37685 00008190 50524F4D50543D          	db	"PROMPT="
 37686                                  COMSPECSTR:
 37687 00008197 434F4D535045433D        	db	"COMSPEC="
 37688                                  DirEnvVar:
 37689 0000819F 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37690                                  
 37691                                  ; 15/04/2023
 37692                                  %if 0
 37693                                  
 37694                                  ;============================================================================
 37695                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37696                                  ;============================================================================
 37697                                  ; 30/09/2018 - Retro DOS v3.0
 37698                                  
 37699                                  ; TITLE	COMMAND Transient Initialized DATA
 37700                                  
 37701                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37702                                  ;initial values at the beginning of each command cycle. It is
 37703                                  ;included in the transient checksum area. If values in TRANDATA
 37704                                  ;change, the transient will be reloaded for the next command cycle.
 37705                                  
 37706                                  align 16
 37707                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37708                                  
 37709                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37710                                  _3740h:		db '%S',0
 37711                                  ARG_BUF_PTR:	dw _3740h
 37712                                  		dw _3747h
 37713                                  _3747h:		dw ARG_BUF ; _43E8h
 37714                                  _3749h:		db '%S ',0
 37715                                  STRINGBUF1PTR:	dw _3749h
 37716                                  		dw STRING_PTR_1 ; _4468h
 37717                                  _3751h:		db '%9ld',0
 37718                                  FSIZEMESPTR:	dw _3751h
 37719                                  		dw FILESIZE_L ; _446Ah
 37720                                  		dw FILESIZE_H ; _446Ch
 37721                                  _375Ch:		db '%S',0
 37722                                  STRINGBUF2PTR:	dw _375Ch
 37723                                  		dw STRING_PTR_2 ; _446Eh
 37724                                  _3763h:		db 9,0
 37725                                  TABPTR:		dw _3763h
 37726                                  _3767h:		db 0Dh,0Ah
 37727                                  		db 'Batch file missing',0Dh,0Ah,0
 37728                                  BADPATHPTR:	dw _3767h
 37729                                  _3780h:		db 0Dh,0Ah
 37730                                  		db 'Insert disk with batch file',0Dh,0Ah
 37731                                  		db 'and press any key when ready',0Dh,0Ah,0
 37732                                  INSERTDSKPTR:	dw _3780h
 37733                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37734                                  BADNAMPTR:	dw _37C0h
 37735                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37736                                  RENERRPTR:	dw _37DDh
 37737                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37738                                  FNOTFOUNDPTR:	dw _3807h
 37739                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37740                                  PNOTFOUNDPTR:	dw _381Ah
 37741                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37742                                  ACCDENPTR:	dw _382Dh
 37743                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37744                                  NOSPACEPTR:	dw _383Fh
 37745                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37746                                  ENVERRPTR:	dw _385Bh
 37747                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37748                                  FULDIRPTR:	dw 3878h
 37749                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37750                                  OVERWRPTR:	dw _3890h
 37751                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37752                                  LOSTERRPTR:	dw _38B6h
 37753                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37754                                  INORNOTPTR:	dw _38E2h
 37755                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37756                                  COPIEDPTR:	dw _3909h
 37757                                  		dw COPY_NUM ; _4470h
 37758                                  _3922h:		db '%9d File(s) ',0
 37759                                  DIRMESPTR:	dw _3922h
 37760                                  		dw DIR_NUM  ; _4477h
 37761                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37762                                  BYTEMESPTR:	dw _3933h
 37763                                  		dw BYTES_FREE   ; _4479h
 37764                                  		dw BYTES_FREE+2 ; _447Bh
 37765                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37766                                  BADDRVPTR:	dw _394Bh
 37767                                  _396Bh:		db 0Dh,0Ah
 37768                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37769                                  CPNOTSETPTR:	dw _396Bh
 37770                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37771                                  _3999h:		db 0Dh,0Ah
 37772                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37773                                  CPNOTALLPTR:	dw _3999h
 37774                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37775                                  _39CCh:		db 0Dh,0Ah
 37776                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37777                                  CPACTIVEPTR:	dw _39CCh
 37778                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37779                                  _39EAh:		db 'Current drive is no longer valid',0
 37780                                  BADCURDRVPTR:	dw _39EAh
 37781                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37782                                  PAUSEMESPTR:	dw _3A0Dh
 37783                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37784                                  BADPARMPTR:	dw _3A2Eh
 37785                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37786                                  _3A59h:		db 0Dh,0Ah
 37787                                  		db 'Invalid date',0
 37788                                  BADDATPTR:	dw _3A59h
 37789                                  _3A6Ah:		db 'Current date is ',0
 37790                                  CURDATPTR:	dw _3A6Ah
 37791                                  _3A7Dh:		db 0Dh,0Ah
 37792                                  		db 'Enter new date ',0
 37793                                  NEWDATPTR:	dw _3A7Dh
 37794                                  _3A91h:		db '(mm-dd-yy): ',0
 37795                                  USADATPTR:	dw _3A91h
 37796                                  _3AA0h:		db '(dd-mm-yy): ',0
 37797                                  EURDATPTR:	dw _3AA0h
 37798                                  _3AAFh:		db '(yy-mm-dd): ',0
 37799                                  JAPDATPTR:	dw _3AAFh
 37800                                  _3ABEh:		db 0Dh,0Ah
 37801                                  		db 'Invalid time ',0
 37802                                  BADTIMPTR:	dw _3ABEh
 37803                                  _3AD0h:		db 'Current time is ',0
 37804                                  CURTIMPTR:	dw _3AD0h
 37805                                  _3AE3h:		db 0Dh,0Ah
 37806                                  		db 'Enter new time: ',0
 37807                                  NEWTIMPTR:	dw _3AE3h
 37808                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37809                                  SUREMESPTR:	dw _3AF8h
 37810                                  _3B0Eh:		db ' <DIR>   ',0
 37811                                  DMESPTR:	dw _3B0Eh
 37812                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37813                                  VERMESPTR:	dw _3B1Ah
 37814                                  		dw MAJOR_VER_NUM ; _447Dh
 37815                                  		dw MINOR_VER_NUM ; _447Fh
 37816                                  _3B4Dh:		db '%C',0
 37817                                  ONECHRVALPTR:	dw _3B4Dh
 37818                                  		dw ONE_CHAR_VAL	; _4481h
 37819                                  _3B54h:		db ' Volume in drive %c %s',0
 37820                                  VOLMESPTR:	dw _3B54h
 37821                                  		dw VOL_DRV ; _4484h
 37822                                  		dw VOLNAME_ADDR ; _4482h
 37823                                  IS:		db 'is ',0
 37824                                  NOVOL:		db 'has no label',0
 37825                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37826                                  BADCDPTR:	dw _3B82h
 37827                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37828                                  BADMKDPTR:	dw _3B98h
 37829                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37830                                  		db 'or directory not empty',0Dh,0Ah,0
 37831                                  BADRMDPTR:	dw _3BB7h
 37832                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37833                                  BADONOFFPTR:	dw _3BF0h
 37834                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37835                                  DIRHEADPTR:	dw _3C0Bh
 37836                                  		dw VOL_DIR ; _4485h
 37837                                  _3C23h:		db 'No Path',0
 37838                                  NULLPATHPTR:	dw _3C23h
 37839                                  PATH_TEXT:	db 'PATH='
 37840                                  PROMPT_TEXT:	db 'PROMPT='
 37841                                  COMSPEC_TEXT:	db 'COMSPEC='
 37842                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37843                                  BADPMESPTR:	dw _3C41h
 37844                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37845                                  BADDEVPTR:	dw _3C62h
 37846                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37847                                  BADLABPTR:	dw _3C75h
 37848                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37849                                  SYNTMESPTR:	dw _3C89h
 37850                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37851                                  FORNESTMESTR:	dw _3C9Ah
 37852                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37853                                  INSFMEMMESPTR:	dw _3CB4h
 37854                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37855                                  PIPEEMESPTR:	dw _3CCCh
 37856                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37857                                  INBDEVPTR:	dw _3CF4h
 37858                                  _3D1Dh:		db 'BREAK is ',0
 37859                                  CTRLMESPTR:	dw _3D1Dh
 37860                                  _3D29h:		db 'VERIFY is ',0
 37861                                  VERIMESPTR:	dw _3D29h
 37862                                  _3D36h:		db 'ECHO is ',0
 37863                                  ECHOMESPTR:	dw _3D36h
 37864                                  _3D41h:		db 'off',0Dh,0Ah,0
 37865                                  OFFMESPTR:	dw _3D41h
 37866                                  _3D49h:		db 'on',0Dh,0Ah,0
 37867                                  ONMESPTR:	dw _3D49h
 37868                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 37869                                  BADCPMESPTR:	dw _3D50h
 37870                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 37871                                  BADARGSPTR:	dw _3D6Eh
 37872                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 37873                                  DEVWMESPTR:	dw _3D8Fh
 37874                                  _3DABh:		db 0Dh,0Ah,0
 37875                                  ACRLFPTR:	dw _3DABh
 37876                                  _3DB0h:		db 8
 37877                                  		db 20h
 37878                                  		db 8
 37879                                  		db 0
 37880                                  DBACKPTR:	dw _3DB0h
 37881                                  small_y:	db 'y'
 37882                                  small_n:	db 'n'
 37883                                  CAPITAL_Y:	db 'Y'
 37884                                  CAPITAL_N:	db 'N'
 37885                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 37886                                  PROMPT_TABLE:
 37887                                  		db 'B' ; 42h
 37888                                  		dw PRINT_B
 37889                                  		db 'D' ; 44h
 37890                                  		dw PRINT_DATE
 37891                                  		db 'E' ; 45h
 37892                                  		dw PRINT_ESC
 37893                                  		db 'G' ; 47h
 37894                                  		dw PRINT_G
 37895                                  		db 'H' ; 48h
 37896                                  		dw PRINT_BACK
 37897                                  		db 'L' ; 4Ch
 37898                                  		dw PRINT_L
 37899                                  		db 'N' ; 4Eh
 37900                                  		dw PRINT_DRIVE
 37901                                  		db 'P' ; 50h
 37902                                  		dw BUILD_DIR_FOR_PROMPT
 37903                                  		db 'Q' ; 51h
 37904                                  		dw PRINT_EQ
 37905                                  		db 'T' ; 54h
 37906                                  		dw PRINT_TIME
 37907                                  		db 'V' ; 56h
 37908                                  		dw PRINT_VERSION
 37909                                  		db '_' ; 5Fh
 37910                                  		dw CRLF2
 37911                                  		db '$' ; 24h
 37912                                  		dw PRINT_CHAR
 37913                                  		db 0
 37914                                  
 37915                                  		; Table of IF conditionals
 37916                                  IFTAB:
 37917                                  		db 3	; First byte is count
 37918                                  		db 'NOT'
 37919                                  		dw IFNOT
 37920                                  		db 10
 37921                                  		db 'ERRORLEVEL'
 37922                                  		dw IFERLEV
 37923                                  		db 5
 37924                                  		db 'EXIST'
 37925                                  		dw IFEXISTS
 37926                                  		db 0
 37927                                  
 37928                                  		; Table for internal command names
 37929                                  
 37930                                  COMTAB:		db 3
 37931                                  		db 'DIR'
 37932                                  		db 3
 37933                                  		dw CATALOG
 37934                                  		db 4
 37935                                  		db 'CALL'
 37936                                  		db 2
 37937                                  		dw _$CALL
 37938                                  		db 4
 37939                                  		db 'CHCP'
 37940                                  		db 2
 37941                                  		dw CHCP
 37942                                  		db 6
 37943                                  		db 'RENAME'
 37944                                  		db 1
 37945                                  		dw CRENAME
 37946                                  		db 3
 37947                                  		db 'REN'
 37948                                  		db 1
 37949                                  		dw CRENAME
 37950                                  		db 5
 37951                                  		db 'ERASE'
 37952                                  		db 1
 37953                                  		dw ERASE
 37954                                  		db 3
 37955                                  		db 'DEL'
 37956                                  		db 1
 37957                                  		dw ERASE
 37958                                  		db 4
 37959                                  		db 'TYPE'
 37960                                  		db 1
 37961                                  		dw TYPEFIL
 37962                                  		db 3
 37963                                  		db 'REM'
 37964                                  		db 2
 37965                                  		dw TCOMMAND
 37966                                  		db 4
 37967                                  		db 'COPY'
 37968                                  		db 3
 37969                                  		dw COPY
 37970                                  		db 5
 37971                                  		db 'PAUSE'
 37972                                  		db 2
 37973                                  		dw PAUSE
 37974                                  		db 4
 37975                                  		db 'DATE'
 37976                                  		db 2
 37977                                  		dw DATE
 37978                                  		db 4
 37979                                  		db 'TIME'
 37980                                  		db 0
 37981                                  		dw CTIME
 37982                                  		db 3
 37983                                  		db 'VER'
 37984                                  		db 0
 37985                                  		dw VERSION
 37986                                  		db 3
 37987                                  		db 'VOL'
 37988                                  		db 1
 37989                                  		dw VOLUME
 37990                                  		db 2
 37991                                  		db 'CD'
 37992                                  		db 1
 37993                                  		dw _$CHDIR
 37994                                  		db 5
 37995                                  		db 'CHDIR'
 37996                                  		db 1
 37997                                  		dw _$CHDIR
 37998                                  		db 2
 37999                                  		db 'MD'
 38000                                  		db 1
 38001                                  		dw _$MKDIR
 38002                                  		db 5
 38003                                  		db 'MKDIR'
 38004                                  		db 1
 38005                                  		dw _$MKDIR
 38006                                  		db 2
 38007                                  		db 'RD'
 38008                                  		db 1
 38009                                  		dw _$RMDIR
 38010                                  		db 5
 38011                                  		db 'RMDIR'
 38012                                  		db 1
 38013                                  		dw _$RMDIR
 38014                                  		db 5
 38015                                  		db 'BREAK'
 38016                                  		db 0
 38017                                  		dw CNTRLC
 38018                                  		db 6
 38019                                  		db 'VERIFY'
 38020                                  		db 0
 38021                                  		dw VERIFY
 38022                                  		db 3
 38023                                  		db 'SET'
 38024                                  		db 2
 38025                                  		dw ADD_NAME_TO_ENVIRONMENT
 38026                                  		db 6
 38027                                  		db 'PROMPT'
 38028                                  		db 2
 38029                                  		dw ADD_PROMPT
 38030                                  		db 4
 38031                                  		db 'PATH'
 38032                                  		db 2
 38033                                  		dw PATH
 38034                                  		db 4
 38035                                  		db 'EXIT'
 38036                                  		db 0
 38037                                  		dw _$EXIT
 38038                                  		db 4
 38039                                  		db 'CTTY'
 38040                                  		db 3
 38041                                  		dw CTTY
 38042                                  		db 4
 38043                                  		db 'ECHO'
 38044                                  		db 2
 38045                                  		dw _ECHO
 38046                                  		db 4
 38047                                  		db 'GOTO'
 38048                                  		db 2
 38049                                  		dw _GOTO
 38050                                  		db 5
 38051                                  		db 'SHIFT'
 38052                                  		db 2
 38053                                  		dw _SHIFT
 38054                                  		db 2
 38055                                  		db 'IF'
 38056                                  		db 2
 38057                                  		dw _$IF
 38058                                  		db 3
 38059                                  		db 'FOR'
 38060                                  		db 2
 38061                                  		dw _$FOR
 38062                                  		db 3
 38063                                  		db 'CLS'
 38064                                  		db 0
 38065                                  		dw CLS
 38066                                  		db 0
 38067                                  
 38068                                  CAPITAL_A:	db 'A'
 38069                                  VBAR:		db '|'
 38070                                  LABRACKET:	db '<' ; 3Ch
 38071                                  RABRACKET:	db '>' ; 3Eh
 38072                                  DOLLAR:		db '$'
 38073                                  LPAREN:		db '('
 38074                                  RPAREN:		db ')'
 38075                                  NULLRPAREN:	db ')' ; 29h
 38076                                  		db 0
 38077                                  IN_WORD:	db 'I','N'
 38078                                  DO_WORD	:	db 'D','O'
 38079                                  STAR:		db '*'
 38080                                  CHAR_SUB:	db '-' 
 38081                                  PLUS_CHR:	db '+'
 38082                                  CHAR_L:		db 'L'
 38083                                  char_l:		db 'l'
 38084                                  small_a:	db 'a'
 38085                                  small_z:	db 'z'
 38086                                  CHAR_D:		db 'D'
 38087                                  CHAR_C:		db 'C'
 38088                                  CHAR_S:		db 'S'
 38089                                  CHAR_X:		db 'X'
 38090                                  DOT_CHR:	db '.' 
 38091                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 38092                                  		db ','
 38093                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 38094                                  MNCHR:		db 'p'
 38095                                  SYSTEM_CPAGE:	db 0
 38096                                  		db 0
 38097                                  
 38098                                  COMEXT:		db '.COM'
 38099                                  EXEEXT:		db '.EXE'
 38100                                  BATEXT:		db '.BAT'
 38101                                  SWITCH_LIST:	db 'VBAPW'
 38102                                  BATBUFLEN:	dw BATLEN ; 32
 38103                                  
 38104                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 38105                                  
 38106                                  TRANDATAEND:
 38107                                  
 38108                                  %endif
 38109                                  
 38110                                  ;============================================================================
 38111                                  ; TDATA.ASM, MSDOS 6.0, 1991
 38112                                  ;============================================================================
 38113                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38114                                  
 38115                                  	; 15/04/2023
 38116 000081A6 00                      	db	0
 38117 000081A7 90                      align 2
 38118                                  
 38119                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 38120                                  ; ---------------------------------------------------------------------------
 38121 000081A8 00                      	db 0
 38122                                  ; Lists of help message numbers for internal commands and /?
 38123                                  
 38124                                  ;;NoHelpMsgs:
 38125 000081A9 B0040000                	dw	1200,0		;M014
 38126                                  BreakHelpMsgs:
 38127 000081AD 14050000                	dw	1300,0
 38128                                  ChcpHelpMsgs:
 38129 000081B1 280529050000            	dw	1320,1321,0
 38130                                  CdHelpMsgs:
 38131 000081B7 3C053D053E050000        	dw	1340,1341,1342,0
 38132                                  ClsHelpMsgs:
 38133 000081BF 50050000                	dw	1360,0
 38134                                  CopyHelpMsgs:
 38135 000081C3 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 38135 000081CC 050000             
 38136                                  CttyHelpMsgs:
 38137 000081CF 8C050000                	dw	1420,0
 38138                                  DateHelpMsgs:
 38139 000081D3 A005A1050000            	dw	1440,1441,0
 38140                                  DelHelpMsgs:
 38141 000081D9 B405B505B6050000        	dw	1460,1461,1462,0
 38142                                  DirHelpMsgs:
 38143 000081E1 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 38143 000081EA 05CD05CE05CF05D005 
 38144                                  	; MSDOS 6.0 COMMAND.COM
 38145                                  	;dw	1489,1490,1491,1492
 38146 000081F3 0000                    	dw	0
 38147                                  ExitHelpMsgs:
 38148 000081F5 DC050000                	dw	1500,0
 38149                                  MdHelpMsgs:
 38150 000081F9 F0050000                	dw	1520,0
 38151                                  PathHelpMsgs:
 38152 000081FD 0406050606060000        	dw	1540,1541,1542,0
 38153                                  PromptHelpMsgs:
 38154 00008205 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 38154 0000820E 061D061E061F062006-
 38154 00008217 0000               
 38155                                  RdHelpMsgs:
 38156 00008219 2C060000                	dw	1580,0
 38157                                  RenHelpMsgs:
 38158 0000821D 4006410642060000        	dw	1600,1601,1602,0
 38159                                  SetHelpMsgs:
 38160 00008225 5406550656060000        	dw	1620,1621,1622,0
 38161                                  TimeHelpMsgs:
 38162 0000822D 680669060000            	dw	1640,1641,0
 38163                                  TypeHelpMsgs:
 38164 00008233 7C060000                	dw	1660,0
 38165                                  VerHelpMsgs:
 38166 00008237 90060000                	dw	1680,0
 38167                                  VerifyHelpMsgs:
 38168 0000823B A4060000                	dw	1700,0
 38169                                  VolHelpMsgs:
 38170 0000823F B8060000                	dw	1720,0
 38171                                  CallHelpMsgs:
 38172 00008243 CC06CD060000            	dw	1740,1741,0	;M014
 38173                                  RemHelpMsgs:
 38174 00008249 E0060000                	dw	1760,0		;M014
 38175                                  PauseHelpMsgs:
 38176 0000824D F4060000                	dw	1780,0		;M014
 38177                                  EchoHelpMsgs:
 38178 00008251 080709070000            	dw	1800,1801,0	;M014
 38179                                  GotoHelpMsgs:
 38180 00008257 1C071D070000            	dw	1820,1821,0	;M014
 38181                                  ShiftHelpMsgs:
 38182 0000825D 30070000                	dw	1840,0		;M014
 38183                                  IfHelpMsgs:
 38184 00008261 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 38184 0000826A 0749074A070000     
 38185                                  ForHelpMsgs:
 38186 00008271 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 38186 0000827A 00                 
 38187                                  TruenameHelpMsgs:
 38188 0000827B 6C070000                	 dw	1900,0		;M014
 38189                                  LoadhighHelpMsgs:
 38190 0000827F 800781078207            	dw	1920,1921,1922
 38191                                  	; MSDOS 6.0 COMMAND.COM
 38192                                  	;dw	1923,1924,1925,1926,1927 ;M014
 38193 00008285 0000                    	dw	0
 38194                                  
 38195                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 38196                                  CLSSTRING:
 38197 00008287 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 38198                                  
 38199                                  PROMPT_TABLE:
 38200 0000828C 42                      	db	"B"
 38201 0000828D [FB1D]                  	dw	Print_B
 38202 0000828F 44                      	db	"D"
 38203 00008290 [CA36]                  	dw	PRINT_DATE
 38204 00008292 45                      	db	"E"
 38205 00008293 [EF1D]                  	dw	PRINT_ESC
 38206 00008295 47                      	db	"G"
 38207 00008296 [F31D]                  	dw	PRINT_G
 38208 00008298 48                      	db	"H"
 38209 00008299 [E51D]                  	dw	PRINT_BACK
 38210 0000829B 4C                      	db	"L"
 38211 0000829C [F71D]                  	dw	PRINT_L
 38212 0000829E 4E                      	db	"N"
 38213 0000829F [0C1E]                  	dw	PRINT_DRIVE
 38214 000082A1 50                      	db	"P"
 38215 000082A2 [141E]                  	dw	build_dir_for_prompt
 38216 000082A4 51                      	db	"Q"
 38217 000082A5 [EB1D]                  	dw	PRINT_EQ
 38218 000082A7 54                      	db	"T"
 38219 000082A8 [802F]                  	dw	PRINT_TIME
 38220 000082AA 56                      	db	"V"
 38221 000082AB [7B1D]                  	dw	PRINT_VERSION
 38222 000082AD 5F                      	db	"_"
 38223 000082AE [D125]                  	dw	CRLF2
 38224 000082B0 24                      	db	"$"
 38225 000082B1 [FD1D]                  	dw	PRINT_CHAR
 38226 000082B3 00                      	db	0			; NUL TERMINATED
 38227                                  
 38228                                  ; Table of IF conditionals
 38229                                  IFTAB:
 38230 000082B4 034E4F54                	db	3,"NOT"			; First byte is count
 38231 000082B8 [E00A]                  	dw	IFNOT
 38232 000082BA 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 38232 000082C3 454C               
 38233 000082C5 [9F0B]                  	dw	IFERLEV
 38234 000082C7 054558495354            	db	5,"EXIST"
 38235 000082CD [340B]                  	dw	IFEXISTS
 38236 000082CF 00                      	db	0
 38237                                  
 38238                                  ; Table for internal command names
 38239                                  COMTAB:
 38240 000082D0 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 38241 000082D5 [6410]                  	dw	CATALOG			; In TCMD1.ASM
 38242 000082D7 [E181]                  	dw	DirHelpMsgs
 38243                                  
 38244 000082D9 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 38245 000082DF [140C]                  	dw	_$CALL			; In TBATCH2.ASM
 38246 000082E1 [4382]                  	dw	CallHelpMsgs
 38247                                  
 38248 000082E3 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 38249 000082E9 [5720]                  	dw	CHCP			; In TCMD2B.ASM
 38250 000082EB [B181]                  	dw	ChcpHelpMsgs
 38251                                  
 38252 000082ED 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38253 000082F5 [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38254 000082F7 [1D82]                  	dw	RenHelpMsgs
 38255                                  
 38256 000082F9 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38257 000082FE [411A]                  	dw	CRENAME			; In TCMD1.ASM
 38258 00008300 [1D82]                  	dw	RenHelpMsgs
 38259                                  	
 38260 00008302 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 38261 00008309 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38262 0000830B [D981]                  	dw	DelHelpMsgs
 38263                                  	
 38264 0000830D 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 38265 00008312 [BF19]                  	dw	ERASE			; In TCMD1.ASM
 38266 00008314 [D981]                  	dw	DelHelpMsgs
 38267                                  	
 38268 00008316 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38269 0000831C [E81A]                  	dw	TYPEFIL			; In TCMD1.ASM
 38270 0000831E [3382]                  	dw	TypeHelpMsgs
 38271                                  	
 38272 00008320 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 38273 00008325 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 38274 00008327 [4982]                  	dw	RemHelpMsgs
 38275                                  	
 38276 00008329 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 38277 0000832F [1737]                  	dw	COPY			; In COPY.ASM
 38278 00008331 [C381]                  	dw	CopyHelpMsgs
 38279                                  	
 38280 00008333 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 38281 0000833A [B319]                  	dw	PAUSE			; In TCMD1.ASM
 38282 0000833C [4D82]                  	dw	PauseHelpMsgs
 38283                                  	
 38284 0000833E 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 38285 00008344 [932E]                  	dw	DATE			; In TPIPE.ASM
 38286 00008346 [D381]                  	dw	DateHelpMsgs
 38287                                  	
 38288 00008348 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 38289 0000834E [F22E]                  	dw	CTIME			; In TPIPE.ASM
 38290 00008350 [2D82]                  	dw	TimeHelpMsgs
 38291                                  	
 38292 00008352 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 38293 00008357 [071D]                  	dw	VERSION			; In TCMD2.ASM
 38294 00008359 [3782]                  	dw	VerHelpMsgs
 38295                                  	
 38296 0000835B 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38297 00008360 [0F1C]                  	dw	VOLUME			; In TCMD1.ASM
 38298 00008362 [3F82]                  	dw	VolHelpMsgs
 38299                                  	
 38300 00008364 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38301 00008368 [9A24]                  	dw	_$CHDIR			; In TENV.ASM
 38302 0000836A [B781]                  	dw	CdHelpMsgs
 38303                                  	
 38304 0000836C 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38305 00008373 [9A24]                  	dw	_$CHDIR			; In TENV.ASM
 38306 00008375 [B781]                  	dw	CdHelpMsgs
 38307                                  	
 38308 00008377 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38309 0000837B [FF24]                  	dw	_$MKDIR			; In TENV.ASM
 38310 0000837D [F981]                  	dw	MdHelpMsgs
 38311                                  	
 38312 0000837F 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38313 00008386 [FF24]                  	dw	_$MKDIR			; In TENV.ASM
 38314 00008388 [F981]                  	dw	MdHelpMsgs
 38315                                  	
 38316 0000838A 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38317 0000838E [4125]                  	dw	_$RMDIR			; In TENV.ASM
 38318 00008390 [1982]                  	dw	RdHelpMsgs
 38319                                  	
 38320 00008392 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38321 00008399 [4125]                  	dw	_$RMDIR			; In TENV.ASM
 38322 0000839B [1982]                  	dw	RdHelpMsgs
 38323                                  	
 38324 0000839D 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 38325 000083A4 [1436]                  	dw	CNTRLC			; In TUCODE.ASM
 38326 000083A6 [AD81]                  	dw	BreakHelpMsgs
 38327                                  	
 38328 000083A8 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 38329 000083B0 [5636]                  	dw	VERIFY			; In TUCODE.ASM
 38330 000083B2 [3B82]                  	dw	VerifyHelpMsgs
 38331                                  	
 38332 000083B4 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 38333 000083B9 [0422]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 38334 000083BB [2582]                  	dw	SetHelpMsgs
 38335                                  	
 38336 000083BD 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 38337 000083C5 [EA21]                  	dw	ADD_PROMPT		; In TENV.ASM
 38338 000083C7 [0582]                  	dw	PromptHelpMsgs
 38339                                  	
 38340 000083C9 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 38341 000083CF [7B1E]                  	dw	PATH			; In TCMD2.ASM
 38342 000083D1 [FD81]                  	dw	PathHelpMsgs
 38343                                  	
 38344 000083D3 044558495400            	db	4,"EXIT",0
 38345 000083D9 [4C21]                  	dw	_$EXIT			; In TCMD2.ASM
 38346 000083DB [F581]                  	dw	ExitHelpMsgs
 38347                                  	
 38348 000083DD 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 38349 000083E3 [B91F]                  	dw	CTTY			; In TCMD2.ASM
 38350 000083E5 [CF81]                  	dw	CttyHelpMsgs
 38351                                  	
 38352 000083E7 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 38353 000083ED [DB35]                  	dw	_ECHO			; In TUCODE.ASM
 38354 000083EF [5182]                  	dw	EchoHelpMsgs
 38355                                  	
 38356 000083F1 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 38357 000083F7 [480C]                  	dw	_GOTO			; In TBATCH.ASM
 38358 000083F9 [5782]                  	dw	GotoHelpMsgs
 38359                                  	
 38360 000083FB 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 38361 00008402 [CD0B]                  	dw	_SHIFT			; In TBATCH.ASM
 38362 00008404 [5D82]                  	dw	ShiftHelpMsgs
 38363                                  	
 38364 00008406 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 38365 0000840A [790A]                  	dw	_$IF			; In TBATCH.ASM
 38366 0000840C [6182]                  	dw	IfHelpMsgs
 38367                                  	
 38368 0000840E 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 38369 00008413 [FD0E]                  	dw	_$FOR			; In TBATCH.ASM
 38370 00008415 [7182]                  	dw	ForHelpMsgs
 38371                                  	
 38372 00008417 03434C5300              	db	3,"CLS",0
 38373 0000841C [201F]                  	dw	CLS			; In TCMD2.ASM
 38374 0000841E [BF81]                  	dw	ClsHelpMsgs
 38375                                  	
 38376 00008420 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 38376 00008429 03                 
 38377 0000842A [D520]                  	dw	TRUENAME		;AN000;
 38378 0000842C [7B82]                  	dw	TruenameHelpMsgs
 38379                                  	
 38380 0000842E 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 38380 00008437 02                 
 38381 00008438 [4856]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38382 0000843A [7F82]                  	dw	LoadhighHelpMsgs	; M003
 38383                                  	
 38384 0000843C 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 38385 00008440 [4856]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38386 00008442 [7F82]                  	dw	LoadhighHelpMsgs	; M003
 38387                                  	
 38388 00008444 00                      	db	0			; Terminate command table
 38389                                  
 38390                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 38391                                  
 38392 00008445 2E434F4D                comext:	db	".COM"
 38393 00008449 2E455845                exeext:	db	".EXE"
 38394 0000844D 2E424154                batext:	db	".BAT"
 38395                                  
 38396                                  switch_list:
 38397 00008451 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 38398                                  
 38399                                  AttrLtrs:
 38400 00008457 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 38401                                  
 38402                                  ;	Attribute letters in AttrLtrs must appear in the order that
 38403                                  ;	attribute bits occur in the attribute byte returned by
 38404                                  ;	directory searches, starting with bit 0.
 38405                                  ;	The volume label attribute is lowercased to keep it from
 38406                                  ;	being matched (by an uppercase comparison).
 38407                                  
 38408                                  OrderLtrs:
 38409 0000845D 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 38410                                  	; MSDOS 6.0 COMMAND.COM
 38411                                  	;db	"NEDSGC"		; sort order letters for DIR
 38412                                  
 38413                                  ;	Sort order letters stand for file name, extension,
 38414                                  ;	date/time, size, grouped (directory files before others),
 38415                                  ;	and compression ratio. DIR routines rely on the specific
 38416                                  ;	order of the letters in this list.
 38417                                  
 38418                                  comspec_flag:
 38419 00008462 00                      	db	0                       ;AN071;
 38420                                  
 38421                                  BATBUFLEN:
 38422 00008463 2000                    	dw	BatLen ; 32
 38423                                  
 38424                                  ; *****************************************************
 38425                                  ; EMG 4.00
 38426                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 38427                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 38428                                  ; *****************************************************
 38429                                  
 38430                                  ; COMMON PARSE BLOCKS
 38431                                  
 38432                                  ; Indicates no value list for PARSE.
 38433                                  
 38434                                  NO_VALUES:
 38435 00008465 0000                    	dw	0			;AN000;  no values
 38436                                  
 38437                                  NULL_VALUE_LIST:  ; for unvalidated value
 38438 00008467 00                       	db	0                       ; no value lists
 38439                                  
 38440                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38441                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 38442                                  
 38443                                  ; PARSE control block for a required file specification (upper cased)
 38444                                  
 38445                                  FILE_REQUIRED:
 38446 00008468 0002                    	dw	0200h			;AN000;  filespec - required
 38447 0000846A 0100                    	dw	1			;AN000;  capitalize - file table
 38448 0000846C [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38449 0000846E [6584]                  	dw	NO_VALUES		;AN000;
 38450 00008470 00                      	db	0			;AN000;  no keywords
 38451                                  
 38452                                  ; PARSE control block for an optional file specification (upper cased)
 38453                                  ; or drive number
 38454                                  
 38455                                  FILE_OPTIONAL:
 38456 00008471 0103                    	dw	0301h			;AN000;  filespec or drive number
 38457                                  					;	 optional
 38458 00008473 0100                    	dw	1			;AN000;  capitalize - file table
 38459 00008475 [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38460 00008477 [6584]                  	dw	NO_VALUES		;AN000;
 38461 00008479 00                      	db	0			;AN000;  no keywords
 38462                                  
 38463                                  ; PARSE control block for an optional file specification (upper cased)
 38464                                  
 38465                                  FILE_OPTIONAL2:
 38466 0000847A 0102                    	dw	0201h                   ;AN000;  filespec optional
 38467 0000847C 0100                    	dw	1                       ;AN000;  capitalize - file table
 38468 0000847E [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38469 00008480 [6584]                  	dw	NO_VALUES		;AN000;
 38470 00008482 00                      	db	0			;AN000;  no keywords
 38471                                  
 38472                                  ; PARSE control block for an optional /P switch
 38473                                  
 38474                                  SLASH_P_SWITCH:
 38475 00008483 0000                    	dw	0			;AN000;  no match flags
 38476 00008485 0200                    	dw	2			;AN000;  capitalize - char table
 38477 00008487 [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38478 00008489 [6584]                  	dw	NO_VALUES		;AN000;
 38479 0000848B 01                      	db	1			;AN000;  1 keyword
 38480                                  SLASH_P_SYN:
 38481 0000848C 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38482                                  
 38483                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38484                                  
 38485                                  ; The following parse control block can be used for any command which
 38486                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38487                                  ; the equal sign as an additional delimiter. Returns verified result
 38488                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38489                                  ; internal commands.
 38490                                  
 38491                                  PARSE_BREAK:
 38492 0000848F [9284]                  	dw	BREAK_PARMS		;AN000;
 38493 00008491 00                      	db	0			;AN032; no extra delimiter
 38494                                  
 38495                                  BREAK_PARMS:
 38496 00008492 0001                    	db	0,1			;AN000;  1 positional parm
 38497 00008494 [9884]                  	dw	BREAK_CONTROL1		;AN000;
 38498 00008496 00                      	db	0			;AN000;  no switches
 38499 00008497 00                      	db	0			;AN000;  no keywords
 38500                                  
 38501                                  BREAK_CONTROL1:
 38502 00008498 0120                    	dw	2001h			;AN000;  string value - optional
 38503 0000849A 0200                    	dw	2			;AN000;  capitalize - char table
 38504 0000849C [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38505 0000849E [A184]                  	dw	BREAK_VALUES		;AN000;
 38506 000084A0 00                      	db	0			;AN000;  no keywords
 38507                                  
 38508                                  BREAK_VALUES:
 38509 000084A1 03                      	db	3			;AN000;
 38510 000084A2 00                      	db	0			;AN000;  no ranges
 38511 000084A3 00                      	db	0			;AN000;  no numeric values
 38512 000084A4 02                      	db	2			;AN000;  2 string values
 38513 000084A5 00                      	db	0			;AN000;  returned if ON
 38514 000084A6 [AB84]                  	dw	BREAK_ON		;AN000;  point to ON string
 38515 000084A8 66                      	db	'f'                     ;AN000;  returned if OFF
 38516 000084A9 [AE84]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38517                                  
 38518                                  BREAK_ON:
 38519 000084AB 4F4E00                  	db	"ON",0                  ;AN000;
 38520                                  BREAK_OFF:
 38521 000084AE 4F464600                	db	"OFF",0                 ;AN000;
 38522                                  
 38523                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38524                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38525                                  
 38526                                  ; PARSE BLOCK FOR CHCP
 38527                                  
 38528                                  ; The following parse control block can be used for any command which
 38529                                  ; needs only one optional three digit decimal parameter for operands.
 38530                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38531                                  ; CHCP internal command.
 38532                                  
 38533                                  CHCP_MINVAL	EQU	100			;AN000;
 38534                                  CHCP_MAXVAL	EQU	999			;AN000;
 38535                                  
 38536                                  PARSE_CHCP:
 38537 000084B2 [B584]                  	dw	CHCP_PARMS			;AN000;
 38538 000084B4 00                      	db	0				;AN000;  no extra delimiter
 38539                                  CHCP_PARMS:
 38540 000084B5 0001                    	db	0,1				;AN000;  1 positional parm
 38541 000084B7 [BB84]                  	dw	CHCP_CONTROL1			;AN000;
 38542 000084B9 00                      	db	0				;AN000;  no switches
 38543 000084BA 00                      	db	0				;AN000;  no keywords
 38544                                  
 38545                                  CHCP_CONTROL1:
 38546 000084BB 0180                    	dw	8001h				;AN000;  numeric value - optional
 38547 000084BD 0000                    	dw	0				;AN000;  no function flags
 38548 000084BF [7495]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38549 000084C1 [C484]                  	dw	CHCP_VALUES			;AN000;
 38550 000084C3 00                      	db	0				;AN000;  no keywords
 38551                                  
 38552                                  CHCP_VALUES:
 38553 000084C4 01                      	db	1				;AN000;
 38554 000084C5 01                      	db	1				;AN000;  1 range
 38555 000084C6 01                      	db	1				;AN000;  returned if result
 38556 000084C7 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38557 000084CF 00                      	db	0				;AN000;  no numeric values
 38558 000084D0 00                      	db	0				;AN000;  no string values
 38559                                  
 38560                                  ; PARSE BLOCK FOR DATE
 38561                                  
 38562                                  ; The following parse control block can be used for any command which
 38563                                  ; needs only an optional date string as an operand. Returns unverified
 38564                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38565                                  
 38566                                  PARSE_DATE:
 38567 000084D1 [D484]                  	dw	DATE_PARMS			;AN000;
 38568 000084D3 00                      	db	0				;AN000;  no extra delimiter
 38569                                  DATE_PARMS:
 38570 000084D4 0001                    	db	0,1				;AN000;  1 positional parm
 38571 000084D6 [DA84]                  	dw	DATE_CONTROL1			;AN000;
 38572 000084D8 00                      	db	0				;AN000;  no switches
 38573 000084D9 00                      	db	0				;AN000;  no keywords
 38574                                  
 38575                                  DATE_CONTROL1:
 38576 000084DA 0110                    	dw	1001h				;AN000;  date - optional
 38577 000084DC 0000                    	dw	0				;AN000;  no function flags
 38578 000084DE [7C95]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38579 000084E0 [6584]                  	dw	NO_VALUES			;AN000;
 38580 000084E2 00                      	db	0				;AN000;  no keywords
 38581                                  
 38582                                  ; PARSE BLOCK FOR TIME
 38583                                  
 38584                                  ; The following parse control block can be used for any command which
 38585                                  ; needs only an optional time string as an operand. Returns unverified
 38586                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38587                                  
 38588                                  PARSE_TIME:
 38589 000084E3 [E684]                  	dw	TIME_PARMS			;AN000;
 38590 000084E5 00                      	db	0				;AN000;  no extra delimiter
 38591                                  TIME_PARMS:
 38592 000084E6 0001                    	db	0,1				;AN000;  1 positional parm
 38593 000084E8 [EC84]                  	dw	TIME_CONTROL1			;AN000;
 38594 000084EA 00                      	db	0				;AN000;  no switches
 38595 000084EB 00                      	db	0				;AN000;  no keywords
 38596                                  
 38597                                  TIME_CONTROL1:
 38598 000084EC 0108                    	dw	0801h				;AN000;  TIME - optional
 38599 000084EE 0000                    	dw	0				;AN000;  no function flags
 38600 000084F0 [8495]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38601 000084F2 [6584]                  	dw	NO_VALUES			;AN000;
 38602 000084F4 00                      	db	0				;AN000;  no keywords
 38603                                  
 38604                                  ; PARSE BLOCK FOR VOL
 38605                                  
 38606                                  ; The following parse control block can be used for any command which
 38607                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38608                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38609                                  ; internal command.
 38610                                  
 38611                                  PARSE_VOL:
 38612 000084F5 [F884]                  	dw	VOL_PARMS			;AN000;
 38613 000084F7 00                      	db	0				;AN000;  no extra delimiter
 38614                                  VOL_PARMS:
 38615 000084F8 0001                    	db	0,1				;AN000;  1 positional parm
 38616 000084FA [FE84]                  	dw	DRIVE_CONTROL1			;AN000;
 38617 000084FC 00                      	db	0				;AN000;  no switches
 38618 000084FD 00                      	db	0				;AN000;  no keywords
 38619                                  
 38620                                  DRIVE_CONTROL1:
 38621 000084FE 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38622 00008500 0100                    	dw	1				;AN000;  capitalize - file table
 38623 00008502 [8C95]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38624 00008504 [6584]                  	dw	NO_VALUES			;AN000;
 38625 00008506 00                      	db	0				;AN000;  no keywords
 38626                                  
 38627                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38628                                  
 38629                                  ; The following parse control block can be used for any command which
 38630                                  ; needs only one required file specification as an operand. Returns a
 38631                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38632                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38633                                  
 38634                                  PARSE_MRDIR:
 38635 00008507 [0A85]                  	dw	MRDIR_PARMS			;AN000;
 38636 00008509 00                      	db	0				;AN000;  no extra delimiter
 38637                                  MRDIR_PARMS:
 38638 0000850A 0101                    	db	1,1				;AN000;  1 positional parm
 38639 0000850C [6884]                  	dw	FILE_REQUIRED			;AN000;
 38640 0000850E 00                      	db	0				;AN000;  no switches
 38641 0000850F 00                      	db	0				;AN000;  no keywords
 38642                                  
 38643                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38644                                  
 38645                                  ; The following parse control block can be used for any command which
 38646                                  ; needs only one optional file specification an operand. Returns a
 38647                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38648                                  ; for the CHDIR and TRUENAME internal commands.
 38649                                  
 38650                                  PARSE_CHDIR:
 38651 00008510 [1385]                  	dw	CHDIR_PARMS			;AN000;
 38652 00008512 00                      	db	0				;AN000;  no extra delimiter
 38653                                  CHDIR_PARMS:
 38654 00008513 0001                    	db	0,1				;AN000;  1 positional parm
 38655 00008515 [7184]                  	dw	FILE_OPTIONAL			;AN000;
 38656 00008517 00                      	db	0				;AN000;  no switches
 38657 00008518 00                      	db	0				;AN000;  no keywords
 38658                                  
 38659                                  ; PARSE BLOCK FOR ERASE
 38660                                  
 38661                                  ; The following parse control block is used for the DEL/ERASE internal
 38662                                  ; commands. This command has one required file specification and an
 38663                                  ; optional switch (/p) as operands. The verified switch or unverified
 38664                                  ; file specification is returned in PARSE1_OUTPUT.
 38665                                  
 38666                                  PARSE_ERASE:
 38667 00008519 [1C85]                  	dw	ERASE_PARMS			;AN000;
 38668 0000851B 00                      	db	0				;AN000;  no extra delimiter
 38669                                  
 38670                                  ERASE_PARMS:
 38671 0000851C 0101                    	db	1,1				;AN000;  1 positional parm
 38672 0000851E [6884]                  	dw	FILE_REQUIRED			;AN000;
 38673 00008520 01                      	db	1				;AN000;  1 switch
 38674 00008521 [8384]                  	dw	SLASH_P_SWITCH			;AN000;
 38675 00008523 00                      	db	0				;AN000;  no keywords
 38676                                  
 38677                                  ; PARSE BLOCK FOR DIR
 38678                                  
 38679                                  ; The following parse control block is used for the DIR internal command.
 38680                                  ; This command has one optional file specification and several optional
 38681                                  ; switches. Switches, switch values, and the filespec are returned in 
 38682                                  ; PARSE1_OUTPUT.
 38683                                  ;
 38684                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38685                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38686                                  ; do not require colons, and are not checked against a value list.
 38687                                  ;
 38688                                  ; Switch /h has been removed from the DIR command	;M008
 38689                                  ; Switch /? is no longer handled internally		;M008
 38690                                  ;
 38691                                  ; A list of pointers to all the switch synonyms is provided here to
 38692                                  ; help identify which switch has been matched.
 38693                                  
 38694                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38695                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38696                                  
 38697                                  PARSE_DIR:
 38698 00008524 [2785]                  	dw	DIR_PARMS
 38699 00008526 00                      	db	0			; no extra delimiters
 38700                                  DIR_PARMS:
 38701 00008527 0001                    	db	0,1			; 1 optional positional param
 38702 00008529 [7A84]                  	dw	FILE_OPTIONAL2
 38703 0000852B 02                      	db	2			; 2 kinds of switches
 38704 0000852C [3185]                  	dw	DIR_SW_VALUED
 38705 0000852E [4085]                  	dw	DIR_SW_UNVALUED
 38706 00008530 00                      	db	0			; no keywords
 38707                                  
 38708                                  DIR_SW_VALUED:
 38709 00008531 0120                    	dw	2001h			; optional string value
 38710 00008533 2100                    	dw	21h			; optional colon; capitalize 
 38711 00008535 [7495]                  	dw	PARSE1_OUTPUT		; result buffer
 38712 00008537 [6784]                  	dw	NULL_VALUE_LIST		; don't validate value
 38713                                  
 38714 00008539 02                      	db	2
 38715                                  
 38716                                  ; MSDOS 6.0 COMMAND.COM
 38717                                  ;ifdef DBLSPACE_HOOKS
 38718                                  ;	db	3		; 3 'synonyms'
 38719                                  ;else
 38720                                  ;	db	2		; 2 'synonyms'
 38721                                  ;endif
 38722                                  
 38723                                  DIR_SW_A:
 38724 0000853A 2F4100                  	db	"/A",0
 38725                                  DIR_SW_O:
 38726 0000853D 2F4F00                  	db	"/O",0
 38727                                  
 38728                                  ; MSDOS 6.0 COMMAND.COM
 38729                                  ;ifdef DBLSPACE_HOOKS
 38730                                  ;DIR_SW_C	db	"/C",0
 38731                                  ;endif
 38732                                  
 38733                                  DIR_SW_UNVALUED:
 38734 00008540 0000                    	dw	0			; no value
 38735 00008542 0000                    	dw	0			; no format functions
 38736 00008544 [7495]                  	dw	PARSE1_OUTPUT		; result buffer
 38737 00008546 [6584]                  	dw	NO_VALUES
 38738                                  
 38739                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38740                                  	;db	12
 38741                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38742 00008548 0E                      	db	14		; 14 'synonyms' !?
 38743                                  
 38744                                  ; MSDOS 6.0 COMMAND.COM
 38745                                  ;ifdef DBLSPACE_HOOKS
 38746                                  ;	db	13		; 13 'synonyms'
 38747                                  ;else
 38748                                  ;	db	12		; 12 'synonyms'
 38749                                  ;endif
 38750                                  
 38751                                  DIR_SW_NEG_A:
 38752 00008549 2F2D4100                	db	"/-A",0
 38753                                  DIR_SW_NEG_O:
 38754 0000854D 2F2D4F00                	db	"/-O",0
 38755                                  DIR_SW_S:
 38756 00008551 2F5300                  	db	"/S",0
 38757                                  DIR_SW_NEG_S:
 38758 00008554 2F2D5300                	db	"/-S",0
 38759                                  DIR_SW_B:
 38760 00008558 2F4200                  	db	"/B",0
 38761                                  DIR_SW_NEG_B:
 38762 0000855B 2F2D4200                	db	"/-B",0
 38763                                  DIR_SW_W:
 38764 0000855F 2F5700                  	db	"/W",0
 38765                                  DIR_SW_NEG_W:
 38766 00008562 2F2D5700                	db	"/-W",0
 38767                                  DIR_SW_P:
 38768 00008566 2F5000                  	db	"/P",0
 38769                                  DIR_SW_NEG_P:
 38770 00008569 2F2D5000                	db	"/-P",0
 38771                                  DIR_SW_L:
 38772 0000856D 2F4C00                  	db	"/L",0		;M010
 38773                                  DIR_SW_NEG_L:
 38774 00008570 2F2D4C00                	db	"/-L",0 	;M010
 38775                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38776                                  ;DIR_SW_NEG_C:
 38777                                  ;	db	"/-C",0
 38778                                  
 38779                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38780                                  ; identification. Order is critical - DIR routines rely on the
 38781                                  ; specific order in this list. Negated options appear at odd 
 38782                                  ; positions in the list, and simple on/off options appear first.
 38783                                  
 38784                                  Dir_Sw_Ptrs:
 38785                                  	; MSDOS 5.0 COMMAND.COM
 38786 00008574 [6285]                  	dw	DIR_SW_NEG_W 
 38787                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38788                                  	; MSDOS 6.0 COMMAND.COM
 38789                                  	;dw	DIR_SW_NEG_C
 38790                                  	;dw	DIR_SW_C
 38791                                  	;dw	DIR_SW_NEG_W
 38792                                  	
 38793 00008576 [5F85]                  	dw	DIR_SW_W
 38794 00008578 [6985]                  	dw	DIR_SW_NEG_P
 38795 0000857A [6685]                  	dw	DIR_SW_P
 38796 0000857C [5485]                  	dw	DIR_SW_NEG_S
 38797 0000857E [5185]                  	dw	DIR_SW_S
 38798 00008580 [5B85]                  	dw	DIR_SW_NEG_B
 38799 00008582 [5885]                  	dw	DIR_SW_B
 38800 00008584 [7085]                  	dw	DIR_SW_NEG_L	;M010
 38801 00008586 [6D85]                  	dw	DIR_SW_L	;M010
 38802 00008588 [4D85]                  	dw	DIR_SW_NEG_O
 38803 0000858A [3D85]                  	dw	DIR_SW_O
 38804 0000858C [4985]                  	dw	DIR_SW_NEG_A
 38805 0000858E [3A85]                  	dw	DIR_SW_A
 38806                                  
 38807                                  ; PARSE BLOCK FOR RENAME
 38808                                  
 38809                                  ; The following parse control block can be used for any command which
 38810                                  ; needs only two required file specifications as operands. Returns
 38811                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38812                                  ; Currently used for the RENAME internal command.
 38813                                  
 38814                                  PARSE_RENAME:
 38815 00008590 [9385]                  	dw	RENAME_PARMS		;AN000;
 38816 00008592 00                      	db	0			;AN000;  no extra delimiter
 38817                                  RENAME_PARMS:
 38818 00008593 0202                    	db	2,2			;AN000;  2 positional parms
 38819 00008595 [6884]                  	dw	FILE_REQUIRED		;AN000;
 38820 00008597 [6884]                  	dw	FILE_REQUIRED		;AN000;
 38821 00008599 00                      	db	0			;AN000;  no switches
 38822 0000859A 00                      	db	0			;AN000;  no keywords
 38823                                  
 38824                                  ; PARSE BLOCK FOR CTTY
 38825                                  
 38826                                  ; The following parse control block can be used for any command which
 38827                                  ; needs one required device name as an operand. Returns a pointer to
 38828                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38829                                  ; internal command.
 38830                                  
 38831                                  PARSE_CTTY:
 38832 0000859B [9E85]                  	dw	CTTY_PARMS		;AN000;
 38833 0000859D 00                      	db	0			;AN000;  no extra delimiter
 38834                                  CTTY_PARMS:
 38835 0000859E 0101                    	db	1,1			;AN000;  1 positional parm
 38836 000085A0 [A485]                  	dw	CTTY_CONTROL1		;AN000;
 38837 000085A2 00                      	db	0			;AN000;  no switches
 38838 000085A3 00                      	db	0			;AN000;  no keywords
 38839                                  CTTY_CONTROL1:
 38840 000085A4 0020                    	dw	2000h			;AN000;  string value - required
 38841 000085A6 1100                    	dw	11h			;AN000;  capitalize - file table
 38842                                  					;AN000;  remove colon at end
 38843 000085A8 [7495]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38844 000085AA [6584]                  	dw	NO_VALUES		;AN000;
 38845 000085AC 00                      	db	0			;AN000;  no keywords
 38846                                  
 38847                                  ; PARSE BLOCK FOR VER
 38848                                  
 38849                                  ; The following parse control block can be used for any command which
 38850                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38851                                  
 38852                                  PARSE_VER:
 38853 000085AD [B085]                  	dw	VER_PARMS
 38854 000085AF 00                      	db	0			; no extra delimiters
 38855                                  VER_PARMS:
 38856 000085B0 0000                    	db	0,0			; no positional parameters
 38857                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 38858                                  %if 0	; PCDOS 7.1 (& MSDOS 5.0-6.22) COMMAND.COM 
 38859                                  	db	1			; one switch
 38860                                  	dw	SLASH_R
 38861                                  %else
 38862                                  	; 20/07/2024 - Retro DOS v4-v5 COMMAND.COM
 38863 000085B2 02                      	db	2			; two switches
 38864 000085B3 [B885]                  	dw	SLASH_R
 38865 000085B5 [C485]                  	dw	SLASH_T ; Retro DOS v4-v5 COMMAND.COM switch
 38866                                  %endif
 38867 000085B7 00                      	db	0			; no keywords
 38868                                  SLASH_R:
 38869 000085B8 0000                    	dw	0			; no values
 38870 000085BA 0200                    	dw	2			; capitalize by filename table
 38871 000085BC [7495]                  	dw	PARSE1_OUTPUT		; result buffer
 38872 000085BE [6584]                  	dw	NO_VALUES		; no values
 38873 000085C0 01                      	db	1			; one synonym
 38874                                  SLASH_R_SYN:
 38875 000085C1 2F5200                  	db	"/R",0
 38876                                  
 38877                                  ; 20/07/2024 - Retro DOS v4.1 (&v4.0) COMMAND.COM
 38878                                  %if 1
 38879                                  SLASH_T:
 38880 000085C4 0000                    	dw	0			; no values
 38881 000085C6 0200                    	dw	2			; capitalize by filename table
 38882 000085C8 [7495]                  	dw	PARSE1_OUTPUT		; result buffer
 38883 000085CA [6584]                  	dw	NO_VALUES		; no values
 38884 000085CC 01                      	db	1			; one synonym
 38885                                  SLASH_T_SYN:
 38886 000085CD 2F5400                  	db	"/T",0
 38887                                  %endif
 38888                                  
 38889                                  ; M003 ; Start of changes for LoadHigh support
 38890                                  
 38891                                  ;Parse Control Block for LOADHIGH command
 38892                                  
 38893                                  Parse_LoadHi:
 38894 000085D0 [D385]                  	dw	LoadHi_Parms		;extended parm table
 38895 000085D2 00                      	db	0			;no extra delimiters
 38896                                  
 38897                                  LoadHi_Parms:
 38898 000085D3 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 38899 000085D5 [6884]                  	dw	FILE_REQUIRED		;control struc for filename
 38900 000085D7 00                      	db	0			;no switches
 38901 000085D8 00                      	db	0			;no keywords
 38902                                  
 38903                                  ; M003 ; End of changes for LoadHigh support
 38904                                  
 38905                                  TempVarName:
 38906 000085D9 54454D503D00            	db	"TEMP=",0
 38907                                  
 38908                                  ; ---------------------------------------------------------------------------
 38909                                  ; 20/07/2024 - Retro DOS v4.1 (& v4.0) COMMAND.COM
 38910                                  %if 1
 38911 000085DF 0D0A                    RD4CMD_VER_MSG:	db 0Dh,0Ah
 38912 000085E1 526574726F20444F53-     		db 'Retro DOS v4 COMMAND.COM'
 38912 000085EA 20763420434F4D4D41-
 38912 000085F3 4E442E434F4D       
 38913 000085F9 0D0A                    		db 0Dh,0Ah 
 38914 000085FB 32303234202D204572-     		db '2024 - Erdogan Tan'
 38914 00008604 646F67616E2054616E 
 38915 0000860D 0D0A                    		db 0Dh,0Ah
 38916 0000860F 24                      		db '$'
 38917                                  %endif
 38918                                  ; ---------------------------------------------------------------------------
 38919                                  
 38920                                  	; 16/04/2023
 38921                                  TRANDATAEND:		; TRANGROUP:88C2h
 38922                                  
 38923                                  ;============================================================================
 38924                                  ; PSDATA.INC, MSDOS 6.0, 1991
 38925                                  ;============================================================================
 38926                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38927                                  
 38928                                  ; 18/04/2023
 38929                                  TRANSPACESTART:
 38930                                  
 38931                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 38932                                  
 38933                                  ;********************** Local Data *************************************
 38934                                  
 38935                                  $P_ORDINAL:
 38936 00008610 0000                    	dw	0		;AN000; Operand ordinal save area
 38937                                  $P_RC:
 38938 00008612 0000                    	dw	0		;AN000; Return code from parser
 38939                                  $P_SI_Save:
 38940 00008614 0000                    	dw	0		;AN000; Pointer of command buffer
 38941                                  $P_DX:
 38942 00008616 0000                    	dw	0		;AN000; Return result buffer address
 38943                                  $P_Terminator:
 38944 00008618 00                      	db	0		;AN000; Terminator code (ASCII)
 38945                                  $P_DBCSEV_OFF:
 38946 00008619 0000                    	dw	0		;AN000; Offset of DBCS EV
 38947                                  $P_DBCSEV_SEG:
 38948 0000861B 0000                    	dw	0		;AN000; Segment of DBCS EV
 38949                                  $P_Flags:			;AN000; Parser internal flags
 38950                                  $P_Flags1:
 38951 0000861D 00                      	db	0		;AN038; to reference first byte flags
 38952                                  $P_Flags2:
 38953 0000861E 00                      	db	0		;AN038; to reference second byte flags only
 38954                                  $P_SaveSI_Cmpx:
 38955 0000861F 0000                    	dw	0		;AN000; save si for later use by complex
 38956                                  $P_KEYorSW_Ptr:
 38957 00008621 0000                    	dw	0		;AN000; points next to "=" or ":" code
 38958                                  $P_Save_EOB:
 38959 00008623 0000                    	dw	0		;AN000; save pointer to EOB
 38960                                  $P_Found_SYNONYM:
 38961 00008625 0000                    	dw	0		;AN000; es:@ points to found synonym
 38962                                  $P_STRING_BUF:
 38963 00008627 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 38964                                  $P_ORIG_ORD:
 38965 000086A7 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 38966                                  $P_ORIG_STACK:
 38967 000086A9 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 38968                                  $P_ORIG_SI:
 38969 000086AB 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 38970                                  $P_Got_Time:
 38971 000086AD 00                      	db	0		;AN023; if 1, use Time delimiters
 38972                                  $P_Country_Info:
 38973 000086AE FFFF                    	dw	-1 ; 0FFFFh
 38974 000086B0 00<rep 20h>             	times	32 db 0	
 38975                                  $P_1st_Val:
 38976 000086D0 0000                    	dw	0		;AN000; used when process date or time
 38977                                  $P_2nd_Val:
 38978 000086D2 0000                    	dw	0		;AN000; used when process date or time
 38979                                  $P_3rd_Val:
 38980 000086D4 0000                    	dw	0		;AN000; used when process date or time
 38981                                  $P_4th_Val:
 38982 000086D6 0000                    	dw	0		;AN000; used when process date or time
 38983                                  $P_Char_CAP_Ptr:
 38984 000086D8 FF                      	db	0FFh		;AN000; info id
 38985 000086D9 0000                    	dw	0		;AN000; offset	of char case map table
 38986 000086DB 0000                    	dw	0		;AN000; segment of char case map table
 38987                                  $P_File_CAP_Ptr:
 38988 000086DD FF                      	db	0FFh		;AN000; info id
 38989 000086DE 0000                    	dw	0		;AN000; offset	of file case map table
 38990 000086E0 0000                    	dw	0		;AN000; segment of file case map table
 38991                                  
 38992                                  	; 18/04/2023
 38993                                  ;M029
 38994                                  ;!!!WARNING!!!
 38995                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 38996                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 38997                                  ;changes need to be made in SYSPARSE
 38998                                  
 38999                                  $P_FileSp_Char:
 39000 000086E2 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 39001                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 39002                                  
 39003                                  ;filespec error flag
 39004                                  $P_err_flag:
 39005 000086EB 00                      	db	0		;AN033; flag set if filespec parsing error
 39006                                  				;AN033;  was detected.
 39007                                  
 39008                                  ;============================================================================
 39009                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 39010                                  ;============================================================================
 39011                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39012                                  
 39013                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 39014                                  
 39015                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39016                                  ;;
 39017                                  ;; STRUCTURE: $M_RES_ADDRS
 39018                                  ;;
 39019                                  ;; Resident data area definition of variables
 39020                                  ;;
 39021                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 39022                                  
 39023                                  $M_RT:
 39024 000086EC 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 39025                                  
 39026                                  ;============================================================================
 39027                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 39028                                  ;============================================================================
 39029                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39030                                  
 39031                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 39032                                  ; ---------------------------------------------------------------------------
 39033                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 39034                                  ;;M031 - changed copyright to 1991
 39035                                  ;;9/16 - changed version to 6.0 and copyright to 1992
 39036                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 39037                                  ;;B49,50 - changed version to 6 and copyright to 1993
 39038                                  ; ---------------------------------------------------------------------------
 39039                                  
 39040                                  ;;ifdef USA
 39041                                  ;MsDosVer6_CCopy:
 39042                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 39043                                  ;	db	"Licensed Material - Property of Microsoft "
 39044                                  ;	db	"All rights reserved "
 39045                                  ;endif
 39046                                  
 39047                                  ; 15/04/2023
 39048                                  MsDosVer5_CCopy:
 39049 00008779 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 39049 00008782 7273696F6E20352E30-
 39049 0000878B 3020284329436F7079-
 39049 00008794 726967687420313938-
 39049 0000879D 312D31393931204D69-
 39049 000087A6 63726F736F66742043-
 39049 000087AF 6F727020           
 39050 000087B3 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 39050 000087BC 4D6174657269616C20-
 39050 000087C5 2D2050726F70657274-
 39050 000087CE 79206F66204D696372-
 39050 000087D7 6F736F667420       
 39051 000087DD 416C6C207269676874-     	db	"All rights reserved "
 39051 000087E6 732072657365727665-
 39051 000087EF 6420               
 39052                                  ; ---------------------------------------------------------------------------
 39053                                  ; 15/04/2023
 39054                                  	; 16/04/2023 - 21/04/2023
 39055                                  	;db 	0
 39056                                  	;db	0Dh,0Ah
 39057                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 39058                                  	;db	0
 39059                                  	;db	'by Erdogan Tan - 05/05/2023'
 39060                                  	;db	0
 39061                                  
 39062                                  ;============================================================================
 39063                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 39064                                  ;============================================================================
 39065                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39066                                  
 39067                                  PRINTF_HANDLE:
 39068 000087F1 0000                    	dw	0		;AC000;
 39069                                  
 39070                                  ; 15/047/2023
 39071                                  %if 0
 39072                                  
 39073                                  ;============================================================================
 39074                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39075                                  ;============================================================================
 39076                                  ; 29/09/2018 - Retro DOS v3.0
 39077                                  
 39078                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39079                                  
 39080                                  ;The TRANSPACE segment contains variable data that is considered
 39081                                  ;volatile between command cycles, and therefore is not included in the
 39082                                  ;transient checksum area. Contents of these variables MUST be
 39083                                  ;initialized before use, and must not be relied upon from command
 39084                                  ;cycle to command cycle.
 39085                                  ;
 39086                                  ;No constant data values should be stored here.
 39087                                  
 39088                                  ; ---------------------------------------------------------------------------
 39089                                  ; START OF UNITIALIZED DATA
 39090                                  ; ---------------------------------------------------------------------------
 39091                                  
 39092                                  ;	times 12 db 0
 39093                                  
 39094                                  align 16
 39095                                  
 39096                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 39097                                  
 39098                                  PRINTF_LEFT:	db 0
 39099                                  PRINTF_LONG:	db 0
 39100                                  PRINTF_HEX:	db 0
 39101                                  TABLE_INDEX:	db 0
 39102                                  PRINTF_WIDTH:	dw 0
 39103                                  PRINTF_BASE:	dw 0
 39104                                  PAD_CHAR:	db 0
 39105                                  PRINTF_HANDLE:	dw 0
 39106                                  PRINTF_BUF: times 100 db 0
 39107                                  PRINTF_BUF_END: ; 30/09/2018
 39108                                  
 39109                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 39110                                  
 39111                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39112                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39113                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39114                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39115                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39116                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39117                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39118                                  
 39119                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39120                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 39121                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 39122                                  TPA:		dw 0			; LTPA	    (dw 0)	
 39123                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 39124                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 39125                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 39126                                  					; MYSEG1    (dw 0)	
 39127                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 39128                                  					; MYSEG2    (dw 0)	
 39129                                  		dw 0			; RESTEST   (dw 0)	
 39130                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 39131                                  
 39132                                  CHKDRV:		db 0
 39133                                  IFNOTFLAG:
 39134                                  FILTYP:
 39135                                  RDEOF:		db 0			; Misc flags
 39136                                  CURDRV:		db 0
 39137                                  PARM1:
 39138                                  Concat:		db 0
 39139                                  PARM2:
 39140                                  ArgC:		db 0
 39141                                  COMSW:		dw 0			; Switches between command and 1st arg
 39142                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 39143                                  ARG2S:					; Switches after 2nd arg		
 39144                                  DestSwitch:	dw 0
 39145                                  ARGTS:
 39146                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 39147                                  CFLAG:		db 0
 39148                                  DestClosed:
 39149                                  SPECDRV:	db 0
 39150                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 39151                                  NXTADD:		dw 0
 39152                                  FRSTSRCH:	db 0
 39153                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 39154                                  ;PerLine:	db 0			; entries/line u.b. DIR
 39155                                  LINCNT:		db 0
 39156                                  LINLEN:		db 0
 39157                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 39158                                  FILECNT:	dw 0			; file count u.b. DIR
 39159                                  ;FileSiz:	dd 0			; file size u.b. DIR
 39160                                  
 39161                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 39162                                  ;
 39163                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 39164                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 39165                                  
 39166                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 39167                                  
 39168                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 39169                                  DESTFCB2:
 39170                                  IDLEN:		db 0
 39171                                  ID:	  times	8  db 0
 39172                                  COM:	  times	3  db 0 
 39173                                  DEST:	  times 37 db 0
 39174                                  DESTNAME: times 11 db 0
 39175                                  DESTDIR:
 39176                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 39177                                  GOTOLEN:	; word
 39178                                  BWDBUF: 	; byte
 39179                                  EXEFCB: 	; word
 39180                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39181                                  
 39182                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39183                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39184                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39185                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39186                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39187                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39188                                  
 39189                                  SDIRBUF:  times 12 db 0	
 39190                                  _BITS:		dw 0
 39191                                  PATHCNT:	dw 0
 39192                                  PATHPOS:	dw 0
 39193                                  PATHSW:		dw 0
 39194                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 39195                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 39196                                  LINPERPAG:	db 0
 39197                                  		db 0
 39198                                  COMMA:		db 0			; flag set if +,, occurs
 39199                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 39200                                  
 39201                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 39202                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 39203                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 39204                                  
 39205                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 39206                                  STRING_PTR_1:	dw 0	   ; _4468h	
 39207                                  FILESIZE_L:	dw 0	   ; _446Ah		
 39208                                  FILESIZE_H:	dw 0	   ; _446Ch	
 39209                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 39210                                  
 39211                                  COPY_NUM:	dw 0
 39212                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 39213                                  CPYFLAG:	db 0
 39214                                  DIR_NUM:	dw 0
 39215                                  BYTES_FREE:	dw 0
 39216                                  		dw 0
 39217                                  MAJOR_VER_NUM:	dw 0
 39218                                  MINOR_VER_NUM:	dw 0
 39219                                  ONE_CHAR_VAL:	db 0
 39220                                  		;db 0
 39221                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 39222                                  VOL_DRV:	db 0
 39223                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 39224                                  
 39225                                  ROM_CALL:	db 0			; flag for rom function
 39226                                  ROM_IP:		dw 0
 39227                                  ROM_CS:		dw 0
 39228                                  
 39229                                  DestVars:
 39230                                  DestIsDir:	db 0
 39231                                  DestSiz:	db 0
 39232                                  DestTail:	dw 0
 39233                                  DestInfo:	db 0
 39234                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 39235                                  ENDDESTBUF:
 39236                                  
 39237                                  DESTHAND:	dw 0
 39238                                  DESTISDEV:	db 0
 39239                                  FIRSTDEST:	db 0
 39240                                  MELCOPY:	db 0
 39241                                  MELSTART:	dw 0
 39242                                  
 39243                                  SrcVars:
 39244                                  SrcIsDir:	db 0
 39245                                  SrcSiz:		db 0
 39246                                  SrcTail:	dw 0
 39247                                  SrcInfo:	db 0
 39248                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 39249                                  
 39250                                  SRCHAND:	dw 0
 39251                                  SRCISDEV:	db 0
 39252                                  
 39253                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 39254                                  
 39255                                  SRCPT:		dw 0
 39256                                  INEXACT:	db 0
 39257                                  		db 0 ; MSDOS 3.3 
 39258                                  NOWRITE:	db 0
 39259                                  BINARY:		db 0
 39260                                  WRITTEN:	dw 0
 39261                                  TERMREAD:	db 0
 39262                                  ASCII:		db 0
 39263                                  PLUS:		db 0
 39264                                  OBJCNT:		db 0			; Used in copy
 39265                                  CPDATE:		dw 0
 39266                                  CPTIME:		dw 0
 39267                                  
 39268                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 39269                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 39270                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39271                                  
 39272                                  BATHAND:	dw 0			; Batch handle
 39273                                  STARTEL:	dw 0
 39274                                  ELCNT:		db 0
 39275                                  ELPOS:		db 0
 39276                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39277                                  MSDOS 5.0
 39278                                  SKPDEL:
 39279                                  SOURCE:   times	11 db 0
 39280                                  
 39281                                  ext_entered:	db 0			;AN005;
 39282                                  
 39283                                  ;display_ioctl	db 0			;AN000; info level
 39284                                  ;		db 0			;AN000; reserved
 39285                                  ;		dw crt_ioctl_ln		;AN000; length of data
 39286                                  ;		dw 0			;AN000; control flags
 39287                                  ;display_mode:	db 0			;AN000; display mode, colors
 39288                                  ;		db 0			;AN000; reserved
 39289                                  ;		dw 0			;AN023; colors
 39290                                  ;		dw 0			;AN000; display width (PELS)
 39291                                  ;		dw 0			;AN000; display length (PELS)
 39292                                  ;display_width:	dw 0			;AN000; display width
 39293                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 39294                                  ;
 39295                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 39296                                  ;		dw 0			;AN000; info level
 39297                                  ;vol_serial:	dd 0			;AN000; volume serial number
 39298                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39299                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 39300                                  
 39301                                  EXPAND_STAR:	db 0
 39302                                  
 39303                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 39304                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 39305                                  ;append_exec:	db 0			;AN041; set if internal append executed
 39306                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 39307                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 39308                                  
 39309                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 39310                                  
 39311                                  ; Data declarations taken out of parse.asm
 39312                                  
 39313                                  ; MSDOS 6.0
 39314                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39315                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39316                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 39317                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39318                                  ;comptr		dw	?		; ptr into combuf
 39319                                  
 39320                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 39321                                  ARG:
 39322                                  ARG_ARGV:
 39323                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 39324                                  ARGV0_ARG_FLAGS:  db 0
 39325                                  ARGV0_ARGSTARTEL: dw 0
 39326                                  ARGV0_ARGLEN:	  dw 0
 39327                                  ARGV0_ARGSW_WORD: dw 0
 39328                                  ARGV0_OCOMPTR:	  dw 0
 39329                                  
 39330                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 39331                                  	  times 5 db 0
 39332                                  ARGV1_ARGSW_WORD: dw 0
 39333                                  		  dw 0
 39334                                  
 39335                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 39336                                  	  times 5 db 0
 39337                                  ARGV2_ARGSW_WORD: dw 0
 39338                                  		  dw 0
 39339                                  
 39340                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 39341                                  	
 39342                                  ARG_ARGVCNT:	dw 0
 39343                                  ARG_ARGSWINFO:	dw 0
 39344                                  
 39345                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 39346                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 39347                                  
 39348                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 39349                                  
 39350                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 39351                                  TPBUF:	times 128 db 0			; temporary buffer
 39352                                  LASTARG:	dw 0			; point at which to accumulate switch info
 39353                                  COMPTR:		dw 0			; ptr into combuf
 39354                                  
 39355                                  ; Data declarations taken out of path.asm
 39356                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 39357                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 39358                                  ;psep_char	DB	?			; '/' or '\'
 39359                                  ;search_best	DB	(?)			; best code, best filename so far
 39360                                  ;fname_max_len	equ	13
 39361                                  ;search_best_buf DB	fname_max_len DUP (?)
 39362                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 39363                                  ;search_error	DW	(?)			; address of error message to be printed
 39364                                  
 39365                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39366                                  
 39367                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 39368                                  
 39369                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 39370                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 39371                                  PATHINFO:
 39372                                  PATHINFO_0:	dw 0
 39373                                  PATHINFO_2:	dw 0
 39374                                  PATHINFO_4:	dw 0
 39375                                  PSEP_CHAR:	db 0
 39376                                  SEARCH_BEST:	db 0
 39377                                  ;FNAME_MAX_LEN equ 13
 39378                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 39379                                  SEARCH_CURDIR_BUF: times 64 db 0
 39380                                  SEARCH_ERROR:	dw 0
 39381                                  
 39382                                  ; Data declarations taken out of tbatch.asm
 39383                                  
 39384                                  ;if_not_count	DW	?
 39385                                  ;
 39386                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39387                                  ;
 39388                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39389                                  
 39390                                  ; 31/03/2023
 39391                                  STACK:		;LABEL	WORD
 39392                                  
 39393                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 39394                                  
 39395                                  IF_NOT_COUNT:	dw 0
 39396                                  ZFLAG:		db 0
 39397                                  	  times 256 db 0 	
 39398                                  STACK:
 39399                                  
 39400                                  ;INTERNATVARS	internat_block <>
 39401                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39402                                  ;
 39403                                  ;;		Buffer for DOS function 64h (Get extended country information)
 39404                                  ;;		subfunctions 2, 4, 6, or 7:
 39405                                  ;
 39406                                  ;CountryPtrInfo	label	byte
 39407                                  ;CountryPtrId	db	?
 39408                                  ;CountryPtr	dd	?
 39409                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39410                                  
 39411                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 39412                                  
 39413                                  INTERNATVARS:	
 39414                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 39415                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39416                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 39417                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 39418                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 39419                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 39420                                  BIT_FIELD:	db 0			; Bit values
 39421                                  					;   Bit 0 = 0 if currency symbol first
 39422                                  					;	  = 1 if currency symbol last
 39423                                  					;   Bit 1 = 0 if No space after currency symbol
 39424                                  					;	  = 1 if space after currency symbol
 39425                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 39426                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39427                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39428                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39429                                  					;  in pieces.
 39430                                  DATA_SEP:	db 0,0			; Data list separator character		
 39431                                  
 39432                                  		times 8 db 0
 39433                                  ;
 39434                                  ; Max size of the block returned by the INTERNATIONAL call
 39435                                  ;
 39436                                  INTERNAT_BLOCK_SIZE EQU	32
 39437                                  
 39438                                  BATLEN equ 32
 39439                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 39440                                  
 39441                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 39442                                  
 39443                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 39444                                  
 39445                                  BATBUFEND:	dw 0
 39446                                  
 39447                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 39448                                  
 39449                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 39450                                  
 39451                                  ; 18/04/2023
 39452                                  ; ----------------------------------------------------------------------------
 39453                                  ; 09/01/2023
 39454                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 39455                                  
 39456                                  %endif
 39457                                  
 39458                                  ;============================================================================
 39459                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39460                                  ;============================================================================
 39461                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39462                                  
 39463                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39464                                  
 39465                                  ;The TRANSPACE segment contains variable data that is considered
 39466                                  ;volatile between command cycles, and therefore is not included in the
 39467                                  ;transient checksum area. Contents of these variables MUST be
 39468                                  ;initialized before use, and must not be relied upon from command
 39469                                  ;cycle to command cycle.
 39470                                  ;
 39471                                  ;No constant data values should be stored here.
 39472                                  
 39473                                  ; ---------------------------------------------------------------------------
 39474                                  ; START OF UNITIALIZED DATA
 39475                                  ; ---------------------------------------------------------------------------
 39476                                  
 39477                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 39478                                  
 39479 000087F3 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39480 0000884A 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39481 000088A1 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39482 00008924 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39483 000089A7 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39484 000089ED 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39485 00008A70 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39486                                  
 39487                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39488                                  HEADCALL:
 39489 00008AC3 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 39490 00008AC5 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 39491 00008AC7 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 39492                                  SWITCHAR:
 39493 00008AC9 00                      	db 0			; RSWITCHAR (db '-')
 39494                                  DIRCHAR:
 39495 00008ACA 00                      	db 0			; RDIRCHAR  (db '/')
 39496                                  EXEC_ADDR:
 39497 00008ACB 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 39498                                  				; MYSEG1    (dw 0)	
 39499                                  RCH_ADDR:
 39500 00008ACF 00000000                	dd 0			;	    (dw TREMCHECK) 	
 39501                                  				; MYSEG2    (dw 0)	
 39502 00008AD3 0000                    	dw 0			; RESTEST   (dw 0)	
 39503                                  TRAN_TPA:
 39504 00008AD5 0000                    	dw 0			; RES_TPA   (dw 0)	
 39505                                  
 39506 00008AD7 00                      CHKDRV:	db 0
 39507                                  IFNOTFLAG:
 39508                                  FILTYP:
 39509 00008AD8 00                      RDEOF:	db 0			; Misc flags
 39510 00008AD9 00                      CURDRV:	db 0
 39511                                  PARM1:
 39512 00008ADA 00                      Concat:	db 0
 39513                                  PARM2:
 39514 00008ADB 00                      ArgC:	db 0
 39515 00008ADC 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39516 00008ADE 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39517                                  ARG2S:				; Switches after 2nd arg		
 39518                                  DestSwitch:
 39519 00008AE0 0000                    	dw 0
 39520                                  ARGTS:
 39521                                  AllSwitch:
 39522 00008AE2 0000                    	dw 0			; ALL switches except for COMSW
 39523 00008AE4 00                      CFLAG:	db 0
 39524                                  DestClosed:
 39525                                  SPECDRV:
 39526 00008AE5 00                      	db 0
 39527 00008AE6 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39528 00008AE8 0000                    NXTADD:	dw 0
 39529                                  FRSTSRCH:
 39530 00008AEA 00                      	db 0
 39531                                  ; 15/04/2023
 39532                                  LeftOnLine:
 39533 00008AEB 00                      	db 0			; entries left on line u.b. DIR
 39534                                  PerLine:
 39535 00008AEC 00                      	db 0			; entries/line u.b. DIR
 39536 00008AED 00                      LINCNT:	db 0
 39537 00008AEE 00                      LINLEN:	db 0
 39538                                  LeftOnPage:
 39539 00008AEF 0000                    	dw 0			; lines left on page u.b. DIR
 39540                                  FileCnt:
 39541 00008AF1 0000                    	dw 0			; file count u.b. DIR
 39542                                  FileSiz:
 39543 00008AF3 00000000                	dd 0			; file size u.b. DIR
 39544                                  
 39545                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39546                                  
 39547                                  FileCntTotal:
 39548 00008AF7 00000000                	dd 0			; total file count u.b. DIR
 39549                                  FileSizTotal:
 39550 00008AFB 00000000                	dd 0			; total file size u.b. DIR
 39551                                  
 39552                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39553                                  CHARBUF:
 39554 00008AFF 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39555                                  DESTFCB2:
 39556 00008B4F 00                      IDLEN:	db 0
 39557 00008B50 00<rep 8h>              ID:	times	8  db 0
 39558 00008B58 00<rep 3h>              COM:	times	3  db 0 
 39559 00008B5B 00<rep 25h>             DEST:	times	37 db 0
 39560                                  DESTNAME:
 39561 00008B80 00<rep Bh>              	times	11 db 0
 39562                                  DESTDIR:
 39563                                  DestFcb:
 39564 00008B8B 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39565                                  GOTOLEN: ; word
 39566                                  BWDBUF:  ; byte
 39567                                  EXEFCB:  ; word
 39568 00008BCE 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39569                                  
 39570                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39571                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39572                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39573                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39574                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39575                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39576                                  
 39577                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39578                                  SDIRBUF:
 39579 00008C14 00<rep Ch>              	times 12 db 0	
 39580                                  _Bits:
 39581 00008C20 0000                    	dw 0
 39582                                  PathCnt:
 39583 00008C22 0000                    	dw 0
 39584                                  PathPos:
 39585 00008C24 0000                    	dw 0
 39586 00008C26 0000                    PathSw:	dw 0
 39587                                  AttrSpecified:
 39588 00008C28 00                      	db 0			; attribute bits u.b. DIR
 39589                                  AttrSelect:
 39590 00008C29 00                      	db 0			; attribute bits u.b. DIR
 39591 00008C2A 00                      comma:	db 0			; flag set if +,, occurs
 39592                                  plus_comma:
 39593 00008C2B 00                      	db 0			; flag set if +,, occurs
 39594                                  DirFlag:
 39595 00008C2C 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39596                                  parse_last:
 39597 00008C2D 0000                    	dw 0			;AN018; used to hold parsing position
 39598                                  system_cpage:
 39599 00008C2F 0000                    	dw 0			;AC001; used for CHCP variable
 39600                                  ; 03/08/2024
 39601                                  ;Arg_Buf:
 39602                                  ;	times 128 db 0	
 39603                                  File_Size_Low:
 39604 00008C31 0000                    	dw 0	
 39605                                  File_Size_High:
 39606 00008C33 0000                    	dw 0		
 39607                                  string_ptr_2:
 39608 00008C35 0000                    	dw 0	
 39609                                  Copy_num:
 39610 00008C37 0000                    	dw 0
 39611                                  cpyflag:
 39612 00008C39 00                      	db 0
 39613                                  Dir_Num:
 39614 00008C3A 0000                    	dw 0
 39615                                  Bytes_Free:
 39616 00008C3C 00000000                	dd 0
 39617                                  
 39618                                  Major_Ver_Num:
 39619 00008C40 0000                    	dw 0
 39620                                  Minor_Ver_Num:
 39621 00008C42 0000                    	dw 0
 39622                                  
 39623                                  One_Char_Val:
 39624 00008C44 00                      	db 0
 39625 00008C45 00                      	db 0
 39626                                  vol_drv:
 39627 00008C46 00                      	db 0
 39628                                  ROM_CALL:
 39629 00008C47 00                      	db 0			; flag for rom function
 39630 00008C48 0000                    ROM_IP:	dw 0
 39631 00008C4A 0000                    ROM_CS:	dw 0
 39632                                  
 39633                                  DestVars:
 39634                                  DestIsDir:
 39635 00008C4C 00                      	db 0
 39636                                  DestSiz:
 39637 00008C4D 00                      	db 0
 39638                                  DestTail:
 39639 00008C4E 0000                    	dw 0
 39640                                  DestInfo:
 39641 00008C50 00                      	db 0
 39642                                  DestBuf:
 39643 00008C51 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39644                                  EndDestBuf:
 39645                                  DESTHAND:
 39646 00008CA8 0000                    	dw 0
 39647                                  DESTISDEV:
 39648 00008CAA 00                      	db 0
 39649                                  FIRSTDEST:
 39650 00008CAB 00                      	db 0
 39651                                  MELCOPY:
 39652 00008CAC 00                      	db 0
 39653                                  MELSTART:
 39654 00008CAD 0000                    	dw 0
 39655                                  SrcVars:
 39656                                  SrcIsDir:
 39657 00008CAF 00                      	db 0
 39658 00008CB0 00                      SrcSiz:	db 0
 39659                                  SrcTail:
 39660 00008CB1 0000                    	dw 0
 39661                                  SrcInfo:
 39662 00008CB3 00                      	db 0
 39663                                  SrcBuf:
 39664 00008CB4 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39665                                  SRCHAND:
 39666 00008D0B 0000                    	dw 0
 39667                                  SRCISDEV:
 39668 00008D0D 00                      	db 0
 39669                                  ScanBuf:
 39670 00008D0E 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39671                                  
 39672 00008D65 0000                    SRCPT:	dw 0
 39673                                  INEXACT:
 39674 00008D67 00                      	db 0
 39675                                  NOWRITE:
 39676 00008D68 00                      	db 0
 39677                                  BINARY:
 39678 00008D69 00                      	db 0
 39679                                  WRITTEN:
 39680 00008D6A 0000                    	dw 0
 39681                                  TERMREAD:
 39682 00008D6C 00                      	db 0
 39683 00008D6D 00                      ASCII:	db 0
 39684 00008D6E 00                      PLUS:	db 0
 39685 00008D6F 00                      objcnt:	db 0			; Used in copy
 39686 00008D70 0000                    CPDATE:	dw 0
 39687 00008D72 0000                    CPTIME:	dw 0
 39688                                  
 39689                                  OFilePtr_Lo:
 39690 00008D74 0000                    	dw 0			; original file ptr for COPY when
 39691                                  OFilePtr_Hi:
 39692 00008D76 0000                    	dw 0			; 1st source is also destination
 39693 00008D78 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39694                                  BATHAND:
 39695 00008D79 0000                    	dw 0			; Batch handle
 39696                                  STARTEL:
 39697 00008D7B 0000                    	dw 0
 39698 00008D7D 00                      ELCNT:	db 0
 39699 00008D7E 00                      ELPOS:	db 0
 39700                                  
 39701                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39702                                  ; MSDOS 5.0
 39703                                  SKPDEL:
 39704 00008D7F 00<rep Bh>              SOURCE:	times 11 db 0
 39705                                  
 39706                                  ext_entered:
 39707 00008D8A 00                      	db 0			;AN005;
 39708                                  
 39709                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39710                                  
 39711                                  Display_Ioctl:
 39712 00008D8B 00                      	db 0			;AN000; info level
 39713 00008D8C 00                      	db 0			;AN000; reserved
 39714 00008D8D 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39715 00008D8F 0000                    	dw 0			;AN000; control flags
 39716                                  display_mode:
 39717 00008D91 00                      	db 0			;AN000; display mode, colors
 39718 00008D92 00                      	db 0			;AN000; reserved
 39719 00008D93 0000                    	dw 0			;AN023; colors
 39720 00008D95 0000                    	dw 0			;AN000; display width (PELS)
 39721 00008D97 0000                    	dw 0			;AN000; display length (PELS)
 39722                                  display_width:
 39723 00008D99 0000                    	dw 0			;AN000; display width
 39724                                  LinPerPag:
 39725 00008D9B 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39726                                  
 39727                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39728 00008D9D 0000                    	dw 0			;AN000; info level
 39729                                  vol_serial:
 39730 00008D9F 00000000                	dd 0			;AN000; volume serial number
 39731                                  vol_label:
 39732 00008DA3 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39733 00008DAE 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39734                                  
 39735                                  expand_star:
 39736 00008DB6 00                      	db 0
 39737                                  
 39738                                  msg_flag:
 39739 00008DB7 00                      	db 0			;AN022; flag set if non-utility message issued
 39740                                  Msg_Numb:
 39741 00008DB8 0000                    	dw 0			;AN022; set with extended error message issued
 39742                                  append_exec:
 39743 00008DBA 00                      	db 0			;AN041; set if internal append executed
 39744                                  print_err_flag:
 39745 00008DBB 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39746                                  subst_buffer:
 39747 00008DBD 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39748                                  				;AN061;
 39749                                  ; 15/04/2023
 39750 00008DD3 00                      KPARSE:	db 0	; 3/3/KK	
 39751                                  
 39752                                  ; Data declarations taken out of parse.asm
 39753                                  
 39754                                  ; MSDOS 6.0
 39755                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39756                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39757                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39758                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39759                                  ;comptr		dw	?		; ptr into combuf
 39760                                  
 39761                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39762                                  ARG:
 39763                                  ARG_ARGV:
 39764                                  ARGV0_ARGPOINTER:
 39765 00008DD4 0000                    	dw 0	; ARGV[0]
 39766                                  ARGV0_ARG_FLAGS:
 39767 00008DD6 00                      	db 0
 39768                                  ARGV0_ARGSTARTEL:
 39769 00008DD7 0000                    	dw 0
 39770                                  ARGV0_ARGLEN:
 39771 00008DD9 0000                    	dw 0
 39772                                  ARGV0_ARGSW_WORD:
 39773 00008DDB 0000                    	dw 0
 39774                                  ARGV0_OCOMPTR:
 39775 00008DDD 0000                    	dw 0
 39776                                  ARGV1_ARGPOINTER:
 39777 00008DDF 0000                    	dw 0	; ARGV[1]	
 39778 00008DE1 00<rep 5h>              	times 5 db 0
 39779                                  ARGV1_ARGSW_WORD:
 39780 00008DE6 0000                    	dw 0
 39781 00008DE8 0000                    	dw 0
 39782                                  ARGV2_ARGPOINTER:
 39783 00008DEA 0000                    	dw 0	; ARGV[2]
 39784 00008DEC 00<rep 5h>              	times 5 db 0
 39785                                  ARGV2_ARGSW_WORD:
 39786 00008DF1 0000                    	dw 0
 39787 00008DF3 0000                    	dw 0
 39788 00008DF5 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39789                                  ARG_ARGVCNT:
 39790 00009094 0000                    	dw 0
 39791                                  ARG_ARGSWINFO:
 39792 00009096 0000                    	dw 0
 39793                                  ARG_ARGBUF:
 39794 00009098 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39795                                  ARG_ARGFORCOMBUF:
 39796 00009298 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39797                                  
 39798                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39799                                  ARGBUF_PTR:
 39800 00009318 0000                    	dw 0			; index for argv[].argpointer
 39801                                  TPBUF:	;times 128 db 0		; temporary buffer
 39802                                  Arg_Buf:
 39803 0000931A 00<rep 80h>             	times 128 db 0	; 03/08/2024 (PCDOS 7.1 COMMAND.COM)
 39804                                  LASTARG:
 39805 0000939A 0000                    	dw 0			; point at which to accumulate switch info
 39806 0000939C 0000                    COMPTR:	dw 0			; ptr into combuf
 39807                                  
 39808                                  ; Data declarations taken out of path.asm
 39809                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39810                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39811                                  ;psep_char	DB	?		; '/' or '\'
 39812                                  ;search_best	DB	(?)		; best code, best filename so far
 39813                                  ;fname_max_len	equ	13
 39814                                  ;search_best_buf DB	fname_max_len DUP (?)
 39815                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39816                                  ;search_error	DW	(?)		; address of error message to be printed
 39817                                  
 39818                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39819                                  
 39820                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39821                                  
 39822 0000939E 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39823                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39824                                  pathinfo:
 39825                                  ;pathinfo_0:
 39826 000093C9 0000                    	dw 0
 39827                                  ;pathinfo_2:
 39828 000093CB 0000                    	dw 0
 39829                                  ;pathinfo_4:
 39830 000093CD 0000                    	dw 0
 39831                                  psep_char:
 39832 000093CF 00                      	db 0
 39833                                  search_best:
 39834 000093D0 00                      	db 0
 39835                                  FNAME_MAX_LEN equ 13
 39836                                  search_best_buf:
 39837 000093D1 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39838                                  search_curdir_buf:
 39839 000093DE 00<rep 40h>             	times 64 db 0
 39840                                  search_error:
 39841 0000941E 0000                    	dw 0
 39842                                  
 39843                                  ; Data declarations taken out of tbatch.asm
 39844                                  
 39845                                  ;if_not_count	DW	?
 39846                                  ;
 39847                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39848                                  ;
 39849                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39850                                  
 39851                                  ; 31/03/2023
 39852                                  ;STACK:	;LABEL	WORD
 39853                                  
 39854                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 39855                                  
 39856                                  IF_NOT_COUNT:
 39857 00009420 0000                    	dw 0
 39858 00009422 00                      zflag:	db 0
 39859 00009423 00<rep 100h>            	times 256 db 0 
 39860                                  	; 16/04/2023
 39861                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 39862                                  STACK:
 39863                                  
 39864                                  ;INTERNATVARS	internat_block <>
 39865                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39866                                  
 39867                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 39868                                  INTERNATVARS:
 39869                                  		; (24+8 = 32 bytes)
 39870                                  DATE_TIME_FORMAT:
 39871 00009523 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 39872                                  CURRENCY_SYM:
 39873 00009525 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39874                                  THOUS_SEP:
 39875 0000952A 0000                    	db 0,0			; Thousands separator 2 bytes
 39876                                  DECIMAL_SEP:
 39877 0000952C 0000                    	db 0,0			; Decimal separator 2 bytes
 39878                                  DATE_SEP:
 39879 0000952E 0000                    	db 0,0			; Date separator 2 bytes
 39880                                  TIME_SEP:
 39881 00009530 0000                    	db 0,0			; Time separator 2 bytes	
 39882                                  BIT_FIELD:
 39883 00009532 00                      	db 0			; Bit values
 39884                                  				;   Bit 0 = 0 if currency symbol first
 39885                                  				;	  = 1 if currency symbol last
 39886                                  				;   Bit 1 = 0 if No space after currency symbol
 39887                                  				;	  = 1 if space after currency symbol
 39888                                  CURRENCY_CENTS:
 39889 00009533 00                      	db 0			; Number of places after currency dec point
 39890                                  TIME_24:
 39891 00009534 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39892                                  MAP_CALL:
 39893 00009535 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39894                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39895                                  				;  in pieces.
 39896                                  DATA_SEP:
 39897 00009539 0000                    	db 0,0			; Data list separator character		
 39898                                  
 39899 0000953B 00<rep 8h>              	times 8 db 0
 39900                                  
 39901                                  ; Max size of the block returned by the INTERNATIONAL call
 39902                                  
 39903                                  INTERNAT_BLOCK_SIZE EQU	32
 39904                                  
 39905                                  ;;	Buffer for DOS function 64h (Get extended country information)
 39906                                  ;;	subfunctions 2, 4, 6, or 7:
 39907                                  ;
 39908                                  ;CountryPtrInfo	label	byte
 39909                                  ;CountryPtrId	db	?
 39910                                  ;CountryPtr	dd	?
 39911                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39912                                  	
 39913                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 39914                                  CountryPtrInfo:
 39915                                  CountryPtrId:	
 39916 00009543 00                      	db 0
 39917                                  CountryPtr:
 39918 00009544 00000000                	dd 0
 39919                                  
 39920                                  OldCtrlCHandler:
 39921 00009548 00000000                	dd 0			; previous int 23 vector		
 39922                                  
 39923                                  BATLEN equ 32
 39924                                  
 39925                                  BATBUFPOS:
 39926 0000954C 0000                    	dw 0			; integer position in buffer of next byte
 39927                                  
 39928 0000954E 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 39929                                  BATBUFEND:
 39930 0000956E 0000                    	dw 0
 39931                                  TypeFilSiz:
 39932 00009570 00000000                	dd 0			; stores size of file to be typed
 39933                                  
 39934                                  ; *****************************************************
 39935                                  ; EMG 4.00
 39936                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 39937                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 39938                                  ; *****************************************************
 39939                                  ;
 39940                                  ; COMMON PARSE OUTPUT BLOCKS
 39941                                  
 39942                                  ; Common output blocks for PARSE number, complex, or string values.
 39943                                  
 39944                                  PARSE1_OUTPUT:
 39945                                  PARSE1_TYPE:
 39946 00009574 00                      	db 0			;AN000;  type
 39947                                  PARSE1_CODE:
 39948 00009575 00                      	db 0			;AN000;  return value
 39949                                  PARSE1_SYN:
 39950 00009576 0000                    	dw 0			;AN000;  es offset of synonym
 39951                                  PARSE1_ADDR:
 39952 00009578 00000000                	dd 0			;AN000;  numeric value / address
 39953                                  				;	 of string value
 39954                                  
 39955                                  ;  Common output block for PARSE date strings.
 39956                                  
 39957                                  DATE_OUTPUT:
 39958                                  DATE_TYPE:
 39959 0000957C 00                      	db 0			;AN000;  type
 39960 0000957D 00                      	db 0			;AN000;  return value
 39961 0000957E 0000                    	dw 0			;AN000;  es offset of synonym
 39962                                  DATE_YEAR:
 39963 00009580 0000                    	dw 0			;AN000;  year
 39964                                  DATE_MONTH:
 39965 00009582 00                      	db 0			;AN000;  month
 39966                                  DATE_DAY:
 39967 00009583 00                      	db 0			;AN000;  day
 39968                                  
 39969                                  ;  Common output block for PARSE time strings.
 39970                                  
 39971                                  TIME_OUTPUT:
 39972                                  TIME_TYPE:
 39973 00009584 00                      	db 0			;AN000;  type
 39974 00009585 00                      	db 0			;AN000;  return value
 39975 00009586 0000                    	dw 0			;AN000;  es offset of synonym
 39976                                  TIME_HOUR:
 39977 00009588 00                      	db 0			;AN000;  hour
 39978                                  TIME_MINUTES:
 39979 00009589 00                      	db 0			;AN000;  minutes
 39980                                  TIME_SECONDS:
 39981 0000958A 00                      	db 0			;AN000;  seconds
 39982                                  TIME_FRACTION:
 39983 0000958B 00                      	db 0			;AN000;  hundredths
 39984                                  
 39985                                  ;  Common output block for PARSE drive specifier (one based drive number).
 39986                                  
 39987                                  DRIVE_OUTPUT:
 39988                                  DRIVE_TYPE:
 39989 0000958C 00                      	db 0			;AN000;  type
 39990                                  DRIVE_VALUE:
 39991 0000958D 00                      	db 0			;AN000;  return value
 39992 0000958E 0000                    	dw 0			;AN000;  es offset of synonym
 39993                                  DRIVE_NUMBER:
 39994 00009590 00                      	db 0			;AN000;  drive number
 39995 00009591 000000                  	db 0,0,0		;AN000;  reserved
 39996                                  
 39997                                  	; 18/04/2023
 39998                                  	; 16/04/2023
 39999                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 40000                                  
 40001                                  ; ----------------------------------------------------------------------------
 40002                                  ; 20/04/2023
 40003                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
