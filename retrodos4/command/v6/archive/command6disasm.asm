

;
; ÉÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ»
; º	This file is generated by The Interactive Disassembler (IDA)	    º
; º	Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>	    º
; º			 Licensed to: Freeware version			    º
; ÈÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ¼
;
; Input	MD5   :	FAF051453F215165981F10BD73071D88

; File Name   :	C:\Users\Erdoğan\Desktop\COMMAND.COM
; Format      :	MS-DOS COM-file
; Base Address:	0h Range: 100h-D675h Loaded length: D575h

		.686p
		.mmx
		.model tiny

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure code
RESGROUP	segment	byte public 'CODE' use16
		assume cs:RESGROUP
		;org 100h
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


StartCode	proc near

; FUNCTION CHUNK AT 017E SIZE 0000000A BYTES
; FUNCTION CHUNK AT 03EA SIZE 000000CD BYTES
; FUNCTION CHUNK AT 1670 SIZE 000002FA BYTES
; FUNCTION CHUNK AT 196D SIZE 000003B2 BYTES

		jmp	ConProc
StartCode	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
VersionByte	db 66h
Int2f_Entry	dd MsgInt2fHandler	; ...
Int2e_Entry	dd Int_2e		; ...
Ctrlc_Entry	dd ContC		; ...
CritErr_Entry	dd DskErr		; ...
Exec_Entry	dd 0			; ...
RemCheck_Entry	dd 0			; ...
TrnLodCom1_Entry dd 0			; ...
LodCom_Entry	dd 0			; ...
MsgRetrv_Entry	dd 0			; ...
HeadFix_Entry	dd 0			; ...
UMBOff_Entry	dd 0
XMMCallAddr	dd 0			; ...
ComInHMA	db 0			; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int2f_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Int2f_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int2e_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Int2e_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ctrlc_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Ctrlc_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CritErr_Trap:				; ...
		sti
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:CritErr_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:Exec_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RemCheck_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:RemCheck_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TrnLodCom1_Trap:			; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:TrnLodCom1_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR StartCode

LodCom_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:LodCom_Entry
; END OF FUNCTION CHUNK	FOR StartCode
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgRetrv_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:MsgRetrv_Entry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HeadFix_Trap:				; ...
		call	CheckA20
		push	ds
		push	cs
		jmp	cs:HeadFix_Entry

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckA20	proc near		; ...
		pushf
		cmp	cs:ComInHMA, 0
		jz	short A20_on
		call	QueryA20
		jnb	short A20_on
		call	EnableA20

A20_on:					; ...
		popf
		retn
CheckA20	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Carousel_i2f_Hook:			; ...
		jmp	far ptr	Int2f_Trap

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


QueryA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 7
		call	cs:XMMCallAddr
		or	ax, ax
		pop	ax
		pop	bx
		jnz	short QA20_ON
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

QA20_ON:				; ...
		clc
		retn
QueryA20	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


EnableA20	proc near		; ...
		push	bx
		push	ax
		mov	ah, 5
		call	cs:XMMCallAddr
		or	ax, ax
		jz	short XMMerror
		pop	ax
		pop	bx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

XMMerror:				; ...
		jmp	short XMMerror
EnableA20	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UnHideUMBs	proc near		; ...
		push	ax		; Marks	HIDDEN elements	as FREE
		push	ds
		mov	al, ds:fInHigh
		pop	ds
		or	al, al
		jnz	short uhu10
		pop	ax
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

uhu10:					; ...
		call	linkumb		; Make sure UMBs are linked in.
		call	FreeUMBs
		push	es
		mov	es:fInHigh, 0
		pop	es
		call	he_unlink	; Unlink UMBs
		pop	ax
		clc
		retn
UnHideUMBs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


he_unlink	proc near		; ...
		xor	bh, bh		; unlinks UMBs if fm_umb is set	to 0
		push	ds
		mov	bl, ds:fm_umb
		pop	ds
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		xor	bh, bh
		push	ds
		mov	bl, ds:fm_strat
		pop	ds
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		retn
he_unlink	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FreeUMBs	proc near		; ...
		push	ax		; frees	all HIDDEN memory elements in upper-memory
		push	es
		call	HeadUmb		; Returns with carry if	err, else ES ==	MCB
		jb	short fusX
		mov	es, ax

fus10:					; ...
		call	isHideMCB	; Returns with ZF set if owner is 0
		jnz	short fus20
		call	freeMCB		; Marks	as free	the MCB	at ES:0

fus20:					; ...
		mov	al, es:0	; [es:arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short fusX	; That means this was the last MCB.
		mov	ax, es
		add	ax, es:3	; [es:arena_size]
		inc	ax
		mov	es, ax
		jmp	short fus10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fusX:					; ...
		pop	es
		pop	ax
		retn
FreeUMBs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isHideMCB	proc near		; ...
		push	ax
		cmp	word ptr es:1, 8 ; cmp word [es:arena_owner],SystemPSPOwner
		jnz	short ihm_x
		mov	ax, es:8	; [es:arena_name]
		cmp	ax, 'IH'        ; HIDDEN
		jnz	short ihm_x
		mov	ax, es:0Ah	; [es:arena_name+2]
		cmp	ax, 'DD'
		jnz	short ihm_x
		mov	ax, es:0Ch	; [es:arena_name+4]
		cmp	ax, 'NE'
		jnz	short ihm_x
		mov	ax, es:0Eh	; [es:arena_name+6]
		cmp	ax, '  '

ihm_x:					; ...
		pop	ax
		retn
isHideMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


freeMCB		proc near		; ...
		mov	word ptr es:1, 0 ; mov word [es:arena_owner],0
		mov	ax, 2020h
		mov	es:8, ax	; [es:arena_name+0],ax
		mov	es:0Ah,	ax
		mov	es:0Ch,	ax
		mov	es:0Eh,	ax	; [es:arena_name+6],ax
		retn
freeMCB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


HeadUmb		proc near		; ...
		push	si		; returns in AX	the address of the first UMB block
					; (0x9FFF)
		push	ds
		push	es
		mov	ah, 52h		; DOS_GET_LISTS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:8Ch	; [es:UMB_HeadIdx]
		cmp	ax, 0FFFFh
		jz	short xhu_e
		clc
		jmp	short xhu_x
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

xhu_e:					; ...
		stc

xhu_x:					; ...
		pop	es
		pop	ds
		pop	si
		retn
HeadUmb		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


linkumb		proc near		; ...
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		or	al, al
		jnz	short lumbX
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state

lumbX:					; ...
		retn
linkumb		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Issue_Exec_Call:			; ...
		int	21h		; DOS -
		cli
		push	cs
		pop	ss
		assume ss:RESGROUP
		mov	sp, 60Ah	; DATARES:RStack ; stack is set	up
		sti
		push	cs
		pop	ds		; ds = DATARES
		assume ds:RESGROUP
		pushf
		call	UnHideUMBs	; This call frees HIDDEN umb's,
					; restores the memory-allocation
					; strategy and link state, as app.
		popf
		jmp	Exec_Trap
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
cox_location	db 'cox'
cox_Y_option	dw 0			; ...
BlkDevErrSubst	db 2			; ...
BlkDevErrRw	dw 0			; ...
		db 1
		dw offset DrvLet
DrvLet		db 'A'                  ; ...
CharDevErrSubst	db 2			; ...
CharDevErrRw	dw 0			; ...
		db 2
		dw offset DevName
DevName		db 8 dup(0)		; ...
		db 0
NeedVolSubst	db 2			; ...
		dw offset VolName
		db 3
		dw offset VolSer+2
		db 3
		dw offset VolSer
VolName		db 11 dup(0)		; ...
		db 0
VolSer		dd 0			; ...
CDevAt		db 0			; ...
BadFatSubst	db 1			; ...
off_2F8		dw offset DrvLet
PutBackSubst	db 2			; ...
PutBackComSpec	dw 0			; ...
		db 1
off_2FE		dw offset PutBackDrv
PutBackDrv	db 20h			; ...
ExecErrSubst	db 2			; ...
		dw offset SafePathBuffer
NeedVol		dd 0			; ...
ErrType		db 0			; ...
Int_2e_Ret	dd 0			; ...
Save_Pdb	dw 0			; ...
Parent		dw 0			; ...
OldTerm		dw 2 dup(0)		; ...
ErrCd_24	dw 0			; ...
Handle01	dw 0			; ...
Loading		db 0			; ...
Batch		dw 0			; ...
ComSpec		db 64 dup(0)		; ...
ComSpec_End	dw 0			; ...
Trans		dw offset COMMAND	; ...
TrnSeg		dw 0			; ...
TrnMvFlg	db 0			; ...
In_Batch	db 0			; ...
Batch_Abort	db 0			; ...
ComDrv		db 0			; ...
MemSiz		dw 0			; ...
Sum		dw 0			; ...
ExtCom		db 1			; ...
RetCode		dw 0			; ...
Crit_Err_Info	db 0			; ...
EchoFlag	db 1			; ...
Suppress	db 1			; ...
Io_Save		dw 0			; ...
RestDir		db 0			; ...
PermCom		db 0			; ...
SemiPermCom	dw 0FFFFh		; ...
SingleCom	dw 0			; ...
VerVal		dw 0FFFFh		; ...
fFail		db 0			; ...
IfFlag		db 0			; ...
ForFlag		db 0			; ...
ForPtr		dw 0			; ...
Nest		dw 0			; ...
Call_Flag	db 0			; ...
Call_Batch_Flag	db 0			; ...
Next_Batch	dw 0			; ...
NullFlag	db 0			; ...
FUCase_Addr	db 5 dup(0)		; ...
Crit_Msg_Off	dw 0			; ...
Crit_Msg_Seg	dw 0			; ...
Dbcs_Vector_Addr dd 0			; ...
Append_State	dw 0			; ...
Append_Flag	db 0			; ...
Re_Out_App	db 0			; ...
Re_OutStr	db 80 dup(0)		; ...
InitFlag	db 1			; ...
PipeFlag	db 0			; ...
PipeFiles	db 0			; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR StartCode

EndInit:				; ...
		push	ds
		push	es
		push	cs
		pop	ds
		mov	dx, TrnSize
		mov	ax, OldEnv
		mov	bx, EnvSiz
		mov	cx, UsedEnv
		push	ax
		push	bx
		push	cx
		mov	bx, ds
		mov	es, bx
		assume es:RESGROUP
		mov	bx, ResSize
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		cmp	PermCom, 1	; permanent command.com?
		jnz	short adjust_env ; no, do not free batchseg
		cmp	Batch, 0
		jz	short adjust_env
		mov	bx, 4		; mov bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16
					; (33+16+15)/16
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short adjust_env ; no memory, use old batchseg
		mov	es, ax		; es = New batch segment
		assume es:nothing
		xor	di, di
		xor	si, si
		push	ds
		mov	ds, Batch	; ds = Old Batch Segment
		assume ds:nothing
		mov	cx, 33		; BATCHSEGMENT.SIZE+16
		add	cx, 16
		cld
		rep movsb
		pop	ds
		mov	cx, es
		mov	es, ds:Batch
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ds:Batch, cx

adjust_env:				; ...
		pop	cx
		pop	bx
		pop	bp
		mov	ah, 48h		; ...
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		mov	ds:EnvirSeg, ax
		mov	ds:2Ch,	ax	; [PDB.ENVIRON]
		mov	es, ax
		push	ds
		mov	ds, bp
		xor	si, si
		mov	di, si
		cld
		rep movsb
		pop	ds		; ds = RESGROUP
		cmp	ds:AllocedEnv, 0
		jz	short no_free
		mov	es, bp
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed

no_free:				; ...
		mov	ds:TrnMvFlg, 1
		push	es
		mov	si, 26E0h	; mov si,TRANSTART (26E0h)
		mov	di, 0
		mov	cx, 0AF95h	; TRANSIENT portion size
					; (TRANSPACEEND)
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; ...
					; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		cmp	bx, dx
		jb	short nomem_err
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short nomem_err
		push	ax
		add	ax, bx
		sub	ax, dx
		mov	ds:TrnSeg, ax
		mov	es, ax
		pop	ax
		add	si, cx
		dec	si
		add	di, cx
		dec	di
		std
		rep movsb
		cld
		mov	es, ax
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ds:InitFlag, 0
		pop	es
		pop	ds
		jmp	LodCom_Trap
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nomem_err:				; ...
		jmp	Alloc_error
; END OF FUNCTION CHUNK	FOR StartCode
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EndCodeInit	db 84 dup(0)
InPipePtr	dw 3EAh			; ...
OutPipePtr	dw 439h			; ...
EnvirSeg	dw 0			; ...
Com_Ptr		dw 80h,	0		; ...
Com_Fcb1	dw 5Ch,	0		; ...
Com_Fcb2	dw 6Ch,	0		; ...
TranVars	dw offset HeadFix_Trap	; ...
MySeg		dw 0			; ...
LTpa		dw 0			; ...
RSwitChar	db '/'                  ; ...
RDirChar	db '\'                  ; ...
		dw offset Issue_Exec_Call
MySeg1		dw 0			; ...
		dw offset RemCheck_Trap
MySeg2		dw 0			; ...
ResTest		dw 0
Res_Tpa		dw 0			; ...
Y_Flag		dw 0			; ...
OldErrNo	dw 0			; ...
SafePathBuffer	db 80 dup(0)		; ...
Int2fHandler	dw 2 dup(0)		; ...
ResMsgEnd	dw 0			; ...
ResSize		dw 0			; ...
		db 125 dup(0)
RStack		dw 0			; ...
fInHigh		db 0			; ...
fUmbTiny	db 0			; ...
SegLoad		dw 0			; ...
UmbLoad		db 0			; ...
UmbUsed		db 16 dup(   0)		; ...
UmbSize		dw 16 dup(   0)		; ...
fm_umb		db 0			; ...
fm_strat	db 0			; ...
fm_argc		db 0			; ...
ABORT_CHAR	db 'A'                  ; ...
RETRY_CHAR	db 'R'                  ; ...
IGNORE_CHAR	db 'I'                  ; ...
FAIL_CHAR	db 'F'                  ; ...
YES_CHAR	db 'Y'                  ; ...
NO_CHAR		db 'N'                  ; ...
REQ_ABORT	db 5			; ...
		db 'Abort'
REQ_RETRY	db 7			; ...
		db ', Retry'
REQ_IGNORE	db 8			; ...
		db ', Ignore'
REQ_FAIL	db 6			; ...
		db ', Fail'
REQ_END		db 1			; ...
		db '?'
MREAD		db 8			; ...
		db 'reading',0
MWRITE		db 8			; ...
		db 'writing',0
MDRIVE		db 14			; ...
		db ' %1 drive %2',0Dh,0Ah
MDEVICE		db 15			; ...
		db ' %1 device %2',0Dh,0Ah
MVOLSERIAL	db 38			; ...
		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
BADFATMSG	db 37			; ...
		db 'File allocation table bad, drive %1',0Dh,0Ah
COMBAD		db 21			; ...
		db 'Invalid COMMAND.COM',0Dh,0Ah
PUTBACKMSG	db 33			; ...
		db 'Insert disk with %1 in drive %2',0Dh,0Ah
PROMPT		db 33			; ...
		db 'Press any key to continue . . .',0Dh,0Ah
ENDBATMES	db 28			; ...
		db 0Dh,0Ah
		db 'Terminate batch job (Y/N)?'
EXECEMES	db 19			; ...
		db 'Cannot execute %1',0Dh,0Ah
EXEBAD		db 19			; ...
		db 'Error in EXE file',0Dh,0Ah
TOOBIG		db 34			; ...
		db 'Program too big to fit in memory',0Dh,0Ah
NOHANDMES	db 22			; ...
		db 0Dh,0Ah
		db 'No free file handles'
RBADNAM		db 26			; ...
		db 'Bad Command or file name',0Dh,0Ah
ACCDEN		db 0Eh			; ...
		db 'Access denied '
BMEMMES		db 25			; ...
		db 0Dh,0Ah
		db 'Memory allocation error'
HALTMES		db 38			; ...
		db 0Dh,0Ah
		db 'Cannot load COMMAND, system halted',0Dh,0Ah
FRETMES		db 33			; ...
		db 0Dh,0Ah
		db 'Cannot start COMMAND, exiting',0Dh,0Ah
PATRICIDE	db 46			; ...
		db 0Dh,0Ah
		db 'Top level process aborted, cannot continue',0Dh,0Ah
NEWLINE		db 2			; ...
		db 0Dh,	0Ah
MsgPtrLists	dd 10D8Fh		; ...
					; extended error messages
		dw offset PARSMSGPTRS	; parse	  error	messages
		dw 1
		dw offset EXTMSGPTRS	; critical error messages
		dw 1
		dw 0			; File system error messages
					; are not supported.
		dw 0
		dw offset MsgRetrv_Trap	; disk retriever routine
MySeg3		dw 0			; ...
					; segment of retriever routine
CRMSG0		db 13h			; ...
		db 'Write protect error'
CRMSG1		db 0Ch			; ...
		db 'Invalid unit'
CRMSG2		db 9			; ...
		db 'Not ready'
CRMSG3		db 16h			; ...
		db 'Invalid device request'
CRMSG4		db 0Ah			; ...
		db 'Data error'
CRMSG5		db 21h			; ...
		db 'Invalid device request parameters'
CRMSG6		db 0Ah			; ...
		db 'Seek error'
CRMSG7		db 12h			; ...
		db 'Invalid media type'
CRMSG8		db 10h			; ...
		db 'Sector not found'
CRMSG9		db 1Ah			; ...
		db 'Printer out of paper error'
CRMSG10		db 11h			; ...
		db 'Write fault error'
CRMSG11		db 10h			; ...
		db 'Read fault error'
CRMSG12		db 0Fh			; ...
		db 'General failure'
CRMSG13		db 11h			; ...
		db 'Sharing violation'
CRMSG14		db 0Eh			; ...
		db 'Lock violation'
CRMSG15		db 13h			; ...
		db 'Invalid disk change'
CRMSG16		db 0Fh			; ...
		db 'FCB unavailable'
CRMSG17		db 19h			; ...
		db 'System resource exhausted'
CRMSG18		db 12h			; ...
		db 'Code page mismatch'
CRMSG19		db 0Ch			; ...
		db 'Out of input'
CRMSG20		db 17h			; ...
		db 'Insufficient disk space'
CRITMSGPTRS	dw offset CRMSG0	; ...
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
PAERRMSG0	db 13h			; ...
		db 'Too many parameters'
PAERRMSG1	db 1Ah			; ...
		db 'Required parameter missing'
PAERRMSG2	db 0Eh			; ...
		db 'Invalid switch'
PAERRMSG3	db 0Fh			; ...
		db 'Invalid keyword'
PAERRMSG4	db 1			; ...
		db ' '
PAERRMSG5	db 24h			; ...
		db 'Parameter value not in allowed range'
PAERRMSG6	db 1Bh			; ...
		db 'Parameter value not allowed'
PAERRMSG7	db 1Bh			; ...
		db 'Parameter value not allowed'
PAERRMSG8	db 1Ch			; ...
		db 'Parameter format not correct'
PAERRMSG9	db 11h			; ...
		db 'Invalid parameter'
PAERRMSG10	db 1Dh			; ...
		db 'Invalid parameter combination'
PARSMSGPTRS	dw offset PAERRMSG0	; ...
		dw offset PAERRMSG1
		dw offset PAERRMSG2
		dw offset PAERRMSG3
		dw offset PAERRMSG4
		dw offset PAERRMSG5
		dw offset PAERRMSG6
		dw offset PAERRMSG7
		dw offset PAERRMSG8
		dw offset PAERRMSG9
		dw offset PAERRMSG10
INVLFUNCT	db 10h			; ...
		db 'Invalid function'
FNOTFOUND	db 0Eh			; ...
		db 'File not found'
PNOTFOUND	db 0Eh			; ...
		db 'Path not found'
TOOMANYOF	db 13h			; ...
		db 'Too many open files'
ACCDENIED	db 0Eh			; ...
		db 'Access denied '
INVHANDLE	db 0Eh			; ...
		db 'Invalid handle'
MEMCBDEST	db 1Fh			; ...
		db 'Memory control blocks destroyed'
INSUFFMEM	db 13h			; ...
		db 'Insufficient memory'
INVMEMBLA	db 1Ch			; ...
		db 'Invalid memory block address'
INVENVIRO	db 13h			; ...
		db 'Invalid Environment'
INVFORMAT	db 0Eh			; ...
		db 'Invalid format'
INVFNPARM	db 1Ah			; ...
		db 'Invalid function parameter'
INVLDDATA	db 0Ch			; ...
		db 'Invalid data'
INVDRVSPC	db 1Bh			; ...
		db 'Invalid drive specification'
ATRCURDIR	db 23h			; ...
		db 'Attempt to remove current directory'
NOTSAMDEV	db 0Fh			; ...
		db 'Not same device'
NOMOREFIL	db 0Dh			; ...
		db 'No more files'
FILEXISTS	db 0Bh			; ...
		db 'File exists'
CANTMKDIR	db 1Bh			; ...
		db 'Cannot make directory entry'
FAILINT24	db 0Eh			; ...
		db 'Fail on INT 24'
TOOMANYRD	db 15h			; ...
		db 'Too many redirections'
DUPLREDIR	db 15h			; ...
		db 'Duplicate redirection'
INVPASSWD	db 10h			; ...
		db 'Invalid password'
INVLDPARM	db 11h			; ...
		db 'Invalid parameter'
NETDATFAU	db 12h			; ...
		db 'Network data fault'
FNOSUPNET	db 21h			; ...
		db 'Function not supported by network'
RSCNOTINS	db 27h			; ...
		db 'Required system component not installed'
EXTMSGPTRS	dw offset INVLFUNCT	; ...
		dw offset FNOTFOUND
		dw offset PNOTFOUND
		dw offset TOOMANYOF
		dw offset ACCDENIED
		dw offset INVHANDLE
		dw offset MEMCBDEST
		dw offset INSUFFMEM
		dw offset INVMEMBLA
		dw offset INVENVIRO
		dw offset INVFORMAT
		dw offset INVFNPARM
		dw offset INVLDDATA
		dw 0
		dw offset INVDRVSPC
		dw offset ATRCURDIR
		dw offset NOTSAMDEV
		dw offset NOMOREFIL
		dw offset CRMSG0
		dw offset CRMSG1
		dw offset CRMSG2
		dw offset CRMSG3
		dw offset CRMSG4
		dw offset CRMSG5
		dw offset CRMSG6
		dw offset CRMSG7
		dw offset CRMSG8
		dw offset CRMSG9
		dw offset CRMSG10
		dw offset CRMSG11
		dw offset CRMSG12
		dw offset CRMSG13
		dw offset CRMSG14
		dw offset CRMSG15
		dw offset CRMSG16
		dw offset CRMSG17
		dw offset CRMSG18
		dw offset CRMSG19
		dw offset CRMSG20
		db 80 dup(0)
		dw offset FILEXISTS
		dw 0
		dw offset CANTMKDIR
		dw offset FAILINT24
		dw offset TOOMANYRD
		dw offset DUPLREDIR
		dw offset INVPASSWD
		dw offset INVLDPARM
		dw offset NETDATFAU
		dw offset FNOSUPNET
		dw offset RSCNOTINS
ExtMsgEnd	db 13 dup(0)		; ...
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Err:				; ...
		mov	bx, offset RBADNAM ; RCODE_START = 0E50h
		cmp	al, 2
		jz	short GotExecEMes
		mov	bx, offset TOOBIG
		cmp	al, 8
		jz	short GotExecEMes
		mov	bx, offset EXEBAD
		cmp	al, 0Bh
		jz	short GotExecEMes
		mov	bx, offset ACCDEN
		cmp	al, 5
		jz	short GotExecEMes
		mov	bx, offset EXECEMES
		mov	si, offset ExecErrSubst

GotExecEMes:				; ...
		mov	dx, bx
		call	RPrint
		jmp	short NoExec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Exec_Ret:
		jb	short Exec_Err

Exec_Wait:				; ...
		mov	ah, 4Dh
		int	21h		; DOS -	2+ - GET EXIT CODE OF SUBPROGRAM (WAIT)
		mov	ds:RetCode, ax

NoExec:					; ...
		jmp	LodCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ContC:					; ...
		pop	ds
		test	ds:InitFlag, 1
		jz	short NotAtInit
		test	ds:InitFlag, 2
		jz	short CmdIret
		pop	ds
		jmp	init_contc_specialcase
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmdIret:				; ...
		pop	ds
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotAtInit:				; ...
		test	ds:InitFlag, 4
		jz	short NotInit
		cmp	ah, 1
		jb	short CmdIret
		cmp	ah, 12
		ja	short CmdIret
		pop	ds
		add	sp, 6
		stc
		retf	2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotInit:				; ...
		or	ds:InitFlag, 4
		sti
		pop	ax
		mov	ax, ds:SingleCom
		or	ax, ax
		jnz	short NoReset
		push	ax
		mov	ah, 0Dh
		int	21h		; DOS -	DISK RESET
		pop	ax

NoReset:				; ...
		test	ds:Batch, 0FFFFh
		jz	short ContCTerm
		or	ax, ax
		jnz	short ContCTerm
		call	SavHand
		call	AskEnd
		jnb	short ContBatch
		mov	cl, ds:EchoFlag
		push	bx

ClearBatch:				; ...
		mov	es, ds:Batch
		mov	di, 20h		; BATCHSEGMENT.BatFile
		mov	bx, es:5	; [es:BATCHSEGMENT.BatForPtr]
		cmp	bx, 0
		jz	short No_Bat_For
		push	es
		mov	es, bx
		mov	ah, 49h		; DEALLOC
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

No_Bat_For:				; ...
		mov	cl, es:1	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	bx, es:3	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ds:Batch, bx
		dec	ds:Nest
		jnz	short ClearBatch
		pop	bx
		mov	ds:EchoFlag, cl
		mov	ds:PipeFlag, 0

ContBatch:				; ...
		call	crlf
		call	RestHand

ContCTerm:				; ...
		xor	ax, ax
		mov	bp, ax
		mov	ds:IfFlag, al
		mov	ds:ForFlag, al
		call	ResPipeOff
		cmp	ds:SingleCom, ax
		jz	short NoSetSing
		mov	ds:SingleCom, 0FFFFh ; -1

NoSetSing:				; ...
		and	ds:InitFlag, 0FBh ; ~INITCTRLC
		cmp	ds:ExtCom, al
		jnz	short DoDAb
		jmp	LodCom1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoDAb:					; ...
		stc
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ResPipeOff	proc near		; ...
		push	ax
		xor	ax, ax
		xchg	al, ds:PipeFlag
		or	al, al
		jz	short NoPipePop
		shr	ds:EchoFlag, 1

NoPipePop:				; ...
		pop	ax
		retn
ResPipeOff	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR alloc_env

BadMemErr:				; ...
		mov	dx, offset BMEMMES

FatalC:					; ...
		call	RPrint
		cmp	ds:PermCom, 0
		jz	short FatalRet
		cmp	ds:SingleCom, 0
		jnz	short FatalRet
		mov	dx, offset HALTMES
		call	RPrint
		sti

Stall:					; ...
		jmp	short Stall
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FatalRet:				; ...
		mov	dx, offset FRETMES
		call	RPrint

FatalRet2:				; ...
		cmp	ds:PermCom, 0
		jnz	short Ret_2e
		mov	ax, ds:Parent
		mov	ds:16h,	ax	; [PDB.PARENT_PID]
		mov	ax, ds:OldTerm
		mov	ds:0Ah,	ax	; [PDB.EXIT]
		mov	ax, ds:OldTerm+2
		mov	ds:0Ch,	ax	; [PDB.EXIT+2]
		mov	ax, 4C00h
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ret_2e:					; ...
		mov	ds:SingleCom, 0
		mov	es, ds:Res_Tpa
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	bx, ds:Save_Pdb
		mov	ah, 50h
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ax, ds:RetCode
		cmp	ds:ExtCom, 0
		jnz	short GotECode
		xor	ax, ax

GotECode:				; ...
		mov	ds:ExtCom, 1
		jmp	ds:Int_2e_Ret
; END OF FUNCTION CHUNK	FOR alloc_env
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Int_2e:					; ...
		pop	ds
		pop	ax
		pop	word ptr ds:Int_2e_Ret
		pop	word ptr ds:Int_2e_Ret+2
		add	sp, 2
		push	ds
		pop	es
		mov	ds, ax
		mov	di, 80h
		mov	cx, 64
		rep movsw
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	es:Save_Pdb, bx
		mov	ah, 50h
		push	es
		pop	ds
		mov	bx, ds
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ds:SingleCom, 81h ; ''
		mov	ds:ExtCom, 1
		push	ds
		push	ds

LodCom:					; ...
		pop	ds
		add	sp, 2
		cmp	ds:ExtCom, 0
		jnz	short LodCom0
		jmp	LodCom1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LodCom0:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		call	SetSize
		add	ax, 20h
		cmp	bx, ax
		jnb	short MemOk

BadMemErrJ:				; ...
		jmp	BadMemErr

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetSize		proc near		; ...
		mov	ax, 0AFA4h	; TRANSPACEEND+15
		mov	cl, 4
		shr	ax, cl
		retn
SetSize		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MemOk:					; ...
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short BadMemErrJ
		mov	ds:ExtCom, 0
		mov	ds:Res_Tpa, ax
		and	ax, 0F000h
		add	ax, 1000h
		jb	short Bad_Tpa
		mov	dx, ds:Res_Tpa
		add	dx, bx
		cmp	dx, ax
		jbe	short Bad_Tpa
		sub	dx, ax
		cmp	dx, 1000h
		jnb	short LTpaSet

Bad_Tpa:				; ...
		mov	ax, ds:Res_Tpa

LTpaSet:				; ...
		mov	ds:LTpa, ax
		mov	ax, ds:Res_Tpa
		add	bx, ax
		mov	ds:MemSiz, bx
		call	SetSize
		sub	bx, ax
		cmp	bx, ds:TrnSeg
		jz	short LodCom1
		mov	cx, 0AF95h	; TRANSPACEEND (Transient portion size)
		ja	short mov_down
		xor	si, si
		mov	di, si
		cld
		jmp	short copy_trans
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mov_down:				; ...
		mov	si, cx
		dec	si
		mov	di, si
		std

copy_trans:				; ...
		push	ds
		push	es
		mov	es, bx
		mov	ds, ds:TrnSeg
		rep movsb
		cld
		pop	es
		pop	ds
		mov	ds:TrnSeg, bx

LodCom1:				; ...
		mov	ax, ds
		mov	ss, ax
		assume ss:nothing
		mov	sp, offset RStack ; mov	sp,offset DATARES:RStack
		call	HeadFix
		xor	bp, bp
		mov	ax, 0FFFFh	; -1
		xchg	ax, ds:VerVal
		cmp	ax, 0FFFFh	; -1
		jz	short NoSetVer
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NoSetVer:				; ...
		cmp	ds:SingleCom, 0FFFFh
		jnz	short NoSng
		jmp	FatalRet2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoSng:					; ...
		call	ChkSum
		cmp	dx, ds:Sum
		jz	short HavCom

Bogus_Com:
		mov	ds:Loading, 1
		call	LoadCom

ChkSame:				; ...
		call	ChkSum
		cmp	dx, ds:Sum
		jz	short HavCom

Also_Bogus:
		call	WrongCom
		jmp	short ChkSame
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HavCom:					; ...
		mov	ds:Loading, 0
		mov	si, offset TranVars ; offset DATARES:TranVars
		mov	di, offset HEADCALL ; offset TRANGROUP:HeadCall
		mov	es, ds:TrnSeg
		cld
		mov	cx, offset OldErrNo ; ;	offset TranVarEnd
		sub	cx, si
		rep movsb
		mov	ax, ds:MemSiz
		mov	ds:2, ax	; [PDB.BLOCK_LEN]
		jmp	dword ptr ds:Trans ; jmp far [Trans]
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRemCheck:
		pop	ds
		add	sp, 2
		call	RemCheck
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RemCheck	proc near		; ...
		push	ax
		push	bx
		mov	bx, ax
		mov	ax, 4408h
		int	21h		; DOS -	2+ - IOCTL -
		jnb	short rcCont
		or	ax, ax
		jmp	short ResRegs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rcCont:					; ...
		and	ax, 1
		not	ax

ResRegs:				; ...
		pop	bx
		pop	ax
		retn
RemCheck	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

THeadFix:
		pop	ds
		add	sp, 2
		call	HeadFix
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


HeadFix		proc near		; ...
		call	SetVect
		xor	bx, bx
		mov	cx, ds:Io_Save
		mov	dx, ds:18h	; [PDB.JFN_TABLE]
		cmp	cl, dl
		jz	short Chk1
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ds:18h,	cl

Chk1:					; ...
		inc	bx
		cmp	ch, dh
		jz	short ChkOtherHand
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ds:19h,	ch	; [PDB.JFN_TABLE+1]

ChkOtherHand:				; ...
		add	bx, 4
		mov	cx, 15		; FILPERPROC-5

CloseLoop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	CloseLoop
		cmp	ds:Append_Flag,	0FFh ; -1
		jnz	short Append_Fix_End
		mov	ax, 0B707h
		mov	bx, ds:Append_State
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		mov	ds:Append_Flag,	0

Append_Fix_End:				; ...
		retn
HeadFix		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SavHand		proc near		; ...
		push	bx
		push	ax
		push	es
		push	ds
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	ds, bx
		lds	bx, ds:34h	; [PDB.JFN_Pointer]
		mov	ax, [bx]
		pop	es
		push	es
		mov	es:Handle01, ax
		mov	al, es:1Ah	; [es:PDB.JFN_TABLE+2]
		mov	ah, al
		mov	[bx], ax
		pop	ds
		pop	es
		pop	ax
		pop	bx
		retn
SavHand		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GetComDsk2:				; ...
		call	GetComDsk
		jmp	LodCom1

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RestHand	proc near		; ...
		push	ds
		push	bx
		push	ax
		mov	ah, 51h
		int	21h		; DOS -	2+ internal - GET PSP SEGMENT
					; Return: BX = current PSP segment
		mov	ax, ds:Handle01
		mov	ds, bx
		lds	bx, ds:34h	; [PDB.JFN_Pointer]
		mov	[bx], ax
		pop	ax
		pop	bx
		pop	ds
		retn
RestHand	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR GetComDsk

Hopeless:				; ...
		mov	dx, offset COMBAD
		jmp	FatalC
; END OF FUNCTION CHUNK	FOR GetComDsk

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetComDsk	proc near		; ...

; FUNCTION CHUNK AT 11A2 SIZE 00000006 BYTES

		mov	al, ds:ComDrv
		call	RemCheck
		jnz	short Hopeless
		cmp	dx, offset COMBAD
		jnz	short GetComDsk4
		mov	dx, offset COMBAD
		call	RPrint

GetComDsk4:				; ...
		cmp	ds:PutBackDrv, 0
		jnz	short Users_Drive
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'
		mov	ds:PutBackDrv, al

Users_Drive:				; ...
		mov	dx, offset PUTBACKMSG
		mov	si, offset PutBackSubst
		call	RPrint
		mov	dx, offset PROMPT
		call	RPrint
		call	GetRawFlushedByte
		retn
GetComDsk	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetRawFlushedByte proc near		; ...
		mov	ax, 0C07h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.

LoadCom_retn:				; ...
		retn
GetRawFlushedByte endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadCom		proc near		; ...
		inc	bp
		mov	dx, offset ComSpec
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnb	short ReadCom
		cmp	ax, 4		; ERROR_TOO_MANY_OPEN_FILES
		jnz	short TryDoOpen
		mov	dx, offset NOHANDMES
		jmp	FatalC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TryDoOpen:				; ...
		call	GetComDsk
		jmp	short LoadCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ReadCom:				; ...
		mov	bx, ax
		mov	dx, 26E0h	; mov dx,offset	RESGROUP:TranStart
		xor	cx, cx
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short WrongCom1
		mov	cx, 0AE95h	; mov cx,offset	TRANGROUP:TranSpaceEnd - 100h
		push	ds
		mov	ds, ds:TrnSeg
		mov	dx, 100h
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds

WrongCom1:				; ...
		pushf
		push	ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	ax
		popf
		jb	short WrongCom
		cmp	ax, cx
		jz	short LoadCom_retn
LoadCom		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


WrongCom	proc near		; ...
		mov	dx, offset COMBAD
		call	GetComDsk
		jmp	short LoadCom
WrongCom	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ChkSum		proc near		; ...
		push	ds
		mov	ds, ds:TrnSeg
		mov	si, 100h
		mov	cx, 9D53h	; offset TRANGROUP:TranDataEnd - 100h
		cld
		shr	cx, 1
		xor	dx, dx

Chk:					; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Chk
		pop	ds
		retn
ChkSum		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetVect		proc near		; ...
		mov	dx, offset LodCom_Trap
		mov	ax, 2522h
		mov	ds:0Ah,	dx	; [PDB.EXIT]
		mov	word ptr ds:0Ch, ds ; [PDB.EXIT+2]
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, offset Ctrlc_Trap
		inc	al
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, offset CritErr_Trap
		inc	al
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		retn
SetVect		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TrnLodCom1:
		pop	ds
		add	sp, 2
		jmp	LodCom1

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


AskEnd		proc near		; ...
		mov	dx, offset ENDBATMES
		call	RPrint
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	CharToUpper
		cmp	al, ds:NO_CHAR
		jz	short aeRet
		cmp	al, ds:YES_CHAR
		jnz	short AskEnd
		stc

aeRet:					; ...
		retn
AskEnd		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DskErr:					; ...
		pop	ds
		pop	ds:RStack	; pop word [OldDS]
		sti
		push	es
		push	si
		push	cx
		push	di
		push	cx
		push	ax
		push	ds
		pop	es		; es = DATARES
		mov	ds, bp
		mov	ax, [si+4]	; [si+SYSDEV.ATT]
		mov	es:CDevAt, ah
		mov	di, offset DevName
		mov	cx, 8
		add	si, 10		; add si,SYSDEV.NAME
		cld
		rep movsb
		pop	ax
		pop	cx
		pop	di
		push	es
		pop	ds		; ds = DATARES
		call	SavHand
		push	dx
		call	crlf
		pop	dx
		mov	ds:Crit_Err_Info, ah
		add	al, 'A'
		mov	ds:DrvLet, al
		test	ah, 80h
		jz	short NoHardE
		test	ds:CDevAt, 80h
		jnz	short NoHardE
		jmp	FatErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoHardE:				; ...
		mov	si, offset MREAD
		test	ah, 1
		jz	short SavMes
		mov	si, offset MWRITE

SavMes:					; ...
		mov	ds:OldErrNo, di
		push	es
		push	ds
		push	bp
		push	si
		push	dx
		push	cx
		push	bx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	bx
		pop	cx
		pop	dx
		pop	si
		pop	bp
		pop	ds
		mov	word ptr ds:NeedVol, di
		mov	word ptr ds:NeedVol+2, es
		pop	es
		xor	ah, ah
		mov	di, ax
		sub	di, 13h		; ERROR_WRITE_PROTECT
		jnb	short HavCod
		mov	di, 0Ch		; ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT

HavCod:					; ...
		mov	ds:ErrType, 0
		cmp	di, 10h		; ERROR_FCB_UNAVAILABLE	- ERROR_WRITE_PROTECT
		jz	short SetStyle
		cmp	di, 11h		; ERROR_SHARING_BUFFER_EXCEEDED	- ERROR_WRITE_PROTECT
		jnz	short GotStyle

SetStyle:				; ...
		mov	ds:ErrType, 1

GotStyle:				; ...
		mov	ds:ErrCd_24, di
		cmp	di, 14h		; ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT
		jbe	short NormalError
		mov	di, ax
		mov	ax, 500h
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh
		jnz	short NoHandler
		push	bx
		mov	bx, di
		mov	ax, 501h
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		pop	bx
		jb	short NoHandler
		mov	ds:ErrType, al
		push	ds
		push	es
		pop	ds
		mov	dx, di
		mov	cx, 0FFFFh	; -1
		xor	al, al
		cld
		repne scasb
		mov	byte ptr [di-1], '$'
		mov	ah, 9		; STD_CON_STRING_OUTPUT
		int	21h		; DOS -	PRINT STRING
					; DS:DX	-> string terminated by	"$"
		mov	byte ptr [di-1], 0
		pop	ds
		jmp	short CheckErrType
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoHandler:				; ...
		mov	ds:ErrType, 0
		mov	di, ds:OldErrNo
		mov	ds:ErrCd_24, di

NormalError:				; ...
		add	di, 13h		; ERROR_WRITE_PROTECT
		xchg	di, dx
		call	RPrintCrit

CheckErrType:				; ...
		cmp	ds:ErrType, 0
		jz	short ContOld
		call	crlf
		jmp	short Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ContOld:				; ...
		inc	si
		test	ds:CDevAt, 80h
		jz	short BlkErr
		mov	dx, offset MDEVICE
		mov	ds:CharDevErrRw, si
		mov	si, offset CharDevErrSubst
		call	RPrint
		jmp	short Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BlkErr:					; ...
		mov	dx, offset MDRIVE
		mov	ds:BlkDevErrRw,	si
		mov	si, offset BlkDevErrSubst
		call	RPrint
		cmp	ds:Loading, 0
		jz	short Ask
		call	RestHand
		jmp	GetComDsk2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Ask:					; ...
		cmp	ds:ErrCd_24, 0Fh
		jnz	short Not15
		push	cx
		push	ds
		pop	es
		lds	si, ds:NeedVol
		push	di
		mov	di, offset VolName
		mov	cx, 16
		cld
		rep movsb
		pop	di
		push	es
		pop	ds
		pop	cx
		mov	dx, offset MVOLSERIAL
		mov	si, offset NeedVolSubst
		call	RPrint

Not15:					; ...
		mov	dx, offset REQ_ABORT
		call	RPrint
		test	ds:Crit_Err_Info, 10h ;	RETRY_ALLOWED
		jz	short Try_Ignore
		mov	dx, offset REQ_RETRY
		call	RPrint

Try_Ignore:				; ...
		test	ds:Crit_Err_Info, 20h ;	IGNORE_ALLOWED
		jz	short Try_Fail
		mov	dx, offset REQ_IGNORE
		call	RPrint

Try_Fail:				; ...
		test	ds:Crit_Err_Info, 8 ; FAIL_ALLOWED
		jz	short Term_Question
		mov	dx, offset REQ_FAIL
		call	RPrint

Term_Question:				; ...
		mov	dx, offset REQ_END
		call	RPrint
		test	ds:fFail, 0FFh	; -1
		jz	short DoPrompt
		mov	ah, 3
		jmp	EExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoPrompt:				; ...
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	crlf
		call	CharToUpper
		mov	ah, 0
		test	ds:Crit_Err_Info, 20h ;	IGNORE_ALLOWED
		jz	short User_Retry
		cmp	al, ds:IGNORE_CHAR
		jz	short EExitJ

User_Retry:				; ...
		inc	ah
		test	ds:Crit_Err_Info, 10h ;	RETRY_ALLOWED
		jz	short User_Abort
		cmp	al, ds:RETRY_CHAR
		jz	short EExitJ

User_Abort:				; ...
		inc	ah
		cmp	al, ds:ABORT_CHAR
		jz	short Abort_Process
		inc	ah
		test	ds:Crit_Err_Info, 8 ; FAIL_ALLOWED
		jz	short AskJ
		cmp	al, ds:FAIL_CHAR
		jz	short EExitJ

AskJ:					; ...
		jmp	Ask
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EExitJ:					; ...
		jmp	short EExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Abort_Process:				; ...
		test	ds:InitFlag, 1	; INITINIT
		jz	short AbortCont
		cmp	ds:PermCom, 0
		jz	short JustExit
		mov	dx, offset PATRICIDE
		call	RPrint

DeadInTheWater:				; ...
		jmp	short DeadInTheWater
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

JustExit:				; ...
		mov	ax, ds:Parent
		mov	ds:16h,	ax	; [PDB.PARENT_PID]
		mov	ax, 4CFFh	; (EXIT<<8)|255
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
					; AL = exit code
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

AbortCont:				; ...
		test	ds:In_Batch, 0FFh ; -1
		jz	short Not_Batch_Abort
		mov	ds:Batch_Abort,	1

Not_Batch_Abort:			; ...
		mov	dl, ds:PipeFlag
		call	ResPipeOff
		or	dl, dl
		jz	short CheckForA
		cmp	ds:SingleCom, 0
		jz	short CheckForA
		mov	ds:SingleCom, 0FFFFh ; -1

CheckForA:				; ...
		cmp	ds:ErrCd_24, 0
		jz	short abortfor
		cmp	ds:ErrCd_24, 2
		jnz	short EExit

abortfor:				; ...
		mov	ds:ForFlag, 0
		cmp	ds:SingleCom, 0
		jz	short EExit
		mov	ds:SingleCom, 0FFFFh ; -1

EExit:					; ...
		mov	al, ah
		mov	dx, di

RestHd:					; ...
		call	RestHand
		pop	cx
		pop	si
		pop	es
		mov	ds, ds:RStack	; mov ds,[OldDS]
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FatErr:					; ...
		mov	dx, offset BADFATMSG
		mov	si, offset BadFatSubst
		call	RPrint
		mov	al, 2
		jmp	short RestHd

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


crlf		proc near		; ...
		mov	dx, offset NEWLINE
crlf		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrint		proc near		; ...
		push	si
		push	ax
		push	bx
		push	cx
		push	dx
		mov	bx, si
		mov	si, dx
		lodsb
		xor	cx, cx
		mov	cl, al
		jcxz	short rpRet
		call	RDispMsg

rpRet:					; ...
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	si
		retn
RPrint		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrintCrit	proc near		; ...
		push	dx
		xchg	bx, dx
		sub	bx, 19
		shl	bx, 1
		mov	bx, ds:CRITMSGPTRS[bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
RPrintCrit	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RDispMsg	proc near		; ...
		lodsb			; rdNextChar
		cmp	al, '%'
		jnz	short rdOutChar
		mov	dl, [si]
		sub	dl, '1'
		cmp	dl, 9
		jnb	short rdOutChar
		call	SubstMsg
		inc	si
		dec	cx
		jmp	short rdCharDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rdOutChar:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output

rdCharDone:				; ...
		loop	RDispMsg	; loop rdNextChar
		retn
RDispMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SubstMsg	proc near		; ...
		push	bx
		push	cx
		mov	al, 3		; size SUBST
		mul	dl
		add	bx, ax
		mov	al, [bx]	; mov al,[bx].SubstType
		mov	bx, [bx+1]	; mov bx,[bx].SubstPtr
		dec	al
		jz	short smChar
		dec	al
		jz	short smStr
		mov	ax, [bx]
		mov	cx, 4

smDigit:				; ...
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		rol	ax, 1
		push	ax
		and	al, 0Fh
		add	al, '0'
		cmp	al, '9'
		jbe	short smDigit09
		add	al, 7		; ('A' - '0') - 10

smDigit09:				; ...
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ax
		loop	smDigit
		jmp	short smRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smChar:					; ...
		mov	dl, [bx]
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		jmp	short smRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smStr:					; ...
		mov	dl, [bx]
		or	dl, dl
		jz	short smRet
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	bx
		jmp	short smStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smRet:					; ...
		pop	cx
		pop	bx
		retn
SubstMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CharToUpper	proc near		; ...
		push	ax
		mov	ax, 1213h
		int	2Fh		; Multiplex - DOS 3+ internal -	UPPERCASE CHARACTER
					; STACK: WORD character	to convert to uppercase
					; Return: AL = uppercase character
					; STACK	unchanged
		inc	sp
		inc	sp
		retn
CharToUpper	endp ; sp = -2

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgInt2fHandler:			; ...
		pop	ds
		cmp	ax, 122Eh	; (MULTDOS<<8)|MESSAGE_2F
		jz	short miOurs
		cmp	ax, 5500h	; GET_COMMAND_STATE
		jz	short fcOurs
		push	ax
		push	ax
		push	bp
		push	ax
		mov	bp, sp
		mov	ax, [bp+8]
		mov	[bp+4],	ax
		mov	ax, ds:Int2fHandler+2
		mov	[bp+8],	ax
		mov	ax, ds:Int2fHandler
		mov	[bp+6],	ax
		pop	ax
		pop	bp
		pop	ds
		retf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcOurs:					; ...
		pop	ax
		push	ds
		mov	si, offset Int2f_Entry
		xor	ax, ax
		jmp	short miRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

miOurs:					; ...
		test	dl, 1
		jnz	short miRet
		push	bx
		mov	bx, dx
		xor	bh, bh
		shl	bx, 1
		les	di, ds:MsgPtrLists[bx]
		pop	bx

miRet:					; ...
		pop	ds
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MsgRetriever:
		pop	ds
		push	ax
		push	bx
		push	cx
		push	dx
		push	si
		push	ds
		pop	es
		mov	bx, 11		; NUMPARSMSGS
		cmp	di, offset PARSMSGPTRS
		jz	short chkmsgnum
		mov	bx, 90		; NUMEXTMSGS

chkmsgnum:				; ...
		cmp	bx, ax
		jb	short mrRet
		dec	ax
		shl	ax, 1
		add	di, ax
		cmp	di, ds:ResMsgEnd
		jb	short mrInMem
		mov	si, offset ComSpec
		mov	dx, 1		; EXT_EXISTS_OPEN
		mov	bx, 2000h	; INT_24_ERROR
		mov	ax, 6C00h	; ExtOpen shl 8
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jb	short mrRet
		mov	bx, ax
		mov	dx, di
		xor	si, si

mrRead:					; ...
		sub	dx, 100h
		xor	cx, cx
		mov	ax, 4200h	; LSEEK	shl 8
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short mrCloseFile
		mov	dx, offset SafePathBuffer ; MsgBuffer
		mov	cx, 64
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short mrCloseFile
		or	si, si
		jnz	short mrCloseFile
		inc	si
		mov	dx, word ptr ds:SafePathBuffer ; [MsgBuffer]
		or	dx, dx
		jnz	short mrRead
		stc

mrCloseFile:				; ...
		pushf
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		popf
		mov	di, dx
		jmp	short mrRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mrInMem:				; ...
		mov	di, es:[di]
		or	di, di
		jnz	short mrRet
		stc

mrRet:					; ...
		pop	si
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		pop	ds
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Lh_OffUnlink	proc far
		mov	ch, al
		mov	cl, al
		mov	ax, 5800h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		mov	bx, ax
		ror	cl, 1
		and	cl, 80h
		and	bl, 7Fh
		or	bl, cl
		mov	ax, 5801h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		mov	bl, ch
		shr	bl, 1
		xor	bh, bh
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retf
Lh_OffUnlink	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
EndCode		db 6 dup(0)
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR StartCode

ConProc:				; ...
		mov	sp, offset RStack
		mov	ah, 50h
		mov	bx, es
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	ax, 3000h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		cmp	ax, 1606h
		jz	short okdos
		mov	dx, offset BADVERMSG
		call	RPrint
		mov	ax, es
		cmp	es:16h,	ax	; [es:PDB.PARENT_PID]

Here:					; ...
		jz	short Here
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

okdos:					; ...
		mov	dx, 26EFh	; TRANSTART+15
		mov	cl, 4
		shr	dx, cl
		mov	ax, cs
		add	ax, dx
		mov	ds:initend, ax
		call	CheckHelp
		call	patch_segs
		mov	ax, 0B700h
		int	2Fh		; - Multiplex -	APPEND - INSTALLATION CHECK
					; Return: AL = 00h not installed
					; AL = FFh if installed
		cmp	al, 0
		jz	short set_msg_addr
		mov	ax, 0B702h
		int	2Fh		; - Multiplex -	APPEND - VERSION CHECK
					; Return: AX = FFFFh if	not DOS	4.0 APPEND
					; AL = major version number
					; AH = minor version number, otherwise
		cmp	ax, 0FFFFh
		jnz	short set_msg_addr
		mov	ax, 0B706h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - GET APPEND FUNCTION STATE
					; Return: BX = APPEND state
		mov	ds:Append_State, bx
		xor	bx, bx
		mov	ax, 0B707h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits

set_msg_addr:				; ...
		mov	di, offset PAERRMSG0 ; offset resgroup:DataresEnd
		mov	ds:ResMsgEnd, di
		call	get_XMMAddr
		mov	ax, 5500h
		int	2Fh
		or	ax, ax
		jnz	short first_com
		mov	es:ResJmpTable,	si
		mov	es:ResJmpTable+2, ds
		jmp	short init_cntry
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

first_com:				; ...
		mov	es:FirstCom, 1

init_cntry:				; ...
		push	es
		pop	ds
		mov	ah, 65h		; GETEXTCNTRY
		mov	al, 4
		mov	dx, 0FFFFh	; -1
		mov	bx, 0FFFFh	; -1
		mov	cx, 5
		mov	di, offset FUCase_Addr
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		push	ds
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		pop	ds
		mov	word ptr ds:Dbcs_Vector_Addr, si
		mov	word ptr ds:Dbcs_Vector_Addr+2,	bx
		mov	ax, ds:16h	; [PDB.PARENT_PID]
		mov	ds:Parent, ax
		mov	ax, ds:0Ah	; [PDB.EXIT]
		mov	ds:OldTerm, ax
		mov	ax, ds:0Ch	; [PDB.EXIT+2]
		mov	ds:OldTerm+2, ax
		mov	ax, 1679h	; EndCode+15
		mov	cl, 4
		shr	ax, cl		; (EndCode+15)>>4
		mov	cx, cs
		add	ax, cx
		mov	ds:Res_Tpa, ax
		and	ax, 0F000h
		add	ax, 1000h
		jnb	short TpaSet
		mov	ax, ds:Res_Tpa

TpaSet:					; ...
		mov	ds:LTpa, ax
		mov	ax, ds:2	; [PDB.BLOCK_LEN]
		mov	ds:MySeg1, ds
		mov	ds:MySeg2, ds
		mov	ds:MySeg, ds
		mov	ds:MySeg3, ds
		mov	ds:MemSiz, ax
		push	ax
		mov	bx, 26E0h	; mov bx,offset	RESGROUP:TranStart
		add	bx, 0AF95h	; add bx,offset	TRANGROUP:TranSpaceEnd
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	ax
		mov	ds:EnvMax, 90	; ((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
		mov	ds:EnvSiz, 16	; ENVSML/16 ; 256/16
		mov	dx, 0AFA4h	; TRANSPACEEND+15
		mov	cl, 4
		shr	dx, cl		; (TRANSPACEEND+15)>>4
		mov	ds:TrnSize, dx
		sub	ax, dx
		mov	ds:TrnSeg, ax
		mov	ax, ds:2Ch	; [PDB.ENVIRON]
		mov	ds:EnvirSeg, ax
		or	ax, ax
		jz	short buildenv
		cmp	ds:FirstCom, 0
		jz	short environpassed

buildenv:				; ...
		call	alloc_env

environpassed:				; ...
		mov	es, ax

gottheenvir:
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		inc	al
		mov	ds:ComDrv, al
		mov	al, ds:5Ch	; [FCB]
		or	al, al
		jz	short nocomdrv
		mov	ah, ':'
		mov	ds:ComDrv, al
		add	al, 40h
		std
		cmp	ds:AllocedEnv, 0
		jz	short notwidenv
		mov	di, ds:ComspOffset
		cmp	byte ptr es:[di+1], ':'
		jz	short notwidenv
		push	ds
		push	es
		pop	ds
		lea	si, [di+143]	; lea si,[di+MAX_COMSPEC-3]
		lea	di, [di+145]	; lea di,[di+MAX_COMSPEC-1]
		mov	cx, 144		; MAX_COMSPEC -	2
		rep movsb
		pop	ds
		mov	es:[di-1], ax

notwidenv:				; ...
		cld
		mov	word ptr ds:AUTOBAT, ax
		mov	word ptr ds:KAUTOBAT, ax

nocomdrv:				; ...
		call	SetVect
		push	cs
		push	cs
		pop	ds
		assume ds:RESGROUP
		pop	es
		mov	si, 80h
		lodsb
		mov	di, si
		xor	ah, ah
		add	di, ax
		mov	byte ptr [di], 0Dh
		xor	cx, cx
		mov	num_positionals, cx

Parse_command_line:			; ...
		mov	di, offset INTERNAT_INFO ; offset ResGroup:Parse_Command
		mov	cx, num_positionals
		xor	dx, dx
		mov	old_parse_ptr, si
		call	dword ptr Init_Parse ; call far	[Init_Parse]
		mov	num_positionals, cx
		cmp	ax, 0FFFFh	; -1
		jnz	short t1
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

t1:					; ...
		cmp	ax, 0
		jz	short parse_cont

parse_line_error:			; ...
		push	si
		push	ax
		cmp	ax, 3
		jnz	short parse_line_error_disp
		mov	di, si
		mov	si, old_parse_ptr

init_chk_delim:				; ...
		cmp	si, di
		jz	short parse_line_error_disp
		lodsb
		cmp	al, space
		jz	short init_chk_delim
		cmp	al, 9
		jz	short init_chk_delim
		cmp	al, RSwitChar
		jnz	short parse_line_error_disp
		lodsb
		call	iupconv
		cmp	al, scswitch
		jnz	short check_k_too
		pop	dx
		pop	dx
		jmp	SetSSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

check_k_too:				; ...
		cmp	al, skswitch
		jnz	short parse_line_error_disp
		pop	dx
		pop	dx
		jmp	SetKSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_line_error_disp:			; ...
		pop	ax
		pop	si
		mov	dx, ax
		call	RPrintParse
		call	crlf
		jmp	short Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_cont:				; ...
		cmp	COMND1_SYN, offset COMMAND_F_SYN ; "/F"
		jz	short SetFSwitch
		cmp	COMND1_SYN, offset COMMAND_P_SYN ; "/P"
		jz	short SetPSwitch
		cmp	COMND1_SYN, offset COMMAND_D_SYN ; "/D"
		jz	short SetDSwitch
		cmp	COMND1_SYN, offset COMMAND_C_SYN ; "/C"
		jnz	short parse_cont_1
		jmp	SetSSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_cont_1:				; ...
		cmp	COMND1_SYN, offset COMMAND_K_SYN ; "/K"
		jz	short SetKSwitch
		cmp	COMND1_SYN, offset COMMAND_E_SYN ; "/E"
		jnz	short parse_cont_2
		jmp	SetESwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_cont_2:				; ...
		cmp	COMND1_SYN, offset COMMAND_Y_SYN ; "/Y"
		jnz	short parse_cont_3
		jmp	SetYSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

parse_cont_3:				; ...
		cmp	COMND1_SYN, offset COMMAND_M_SYN ; "/MSG"
		jz	short SetMSwitchjmp
		jmp	ChkOtherArgs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetMSwitchjmp:				; ...
		jmp	SetMswitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetFSwitch:				; ...
		cmp	fFail, 0FFh	; -1
		jnz	short failok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

failok:					; ...
		mov	fFail, 0FFh
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetPSwitch:				; ...
		cmp	PermCom, 0
		jz	short permcomok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

permcomok:				; ...
		inc	PermCom
		mov	OldTerm, offset	LodCom_Trap
		mov	OldTerm+2, ds
		cmp	PRDATTM, 0FFh	; -1
		jnz	short Parse_command_line_jmp
		mov	PRDATTM, 0

Parse_command_line_jmp:			; ...
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetDSwitch:				; ...
		cmp	dswitch, 0
		jz	short setdateok
		mov	ax, 1
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setdateok:				; ...
		inc	dswitch
		mov	PRDATTM, 1
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetKSwitch:				; ...
		mov	SemiPermCom, 0
		jmp	short SetSorKSwitch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetSSwitch:				; ...
		mov	PermCom, 0

SetSorKSwitch:				; ...
		mov	SingleCom, si
		mov	PRDATTM, 1
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetESwitch:				; ...
		cmp	eswitch, 0
		jz	short eswitchok
		mov	ax, 1		; MoreArgs_Ptr
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

eswitchok:				; ...
		inc	eswitch
		mov	di, offset COMND1_ADDR
		mov	bx, [di]
		add	bx, 0Fh
		mov	cl, 4
		shr	bx, cl
		mov	EnvSiz,	bx
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetMswitch:				; ...
		cmp	ext_msg, 1	; SET_EXTENDED_MSG
		jnz	short setMswitchok
		mov	ax, 1		; MoreArgs_Ptr
		jmp	parse_line_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setMswitchok:				; ...
		mov	ext_msg, 1
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetYSwitch:				; ...
		or	byte ptr Y_Flag, 10h
		jmp	Parse_command_line
; END OF FUNCTION CHUNK	FOR StartCode
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	ArgsDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR StartCode

ChkOtherArgs:				; ...
		push	ds
		push	si
		lds	si, COMND1_ADDR
		assume ds:nothing
		mov	dx, si
		mov	ax, 3D02h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short ChkSrchSpec
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short IsaDevice

BadSetCon:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short ChkSrchSpec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IsaDevice:				; ...
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jb	short BadSetCon
		mov	dx, bx
		cmp	es:DevFlag, 1
		jz	short DevErr
		push	cx
		mov	cx, 3
		xor	bx, bx

rcclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	rcclloop
		mov	bx, dx
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	cx
		pop	si
		pop	ds
		inc	es:DevFlag
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DevErr:					; ...
		pop	si
		pop	ds
		mov	dx, 1
		call	RPrintParse
		call	crlf
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ChkSrchSpec:				; ...
		cmp	es:PathFlag, 1
		jz	short DevErr
		inc	es:PathFlag
		call	alloc_env

env_alloced:
		mov	es, ax
		push	si
		xor	cx, cx

countloop:				; ...
		lodsb
		inc	cx
		cmp	al, 0
		jnz	short countloop
		mov	al, ss:space
		dec	si
		mov	[si], al
		push	cx
		mov	cx, 32768	; ENVBIG
		mov	di, ss:ComspOffset
		mov	al, 0
		repne scasb
		mov	si, di

comp_endenv:				; ...
		scasb
		jz	short got_endenv
		repne scasb
		jmp	short comp_endenv
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_endenv:				; ...
		mov	cx, di
		sub	cx, si
		mov	di, ss:ComspOffset
		sub	di, 8		; ComspStrLen
		push	ds
		push	es
		pop	ds
		rep movsb
		dec	di
		push	cs
		pop	ds
		assume ds:RESGROUP
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		mov	cx, 8
		rep movsb
		mov	ComspOffset, di
		pop	ds
		assume ds:nothing
		pop	cx
		pop	si

ComtrLoop:				; ...
		lodsb
		dec	cx
		cmp	al, ss:space
		jz	short SetComsr
		stosb
		jcxz	short SetComsr
		jmp	short ComtrLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetComsr:				; ...
		push	cx
		push	cs
		pop	ds
		assume ds:RESGROUP
		push	ds
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	cx, 14
		mov	al, es:[di-1]
		cmp	al, RDirChar
		jnz	short iNotRoot
		inc	si
		dec	cx

iNotRoot:				; ...
		rep movsb
		mov	dx, ComspOffset
		push	es
		pop	ds
		assume ds:nothing
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		pop	ds
		jb	short SetComsrBad
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

SetComsrRet:				; ...
		pop	cx
		pop	si
		pop	ds
		push	cs
		pop	es
		assume es:RESGROUP
		jmp	Parse_command_line
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SetComsrBad:				; ...
		mov	dx, offset BADCOMLKMES
		call	5A1Ch		; call TriageError (in TRANSCODE)
					; 26E0h+333Ch
		cmp	ax, 65
		jnz	short doprt
		mov	dx, offset BADCOMACCMSG

doprt:					; ...
		call	RPrint
		mov	si, offset COMSPECT ; "\\COMMAND.COM"
		mov	di, ds:ComspOffset
		mov	cx, 14
		rep movsb
		jmp	short SetComsrRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ArgsDone:				; ...
		mov	es, ds:EnvirSeg
		assume es:nothing
		cmp	ds:PermCom, 0
		jz	short ComReturns
		push	es
		mov	ah, 50h
		mov	bx, ds
		mov	es, bx
		int	21h		; DOS -	2+ internal - SET PSP SEGMENT
					; BX = segment address of new PSP
		mov	di, 0Ah		; PDB.EXIT
		mov	ax, offset LodCom_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset Ctrlc_Trap
		stosw
		mov	ax, ds
		stosw
		mov	ax, offset CritErr_Trap
		stosw
		mov	ax, ds
		stosw
		mov	word ptr ds:16h, ds ; [PDB.PARENT_PID]
		mov	dx, offset Int2e_Trap
		mov	ax, 252Eh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	es

ComReturns:				; ...
		mov	ax, ds:16h	; [PDB.PARENT_PID]
		mov	ds:Parent, ax
		mov	word ptr ds:16h, ds
		mov	ax, ds:18h	; [PDB.JFN_TABLE]
		mov	ds:Io_Save, ax
		mov	ds:Com_Ptr+2, ds
		mov	ds:Com_Fcb1+2, ds
		mov	ds:Com_Fcb2+2, ds
		mov	di, offset ComSpec
		mov	si, ds:ComspOffset
		cmp	ds:AllocedEnv, 0
		mov	ax, ds
		push	es
		pop	ds
		mov	es, ax
		jnz	short CopyComsp
		push	cs
		pop	ds
		assume ds:RESGROUP
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		push	es
		push	di
		call	IfindE
		mov	si, di
		push	es
		pop	ds
		assume ds:nothing
		pop	di
		pop	es
		jnb	short CopyComsp
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		add	si, 8		; ComspStrLen
		push	cs
		pop	ds
		assume ds:RESGROUP

CopyComsp:				; ...
		mov	es:PutBackComSpec, di
		cmp	byte ptr [si+1], ':'
		jnz	short CopyComspLoop
		add	es:PutBackComSpec, 2

CopyComspLoop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short CopyComspLoop
		mov	es:ComSpec_End,	di
		dec	es:ComSpec_End
		mov	ah, es:ComDrv
		add	ah, 40h		; 'A' - 1
		mov	es:PutBackDrv, ah
		call	setup_for_messages
		call	Setup_res_end
		push	cs
		pop	ds

EnvMaximum:				; offset RESGROUP:TranStart
		mov	si, 26E0h
		add	si, 100h	; TRANSTART+100h
		mov	cx, 9D53h	; offset TRANGROUP:TranDataEnd - 100h
		cld
		shr	cx, 1
		xor	dx, dx

Ichksum:				; ...
		lodsw
		add	dx, ax
		adc	dx, 0
		loop	Ichksum
		mov	Sum, dx
		cmp	PRDATTM, 0
		jnz	short NoBatchSeg
		mov	bx, 4		; ((BATCHSEGMENT.SIZE)+16+0Fh)/16
					; (33+16+15)/16
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short NoBatchSeg
		mov	Batch, ax

NoBatchSeg:				; ...
		mov	bx, EnvirSeg
		mov	OldEnv,	bx
		mov	UsedEnv, 0
		mov	ds, bx
		assume ds:nothing
		xor	si, si
		mov	di, si
		mov	bx, 0FFFh	; 4096 - 1
		mov	ss:EnvMax, bx
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		shl	bx, 1
		mov	ss:EnvMax, bx
		dec	bx
		xor	dx, dx

NxtStr:					; ...
		call	GetStrLen
		push	ds
		push	cs
		pop	ds
		assume ds:RESGROUP
		add	UsedEnv, cx
		pop	ds
		assume ds:nothing
		cmp	cx, 1
		jz	short EnvExit
		sub	bx, cx
		jnb	short OkCpyStr
		inc	dx
		jmp	short EnvExit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OkCpyStr:				; ...
		jmp	short NxtStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EnvExit:				; ...
		push	cs
		pop	ds
		assume ds:RESGROUP
		or	dx, dx
		jz	short EnvNoErr
		mov	dx, offset OUTENVMSG
		call	RPrint

EnvNoErr:				; ...
		mov	ax, EnvSiz
		mov	cl, 4
		shl	ax, cl
		cmp	ax, UsedEnv
		ja	short st_envsize
		mov	ax, UsedEnv
		add	ax, 15

st_envsize:				; ...
		shr	ax, cl
		mov	EnvSiz,	ax
		cmp	Batch, 0
		jnz	short DoDate
		jmp	NoDttm
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoDate:					; ...
		mov	ax, Batch
		mov	EchoFlag, 3
		mov	Nest, 1
		mov	es, ax
		xor	di, di
		mov	al, 0
		stosb
		mov	al, 1
		stosb
		xor	ax, ax
		stosb
		stosw
		stosw
		stosb
		stosw
		stosw
		mov	ax, 0FFFFh	; -1
		mov	cx, 10
		rep stosw
		cmp	AUTOBAT, 0
		jnz	short NoAutSet
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, ucasea
		mov	AUTOBAT, al
		mov	KAUTOBAT, al

NoAutSet:				; ...
		mov	si, offset AUTOBAT
		mov	cx, 8
		rep movsw
		movsb
		mov	dx, offset AUTOBAT
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short noabat
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	Drv0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

noabat:					; ...
		push	ax
		call	Setup_Seg
		mov	triage_add_seg,	ax
		pop	ax
		call	dword ptr triage_add ; call far	[triage_add]
		cmp	ax, 65
		jz	short AccDenErr
		mov	dx, offset INTERNAT_INFO
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jb	short NoKabat
		cmp	bx, 52h		; KOREA_COUNTRY_CODE
		jnz	short OpenErr
		mov	di, 20h		; BatFile
		mov	si, offset KAUTOBAT
		mov	cx, 8
		rep movsw
		movsb
		mov	dx, offset KAUTOBAT
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short NoKabat
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	short Drv0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoKabat:				; ...
		call	dword ptr triage_add ; call far	[Triage_Add]
		cmp	ax, 65
		jnz	short OpenErr

AccDenErr:				; ...
		mov	dx, offset ACCDEN
		call	RPrint

OpenErr:				; ...
		mov	es, Batch
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	Batch, 0
		mov	EchoFlag, 1
		mov	Nest, 0
		mov	ax, offset DATINIT ; offset TranGroup:Datinit
		mov	InitAdd, ax
		mov	ax, 26E0h	; offset RESGROUP:TranStart
		mov	cl, 4
		shr	ax, cl
		mov	cx, cs
		add	ax, cx
		mov	InitAdd+2, ax
		call	dword ptr InitAdd ; call far [INITADD]

NoDttm:					; ...
		cmp	SingleCom, 0
		jnz	short Drv0
		mov	dx, offset COPYRIGHTMSG
		call	RPrint

Drv0:					; ...
		push	ds
		push	cs
		pop	ds
		mov	ax, 0B707h
		mov	bx, Append_State
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits
		pop	ds
		assume ds:nothing
		cmp	ds:FirstCom, 1
		jz	short move_code
		push	es
		push	ds
		push	ds
		pop	es
		mov	di, offset Int2f_Entry
		mov	ds, es:ResJmpTable+2
		mov	si, es:ResJmpTable
		mov	cx, 11
		shl	cx, 1
		shl	cx, 1
		cld
		rep movsb
		cmp	word ptr es:[di-2], 0F000h
		jb	short res_low
		mov	es:ComInHMA, 1

res_low:				; ...
		pop	ds
		pop	es
		jmp	short finish_init
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

move_code:				; ...
		call	Move_res_code

finish_init:				; ...
		jmp	EndInit
; END OF FUNCTION CHUNK	FOR StartCode

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetStrLen	proc near		; ...
		xor	cx, cx

NxtChar:				; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short NxtChar
		retn
GetStrLen	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Setup_Seg	proc near		; ...
		mov	ax, ds:TrnSeg
		cmp	ds:TrnMvFlg, 1
		jz	short setup_end
		push	bx
		mov	bx, cs
		mov	ax, 26E0h	; offset ResGroup:TranStart
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		shr	ax, 1
		add	ax, bx
		pop	bx

setup_end:				; ...
		retn
Setup_Seg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RPrintParse	proc near		; ...
		push	dx		; display parse	error message
		xchg	bx, dx
		dec	bx
		shl	bx, 1
		mov	bx, ds:PARSMSGPTRS[bx]
		xchg	bx, dx
		call	RPrint
		pop	dx
		retn
RPrintParse	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


IfindE		proc near		; ...
		call	ifind
		jb	short ifind2
		jmp	short Iscasb1
IfindE		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ifind		proc near		; ...
		cld
		call	Icount0
		mov	es, ds:EnvirSeg
		xor	di, di

ifind1:					; ...
		push	cx
		push	si
		push	di

ifind11:				; ...
		lodsb
		call	iupconv
		inc	di
		cmp	al, es:[di-1]
		jnz	short ifind12
		loop	ifind11

ifind12:				; ...
		pop	di
		pop	si
		pop	cx
		jz	short ifind2
		push	cx
		call	Iscasb2
		pop	cx
		cmp	byte ptr es:[di], 0
		jnz	short ifind1
		stc

ifind2:					; ...
		retn
ifind		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Icount0		proc near		; ...
		push	ds
		pop	es
		mov	di, si
		push	di
		call	Iscasb1
		jmp	short Icountx
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		push	di
		call	Iscasb2

Icountx:				; ...
		pop	cx
		sub	di, cx
		xchg	di, cx
		retn
Icount0		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Iscasb1		proc near		; ...
		mov	al, ds:equalsign
		jmp	short Iscasbx
Iscasb1		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Iscasb2		proc near		; ...
		xor	al, al

Iscasbx:				; ...
		mov	cx, 256
		repne scasb
		retn
Iscasb2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


iupconv		proc near		; ...
		cmp	al, 80h
		jb	short other_fucase
		sub	al, 80h
		push	ds
		push	bx
		lds	bx, dword ptr ds:FUCase_Addr+1
		add	bx, 2
		xlat
		pop	bx
		pop	ds
		jmp	short iupconv_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

other_fucase:				; ...
		cmp	al, ds:lcasea
		jb	short iupconv_end
		cmp	al, ds:lcasez
		ja	short iupconv_end
		sub	al, 20h

iupconv_end:				; ...
		retn
iupconv		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

init_contc_specialcase:			; ...
		add	sp, 6
		push	si
		mov	si, dx
		mov	word ptr [si+1], 0D00h
		pop	si
		iret

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


setup_for_messages proc	near		; ...
		push	bx
		push	ds
		push	es
		push	ax
		push	dx
		push	di
		mov	ax, cs
		mov	ds, ax
		assume ds:RESGROUP
		mov	es, ax
		assume es:RESGROUP
		cmp	PermCom, 0
		jz	short no_permcom
		push	es
		mov	ax, 352Fh
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	Int2fHandler, bx
		mov	Int2fHandler+2,	es
		pop	es
		assume es:nothing
		cmp	FirstCom, 0
		jz	short no_msg_hook
		push	ds
		mov	dx, offset Carousel_i2f_Hook
		sub	dx, 10h
		mov	ax, ds
		inc	ax
		mov	ds, ax
		assume ds:nothing
		mov	ax, 252Fh
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		pop	ds
		assume ds:nothing
		mov	word ptr ds:Carousel_i2f_Hook+3, ds

no_msg_hook:				; ...
		cmp	ds:ext_msg, 1
		jnz	short permcom_end
		mov	di, offset ExtMsgEnd
		mov	ds:ResMsgEnd, di
		jmp	short permcom_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_permcom:				; ...
		cmp	ds:ext_msg, 1	; SET_EXTENDED_MSG
		jnz	short permcom_end
		mov	dx, 2
		call	RPrintParse

permcom_end:				; ...
		pop	di
		pop	dx
		pop	ax
		pop	es
		pop	ds
		pop	bx
		retn
setup_for_messages endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckHelp	proc near		; ...
		mov	si, 81h		; DS:SI	= ptr to command-line tail
		mov	di, offset INTERNAT_INFO ; RESGROUP:Parse_Command
		xor	cx, cx
		xor	dx, dx

chParse:				; ...
		call	dword ptr ds:Init_Parse	; call far [Init_Parse]
		cmp	ax, 0FFFFh	; -1
		jz	short chRet
		cmp	ax, 0
		jz	short chWhich
		jmp	short chParse
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chWhich:				; ...
		cmp	ds:COMND1_SYN, offset COMMAND_?_SYN ; "/?"
		jz	short chHelp
		cmp	ds:COMND1_SYN, offset COMMAND_C_SYN ; "/C"
		jz	short chRet
		cmp	ds:COMND1_SYN, offset COMMAND_K_SYN ; "/K"
		jz	short chRet
		jmp	short chParse
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chHelp:					; ...
		mov	si, offset HelpMsgs

chHelpNext:				; ...
		lodsw
		or	ax, ax
		jz	short chHelpDone
		mov	dx, ax
		call	RPrint
		jmp	short chHelpNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chHelpDone:				; ...
		int	20h		; DOS -	PROGRAM	TERMINATION
					; returns to DOS--identical to INT 21/AH=00h
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chRet:					; ...
		retn
CheckHelp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Setup_res_end	proc near		; ...
		push	ds
		mov	ax, cs
		mov	ds, ax
		assume ds:RESGROUP
		mov	cx, ResMsgEnd
		cmp	cx, offset ExtMsgEnd
		jnz	short calc_res
		add	cx, 0Fh
		and	cx, 0FFF0h

calc_res:				; ...
		xor	ax, ax
		cmp	FirstCom, 1
		jnz	short not_first
		push	bx
		push	cx
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		pop	cx
		cmp	bl, 5
		jb	short oldver
		xor	ax, ax
		and	dh, 10h
		pop	bx
		jnz	short not_first
		mov	ax, 81Ah	; size of code in bytes
					; EndCode-RCODE_START

not_first:				; ...
		add	cx, ax
		add	cx, 15
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	ResSize, cx
		pop	ds
		assume ds:nothing
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oldver:					; ...
		pop	bx
		mov	ax, 81Ah	; EndCode-RCODE_START
		jmp	short not_first
Setup_res_end	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Move_res_code	proc near		; ...
		push	ds
		push	es
		mov	ax, cs
		mov	ds, ax
		assume ds:RESGROUP
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		and	dh, 10h
		jnz	short move_high

load_low:				; ...
		push	ds
		pop	es
		assume es:RESGROUP
		mov	di, ResMsgEnd
		mov	bx, offset ExtMsgEnd
		cmp	di, bx
		jz	short no_move
		jmp	short setup_move
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

move_high:				; ...
		mov	bx, 81Ah	; offset CODERES:EndCode
					;
					; RESGROUP:EndCode - RESGROUP:RCODE_START
		mov	di, 0FFFFh
		mov	ax, 4A02h	; GET_HMA_ADDR
		int	2Fh
		cmp	di, 0FFFFh	; HMA available?
		mov	ComInHMA, 1
		jnz	short setup_move
		mov	ComInHMA, 0
		mov	cx, ResMsgEnd
		mov	ax, 81Ah	; EndCode-RCODE_START (CODERES:EndCode)
		add	cx, ax		; ax = para size of res	code
		add	cx, 0Fh
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		mov	ResSize, cx	; resident size
		jmp	short load_low
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_move:				; ...
		mov	cl, 4
		add	di, 0Fh
		and	di, 0FFF0h	; round	it to a	para offset
		jmp	short patch_up
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

setup_move:				; ...
		mov	si, offset Exec_Err ; offset RESGROUP:StartCode
					; RCODE_START
		mov	cx, 81Ah	; offset CODERES:EndCode
					; RESGROUP:EndCode - RESGROUP:RCODE_START
		cld
		push	di
		rep movsb
		pop	di

patch_up:				; ...
		call	patch_stub
		pop	es
		assume es:nothing
		pop	ds
		assume ds:nothing
		retn
Move_res_code	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


alloc_env	proc near		; ...

; FUNCTION CHUNK AT 0F5B SIZE 0000006C BYTES

		push	ds
		push	es
		push	si
		push	di
		push	ss
		pop	ds
		mov	ax, ds:EnvirSeg
		cmp	ds:AllocedEnv, 0
		jz	short alloc_cont
		jmp	alloc_done
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

alloc_cont:				; ...
		sub	di, di
		mov	bx, 180		; SIZE Environment
					; ENVIRONSIZ
		cmp	ds:FirstCom, 0
		jz	short alloc_seg
		or	ax, ax
		jz	short alloc_new

_find_path:
		mov	es, ax
		mov	al, 0
		sub	di, di

comp_path:				; ...
		scasb
		jz	short _find_prompt
		dec	di
		mov	cx, 5		; PathStrLen
		mov	si, offset PathString ;	"PATH="
		repe cmpsb
		jz	short got_path
		mov	cx, 256
		repne scasb
		jmp	short comp_path
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_path:				; ...
		mov	byte ptr ds:PathString,	0 ; "PATH="

_find_prompt:				; ...
		sub	di, di

comp_prompt:				; ...
		scasb
		jz	short find_comspec
		dec	di
		mov	cx, 7		; PrmptStrLen2
		mov	si, offset PrmptString ; "PROMPT=$P$G"
		repe cmpsb
		jz	short got_prompt
		mov	cx, 256
		repne scasb
		jmp	short comp_prompt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_prompt:				; ...
		mov	byte ptr ds:PrmptString, 0 ; "PROMPT=$P$G"

find_comspec:				; ...
		sub	di, di

comp_comspec:				; ...
		scasb
		jz	short got_envend
		dec	di
		mov	cx, 8		; ComspStrLen
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		repe cmpsb
		jz	short got_comspec
		mov	cx, 256
		repne scasb
		jmp	short comp_comspec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_comspec:				; ...
		mov	ds:ComspOffset,	di
		sub	di, di
		mov	cx, 32768	; ENVBIG (maximum environment size)

comp_envend:				; ...
		dec	cx
		scasb
		jz	short got_envend
		repne scasb
		jmp	short comp_envend
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_envend:				; ...
		dec	di
		lea	bx, [di+180]	; lea bx,[di+SIZE Environment]
					; lea bx,[di+ENVIRONSIZ]
		push	ds
		mov	ds, word ptr ds:16h ; [PDB.PARENT_PID]
		cmp	word ptr ds:16h, 0
		pop	ds
		jnz	short alloc_seg

alloc_new:				; ...
		inc	ds:AllocedEnv

alloc_seg:				; ...
		mov	cx, bx
		add	bx, 15
		shr	bx, 1
		shr	bx, 1
		shr	bx, 1
		shr	bx, 1
		mov	ah, 48h		; mov ah,ALLOC
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jnb	short init_ok
		jmp	init_nomem
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

init_ok:				; ...
		mov	es, ax
		assume es:nothing
		or	di, di
		jz	short copy_path
		push	cx
		push	ds
		mov	ds, ds:EnvirSeg
		sub	si, si
		mov	cx, di
		sub	di, di
		rep movsb
		pop	ds
		pop	cx
		sub	cx, di

copy_path:				; ...
		push	di
		sub	ax, ax
		rep stosb
		pop	di
		mov	si, offset PathString ;	"PATH="
		cmp	[si], al
		jz	short init_prompt
		mov	cx, 6		; PathStrLen+1
		rep movsb
		cmp	ds:AllocedEnv, al
		jz	short init_prompt
		mov	ah, 19h		; mov ah,GET_DEFAULT_DRIVE
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 'A'
		mov	byte ptr ds:DefPathString, al ;	"C:\\MSDOS"
		mov	byte ptr ds:DefPath2String, al ; "C:\\DOS"
		mov	dl, 0
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		mov	byte ptr [di], '\'
		lea	si, [di+1]
		mov	ah, 47h		; mov ah,Current_Dir
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		pop	ds
		assume ds:nothing
		mov	cx, 9		; DefPathStrLen+1
		mov	dx, offset DefPathString ; "C:\\MSDOS"
		mov	si, dx
		mov	ah, 3Bh		; mov ah,CHDir
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short init_setpath
		mov	cx, 7		; DefPath2StrLen+1
		mov	dx, offset DefPath2String ; "C:\\DOS"
		mov	si, dx
		mov	ah, 3Bh		; mov ah,CHDir
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short init_prompt

init_setpath:				; ...
		mov	dx, di
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		mov	ah, 3Bh		; mov ah,CHDir
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
		assume ds:nothing
		dec	di
		rep movsb

init_prompt:				; ...
		push	di
		sub	ax, ax
		mov	cx, 64
		rep stosb
		pop	di
		cmp	ds:AllocedEnv, al
		jz	short init_comspec
		mov	si, offset PrmptString ; "PROMPT=$P$G"
		cmp	[si], al
		jz	short init_comspec
		mov	cx, 12		; PrmptStrLen+1
		rep movsb

init_comspec:				; ...
		cmp	ds:ComspOffset,	ax
		jnz	short init_done
		lea	ax, [di+8]	; lea ax,[di+ComspStrLen]
		mov	ds:ComspOffset,	ax
		mov	si, offset ComspString ; "COMSPEC=\\COMMAND.COM"
		mov	cx, 21		; ComspStrLen2+1
		rep movsb

init_done:				; ...
		mov	ax, es
		mov	ds:EnvirSeg, ax
		inc	ds:AllocedEnv

alloc_done:				; ...
		pop	di
		pop	si
		pop	es
		assume es:nothing
		pop	ds
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

init_nomem:				; ...
		call	$+3		; call alloc_error

Alloc_error:				; ...
		jmp	BadMemErr
alloc_env	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


patch_stub	proc near		; ...
		push	es
		mov	bx, es
		mov	dx, di
		mov	di, offset Int2f_Entry ; offset	DATARES:Int2f_Entry
		mov	si, offset Reloc_Table ; offset	RESGROUP:Reloc_Table
		push	ds
		pop	es
		mov	cx, 11

patchlp:				; ...
		lodsw
		add	ax, dx
		stosw
		mov	ax, bx
		stosw
		loop	patchlp
		pop	es
		retn
patch_stub	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


patch_segs	proc near		; ...
		mov	di, offset Int2f_Entry
		mov	cx, 4
		add	di, 2
		mov	ax, es

pseglp:					; ...
		stosw
		add	di, 2
		loop	pseglp
		retn
patch_segs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_XMMAddr	proc near		; ...
		push	es
		mov	ax, 4300h
		int	2Fh		; - Multiplex -	XMS - INSTALLATION CHECK
					; Return: AL = 80h XMS driver installed
					; AL <>	80h no driver
		cmp	al, 80h
		jnz	short cXMMexit
		mov	ax, 4310h
		int	2Fh		; - Multiplex -	XMS - GET DRIVER ADDRESS
					; Return: ES:BX	-> driver entry	point
		mov	word ptr ds:XMMCallAddr, bx
		mov	word ptr ds:XMMCallAddr+2, es

cXMMexit:				; ...
		pop	es
		retn
get_XMMAddr	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		db 15 dup(0)
ICONDEV		db '/DEV/CON',0,0,0,0,0,0
BADCSPFL	db 0
COMSPECT	db '\COMMAND.COM',0     ; ...
		db 0
AUTOBAT		db 0			; ...
		db ':\AUTOEXEC.BAT',0
		db 0Dh
KAUTOBAT	db 0			; ...
		db ':\KAUTOEXE.BAT',0
		db 0Dh
PRDATTM		db 0FFh			; ...
InitAdd		dw 2 dup(0)		; ...
print_add	dw offset Printf_Init
print_add_seg	dw 0
triage_add	dw offset Triage_Init	; ...
triage_add_seg	dw 0			; ...
AllocedEnv	db 0			; ...
PathString	db 'PATH=',0            ; ...
DefPathString	db 'C:\MSDOS',0         ; ...
DefPath2String	db 'C:\DOS',0           ; ...
PrmptString	db 'PROMPT=$P$G',0      ; ...
ComspOffset	dw 0			; ...
ComspString	db 'COMSPEC=\COMMAND.COM',0 ; ...
equalsign	db '='                  ; ...
lcasea		db 'a'                  ; ...
lcasez		db 'z'                  ; ...
space		db 20h			; ...
scswitch	db 'C'                  ; ...
skswitch	db 'K'                  ; ...
ucasea		db 'A'                  ; ...
EnvSiz		dw 0			; ...
EnvMax		dw 0			; ...
OldEnv		dw 0			; ...
UsedEnv		dw 0			; ...
PARS_MSG_OFF	dw 0
PARS_MSG_SEG	dw 0
Init_Parse	dw offset append_parse	; ...
initend		dw 0			; ...
TrnSize		dw 0			; ...
resetenv	db 0
ext_msg		db 0			; ...
eswitch		db 0			; ...
dswitch		db 0			; ...
parsemes_ptr	dw 0
INTERNAT_INFO	dw offset COMMAND_PARMS	; ...
					; PARSE_COMMAND
		db 0
COMMAND_PARMS	db 0			; ...
		db 2
		dw offset COMMAND_FILE
		dw offset COMMAND_FILE
		db 9
		dw offset COMMAND_SWITCH1
		dw offset COMMAND_SWITCH2
		dw offset COMMAND_SWITCH3
		dw offset COMMAND_SWITCH4
		dw offset COMMAND_SWITCH5
		dw offset COMMAND_SWITCH6
		dw offset COMMAND_SWITCH7
		dw offset COMMAND_SWITCH8
		dw offset COMMAND_SWITCH9
		db 0
COMMAND_FILE	dw 201h			; ...
		dw 1
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 0
COMMAND_SWITCH1	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_P_SYN	db '/P',0               ; ...
COMMAND_SWITCH2	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_F_SYN	db '/F',0               ; ...
COMMAND_SWITCH3	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_D_SYN	db '/D',0               ; ...
COMMAND_SWITCH4	dw 8000h		; ...
		dw 0
		dw offset COMND1_OUTPUT
		dw offset COMMAND_E_VAL
		db 1
COMMAND_E_SYN	db '/E',0               ; ...
COMMAND_E_VAL	db 1			; ...
		db 1
		db 1
		dd 160			; ENVSML
		dd 32768		; ENVBIG
		db 0
		db 0
COMMAND_SWITCH5	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_C_SYN	db '/C',0               ; ...
COMMAND_SWITCH6	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_M_SYN	db '/MSG',0             ; ...
COMMAND_SWITCH7	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_?_SYN	db '/?',0               ; ...
COMMAND_SWITCH8	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_K_SYN	db '/K',0               ; ...
COMMAND_SWITCH9	dw 0			; ...
		dw 2
		dw offset COMND1_OUTPUT
		dw offset NO_VAL
		db 1
COMMAND_Y_SYN	db '/Y',0               ; ...
COMND1_OUTPUT	db 0			; ...
COMND1_CODE	db 0
COMND1_SYN	dw 0			; ...
COMND1_ADDR	dd 0			; ...
NO_VAL		db 0			; ...
num_positionals	dw 0			; ...
old_parse_ptr	dw 0			; ...
BADVERMSG	db 17h			; ...
		db 'Incorrect DOS version',0Dh,0Ah
OUTENVMSG	db 1Ah			; ...
		db 'Out of environment space',0Dh,0Ah
COPYRIGHTMSG	db 5Eh			; ...
		db 0Dh,0Ah
		db 0Dh,0Ah
		db 'Microsoft(R) MS-DOS(R) Version 6.22',0Dh,0Ah
		db '             (C)Copyright Microsoft Corp 1981-1994.',0Dh,0Ah
BADCOMLKMES	db 28h			; ...
		db 'Specified COMMAND search directory bad',0Dh,0Ah
BADCOMACCMSG	db 37h			; ...
		db 'Specified COMMAND search directory bad, access denied',0Dh,0Ah
HELPMSG1	db 38h			; ...
		db 'Starts a new copy of the MS-DOS Command Interpreter.',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG2	db 38h			; ...
		db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P [/MSG]]',0Dh,0Ah
HELPMSG3	db 2Ah			; ...
		db '        [/Y [/C command | /K command]]',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG4	db 48h			; ...
		db '  [drive:]path    Specifies the directory containing COMMAND.COM '
		db 'file.',0Dh,0Ah
HELPMSG5	db 4Dh			; ...
		db '  device          Specifies the device to use for command input a'
		db 'nd output.',0Dh,0Ah
HELPMSG6	db 45h			; ...
		db '  /E:nnnnn        Sets the initial environment size to nnnnn byte'
		db 's.',0Dh,0Ah
HELPMSG7	db 4Dh			; ...
		db '  /P              Makes the new Command Interpreter permanent (ca'
		db 'n',27h,'t exit).',0Dh,0Ah
HELPMSG8	db 46h			; ...
		db '  /MSG            Stores all error messages in memory (requires /'
		db 'P).',0Dh,0Ah
HELPMSG9	db 4Ah			; ...
		db '  /Y              Steps through the batch program specified by /C'
		db ' or /K.',0Dh,0Ah
HELPMSG10	db 3Fh			; ...
		db '  /C command      Executes the specified command and returns.',0Dh,0Ah
HELPMSG11	db 4Bh			; ...
		db '  /K command      Executes the specified command and continues ru'
		db 'nning.',0Dh,0Ah
		db 0Dh,0Ah
HELPMSG12	db 4Ch			; ...
		db 'The /P and /MSG switches may be used only when COMMAND is started'
		db ' by using',0Dh,0Ah
HELPMSG13	db 2Bh			; ...
		db 'the SHELL command in the CONFIG.SYS file.',0Dh,0Ah
HelpMsgs	dw offset HELPMSG1	; ...
		dw offset HELPMSG2
		dw offset HELPMSG3
		dw offset HELPMSG4
		dw offset HELPMSG5
		dw offset HELPMSG6
		dw offset HELPMSG7
		dw offset HELPMSG8
		dw offset HELPMSG9
		dw offset HELPMSG10
		dw offset HELPMSG11
		dw offset HELPMSG12
		dw offset HELPMSG13
		dw 0
Reloc_Table	dw 738h			; ...
					; 738h+0E50h = MsgInt2fHandler
		dw 177h			; 177h+0E50h = Int_2e
		dw 35h			; 035h+0E50h = ContC
		dw 445h			; 445h+0E50h = DskErr
		dw 29h			; 029h+0E50h = Exec_Ret
		dw 2A3h			; 2A3h+0E50h = TRemCheck
		dw 422h			; 422h+0E50h = TrnLodCom1
		dw 1AEh			; 1AEh+0E50h = LodCom
		dw 77Bh			; 77Bh+0E50h = MsgRetriever
		dw 2C2h			; 2C2h+0E50h = THeadFix
		dw 7F4h			; 7F4h+0E50h = Lh_OffUnlink
ResJmpTable	dw 2 dup(0)		; ...
FirstCom	db 0			; ...
DevFlag		db 0			; ...
PathFlag	db 0			; ...
		db 2 dup(0)
RESGROUP	ends

; ÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍÍ

; Segment type:	Pure code
TRANGROUP	segment	byte public 'CODE' use16
		assume cs:TRANGROUP
		assume es:nothing, ss:nothing, ds:nothing, fs:nothing, gs:nothing
TRANSTART	db 256 dup(0)
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

SETDRV:					; ...
		mov	ah, 0Eh
		int	21h		; DOS -	SELECT DISK
					; DL = new default drive number	(0 = A,	1 = B, etc.)
					; Return: AL = number of logical drives

TCOMMAND:				; ...
		mov	ds, cs:RESSEG
		mov	ax, 0FFFFh	; -1
		xchg	ax, ds:VerVal
		cmp	ax, 0FFFFh
		jz	short NOSETVER2
		mov	ah, 2Eh
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOSETVER2:				; ...
		call	dword ptr cs:HEADCALL ;	call far [cs:HEADCALL]
		xor	bp, bp
		cmp	ds:SingleCom, 0FFFFh ; -1
		jnz	short COMMAND

_$EXITPREP:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	_$EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COMMAND:				; ...
		cld
		mov	ax, cs
		cli
		mov	ss, ax
		assume ss:TRANGROUP
		mov	sp, offset STACK
		sti
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		call	TSYSLOADMSG
		mov	append_exec, 0
		mov	ds, RESSEG
		assume ds:nothing
		mov	ss:UCOMBUF, 128
		mov	ss:COMBUF, 128
		or	bp, bp
		jz	short TESTRDIR
		mov	word ptr ss:UCOMBUF+1, 0D01h
		jmp	short NOSETBUF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTRDIR:				; ...
		cmp	ds:RestDir, 0
		jz	short NOSETBUF
		push	ds
		mov	ds:RestDir, 0
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		pop	ds
		assume ds:nothing

NOSETBUF:				; ...
		cmp	ds:PipeFiles, 0
		jz	short NOPCLOSE
		cmp	ds:PipeFlag, 0
		jnz	short NOPCLOSE
		call	PIPEDEL

NOPCLOSE:				; ...
		mov	ds:ExtCom, 0
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		push	ax
		mov	dx, offset STACK ; offset INTERNATVARS
		mov	ax, 3800h	; mov ax,INTERNATIONAL*256
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		sub	ax, TPA
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ
		mov	ax, 0FFFFh	; -1

SAVSIZ:					; ...
		cmp	ax, 512
		jbe	short GOTSIZE
		and	ax, 0FE00h	; ~1FFh	(NOT 511)

GOTSIZE:				; ...
		mov	BYTCNT,	ax
		mov	ds, RESSEG
		assume ds:nothing
		test	ds:EchoFlag, 1
		jz	short GETCOM
		call	SINGLETEST
		jb	short GETCOM
		test	ds:PipeFlag, 0FFh ; -1
		jnz	short GETCOM
		test	ds:ForFlag, 0FFh
		jnz	short GETCOM
		test	ds:Batch, 0FFFFh ; -1
		jnz	short GETCOM
		call	CRLF2

GETCOM:					; ...
		cmp	ds:SingleCom, 0
		jnz	short GETCOM2
		test	ds:Batch, 0FFFFh
		jnz	short GETCOM2
		and	byte ptr ds:Y_Flag, 0EFh ; Y/N question	overwrite flag

GETCOM2:				; ...
		mov	ds:Call_Flag, 0
		mov	ds:Call_Batch_Flag, 0
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		mov	ss:CURDRV, al
		test	ds:PipeFlag, 0FFh
		jz	short NOPIPE
		jmp	PIPEPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPIPE:					; ...
		test	ds:EchoFlag, 1
		jz	short NOPDRV
		call	SINGLETEST
		jb	short NOPDRV
		test	ds:ForFlag, 0FFh
		jnz	short NOPDRV
		test	ds:Batch, 0FFFFh
		jnz	short TESTFORBAT
		call	PRINT_PROMPT

NOPDRV:					; ...
		test	ds:ForFlag, 0FFh
		jz	short TESTFORBAT
		jmp	FORPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTFORBAT:				; ...
		mov	ss:RE_INSTR, 0
		mov	ds:Re_OutStr, 0
		mov	ds:Re_Out_App, 0
		mov	ds:IfFlag, 0
		test	ds:Batch, 0FFFFh
		jz	short ISNOBAT
		push	es
		push	ds
		mov	ax, 1902h	; mult_shell_get
		mov	es, ds:Batch
		assume es:nothing
		mov	di, 20h
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset COMBUF
		int	2Fh		; - Multiplex -	DOS 4.x	only SHELLB.COM	- COMMAND.COM INTERFACE
					; ES:DI	-> ASCIZ full filename of current batch	file, with at least the
					; final	filename element uppercased
					; DS:DX	-> buffer for results
		cmp	al, 0FFh	; shell_action
		pop	ds
		assume ds:nothing
		pop	es
		jz	short JDOCOM1
		push	ds
		call	READBAT
		pop	ds
		mov	ds:NullFlag, 0
		test	ds:Batch, 0FFFFh
		jnz	short JDOCOM1
		mov	bx, ds:Next_Batch
		cmp	bx, 0
		jz	short JDOCOM1
		mov	ds:Batch, bx
		mov	ds:Next_Batch, 0

JDOCOM1:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	short DOCOM0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISNOBAT:				; ...
		cmp	ds:SingleCom, 0
		jz	short REGCOM
		mov	si, ds:SemiPermCom
		xchg	si, ds:SingleCom
		mov	di, (offset COMBUF+2)
		xor	cx, cx

SINGLELOOP:				; ...
		lodsb
		stosb
		inc	cx
		cmp	al, 0Dh
		jnz	short SINGLELOOP
		dec	cx
		push	cs
		pop	ds
		mov	COMBUF+1, cl
		jmp	short DOCOM0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REGCOM:					; ...
		mov	ax, 5D09h	; (SERVERCALL<<8)+9
		int	21h		; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
		mov	ax, 5D08h	; (SERVERCALL<<8)+8
		mov	dl, 1
		int	21h		; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
					; DL = 00h redirected output is	combined
					;      01h redirected output placed in separate	jobs
					; start	new print job now
		push	cs
		pop	ds
		mov	dx, offset UCOMBUF
		mov	ax, 4810h	; AX = DOSKey Read Line	function
		int	2Fh
		or	ax, ax
		jz	short GOTCOM
		mov	ah, 0Ah		; Std_Con_String_Input
		int	21h		; DOS -	BUFFERED KEYBOARD INPUT
					; DS:DX	-> buffer

GOTCOM:					; ...
		mov	cl, UCOMBUF
		xor	ch, ch
		add	cx, 3
		mov	si, offset UCOMBUF
		mov	di, offset COMBUF
		rep movsb
		call	CRLF2
		xor	ax, ax
		jmp	short DOCOM2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOCOM:					; ...
		call	CRLF2

DOCOM0:					; ...
		mov	ax, 1		; cox_Y_option = yes (1)

DOCOM2:					; ...
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		mov	ds:cox_Y_option, ax
		pop	ds
		mov	si, offset COMBUF
		mov	cl, [si+1]
		xor	ch, ch
		add	si, 2
		call	get_cox_y_n_opt
		jnb	short DOCOM1	; YES answer
		jmp	NULLCOM		; NO answer
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOCOM1:					; ...
		call	PRESCAN
		jz	short NOPIPEPROC
		jmp	PIPEPROCSTRT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NULLCOMJ:				; ...
		jmp	NULLCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPIPEPROC:				; ...
		call	PARSELINE
		jnb	short OKPARSE

BADPARSE:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADNAM_PTR
		call	std_eprintf
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OKPARSE:				; ...
		test	ARGV0_ARG_FLAGS, 2 ; [ARG+ARGV_ELE.argflags],wildcard
		jnz	short BADPARSE
		cmp	ARG_ARGVCNT, 0	;  [ARG+ARG_UNIT.argvcnt]
		jz	short NULLCOMJ
		cmp	ARGV0_ARGLEN, 0	; [ARG+ARGV_ELE.arglen]
		jz	short NULLCOMJ
		mov	si, (offset COMBUF+2)
		mov	di, offset IDLEN
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, ARG_ARGV	; [ARG+ARG_UNIT.argv]
		cmp	byte ptr [bx+1], ':'
		jnz	short DRVGD
		mov	dl, [bx]
		and	dl, 0DFh
		sub	dl, 'A'
		cmp	al, 0FFh	; -1
		jz	short DRVBADJ
		mov	di, ARGV0_ARGSTARTEL ; [ARG+ARGV_ELE.argstartel]
		cmp	byte ptr [di], 0
		jnz	short DRVGD
		jmp	SETDRV
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRVBADJ:				; ...
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRVGD:					; ...
		mov	al, [di]
		mov	SPECDRV, al
		mov	al, 20h	; ' '
		mov	cx, 9
		inc	di
		repne scasb
		mov	al, 8
		sub	al, cl
		mov	IDLEN, al
		mov	di, 81h
		push	si
		mov	si, (offset COMBUF+2)
		call	scanoff
		inc	si

DO_SKIPCOM:				; ...
		lodsb
		call	DELIM
		jz	short DO_SKIPPED
		cmp	al, 0Dh
		jz	short DO_SKIPPED
		cmp	al, SWITCHAR
		jnz	short DO_SKIPCOM

DO_SKIPPED:				; ...
		dec	si
		xor	cx, cx

COMTAIL:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		loopne	COMTAIL
		dec	di
		mov	bp, di
		not	cl
		mov	TRANSTART+80h, cl ; mov	[80h],cl
		pop	si
		mov	di, ARGV0_ARGSW_WORD ; [ARG+ARGV_ELE.argsw_word]
		mov	COMSW, di
		mov	si, ARGV1_ARGPOINTER ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
		or	si, si
		jnz	short DOPARSE
		mov	si, bp

DOPARSE:				; ...
		mov	di, 5Ch		; mov di,FCB ; 5Ch
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	PARM1, al
		mov	di, ARGV1_ARGSW_WORD ; [ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
		mov	ARG1S, di
		mov	si, ARGV2_ARGPOINTER ; [ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
		or	si, si
		jnz	short DOPARSE2
		mov	si, bp

DOPARSE2:				; ...
		mov	di, 6Ch		; mov di,FCB+10h ; 6Ch
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	PARM2, al
		mov	di, ARGV2_ARGSW_WORD ; [ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
		mov	ARG2S, di
		mov	di, ARGV0_ARGSW_WORD ; [ARG+ARGV_ELE.argsw_word]
		not	di
		and	di, ARG_ARGSWINFO ; [ARG+ARG_UNIT.argswinfo]
		mov	ARGTS, di
		mov	al, IDLEN
		mov	dl, SPECDRV
		or	dl, dl
		jnz	short EXTERNALJ1
		dec	al
		jmp	FNDCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXTERNALJ1:				; ...
		jmp	EXTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NULLCOM:				; ...
		mov	ds, RESSEG
		assume ds:nothing
		test	ds:Batch, 0FFFFh ; -1
		jz	short NOSETFLAG
		mov	ds:NullFlag, 1	; mov byte [NullFlag],nullcommand

NOSETFLAG:				; ...
		cmp	ds:SingleCom, 0FFFFh ; -1
		jz	short EXITJ
		jmp	GETCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXITJ:					; ...
		jmp	_$EXITPREP
; END OF FUNCTION CHUNK	FOR _$IF

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_cox_y_n_opt	proc near		; ...
		jcxz	short ccydp4	; empty	input buffer

ccydp0:
		cmp	byte ptr [si], 0Dh
		jz	short ccydp4
		cmp	byte ptr [si], 0Ah
		jz	short ccydp4
		push	es
		mov	es, ds:RESSEG
		mov	al, byte ptr es:Y_Flag
		test	al, 10h		; bit 1	= 1 -> Y/N answer is needed
		jz	short ccydp3
		cmp	es:Call_Batch_Flag, 1 ;	(in) Batch file	?
		jz	short ccydp3	; yes, don't check for ESCAPE
		test	al, 40h		; ESCAPE status
					; (bit 4 is zero if Y/N	is excaped)
		jz	short ccydp5

ccydp1:					; ...
		test	es:Batch, 0FFFFh
		jz	short ccydp2
		mov	es, es:Batch
		mov	byte ptr es:2, 1 ; [es:BATCHSEGMENT.BatchEOF]

ccydp2:					; ...
		stc
		pop	es
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccydp3:					; ...
		pop	es

ccydp4:					; ...
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccydp5:					; ...
		mov	dx, si
		mov	bx, 2
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		mov	dx, offset cox_Y_quest_ptr ; msg number	pointer	of ' [Y/N]?' (is 1082)
		call	std_eprintf
		push	ds
		mov	ax, 1083	; cox_Y_answer number (overwrite Y/N answer letter)
		mov	dh, 0FFh	; utility_msg_class
		call	TSYSGETMSG
		mov	cx, 'NY'        ; 'YN' Yes/No (CL=Y)
		jb	short ccydp6
		mov	cx, [si]

ccydp6:					; ...
		pop	ds

ccydp7:					; ...
		mov	ah, 8
		int	21h		; DOS -	KEYBOARD INPUT,	NO ECHO
					; Return: AL = character
		test	al, al
		jnz	short ccydp8
		mov	ah, 8
		int	21h		; DOS -	KEYBOARD INPUT,	NO ECHO
					; Return: AL = character
		cmp	al, '?'
		jnz	short ccydp7
		or	byte ptr es:Y_Flag, 40h	; bit 4, question flag
		jmp	short ccydp1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccydp8:					; ...
		cmp	al, 1Bh		; ESCAPE ?
		jnz	short ccydp9
		and	byte ptr es:Y_Flag, 0EFh ; (ESCAPE) Clear bit 4	; ~10h
		jmp	short ccydp12
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccydp9:					; ...
		and	al, 0DFh	; uppercase
		cmp	al, ch		; NO character (N)
		jnz	short ccydp10
		stc
		jmp	short ccydp11	; cf = 1 -> overwrite NO answer
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccydp10:				; ...
		cmp	al, cl		; YES character	(Y)
		jnz	short ccydp7

ccydp11:				; ...
		pushf			; cf = 0 -> overwrite YES answer
		mov	dl, al
		mov	ah, 2
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		popf

ccydp12:				; ...
		pushf
		call	CRLF2
		popf
		pop	es
		retn
get_cox_y_n_opt	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ROM_SCAN	proc near		; ...
		push	es
		push	si
		push	di
		push	cx
		push	ax
		push	bx
		mov	ax, 0F000h
		mov	es, ax
		assume es:nothing
		cmp	byte ptr es:0FFFEh, 0FDh
		jz	short SCAN_IT

NO_ROM:					; ...
		clc

ROM_RET:				; ...
		pop	bx
		pop	ax
		pop	cx
		pop	di
		pop	si
		pop	es
		assume es:nothing
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_IT:				; ...
		mov	ax, 0C000h

SCAN_ONE:				; ...
		mov	es, ax
		assume es:nothing
		xor	di, di
		cmp	word ptr es:[di], 0AA55h
		jz	short SCAN_LIST
		add	ax, 80h

SCAN_END:				; ...
		cmp	ax, 0F000h
		jb	short SCAN_ONE
		jmp	short NO_ROM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_LIST:				; ...
		mov	bl, es:[di+2]	; [es:di+ROM_HEADER.rom_length]
		xor	bh, bh
		shl	bx, 1
		shl	bx, 1
		add	bx, 7Fh
		and	bx, 0FF80h	; round	to 2k
		mov	di, 6		; ROM_HEADER.name_list

SCAN_NAME:				; ...
		mov	cl, es:[di]
		inc	di
		xor	ch, ch
		or	cx, cx
		jnz	short SCAN_TEST
		add	ax, bx
		jmp	short SCAN_END
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_TEST:				; ...
		mov	si, dx
		inc	si
		repe cmpsb
		jz	short SCAN_FOUND

SCAN_NEXT:				; ...
		add	di, cx
		add	di, 3
		jmp	short SCAN_NAME
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCAN_FOUND:				; ...
		cmp	byte ptr [si], 3Fh ; '?'
		jz	short SCAN_SAVE
		cmp	byte ptr [si], 20h ; ' '
		jnz	short SCAN_NEXT

SCAN_SAVE:				; ...
		mov	cs:ROM_CS, es
		mov	cs:ROM_IP, di
		stc
		jmp	short ROM_RET
ROM_SCAN	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

ROM_EXEC:				; ...
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		push	bx
		push	ax
		mov	ax, 2522h	; (SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
		push	ds
		mov	ds, cs:RESSEG
		mov	dx, offset Exec_Wait
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		mov	dx, ds
		mov	es, dx
		assume es:nothing
		pop	ds
		pop	dx
		mov	ah, 55h
		int	21h		; DOS -	2+ internal - CREATE PSP
					; DX = segment number at which to set up PSP
					; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		mov	ds, dx
		mov	dx, 80h
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ax, es:EnvirSeg
		mov	ds:2Ch,	ax	; [PDB.ENVIRON]
		pop	bx
		mov	dx, ds
		add	dx, bx
		mov	ds:2, dx	; [PDB.BLOCK_LEN]
		mov	dx, ds
		dec	dx
		mov	ds, dx
		assume ds:nothing
		inc	dx
		mov	ds:1, dx	; [ARENA.owner]
		mov	ds, dx
		assume ds:nothing
		cmp	bx, 1000h
		jb	short GOT_STACK
		xor	bx, bx

GOT_STACK:				; ...
		mov	cl, 4
		shl	bx, cl
		mov	dx, ds
		mov	ss, dx
		assume ss:nothing
		mov	sp, bx
		xor	ax, ax
		push	ax
		not	ax
		push	cs:ROM_CS
		push	cs:ROM_IP
		mov	es, dx
		retf
; END OF FUNCTION CHUNK	FOR _$IF

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PROMPTBAT	proc near		; ...
		call	BATOPEN
		jb	short PROMPTBAT1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PROMPTBAT1:				; ...
		cmp	dx, 2		; ERROR_FILE_NOT_FOUND
		jz	short BAT_REMCHECK
		cmp	dx, 3		; ERROR_PATH_NOT_FOUND
		jz	short BAT_REMCHECK
		call	output_batch_name
		jmp	short BATDIE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BAT_REMCHECK:				; ...
		call	cs:RCH_ADDR	; call far [cs:RCH_ADDR]
		jz	short ASKFORBAT
		call	FOROFF
		call	PipeOff
		mov	ds:IfFlag, al
		mov	dx, offset BADBAT_PTR

BATDIE:					; ...
		call	BATCHOFF
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	std_eprintf
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ASKFORBAT:				; ...
		push	ds
		push	cs
		pop	ds
		mov	dx, offset NEEDBAT_PTR
		call	std_eprintf
		mov	dx, offset PAUSEMES_PTR
		call	std_eprintf
		call	GETKEYSTROKE
		pop	ds
		assume ds:nothing
		jmp	short PROMPTBAT
PROMPTBAT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


output_batch_name proc near		; ...
		push	ds
		mov	ds, ds:Batch
		mov	si, 20h		; BATCHSEGMENT.BatFile
		call	dstrlen
		mov	di, offset BWDBUF
		rep movsb
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	extend_buf_ptr,	dx
		mov	msg_disp_class,	1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	string_ptr_2, offset BWDBUF
		mov	extend_buf_sub,	1 ; one_subst
		pop	ds
		assume ds:nothing
		retn
output_batch_name endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETKEYSTROKE	proc near		; ...
		push	dx
		mov	ax, 6302h	; (ECS_call SHL	8) OR GetInterimMode
		int	21h		; DOS -	3.2+ only - GET	KOREAN (HONGEUL) INPUT MODE
		push	dx
		mov	ax, 6301h	; (ECS_call SHL	8) OR SetInterimMode
		mov	dl, 1		; InterimMode
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		mov	ax, 0C08h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 0C00h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		mov	ax, 6301h	; (ECS_call SHL	8) OR SetInterimMode
		pop	dx
		int	21h		; DOS -	3.2+ only - SET	KOREAN (HONGEUL) INPUT MODE
					; DL = new mode
					; 00h return only full characters on DOS keyboard input	functions
					; 01h return partially-formed characters also
		pop	dx
		retn
GETKEYSTROKE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


READBAT		proc near		; ...
		mov	ds:Suppress, 1	; YES_ECHO
		test	ds:Batch_Abort,	0FFh
		jnz	short TRYING_TO_ABORT
		mov	ds:In_Batch, 1
		push	ds
		mov	ds, ds:Batch
		cmp	byte ptr ds:2, 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		jz	short CONTBAT
		call	GETBATBYT
		mov	es:COMBUF+2, al
		call	CRLF2
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONTBAT:				; ...
		call	PROMPTBAT

TRYING_TO_ABORT:			; ...
		mov	di, (offset COMBUF+2)

TESTNOP:				; ...
		mov	ax, ds
		mov	ds, ds:Batch
		push	word ptr ds:8	; [BATCHSEGMENT.BatSeek]
		push	word ptr ds:10	; [BATCHSEGMENT.BatSeek+2]
		mov	ds, ax
		call	SKIPDELIM
		cmp	al, ':'
		pop	cx
		pop	dx
		jz	short NOPLINE
		test	ds:Batch, 0FFFFh
		jz	short RDBAT
		cmp	al, '@'         ; No_Echo_Char
		jnz	short SET_BAT_POS
		mov	ds:Suppress, 0	; NO_ECHO
		jmp	short RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SET_BAT_POS:				; ...
		push	ds
		mov	ds, ds:Batch
		mov	ds:8, dx
		mov	ds:10, cx
		pop	ds
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	es:BATBUFPOS, 0FFFFh
		xor	cx, cx
		jmp	short RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOPLINE:				; ...
		call	SKIPTOEOL
		call	GETBATBYT
		test	ds:Batch, 0FFFFh
		jnz	short TESTNOP

READBAT_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RDBAT:					; ...
		call	GETBATBYT
		inc	cx
		call	testkanj
		jz	short RDBAT1
		cmp	cx, 127		; COMBUFLEN-1
		jnb	short TOOLONG
		stosb
		call	GETBATBYT
		inc	cx
		jmp	short SAVBATBYT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

RDBAT1:					; ...
		cmp	cx, 128		; COMBUFLEN
		jnb	short TOOLONG
		cmp	al, '%'
		jz	short NEEDPARM

SAVBATBYT:				; ...
		stosb
		cmp	al, 0Dh
		jnz	short RDBAT

FOUND_EOL:				; ...
		sub	di, (offset COMBUF+3)
		mov	ax, di
		mov	es:COMBUF+1, al
		call	GETBATBYT
		call	BATCLOSE
		cmp	ds:Suppress, 0	; NO_ECHO
		jz	short RESET
		test	ds:EchoFlag, 1
		jnz	short TRY_NEXTFLAG

RESET:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jz	short READBAT_RETN

TRY_NEXTFLAG:				; ...
		cmp	ds:NullFlag, 1
		jz	short NO_CRLF_PRINT
		call	CRLF2

NO_CRLF_PRINT:				; ...
		call	PRINT_PROMPT
		push	cs
		pop	ds
		mov	dx, (offset COMBUF+2)
		call	CRPRINT
		call	CRLF2
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TOOLONG:				; ...
		cmp	al, 0Dh
		jz	short LTLCONT
		call	SKIPTOEOL

LTLCONT:				; ...
		stosb
		jmp	short FOUND_EOL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEEDPARM:				; ...
		call	GETBATBYT
		cmp	al, '%'
		jz	short SAVBATBYT
		cmp	al, 0Dh
		jz	short SAVBATBYT

PAROK:
		sub	al, '0'
		jb	short NEEDENV
		cmp	al, 9
		ja	short NEEDENV
		cbw
		mov	bx, ax
		shl	bx, 1
		push	es
		mov	es, ds:Batch
		mov	si, es:[bx+0Ch]	; [es:bx+BATCHSEGMENT.BatParm]
		pop	es
		cmp	si, 0FFFFh	; -1
		jnz	short YES_THERE_IS
		jmp	RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

YES_THERE_IS:				; ...
		push	ds
		mov	ds, ds:Batch
		assume ds:nothing
		dec	cx

COPYPARM:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short ENDPARAM
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jnb	short LINETOOL
		stosb
		jmp	short COPYPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LINETOOL:				; ...
		xor	al, al
		pop	ds
		jmp	short TOOLONG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENDPARAM:				; ...
		pop	ds
		jmp	RDBAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEEDENV:				; ...
		dec	cx
		push	ds
		push	di
		mov	di, offset ID
		add	al, '0'
		stosb

GETENV1:				; ...
		call	GETBATBYT
		stosb
		cmp	al, 0Dh
		jnz	short GETENV15
		mov	byte ptr es:[di-1], 0
		mov	si, offset ID
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	STRCPY
		jb	short LINETOOL
		pop	ds
		assume ds:nothing
		jmp	SAVBATBYT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GETENV15:				; ...
		cmp	al, '%'
		jnz	short GETENV1
		mov	al, '='
		mov	es:[di-1], al
		mov	si, offset ID
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cx
		call	find_name_in_environment
		pop	cx
		push	es
		pop	ds
		assume ds:nothing
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	si, di
		pop	di
		jb	short GETENV6
		call	STRCPY

GETENV6:				; ...
		pop	ds
		jmp	RDBAT
READBAT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SKIPTOEOL	proc near		; ...
		test	ds:Batch, 0FFFFh
		jnz	short SKIPTOEOL1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SKIPTOEOL1:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short SKIPTOEOL
		retn
SKIPTOEOL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FREE_TPA	proc near		; ...
		push	es
		mov	es, ds:RESSEG
		assume es:nothing
		mov	es, es:Res_Tpa
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		retn
FREE_TPA	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ALLOC_TPA	proc near		; ...
		push	es
		mov	es, ds:RESSEG
		mov	bx, 0FFFFh
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		push	bx
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		pop	bx
		mov	es:Res_Tpa, ax
		mov	ds:TRAN_TPA, ax
		mov	dx, ax
		and	ax, 0FFFh
		jnz	short CALC_TPA
		mov	ax, dx
		and	ax, 0F000h
		jnz	short NOROUND

CALC_TPA:				; ...
		mov	ax, dx
		and	ax, 0F000h
		add	ax, 1000h
		jb	short NOROUND
		mov	dx, es:Res_Tpa
		add	dx, bx
		cmp	dx, ax
		jb	short NOROUND
		mov	bx, cs
		cmp	bx, ax
		jb	short NOROUND
		sub	bx, ax
		cmp	bx, 1000h
		jnb	short ROUNDDONE

NOROUND:				; ...
		mov	ax, es:Res_Tpa

ROUNDDONE:				; ...
		mov	es:LTpa, ax
		mov	ds:TPA,	ax
		mov	bx, ax
		mov	ax, cs
		sub	ax, bx
		push	bx
		mov	bx, 16
		mul	bx
		pop	bx
		or	dx, dx
		jz	short SAVSIZ2
		mov	ax, 0FFFFh

SAVSIZ2:				; ...
		cmp	ax, 512
		jbe	short GOTSIZE2
		and	ax, 0FE00h	; NOT 511 = NOT	1FFh

GOTSIZE2:				; ...
		mov	ds:BYTCNT, ax
		pop	es
		retn
ALLOC_TPA	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

BATCOM:					; ...
		mov	es, ds:RESSEG
		cmp	es:Call_Batch_Flag, 1
		jz	short skip_ioset
		call	IOSET

skip_ioset:				; ...
		call	FREE_TPA
		cmp	es:Call_Batch_Flag, 1 ;	call_in_progress
		jz	short GETECHO
		call	FOROFF

GETECHO:				; ...
		call	PipeOff
		mov	al, es:EchoFlag
		and	al, 1
		push	ax
		xor	ax, ax
		test	es:Batch, 0FFFFh
		jz	short LEAVEBAT
		mov	ax, es:Batch
		cmp	es:Call_Batch_Flag, 1 ;	call_in_progress
		jz	short LEAVEBAT
		push	es
		mov	es, ax
		mov	ax, es:3	; [es:BATCHSEGMENT.BatLast]
		pop	es

LEAVEBAT:				; ...
		push	ax
		cmp	es:Call_Batch_Flag, 1
		jz	short STARTBAT
		call	BATCHOFF

STARTBAT:				; ...
		mov	es:Call_Batch_Flag, 0
		mov	si, offset EXECPATH
		mov	ax, 0B711h	; AppendTruename
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET RETURN FOUND NAME STATE
		mov	ah, 4Eh
		mov	dx, si
		mov	cx, 13h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		call	dstrlen
		mov	bx, cx
		add	bx, 191		; 15+BATCHSEGMENT.SIZE+COMBUFLEN+15
		push	cx
		mov	cl, 4
		shr	bx, cl
		push	bx
		mov	ah, 48h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		pop	bx
		jb	short MEM_ERROR
		push	ax
		add	ax, bx
		add	ax, 20h
		mov	bx, cs
		mov	dx, 0AF95h	; mov dx,offset	TRANGROUP:TranSpaceEnd
		add	dx, 15
		shr	dx, cl
		add	dx, bx
		cmp	ax, bx
		jb	short ENOUGH_MEM
		cmp	ax, dx
		ja	short ENOUGH_MEM
		pop	ax
		push	es
		mov	es, ax
		mov	ax, 4900h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

MEM_ERROR:				; ...
		jmp	NO_MEMORY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENOUGH_MEM:				; ...
		pop	ax
		mov	es:Batch, ax
		call	ALLOC_TPA
		pop	dx
		pop	ax
		inc	es:Nest
		push	es
		mov	es, es:Batch
		mov	byte ptr es:0, 0 ; [es:BATCHSEGMENT.BatType]
		mov	es:3, ax	; [es:BATCHSEGMENT.BatLast]
		push	ds
		mov	ds, ds:RESSEG
		xor	ax, ax
		mov	bl, ds:ForFlag
		mov	es:7, bl	; [es:BATCHSEGMENT.BatForFlag]
		test	bl, 0FFh
		jz	short FOR_NOT_ON
		mov	ax, ds:ForPtr
		mov	ds:ForFlag, 0

FOR_NOT_ON:				; ...
		mov	es:5, ax	; [es:BATCHSEGMENT.BatForPtr]
		xor	ax, ax
		mov	ds:ForPtr, ax
		mov	bl, ds:EchoFlag
		pop	ds
		mov	es:1, bl	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	byte ptr es:2, 0 ; [es:BATCHSEGMENT.BatchEOF]
		mov	es:8, ax	; [es:BATCHSEGMENT.BatSeek]
		mov	es:0Ah,	ax	; [es:BATCHSEGMENT.BatSeek+2]
		dec	ax
		mov	di, 0Ch		; BATCHSEGMENT.BatParm
		mov	bx, di
		mov	cx, 10
		rep stosw
		mov	cx, dx
		rep movsb
		mov	si, (offset COMBUF+2)
		mov	cx, 10

EACHPARM:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short HAVPARM
		jcxz	short MOVPARM
		mov	es:[bx], di
		add	bx, 2

MOVPARM:				; ...
		lodsb
		call	DELIM
		jz	short ENDPARM
		stosb
		cmp	al, 0Dh
		jz	short HAVPARM
		jmp	short MOVPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ENDPARM:				; ...
		mov	al, 0Dh
		stosb
		jcxz	short EACHPARM
		dec	cx
		jmp	short EACHPARM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HAVPARM:				; ...
		xor	al, al
		stosb
		lea	bx, [di+0Fh]
		mov	cl, 4
		shr	bx, cl
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs
		pop	es
		push	es
		pop	ds
		cmp	ds:SingleCom, 0FFFFh ; -1
		jnz	short NOBATSING
		mov	ds:SingleCom, 0FFF0h

NOBATSING:				; ...
		pop	ax
		mov	ds:EchoFlag, al
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_MEMORY:				; ...
		pop	dx
		pop	ax
		pop	ax
		call	ALLOC_TPA
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror
; END OF FUNCTION CHUNK	FOR _$IF

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATCHOFF	proc near		; ...
		push	ax
		push	es
		push	ds
		push	bx
		mov	es, cs:RESSEG
		mov	ds, cs:RESSEG
		mov	ax, ds:Batch
		or	ax, ax
		jz	short NOTFREE
		push	es
		mov	es, ax
		test	ds:EchoFlag, 1
		jnz	short ECHO_LAST_LINE
		mov	ds:Suppress, 0	; NO_ECHO

ECHO_LAST_LINE:				; ...
		mov	bl, es:1	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	ds:EchoFlag, bl
		mov	bx, es:5	; [es:BATCHSEGMENT.BatForPtr]
		mov	ds:ForPtr, bx
		mov	bl, es:7	; [es:BATCHSEGMENT.BatForFlag]
		mov	ds:ForFlag, bl
		mov	bx, es:3	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	ds:Next_Batch, bx
		dec	es:Nest
		xor	ax, ax
		mov	ds:Batch, ax

NOTFREE:				; ...
		pop	bx
		pop	ds
		pop	es
		pop	ax
		retn
BATCHOFF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRCPY		proc near		; ...
		push	ax

ccycle:					; ...
		lodsb
		inc	cx
		cmp	cx, 128		; COMBUFLEN
		jb	short ccopy
		stc
		jmp	short ccend
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccopy:					; ...
		stosb
		or	al, al
		jnz	short ccycle

ccend:					; ...
		dec	cx
		dec	di
		pop	ax
		retn
STRCPY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETBATBYT	proc near		; ...
		push	bx
		push	cx
		push	ds
		test	ds:Batch_Abort,	0FFh
		jz	short getbatbyt1
		jmp	BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getbatbyt1:				; ...
		test	ds:Batch, 0FFFFh
		jnz	short getbatbyt2
		jmp	BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getbatbyt2:				; ...
		push	es
		mov	es, ds:Batch
		cmp	byte ptr es:2, 0 ; [es:BATCHSEGMENT.BatchEOF]
		jz	short not_eof
		jmp	At_EOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_eof:				; ...
		add	word ptr es:8, 1 ; [es:BATCHSEGMENT.BatSeek]
		adc	word ptr es:0Ah, 0 ; [es:BATCHSEGMENT.BatSeek+2]
		pop	es
		mov	ax, cs
		mov	ds, ax
		assume ds:TRANGROUP
		mov	bx, BATBUFPOS
		cmp	bx, 0FFFFh
		jnz	short UNBUF
		mov	dx, offset BATBUF
		mov	cx, BATBUFLEN
		mov	bx, BATHAND
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jnb	short bat_read_ok
		call	get_ext_error_number
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		mov	dx, ax
		call	output_batch_name
		pop	ds
		call	std_eprintf
		mov	ds:COMBUF+2, 0Dh ; END_OF_LINE_IN
		mov	ds:COMBUF+3, 0	; END_OF_LINE_OUT
		mov	ds, ds:RESSEG
		jmp	short BATEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

bat_read_ok:				; ...
		mov	cx, ax
		jcxz	short BATEOFDS
		mov	ds:BATBUFEND, cx
		xor	bx, bx
		mov	ds:BATBUFPOS, bx

UNBUF:					; ...
		mov	al, ds:BATBUF[bx]
		inc	bx
		cmp	bx, ds:BATBUFEND
		jb	short SETBUFPOS
		mov	bx, 0FFFFh	; -1

SETBUFPOS:				; ...
		mov	ds:BATBUFPOS, bx
		cmp	al, 1Ah		; ^Z for termination?
		jnz	short GETBYTEDONE

BATEOFDS:				; ...
		push	es
		mov	es, ds:RESSEG
		mov	es, es:Batch
		cmp	byte ptr es:2, 0
		jnz	short crpresent
		inc	byte ptr es:2	; [es:BATCHSEGMENT.BatchEOF]
		mov	bx, ds:BATBUFEND
		cmp	byte ptr ds:(BATBUFPOS+1)[bx], 0Ah ;
					; cmp byte [bx+BATBUF-1],0Ah
					; was a	LF present?
		jz	short crpresent
		add	byte ptr es:2, 3 ; BatchEOF == 4 to fake CR-LF

crpresent:				; ...
		mov	ds, ds:RESSEG

At_EOF:					; ...
		shr	byte ptr es:2, 1 ; decrement the flag
		jz	short turn_off	; zero,turn batch off
		cmp	byte ptr es:2, 1
		jz	short ret_lf	; BatchEOF was 2, return LF
		mov	al, 0Dh		; BatchEOF == 4,
					; indicates return fake	CR now
					; and fake LF next
		pop	es
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ret_lf:					; ...
		mov	al, 0Ah		; return fake LF
		pop	es
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

turn_off:				; ...
		pop	es

BATEOF:					; ...
		call	BATCHOFF
		call	BATCLOSE
		mov	al, 0Dh
		test	ds:Batch_Abort,	0FFh
		mov	ds:Batch_Abort,	0
		jz	short CONT_GET_BYT
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		jmp	short GETBYTEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONT_GET_BYT:				; ...
		cmp	ds:SingleCom, 0FFF0h
		jnz	short GETBYTEDONE
		cmp	ds:Nest, 0
		jnz	short GETBYTEDONE
		mov	ds:SingleCom, 0FFFFh ; -1

GETBYTEDONE:				; ...
		pop	ds
		pop	cx
		pop	bx
		retn
GETBATBYT	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

IFERRORP:				; ...
		pop	ax

IFFORERROR:				; ...
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; END OF FUNCTION CHUNK	FOR _$IF

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$IF		proc far		; ...

; FUNCTION CHUNK AT 0100 SIZE 00000336 BYTES
; FUNCTION CHUNK AT 054E SIZE 0000006E BYTES
; FUNCTION CHUNK AT 0868 SIZE 00000178 BYTES
; FUNCTION CHUNK AT 0B62 SIZE 00000007 BYTES
; FUNCTION CHUNK AT 0ED1 SIZE 00000124 BYTES
; FUNCTION CHUNK AT 2E45 SIZE 000000F5 BYTES
; FUNCTION CHUNK AT 2F50 SIZE 000000A5 BYTES
; FUNCTION CHUNK AT 33CF SIZE 0000016D BYTES

		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:PipeFiles, 0
		jz	short IFNoPipe
		call	PIPEDEL

IFNoPipe:				; ...
		pop	ds
		mov	ds:IFNOTFLAG, 0
		mov	ds:IF_NOT_COUNT, 0
		mov	si, 81h

IFREENT:				; ...
		call	scanoff
		cmp	al, 0Dh
		jz	short IFFORERROR
		mov	bp, si
		mov	di, offset IFTAB
		mov	ch, 0

IFINDCOM:				; ...
		mov	si, bp
		mov	cl, [di]
		inc	di
		jcxz	short IFSTRING
		jmp	short FIRSTCOMP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFCOMP:					; ...
		jnz	short IF_DIF

FIRSTCOMP:				; ...
		lodsb
		mov	ah, es:[di]
		inc	di
		cmp	al, ah
		jz	short IFLP
		or	ah, 20h		; Try lower case
		cmp	al, ah

IFLP:					; ...
		loop	IFCOMP

IF_DIF:					; ...
		lahf
		add	di, cx
		mov	bx, [di]
		inc	di
		inc	di
		sahf
		jnz	short IFINDCOM
		lodsb
		cmp	al, 0Dh

IFERRJ:					; ...
		jz	short IFFORERROR
		call	DELIM
		jnz	short IFINDCOM
		call	scanoff
		jmp	bx
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFNOT:					; ...
		not	ds:IFNOTFLAG
		inc	ds:IF_NOT_COUNT
		jmp	short IFREENT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFSTRING:				; ...
		push	si
		xor	cx, cx

FIRST_STRING:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORP
		call	DELIM
		jz	short EQUAL_CHECK
		inc	cx
		jmp	short FIRST_STRING
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EQUAL_CHECK:				; ...
		cmp	al, '='
		jz	short EQUAL_CHECK2
		cmp	al, 0Dh
		jz	short IFERRPJ
		lodsb
		jmp	short EQUAL_CHECK
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EQUAL_CHECK2:				; ...
		lodsb
		cmp	al, '='
		jnz	short IFERRPJ
		call	scanoff
		cmp	al, 0Dh
		jz	short IFERRPJ
		pop	di
		repe cmpsb
		jz	short MATCH
		dec	si
		cmp	byte ptr [si], 0Dh
		jz	short IFERRJ

SKIPSTRINGEND:				; ...
		lodsb

NOTMATCH:				; ...
		cmp	al, 0Dh

IFERRORJ2:				; ...
		jz	short IFERRJ
		call	DELIM
		jnz	short SKIPSTRINGEND
		mov	al, 0FFh	; -1
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERRPJ:				; ...
		jmp	IFERRORP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MATCH:					; ...
		lodsb
		call	DELIM
		jnz	short NOTMATCH
		xor	al, al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFEXISTS:				; ...
		lodsb
		call	DELIM
		jnz	short IFEXISTS
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	bx, 2
		add	bx, ds:IF_NOT_COUNT
		mov	ax, offset ARG_ARGV ; mov ax,ARG
					; (mov ax,ARG+ARG_UNIT.argv)
		call	argv_calc
		mov	dx, [bx]	; [bx+ARGV_ELE.argpointer]
					; mov dx,[bx+0]
		mov	cx, 6		; IFEXIST_ATTR ; filetypes to search for
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short IF_EX_C
		xor	al, al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IF_EX_C:				; ...
		mov	al, 0FFh	; -1

IFRET:					; ...
		test	ds:IFNOTFLAG, 0FFh
		jz	short REALTEST
		not	al

REALTEST:				; ...
		or	al, al
		jz	short IFTRUE
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFTRUE:					; ...
		call	scanoff
		mov	cx, si
		sub	cx, 81h
		sub	ds:80h,	cl
		mov	cl, ds:80h
		mov	ds:COMBUF+1, cl
		mov	di, (offset COMBUF+2)
		cld
		rep movsb
		mov	al, 0Dh
		stosb
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:IfFlag, 0FFh	; -1
		pop	ds
		jmp	DOCOM0
_$IF		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERRORJ3:				; ...
		jmp	IFERRORJ2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

IFERLEV:				; ...
		mov	bh, 10
		xor	bl, bl

GETNUMLP:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short IFERRORJ3
		call	DELIM
		jz	short GOTNUM
		sub	al, '0'
		xchg	al, bl
		mul	bh
		add	al, bl
		xchg	al, bl
		jmp	short GETNUMLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTNUM:					; ...
		push	ds
		mov	ds, ds:RESSEG
		mov	ah, byte ptr ds:RetCode
		pop	ds
		xor	al, al
		cmp	ah, bl
		jnb	short IFRET
		dec	al
		jmp	short IFRET
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SHIFT:					; ...
		mov	ds, ds:RESSEG
		mov	ax, ds:Batch
		or	ax, ax
		jnz	short SHIFT1

SHIFT_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SHIFT1:					; ...
		mov	es, ax
		mov	ds, ax
		mov	di, 0Ch		; BATCHSEGMENT.BatParm
		lea	si, [di+2]
		mov	cx, 9
		rep movsw
		cmp	word ptr [di], 0FFFFh ;	-1
		jz	short SHIFT_RETN
		mov	si, [di]
		mov	word ptr [di], 0FFFFh ;	-1

SKIPCRLP:				; ...
		lodsb
		cmp	al, 0Dh
		jnz	short SKIPCRLP
		cmp	byte ptr [si], 0
		jz	short SHIFT_RETN
		mov	[di], si
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SKIPDELIM	proc near		; ...
		test	ds:Batch, 0FFFFh
		jz	short SKIPERR
		call	GETBATBYT
		call	DELIM
		jz	short SKIPDELIM
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SKIPERR:				; ...
		stc

GOTO_RETN:				; ...
		retn
SKIPDELIM	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$CALL		proc near		; ...
		push	si
		push	di
		push	ax
		push	cx
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, 4		; length_call
		mov	di, (offset COMBUF+2)
		mov	cx, 124		; COMBUFLEN-length_call
		rep movsb
		pop	cx
		pop	ax
		pop	di
		pop	si
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:Call_Flag, 1	; call_in_progress
		mov	ds:Call_Batch_Flag, 1
		cmp	ds:PipeFiles, 0
		jz	short _NOPIPE
		call	PIPEDEL

_NOPIPE:				; ...
		pop	ds
		retn
_$CALL		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTO:					; ...
		mov	ds, ds:RESSEG
		test	ds:Batch, 0FFFFh
		jz	short GOTO_RETN
		xor	dx, dx
		push	ds
		mov	ds, ds:Batch
		mov	ds:8, dx	; [BATCHSEGMENT.BatSeek]
		mov	ds:10, dx	; [BATCHSEGMENT.BatSeek+2]
		mov	byte ptr ds:2, 0 ; [BATCHSEGMENT.BatchEOF]
		pop	ds
		call	PROMPTBAT
		mov	di, 5Dh		;  FCB+1
		mov	cx, 11
		mov	al, 20h	; ' '
		repne scasb
		jnz	short NOINC
		inc	cx

NOINC:					; ...
		sub	cx, 11
		neg	cx
		mov	es:BWDBUF, cx	; mov [es:GOTOLEN],cx
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, ':'
		jz	short CHKLABEL

LABLKLP:				; ...
		call	GETBATBYT
		cmp	al, 0Ah
		jnz	short LABLKTST
		call	SKIPDELIM
		jb	short BADGOTO
		cmp	al, ':'
		jz	short CHKLABEL

LABLKTST:				; ...
		test	ds:Batch, 0FFFFh
		jnz	short LABLKLP

BADGOTO:				; ...
		call	BATCLOSE
		call	free_batch
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADLAB_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHKLABEL:				; ...
		call	SKIPDELIM
		jb	short BADGOTO
		mov	di, 5Dh		; FCB+1
		mov	cx, es:BWDBUF	; mov cx,[es:GOTOLEN]
		jmp	short GOTBYTE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTCHRLP:				; ...
		push	cx
		call	GETBATBYT
		pop	cx

GOTBYTE:				; ...
		call	testkanj
		jz	short NOTKANJ1
		cmp	al, es:[di]
		jnz	short LABLKTST
		inc	di
		dec	cx
		jcxz	short LABLKTST
		push	cx
		call	GETBATBYT
		pop	cx
		cmp	al, es:[di]
		jmp	short KNEXTLABCHR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ1:				; ...
		or	al, 20h
		cmp	al, es:[di]
		jnz	short TRYUPPER
		jmp	short NEXTLABCHR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRYUPPER:				; ...
		sub	al, 20h
		cmp	al, es:[di]

KNEXTLABCHR:				; ...
		jnz	short LABLKTST

NEXTLABCHR:				; ...
		inc	di
		loop	NEXTCHRLP
		call	GETBATBYT
		cmp	es:BWDBUF, 8	; cmp [es:GOTOLEN],8
		jge	short GOTOCONT
		cmp	al, 20h	; ' '
		ja	short LABLKTST

GOTOCONT:				; ...
		cmp	al, 0Dh
		jz	short SKIPLFEED

TONEXTBATLIN:				; ...
		call	GETBATBYT
		cmp	al, 0Dh
		jnz	short TONEXTBATLIN

SKIPLFEED:				; ...
		call	GETBATBYT
		push	es
		mov	es, ds:Batch
		mov	byte ptr es:2, 0 ; BATCHSEGMENT.BatchEOF
		pop	es
		call	BATCLOSE
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATCLOSE	proc near		; ...
		mov	bx, cs:BATHAND
		cmp	bx, 5
		jb	short CLOSERETURN
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

CLOSERETURN:				; ...
		mov	ds:In_Batch, 0
		retn
BATCLOSE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BATOPEN		proc near		; ...
		push	ds
		mov	ds, ds:Batch
		assume ds:nothing
		mov	dx, 20h		; BATCHSEGMENT.BatFile
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short SETERRDL
		mov	dx, ds:8	; [BATCHSEGMENT.BatSeek]
		mov	cx, ds:10	; [BATCHSEGMENT.BatSeek+2]
		pop	ds
		mov	es:BATHAND, ax
		mov	bx, ax
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		mov	es:BATBUFPOS, 0FFFFh ; -1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SETERRDL:				; ...
		mov	bx, dx
		call	get_ext_error_number
		mov	dx, ax
		mov	al, [bx]
		sub	al, 40h	; '@'
		pop	ds
		stc
		retn
BATOPEN		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


free_batch	proc near		; ...
		push	es
		mov	bx, ds:Next_Batch
		or	bx, bx
		jz	short fb_ret

_ClearBatch:				; ...
		mov	es, bx
		mov	bx, es:5	; [es:BATCHSEGMENT.BatForPtr]
		cmp	bx, 0
		jz	short no_bat_for
		push	es
		mov	es, bx
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

no_bat_for:				; ...
		mov	cl, es:1	; [es:BATCHSEGMENT.BatEchoFlag]
		mov	bx, es:3	; [es:BATCHSEGMENT.BatLast]
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	ds:Batch, bx
		dec	ds:Nest
		jnz	short _ClearBatch
		mov	ds:EchoFlag, cl
		mov	ds:Batch, 0

fb_ret:					; ...
		pop	es
		retn
free_batch	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$FOR

FORTERM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	cs
		pop	es
		assume es:TRANGROUP
		call	FOROFF
		mov	ds, es:RESSEG
		assume ds:nothing
		cmp	ds:SingleCom, 0FF00h
		jnz	short BAT_CRLF
		cmp	ds:Nest, 0
		jnz	short BAT_CRLF
		mov	ds:SingleCom, 0FFFFh ; -1
		jmp	short NOFORP2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BAT_CRLF:				; ...
		test	ds:EchoFlag, 1
		jz	short NOFORP2
		test	ds:Batch, 0FFFFh
		jz	short NOFORP2
		call	CRLF2

NOFORP2:				; ...
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR _$FOR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

_$FOR_EXIT:				; ...
		jmp	short FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORPROC:				; ...
		mov	ax, ds:ForPtr
		mov	ds, ax
		mov	es, ax
		assume es:nothing
		mov	dx, 5CBh	; FOR_INFO.FORDMA
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer

FOR_BEGIN:				; ...
		cmp	word ptr ds:545h, 0 ; FOR_INFO.FOR_EXPAND
		jz	short FOR_BEGIN1
		inc	word ptr ds:547h ; FOR_INFO.FOR_MINARG

FOR_BEGIN1:				; ...
		mov	bx, ds:547h
		cmp	bx, ds:549h	; FOR_INFO.FOR_MAXARG
		jg	short _$FOR_EXIT
		mov	ax, 0		; FOR_INFO.FOR_ARGS
		call	argv_calc
		mov	cx, [bx+3]	; [bx+ARGV_ELE.argstartel]
		mov	dx, [bx]	; [bx+ARGV_ELE.argpointer]
		test	byte ptr [bx+2], 4 ; [bx+ARGV_ELE.argflags],path_sep
		jnz	short FORSUB
		mov	si, [bx]
		mov	al, '('         ; lparen
		cmp	[si-1],	al
		jnz	short FORSUB
		inc	cx
		mov	al, ':'
		cmp	[si+1],	al
		jnz	short FORSUB
		add	cx, 2

FORSUB:					; ...
		sub	cx, dx
		cmp	word ptr ds:545h, 0 ; [FOR_INFO.FOR_EXPAND]
		jz	short FOR_FIND_NEXT
		test	byte ptr [bx+2], 2 ; wildcard
		jnz	short FOR_FIND_FIRST
		mov	cx, [bx+5]	; [bx+ARGV_ELE.arglen]
		jmp	short FOR_SMOOSH
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_FIND_FIRST:				; ...
		push	cx
		xor	cx, cx
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		pop	cx
		jmp	short FOR_RESULT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_FIND_NEXT:				; ...
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call

FOR_RESULT:				; ...
		mov	ax, 0FFFFh
		jb	short FOR_CHECK
		mov	ax, 0

FOR_CHECK:				; ...
		mov	ds:545h, ax
		or	ax, ax
		jnz	short FOR_BEGIN

FOR_SMOOSH:				; ...
		mov	si, [bx]
		mov	di, 54Bh	; FOR_INFO.FORBUF
		rep movsb
		cmp	word ptr ds:545h, 0
		jnz	short FOR_MAKE_COM
		mov	si, 5E9h	; FOR_INFO.FORDMA+FIND_BUF.PNAME

FOR_MORE:				; ...
		cmp	byte ptr [si], 0
		jz	short FOR_MAKE_COM
		movsb
		jnz	short FOR_MORE

FOR_MAKE_COM:				; ...
		xor	al, al
		stosb
		xor	cx, cx
		not	cx
		xor	bx, bx
		mov	di, (offset COMBUF+2)
		mov	bl, ds:544h	; [FOR_INFO.FOR_COM_START]
		mov	dh, ds:64Bh	; [FOR_INFO.FOR_VAR]
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	ax, 0		; FOR_INFO.FOR_ARGS = 0
		call	argv_calc
		mov	si, [bx+9]	; [bx+ARGV_ELE.arg_ocomptr]
		inc	si

FOR_MAKE_LOOP:				; ...
		mov	al, [si]
		inc	si
		cmp	al, '%'
		jnz	short FOR_STOSB
		cmp	[si], dh
		jnz	short FOR_STOSB
		inc	si
		push	si
		mov	si, 54Bh	; FOR_INFO.FORBUF

SLOOP:					; ...
		lodsb
		stosb
		or	al, al
		loopne	SLOOP
		dec	di
		inc	cx
		pop	si
		jmp	short FOR_MAKE_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_STOSB:				; ...
		stosb
		dec	cx
		cmp	al, 0Dh
		jnz	short FOR_MAKE_LOOP
		not	cl
		mov	es:COMBUF+1, cl
		mov	ds, es:RESSEG
		test	ds:EchoFlag, 1
		jz	short NOECHO3
		cmp	ds:NullFlag, 1
		jz	short NO_CRLF_PR
		call	CRLF2

NO_CRLF_PR:				; ...
		mov	ds:NullFlag, 0
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	di
		call	PRINT_PROMPT
		pop	di
		mov	byte ptr es:[di-1], 0
		mov	string_ptr_2, (offset COMBUF+2)
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	byte ptr es:[di-1], 0Dh
		jmp	DOCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOECHO3:				; ...
		mov	ds:NullFlag, 0
		push	cs
		pop	ds
		jmp	DOCOM0
; END OF FUNCTION CHUNK	FOR _$IF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$FOR

FORNESTERRJ:				; ...
		call	FOROFF
		jmp	FORNESTERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORERRORJ:				; ...
		jmp	IFFORERROR
; END OF FUNCTION CHUNK	FOR _$FOR

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$FOR		proc near		; ...

; FUNCTION CHUNK AT 0E99 SIZE 00000038 BYTES
; FUNCTION CHUNK AT 0FF5 SIZE 00000009 BYTES
; FUNCTION CHUNK AT 1126 SIZE 0000001A BYTES

		mov	es, RESSEG
		assume es:nothing
		cmp	es:ForFlag, 0
		jnz	short FORNESTERRJ
		cmp	es:PipeFiles, 0
		jz	short NO_PIPE
		call	PIPEDEL

NO_PIPE:				; ...
		xor	dx, dx
		call	NEXTARG
		jb	short FORERRORJ
		cmp	al, '%'
		jnz	short FORERRORJ
		mov	bp, ax
		lodsb
		or	al, al
		jnz	short FORERRORJ
		call	NEXTARG
		jb	short FORERRORJ
		and	ax, 0DFDFh	; ~2020h (not 2020h)
		cmp	ax, 'NI'        ; "IN"
		jnz	short FORERRORJ
		lodsb
		or	al, al
		jnz	short FORERRORJ

CHECKLPAREN:
		call	NEXTARG
		jb	short FORERRORJ

LPCHECK:				; lparen
		cmp	al, '('
		jnz	short FORERRORJ
		cmp	ah, 0
		jz	short FOR_PAREN_TOKEN
		cmp	ah, ')'         ; rparen
		jnz	short FOR_LIST_NOT_EMPTY
		jmp	FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_LIST_NOT_EMPTY:			; ...
		inc	word ptr [bx]	; [bx+ARGV_ELE.argpointer] ; [bx+0]
		dec	word ptr [bx+5]	; [bx+ARGV_ELE.arglen]
		inc	si
		jmp	short FOR_LIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_PAREN_TOKEN:			; ...
		call	NEXTARG
		jb	short FORERRORJ
		cmp	ax, 29h		; db 29h,0 ; db	')',0
		jnz	short FOR_LIST
		jmp	FORTERM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FORERORJJ:				; ...
		jmp	IFFORERROR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_LIST:				; ...
		mov	cx, dx

SKIP_LIST:				; ...
		add	si, [bx+5]
		sub	si, 3
		mov	al, ')'
		cmp	[si], al
		jz	short FOR_END_LIST
		call	NEXTARG
		jb	short FORERORJJ
		jmp	short SKIP_LIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_END_LIST:				; ...
		mov	di, dx
		mov	byte ptr [si], 0
		cmp	ax, 29h		; db 29h,0 ; db	')',0
		jz	short FOR_DO
		inc	di

FOR_DO:					; ...
		call	NEXTARG
		jb	short FORERORJJ
		and	ax, 0DFDFh	; and ax,~2020h
		cmp	ax, 'OD'        ; "DO" ; 4F44h
		jnz	short FORERORJJ
		lodsb
		or	al, al
		jnz	short FORERORJJ
		call	NEXTARG
		jb	short FORERORJJ
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		call	FREE_TPA
		call	FOROFF
		mov	bx, 264		; FOR_INFO.size-ARG_UNIT.SIZE
		call	SAVE_ARGS
		pushf
		mov	es:ForPtr, ax
		call	ALLOC_TPA
		popf
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		jb	short FOR_ALLOC_ERR
		push	es
		push	es:ForPtr
		pop	es
		dec	cx
		dec	di
		mov	es:547h, cx	; [es:FOR_INFO.FOR_MINARG]
		mov	es:549h, di	; [es:FOR_INFO.FOR_MAXARG]
		mov	es:544h, dl	; [es:FOR_INFO.FOR_COM_START]
		mov	word ptr es:545h, 0FFFFh ; [es:FOR_INFO.FOR_EXPAND]
		mov	ax, bp
		mov	es:64Bh, ah	; [es:FOR_INFO.FOR_VAR]
		pop	es
		inc	es:ForFlag
		cmp	es:SingleCom, 0FFFFh ; -1
		jnz	short FOR_RET
		mov	es:SingleCom, 0FF00h

FOR_RET:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOR_ALLOC_ERR:				; ...
		mov	msg_disp_class,	1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	8 ; ERROR_NOT_ENOUGH_MEMORY
		jmp	cerror
_$FOR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


NEXTARG		proc near		; ...
		inc	dx
		cmp	dx, ARG_ARGVCNT	; [ARG+ARG_UNIT.argvcnt]
		jge	short NEXTARG_ERR
		mov	bx, dx
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv	; ARG
		call	argv_calc
		mov	si, [bx]	; [bx+ARGV_ELE.argpointer]
					; mov si,[bx+0]
		lodsw
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTARG_ERR:				; ...
		stc
		retn
NEXTARG		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$FOR

FORNESTERR:				; ...
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		mov	dx, offset FORNESTMES_PTR
		cmp	ds:SingleCom, 0FF00h
		jnz	short NOFORP3
		mov	ds:SingleCom, 0FFFFh ; -1

NOFORP3:				; ...
		pop	ds
		jmp	cerror
; END OF FUNCTION CHUNK	FOR _$FOR

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FOROFF		proc near		; ...
		push	ax
		push	es
		mov	es, cs:RESSEG
		mov	ax, es:ForPtr
		or	ax, ax
		jz	short FREEDONE
		push	es
		mov	es, ax
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es

FREEDONE:				; ...
		mov	es:ForPtr, 0
		mov	es:ForFlag, 0
		pop	es
		pop	ax
		retn
FOROFF		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CATALOG:				; ...
		call	screen_f_set
		call	SetDefaults
		call	ParseEnvironment
		call	ParseCmdLine
		jnb	short catalog1
		jmp	catExtErr2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catalog1:				; ...
		call	SetOptions
		call	SetCollatingTable
		test	ds:_Bits, 10h	; mask.bare
		jnz	short catalog2
		call	OkVolArg
		sub	ds:LeftOnPage, 2
		jmp	short catCrunch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catalog2:				; ...
		call	DisAppend
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	di, 5Ch		; FCB
		inc	di
		mov	al, '?'         ; wildcard character
		mov	cx, 11
		rep stosb

catCrunch:				; ...
		call	CrunchPath
		jb	short catRecErr
		cmp	ds:COMSW, 0
		jnz	short catRecErr
		call	InstallCtrlC
		test	ds:_Bits, 1	; mask cratio
					; compression ratio wanted?
		jz	short catalog4
		call	OpenCVF		; yes, try to open CVF file
		jnb	short catalog4
		and	ds:_Bits, 0FFFEh ; not (mask cratio)

catalog4:				; ...
		call	ZeroTotals
		call	ListDir
		jb	short catExtErr1
		test	ds:_Bits, 8	; mask.subd
		jz	short catalog3
		call	ListSubds
		jb	short catExtErr1

catalog3:				; ...
		test	ds:_Bits, 10h	; mask.bare
		jnz	short catRet
		mov	ax, ds:FileCntTotal
		or	ax, ax
		jz	short catNoFiles
		call	DisplayTotals
		jmp	short catRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catRecErr:				; ...
		test	ds:COMSW, 1	; mask.dev
		jnz	short catNoFiles
		test	ds:COMSW, 2	; mask.baddir
		jz	short catExtErr1
		mov	dx, offset badcd_ptr
		jmp	short catExtErr2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catNoFiles:				; ...
		call	DisplayHeader
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		jmp	short catExtErr2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catExtErr1:				; ...
		call	Set_Ext_Error_Msg
		cmp	ds:extend_buf_ptr, 18 ;	ERROR_NO_MORE_FILES
		jnz	short catExtErr2
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND

catExtErr2:				; ...
		test	ds:_Bits, 1	; close	Compressed Volume File if cratio
		jz	short catErr
		call	CloseCVF

catErr:					; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

catRet:					; ...
		test	ds:_Bits, 1	; mask cratio
		jz	short catRetn
		call	CloseCVF

catRetn:				; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetDefaults	proc near		; ...
		mov	di, offset SrcBuf
		mov	ds:PathPos, di
		mov	al, '*'
		stosb
		mov	al, 0Dh
		stosb
		mov	ds:PathCnt, 1
		xor	ax, ax
		mov	ds:COMSW, ax
		mov	ds:_Bits, ax
		mov	ds:DestBuf, al
		mov	ds:AttrSpecified, 6 ; ATTR_HIDDEN+ATTR_SYSTEM
		mov	ds:AttrSelect, al
		mov	ds:fUseHostSize, al
		retn
SetDefaults	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseEnvironment proc near		; ...
		call	GetEnvValue
		jb	short peRet
		call	Parse_Line
		cmp	ax, 0FFFFh	; -1
		jz	short peRet
		call	std_eprintf
		mov	ds:msg_disp_class, 0FFh	; -1
		mov	dx, offset errparsenv_ptr
		call	Printf_Crlf

peRet:					; ...
		retn
ParseEnvironment endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseCmdLine	proc near		; ...
		mov	si, 81h
		call	Parse_Line
		cmp	ax, 0FFFFh	; -1
		jz	short pcOk
		stc
		jmp	short pcRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pcOk:					; ...
		clc

pcRet:					; ...
		retn
ParseCmdLine	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetCollatingTable proc near		; ...
		mov	dx, offset STACK ; INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jb	short scNoTable
		cmp	bx, 1
		jz	short scNoTable
		mov	ax, 6506h	; (GETEXTCNTRY<<8)+SETCOLLATE
					; AH = 'Get Extended Country Info'
					; AL = 'Get Pointer to Collating Table'
		mov	bx, 0FFFFh	; -1
		mov	cx, 5		; buffer length
		mov	dx, bx		; default country ID
		mov	di, offset CountryPtrInfo
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		jnb	short scRet

scNoTable:				; ...
		mov	ds:CountryPtrInfo, 0 ; mov byte	[CountryPtrId],0

scRet:					; ...
		retn
SetCollatingTable endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetOptions	proc near		; ...
		test	ds:_Bits, 10h	; (inmem,lcase,bare,subd,pagd,wide,cratio)
					;
					; mask bare
		jz	short setopts0
		and	ds:_Bits, 0FFFDh ; not mask wide

setopts0:				; ...
		test	ds:_Bits, 12h	; (mask	bare) or (mask wide)
		jz	short setopts1
		and	ds:_Bits, 0FFFEh ; not mask cratio

setopts1:				; ...
		push	ds
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		mov	al, ds:84h	; [CRT_Rows]
		pop	ds
		assume ds:nothing
		or	al, al
		jnz	short setopts2
		mov	al, 25		; LINESPERPAGE

setopts2:				; ...
		xor	ah, ah

setopts3:
		inc	al
		mov	ds:LinPerPag, ax
		mov	ax, 440Ch	; (IOCTL<<8)+GENERIC_IOCTL_HANDLE
		mov	bx, 1		; STDOUT
		mov	ch, 3		; IOC_SC (screen)
		mov	cl, 7Fh		; get_generic
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		mov	ax, ds:LinPerPag
		mov	ds:LeftOnPage, ax
		mov	ds:PerLine, 1	; NORMPERLIN
		test	ds:_Bits, 2
		jz	short setopts4
		mov	ds:PerLine, 5	; WIDEPERLIN

setopts4:				; ...
		cmp	ds:SrcBuf+1, ':'
		jnz	short soRet
		mov	al, ds:SrcBuf
		and	al, 0DFh	; ~20h ; not 20h
					; capitalize ASCII drive letter
		sub	al, '@'         ; sub al,40h
					; convert to 1-based number (1=A)
		mov	ds:5Ch,	al	; [FCB]

soRet:					; ...
		retn
SetOptions	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CrunchPath	proc near		; ...
		call	FileIsDevice
		jnz	short crpath1
		or	ds:COMSW, 1	; mask.dev
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

crpath1:				; ...
		push	ds:PathPos
		mov	ds:DirFlag, 0FFh ; -1
		call	PathCrunch
		mov	ds:DirFlag, 0
		pop	si
		jb	short cpNoDir
		jz	short cpRet
		mov	si, ds:DestTail
		jmp	short cpFile
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpNoDir:				; ...
		mov	ax, ds:Msg_Numb
		or	ax, ax
		jnz	short cpErr
		cmp	ds:DestIsDir, 0
		jz	short cpMaybe
		or	ds:COMSW, 2	; mask.baddir
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpMaybe:				; ...
		cmp	byte ptr [si+1], ':'
		jnz	short crpath2
		lodsw

crpath2:				; ...
		cmp	word ptr [si], '..'
		jnz	short cpFile
		cmp	byte ptr [si+2], 0
		jnz	short cpFile
		or	ds:COMSW, 2
		jmp	short cpErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpFile:					; ...
		mov	di, 5Ch		; FCB
		mov	ax, 290Eh
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		clc
		jmp	short cpRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpErr:					; ...
		stc

cpRet:					; ...
		retn
CrunchPath	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


InstallCtrlC	proc near		; ...
		push	es
		mov	ax, 3523h
		int	21h		; DOS -	2+ - GET INTERRUPT VECTOR
					; AL = interrupt number
					; Return: ES:BX	= value	of interrupt vector
		mov	word ptr ds:OldCtrlCHandler, bx
		mov	word ptr ds:OldCtrlCHandler+2, es
		pop	es
		mov	dx, offset CtrlCHandler
		mov	ax, 2523h
		int	21h		; DOS -	SET INTERRUPT VECTOR
					; AL = interrupt number
					; DS:DX	= new vector to	be used	for specified interrupt
		retn
InstallCtrlC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ListSubds	proc near		; ...
		call	SetRest1
		mov	bx, offset ScanBuf

lsNode:					; ...
		mov	byte ptr [bx], 0

lsLoop:					; ...
		call	FindNextChild
		jb	short lsErr
		mov	dx, bx
		call	ChangeDir
		jnb	short lstsd1
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short lsLoop
		jmp	short lsRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lstsd1:					; ...
		push	bx
		call	ListDir
		pop	bx
		mov	di, bx
		mov	cx, 13
		xor	al, al
		repne scasb
		push	bx
		mov	bx, di
		call	lsNode
		pop	bx
		pushf
		mov	ax, 0
		push	ax
		mov	ax, '..'
		push	ax
		mov	dx, sp
		call	ChangeDir
		pop	ax
		pop	ax
		popf
		jb	short lsRet
		jmp	short lsLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lsErr:					; ...
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short lsRet
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short lsRet
		stc

lsRet:					; ...
		retn
ListSubds	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckChild	proc near		; ...
		test	ds:DIRBUF_find_buf_attr, 10h ;
					; [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY
		jz	short ccRet
		cmp	ds:DIRBUF_find_buf_pname, '.' ; [DIRBUF+FIND_BUF.PNAME]
		jz	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bx
		call	CmpAscz
		jbe	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bp
		call	CmpAscz
		jnb	short ccRet
		mov	si, offset DIRBUF_find_buf_pname
		mov	di, bp
		mov	cx, 13
		rep movsb

ccRet:					; ...
		retn
CheckChild	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CmpEntry	proc near		; ...
		mov	si, offset DestBuf

ceLoop:					; ...
		xor	ax, ax
		mov	al, [si]
		or	al, al
		jz	short ceDone
		inc	si
		push	si
		dec	al
		shl	al, 1
		mov	si, ax
		mov	ax, cs:FieldCmps[si]
		jb	short ceDn
		call	ax
		jmp	short ceNs
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ceDn:					; ...
		xchg	bx, bp
		call	ax
		xchg	bx, bp

ceNs:					; ...
		pop	si
		jz	short ceLoop

ceDone:					; ...
		retn
CmpEntry	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
FieldCmps	dw offset CmpName	; ...
		dw offset CmpExt
		dw offset CmpTime
		dw offset CmpSize
		dw offset CmpType
		dw offset CmpCratio
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpName:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 1		; entry.filename
		add	di, 1		; entry.filename
		mov	cx, 8		; size entry.filename
		jmp	short CmpStr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpExt:					; ...
		mov	si, bx
		mov	di, bp
		add	si, 9		; entry.fileext
		add	di, 9		; entry.fileext
		mov	cx, 3		; size entry.fileext

CmpStr:					; ...
		cmp	ds:CountryPtrInfo, 6 ; CountryPtrId
		jnz	short cnNoCollTable
		push	bp
		push	bx
		push	ds
		lds	bx, ds:CountryPtr
		mov	bp, [bx]
		inc	bx
		inc	bx
		xor	ax, ax

cnNextChar:				; ...
		mov	al, es:[di]
		inc	di
		cmp	ax, bp
		jnb	short cn1
		xlat

cn1:					; ...
		mov	dx, ax
		lods	byte ptr es:[si]
		cmp	ax, bp
		jnb	short cn2
		xlat

cn2:					; ...
		cmp	ax, dx
		loope	cnNextChar
		pop	ds
		pop	bx
		pop	bp
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cnNoCollTable:				; ...
		repe cmps byte ptr es:[si], byte ptr es:[di]
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpTime:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 16		; entry.filedate + size	entry.filedate - 1
		add	di, 16		; entry.filedate + size	entry.filedate - 1
		mov	cx, 4		; size entry.filetime +	size entry.filedate
		std
		repe cmps byte ptr es:[si], byte ptr es:[di]
		cld
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpSize:				; ...
		mov	si, bx
		mov	di, bp
		add	si, 20
		add	di, 20
		mov	cx, 4
		std
		repe cmps byte ptr es:[si], byte ptr es:[di]
		cld
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpType:				; ...
		mov	al, es:[bx+12]	; entry.fileattr
		mov	ah, es:[bp+12]
		and	ax, 1010h	; (ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
		cmp	ah, al
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CmpCratio:				; ...
		mov	al, es:[bx+21]	;  es:[bx].compratio
		cmp	al, es:[bp+21]
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DefaultAttr	proc near		; ...
		mov	ds:AttrSpecified, 6 ; ATTR_HIDDEN+ATTR_SYSTEM
		mov	ds:AttrSelect, 0
		clc
		retn
DefaultAttr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTotals	proc near		; ...
		test	ds:_Bits, 8	; mask subd
		jz	short dtFree
		call	CRLF2
		call	UseLine
		mov	dx, offset total_ptr
		call	std_printf
		call	UseLine
		test	ds:_Bits, 1	; mask cratio
		jz	short dtCntSize
		mov	ax, ds:ccluUsedTotal
		mov	ds:ccluUsedDir,	ax
		mov	si, offset csecUsedTotal
		mov	di, offset csecUsedDir
		movsw
		movsw

dtCntSize:				; ...
		mov	ax, ds:FileCntTotal
		mov	si, offset FileSizTotal
		mov	di, offset FileSiz
		movsw
		movsw
		call	DisplayCntSiz

dtFree:					; ...
		mov	ah, 36h
		mov	dl, ds:5Ch
		int	21h		; DOS -	2+ - GET DISK SPACE
					; DL = drive code (0 = default,	1 = A, 2 = B, etc.)
		cmp	ax, 0FFFFh	; -1
		jz	short dtRet
		mul	cx
		mul	bx
		mov	word ptr ds:Bytes_Free,	ax
		mov	word ptr ds:Bytes_Free+2, dx
		mov	dx, offset bytmes_ptr
		call	std_printf
		call	UseLine

dtRet:					; ...
		retn
DisplayTotals	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FileIsDevice	proc near		; ...
		mov	dx, ds:PathPos
		mov	di, dx
		add	di, ds:PathCnt
		xor	bl, bl
		xchg	bl, [di]
		xor	cx, cx
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		xchg	bl, [di]
		jb	short piCol
		test	ds:DIRBUF_find_buf_attr, 40h ; [DIRBUF+21],40h
					; [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
		jz	short piCol
		xor	cx, cx
		jmp	short piRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

piCol:					; ...
		dec	di
		mov	al, ':'
		mov	cx, ds:PathCnt
		dec	cx
		dec	cx
		or	cx, cx
		js	short piRet
		or	di, di
		std
		repne scasb
		cld

piRet:					; ...
		retn
FileIsDevice	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindFirst	proc near		; ...
		mov	ax, offset GetFirst
		jmp	short ffFindEntry
FindFirst	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNext	proc near		; ...
		mov	ax, offset GetNext

ffFindEntry:				; ...
		push	es
		test	ds:_Bits, 40h	; mask.inmem
		jz	short ffDisk
		call	FindInMem
		jmp	short ffRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ffDisk:					; ...
		call	ax
		jb	short ffGetErr
		mov	es, ds:TPA
		xor	di, di
		mov	bx, di
		call	LoadEntry
		clc
		jmp	short ffRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ffGetErr:				; ...
		call	get_ext_error_number
		stc

ffRet:					; ...
		pop	es
		retn
FindNext	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindInMem	proc near		; ...
		mov	es, ds:TPA
		xor	bx, bx
		cld
		call	FindOneInMem
		jb	short fiNoMore

fiBest:					; ...
		mov	bp, bx

fiNext:					; ...
		call	FindNextInMem
		jb	short fiFound
		call	CmpEntry
		jnb	short fiNext
		jmp	short fiBest
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fiNoMore:				; ...
		mov	ax, 18		; ERROR_NO_MORE_FILES
		stc
		jmp	short fiRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fiFound:				; ...
		mov	bx, bp
		mov	byte ptr es:[bx], 1
		clc

fiRet:					; ...
		retn
FindInMem	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNextChild	proc near		; ...
		sub	sp, 12
		mov	ax, 0FFh
		push	ax
		mov	bp, sp
		mov	ax, '*'         ; 002Ah
		push	ax
		mov	ax, 2E2Ah	; '*.'
		push	ax
		call	GetDriveLtr
		push	ax
		mov	dx, sp
		mov	cx, 10h		; ATTR_DIRECTORY
		mov	ah, 4Eh
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short fcRet
		call	CheckChild

fcNext:					; ...
		mov	cx, 10h
		mov	ah, 4Fh
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jb	short fcErr
		call	CheckChild
		jmp	short fcNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcErr:					; ...
		call	get_ext_error_number
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jnz	short fcNope
		cmp	byte ptr [bp+0], 0FFh
		jz	short fcNope
		mov	si, bp
		mov	di, bx

fcMove:					; ...
		lodsb
		stosb
		or	al, al
		jz	short fcRet
		jmp	short fcMove
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fcNope:					; ...
		stc

fcRet:					; ...
		lahf
		add	sp, 20
		sahf
		retn
FindNextChild	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindOneInMem	proc near		; ...

; FUNCTION CHUNK AT 163F SIZE 00000002 BYTES

		mov	al, es:[bx]
		cmp	al, 1
		jz	short FindNextInMem
		cmp	al, 0FFh
		jz	short foNoMore
		clc
		retn
FindOneInMem	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FindNextInMem	proc near		; ...
		add	bx, 22		; size EntryStruc (22 =	21 + compratio)
		jmp	short FindOneInMem
FindNextInMem	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR FindOneInMem

foNoMore:				; ...
		stc
		retn
; END OF FUNCTION CHUNK	FOR FindOneInMem

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetEnvValue	proc near		; ...
		push	es
		mov	si, offset DirEnvVar ; "DIRCMD="
		call	find_name_in_environment
		jb	short geRet
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		mov	di, offset ScanBuf

geLoop:					; ...
		lodsb
		or	al, al
		stosb
		loopne	geLoop
		push	es
		pop	ds
		mov	si, offset ScanBuf

geRet:					; ...
		pop	es
		retn
GetEnvValue	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetFirst	proc near		; ...
		mov	byte ptr ds:55h, 0FFh ;	[FCB-7]
		mov	byte ptr ds:5Bh, 16h ; mov byte	[FCB-1],ATTR_ALL
		mov	dx, 55h		; FCB-7
		mov	ah, 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		shl	al, 1
		jb	short gfRet
		jmp	short gfFound
GetFirst	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetNext		proc near		; ...
		mov	dx, 55h
		mov	ah, 12h
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		shl	al, 1
		jb	short gfRet

gfFound:				; ...
		mov	al, ds:DIRBUF_8_DIR_ATTR ;
					; [DIRBUF+8+DIR_ENTRY.DIR_ATTR]
		mov	ah, ds:AttrSpecified
		and	al, ah
		and	ah, ds:AttrSelect
		cmp	al, ah
		jnz	short GetNext

gfRet:					; ...
		retn
GetNext		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ListDir		proc near		; ...
		xor	ax, ax
		mov	ds:FileCnt, ax	; zero file count
		mov	ds:FileSiz, ax	; zero file size accumulator
		mov	ds:FileSiz+2, ax
		mov	ds:ccluUsedDir,	ax ; zero count	clusters used
		mov	ds:csecUsedDir,	ax ; zero count	compressed sectors used
		mov	ds:csecUsedDir+2, ax
		cmp	ds:DestBuf, 0	; check	for sort code
		jz	short ld1
		call	LoadEntries	; load entries for sorted listing
		jnb	short ld1
		call	get_ext_error_number
		stc
		jmp	short ldErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ld1:					; ...
		call	FindFirst
		jb	short ldErr
		call	DisplayHeader
		call	DisplayFile

ldNext:					; ...
		call	FindNext
		jb	short ldErr
		call	DisplayFile
		jmp	short ldNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ldErr:					; ...
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short ldDone
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short ldDone
		stc
		jmp	short ldRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ldDone:					; ...
		cmp	ds:FileCnt, 0
		jz	short ld2
		call	DisplayTrailer

ld2:					; ...
		clc

ldRet:					; ...
		retn
ListDir		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadEntries	proc near		; ...
		push	es
		mov	es, ds:TPA
		xor	di, di
		and	ds:_Bits, 0FFBFh ;  ~mask.inmem	; not mask.inmem
		call	GetFirst
		jb	short leRet
		call	LoadEntry

leNext:					; ...
		call	GetNext
		jb	short leLoaded
		mov	ax, ds:BYTCNT
		sub	ax, di
		cmp	ax, 24		; size EntryStruc+2 (23	+ compratio)
		jb	short leOk
		call	LoadEntry
		jmp	short leNext
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

leLoaded:				; ...
		mov	byte ptr es:[di], 0FFh
		or	ds:_Bits, 40h	; mask.inmem

leOk:					; ...
		clc

leRet:					; ...
		pop	es
		retn
LoadEntries	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LoadEntry	proc near		; ...
		mov	si, offset DIRBUF_8 ; DIRBUF+8
		xor	al, al
		stosb
		mov	cx, 11
		rep movsb
		lodsb
		stosb
		add	si, 10		; (DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
		movsw
		movsw
		mov	cl, al
		lodsw
		and	cl, 10h		; ATTR_DIRECTORY
		jnz	short leSetDirSize
		movsw
		movsw
		test	ds:_Bits, 1	; mask.cratio
		jnz	short leCalcRatio
		xor	ax, ax
		stosb
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

leCalcRatio:				; ...
		call	CalcCompRatio
		or	ax, ax
		jz	short leNoRatio
		dec	ah
		mov	cl, 4
		shl	ah, cl
		or	al, ah
		stosb
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

leSetDirSize:				; ...
		xor	ax, ax
		stosw
		stosw

leNoRatio:				; ...
		dec	al
		stosb
		retn
LoadEntry	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


NoOrder		proc near		; ...
		mov	ds:DestBuf, 0	; no sort
		clc			; no error
		retn
NoOrder		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


OnOffSw		proc near		; ...
		mov	cx, di
		shr	cx, 1
		shr	cx, 1
		mov	ax, 1
		shl	ax, cl
		test	di, 2
		jz	short oo1
		or	ds:_Bits, ax
		jmp	short ooRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oo1:					; ...
		not	ax
		and	ds:_Bits, ax

ooRet:					; ...
		clc
		retn
OnOffSw		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseAttr	proc near		; ...
		push	si
		mov	ds:AttrSpecified, 0
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]

paLoop:					; ...
		mov	dx, 1
		lodsb
		or	al, al
		jz	short paOk
		cmp	al, '-'
		jnz	short pa1
		dec	dx
		lodsb

pa1:					; ...
		mov	di, offset AttrLtrs ; "RHSvDA"
		mov	cx, 6		; NUM_ATTR_LTRS
		repne scasb
		jnz	short paErr
		not	cx
		add	cx, 6		; NUM_ATTR_LTRS
		mov	al, 1
		shl	al, cl
		or	ds:AttrSpecified, al
		not	al
		and	ds:AttrSelect, al
		shl	dl, cl
		or	ds:AttrSelect, dl
		jmp	short paLoop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

paErr:					; ...
		call	SetupParamError
		stc
		jmp	short paRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

paOk:					; ...
		clc

paRet:					; ...
		pop	si
		retn
ParseAttr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Parse_Line	proc near		; ...
		mov	di, offset PARSE_DIR
		xor	cx, cx

plPars:					; ...
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short plRet
		cmp	ax, 0
		jnz	short plRet
		mov	bx, dx
		cmp	byte ptr [bx], 5 ;  RESULT_FILESPEC
		jz	short plFil
		call	ParseSwitch
		jb	short plRet
		jmp	short plPars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plFil:					; ...
		call	CopyPathname
		jmp	short plPars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plRet:					; ...
		retn
Parse_Line	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseOrder	proc near		; ...
		push	si
		push	bx
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	bx, offset DestBuf
		mov	al, [si]
		or	al, al
		jnz	short poLtr
		mov	byte ptr [bx], 5 ; sort	1st by group
		inc	bx
		mov	byte ptr [bx], 1 ; then	by name
		inc	bx
		mov	byte ptr [bx], 2 ; then	by extension
		inc	bx
		jmp	short poOk
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poLtr:					; ...
		xor	dl, dl
		lodsb
		or	al, al
		jz	short poOk
		cmp	al, '-'
		jnz	short po1
		mov	dl, 80h
		lodsb

po1:					; ...
		mov	di, offset OrderLtrs ; "NEDSGC"
		mov	cx, 6		; NUM_ORDER_LTRS
		repne scasb
		jnz	short poErr
		neg	cx
		add	cx, 6		; NUM_ORDER_LTRS
		cmp	cl, 6		; cmp cl, CRATIO_ORDER
		jnz	short poSet
		or	ds:_Bits, 1	; mask.cratio

poSet:					; ...
		or	cl, dl
		mov	[bx], cl
		inc	bx
		cmp	bx, offset EndDestBuf
		jnb	short poErr
		jmp	short poLtr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poErr:					; ...
		pop	bx
		call	SetupParamError
		stc
		jmp	short poRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

poOk:					; ...
		mov	byte ptr [bx], 0
		pop	bx
		clc

poRet:					; ...
		pop	si
		retn
ParseOrder	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseRatio	proc near		; ...
		call	OnOffSw
		push	si
		mov	si, [bx+4]	; mov si,word ptr [bx].ValuePtr
		mov	al, [si]
		or	al, al
		jz	short prDone
		cmp	al, 'H'
		jz	short prDone
		call	SetupParamError
		stc
		jmp	short prRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

prDone:					; ...
		mov	ds:fUseHostSize, al ; set Host cluster size flag
		clc

prRet:					; ...
		pop	si
		retn
ParseRatio	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ParseSwitch:				; ...
		push	cx
		push	di
		mov	ax, [bx+2]	; [bx+ResultBuffer.SynPtr]
		mov	di, offset Dir_Sw_Ptrs
		mov	cx, 16		; NUM_DIR_SWS
		cld
		repne scasw
		sub	di, offset Dir_Sw_Ptrs_2 ; Dir_Sw_Ptrs+2
		call	cs:SwHandler[di] ; call	word [cs:di+SwHandler]
		pop	di
		pop	cx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
SwHandler	dw offset OnOffSw	; ...
		dw offset ParseRatio
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset OnOffSw
		dw offset NoOrder
		dw offset ParseOrder
		dw offset DefaultAttr
		dw offset ParseAttr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ChangeDir:				; ...
		mov	di, offset BWDBUF ; DIRBUF
		call	GetDriveLtr
		stosw
		mov	si, dx

cdLoop:					; ...
		lodsb
		stosb
		or	al, al
		jnz	short cdLoop
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CmpAscz		proc near		; ...
		push	di
		mov	di, si
		xor	al, al
		mov	cx, 0FFFFh
		repne scasb
		not	cx
		pop	di
		repe cmpsb
		retn
CmpAscz		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CopyPathname	proc near		; ...
		push	si
		lds	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		call	Move_To_SrcBuf
		pop	si
		retn
CopyPathname	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CountFile	proc near		; ...
		push	es
		mov	es, ds:TPA
		inc	ds:FileCnt
		inc	ds:FileCntTotal
		jnz	short cntf1
		inc	ds:FileCntTotal+2

cntf1:					; ...
		mov	ax, es:[bx+17]	; EntryStruc.filesize
		mov	dx, es:[bx+19]	; EntryStruc.filesize +	2
		add	ds:FileSiz, ax
		adc	ds:FileSiz+2, dx
		add	word ptr ds:FileSizTotal, ax
		adc	word ptr ds:FileSizTotal+2, dx
		pop	es
		retn
CountFile	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayBare	proc near		; ...
		mov	cx, ds
		mov	ds, ds:TPA
		cmp	byte ptr [bx+1], '.' ; [bx+EntrStruc.filename]
		mov	ds, cx
		jz	short dbRet
		test	ds:_Bits, 8	; mask.subd
		jz	short dbNameExt
		call	build_dir_string
		mov	di, offset BWDBUF
		test	ds:_Bits, 20h	; mask.lcase
		jz	short dbare1
		mov	si, di
		call	LowercaseString

dbare1:					; ...
		xor	al, al
		mov	cx, 0FFFFh
		cld
		repne scasb
		dec	di
		cmp	byte ptr es:[di-1], '\'
		jz	short dbare2
		mov	ax, '\'
		stosw

dbare2:					; ...
		mov	ds:string_ptr_2, offset	BWDBUF
		mov	dx, offset string_buf_ptr
		call	std_printf

dbNameExt:				; ...
		call	DisplayDotForm
		call	CRLF2
		call	UseLine

dbRet:					; ...
		retn
DisplayBare	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayDotForm	proc near		; ...
		push	ds
		push	es
		mov	ax, cs:TPA
		mov	ds, ax
		mov	es, ax
		mov	di, bx
		add	di, 8		; filename + size filename - 1
		mov	cx, 8		; size filename	= 8 ; size of EntryStruc.filename
		mov	al, 20h	; ' '
		std
		repe scasb
		inc	cx
		mov	dx, cx
		mov	si, bx
		add	si, 1

NextNameChar:				; ...
		cld
		lodsb
		test	ss:_Bits, 20h	; mask.lcase
		jz	short ddf1
		call	LowerCase

ddf1:					; ...
		call	PRINT_CHAR
		loop	NextNameChar
		mov	di, bx
		add	di, 11		; fileext + size fileext - 1
		mov	cx, 3		; size fileext
		mov	al, 20h	; ' '
		std
		repe scasb
		jz	short ddDone
		inc	cx
		add	dx, cx
		inc	dx
		mov	al, '.'
		call	PRINT_CHAR
		mov	si, bx
		add	si, 9		; EntryStruc.fileext

NextExtChar:				; ...
		cld
		lodsb
		test	cs:_Bits, 20h
		jz	short ddf2
		call	LowerCase

ddf2:					; ...
		call	PRINT_CHAR
		loop	NextExtChar

ddDone:					; ...
		pop	es
		pop	ds
		cld
		retn
DisplayDotForm	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayFile	proc near		; ...
		test	ds:_Bits, 10h	; mask.bare
		jz	short dfNorm
		call	DisplayBare
		jmp	short dfRet
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dfNorm:					; ...
		call	DisplayNext
		test	ds:_Bits, 2
		jz	short dfFul
		call	DisplayWide
		jmp	short dfCnt
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dfFul:					; ...
		call	DisplayName
		call	DisplayTheRest
		test	ds:_Bits, 1	; mask.cratio
		jz	short dfCnt
		call	DisplayCompRatio

dfCnt:					; ...
		call	CountFile

dfRet:					; ...
		retn
DisplayFile	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayHeader	proc near		; ...
		test	ds:_Bits, 10h	; mask.bare
		jnz	short dhRet
		test	ds:_Bits, 8	; mask.subd
		jz	short dhNorm
		call	CRLF2
		call	UseLine
		jmp	short dhCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dhNorm:					; ...
		mov	al, 20h	; ' '
		call	PRINT_CHAR

dhCom:					; ...
		call	build_dir_string
		mov	dx, offset dirhead_ptr
		call	std_printf
		call	UseLine
		call	CRLF2
		call	UseLine

dhRet:					; ...
		retn
DisplayHeader	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayName	proc near		; ...
		push	ds
		mov	ds, ds:TPA
		mov	si, bx		; DS:SI	= ptr to entry
		add	si, 1		; EntryStruc.filename
		mov	di, offset CHARBUF
		mov	cx, 8
		cld
		rep movsb		; move filename	to CharBuf
		mov	al, 20h	; ' '
		stosb			; add a	blank
		mov	cx, 3
		rep movsb		; add extension
		xor	al, al
		stosb			; add a	NULL
		pop	ds
		test	ds:_Bits, 20h	; mask.lcase
		jz	short dn1	; lowercase not	required
		mov	si, offset CHARBUF
		call	LowercaseString

dn1:					; ...
		mov	ds:string_ptr_2, offset	CHARBUF
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
DisplayName	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayNext	proc near		; ...
		cmp	ds:FileCnt, 0
		jz	short dn1st
		cmp	ds:LeftOnLine, 0
		jle	short dnEol
		mov	dx, offset tab_ptr
		call	std_printf
		jmp	short dnDone
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dnEol:					; ...
		call	CRLF2
		call	UseLine

dn1st:					; ...
		mov	al, ds:PerLine
		mov	ds:LeftOnLine, al

dnDone:					; ...
		dec	ds:LeftOnLine
		retn
DisplayNext	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTheRest	proc near		; ...
		push	es
		mov	es, ds:TPA
		mov	bp, bx
		test	byte ptr es:[bp+12], 10h ;
					; [es:bp+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short drNonDir
		mov	dx, offset dmes_ptr
		call	std_printf
		test	ds:screen_f_1, 40h ; 80	columns	?
		jz	short dr_0	; no
		mov	dx, offset space_4_ptr ; 4 space chars
		call	std_printf

dr_0:					; ...
		jmp	short drCom
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

drNonDir:				; ...
		mov	dx, es:[bp+17]	; [es:bp+EntryStruc.filesize]
		mov	ds:File_Size_Low, dx
		mov	dx, es:[bp+19]	; [es:bp+EntryStruc.filesize+2]
		mov	ds:File_Size_High, dx
		mov	dx, offset disp_file_size_ptr
		call	std_printf

drCom:					; ...
		mov	ax, es:[bp+15]	; [es:bp+EntryStruc.filedate]
		or	ax, ax
		jz	short drDone
		mov	bx, ax
		and	ax, 1Fh
		mov	dl, al
		mov	ax, bx
		mov	cl, 5
		shr	ax, cl
		and	al, 0Fh
		mov	dh, al
		mov	cl, bh
		shr	cl, 1
		xor	ch, ch
		add	cx, 80
		cmp	cl, 100
		jb	short dr_1
		sub	cl, 100

dr_1:					; ...
		xchg	dh, dl
		mov	ds:DirDat_Yr, cx
		mov	ds:DirDat_Mo_Day, dx
		mov	cx, es:[bp+13]	; [es:bp+EntryStruc.filetime]
		jcxz	short drPrint
		shr	cx, 1
		shr	cx, 1
		shr	cx, 1
		shr	cl, 1
		shr	cl, 1
		xchg	ch, cl
		mov	ds:DirTim_Hr_Min, cx

drPrint:				; ...
		mov	dx, offset dirdattim_ptr
		call	std_printf

drDone:					; ...
		pop	es
		mov	bx, bp
		retn
DisplayTheRest	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayCompRatio proc near		; ...
		push	es
		mov	es, ds:TPA
		mov	al, es:[bx+15h]	; mov al, es:[bx].compratio
					; mov al,[es:bx+EntryStruc.compratio]
		cmp	al, 0FFh
		jz	short dcrRet
		mov	ah, al
		mov	cl, 4
		shr	ah, cl
		inc	ah
		and	al, 0Fh
		mov	ds:Dir_CRatio_1, ah
		mov	ds:Dir_CRatio_2, al
		mov	dx, offset DirCompRatio_Ptr
		call	std_printf

dcrRet:					; ...
		pop	es
		retn
DisplayCompRatio endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayTrailer	proc near		; ...
		test	ds:_Bits, 10h	; mask.bare
		jnz	short dtrRet
		call	CRLF2
		call	UseLine
		mov	ax, ds:FileCnt

DisplayCntSiz:				; ...
		test	ds:_Bits, 1	; mask.cratio
		jz	short dtrSize
		push	ax
		mov	ax, ds:ccluUsedDir
		or	ax, ax
		jz	short dtrSkipRatio
		mov	cx, ds:csecUsedDir+2
		mov	bx, ds:csecUsedDir
		call	ComputeRatio
		mov	ds:Dir_CRatio_1, ah
		mov	ds:Dir_CRatio_2, al
		mov	dx, offset AveCompRatio_Ptr
		call	std_printf
		call	UseLine

dtrSkipRatio:				; ...
		pop	ax

dtrSize:				; ...
		mov	ds:Dir_Num, ax
		mov	dx, offset dirmes_ptr
		call	std_printf
		mov	dx, offset bytes_ptr
		call	std_printf
		call	UseLine

dtrRet:					; ...
		retn
DisplayTrailer	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisplayWide	proc near		; ...
		push	ds
		mov	ds, ds:TPA
		test	byte ptr [bx+12], 10h ;
					; [bx+EntryStruc.fileattr],ATTR_DIRECTORY
		jz	short dw1
		mov	al, '['
		call	PRINT_CHAR

dw1:					; ...
		call	DisplayDotForm
		test	byte ptr [bx+12], 10h
		jz	short dw2
		mov	al, ']'
		call	PRINT_CHAR

dw2:					; ...
		mov	cx, 12		; size filename	+ size fileext + 1
		sub	cx, dx
		jcxz	short dwDone
		mov	al, 20h	; ' '

dw3:					; ...
		call	PRINT_CHAR
		loop	dw3

dwDone:					; ...
		pop	ds
		retn
DisplayWide	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


EndPage		proc near		; ...
		test	ds:_Bits, 4	; mask.pagd
		jz	short epNew
		push	bx
		push	cx
		call	PAUSE
		call	build_dir_string
		mov	dx, offset dircont_ptr
		call	Printf_Crlf
		pop	cx
		pop	bx

epNew:					; ...
		mov	ax, ds:LinPerPag
		dec	ax
		mov	ds:LeftOnPage, ax
		retn
EndPage		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetDriveLtr	proc near		; ...
		mov	al, ds:5Ch	; [FCB]
		or	al, al
		jnz	short gdl1
		mov	al, ds:CURDRV
		inc	al

gdl1:					; ...
		add	al, 40h		; 'A'-1
		mov	ah, ':'
		retn
GetDriveLtr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupParamError	proc near		; ...
		mov	ax, 9
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	ds:extend_buf_ptr, ax
		mov	si, [bx+4]	; [bx+ResultBuffer.ValuePtr]
		mov	ds:string_ptr_2, si
		mov	ds:extend_buf_sub, 1 ; one_subst
		mov	dx, offset extend_buf_ptr
		retn
SetupParamError	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UseLine		proc near		; ...
		dec	ds:LeftOnPage
		cmp	ds:LeftOnPage, 2
		ja	short ulRet
		call	EndPage

ulRet:					; ...
		retn
UseLine		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ZeroTotals	proc near		; ...
		mov	di, offset FileCntTotal
		mov	cx, 26		; size FileCntTotal + size FileSizTotal
					; + csecSIZE + ccluSIZE
		xor	al, al
		rep stosb
		retn
ZeroTotals	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CtrlCHandler:				; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	ax
		push	bx
		push	dx
		call	CloseCVF	; close	CVF file if open
		call	RestUDir	; restore user's default directory
		pop	dx
		pop	bx
		pop	ax
		pop	ds
		assume ds:nothing
		jmp	cs:OldCtrlCHandler

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LowerCase	proc near		; ...
		cmp	al, 'A'
		jb	short lcRet
		cmp	al, 'Z'
		ja	short lcRet
		or	al, 20h

lcRet:					; ...
		retn
LowerCase	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LowercaseString	proc near		; ...
		push	di
		mov	di, si
		cld

NextChar:				; ...
		lodsb
		or	al, al
		jz	short EndOfString
		call	LowerCase
		stosb
		jmp	short NextChar
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EndOfString:				; ...
		pop	di
		retn
LowercaseString	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


screen_f_set	proc near		; ...
		push	ds
		mov	ax, 40h
		mov	ds, ax
		assume ds:nothing
		cmp	word ptr ds:4Ah, 40 ; Check ROMBIOS DATA colums	per row	value (80 or 40)
		pop	ds
		assume ds:nothing
		jnz	short columns_80 ; 80 columns per line (video mode 3)
		and	ds:screen_f_1, 0BFh ; ~40h ; not 40h
		mov	word ptr ds:screen_f_2,	0A0Ah ;	10 bytes (file size field)
		and	ds:screen_f_3, 0BFh
		and	ds:screen_f_4, 0BFh
		mov	word ptr ds:screen_f_5,	0A0Ah
		and	ds:screen_f_6, 0BFh
		mov	word ptr ds:screen_f_7,	1C1Ch ;	28 bytes (free bytes field)
		jmp	short screen_f_set_retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

columns_80:				; ...
		or	ds:screen_f_1, 40h
		mov	word ptr ds:screen_f_2,	0E0Eh ;	14 bytes (file size field)
		or	ds:screen_f_3, 40h
		or	ds:screen_f_4, 40h
		mov	word ptr ds:screen_f_5,	0E0Eh
		or	ds:screen_f_6, 40h
		mov	word ptr ds:screen_f_7,	2020h ;	32 bytes (free bytes field)

screen_f_set_retn:			; ...
		retn
screen_f_set	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


OpenCVF		proc near		; ...
		mov	ax, 0FFFFh	; -1
		mov	ds:fhCVF, ax	; CVF not open
		mov	ds:entInBuf, ax	; no FAT entries in buffers
		mov	dl, ds:5Ch	; [FCB]
		or	dl, dl
		jz	short ocvf_default
		dec	dl
		jmp	short ocvf_swap_info
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ocvf_errorj:				; ...
		jmp	ocvf_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ocvf_default:				; ...
		mov	dl, ds:CURDRV

ocvf_swap_info:				; ...
		mov	ax, 4A11h	; multMagicDrv
		mov	bx, 1		; MD_DRIVE_MAP
		int	2Fh
		or	ax, ax
		jnz	short ocvf_errorj
		test	bl, 80h
		jz	short ocvf_errorj
		and	bl, 7Fh
		push	bx
		push	dx
		mov	ax, 4A11h
		mov	dl, bl
		mov	bx, 1
		int	2Fh
		pop	dx
		pop	cx
		or	ax, ax
		jnz	short ocvf_error
		and	bl, 7Fh
		xchg	bx, cx
		cmp	dl, cl
		jz	short ocvf_got_host
		mov	bl, cl

ocvf_got_host:				; ...
		mov	di, offset szCVF
		mov	al, bl
		add	al, 'A'
		mov	ah, ':'
		cld
		stosw
		mov	si, offset sCVFRoot ; "\\DBLSPACE."
		mov	cx, 10		; cbCVFRoot
		rep movsb
		add	di, 3
		xor	al, al
		std
		stosb
		mov	al, bh
		mov	bl, 10
		mov	cx, 3

ocvf_1:					; ...
		xor	ah, ah
		div	bl
		add	ah, '0'
		xchg	ah, al
		stosb
		mov	al, ah
		loop	ocvf_1
		cld
		mov	di, offset szCVF
		mov	word ptr [di+4], 5652h ; 'RV'  (DRVSPACE)
		mov	ax, 3D00h
		mov	dx, offset szCVF
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jnb	short ocvf_2
		mov	word ptr [di+4], 4C42h ; 'BL'  (DBLSPACE)
		mov	ax, 3D00h
		mov	dx, offset szCVF
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		jb	short ocvf_error

ocvf_2:					; ...
		mov	ds:fhCVF, ax
		mov	bx, ax
		mov	ah, 3Fh		; READ
		mov	cx, 64		; size MD_BPB
		mov	dx, offset MDBPB
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short ocvf_error1
		cmp	ax, cx
		jz	short ocvf_pick_cluster_size

ocvf_error1:				; ...
		call	CloseCVF

ocvf_error:				; ...
		stc
		jmp	short ocvf_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ocvf_pick_cluster_size:			; ...
		cmp	ds:fUseHostSize, 0
		jz	short ovcf_use_CVF_size
		mov	ah, 1Ch		; Get_Drive_Data
		mov	dl, ds:szCVF
		sub	dl, 40h		; 'A'-1
		push	ds
		int	21h		; DOS -	GET ALLOCATION TABLE INFORMATION FOR SPECIFIC DRIVE
					; DL = drive number to check (0=default, 1=A, etc)
		pop	ds
		cmp	al, 0FFh
		jnz	short ovcf_set_size

ovcf_use_CVF_size:			; ...
		mov	al, ds:MDBPB+0Dh ; mov al,[MDBPB.dos_bpb.csecPerClu]

ovcf_set_size:				; ...
		mov	ds:csecPerCluster, al
		mov	ax, ds:BYTCNT
		mov	ds:savBytCnt, ax
		cmp	ax, 8000h	; 32*1024
		jnb	short ocvf_big_buf
		mov	ds:cFATEntries,	32 ; cRES_FAT_ENTRIES
		mov	ds:segFATBuf, ds
		mov	ds:pbufDOSFAT, offset bufDOSFAT
		mov	ds:pbufMDFAT, offset bufMDFAT
		jmp	short ocvf_success
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ocvf_big_buf:				; ...
		mov	bx, 256		; cBIG_FAT_ENTRIES
		mov	ds:cFATEntries,	bx
		shl	bx, 1		; 6 bytes per entry (2 for DOS FAT, 4 MD FAT)
		mov	cx, bx		; entries * 2
		shl	bx, 1
		add	bx, cx		; bx = # entries * 6
		sub	ax, bx
		and	ax, 0FE00h
		mov	ds:BYTCNT, ax
		mov	bx, ds:TPA
		mov	ds:segFATBuf, bx
		mov	ds:pbufDOSFAT, ax
		add	ax, cx
		mov	ds:pbufMDFAT, ax

ocvf_success:				; ...
		clc

ocvf_ret:				; ...
		retn
OpenCVF		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CloseCVF	proc near		; ...
		mov	bx, ds:fhCVF
		cmp	bx, 0FFFFh	; -1
		jz	short ccvf_ret
		mov	ah, 3Eh		; CLOSE
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	ds:fhCVF, 0FFFFh ; -1
		mov	ax, ds:savBytCnt
		mov	ds:BYTCNT, ax

ccvf_ret:				; ...
		retn
CloseCVF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CalcCompRatio	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	es
		mov	es, ds:segFATBuf
		xor	bx, bx
		mov	ds:ccluUsed, bx
		mov	ds:csecUsed, bx
		mov	ds:csecUsed+2, bx

ccr_next:				; ...
		cmp	ax, 2
		jb	short ccr_screwy
		cmp	ax, 0FFF0h
		jnb	short ccr_eof
		call	CheckFATBuffers
		jb	short ccr_screwy
		call	GetMDFATEntry
		jb	short ccr_screwy
		shl	bx, 1
		jnb	short ccr_screwy
		mov	ch, bh
		shl	bx, 1
		and	bx, 0F00h
		xchg	bh, bl
		inc	bx
		add	ds:csecUsed, bx
		adc	ds:csecUsed+2, 0
		mov	dx, ax
		mov	al, ch
		mov	cl, 3
		shr	al, cl
		and	ax, 0Fh
		dec	bx
		cmp	ax, bx
		jnb	short ccr_1
		mov	ax, bx

ccr_1:					; ...
		mov	cl, ds:csecPerCluster
		xor	ch, ch
		add	ax, cx
		div	cl
		xor	ah, ah
		add	ds:ccluUsed, ax
		mov	ax, dx
		call	GetDOSFATEntry
		jb	short ccr_screwy
		jmp	short ccr_next
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccr_eof:				; ...
		mov	ax, ds:ccluUsed
		add	ds:ccluUsedDir,	ax
		add	ds:ccluUsedTotal, ax
		mov	cx, ds:csecUsed+2
		mov	bx, ds:csecUsed
		add	ds:csecUsedDir,	bx
		adc	ds:csecUsedDir+2, cx
		add	word ptr ds:csecUsedTotal, bx
		adc	word ptr ds:csecUsedTotal+2, cx
		call	ComputeRatio
		jmp	short ccr_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ccr_screwy:				; ...
		xor	ax, ax

ccr_ret:				; ...
		pop	es
		pop	dx
		pop	cx
		pop	bx
		retn
CalcCompRatio	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ComputeRatio	proc near		; ...
		push	si
		push	di
		mov	si, bx
		mov	di, cx
		mov	bl, ds:csecPerCluster
		xor	bh, bh
		mul	bx
		mov	bx, si
		call	Div32
		push	ax
		mov	ax, bx
		or	ax, cx
		jz	short cr_got_tenths
		mov	ax, cx
		xor	dx, dx
		mov	cx, bx
		mov	bx, 10
		mul	bx
		xchg	ax, cx
		mul	bx
		add	dx, cx
		mov	cx, di
		mov	bx, si
		shr	cx, 1
		rcr	bx, 1
		add	ax, bx
		adc	dx, cx
		mov	cx, di
		mov	bx, si
		call	Div32

cr_got_tenths:				; ...
		pop	bx
		mov	ah, bl
		cmp	al, 10
		jb	short cr_exit
		inc	ah
		xor	al, al

cr_exit:				; ...
		pop	di
		pop	si
		retn
ComputeRatio	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Div32		proc near		; ...
		jcxz	short d32_16bit
		push	si
		push	di
		xor	si, si
		mov	di, si

div32_1:				; ...
		sub	ax, bx
		sbb	dx, cx
		jb	short d32_too_far
		add	si, 1
		adc	di, 0
		jmp	short div32_1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

d32_too_far:				; ...
		add	ax, bx
		adc	dx, cx
		mov	cx, di
		mov	bx, si
		xchg	ax, bx
		xchg	dx, cx
		pop	di
		pop	si
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

d32_16bit:				; ...
		div	bx
		mov	bx, dx
		xor	dx, dx
		mov	cx, dx
		retn
Div32		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetDOSFATEntry	proc near		; ...
		sub	ax, ds:entInBuf
		jb	short gdf_ret
		mov	bx, ax
		cmp	ds:MDBPB+3Dh, 0	; cmp MDBPB.f12BitFAT, 0
		jnz	short gdf_12
		shl	bx, 1
		add	bx, ds:pbufDOSFAT
		mov	ax, es:[bx]

gdf_success:				; ...
		clc

gdf_ret:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gdf_12:					; ...
		shr	bx, 1
		add	bx, ax
		add	bx, ds:pbufDOSFAT
		test	al, 1
		mov	ax, es:[bx]
		jnz	short gdf_odd
		and	ax, 0FFFh
		jmp	short gdf_testEOF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gdf_odd:				; ...
		mov	bx, cx
		mov	cl, 4
		shr	ax, cl
		mov	cx, bx

gdf_testEOF:				; ...
		cmp	ax, 0FF0h
		jb	short gdf_success
		or	ah, 0F0h
		jmp	short gdf_success
GetDOSFATEntry	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetMDFATEntry	proc near		; ...
		mov	bx, ax
		sub	bx, ds:entInBuf
		jb	short gmf_ret
		shl	bx, 1
		shl	bx, 1		; * 4 bytes per	MDFAT entry
		add	bx, ds:pbufMDFAT
		mov	cx, es:[bx]
		mov	bx, es:[bx+2]
		clc

gmf_ret:				; ...
		retn
GetMDFATEntry	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CheckFATBuffers	proc near		; ...
		mov	bx, ax
		sub	bx, ds:entInBuf
		jb	short cfb_load_fat
		sub	bx, ds:cFATEntries
		jnb	short cfb_load_fat
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cfb_load_fat:				; ...
		push	ax
		push	cx
		push	dx
		xor	cx, cx
		cmp	ds:MDBPB+3Dh, 0	; cmp MDBPB.f12BitFAT, 0
		jnz	short cfb_12
		mov	ds:entInBuf, ax
		shl	ax, 1
		rcl	cx, 1
		jmp	short cfb_common
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cfb_12:					; ...
		and	al, 0FEh	; not 1
		mov	ds:entInBuf, ax
		mov	bx, ax
		shr	bx, 1
		add	ax, bx

cfb_common:				; ...
		mov	bx, ax
		mov	ax, word ptr ds:MDBPB+27h ; mov	ax, MDBPB.csecMDReserved
					; # magicDrv reserved sectors
		add	ax, word ptr ds:MDBPB+0Eh ; add	ax, MDBPB.dos_bpb.csecReserved
		mul	word ptr ds:MDBPB+0Bh ;	mul MDBPB.dos_bpb.cbPerSec
					; DX:AX	= DOS FAT file origin
		add	ax, bx
		adc	dx, cx
		mov	cx, ds:cFATEntries
		shl	cx, 1
		mov	bx, ds:pbufDOSFAT
		call	ReadCVFile
		jb	short cfb_error
		mov	ax, word ptr ds:MDBPB+24h ; mov	ax, MDBPB.secMDFATStart
		inc	ax
		mul	word ptr ds:MDBPB+0Bh ;	mul MDBPB.dos_bpb.cbPerSec
					; DX:AX	= MDFAT	file offset
					;
		mov	bx, ds:entInBuf
		xor	cx, cx
		add	bx, word ptr ds:MDBPB+2Dh ; add	bx, MDBPB.cluFirstData
					; CX:BX	= MDFAT	entry #
		adc	cx, cx
		shl	bx, 1
		rcl	cx, 1
		shl	bx, 1
		rcl	cx, 1
		add	ax, bx
		adc	dx, cx
		mov	cx, ds:cFATEntries
		shl	cx, 1
		shl	cx, 1
		mov	bx, ds:pbufMDFAT
		call	ReadCVFile
		jnb	short cfb_ret

cfb_error:				; ...
		stc

cfb_ret:				; ...
		pop	dx
		pop	cx
		pop	ax
		retn
CheckFATBuffers	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ReadCVFile	proc near		; ...
		push	bx
		push	cx
		mov	cx, dx
		mov	dx, ax
		mov	ax, 4200h	; (LSEEK shl 8)	or 0
		mov	bx, ds:fhCVF
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jb	short rcf_ret
		mov	ah, 3Fh		; READ
		pop	cx
		pop	dx
		push	ds
		push	es
		pop	ds
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		jb	short rcf_ret
		cmp	ax, cx
		jz	short rcf_ret
		stc

rcf_ret:				; ...
		retn
ReadCVFile	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PAUSE		proc near		; ...
		mov	dx, offset PAUSEMES_PTR
		call	std_printf
		call	GETKEYSTROKE
		call	CRLF2
		retn
PAUSE		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ERASE		proc near		; ...

; FUNCTION CHUNK AT 3C16 SIZE 00000116 BYTES

		mov	si, 81h
		mov	ds:COMSW, 0
		mov	di, offset PARSE_ERASE
		xor	cx, cx

erase_scan:				; ...
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short good_line
		cmp	ax, 0
		jnz	short errj2
		cmp	ds:PARSE1_SYN, offset SLASH_P_SYN ; "/P"
		jz	short set_erase_prompt
		push	si
		lds	si, ds:PARSE1_ADDR
		cmp	byte ptr [si+1], ':' ; colon_char
		jnz	short erase_drive_ok
		cmp	byte ptr [si+2], 0 ; end_of_line_out
		jnz	short erase_drive_ok
		mov	ax, 2
		jmp	short extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

erase_drive_ok:				; ...
		call	Move_To_SrcBuf
		pop	si
		jmp	short erase_scan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

set_erase_prompt:			; ...
		cmp	ds:COMSW, 0
		jz	short ok_to_set_erase_prompt
		mov	ax, 1		; MoreArgs_Ptr
		call	setup_parse_error_msg
		jmp	short errj2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ok_to_set_erase_prompt:			; ...
		inc	ds:COMSW
		jmp	short erase_scan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_line:				; ...
		call	PathCrunch
		jnb	short checkdr
		mov	ax, ds:Msg_Numb
		cmp	ax, 0
		jnz	short extend_setup
		cmp	ds:DestIsDir, 0
		jnz	short badpath_err

checkdr:				; ...
		cmp	ds:COMSW, 0
		jz	short notest2j
		jmp	slashp_erase
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notest2j:				; ...
		jmp	notest2
ERASE		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR BUILDPATH

badpath_err:				; ...
		mov	ax, 3		; ERROR_PATH_NOT_FOUND

extend_setup:				; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax

errj2:					; ...
		jmp	cerror
; END OF FUNCTION CHUNK	FOR BUILDPATH

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CRENAME		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_RENAME
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short crename_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short crename_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		mov	al, ':'
		cmp	[si+1],	al
		jnz	short ren_no_drive
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 0Ah ; BadParm_ptr
		pop	si

crename_parse_error:			; ...
		jmp	short errj
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ren_no_drive:				; ...
		mov	di, 6Ch		; FCB+10h
		mov	ax, 2901h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		lodsb
		mov	ds:One_Char_Val, al
		pop	si
		mov	di, offset PARSE_RENAME
		call	parse_check_eol
		jnz	short crename_parse_error
		call	PathCrunch
		mov	dx, offset BADCPMES_PTR
		jz	short errj2
		jnb	short notest3
		mov	ax, ds:Msg_Numb
		cmp	ax, 0
		jnz	short extend_setup
		cmp	ds:DestIsDir, 0
		jz	short notest3
		jmp	badpath_err
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notest3:				; ...
		mov	al, ds:One_Char_Val
		mov	dx, offset INORNOT_PTR
		call	pathchrcmp
		jz	short errj
		mov	ah, 17h
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	RENAME FILE via	FCB
					; DS:DX	-> FCB
					; FCB contains new name	starting at byte 17h.
		cmp	al, 0FFh
		jnz	short renameok
		call	get_ext_error_number
		push	ax
		mov	al, 0FFh

renameok:				; ...
		push	ax
		call	RestUDir
		pop	ax
		inc	al
		jz	short rn1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

rn1:					; ...
		pop	ax
		cmp	ax, 2
		jz	short use_renerr
		cmp	ax, 5
		jz	short use_renerr
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

use_renerr:				; ...
		mov	dx, offset RENERR_PTR

errj:					; ...
		jmp	cerror
CRENAME		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TYPEFIL		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0
		jnz	short typefil_parse_error
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		jz	short gottarg

typefil_parse_error:			; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gottarg:				; ...
		call	SETPATH
		test	ds:DestInfo, 2	; 00000010b
		jz	short nowilds
		mov	dx, offset INORNOT_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nowilds:				; ...
		mov	ax, 6C00h	; ExtOpen SHL 8
		mov	bx, 0		; read_open_mode
		xor	cx, cx
		mov	dx, 101h	; read_open_flag
		mov	si, offset SrcBuf
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short typecont

typerr:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	Set_Ext_Error_Msg
		mov	string_ptr_2, offset SrcBuf
		mov	extend_buf_sub,	1 ; one_subst
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

typecont:				; ...
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jz	short not_device
		mov	TypeFilSiz+2, 0FFFFh ; -1
		jmp	short dotype
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_device:				; ...
		mov	ax, 4202h
		xor	dx, dx
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		mov	TypeFilSiz, ax
		mov	TypeFilSiz+2, dx
		mov	ax, 4200h
		xor	dx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file

dotype:					; ...
		mov	zflag, 0
		mov	ds, TPA
		assume ds:nothing
		xor	dx, dx

typelp:					; ...
		cmp	cs:zflag, 0
		jz	short tf1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf1:					; ...
		mov	cx, cs:BYTCNT
		cmp	cs:TypeFilSiz+2, 0FFFFh	; -1
		jz	short typ_read
		cmp	cs:TypeFilSiz+2, 0
		jz	short lt64k
		sub	cs:TypeFilSiz, cx
		sbb	cs:TypeFilSiz+2, 0
		jmp	short typ_read
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lt64k:					; ...
		cmp	cx, cs:TypeFilSiz
		jbe	short gtbuf
		mov	cx, cs:TypeFilSiz
		jcxz	short typelp_ret
		mov	cs:TypeFilSiz, 0
		jmp	short typ_read
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gtbuf:					; ...
		sub	cs:TypeFilSiz, cx

typ_read:				; ...
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jnb	short tf2
		jmp	typerr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf2:					; ...
		mov	cx, ax
		jcxz	short typelp_ret
		push	ds
		pop	es
		xor	di, di
		push	ax
		mov	al, 1Ah
		repne scasb
		pop	ax
		xchg	ax, cx
		cmp	ax, 0
		jnz	short foundz
		cmp	byte ptr [di-1], 1Ah
		jnz	short typecont2

foundz:					; ...
		sub	cx, ax
		dec	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		not	es:zflag

typecont2:				; ...
		push	bx
		mov	bx, 1
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		jb	short Error_outputj
		cmp	ax, cx
		jnz	short tf3
		jmp	typelp
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tf3:					; ...
		dec	cx
		cmp	ax, cx
		jnz	short Error_outputj

tf4:					; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Error_outputj:				; ...
		mov	bx, 1
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short tf4
		jmp	error_output
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

typelp_ret:				; ...
		retn
TYPEFIL		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


VOLUME		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_VOL
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; -1
		jz	short OkVolArg
		cmp	ax, 0
		jnz	short badvolarg
		mov	di, offset PARSE_VOL
		xor	dx, dx
		call	parse_check_eol
		jz	short OkVolArg

badvolarg:				; ...
		jmp	cerror
VOLUME		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DisAppend	proc near		; ...
		push	ds
		push	es
		push	di
		mov	ax, 0B700h
		int	2Fh		; - Multiplex -	APPEND - INSTALLATION CHECK
					; Return: AL = 00h not installed
					; AL = FFh if installed
		or	al, al
		jz	short daRet
		mov	ax, 0B702h
		int	2Fh		; - Multiplex -	APPEND - VERSION CHECK
					; Return: AX = FFFFh if	not DOS	4.0 APPEND
					; AL = major version number
					; AH = minor version number, otherwise
		cmp	ax, 0FFFFh
		jnz	short daRet
		mov	ax, 0B706h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - GET APPEND FUNCTION STATE
					; Return: BX = APPEND state
		mov	ds, ds:RESSEG
		mov	ds:Append_State, bx
		mov	ds:Append_Flag,	0FFh ; -1
		xor	bx, bx
		mov	ax, 0B707h
		int	2Fh		; - Multiplex -	DOS 4.0	APPEND - SET APPEND FUNCTION STATE
					; BX = APPEND state bits

daRet:					; ...
		pop	di
		pop	es
		assume es:nothing
		pop	ds
		retn
DisAppend	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


OkVolArg	proc near		; ...
		call	DisAppend
		call	CRLF2
		mov	al, 20h	; ' '   ; blank
		call	PRINT_CHAR
		push	ds
		pop	es
		mov	di, 55h		; FCB-7
		mov	al, 0FFh	; -1
		stosb
		xor	ax, ax
		stosw
		stosw
		stosb
		mov	al, 8		; ATTR_VOLUME_ID
		stosb
		inc	di
		mov	cx, 11
		mov	al, '?'
		rep stosb
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	dx, 55h
		mov	ah, 11h
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		push	ax
		mov	al, ds:5Ch
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short drvok
		mov	al, ds:CURDRV
		add	al, 'A'

drvok:					; ...
		mov	ds:vol_drv, al
		pop	ax
		or	al, al
		jz	short Get_vol_name
		mov	dx, offset VolMes_Ptr_2
		jmp	short print_serial
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Get_vol_name:				; ...
		mov	di, offset CHARBUF
		mov	dx, di
		mov	si, offset DIRBUF_8 ; DIRBUF+8
		mov	cx, 11
		rep movsb
		xor	al, al
		stosb
		mov	dx, offset VolMes_Ptr

print_serial:				; ...
		push	dx
		mov	ax, 6900h
		mov	bl, ds:5Ch	; [FCB]
		mov	dx, offset vol_ioctl_buf
		int	21h		; DOS -	4.0 internal - GET/SET DISK SERIAL NUMBER
					; AL = 00h get serial number / 01h set serial number
					; BL = drive (0=default, 1=A, 2=B, etc)
					; DS:DX	-> disk	info
		pop	dx
		jb	short printvol_end
		call	std_printf
		mov	al, 20h	; ' '
		call	PRINT_CHAR
		mov	dx, offset VolSerMes_Ptr

printvol_end:				; ...
		jmp	std_printf
OkVolArg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Set_Ext_Error_Msg proc near		; ...
		call	get_ext_error_number
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		stc
		retn
Set_Ext_Error_Msg endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_ext_error_number proc near		; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		mov	ah, 59h		; GetExtendedError
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	ds
		pop	es
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
get_ext_error_number endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


VERSION		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_VER
		xor	cx, cx
		call	Parse_With_Msg
		mov	bl, 1
		cmp	ax, 0		; RESULT_NO_ERROR
		jz	short verPrintVer
		dec	bl
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short verPrintVer
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verPrintVer:				; ...
		push	bx
		call	CRLF2
		call	PRINT_VERSION
		call	CRLF2
		pop	bx
		or	bl, bl
		jz	short verDone
		mov	ax, 3306h
		int	21h		; DOS -	5+ Get TRUE Version Number (BL major, BH minor,	DL revision, DH	flags)
		mov	al, dl
		mov	bh, dh
		cmp	al, 25		; 'Z'-'A'
		jbe	short ver1
		mov	al, -23		; '*'-'A'

ver1:					; ...
		add	al, 'A'         ; 41h
		mov	ds:One_Char_Val, al
		mov	dx, offset dosrev_ptr
		call	std_printf
		mov	cl, 4
		shr	bh, cl
		jb	short verRom
		shr	bh, 1
		jb	short verHma
		mov	dx, offset DosLow_Ptr
		jmp	short verPrintLoc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verRom:					; ...
		mov	dx, offset DosRom_Ptr
		jmp	short verPrintLoc
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

verHma:					; ...
		mov	dx, offset DosHma_Ptr

verPrintLoc:				; ...
		call	std_printf

verDone:				; ...
		jmp	CRLF2
VERSION		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_VERSION	proc near		; ...
		mov	ah, 30h
		int	21h		; DOS -	GET DOS	VERSION
					; Return: AL = major version number (00h for DOS 1.x)
		push	ax
		xor	ah, ah
		mov	ds:Major_Ver_Num, ax
		pop	ax
		xchg	ah, al
		xor	ah, ah
		mov	ds:Minor_Ver_Num, ax
		mov	dx, offset VerMes_Ptr
		jmp	std_printf
PRINT_VERSION	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_PROMPT	proc near		; ...
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		push	es
		call	find_prompt
		jb	short PP0
		cmp	byte ptr es:[di], 0
		jnz	short PP1

PP0:					; ...
		call	PRINT_DRIVE
		mov	al, '>'
		call	PRINT_CHAR
		jmp	short PP5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP1:					; ...
		mov	al, es:[di]
		inc	di
		or	al, al
		jz	short PP5
		cmp	al, '$'
		jz	short PP2
		call	PRINT_CHAR
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP2:					; ...
		mov	al, es:[di]
		inc	di
		mov	bx, offset clsstring_2 ; PROMPT_TABLE-3	(db '[2J')
		or	al, al
		jz	short PP5

PP3:					; ...
		add	bx, 3
		call	UPCONV
		cmp	al, [bx]
		jz	short PP4
		cmp	byte ptr [bx], 0
		jnz	short PP3
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP4:					; ...
		push	es
		push	di
		push	cs
		pop	es
		assume es:TRANGROUP
		call	word ptr [bx+1]
		pop	di
		pop	es
		assume es:nothing
		jmp	short PP1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PP5:					; ...
		pop	es
		pop	ds
		assume ds:nothing
		retn
PRINT_PROMPT	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_BACK:				; ...
		mov	dx, offset dback_ptr
		jmp	std_printf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_EQ:				; ...
		mov	al, '='
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_ESC:				; ...
		mov	al, 1Bh		; ESCape
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_G:				; ...
		mov	al, '>'
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_L:				; ...
		mov	al, '<'
		jmp	short PRINT_CHAR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Print_B:				; ...
		mov	al, '|'

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_CHAR	proc near		; ...
		push	es
		push	ds
		pop	es
		push	di
		push	dx
		mov	dl, al
		mov	ah, 2		; STD_CON_OUTPUT
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	dx
		pop	di
		pop	es
		retn
PRINT_CHAR	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRINT_DRIVE	proc near		; ...
		mov	ah, 19h
		int	21h		; DOS -	GET DEFAULT DISK NUMBER
		add	al, 41h	; 'A'
		call	PRINT_CHAR
		retn
PRINT_DRIVE	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

build_dir_for_prompt:			; ...
		xor	dl, dl
		mov	si, offset BWDBUF
		mov	di, si
		mov	al, ds:CURDRV
		add	al, 'A'
		mov	ah, ':'
		stosw
		mov	al, ds:DIRCHAR
		stosb
		xchg	si, di
		mov	ds:string_ptr_2, di
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		mov	dx, offset string_buf_ptr
		jnb	short doprint
		mov	dx, offset BADCURDRV

doprint:				; ...
		call	std_printf
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


build_dir_for_chdir proc near		; ...
		call	build_dir_string
		mov	dx, offset BWDBUF ; DIRBUF
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		retn
build_dir_for_chdir endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


build_dir_string proc near		; ...
		mov	dl, ds:5Ch
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short gotdrive
		add	al, ds:CURDRV
		inc	al

gotdrive:				; ...
		push	ax
		mov	si, (offset BWDBUF+3)
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		jnb	short dpbisok
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

dpbisok:				; ...
		mov	di, offset BWDBUF
		mov	dx, di
		pop	ax
		mov	ah, ':'
		stosw
		mov	al, DIRCHAR
		stosb
		retn
build_dir_string endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PATH		proc near		; ...
		xor	al, al
		mov	di, offset SRCXNAME
		stosb
		dec	di
		call	PGETARG
		jz	short disppath
		cmp	al, ';'         ; 3Bh
		jnz	short pathslp
		inc	si
		jmp	short scan_white
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pathslp:				; ...
		lodsb
		cmp	al, 0Dh		; END_OF_LINE_IN
		jz	short path_eol
		call	testkanj
		jz	short notkanj2
		stosb
		lodsb

path_hold:				; ...
		stosb
		jmp	short pathslp
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj2:				; ...
		call	UPCONV
		cmp	al, ';'         ; 3Bh ; semicolon
		jz	short path_hold
		call	DELIM
		jnz	short path_hold

scan_white:				; ...
		lodsb
		cmp	al, 0Dh
		jz	short path_eol
		cmp	al, 20h	; ' '
		jz	short scan_white
		cmp	al, 9
		jz	short scan_white
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	1 ; MoreArgs_Ptr
		mov	msg_disp_class,	2 ; parse_msg_class
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_eol:				; ...
		xor	al, al
		stosb
		call	find_path
		call	delete_path
		call	scan_double_null
		call	move_name
		mov	si, offset SRCXNAME

store_path:				; ...
		lodsb
		cmp	al, 0
		jz	short got_paths
		call	store_char
		jmp	short store_path
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_paths:				; ...
		xor	ax, ax
		stosw
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

disppath:				; ...
		call	find_path
		call	print_path
		call	CRLF2
		retn
PATH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


print_path	proc near		; ...
		cmp	byte ptr es:[di], 0
		jnz	short path1

path0:					; ...
		mov	dx, offset NULLPATH_PTR
		push	cs
		pop	es
		assume es:TRANGROUP
		push	cs
		pop	ds
		jmp	std_printf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path1:					; ...
		push	es
		pop	ds
		sub	di, 5
		mov	si, di
		call	SCASB2
		cmp	cx, 0FFh	; 255
		jz	short path0
		push	cs
		pop	es
		mov	di, offset Arg_Buf
		mov	dx, 100h	; 256
		sub	dx, cx
		xchg	dx, cx
		rep movsb
		mov	dx, offset arg_buf_ptr
		push	cs
		pop	ds
		jmp	std_printf
print_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CLS		proc near		; ...
		mov	ah, 1Ah
		mov	al, 0
		int	2Fh		; - Multiplex -	DOS 4+ ANSI.SYS	internal - INSTALLATION	CHECK
					; Return: AL = FFh if installed
		cmp	al, 0FFh	; ANSI_installed
		jz	short ansicls
		mov	ax, 440Ch
		mov	bx, 1
		mov	ch, 3
		mov	cl, 7Fh
		mov	dx, offset Display_Ioctl
		int	21h		; DOS -	2+ - IOCTL -
		jb	short no_variable
		mov	ax, LinPerPag
		mov	dh, al
		mov	ax, display_width
		mov	dl, al
		jmp	short regcls
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_variable:				; ...
		mov	bx, 1
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jz	short ansicls
		test	dl, 10h
		jnz	short cls_normal

ansicls:				; ...
		call	ansi_cls
		jmp	short cls_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cls_normal:				; ...
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		cmp	al, 3
		jbe	short DoAlpha
		cmp	al, 7
		jz	short DoAlpha
		mov	ah, 0
		int	10h		; - VIDEO - SET	VIDEO MODE
					; AL = mode
		jmp	short cls_ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DoAlpha:				; ...
		push	ds
		mov	ax, 40h		; ROMBIOS_DATA
		mov	ds, ax
		assume ds:nothing
		mov	dx, ds:4Ah	; [CRT_Cols]
		mov	dh, ds:84h	; [CRT_Rows]
		pop	ds
		assume ds:nothing
		or	dh, dh
		jnz	short regcls
		mov	dh, 25

regcls:					; ...
		inc	dh
		call	reg_cls

cls_ret:				; ...
		retn
CLS		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


reg_cls		proc near		; ...
		dec	dh
		dec	dl
		push	dx
		mov	ah, 0Bh
		xor	bx, bx
		int	10h		; - VIDEO - SET	COLOR PALETTE
					; BH = 00h, BL = border	color
					; BH = 01h, BL = palette (0-3)
		pop	dx
		xor	ax, ax
		mov	cx, ax
		mov	ah, 6
		mov	bh, 7
		xor	bl, bl
		int	10h		; - VIDEO - SCROLL PAGE	UP
					; AL = number of lines to scroll window	(0 = blank whole window)
					; BH = attributes to be	used on	blanked	lines
					; CH,CL	= row,column of	upper left corner of window to scroll
					; DH,DL	= row,column of	lower right corner of window
		mov	ah, 0Fh
		int	10h		; - VIDEO - GET	CURRENT	VIDEO MODE
					; Return: AH = number of columns on screen
					; AL = current video mode
					; BH = current active display page
		mov	ah, 2
		xor	dx, dx
		int	10h		; - VIDEO - SET	CURSOR POSITION
					; DH,DL	= row, column (0,0 = upper left)
					; BH = page number
		retn
reg_cls		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ansi_cls	proc near		; ...
		mov	si, offset CLSSTRING
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	ah, 6		; Raw_CON_IO

clrloop:				; ...
		lodsb
		mov	dl, al
		int	21h		; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
					; DL = character <> FFh
					;  Return: ZF set = no character
					;   ZF clear = character recieved, AL =	character
		loop	clrloop
		retn
ansi_cls	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CTTY		proc near		; ...
		push	ds
		pop	es
		assume es:nothing
		mov	si, 81h
		mov	di, offset PARSE_CTTY
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short ctty_error
		cmp	ax, 0
		jnz	short ctty_error
		push	si
		lds	si, ds:PARSE1_ADDR
		mov	di, offset SrcBuf

ctty_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short ctty_move_filename
		pop	si
		mov	di, offset PARSE_CTTY
		call	parse_check_eol
		jz	short nocolon

ctty_error:				; ...
		jmp	short isbaddev
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nocolon:				; ...
		mov	dx, offset SrcBuf
		mov	ax, 3D02h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		jb	short isbaddev
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short devisok

closedev:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

isbaddev:				; ...
		mov	dx, offset BADDEV_PTR
		call	std_printf
		jmp	short resret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

devisok:				; ...
		push	dx
		mov	ax, ds:acrlf_ptr
		mov	dh, 0FFh	; -1 ; util_msg_class
		push	bx
		call	TSYSGETMSG
		mov	dx, si
		mov	ax, 4000h
		mov	cx, 2
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		pop	dx
		jb	short closedev
		xor	dh, dh
		or	dl, 3
		mov	ax, 4401h
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		push	bx
		mov	cx, 3
		xor	bx, bx

iclloop:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		inc	bx
		loop	iclloop
		pop	bx
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 45h
		int	21h		; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
					; BX = file handle to duplicate
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

resret:					; ...
		mov	ds, ds:RESSEG
		push	ds
		mov	ax, ds:18h	; [PDB.JFN_TABLE]
		mov	ds:Io_Save, ax
		mov	ax, offset TrnLodCom1_Trap
		push	ax
		retf
CTTY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CHCP		proc near		; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHCP
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh	; -1
		jz	short getcp
		cmp	ax, 0
		jnz	short cp_error
		push	cx
		mov	bx, offset PARSE1_ADDR
		mov	cx, [bx]
		mov	ds:system_cpage, cx
		pop	cx
		mov	di, offset PARSE_CHCP
		call	parse_check_eol
		jnz	short cp_error
		mov	ah, 14h
		mov	al, 0
		int	2Fh		; - Multiplex -	NLSFUNC.COM - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, not OK
					; FFh installed
		cmp	al, 0FFh	; NLSFUNC_installed
		jz	short got_NLS
		mov	dx, offset NLSFUNC_PTR
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

got_NLS:				; ...
		mov	bx, ds:system_cpage
		mov	ah, 66h		; GETSETCDPG
		mov	al, 2
		int	21h		; DOS -	3.3+ - SET GLOBAL CODE PAGE TABLE
					; BX = active code page
					; DX = system code page	(active	page at	boot time)
		jnb	short chcp_return
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jnz	short chcp_other_error
		mov	ah, 59h		; GETEXTENDEDERROR
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 0Dh		; ERROR_INVALID_DATA
		jnz	short no_countrysys
		mov	dx, offset INV_CODE_PAGE
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_countrysys:				; ...
		mov	dx, offset NoCntry_Ptr
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chcp_other_error:			; ...
		mov	ah, 59h
		xor	bx, bx
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		cmp	ax, 65
		jnz	short none_set
		mov	dx, offset cp_not_all_ptr
		jmp	short cp_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

none_set:				; ...
		mov	dx, offset cp_not_set_ptr

cp_error:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getcp:					; ...
		mov	ah, 66h
		mov	al, 1
		int	21h		; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
		mov	ds:system_cpage, bx
		mov	dx, offset cp_active_ptr
		call	std_printf

chcp_return:				; ...
		retn
CHCP		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TRUENAME	proc near		; ...
		push	ds
		pop	es
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		mov	di, offset SRCXNAME
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short tn_eol
		cmp	ax, 0
		jnz	short tn_parse_error
		cmp	ds:PARSE1_OUTPUT, 6 ; PARSE1_TYPE
		jz	short tn_drive
		jmp	short tn_filespec
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_eol:					; ...
		mov	ah, 0
		mov	al, '.'
		stosw
		jmp	short tn_doit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_drive:				; ...
		push	si
		mov	si, offset PARSE1_ADDR
		lodsb
		add	al, 40h		; 'A'-1
		stosb
		mov	ax, '.:'        ; 2E3Ah ; ah=".", al=":"
		stosw
		mov	al, 0
		stosb
		pop	si
		jmp	short tn_check_eol
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_filespec:				; ...
		push	si
		lds	si, ds:PARSE1_ADDR

tn_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0
		jnz	short tn_move_filename
		pop	si

tn_check_eol:				; ...
		mov	di, offset PARSE_CHDIR
		call	parse_check_eol
		jz	short tn_doit

tn_parse_error:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_doit:				; ...
		mov	si, offset SRCXNAME
		mov	di, offset COMBUF
		mov	ah, 60h
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		jnb	short tn_print_xname
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	SRCXNAME
		mov	ds:extend_buf_sub, 1 ; one_subst
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tn_print_xname:				; ...
		mov	ds:string_ptr_2, offset	COMBUF
		mov	dx, offset string_buf_ptr
		call	CRLF2
		call	Printf_Crlf
		retn
TRUENAME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$EXIT		proc near		; ...
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:PermCom, 0
		jz	short free_com
		cmp	ds:SingleCom, 0FFFFh ; -1
		jz	short no_reset
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

free_com:				; ...
		mov	ax, 122Eh	; (multdos shl 8 or message_2f)
		mov	dl, 5		; SET_CRITICAL_MSG
		mov	di, ds:Crit_Msg_Off
		mov	es, ds:Crit_Msg_Seg
		assume es:RESGROUP
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - set critical/SHARE	error table
					; ES:DI	-> error table

no_reset:				; ...
		pop	ds
		call	RestUDir1
		mov	es, ds:RESSEG
		assume es:nothing
		mov	ax, es:Parent
		mov	es:16h,	ax	; [es:PDB.PARENT_PID]
		mov	ax, es:OldTerm
		mov	es:0Ah,	ax	; [es:PDB.EXIT]
		mov	ax, es:OldTerm+2
		mov	es:0Ch,	ax	; [es:PDB.EXIT+2]
		push	es
		mov	es, ds:TRAN_TPA
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		pop	es
		mov	ah, 4Ch		; EXIT
		mov	al, byte ptr es:RetCode
		int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
_$EXIT		endp			; AL = exit code


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


parse_check_eol	proc near		; ...
		xor	dx, dx
		mov	ds:parse_last, si
		call	cmd_parse
		cmp	al, 0FFh	; END_OF_LINE
		jz	short parse_good_eol
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short ok_to_setup_pmsg
		inc	ax

ok_to_setup_pmsg:			; ...
		call	setup_parse_error_msg

parse_good_eol:				; ...
		retn
parse_check_eol	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Parse_With_Msg	proc near		; ...
		mov	ds:parse_last, si
		call	cmd_parse
		cmp	al, 0FFh
		jz	short parse_msg_good
		cmp	ax, 0
		jz	short parse_msg_good
		call	setup_parse_error_msg

parse_msg_good:				; ...
		retn
Parse_With_Msg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


setup_parse_error_msg proc near		; ...
		mov	ds:msg_disp_class, 2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	byte ptr [si], 0 ; END_OF_LINE_OUT
		mov	ds:extend_buf_ptr, ax
		cmp	ax, 2
		jz	short setup_parse_msg_ret
		mov	si, ds:parse_last
		mov	ds:string_ptr_2, si
		mov	ds:extend_buf_sub, 1 ; one_subst

setup_parse_msg_ret:			; ...
		inc	si
		retn
setup_parse_error_msg endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ADD_PROMPT	proc near		; ...

; FUNCTION CHUNK AT 2930 SIZE 00000033 BYTES

		call	delete_prompt
		call	scan_double_null
		push	si
		call	GETARG
		pop	si
		jnz	short ADD_PROMPT3

ADD_PROMPT_RETN:			; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_PROMPT3:				; ...
		call	move_name
		call	GETARG
		push	si
		jmp	short ADD_NAME
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DISP_ENVJ:				; ...
		jmp	DISP_ENV
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_NAME_TO_ENVIRONMENT:		; ...
		call	GETARG
		jz	short DISP_ENVJ
		xor	bx, bx
		push	si

EQLP:					; ...
		lodsb
		cmp	al, 13		; 0Dh
		jz	short QUEQ
		cmp	al, '='         ; 3Dh
		jnz	short EQLP
		inc	bl
		cmp	byte ptr [si], 13 ; 0Dh
		jnz	short EQLP
		inc	bh
		jmp	short EQLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

QUEQ:					; ...
		pop	si
		dec	bl
		jz	short ONEQ
		mov	dx, offset SYNTMES_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ONEQ:					; ...
		push	bx
		call	delete_name_in_environment
		pop	bx
		dec	bh
		jz	short ADD_PROMPT_RETN
		call	scan_double_null
		mov	bx, di
		call	move_name
		push	si
		xchg	bx, di
		mov	ds:comspec_flag, 0
		mov	si, offset COMSPECSTR ;	"COMSPEC="
		mov	cx, 4
		repe cmpsw
		jnz	short NOT_COMSPEC
		inc	ds:comspec_flag

NOT_COMSPEC:				; ...
		mov	di, bx

ADD_NAME:				; ...
		pop	si
		push	si

ADD_NAME1:				; ...
		lodsb
		cmp	al, 0Dh		; 13
		jz	short ADD_NAME_RET
		call	store_char
		jmp	short ADD_NAME1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ADD_NAME_RET:				; ...
		pop	si
		cmp	ds:comspec_flag, 0

ADD_NAME_JZ_RET:			; ...
		jz	short ADD_PROMPT_RETN
		call	scanoff
		mov	es, ds:RESSEG
		mov	di, offset ComSpec
		mov	bx, di
		xor	ax, ax
		mov	es:ComDrv, al
		push	ax
		mov	al, [si]
		call	testkanj
		pop	ax
		jnz	short _GOTDRIVE
		cmp	byte ptr [si+1], ':' ; 3Ah
		jnz	short _GOTDRIVE
		mov	al, [si]
		call	UPCONV
		sub	al, 'A'         ; 41h
		add	di, 2
		inc	al
		mov	es:ComDrv, al
		add	al, 40h		; 'A'-1

_GOTDRIVE:				; ...
		mov	es:PutBackComSpec, di
		mov	es:PutBackDrv, al
		mov	di, bx

COPY_COMSPEC:				; ...
		lodsb
		call	DELIM
		jz	short COPYDONE
		cmp	al, 0Dh		; 13
		jz	short COPYDONE
		stosb
		jmp	short COPY_COMSPEC
ADD_PROMPT	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR ADD_PROMPT

COPYDONE:				; ...
		xor	al, al
		stosb
		mov	ds:comspec_flag, 0
		dec	di
		mov	es:ComSpec_End,	di
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DISP_ENV:				; ...
		mov	ds, ds:RESSEG
		mov	ds, ds:EnvirSeg
		xor	si, si

PENVLP:					; ...
		cmp	byte ptr [si], 0
		jz	short ADD_NAME_JZ_RET
		mov	di, offset Arg_Buf

PENVLP2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short PENVLP2
		mov	dx, offset arg_buf_ptr
		push	ds
		push	es
		pop	ds
		call	Printf_Crlf
		pop	ds
		jmp	short PENVLP
; END OF FUNCTION CHUNK	FOR ADD_PROMPT

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


delete_path	proc near		; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short delete_name_in_environment
delete_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


delete_prompt	proc near		; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="

delete_name_in_environment:		; ...
		push	si
		push	ds
		call	FIND
		jb	short del1
		mov	si, di
		call	SCASB2
		xchg	si, di
		cmp	byte ptr es:[si], 0
		jnz	short not_dnull
		dec	si

not_dnull:				; ...
		call	GETENVSIZ
		sub	cx, si
		push	es
		pop	ds
		rep movsb

del1:					; ...
		pop	ds
		pop	si

find_retn:				; ...
		retn
delete_prompt	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


find_path	proc near		; ...
		mov	si, offset PATH_TEXT ; "PATH="
		jmp	short find_name_in_environment
find_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


find_prompt	proc near		; ...
		mov	si, offset PROMPT_TEXT ; "PROMPT="
find_prompt	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


find_name_in_environment proc near	; ...
		call	FIND
		jb	short find_retn
		jmp	SCASB1
find_name_in_environment endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FIND		proc near		; ...
		cld
		call	COUNT0
		mov	es, ds:RESSEG
		mov	es, es:EnvirSeg
		xor	di, di

find1:					; ...
		push	cx
		push	si
		push	di

find11:					; ...
		lodsb
		call	testkanj
		jz	short notkanj3
		dec	si
		lodsw
		inc	di
		inc	di
		cmp	ax, es:[di-2]
		jnz	short find12
		dec	cx
		loop	find11
		jmp	short find12
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj3:				; ...
		call	UPCONV
		inc	di
		cmp	al, es:[di-1]
		jnz	short find12
		loop	find11

find12:					; ...
		pop	di
		pop	si
		pop	cx
		jz	short find_retn
		push	cx
		call	SCASB2
		pop	cx
		cmp	byte ptr es:[di], 0
		jnz	short find1
		stc
		retn
FIND		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


COUNT0		proc near		; ...
		push	ds
		pop	es
		mov	di, si
		push	di
		call	SCASB1
		jmp	short COUNTX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		push	di
		call	SCASB2

COUNTX:					; ...
		pop	cx
		sub	di, cx
		xchg	di, cx

move_name_retn:				; ...
		retn
COUNT0		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


move_name	proc near		; ...
		cmp	byte ptr [si], 13 ; 0Dh
		jz	short move_name_retn
		lodsb
		call	testkanj
		jz	short notkanj1
		call	store_char
		lodsb
		call	store_char
		jmp	short move_name
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj1:				; ...
		call	UPCONV
		call	store_char
		cmp	al, '='
		jnz	short move_name

getarg_retn:				; ...
		retn
move_name	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETARG		proc near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short getarg_retn
		call	scanoff
		cmp	al, 0Dh		; 13

sdn_retn:				; ...
		retn
GETARG		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scan_double_null proc near		; ...
		mov	es, ds:RESSEG
		mov	es, es:EnvirSeg
		xor	di, di

sdn1:					; ...
		cmp	byte ptr es:[di], 0
		jz	short sdn_retn
		call	SCASB2
		jmp	short sdn1
scan_double_null endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SCASB1		proc near		; ...
		mov	al, '='
		jmp	short SCASBX
SCASB1		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SCASB2		proc near		; ...
		xor	al, al

SCASBX:					; ...
		mov	cx, 256
		repne scasb
		retn
SCASB2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


testkanj	proc near		; ...
		push	ds
		push	si
		push	ax
		mov	ds, cs:RESSEG
		lds	si, ds:Dbcs_Vector_Addr

ktlop:					; ...
		cmp	word ptr [si], 0
		jz	short notlead
		pop	ax
		push	ax
		cmp	al, [si]
		jb	short notlead
		inc	si
		cmp	al, [si]
		jbe	short islead
		inc	si
		jmp	short ktlop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notlead:				; ...
		xor	ax, ax
		jmp	short ktret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

islead:					; ...
		xor	ax, ax
		inc	ax

ktret:					; ...
		pop	ax
		pop	si
		pop	ds
		retn
testkanj	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UPCONV		proc near		; ...
		cmp	al, 80h
		jb	short oth_fucase
		sub	al, 80h
		push	ds
		push	bx
		mov	ds, ds:RESSEG
		lds	bx, dword ptr ds:FUCase_Addr+1 ;
					; lds bx,[FUCase_Addr+1]
		add	bx, 2
		xlat
		pop	bx
		pop	ds
		jmp	short upconv_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

oth_fucase:				; ...
		cmp	al, 61h	; 'a'   ; small_a
		jb	short upconv_end
		cmp	al, 7Ah	; 'z'   ; small_z
		ja	short upconv_end
		sub	al, 20h

upconv_end:				; ...
		retn
UPCONV		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


store_char	proc near		; ...
		push	cx
		push	bx
		push	es
		push	ds
		mov	ds, ds:RESSEG
		mov	es, ds:EnvirSeg
		pop	ds
		call	GETENVSIZ
		mov	bx, cx
		sub	bx, 2
		cmp	di, bx
		jb	short store1
		push	ax
		push	cx
		push	bx
		call	FREE_TPA
		pop	bx
		add	bx, 2
		cmp	bx, 8000h
		jb	short envsiz_ok

bad_env_size:				; ...
		stc
		jmp	short envnoset
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

envsiz_ok:				; ...
		mov	cl, 4
		shr	bx, cl
		inc	bx
		mov	cx, es
		add	cx, bx
		add	cx, 20h
		mov	ax, cs
		cmp	cx, ax
		jnb	short bad_env_size
		mov	ah, 4Ah
		int	21h		; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
					; ES = segment address of block	to change
					; BX = new size	in paragraphs

envnoset:				; ...
		pushf
		push	es
		mov	es, ds:RESSEG
		call	ALLOC_TPA
		pop	es
		popf
		pop	cx
		pop	ax
		jnb	short store1
		pop	es
		mov	dx, offset ENVERR_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

store1:					; ...
		stosb
		mov	word ptr es:[di], 0
		pop	es
		pop	bx
		pop	cx
		retn
store_char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETENVSIZ	proc near		; ...
		push	es
		push	ax
		mov	ax, es
		dec	ax
		mov	es, ax
		assume es:nothing
		mov	ax, es:3	; [es:ARENA.size]
		mov	cl, 4
		shl	ax, cl
		mov	cx, ax
		pop	ax
		pop	es
		assume es:nothing

getenvsiz_retn:				; ...
		retn
GETENVSIZ	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


RestUDir1	proc near		; ...
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:RestDir, 0
		pop	ds
		jz	short getenvsiz_retn

RestUDir:				; ...
		mov	dx, offset USERDIR1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xor	al, al
		call	SETREST
		retn
RestUDir1	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$CHDIR		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_CHDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0FFFFh
		jz	short bwdj
		cmp	ax, 0
		jnz	short ChDirErr
		cmp	ds:PARSE1_OUTPUT, 6 ; [PARSE1_TYPE],result_drive
		jnz	short REALCD
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr

bwdj:					; ...
		call	build_dir_for_chdir
		call	CRLF2

chdir_retn:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REALCD:					; ...
		push	si
		lds	si, ds:PARSE1_ADDR
		call	Move_To_SrcBuf
		pop	si
		mov	di, offset PARSE_CHDIR
		xor	dx, dx
		call	parse_check_eol
		jnz	short ChDirErr
		call	SETPATH
		test	ds:DestInfo, 2
		jnz	short BadChDir
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short chdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short BadChDir
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short BadChDir
		call	set_ext_error_subst
		jmp	short ChDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BadChDir:				; ...
		mov	dx, offset badcd_ptr

ChDirErr:				; ...
		call	std_eprintf

mkdir_retn:				; ...
		retn
_$CHDIR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$MKDIR		proc near		; ...
		call	SETRMMK
		jb	short MkDirErr
		mov	ah, 39h
		int	21h		; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
					; DS:DX	-> ASCIZ pathname (may include drive)
		jnb	short mkdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short MD_other_err
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badmderr
		call	set_ext_error_subst
		jmp	short MkDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badmderr:				; ...
		mov	dx, offset SRCXNAME
		mov	ah, 1Ah
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 4Eh
		mov	cx, 10h		; ATTR_DIRECTORY
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short MD_other_err
		mov	dl, ds:SRCXNAME+15h ; [SRCXNAME+FIND_BUF.ATTR] ; [SRCXNAME+21]
		test	dl, 10h
		jz	short MD_other_err
		mov	dx, offset MD_EXISTS_PTR
		jmp	short MkDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MD_other_err:				; ...
		mov	dx, offset badmkd_ptr

MkDirErr:				; ...
		call	std_eprintf

setrmmk_retn:				; ...
		retn
_$MKDIR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETRMMK		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_MRDIR
		xor	cx, cx
		xor	dx, dx
		call	Parse_With_Msg
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short noarger
		mov	di, offset SRCXNAME
		push	di
		push	si
		lds	si, ds:PARSE1_ADDR

mrdir_move_filename:			; ...
		lodsb
		stosb
		cmp	al, 0		; END_OF_LINE_OUT
		jnz	short mrdir_move_filename
		pop	si
		mov	di, offset PARSE_MRDIR
		call	parse_check_eol
		pop	dx
		jz	short setrmmk_retn

noarger:				; ...
		mov	dx, offset extend_buf_ptr
		xor	ax, ax
		stc

rmdir_retn:				; ...
		retn
SETRMMK		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


_$RMDIR		proc near		; ...
		call	SETRMMK
		jb	short RmDirErr
		jnz	short badrderr
		mov	ah, 3Ah
		int	21h		; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
					; DS:DX	-> ASCIZ pathname (may include drive)
		jnb	short rmdir_retn
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short badrderr
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short badrderr
		call	set_ext_error_subst
		jmp	short RmDirErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badrderr:				; ...
		mov	dx, offset badrmd_ptr

RmDirErr:				; ...
		call	std_eprintf

savudir_err_retn:			; ...
		retn
_$RMDIR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


set_ext_error_subst proc near		; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	ds:string_ptr_2, dx
		mov	ds:extend_buf_sub, 1 ; one_subst
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		retn
set_ext_error_subst endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SAVUDIR		proc near		; ...
		mov	di, offset USERDIR1

SAVUDIR1:				; ...
		mov	al, dl
		add	al, 40h	; '@'
		cmp	al, 40h	; '@'
		jnz	short GOTUDRV
		add	al, ds:CURDRV
		inc	al

GOTUDRV:				; ...
		stosb
		mov	ah, ds:DIRCHAR
		mov	al, ':'         ; 3Ah
		stosw
		push	es
		pop	ds
		mov	si, di
		mov	ah, 47h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		jb	short savudir_err_retn
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
SAVUDIR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CRLF2		proc near		; ...
		push	dx
		mov	dx, offset acrlf_ptr
		push	ds
		push	cs
		pop	ds
		call	std_printf
		pop	ds
		assume ds:nothing
		pop	dx
		retn
CRLF2		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scanoff		proc near		; ...
		lodsb
		call	DELIM
		jz	short scanoff
		dec	si

scanoff_retn:				; ...
		retn
scanoff		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DELIM		proc near		; ...
		cmp	al, 20h	; ' '
		jz	short scanoff_retn
		cmp	al, 3Dh	; '='
		jz	short scanoff_retn
		cmp	al, 2Ch	; ','
		jz	short scanoff_retn
		cmp	al, 3Bh	; ';'
		jz	short scanoff_retn
		cmp	al, 9
		jz	short scanoff_retn
		cmp	al, 0Ah
		retn
DELIM		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FCB_TO_ASCZ	proc near		; ...
		mov	cx, 8

MAINNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short SKIPSPC
		stosb

SKIPSPC:				; ...
		loop	MAINNAME
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		mov	ah, al
		mov	al, 2Eh	; '.'
		stosb
		xchg	al, ah
		stosb
		mov	cl, 2

EXTNAME:				; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short GOTNAME
		stosb
		loop	EXTNAME

GOTNAME:				; ...
		xor	al, al
		stosb

STRCOMP_RETN:				; ...
		retn
FCB_TO_ASCZ	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRCOMP		proc near		; ...
		cmpsb
		jnz	short STRCOMP_RETN
		cmp	byte ptr [si-1], 0
		jz	short STRCOMP_RETN
		jmp	short STRCOMP
STRCOMP		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CRPRINT		proc near		; ...
		push	ax
		mov	al, 13		; 0Dh
		push	cx
		push	di
		mov	di, dx
		mov	cx, 65535	; 0FFFFh
		push	es
		push	ds
		pop	es
		repne scasb
		mov	byte ptr [di-1], 0
		pop	es
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	byte ptr [di-1], 13 ; 0Dh
		jb	short error_output
		pop	di
		pop	cx
		pop	ax
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

error_output:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	es, RESSEG
		mov	dx, offset NOSPACE_PTR
		cmp	es:PipeFlag, 0
		jz	short go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR

go_to_error:				; ...
		jmp	cerror
CRPRINT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


pathchrcmp	proc near		; ...
		push	ax
		mov	ah, '/'         ; 2Fh
		cmp	SWITCHAR, ah
		jz	short noslasht
		cmp	al, '/'         ; 2Fh
		jz	short pccont

noslasht:				; ...
		cmp	al, '\'         ; 5Ch

pccont:					; ...
		pop	ax
		retn
pathchrcmp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PathCrunch	proc near		; ...
		mov	Msg_Numb, 0
		mov	dl, ds:5Ch	; [FCB]
		call	SAVUDIR
		jb	short pcrunch_cderrj
		call	SETPATH
		test	DestInfo, 2
		jnz	short trypeel
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short chdir_worked
		call	get_ext_error_number
		cmp	ax, 3
		jz	short trypeel
		cmp	ax, 5
		jz	short trypeel
		mov	Msg_Numb, ax
		jmp	peelfail
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chdir_worked:				; ...
		call	SetRest1
		mov	al, '?'         ; 3Fh
		mov	di, 5Dh
		mov	cx, 11
		rep stosb
		xor	al, al
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pcrunch_cderrj:				; ...
		jmp	pcrunch_cderr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

trypeel:				; ...
		mov	si, PathPos
		dec	si
		mov	al, [si-1]
		cmp	KPARSE,	0
		jnz	short delstrt
		call	pathchrcmp
		jz	short peelfail

delstrt:				; ...
		mov	cx, si
		mov	si, dx
		push	dx

delloop:				; ...
		cmp	si, cx
		jz	short gotdele
		lodsb
		call	testkanj
		jz	short notkanj8
		inc	si
		jmp	short delloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj8:				; ...
		call	pathchrcmp
		jnz	short delloop
		mov	dx, si
		dec	dx
		jmp	short delloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gotdele:				; ...
		mov	si, dx
		pop	dx
		cmp	si, dx
		jz	short badret
		mov	cx, si
		mov	si, dx

delloop2:				; ...
		cmp	si, cx
		jz	short trycd
		mov	KPARSE,	0
		lodsb
		call	testkanj
		jz	short delloop2
		inc	si
		inc	KPARSE
		jmp	short delloop2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

trycd:					; ...
		push	ax
		mov	al, 2Eh	; '.'
		cmp	[si+1],	al
		jnz	short trycd1
		cmp	[si+2],	al
		jz	short trycd1
		cmp	byte ptr [si+2], 0

trycd1:					; ...
		pop	ax
		jz	short peelfail
		mov	al, [si-1]
		cmp	al, 3Ah	; ':'
		jz	short badret
		cmp	KPARSE,	0
		jnz	short notdoublesl
		call	pathchrcmp
		jnz	short notdoublesl

peelfail:				; ...
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notdoublesl:				; ...
		mov	byte ptr [si], 0
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jnb	short cdsucc

pcrunch_cderr:				; ...
		call	get_ext_error_number
		mov	Msg_Numb, ax
		or	si, si
		stc

pcrunch_retn:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badret:					; ...
		mov	al, [si]
		call	pathchrcmp
		stc
		jnz	short pcrunch_retn
		xor	bl, bl
		xchg	bl, [si+1]
		mov	ah, 3Bh		; CHDIR
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short pcrunch_cderr
		mov	[si+1],	bl

cdsucc:					; ...
		call	SetRest1
		inc	si
		mov	DestTail, si
		pushf
		cmp	DirFlag, 0FFh	; -1
		jz	short pcrunch_end
		mov	di, 5Ch		; FCB
		mov	ax, 2902h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing

pcrunch_end:				; ...
		popf
		retn
PathCrunch	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR SWITCH

RETSW:					; ...
		xchg	ax, bx
		retn
; END OF FUNCTION CHUNK	FOR SWITCH

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SWITCH		proc near		; ...

; FUNCTION CHUNK AT 2E13 SIZE 00000002 BYTES

		xor	bx, bx

SWLOOP:					; ...
		call	scanoff
		cmp	al, SWITCHAR
		jnz	short RETSW
		or	bx, 8000h
		inc	si
		call	scanoff
		cmp	al, 0Dh
		jz	short RETSW
		inc	si
		call	UPCONV
		mov	di, offset switch_list ; "-Y?VBAPW"
		mov	cx, 8
		repne scasb
		jnz	short BADSW
		mov	ax, 1
		shl	ax, cl
		or	bx, ax
		jmp	short SWLOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADSW:					; ...
		jmp	short SWLOOP
SWITCH		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

DRVBAD:					; ...
		mov	dx, offset baddrv_ptr
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXTERNALJ:				; ...
		jmp	EXTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FNDCOM:					; ...
		or	al, al
		jz	short EXTERNALJ
		call	test_append
		jz	short CONTCOM

APPEND_INTERNAL:			; ...
		mov	cl, IDLEN
		mov	ch, 0
		mov	PathPos, cx
		inc	append_exec
		call	IOSET
		mov	si, offset IDLEN
		mov	dx, 0FFFFh	; -1
		mov	di, offset append_parse
		mov	ax, 0AE01h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- EXECUTE
					; DX = FFFFh, DS:SI -> buffer
					; Return: buffer at DS:SI filled with a	length byte followed by	the uppercase
					; internal command to execute (if length not 0)
		cmp	IDLEN, 0
		jnz	short CONTCOM
		jmp	CMD_DONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CONTCOM:				; ...
		mov	di, offset COMTAB
		xor	cx, cx

FINDCOM:				; ...
		mov	si, offset ID
		mov	cl, [di]
		inc	di
		jcxz	short EXTERNALJ
		cmp	cl, IDLEN
		jnz	short ABCD
		mov	PathPos, cx
		repe cmpsb

ABCD:					; ...
		lahf
		add	di, cx
		mov	al, [di]
		mov	CHKDRV,	al
		inc	di
		mov	bx, [di]
		inc	di
		inc	di
		mov	dx, [di]
		inc	di
		inc	di
		sahf
		jnz	short FINDCOM
		cmp	append_exec, 0
		jnz	short DONT_SET_IO
		call	IOSET

DONT_SET_IO:				; ...
		mov	ax, COMSW
		or	ax, ARGTS	; [AllSwitch]
		and	ax, 20h
		jz	short DRIVE_CHECK
		test	CHKDRV,	4
		jz	short DO_HELP
		cmp	ARG_ARGVCNT, 2	; [ARG+ARG_UNIT.argvcnt]
		jnz	short DRIVE_CHECK

DO_HELP:				; ...
		mov	si, dx
		mov	ax, 0
		push	ax

NEXT_HELP_MSG:				; ...
		lodsw
		or	ax, ax
		jz	short HELP_DONE
		push	ax
		mov	dx, sp
		call	std_printf
		pop	ax
		jmp	short NEXT_HELP_MSG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

HELP_DONE:				; ...
		pop	ax
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DRIVE_CHECK:				; ...
		test	CHKDRV,	1
		jz	short NOCHECK
		mov	al, PARM1
		or	al, PARM2
		cmp	al, 0FFh
		jnz	short NOCHECK
		jmp	DRVBAD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOCHECK:				; ...
		call	cmd_copy
		test	CHKDRV,	2	; fSwitchAllowed
		jnz	short REALWORK
		call	noswit
		jnz	short REALWORK
		mov	msg_disp_class,	2 ; parse_msg_class
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	3 ; BadSwt_Ptr
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REALWORK:				; ...
		call	bx

CMD_DONE:				; ...
		push	cs
		pop	ds
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		cmp	ds:Call_Flag, 1	; call_in_progress
		mov	ds:Call_Flag, 0
		pop	ds
		jz	short INCALL
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

INCALL:					; ...
		jmp	DOCOM0
; END OF FUNCTION CHUNK	FOR _$IF

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


noswit		proc near		; ...
		push	di
		mov	di, 81h
		mov	si, 80h
		lodsb
		mov	cl, al
		xor	ch, ch
		mov	al, cs:SWITCHAR
		cmp	al, 0
		repne scasb
		pop	di
		retn
noswit		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

EXTERNAL:				; ...
		call	test_append
		jz	short NOT_BARRYF
		jmp	APPEND_INTERNAL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOT_BARRYF:				; ...
		mov	cs:IFNOTFLAG, 0
		mov	dl, cs:SPECDRV
		mov	cs:IDLEN, dl
		mov	cs:ROM_CALL, 0
		push	dx
		mov	dx, offset IDLEN
		call	ROM_SCAN
		pop	dx
		jnb	short DO_SCAN
		inc	cs:ROM_CALL
		jmp	short $+2

DO_SCAN:				; ...
		mov	di, offset EXECPATH
		mov	byte ptr [di], 0
		cmp	cs:ROM_CALL, 0
		jnz	short EXECUTE	; NEOEXECUTE

RESEARC:
		call	path_search
		or	ax, ax
		jz	short badcomj45
		cmp	ax, 4
		jge	short EXECUTE
		jmp	BATCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

badcomj45:				; ...
		jmp	short BADCOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EXECUTE:				; ...
		call	IOSET

LH_EXECUTE:				; ...
		mov	es, ds:TRAN_TPA
		mov	ah, 49h
		int	21h		; DOS -	2+ - FREE MEMORY
					; ES = segment address of area to be freed
		mov	es, ds:RESSEG
		inc	es:ExtCom
		mov	es:RestDir, 0
		mov	si, offset EXECPATH
		mov	di, offset SafePathBuffer ; RESGROUP
		mov	cx, 80
		cld
		rep movsb
		mov	di, 5Ch		; FCB
		mov	si, di
		mov	cx, 82
		rep movsw
		mov	dx, offset SafePathBuffer
		push	es
		pop	ds
		mov	bx, offset EnvirSeg ; offset Exec_Block	= offset EnvirSeg
		mov	ax, 4B00h
		test	cs:ROM_CALL, 0FFh
		jz	short OK_EXEC
		jmp	ROM_EXEC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OK_EXEC:				; ...
		mov	cx, es
		mov	ss, cx
		mov	sp, offset RStack
		jmp	cs:EXEC_ADDR	; jmp far [cs:EXEC_ADDR]
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADCOM:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset BADNAM_PTR
; END OF FUNCTION CHUNK	FOR _$IF
; START	OF FUNCTION CHUNK FOR TESTDOREIN

cerror:					; ...
		call	std_eprintf
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR TESTDOREIN

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PRESCAN		proc near		; ...
		xor	cx, cx
		mov	es, RESSEG
		mov	si, (offset COMBUF+2)
		mov	di, si

COUNTQUOTES:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short COUNTEND
		inc	ch
		jmp	short COUNTQUOTES
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COUNTEND:				; ...
		cmp	al, 0Dh		; 13
		jnz	short COUNTQUOTES
		push	cx
		mov	si, di

KanjiScan:				; ...
		lodsb
		call	testkanj
		jz	short KanjiQuote
		mov	ah, al
		lodsb
		cmp	ax, 2020h
		jnz	short KanjiScan
		mov	word ptr [si-2], 2020h ; DB_SPACE
		jmp	short KanjiScan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KanjiQuote:				; ...
		cmp	al, 22h	; '"'
		jnz	short KanjiEnd
		dec	ch
		jz	short KanjiScan

KanjiQuoteLoop:				; ...
		lodsb
		cmp	al, 22h	; '"'
		jnz	short KanjiQuoteLoop
		dec	ch
		jmp	short KanjiScan
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KanjiEnd:				; ...
		cmp	al, 0Dh
		jnz	short KanjiScan
		pop	cx
		mov	si, di

PRESCANLP:				; ...
		lodsb
		call	testkanj
		jz	short NOTKANJ6
		mov	[di], al
		inc	di
		lodsb
		mov	[di], al
		inc	di
		inc	cl
		inc	cl
		jmp	short PRESCANLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ6:				; ...
		cmp	al, 22h	; '"'
		jnz	short TRYGREATER
		dec	ch
		jz	short TRYGREATER

QLOOP:					; ...
		mov	[di], al
		inc	di
		inc	cl
		lodsb
		cmp	al, 22h	; '"'
		jnz	short QLOOP
		dec	ch

TRYGREATER:				; ...
		cmp	al, 3Eh	; '>'   ; rabracket
		jnz	short NOOUT
		cmp	[si], al
		jnz	short NOAPPND
		lodsb
		inc	es:Re_Out_App

NOAPPND:				; ...
		call	scanoff
		cmp	al, 3Ch	; '<'   ; labracket
		jz	short REOUT_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREOFIL

REOUT_ERRSET:				; ...
		mov	byte ptr [di], 0Dh
		mov	word ptr es:Re_OutStr, 9
		jmp	PRESCANEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTREOFIL:				; ...
		push	di
		mov	di, offset Re_OutStr
		mov	bx, di
		push	es

SETREOUTSTR:				; ...
		push	cx
		mov	cx, 77		; 64+13

SETREOUTSTR_LOOP:			; ...
		lodsb
		cmp	al, 0Dh
		jz	short GOTRESTR_J
		call	DELIM
		jz	short GOTRESTR_J
		cmp	al, SWITCHAR
		jz	short GOTRESTR_J
		cmp	al, 22h	; '"'   ; quote
		jz	short PIPEERRSYNJ5_J
		cmp	al, 3Ch	; '<'   ; labracket
		jz	short ABRACKET_TERM
		cmp	al, 3Eh	; '>'   ; rabracket
		jnz	short NO_ABRACKET

ABRACKET_TERM:				; ...
		dec	si
		mov	al, 20h	; ' '

GOTRESTR_J:				; ...
		pop	cx
		jmp	short GOTRESTR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_ABRACKET:				; ...
		stosb
		loop	SETREOUTSTR_LOOP
		jmp	short GOTRESTR_J
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEERRSYNJ5_J:				; ...
		pop	cx
		jmp	short PIPEERRSYNJ5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOOUT:					; ...
		cmp	al, 3Ch	; '<'
		jnz	short CHKPIPE
		mov	bx, si
		call	scanoff
		cmp	al, 3Eh	; '>'
		jz	short REIN_ERRSET
		cmp	al, 0Dh
		jnz	short GOTREIFIL

REIN_ERRSET:				; ...
		mov	byte ptr [di], 0Dh
		mov	word ptr RE_INSTR, 9
		jmp	short PRESCANEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTREIFIL:				; ...
		push	di
		mov	di, offset RE_INSTR
		mov	bx, di
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	short SETREOUTSTR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHKPIPE:				; ...
		mov	ah, al
		cmp	ah, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE3
		cmp	ah, 7Ch	; '|'   ; vbar
		jnz	short CONTPRESCAN

ISPIPE3:				; ...
		cmp	es:PipeFlag, 0
		jnz	short NOECHOPUSH
		shl	es:EchoFlag, 1	; shl byte [es:EchoFlag],1

NOECHOPUSH:				; ...
		inc	es:PipeFlag
		call	scanoff
		cmp	al, 0Dh
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short PIPEERRSYNJ5
		cmp	al, 7Ch	; '|'   ; vbar
		jnz	short CONTPRESCAN

PIPEERRSYNJ5:				; ...
		push	es
		pop	ds
		jmp	PIPEERRSYN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOTRESTR:				; ...
		xchg	ah, al
		mov	al, 3Ah	; ':'
		sub	bx, di
		cmp	bx, 0FFFFh	; -1
		jz	short NOTRAILCOL
		cmp	es:[di-1], al
		jnz	short NOTRAILCOL
		dec	di

NOTRAILCOL:				; ...
		xor	al, al
		stosb
		pop	es
		assume es:nothing
		pop	di

CONTPRESCAN:				; ...
		mov	[di], ah
		inc	di
		cmp	ah, 0Dh
		jz	short PRESCANEND
		inc	cl
		jmp	PRESCANLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRESCANEND:				; ...
		cmp	es:PipeFlag, 0
		jz	short ISNOPIPE
		mov	di, 48Ah	; PipeStr ; RESGROUP:EndInit+160
		mov	es:488h, di	; [es:PipePtr],di
					; (RESGROUP:EndInit+158)
		mov	si, (offset COMBUF+2)
		call	scanoff

PIPESETLP:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jnz	short PIPESETLP

ISNOPIPE:				; ...
		mov	COMBUF+1, cl
		cmp	es:PipeFlag, 0
		push	cs
		pop	es
		assume es:TRANGROUP
		retn
PRESCAN		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cmd_copy	proc near		; ...
		mov	si, (offset COMBUF+2)
		call	scanoff
		add	si, PathPos
		mov	di, 81h
		xor	cx, cx

cmdcopy:				; ...
		lodsb
		stosb
		cmp	al, 0Dh
		jz	short copy_done
		inc	cx
		jmp	short cmdcopy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

copy_done:				; ...
		mov	TRANSTART+80h, cl ; mov	ds:80h,	cl
		retn
cmd_copy	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


test_append	proc near		; ...
		mov	bx, offset COMBUF
		mov	si, offset IDLEN
		mov	dx, 0FFFFh	; -1
		mov	ax, 0AE00h
		int	2Fh		; - Multiplex -	DOS 3.3+ internal - INSTALLABLE	COMMAND	- INSTALL CHECK
					; DX = FFFFh, DS:BX -> command line
					; Return: AL = FFh if this command is a	TSR extension to COMMAND.COM
					; AL = 00h if the command should be executed as	usual
		cmp	al, 0
		retn
test_append	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETPATH		proc near		; ...
		mov	ax, PathCnt
		mov	si, PathPos

GETPATH:
		mov	DestInfo, 0
		mov	DestIsDir, 0
		mov	si, PathPos
		mov	cx, PathCnt
		mov	dx, si
		jcxz	short PATHDONE
		push	cx
		push	si
		call	SWITCH
		mov	PathSw,	ax
		pop	bx
		sub	bx, si
		pop	cx
		add	cx, bx
		mov	dx, si

SKIPPATH:				; ...
		mov	KPARSE,	0

SKIPPATH2:				; ...
		jcxz	short PATHDONE
		dec	cx
		lodsb
		call	testkanj
		jz	short TESTPPSEP
		dec	cx
		inc	si
		inc	KPARSE
		jmp	short SKIPPATH2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTPPSEP:				; ...
		call	pathchrcmp
		jnz	short TESTPMETA
		inc	DestIsDir

TESTPMETA:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short TESTPSTAR
		or	DestInfo, 2

TESTPSTAR:				; ...
		cmp	al, 2Ah	; '*'
		jnz	short TESTPDELIM
		or	DestInfo, 2

TESTPDELIM:				; ...
		call	DELIM
		jz	short PATHDONEDEC
		cmp	al, SWITCHAR
		jnz	short SKIPPATH

PATHDONEDEC:				; ...
		dec	si

PATHDONE:				; ...
		xor	al, al
		xchg	al, [si]
		inc	si
		cmp	al, 0Dh
		jnz	short NOPSTORE
		mov	[si], al

NOPSTORE:				; ...
		mov	PathPos, si
		mov	PathCnt, cx

SETPATH_RETN:				; ...
		retn
SETPATH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PGETARG		proc near		; ...
		mov	si, 80h
		lodsb
		or	al, al
		jz	short SETPATH_RETN
		call	PSCANOFF
		cmp	al, 0Dh
		retn
PGETARG		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PSCANOFF	proc near		; ...
		lodsb
		call	DELIM
		jnz	short PSCANOFFD
		cmp	al, ';'         ; 3Bh
		jnz	short PSCANOFF

PSCANOFFD:				; ...
		dec	si
		retn
PSCANOFF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


IOSET		proc near		; ...
		push	ds
		push	dx
		push	ax
		push	bx
		push	cx
		mov	ds, cs:RESSEG
		assume ds:nothing
		cmp	ds:PipeFlag, 0
		jnz	short NOREDIR
		test	ds:IfFlag, 0FFh
		jnz	short NOREDIR
		call	TESTDOREIN
		call	TESTDOREOUT

NOREDIR:				; ...
		pop	cx
		pop	bx
		pop	ax
		pop	dx
		pop	ds

IOSET_RETN:				; ...
		retn
IOSET		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TESTDOREIN	proc near		; ...

; FUNCTION CHUNK AT 2FF5 SIZE 00000006 BYTES

		cmp	cs:RE_INSTR, 0
		jz	short IOSET_RETN
		push	ds
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	dx, offset RE_INSTR
		mov	ax, 3D00h	; OPEN*256
		mov	bx, ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read
		pop	ds
		assume ds:nothing
		jb	short REDIRERR
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:18h,	al	; [PDB.JFN_TABLE]
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REDIRERR:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		call	TriageError
		cmp	ax, 65
		jz	short _CERRORJ
		cmp	bh, 3Dh		; OPEN
		jz	short OpenError
		mov	dx, offset FULLDIR_PTR

_CERRORJ:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OpenError:				; ...
		mov	cs:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	cs:extend_buf_ptr, ax
		jmp	cerror
TESTDOREIN	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TESTDOREOUT	proc near		; ...
		cmp	ds:Re_OutStr, 0
		jnz	short REOUTEXISTS
		jmp	NOREOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REOUTEXISTS:				; ...
		cmp	ds:Re_Out_App, 0
		jz	short REOUTCRT
		mov	dx, offset Re_OutStr
		mov	ax, 3D02h
		push	ax
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 2 - read & write
		pop	bx
		jb	short OpenWriteError
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		test	dl, 80h
		jnz	short SET_REOUT
		mov	ax, 4202h
		mov	cx, 0FFFFh	; -1
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		push	cs
		pop	ds
		mov	ax, 3F00h
		mov	cx, 1
		mov	dx, offset One_Char_Val
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		jb	short OpenWriteError
		cmp	ax, cx
		jnz	short reout_0_length
		cmp	One_Char_Val, 1Ah
		mov	ds, RESSEG
		assume ds:nothing
		jnz	short SET_REOUT
		mov	ax, 4201h
		mov	cx, 0FFFFh
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		jmp	short SET_REOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

reout_0_length:				; ...
		mov	ds, cs:RESSEG
		mov	ax, 4200h
		xor	cx, cx
		mov	dx, cx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		jmp	short SET_REOUT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OpenWriteError:				; ...
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		stc
		jnz	short REOUTCRT
		jmp	REDIRERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

REOUTCRT:				; ...
		mov	dx, offset Re_OutStr
		xor	cx, cx
		mov	ah, 3Ch
		push	ax
		int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
					; CX = attributes for file
					; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	bx
		jnb	short NOREDIRERR
		jmp	REDIRERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOREDIRERR:				; ...
		mov	bx, ax

SET_REOUT:				; ...
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:19h,	al	; mov [PDB.JFN_TABLE+1],al

NOREOUT:				; ...
		retn
TESTDOREOUT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


dstrlen		proc near		; ...
		push	ax
		xor	cx, cx
		cld

dloop:					; ...
		lodsb
		inc	cx
		or	al, al
		jnz	short dloop
		sub	si, cx
		pop	ax

TRIAGEERR_RETN:				; ...
		retn
dstrlen		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TriageError	proc near		; ...
		jnb	short TRIAGEERR_RETN
		pushf
		push	bx
		push	cx
		push	si
		push	di
		push	bp
		push	es
		push	ds
		push	ax
		push	dx
		mov	ah, 59h
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		pop	cx
		pop	bx
		mov	dx, offset ACCDEN_PTR
		cmp	ax, 65
		jz	short NoMove
		mov	ax, bx
		mov	dx, cx

NoMove:					; ...
		pop	ds
		pop	es
		assume es:nothing
		pop	bp
		pop	di
		pop	si
		pop	cx
		pop	bx
		popf
		retn
TriageError	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Triage_Init:				; ...
		call	TriageError
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Move_To_SrcBuf	proc near		; ...
		push	si
		push	di
		push	cx
		mov	di, offset SrcBuf
		xor	cx, cx
		mov	ax, cx
		push	di
		lodsb

mts_get_chars:				; ...
		cmp	al, 0
		jz	short mts_end_string
		stosb
		inc	cx
		lodsb
		jmp	short mts_get_chars
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

mts_end_string:				; ...
		mov	al, 0Dh
		stosb
		pop	di
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	PathCnt, cx
		mov	PathPos, di
		pop	cx
		pop	di
		pop	si
		retn
Move_To_SrcBuf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SINGLETEST	proc near		; ...
		push	ds
		mov	ds, cs:RESSEG
		assume ds:nothing
		cmp	ds:SingleCom, 0
		jz	short TESTDONE
		cmp	ds:SingleCom, 0EFFFh

TESTDONE:				; ...
		pop	ds
		retn
SINGLETEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetRest1	proc near		; ...
		mov	al, 1
SetRest1	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETREST		proc near		; ...
		push	ds
		mov	ds, ds:RESSEG
		mov	ds:RestDir, al
		pop	ds
		retn
SETREST		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PIPEDEL		proc near		; ...
		push	ds
		push	dx
		mov	ds, cs:RESSEG
		mov	dx, 3EAh	; offset Pipe1 = offset	RESGROUP:EndInit
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	dx, 439h	; offset Pipe2 = offset	RESGROUP:EndInit+79
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		pop	dx
		call	PipeOff
		mov	ds:PipeFiles, 0
		pop	ds
		retn
PIPEDEL		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR _$IF

PIPEERRSYN:				; ...
		mov	dx, offset SYNTMES_PTR
		call	PIPEDEL
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPERR:					; ...
		pushf
		call	TriageError
		push	ax
		push	dx
		mov	dx, offset PIPEEMES_PTR
		call	PIPEDEL
		push	cs
		pop	ds
		call	std_eprintf
		pop	dx
		pop	ax
		popf
		cmp	ax, 65
		jnz	short TCOMMANDJ
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TCOMMANDJ:				; ...
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEPROCSTRT:				; ...
		mov	ds, RESSEG
		assume ds:nothing
		inc	ds:PipeFiles
		push	es
		push	di
		push	ds
		push	si
		push	ds
		push	es
		pop	ds
		mov	si, offset TempVarName ; "TEMP="
		call	find_name_in_environment
		pop	ds
		jb	short no_temp_path
		push	ds
		push	es
		pop	ds
		pop	es
		mov	si, di
		call	skip_white
		call	copy_pipe_path
		push	es
		pop	ds
		mov	dx, offset EndInit ; offset DATARES:Pipe1 = RESGROUP:EndInit
		mov	ax, 4300h
		int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
					; DS:DX	-> ASCIZ file name or directory
					; name without trailing	slash
		jb	short no_temp_path
		test	cx, 10h
		jnz	short no_temp_path
		stc

no_temp_path:				; ...
		pop	si
		pop	ds
		pop	di
		pop	es
		jnb	short crt_temp
		mov	ah, '.'         ; 2Eh
		mov	ds:3EAh, ah	; offset DATARES:Pipe1 = RESGROUP:EndInit
		mov	ds:439h, ah	; offset DATARES:Pipe2 = RESGROUP:EndInit+79
		xor	ah, ah
		mov	ds:3EBh, ah	; offset DATARES:Pipe1+1 = RESGROUP:EndInit+1
		mov	ds:43Ah, ah	; offset DATARES:Pipe2+1 = RESGROUP:EndInit+80

crt_temp:				; ...
		mov	dx, 3EAh	; offset DATARES:Pipe1 = offset	RESGROUP:EndInit
		xor	cx, cx
		mov	ah, 5Ah
		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
					; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
					; receive generated filename
					; CX = file attributes (only bits 0,1,2,5 may be set)
		jnb	short pps0
		jmp	short PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pps0:					; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		mov	dx, 439h	; offset DATARES:Pipe2 = offset	RESGROUP:EndInit+79
		mov	ah, 5Ah
		int	21h		; DOS -	3+ - CREATE UNIQUE FILE
					; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
					; receive generated filename
					; CX = file attributes (only bits 0,1,2,5 may be set)
		jnb	short pps1
		jmp	PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pps1:					; ...
		mov	bx, ax
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		call	TESTDOREIN
		mov	si, ds:488h	; offset DATARES:PipePtr = offset RESGROUP:EndInit+158
		cmp	ds:SingleCom, 0FFFFh ; -1
		jnz	short NOSINGP
		mov	ds:SingleCom, 0F000h

NOSINGP:				; ...
		jmp	short FIRSTPIPE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEPROC:				; ...
		and	ds:EchoFlag, 0FEh
		mov	si, ds:488h	; offset DATARES:PipePtr = offset RESGROUP:EndInit+158
		lodsb
		cmp	al, 7Ch	; '|'   ; ALTPIPECHR
		jz	short ISPIPE1
		cmp	al, 7Ch	; '|'   ; vbar
		jz	short ISPIPE1
		jmp	PIPEEND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ISPIPE1:				; ...
		mov	dx, ds:InPipePtr
		mov	ax, 3D00h
		int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
					; DS:DX	-> ASCIZ filename
					; AL = access mode
					; 0 - read

PIPEERRJ:				; ...
		jnb	short NO_PIPEERR
		jmp	PIPERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_PIPEERR:				; ...
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:18h,	al	; [PDB.JFN_TABLE],al  ;	Redirect

FIRSTPIPE:				; ...
		mov	di, (offset COMBUF+2)
		xor	cx, cx
		cmp	byte ptr [si], 0Dh ; '|<CR>'
		jnz	short PIPEOK1

PIPEERRSYNJ:				; ...
		jmp	PIPEERRSYN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEOK1:				; ...
		mov	al, 7Ch	; '|'
		cmp	[si], al
		jz	short PIPEERRSYNJ
		cmp	byte ptr [si], 7Ch ; '|'
		jz	short PIPEERRSYNJ

PIPECOMLP:				; ...
		lodsb
		stosb
		call	testkanj
		jz	short NOTKANJ5
		movsb
		inc	cx
		inc	cx
		jmp	short PIPECOMLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ5:				; ...
		cmp	al, 0Dh
		jz	short LASTPIPE
		inc	cx
		cmp	al, 7Ch	; '|'
		jz	short ISPIPE2
		cmp	al, 7Ch	; '|'
		jnz	short PIPECOMLP

ISPIPE2:				; ...
		mov	byte ptr es:[di-1], 0Dh
		dec	cx
		mov	es:COMBUF+1, cl
		dec	si
		mov	ds:488h, si	; [PipePtr] = [EndInit+158]
		mov	dx, ds:OutPipePtr
		push	cx
		xor	cx, cx
		mov	ax, 3C00h
		int	21h		; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
					; CX = attributes for file
					; DS:DX	-> ASCIZ filename (may include drive and path)
		pop	cx
		jb	short PIPEERRJ
		mov	bx, ax
		mov	al, 0FFh
		xchg	al, [bx+18h]	; [bx+PDB.JFN_TABLE]
		mov	ds:19h,	al	; [PDB.JFN_TABLE+1]
		xchg	dx, ds:InPipePtr
		mov	ds:OutPipePtr, dx
		jmp	short PIPECOM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LASTPIPE:				; ...
		mov	es:COMBUF+1, cl
		dec	si
		mov	ds:488h, si	; [PipePtr] = [EndInit+158]
		call	TESTDOREOUT

PIPECOM:				; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP
		jmp	NOPIPEPROC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PIPEEND:				; ...
		call	PIPEDEL
		cmp	ds:SingleCom, 0F000h
		jnz	short NOSINGP2
		mov	ds:SingleCom, 0FFFFh ; -1

NOSINGP2:				; ...
		jmp	TCOMMAND
; END OF FUNCTION CHUNK	FOR _$IF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DATINIT:				; ...
		mov	cs:RESSEG, ds
		push	es
		push	ds
		mov	ax, cs
		mov	es, ax
		assume es:TRANGROUP
		mov	ds, ax
		assume ds:nothing
		call	TSYSLOADMSG
		mov	dx, offset STACK ; mov dx, offset INTERNATVARS
		mov	ax, 3800h
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		mov	word ptr ds:81h, 0Dh
		mov	ds:COMBUF, 128
		mov	word ptr ds:COMBUF+1, 0D01h
		call	DATE
		call	CTIME
		pop	ds
		pop	es
		assume es:nothing
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DATE		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh
		jz	short PRMTDAT
		cmp	ax, 0
		jnz	short DATERR
		jmp	short COMDAT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRMTDAT:				; ...
		call	GetDate
		xchg	dh, dl
		mov	ds:CurDat_yr, cx
		mov	ds:CurDat_mo_day, dx
		mov	dx, offset CurDat_Ptr
		call	std_printf

GET_NEW_DATE:				; ...
		call	GETDAT
		cmp	ax, 0FFFFh	; END_OF_LINE (-1)
		jz	short date_end
		cmp	ax, 0
		jnz	short DATERR

COMDAT:					; ...
		mov	cx, ds:DATE_YEAR
		mov	dh, ds:DATE_MONTH
		mov	dl, ds:DATE_DAY
		push	cx
		push	dx
		mov	cx, 1
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh	; END_OF_LINE (-1)
		pop	dx
		pop	cx
		jnz	short DATERR
		mov	ah, 2Bh
		int	21h		; DOS -	SET CURRENT DATE
					; DL = day, DH = month,	CX = year
					; Return: AL = 00h if no error /= FFh if bad value sent	to routine
		or	al, al
		jnz	short DATERR

date_end:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DATERR:					; ...
		call	CRLF2
		mov	dx, offset BADDAT_PTR
		call	std_printf
		jmp	short GET_NEW_DATE
DATE		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CTIME		proc near		; ...
		mov	si, 81h
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jz	short PRMTTIM
		cmp	ax, 0		; RESULT_NO_ERROR
		jnz	short TIMERR
		jmp	short COMTIM
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRMTTIM:				; ...
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		xchg	ch, cl
		xchg	dh, dl
		mov	ds:CurTim_hr_min, cx
		mov	ds:CurTim_Sec_hn, dx
		mov	dx, offset CurTim_Ptr
		call	std_printf

GET_NEW_TIME:				; ...
		call	GETTIM
		cmp	ax, 0FFFFh	; -1 ; END_OF_LINE
		jz	short time_end
		cmp	ax, 0		; 0 ; RESULT_NO_ERROR
		jnz	short TIMERR

COMTIM:					; ...
		mov	ch, ds:TIME_HOUR
		mov	cl, ds:TIME_MINUTES
		mov	dh, ds:TIME_SECONDS
		mov	dl, ds:TIME_FRACTION
		push	cx
		push	dx
		mov	cx, 1
		xor	dx, dx
		call	cmd_parse
		cmp	al, 0FFh	; -1 ; END_OF_LINE
		pop	dx
		pop	cx
		jnz	short TIMERR
		mov	ah, 2Dh
		int	21h		; DOS -	SET CURRENT TIME
					; CH = hours, CL = minutes, DH = seconds, DL = hundredths of seconds
					; Return: AL = 00h if no error / = FFh if bad value sent to routine
		or	al, al
		jnz	short TIMERR

time_end:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TIMERR:					; ...
		call	CRLF2
		mov	dx, offset BadTim_Ptr
		call	std_printf
		jmp	short GET_NEW_TIME
CTIME		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetInitFlag	proc near		; ...
		mov	ds, ds:RESSEG
		and	ds:InitFlag, 0FDh ; ~INITSPECIAL ; NOT INITSPECIAL
		or	ds:InitFlag, cl
		push	cs
		pop	ds
		assume ds:TRANGROUP
		retn
SetInitFlag	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PipeOff		proc near		; ...
		push	ds
		push	ax
		mov	ds, cs:RESSEG
		assume ds:nothing
		xor	al, al
		xchg	al, ds:PipeFlag
		or	al, al
		jz	short PipeOffDone
		shr	ds:EchoFlag, 1

PipeOffDone:				; ...
		pop	ax
		pop	ds
		retn
PipeOff		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_TIME:				; ...
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		push	es
		push	cs
		pop	es
		assume es:TRANGROUP
		xchg	ch, cl
		xchg	dh, dl
		mov	cs:PromTim_hr_min, cx
		mov	cs:PromTim_Sec_hn, dx
		mov	dx, offset promtim_ptr
		call	std_printf
		pop	es
		assume es:nothing
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETDAT		proc near		; ...
		mov	ax, 3800h
		mov	dx, 5Ch
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		mov	si, dx
		lodsw
		mov	dx, cs:usadat_Ptr
		dec	ax
		js	short printformat
		mov	dx, cs:eurdat_ptr
		jz	short printformat
		mov	dx, cs:japdat_ptr

printformat:				; ...
		mov	ax, dx
		mov	dh, 0FFh	; util_msg_class
		call	TSYSGETMSG
		mov	cs:NewDat_Format, si
		mov	dx, offset NewDat_Ptr
		call	std_printf
		mov	cs:NewDat_Format, 0
		mov	ah, 0Ah		; STD_CON_STRING_INPUT
		mov	dx, offset COMBUF
		mov	cx, 2		; INITSPECIAL
		call	SetInitFlag
		int	21h		; DOS -
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_DATE
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
GETDAT		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GETTIM		proc near		; ...
		xor	cx, cx
		mov	dx, offset NewTim_Ptr
		call	std_printf
		mov	ah, 0Ah		; STD_CON_STRING_INPUT
		mov	dx, offset COMBUF
		mov	cx, 2		; INITSPECIAL
		call	SetInitFlag
		int	21h		; DOS -
		xor	cx, cx
		call	SetInitFlag
		call	CRLF2
		mov	si, (offset COMBUF+2)
		mov	di, offset PARSE_TIME
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		retn
GETTIM		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


skip_white	proc near		; ...
		cld

skw_lp:					; ...
		lodsb
		cmp	al, 20h	; ' '
		jz	short skw_lp
		cmp	al, 9
		jz	short skw_lp
		dec	si
		retn
skip_white	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


copy_pipe_path	proc near		; ...
		mov	cx, 0FFFFh	; 65535
		xor	al, al
		mov	di, si
		push	es
		push	ds
		pop	es
		cld
		push	di
		repne scasb
		pop	di
		pop	es
		not	cx
		mov	di, 3EAh	; offset DATARES:Pipe1
					; (offset RESGROUP:EndINit)
		push	di
		push	cx
		rep movsb
		pop	cx
		pop	di
		push	ds
		push	es
		pop	ds
		mov	si, di
		mov	di, 439h	; offset DATARES:Pipe2
					; (offset RESGROUP:EndINit+79)
		rep movsb
		pop	ds
		retn
copy_pipe_path	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PARSELINE	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	ds:cpyflag, 0
		mov	ds:LASTARG, 0FFFFh
		xor	ax, ax
		mov	cx, 1348	; ARG_UNIT.SIZE
		mov	di, offset ARG_ARGV ; offset ARG
		rep stosb
		mov	ds:ARGBUF_PTR, offset ARG_ARGBUF ; ARG+ARG_UNIT.argbuf
		mov	ds:ARG_ARGSWINFO, 0 ; [ARG+ARG_UNIT.argswinfo]
		mov	ds:ARG_ARGVCNT,	0 ; [ARG+ARG_UNIT.argvcnt]
		mov	si, (offset COMBUF+2)
		push	ds
		mov	ds, ds:RESSEG
		cmp	ds:ForFlag, 0
		pop	ds
		jnz	short PCONT
		mov	di, offset ARG_ARGFORCOMBUF ; ARG+ARG_UNIT.argforcombuf
		xor	ch, ch
		mov	cl, ds:COMBUF+1
		inc	cl
		rep movsb
		mov	si, offset ARG_ARGFORCOMBUF

PCONT:					; ...
		mov	di, offset TPBUF
		mov	bl, 20h	; ' '

PARSELOOP:				; ...
		mov	ds:COMPTR, si
		xor	bp, bp
		mov	ds:expand_star,	0
		call	scanoff
		call	cparse
		jnb	short MORE_PRSE
		or	bp, bp
		jz	short PARSEDONE
		call	newarg
		jmp	short PARSEDONE
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MORE_PRSE:				; ...
		mov	ds:cpyflag, 2
		call	newarg
		jnb	short PARSELOOP
		jmp	short PARSE_ERROR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PARSEDONE:				; ...
		popf
		clc
		jmp	short PARSE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PARSE_ERROR:				; ...
		popf
		stc

PARSE_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
PARSELINE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


newarg		proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	arg_switch
		cmp	ds:ARG_ARGVCNT,	64 ; cmp [ARG+ARG_UNIT.argvcnt],ARGMAX
		jge	short to_many_args
		mov	dh, bh
		mov	bx, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		inc	ds:ARG_ARGVCNT
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv
		call	argv_calc
		mov	word ptr [bx+7], 0 ; [bx+ARGV_ELE.argsw_word]
		mov	[bx+5],	cx	; [bx+ARGV_ELE.arglen]
		mov	[bx+2],	dh	; [bx+ARGV_ELE.argflags]
		mov	si, ds:ARGBUF_PTR
		mov	[bx], si	; [bx+ARGV_ELE.argpointer]
		add	si, ds:STARTEL
		sub	si, di
		mov	[bx+3],	si	; [bx+ARGV_ELE.argstartel]
		mov	si, ds:COMPTR
		mov	[bx+9],	si	; [bx+ARGV_ELE.arg_ocomptr]
		mov	si, di
		mov	di, ds:ARGBUF_PTR
		add	di, cx
		cmp	di, (offset ARG_ARGBUF+0FFh) ; ARG+ARG_UNIT.argbuf+ARGBLEN-1
		jge	short buf_oflow
		sub	di, cx
		cld
		rep movsb
		mov	al, 0		; ANULL
		stosb
		mov	ds:ARGBUF_PTR, di
		popf
		clc
		jmp	short newarg_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

to_many_args:				; ...
		mov	ax, 1
		jmp	short newarg_error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

buf_oflow:				; ...
		mov	ax, 2

newarg_error:				; ...
		popf
		stc

newarg_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
newarg		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


arg_switch	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	di
		pushf
		test	bh, 1
		jz	short arg_no_switch0
		cmp	ds:LASTARG, 0FFFFh ; -1
		jz	short arg_no_switch1
		mov	bx, ds:LASTARG
		mov	ax, offset ARG_ARGV ; ARG+ARG_UNIT.argv	; ARG+0
		call	argv_calc
		or	[bx+7],	bp	; [bx+ARGV_ELE.argsw_word]
		or	ds:ARG_ARGSWINFO, bp ; [ARG+ARG_UNIT.argswinfo]
		popf
		stc
		jmp	short arg_switch_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

arg_no_switch0:				; ...
		mov	ax, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		mov	ds:LASTARG, ax

arg_no_switch1:				; ...
		popf
		clc

arg_switch_exit:			; ...
		pop	di
		pop	cx
		pop	bx
		pop	ax
		retn
arg_switch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


argv_calc	proc near		; ...
		push	ax
		mov	al, bl
		mov	bl, 11		; ARGV_ELE.SIZE
		mul	bl
		pop	bx
		add	ax, bx
		xchg	ax, bx
		retn
argv_calc	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


path_search	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	si
		push	di
		push	bp
		pushf
		test	ds:ARGV0_ARG_FLAGS, 3 ;	[ARG+ARGV_ELE.argflags],wildcard+sw_flag
		jz	short path_search_ok

path_failure_jmp:			; ...
		jmp	path_failure
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_search_ok:				; ...
		call	STORE_PCHAR
		mov	dx, offset FBUF
		mov	ax, 1A00h
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		push	es
		call	find_path
		mov	ds:pathinfo, es	; [pathinfo+0]
		mov	ds:pathinfo+2, di
		mov	ds:pathinfo+4, di
		pop	es
		mov	bx, 128		; PBUFLEN
		mov	si, offset EXECPATH
		call	STRIP
		jb	short path_failure_jmp
		mov	dx, si
		mov	ds:search_error, offset	baddrv_ptr
		call	PSEARCH
		or	ax, ax
		jz	short path_noinit
		mov	bp, ax
		mov	di, offset EXECPATH
		mov	si, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		mov	cx, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		sub	cx, si
		mov	ah, ':'
		cmp	cx, 2
		jb	short adddrive
		cmp	[si+1],	ah
		jz	short movedrive

adddrive:				; ...
		mov	al, ds:CURDRV
		add	al, 'A'
		stosw
		jmp	short checkpath
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

movedrive:				; ...
		lodsw
		stosw
		sub	cx, 2

checkpath:				; ...
		or	al, 20h
		mov	dl, al
		sub	dl, 60h		; 'a'-1
		mov	al, ds:psep_char
		stosb
		cmp	cx, 1
		jb	short addpath
		lodsb
		dec	cx
		cmp	al, ds:psep_char
		jz	short movepath
		inc	cx
		dec	si

addpath:				; ...
		push	si
		mov	si, di
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		mov	di, si
		pop	si
		mov	al, ds:psep_char
		cmp	byte ptr [di], 0
		jz	short movepath

scanend:				; ...
		cmp	byte ptr [di], 0
		jz	short foundend
		inc	di
		jmp	short scanend
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

foundend:				; ...
		stosb

movepath:				; ...
		cmp	[si], al
		jnz	short copypath
		inc	si
		dec	cx

copypath:				; ...
		jcxz	short _copydone
		rep movsb

_copydone:				; ...
		jmp	path_success
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_noinit:				; ...
		test	ds:ARGV0_ARG_FLAGS, 4 ;	[ARG+ARGV_ELE.argflags],path_sep
		jnz	short path_failure
		mov	bh, ';'
		mov	dx, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		sub	dx, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		add	dx, offset EXECPATH

path_loop:				; ...
		call	path_crunch
		mov	bp, ax
		lahf
		or	bp, bp
		jnz	short path_found
		sahf
		jnb	short path_loop

path_failure:				; ...
		xor	ax, ax
		jmp	path_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_found:				; ...
		mov	di, offset EXECPATH
		mov	cx, ds:pathinfo+4
		mov	si, ds:pathinfo+2
		push	es
		push	ds:pathinfo	; [pathinfo+0]
		pop	es
		cmp	byte ptr es:[si+2], 2Eh	; '.'
		jnz	short path_cpy
		cmp	byte ptr es:[si+1], 3Ah	; ':'
		jnz	short path_cpy
		push	cx
		mov	al, es:[si]
		mov	[di], al
		mov	al, es:[si+1]
		mov	[di+1],	al
		mov	al, ds:psep_char
		mov	[di+2],	al
		push	si
		mov	dl, es:[si]
		or	dl, 20h
		sub	dl, 60h		; 'a'-1
		mov	si, di
		add	si, 3
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		call	dstrlen
		add	si, cx
		dec	si
		mov	di, si
		pop	si
		add	si, 3
		pop	cx

path_cpy:				; ...
		pop	es
		sub	cx, si
		push	ds
		push	ds:pathinfo	; [pathinfo+0]
		pop	ds
		cld

kloop:					; ...
		lodsb
		stosb
		call	testkanj
		jz	short notkanj1
		dec	cx
		jcxz	short popdone
		movsb
		dec	cx
		cmp	cx, 1
		ja	short kloop

popdone:				; ...
		pop	ds
		mov	al, ds:psep_char
		jmp	short path_store
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

notkanj1:				; ...
		loop	kloop
		pop	ds
		dec	di
		mov	al, ds:psep_char
		cmp	al, [di-1]
		jz	short path_success

path_store:				; ...
		stosb

path_success:				; ...
		mov	si, offset search_best_buf
		xor	cx, cx

path_succ_loop:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short path_succ_loop
		mov	ax, bp

path_exit:				; ...
		popf
		pop	bp
		pop	di
		pop	si
		pop	dx
		pop	cx
		pop	bx
		retn
path_search	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STORE_PCHAR	proc near		; ...
		push	ax
		mov	al, 2Fh	; '/'
		call	pathchrcmp
		jz	short STORE_SLASH
		mov	al, 5Ch	; '\'
		mov	ds:psep_char, al
		pop	ax
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

STORE_SLASH:				; ...
		mov	ds:psep_char, al
		pop	ax
		retn
STORE_PCHAR	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


path_crunch	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		call	STORE_PCHAR
		mov	di, offset TPBUF
		mov	si, ds:pathinfo+4
		mov	ds:pathinfo+2, si
		push	ds
		push	ds:pathinfo	; [pathinfo+0]
		pop	ds
		xor	cl, cl

path_cr_copy:				; ...
		lodsb
		or	al, al
		jz	short path_seg
		cmp	al, bh
		jz	short path_seg
		call	testkanj
		jz	short _notkanj2
		stosb
		movsb
		mov	cl, 1
		jmp	short path_cr_copy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_notkanj2:				; ...
		xor	cl, cl
		stosb
		jmp	short path_cr_copy
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_seg:				; ...
		pop	ds
		mov	ds:pathinfo+4, si
		mov	bl, al
		xor	ax, ax
		cmp	di, offset TPBUF
		jz	short path_cr_leave

path_cr_look:
		mov	al, ds:psep_char
		or	cl, cl
		jnz	short path_cr_store
		cmp	al, [di-1]
		jz	short path_cr_l1

path_cr_store:				; ...
		stosb

path_cr_l1:				; ...
		mov	si, dx

path_cr_l2:				; ...
		lodsb
		stosb
		or	al, al
		jnz	short path_cr_l2
		mov	dx, offset TPBUF
		mov	ds:search_error, offset	BADPMES_PTR
		call	PSEARCH

path_cr_leave:				; ...
		or	bl, bl
		jz	short path_cr_empty
		popf
		clc
		jmp	short path_cr_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

path_cr_empty:				; ...
		popf
		stc

path_cr_exit:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
path_crunch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


PSEARCH		proc near		; ...
		push	cx
		push	dx
		push	di
		push	si
		pushf
		push	dx
		mov	di, dx
		mov	si, offset search_curdir_buf
		xor	dx, dx
		cmp	byte ptr [di+1], 3Ah ; ':'
		jnz	short SEARCH_DIR_CHECK
		mov	dl, [di]
		and	dl, 0DFh	; ~20h	; uppercase
		sub	dl, 40h	; '@'   ; convert to drive number

SEARCH_DIR_CHECK:			; ...
		mov	ax, 4700h
		int	21h		; DOS -	2+ - GET CURRENT DIRECTORY
					; DL = drive (0=default, 1=A, etc.)
					; DS:SI	points to 64-byte buffer area
		pop	dx
		jb	short SEARCH_INVALID_DRIVE
		mov	cx, 13h		; search_attr
		mov	ax, 4E00h
		int	21h		; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
					; CX = search attributes
					; DS:DX	-> ASCIZ filespec
					; (drive, path,	and wildcards allowed)
		jb	short SEARCH_NO_FILE
		mov	ds:search_best,	0 ; SEARCH_FILE_NOT_FOUND ; 0
		mov	ds:search_best_buf, 0 ;	ANULL ;	0

SEARCH_LOOP:				; ...
		call	SEARCH_FTYPE
		cmp	al, ds:search_best
		jle	short SEARCH_NEXT
		mov	ds:search_best,	al
		mov	si, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME
		mov	di, offset search_best_buf
		mov	cx, 13		; FNAME_MAX_LEN
		cld
		rep movsb
		cmp	al, 8		; SEARCH_COM
		jz	short SEARCH_DONE

SEARCH_NEXT:				; ...
		mov	cx, 13h		; SEARCH_ATTR
		mov	ax, 4F00h
		int	21h		; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
					; [DTA]	= data block from
					; last AH = 4Eh/4Fh call
		jnb	short SEARCH_LOOP

SEARCH_DONE:				; ...
		mov	al, ds:search_best
		cmp	ds:ext_entered,	1
		jz	short SEARCH_EXIT
		mov	al, ds:ext_entered
		mov	ds:search_best,	al
		jmp	short SEARCH_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SEARCH_INVALID_DRIVE:			; ...
		mov	dx, ds:search_error
		call	std_printf

SEARCH_NO_FILE:				; ...
		mov	ax, 0

SEARCH_EXIT:				; ...
		popf
		pop	si
		pop	di
		pop	dx
		pop	cx
		retn
PSEARCH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCH_FTYPE	proc near		; ...
		push	di
		push	si
		mov	ax, 0
		mov	di, (offset FBUF+1Eh) ;	FBUF+FIND_BUF.PNAME
		mov	cx, 13		; FNAME_MAX_LEN
		cld
		repne scasb
		jnz	short FTYPE_EXIT
		sub	di, 5
		mov	si, offset comext ; ".COM"
		mov	ax, di
		cmpsw
		jnz	short FTYPE_EXE
		cmpsw
		jnz	short FTYPE_EXE
		mov	ax, 8		; SEARCH_COM
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_EXE:				; ...
		mov	di, ax
		mov	si, offset exeext ; ".EXE"
		cmpsw
		jnz	short FTYPE_BAT
		cmpsw
		jnz	short FTYPE_BAT
		mov	ax, 4		; SEARCH_EXE
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_BAT:				; ...
		mov	di, ax
		mov	si, offset batext ; ".BAT"
		cmpsw
		jnz	short FTYPE_FAIL
		cmpsw
		jnz	short FTYPE_FAIL
		mov	ax, 2		; SEARCH_BAT
		jmp	short FTYPE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FTYPE_FAIL:				; ...
		mov	ax, 0

FTYPE_EXIT:				; ...
		cmp	ds:ext_entered,	1
		jz	short FTYPE_DONE
		cmp	ax, 0		; ANULL
		jz	short FTYPE_DONE
		mov	ds:ext_entered,	al
		mov	ax, 8		; SEARCH_COM

FTYPE_DONE:				; ...
		pop	si
		pop	di
		retn
SEARCH_FTYPE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


STRIP		proc near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		pushf
		mov	ds:ext_entered,	1
		mov	dx, ds:ARG_ARGV	; [ARG+ARGV_ELE.argpointer]
		mov	di, ds:ARGV0_ARGSTARTEL	; [ARG+ARGV_ELE.argstartel]
		cmp	byte ptr [di], 0
		jz	short STRIP_ERROR
		mov	cx, dx
		add	cx, ds:ARGV0_ARGLEN ; [ARG+ARGV_ELE.arglen]
		sub	cx, di
		inc	cx
		mov	al, 2Eh	; '.'
		cld
		repne scasb
		jcxz	short PROCESS_EXT
		mov	ds:ext_entered,	0
		mov	al, 0
		repne scasb

PROCESS_EXT:				; ...
		mov	cx, di
		sub	cx, dx
		sub	bx, 4
		cmp	cx, bx
		jg	short STRIP_ERROR
		mov	di, si
		mov	si, dx
		cld
		rep movsb
		cmp	ds:ext_entered,	1
		jnz	short SKIP_WILDS
		dec	di
		stosb
		mov	al, 3Fh	; '?'
		stosb
		stosb
		stosb
		mov	al, 0
		stosb

SKIP_WILDS:				; ...
		popf
		clc
		jmp	short STRIP_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

STRIP_ERROR:				; ...
		popf
		stc

STRIP_EXIT:				; ...
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
STRIP		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SAVE_ARGS	proc near		; ...
		push	bx
		push	cx
		push	dx
		push	di
		push	si
		push	bp
		pushf
		add	bx, 1363	; ARG_UNIT.SIZE+15
		mov	cl, 4
		shr	bx, cl
		mov	ax, 4800h
		int	21h		; DOS -	2+ - ALLOCATE MEMORY
					; BX = number of 16-byte paragraphs desired
		jb	short SAVE_ERROR
		mov	bp, ax
		push	es
		mov	es, ax
		assume es:nothing
		mov	cx, 1348	; ARG_UNIT.SIZE
		xor	di, di
		mov	si, offset ARG_ARGV ; offset ARG
		rep movsb
		mov	cx, ds:ARG_ARGVCNT ; [ARG+ARG_UNIT.argvcnt]
		xor	ax, ax
		mov	si, offset ARG_ARGV ; offset ARG

SAVE_PTR_LOOP:				; ...
		dec	cx
		jl	short SAVE_DONE
		mov	bx, cx
		call	argv_calc
		mov	dx, ds:ARG_ARGV[bx] ; [ARG+ARGV_ELE.argpointer+bx]
		sub	dx, si
		mov	es:[bx], dx
		mov	dx, ds:ARGV0_ARGSTARTEL[bx] ; [ARG+ARGV_ELE.argstartel+bx]
		sub	dx, si
		mov	es:[bx+3], dx	; [es:bx+ARGV_ELE.argstartel]
		mov	dx, ds:ARGV0_OCOMPTR[bx] ; [ARG+ARGV_ELE.arg_ocomptr+bx]
		sub	dx, si
		mov	es:[bx+9], dx	; [es:bx+ARGV_ELE.arg_ocomptr]
		jmp	short SAVE_PTR_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_DONE:				; ...
		pop	es
		assume es:nothing
		mov	ax, bp
		jmp	short SAVE_OK
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_ERROR:				; ...
		popf
		stc
		jmp	short SAVE_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SAVE_OK:				; ...
		popf
		clc

SAVE_EXIT:				; ...
		pop	bp
		pop	si
		pop	di
		pop	dx
		pop	cx
		pop	bx
		retn
SAVE_ARGS	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR ERASE

notest2:				; ...
		mov	cx, 11
		mov	si, 5Dh		; FCB+1

ambspec:				; ...
		lodsb
		cmp	al, '?'
		jnz	short allfil
		loop	ambspec

allfil:					; ...
		cmp	cx, 0
		jnz	short noprmpt

askagn:					; ...
		mov	dx, offset SureMes_Ptr
		call	std_printf
		mov	si, 80h
		mov	dx, si
		mov	word ptr [si], 120
		mov	ax, 0C0Ah
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		lodsw
		or	ah, ah
		jz	short askagn
		call	scanoff
		call	char_in_xlat
		jnb	short check_yn

answ_no:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

check_yn:				; ...
		cmp	al, 0		; NO character
		jz	short answ_no
		cmp	al, 1		; YES character
		pushf
		call	CRLF2
		popf
		jnz	short askagn

noprmpt:				; ...
		mov	ah, 13h
		mov	dx, 5Ch		; FCB
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jz	short eraerr
		call	RestUDir
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

eraerr:					; ...
		call	Set_Ext_Error_Msg
		push	dx
		call	RestUDir
		pop	dx
		cmp	ds:extend_buf_ptr, 18 ;	ERROR_NO_MORE_FILES
		jnz	short cerrorj2
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND

cerrorj2:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slashp_erase:				; ...
		call	build_dir_string
		mov	ah, 1Ah
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 11h
		mov	dx, 5Ch
		int	21h		; DOS -	SEARCH FIRST USING FCB
					; DS:DX	-> FCB
		inc	al
		jz	short eraerr

delete_prompt_loop:			; ...
		mov	si, (offset DESTDIR+1)
		mov	di, offset DEST
		mov	al, ds:DIRCHAR
		stosb
		call	FCB_TO_ASCZ

slashp_askagn:				; ...
		call	CRLF2
		mov	dx, offset BWDBUF
		mov	bx, dx
		cmp	byte ptr [bx+3], 0 ; END_OF_LINE_OUT
		jnz	short not_del_root
		mov	byte ptr [bx+2], 0

not_del_root:				; ...
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset DEST
		mov	ds:string_ptr_2, dx
		mov	dx, offset string_buf_ptr
		call	std_printf
		mov	dx, offset Del_Y_N_Ptr
		call	std_printf
		mov	ax, 0C01h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		call	char_in_xlat
		jnb	short slashp_check_yn
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slashp_check_yn:			; ...
		cmp	al, 0		; NO character
		jz	short next_del_file
		cmp	al, 1		; YES character
		jz	short delete_this_file
		jmp	short slashp_askagn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

delete_this_file:			; ...
		mov	ah, 13h
		mov	dx, offset DESTDIR
		int	21h		; DOS -	DELETE FILE via	FCB
					; DS:DX	-> FCB with filename field filled with
					; template for	deletion ('?' wildcard allowed, but not '*')
					; Return: AL = 00h file	found, FFh file	not found
		inc	al
		jnz	short next_del_file
		call	get_ext_error_number
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short stop_del
		call	CRLF2
		call	Set_Ext_Error_Msg
		call	std_eprintf
		jmp	short next_del_file
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

stop_del:				; ...
		jmp	eraerr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

next_del_file:				; ...
		mov	ah, 1Ah
		mov	dx, offset DESTDIR
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		mov	ah, 12h
		mov	dx, 5Ch
		int	21h		; DOS -	SEARCH NEXT USING FCB
					; DS:DX	-> FCB
					; Return: AL = status
		inc	al
		jz	short slash_p_exit
		jmp	delete_prompt_loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

slash_p_exit:				; ...
		call	get_ext_error_number
		cmp	ax, 18		; ERROR_NO_MORE_FILES
		jz	short good_erase_exit
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_erase_exit:			; ...
		call	RestUDir
		call	CRLF2
		retn
; END OF FUNCTION CHUNK	FOR ERASE

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ECHO		proc near		; ...

; FUNCTION CHUNK AT 3D88 SIZE 00000021 BYTES

		call	ON_OFF
		jb	short DOEMES
		mov	ds, ds:RESSEG
		jnz	short ECH_OFF
		or	ds:EchoFlag, 1
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ECH_OFF:				; ...
		and	ds:EchoFlag, 0FEh
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CERRORJ:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOEMES:					; ...
		cmp	cl, 0
		jz	short PECHO
		mov	dx, 82h
		call	CRPRINT
		jmp	CRLF2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PECHO:					; ...
		mov	ds, ds:RESSEG
		mov	bl, ds:EchoFlag
		push	cs
		pop	ds
		assume ds:TRANGROUP
		and	bl, 1
		mov	dx, offset EchoMes_Ptr
		jmp	short PYN
ECHO		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CNTRLC		proc near		; ...
		call	ON_OFF
		mov	ax, 3301h	; (SET_CTRL_C_TRAPPING<<8)|1
		jb	short PCNTRLC
		jnz	short CNTRLC_OFF
		mov	dl, 1
		int	21h		; DOS -	EXTENDED CONTROL-BREAK CHECKING
					; AL = 00h get state / 01h set state / 02h set AND get
					; DL = 00h for OFF or 01h for ON
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CNTRLC_OFF:				; ...
		xor	dl, dl
		int	21h		; DOS -
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PCNTRLC:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		xor	al, al
		int	21h		; DOS -
		mov	bl, dl
		mov	dx, offset CtrlcMes_Ptr
CNTRLC		endp

; START	OF FUNCTION CHUNK FOR ECHO

PYN:					; ...
		mov	si, offset ONMES_PTR
		or	bl, bl
		jnz	short PRINTVAL
		mov	si, offset OFFMES_PTR

PRINTVAL:				; ...
		push	dx
		mov	bx, dx
		lodsw
		mov	dh, 0FFh	; util_msg_class ; -1
		call	TSYSGETMSG
		add	bx, 5		; Ptr_off_pos
		mov	[bx], si
		pop	dx
		call	std_printf
		mov	word ptr [bx], 0
		retn
; END OF FUNCTION CHUNK	FOR ECHO

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


VERIFY		proc near		; ...
		call	ON_OFF
		mov	ax, 2E01h	; (SET_VERIFY_ON_WRITE<<8)|1
		jb	short PVERIFY
		jnz	short VER_OFF
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

VER_OFF:				; ...
		dec	al
		int	21h		; DOS -
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PVERIFY:				; ...
		cmp	cl, 0
		jnz	short CERRORJ
		mov	ah, 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		mov	bl, al
		mov	dx, offset VeriMes_Ptr
		jmp	short PYN
VERIFY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ON_OFF		proc near		; ...
		mov	si, 81h

scan_on_off:				; ...
		lodsb
		cmp	al, 20h	; ' '   ; blank
		jz	short scan_on_off
		cmp	al, 9		; tab_chr
		jz	short scan_on_off
		cmp	al, 3Dh	; '='   ; equal_chr
		jz	short parse_on_off
		dec	si

parse_on_off:				; ...
		mov	di, offset PARSE_BREAK
		xor	cx, cx
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE ;	-1
		jz	short BADONF
		cmp	ax, 0
		jz	short on_off_there
		mov	cx, ax
		jmp	short BADONF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

on_off_there:				; ...
		cmp	PARSE1_CODE, 0FFh ; -1
		jnz	short good_on_off
		mov	cx, 0Ah		; BadParm_Ptr
		jmp	short BADONF
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

good_on_off:				; ...
		xor	ax, ax
		or	al, PARSE1_CODE
		pushf
		mov	di, offset PARSE_BREAK
		xor	dx, dx
		call	cmd_parse
		cmp	ax, 0FFFFh	; END_OF_LINE
		jnz	short BADONF_flag
		popf
		clc
		jmp	short on_off_end
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADONF_flag:				; ...
		mov	cx, ax
		popf

BADONF:					; ...
		mov	dx, offset bad_on_off_ptr
		stc

on_off_end:				; ...
		retn
ON_OFF		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PRINT_DATE:				; ...
		push	es
		push	di
		push	cs
		pop	es
		assume es:TRANGROUP
		call	GetDate
		xchg	dh, dl
		mov	promptDat_yr, cx
		mov	promptDat_moday, dx
		mov	dx, offset promptdat_ptr
		call	std_printf
		pop	di
		pop	es
		assume es:nothing
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetDate		proc near		; ...
		mov	di, offset Arg_Buf
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		cbw
		push	cx
		push	dx
		mov	si, ax
		shl	si, 1
		add	si, ax		; SI=AX*3
		mov	cx, si
		mov	ax, WeekTab
		mov	dh, 0FFh	; util_msg_class
		push	di
		call	TSYSGETMSG
		pop	di
		add	si, cx
		mov	cx, 3
		rep movsb
		mov	al, 0		; END_OF_LINE_OUT
		stosb
		pop	dx
		pop	cx
		retn
GetDate		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


char_in_xlat	proc near		; ...
		mov	dl, al
		xor	dh, dh
		mov	ax, 6523h	; (GetExtCntry<<8)+35
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		retn
char_in_xlat	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


COPY		proc near		; ...

; FUNCTION CHUNK AT 40F3 SIZE 00000037 BYTES
; FUNCTION CHUNK AT 4151 SIZE 000001C7 BYTES

		xor	ax, ax
		mov	Copy_num, ax
		mov	SRCPT, ax
		mov	SrcTail, ax
		mov	CFLAG, al
		mov	NXTADD,	ax
		mov	ARG2S, ax	; [DestSwitch]
		mov	STARTEL, ax
		mov	DestTail, ax
		mov	SPECDRV, al	; [DestClosed]
		mov	DestSiz, al
		mov	SrcSiz,	al
		mov	DestInfo, al
		mov	SrcInfo, al
		mov	INEXACT, al
		mov	DestIsDir, al	; [DestVars]
		mov	SrcIsDir, al	; [SrcVars]
		mov	USERDIR1, al
		mov	NOWRITE, al
		mov	IFNOTFLAG, al	; [RDEOF]
		mov	SRCHAND, ax
		mov	CPDATE,	ax
		mov	CPTIME,	ax
		mov	SRCISDEV, al
		mov	OCtrlZ,	al
		mov	OFilePtr_Lo, ax
		mov	OFilePtr_Hi, ax
		mov	TERMREAD, al
		mov	comma, al
		mov	plus_comma, al
		mov	msg_flag, al
		mov	ARGTS, ax	; [AllSwitch]
		mov	PARM2, al	; [ArgC]
		mov	PLUS, al
		mov	BINARY,	al
		mov	ASCII, al
		mov	FileCnt, ax
		mov	WRITTEN, ax
		mov	PARM1, al	; [Concat]
		mov	MELCOPY, al
		mov	MELSTART, ax
		mov	cox_dest_file, al ; MSDOS 6.22
		mov	cox_src_file, al
		mov	word ptr ScanBuf, ax
		mov	word ptr DestBuf, ax
		mov	word ptr SrcBuf, ax
		mov	word ptr SDIRBUF, ax
		mov	BWDBUF,	ax	; [DIRBUF]
		mov	word ptr DESTDIR, ax ; [DestFcb]
		mov	ObjCnt,	al
		dec	ax		; -1
		mov	EndDestBuf, ax	; [DESTHAND]
		mov	FRSTSRCH, al
		mov	FIRSTDEST, al
		mov	DestIsDir, al
		call	init_copycmd_option
		mov	si, 81h
		mov	bl, '+'
		inc	expand_star
		mov	cpyflag, 1

DESTSCAN:				; ...
		xor	bp, bp
		mov	di, offset ScanBuf
		mov	parse_last, si
		call	cparse
		pushf
		inc	ObjCnt
		test	bh, 80h		; no "+" delimiter
		jz	short NOCOPY
		mov	PLUS, 1

NOCOPY:					; ...
		test	bh, 1
		jnz	short CHK_CP_SWITCH
		jmp	TESTP2		; not a	switch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHK_CP_SWITCH:				; ...
		test	bp, 10h		; SwitchV
					; Verify requested?
		jz	short NOT_SLASHV
		test	ARGTS, 10h	; test word [AllSwitch],SwitchV
					; Verify already entered?
		jz	short NOT_SLASHV
		or	bp, 4000h	; FBadSwitch
					; Set up bad switch

NOT_SLASHV:				; ...
		test	bp, 40h		; negative Y (-Y) switch flag
		jz	short CHK_SLASHY0
		test	ARGTS, 40h	; [AllSwitch] negative (-Y) flag
		jnz	short NOT_SLASHY1 ; N flag
		test	ARGTS, 80h	; [AllSwitch] SwitchY (Y) flag
		jz	short NOT_SLASHY2

NOT_SLASHY1:				; ...
		or	bp, 4000h	; FBadSwitch (Repetitive)
					; Set up bad switch

NOT_SLASHY2:				; ...
		mov	cox_y_override,	0 ; cox_y setting will be used

CHK_SLASHY0:				; ...
		test	bp, 80h
		jz	short CHK_SLASHY4 ; not	a /Y switch
		mov	al, [si]
		cmp	al, 'y'
		jz	short CHK_SLASHY1
		cmp	al, 'Y'
		jz	short CHK_SLASHY1
		or	bp, 4000h	; FBadSwitch
					; Set up bad switch
		jmp	short CHK_SLASHY4
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHK_SLASHY1:				; ...
		mov	byte ptr [si], 20h ; ' '
		inc	si
		test	ARGTS, 40h	; [AllSwitch] negative (-Y) flag
		jnz	short CHK_SLASHY2 ; N flag
		test	ARGTS, 80h	; [AllSwitch] SwitchY (Y) flag
		jz	short CHK_SLASHY3

CHK_SLASHY2:				; ...
		or	bp, 4000h	; FBadSwitch (Repetitive)
					; Set up bad switch

CHK_SLASHY3:				; ...
		mov	cox_y_override,	1

CHK_SLASHY4:				; ...
		or	ARG2S, bp	; set [DestSwitch] SwitchY flag	to 1
		or	ARGTS, bp	; set [AllSwitch] SwitchY flag to 1
		test	bp, 7F23h	; ~SwitchCopy ;	not SwitchCopy
		jz	short NOT_BAD_SWITCH
		popf
		mov	ax, 3		; BadSwt_Ptr
		call	setup_parse_error_msg
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOT_BAD_SWITCH:				; ...
		popf
		jb	short CHECKDONE
		jmp	DESTSCAN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTP2:					; ...
		popf
		jb	short CHECKDONE
		test	bh, 80h
		jnz	short GOTPLUS
		inc	PARM2		; inc byte [ArgC]

GOTPLUS:				; ...
		push	si
		mov	ax, STARTEL
		mov	si, offset ScanBuf
		sub	ax, si
		mov	di, offset DestBuf
		add	ax, di
		mov	DestTail, ax
		mov	DestSiz, cl
		inc	cx
		rep movsb
		mov	DestInfo, bh
		mov	ARG2S, 0	; [DestSwitch]
		pop	si
		jmp	DESTSCAN
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKDONE:				; ...
		cmp	PLUS, 1
		jnz	short CDCONT
		cmp	PARM2, 1	; [ArgC]
		jnz	short CDCONT
		cmp	ObjCnt,	2
		jnz	short CDCONT
		mov	dx, offset OVERWR_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CDCONT:					; ...
		mov	al, PLUS
		mov	PARM1, al	; [Concat]
		shl	al, 1
		shl	al, 1
		mov	INEXACT, al
		mov	al, PARM2	; [ArgC]
		or	al, al
		jnz	short TRY_TOO_MANY
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	2 ; LessArgs_Ptr
		jmp	short CERROR_PARSEJ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TRY_TOO_MANY:				; ...
		cmp	al, 2
		jbe	short ACOUNTOK
		mov	dx, offset extend_buf_ptr
		mov	extend_buf_ptr,	1 ; MoreArgs_Ptr

CERROR_PARSEJ:				; ...
		mov	msg_disp_class,	2 ; parse_msg_class

CERROR4J:				; ...
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ACOUNTOK:				; ...
		mov	bp, offset DestIsDir ; offset DestVars
		cmp	al, 1
		jnz	short GOT2ARGS
		mov	al, CURDRV
		add	al, 'A'
		mov	ah, ':'
		mov	byte ptr [bp+1], 2 ; [bp+VARSTRUC.SIZ]
		mov	di, offset DestBuf
		stosw
		mov	ARG2S, 0	; [DestSwitch]
		mov	byte ptr [bp+4], 2 ; [bp+VARSTRUC.INFO]
		mov	byte ptr [bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		call	SETSTARS

GOT2ARGS:				; ...
		cmp	byte ptr [bp+1], 2
		jnz	short NOTSHORTDEST
		mov	al, ':'         ; 3Ah
		cmp	DestBuf+1, al
		jnz	short NOTSHORTDEST
		or	byte ptr [bp+4], 2
		mov	di, (offset DestBuf+2)
		mov	byte ptr [bp+0], 0
		call	SETSTARS

NOTSHORTDEST:				; ...
		mov	di, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	byte ptr [di], 0
		jnz	short CHKSWTCHES
		mov	dx, offset badcd_ptr
		mov	al, ':'
		cmp	[di-2],	al
		jnz	short CERROR4J
		mov	byte ptr [bp+0], 2
		or	byte ptr [bp+4], 6
		call	SETSTARS

CHKSWTCHES:				; ...
		mov	ax, ARGTS
		test	ax, 10h		; SwitchV
		jz	short NOVERIF
		mov	ah, 54h
		int	21h		; DOS -	2+ - GET VERIFY	FLAG
					; Return: AL = 00h if flag OFF
					; AL = 01h if flag ON
		push	ds
		mov	ds, RESSEG
		assume ds:nothing
		xor	ah, ah
		mov	ds:VerVal, ax
		pop	ds
		mov	ax, 2E01h
		int	21h		; DOS -	SET VERIFY FLAG
					; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off

NOVERIF:				; ...
		xor	bp, bp
		mov	si, 81h
		mov	bl, '+'         ; plus_chr ; 2Bh

SCANFSRC:				; ...
		mov	di, offset ScanBuf
		call	cparse
		test	bh, 1
		jnz	short SCANFSRC
		or	ds:ARG2S, bp	; [DestSwitch]
		test	bp, 8
		jnz	short NOSETCASC
		cmp	ds:PARM1, 0	; [Concat]
		jz	short NOSETCASC
		mov	ds:ASCII, 4	; SWITCHA

NOSETCASC:				; ...
		call	SOURCE_SET
		call	FRSTSRC
		jmp	FIRSTENT
COPY		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR COPY

ENDCOPY:				; ...
		call	CLOSEDEST

ENDCOPY2:				; ...
		mov	dx, offset copied_ptr
		mov	si, ds:FileCnt
		mov	ds:Copy_num, si
		call	std_printf
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SRCNONEXIST:				; ...
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short NEXTSRC
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, 2 ; ERROR_FILE_NOT_FOUND
		mov	ds:string_ptr_2, offset	SrcBuf
		mov	ds:extend_buf_sub, 1 ; one_subst
		jmp	COPYERR
; END OF FUNCTION CHUNK	FOR COPY

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SOURCEPROC	proc near		; ...
		call	SOURCE_SET
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short LEAVECFLAG
SOURCEPROC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FRSTSRC		proc near		; ...
		xor	ax, ax
		mov	ds:CFLAG, al
		mov	ds:NXTADD, ax
		mov	ds:SPECDRV, al	; [DestClosed]

LEAVECFLAG:				; ...
		mov	ds:SRCPT, si
		mov	di, offset USERDIR1
		mov	bp, offset SrcIsDir ; offset SrcVars
		call	BUILDPATH
		mov	si, ds:SrcTail
		retn
FRSTSRC		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR COPY

NEXTSRC:				; ...
		cmp	ds:PLUS, 0
		jnz	short MORECP

ENDCOPYJ2:				; ...
		jmp	short ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MORECP:					; ...
		xor	bp, bp
		mov	si, ds:SRCPT
		mov	bl, '+'

SCANSRC:				; ...
		mov	di, offset ScanBuf
		call	cparse
		jb	short ENDCOPYJ2
		test	bh, 80h
		jz	short ENDCOPYJ2
		test	bh, 1
		jnz	short SCANSRC
		call	SOURCEPROC
		cmp	ds:comma, 1
		jnz	short NOSTAMP
		mov	ds:plus_comma, 1
		jmp	short SRCNONEXIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOSTAMP:				; ...
		mov	ds:plus_comma, 0

FIRSTENT:				; ...
		mov	di, 5Ch		; FCB
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte ptr [si], 0
		jnz	short SRCHDONE
		mov	ax, word ptr ds:SrcBuf
		cmp	ah, ':'
		jz	short DRVSPEC1
		mov	al, 40h	; '@'

DRVSPEC1:				; ...
		or	al, 20h
		sub	al, 60h
		mov	ds:5Ch,	al	; mov [FCB],al
		mov	ah, 11h		; DIR_SEARCH_FIRST
		call	SEARCH

SRCHDONE:				; ...
		pushf
		call	RestUDir1
		popf
		jz	short NEXTAMBIG0
		jmp	SRCNONEXIST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTAMBIG0:				; ...
		xor	al, al
		xchg	al, ds:FRSTSRCH
		or	al, al
		jz	short NEXTAMBIG

SETNMEL:				; ...
		mov	cx, 12
		mov	di, offset SDIRBUF
		mov	si, offset BWDBUF ; offset DIRBUF
		rep movsb

NEXTAMBIG:				; ...
		xor	al, al
		mov	ds:NOWRITE, al
		mov	di, ds:SrcTail
		mov	si, (offset BWDBUF+1) ;	offset DIRBUF+1
		call	FCB_TO_ASCZ

MELDO0:					; ...
		cmp	ds:cox_y_override, 0 ; /Y switch override (question) enabled ?
		jz	short MELDO	; no
		call	BUILDDEST
		mov	si, offset SrcBuf
		mov	di, offset SRCXNAME
		mov	ah, 60h		; xNameTrans
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		call	COMPNAME
		jnz	short MELDO1	; different file names
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short MELDO1	; concatenating
		mov	dx, offset file_name_ptr
		call	std_printf
		call	CRLF2
		mov	dx, offset OVERWR_PTR ;	"File cannot be	copied onto itself"
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MELDO1:					; ...
		cmp	ds:CFLAG, 0	; destination file created flag
		jnz	short MELDO	; yes, new (created) file
					; no, overwrite	question (must be confirmed)
		call	get_answer_YNA
		jb	short MELDO2	; answer is no
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short MELDO
		cmp	ds:cox_dest_file, 0 ; is there a (valid) target	file ?
		jnz	short DOREAD	; yes
		jmp	short MELDO	; no, destination/target file does not exist
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MELDO2:					; ...
		cmp	ds:MELCOPY, 0	; is 'Mel Hallerman copy' false ?
		jnz	short MELDO3	; no (,	it is true)
		cmp	ds:PARM1, 0	; [Concat]
		jz	short MELDO4

MELDO3:					; ...
		mov	ds:SPECDRV, 1	; [DestClosed]
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MELDO4:					; ...
		call	SEARCHNEXT
		jz	short NEXTAMBIG
		cmp	ds:cox_src_file, 0
		jz	short MELDO5
		jmp	NEXTSRC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MELDO5:					; ...
		mov	ds:SPECDRV, 1	; [DestClosed]
		jmp	NEXTSRC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MELDO:					; ...
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short SHOWCPNAM
		test	ds:SrcInfo, 2
		jz	short DOREAD

SHOWCPNAM:				; ...
		mov	dx, offset file_name_ptr
		call	std_printf
		call	CRLF2

DOREAD:					; ...
		call	DOCOPY
		cmp	ds:PARM1, 0	; [Concat]
		jnz	short NODCLOSE
		call	CLOSEDEST
		jb	short NODCLOSE
		mov	ds:CFLAG, 0	; clear	new file (created) flag

NODCLOSE:				; ...
		cmp	ds:PARM1, 0	; [Concat]
		jz	short NOFLUSH
		call	FlshFil
		test	ds:MELCOPY, 0FFh
		jz	short NOFLUSH
		jmp	short DOMELCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOFLUSH:				; ...
		call	SEARCHNEXT
		jnz	short NEXTSRCJ
		mov	ds:SPECDRV, 0	; [DestClosed]
		jmp	NEXTAMBIG
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DOMELCOPY:				; ...
		cmp	ds:MELCOPY, 0FFh
		jz	short CONTMEL
		mov	si, ds:SRCPT
		mov	ds:MELSTART, si
		mov	ds:MELCOPY, 0FFh

CONTMEL:				; ...
		xor	bp, bp
		mov	si, ds:SRCPT
		mov	bl, '+'         ; 2Bh

SCANSRC2:				; ...
		mov	di, offset ScanBuf
		call	cparse
		test	bh, 80h
		jz	short NEXTMEL
		test	bh, 1
		jnz	short SCANSRC2
		call	SOURCEPROC
		call	RestUDir1
		mov	di, offset IDLEN ; offset DESTFCB2
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		mov	bx, (offset SDIRBUF+1)
		mov	si, offset ID	; offset DESTFCB2+1
		mov	di, ds:SrcTail
		call	BUILDNAME
		cmp	ds:PARM1, 0	; [Concat]
		jz	short MELDOJ
		mov	ds:NOWRITE, 0

MELDOJ:					; ...
		jmp	MELDO0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTSRCJ:				; ...
		jmp	NEXTSRC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NEXTMEL:				; ...
		call	CLOSEDEST
		xor	ax, ax
		mov	ds:CFLAG, al
		mov	ds:NXTADD, ax
		mov	ds:SPECDRV, al
		mov	si, ds:MELSTART
		mov	ds:SRCPT, si
		call	SEARCHNEXT
		jz	short SETNMELJ
		jmp	ENDCOPY2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SETNMELJ:				; ...
		jmp	SETNMEL
; END OF FUNCTION CHUNK	FOR COPY

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCHNEXT	proc near		; ...
		mov	ah, 12h		; DIR_SEARCH_NEXT
		test	ds:SrcInfo, 2
		jnz	short SEARCH
		or	ah, ah
		retn
SEARCHNEXT	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SEARCH		proc near		; ...
		push	ax
		mov	ah, 1Ah
		mov	dx, offset BWDBUF
		int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
					; DS:DX	-> disk	transfer buffer
		pop	ax
		mov	dx, 5Ch
		int	21h		; DOS -
		or	al, al
		retn
SEARCH		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DOCOPY		proc near		; ...
		mov	si, offset SrcBuf
		mov	di, offset SRCXNAME
		mov	ah, 60h
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	ds:IFNOTFLAG, 0	; [RDEOF]
		mov	ax, 6C00h
		mov	bx, 40h
		xor	cx, cx
		mov	dx, 101h
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short OPENOK

loc_6A33:
		jmp	short Error_On_Source
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

OPENOK:					; ...
		mov	bx, ax
		mov	ds:SRCHAND, bx
		mov	ax, 5700h
		int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
					; BX = file handle
		jb	short Error_On_Source
		mov	ds:CPDATE, dx
		mov	ds:CPTIME, cx
		jmp	short No_Copy_Xa
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Error_On_Source:			; ...
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	SrcBuf
		mov	ds:extend_buf_sub, 1
		call	std_eprintf
		cmp	ds:SRCHAND, 0
		jz	short No_Close_Src
		call	CLOSESRC

No_Close_Src:				; ...
		cmp	ds:CFLAG, 0
		jz	short EndCopyJ3
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

EndCopyJ3:				; ...
		jmp	ENDCOPY2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

No_Copy_Xa:				; ...
		mov	bx, ds:SRCHAND
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		and	dl, 80h
		mov	ds:SRCISDEV, dl
		jz	short COPYLP
		cmp	ds:BINARY, 0
		jz	short COPYLP
		mov	dx, offset INBDEV_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPYLP:					; ...
		mov	bx, ds:SRCHAND
		mov	cx, ds:BYTCNT
		mov	dx, ds:NXTADD
		sub	cx, dx
		jnz	short GOTROOM
		call	FlshFil
		cmp	ds:TERMREAD, 0
		jnz	short CLOSESRC
		mov	cx, ds:BYTCNT

GOTROOM:				; ...
		push	ds
		mov	ds, ds:TPA
		mov	ah, 3Fh
		int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
					; BX = file handle, CX = number	of bytes to read
					; DS:DX	-> buffer
		pop	ds
		jb	short Error_On_Source
		mov	cx, ax
		jcxz	short CLOSESRC
		cmp	ds:SRCISDEV, 0
		jnz	short NOTESTA
		cmp	ds:ASCII, 0
		jz	short BINREAD

NOTESTA:				; ...
		mov	dx, cx
		mov	di, ds:NXTADD
		mov	al, 1Ah
		push	es
		mov	es, ds:TPA
		repne scasb
		pop	es
		jnz	short USEALL
		inc	ds:IFNOTFLAG	; inc byte [RDEOF]
		inc	cx

USEALL:					; ...
		sub	dx, cx
		mov	cx, dx

BINREAD:				; ...
		add	cx, ds:NXTADD
		mov	ds:NXTADD, cx
		cmp	cx, ds:BYTCNT
		jb	short TESTDEV
		call	FlshFil
		cmp	ds:TERMREAD, 0
		jnz	short CLOSESRC
		jmp	short COPYLP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

TESTDEV:				; ...
		cmp	ds:SRCISDEV, 0
		jz	short CLOSESRC
		cmp	ds:IFNOTFLAG, 0	; cmp byte [RDEOF],0
		jz	short COPYLP
DOCOPY		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CLOSESRC	proc near		; ...
		mov	bx, ds:SRCHAND
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

CLOSESRCDEST_RETN:			; ...
		retn
CLOSESRC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CLOSEDEST	proc near		; ...

; FUNCTION CHUNK AT 4511 SIZE 00000012 BYTES

		cmp	ds:SPECDRV, 0	; byte [DestClosed]
		jnz	short CLOSESRCDEST_RETN
		mov	al, byte ptr ds:ARG2S ;	byte [DestSwitch]
		call	SETASC
		jz	short BINCLOS
		mov	bx, ds:NXTADD
		call	TRYFLUSH
		jz	short NOCONC

CONCHNG:				; ...
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOCONC:					; ...
		xor	bx, bx
		push	ds
		mov	ds, ds:TPA
		mov	word ptr [bx], 1Ah ; EOF mark (ctrl-Z)
		pop	ds
		inc	ds:NXTADD
		mov	ds:NOWRITE, 0
		mov	ax, ds:WRITTEN
		add	ax, ds:NXTADD
		jb	short BINCLOS
		cmp	ax, 1
		jz	short FORGETITJ

BINCLOS:				; ...
		call	TRYFLUSH
		jnz	short CONCHNG
		cmp	ds:WRITTEN, 0

FORGETITJ:				; ...
		jnz	short NO_FORGET
		jmp	FORGETIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NO_FORGET:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		mov	cx, ds:CPTIME
		mov	dx, ds:CPDATE
		cmp	ds:INEXACT, 0
		jz	short DODCLOSE
		mov	ah, 2Ch
		int	21h		; DOS -	GET CURRENT TIME
					; Return: CH = hours, CL = minutes, DH = seconds
					; DL = hundredths of seconds
		shl	cl, 1
		shl	cl, 1
		shl	cx, 1
		shl	cx, 1
		shl	cx, 1
		shr	dh, 1
		or	cl, dh
		push	cx
		mov	ah, 2Ah
		int	21h		; DOS -	GET CURRENT DATE
					; Return: DL = day, DH = month,	CX = year
					; AL = day of the week (0=Sunday, 1=Monday, etc.)
		sub	cx, 1980
		xchg	ch, cl
		shl	cx, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		shl	dh, 1
		adc	ch, 0
		or	dl, dh
		mov	dh, ch
		pop	cx
CLOSEDEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DODCLOSE	proc near		; ...
		cmp	bx, 0
		jle	short CLOSEDONE
		mov	ax, 5701h
		int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
					; BX = file handle, CX = time to be set
					; DX = date to be set
		jb	short Cleanup_Err
		mov	ax, 4202h
		xor	dx, dx
		mov	cx, dx
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from end of file
		or	dx, ax
		pushf
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		push	dx
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		pop	dx
		jnb	short Close_Cont
		popf

Cleanup_Err:				; ...
		call	CleanUpErr
		call	DestDelete
		jmp	short FILECLOSED
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Close_Cont:				; ...
		popf
		jnz	short CLOSEDONE
		test	dx, 80h
		jnz	short CLOSEDONE
		call	DestDelete
		jmp	short FILECLOSED
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CLOSEDONE:				; ...
		inc	ds:FileCnt

FILECLOSED:				; ...
		inc	ds:SPECDRV	; [DestClosed]

RET50:					; ...
		clc
		retn
DODCLOSE	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR CLOSEDEST

FORGETIT:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		call	DODCLOSE
		call	DestDelete
		mov	ds:FileCnt, 0
		jmp	short RET50
; END OF FUNCTION CHUNK	FOR CLOSEDEST

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


DestDelete	proc near		; ...
		mov	dx, offset DestBuf
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		retn
DestDelete	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SOURCE_SET	proc near		; ...
		push	si
		mov	ax, ds:STARTEL
		mov	si, offset ScanBuf
		sub	ax, si
		mov	di, offset SrcBuf
		add	ax, di
		mov	ds:SrcTail, ax
		mov	ds:SrcSiz, cl
		inc	cx
		rep movsb
		mov	ds:SrcInfo, bh
		pop	si
		mov	ax, bp
		call	SETASC
		call	SWITCH
		call	SETASC
		retn
SOURCE_SET	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


CleanUpErr	proc near		; ...
		cmp	ds:msg_flag, 0
		jnz	short CleanupErr_Cont
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	DestBuf
		mov	ds:extend_buf_sub, 1 ; one_subst
		call	std_eprintf

CleanupErr_Cont:			; ...
		retn
CleanUpErr	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_answer_YNA	proc near		; ...
		mov	ds:cox_dest_file, 0 ; clear validation flag
		mov	ax, 4300h
		mov	dx, offset DestBuf
		int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
					; DS:DX	-> ASCIZ file name or directory
					; name without trailing	slash
		jnb	short getansw_1
		jmp	getansw_5
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getansw_1:				; ...
		inc	ds:cox_dest_file ; valid destination file
		lea	si, cox_sublist_buff
		mov	word ptr [si], 11 ; sublist size, 11 bytes
		mov	word ptr [si+2], offset	DestBuf	; sublist value	(pointer)
		mov	word ptr [si+4], ds ; sublist segment
		mov	byte ptr [si+6], 1 ; sub id (N of %N)
		mov	byte ptr [si+7], 10h ; data type flags
		mov	byte ptr [si+8], 0 ; maximum length (chars)
		mov	byte ptr [si+9], 0 ; minimum length (chars)
		mov	byte ptr [si+10], 0 ; pad field	character (0)
		lea	si, cox_sublist_buff
		mov	ax, 1103	; message number
					; 'Overwrite %1 (Yes/No/All)?'
		mov	bx, 2		; std error (file handle = 2)
		mov	cx, 1		; byte count
		mov	dh, 0FFh	; message class	(utility)
		xor	dl, dl		; control flag = 0
		call	SYSDISPMSG
		xor	bx, bx

getansw_2:				; ...
		mov	ax, 0C08h
		int	21h		; DOS -	CLEAR KEYBOARD BUFFER
					; AL must be 01h, 06h, 07h, 08h, or 0Ah.
		cmp	al, 0
		jz	short getansw_2
		cmp	al, 0Dh
		jz	short getansw_4
		mov	bl, al
		mov	dl, al
		mov	ax, 6520h
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		cmp	dl, ds:_Y_es	; 'Y' ?
		jz	short getansw_3
		cmp	dl, ds:_N_o	; 'N' ?
		jz	short getansw_3
		cmp	dl, ds:_A_ll	; 'A' ?
		jnz	short getansw_2

getansw_3:				; ...
		mov	bh, bl
		push	bx
		mov	ds:MSG_1104, bl
		mov	ah, 40h
		mov	bx, 2		; std error (file handle = 2)
		mov	cx, 1		; byte count
		mov	dx, offset MSG_1104
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		mov	ah, 40h
		mov	ds:MSG_1104, 8	; backspace (move cursor to back)
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	bx
		jmp	short getansw_2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getansw_4:				; ...
		cmp	bh, 0
		jz	short getansw_2
		mov	dl, bh
		mov	ax, 6520h
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		push	dx
		mov	ax, 1070	; message number
		mov	bx, 2		; std error (file handle = 2)
		xor	cx, cx
		mov	dh, 0FFh	; message class	(utility)
		xor	dl, dl
		call	SYSDISPMSG
		pop	dx
		cmp	dl, ds:_Y_es
		jz	short getansw_5
		cmp	dl, ds:_N_o
		jz	short getansw_6
		mov	ds:cox_y_override, 0
		jmp	short $+2

getansw_5:				; ...
		clc
		jmp	short getansw_7
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

getansw_6:				; ...
		stc

getansw_7:				; ...
		retn
get_answer_YNA	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


init_copycmd_option proc near		; ...
		mov	ds:cox_y_override, 1 ; suppress	copy overwrite confirmation
		push	es
		mov	es, ds:RESSEG
		mov	es, es:EnvirSeg
		lea	si, copycmd	; "COPYCMD="
		mov	cx, 8
		call	getenv_copycmd
		jb	short icpcmd_3
		call	get_copycmd_option ; copycmd=/Y	or copycmd=/-Y
		jb	short icpcmd_2
		inc	di		; skip '/'
		mov	al, es:[di]
		and	al, 0DFh	; convert to uppercase
		cmp	al, 'Y'
		jnz	short icpcmd_2

icpcmd_1:				; ...
		mov	ds:cox_y_override, 0 ; clear copy overwrite question/confirmation
					; (don't suppress)

icpcmd_2:				; ...
		pop	es
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

icpcmd_3:				; ...
		mov	es, ds:RESSEG
		cmp	es:cox_Y_option, 0 ; default (/Y) switch option	(1 = enabled)
		jz	short icpcmd_2
		jmp	short icpcmd_1
init_copycmd_option endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


get_copycmd_option proc	near		; ...
		cmp	byte ptr es:[di], 0
		jz	short gcpcmdo_2
		cmp	byte ptr es:[di], '/'
		jz	short gcpcmdo_1
		inc	di
		jmp	short get_copycmd_option
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gcpcmdo_1:				; ...
		clc
		jmp	short gcpcmdo_3
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gcpcmdo_2:				; ...
		stc

gcpcmdo_3:				; ...
		retn
get_copycmd_option endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


getenv_copycmd	proc near		; ...
		xor	di, di
		xor	al, al

gecpcmd_1:				; ...
		cmp	byte ptr es:[di], 0
		jz	short gecpcmd_3
		push	cx
		push	si
		repe cmpsb
		pop	si
		pop	cx
		jz	short gecpcmd_2
		push	cx
		mov	cx, 32768
		repne scasb
		pop	cx
		jmp	short gecpcmd_1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gecpcmd_2:				; ...
		clc
		jmp	short gecpcmd_4
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gecpcmd_3:				; ...
		stc

gecpcmd_4:				; ...
		retn
getenv_copycmd	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TRYFLUSH	proc near		; ...
		mov	al, ds:PARM1	; [Concat]
		push	ax
		call	FlshFil
		pop	ax
		cmp	al, ds:PARM1	; [Concat]
		retn
TRYFLUSH	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FlshFil		proc near		; ...
		mov	ds:TERMREAD, 0
		cmp	ds:CFLAG, 0
		jz	short NotExists
		jmp	Exists
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotExists:				; ...
		call	BUILDDEST
		call	COMPNAME
		jnz	short ProcDest
		cmp	ds:SRCISDEV, 0
		jnz	short ProcDest
		cmp	ds:PARM1, 0	; [Concat]
		mov	dx, offset OVERWR_PTR
		jnz	short No_Concat_Err
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

No_Concat_Err:				; ...
		mov	ds:NOWRITE, 1

ProcDest:				; ...
		mov	ax, 6C00h
		mov	si, offset DestBuf
		mov	bx, 21h
		xor	cx, cx
		mov	dx, 101h
		cmp	ds:NOWRITE, 0
		jnz	short DoDestOpen
		mov	dx, 112h

DoDestOpen:				; ...
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		jnb	short Dest_Open_Okay

Xa_Set_Error:				; ...
		call	Set_Ext_Error_Msg
		mov	ds:string_ptr_2, offset	DestBuf
		mov	ds:extend_buf_sub, 1
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Dest_Open_Okay:				; ...
		mov	ds:EndDestBuf, ax ; [DESTHAND]
		mov	ds:CFLAG, 1
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ds:DESTISDEV, dl
		test	dl, 80h
		jz	short Exists
		mov	al, byte ptr ds:ARG2S ;	[DestSwitch]
		and	al, 0Ch		; SWITCHA+SWITCHB ; 4+8
		jnz	short TestBoth
		mov	al, ds:ASCII
		or	al, ds:BINARY
		jz	short ExSetA

TestBoth:				; ...
		jp	short Exists
		test	al, 8		; SWITCHB
		jz	short Exists
		mov	ax, 4401h
		xor	dh, dh
		or	dl, 20h		; devid_RAW
		mov	ds:DESTISDEV, dl
		int	21h		; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
					; BX = device handle, DH = 0
					; DL = device information to set (bits 0-7 from	function 0)
		jmp	short Exists
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ExSetA:					; ...
		mov	ds:ASCII, 4	; SWITCHA
		or	ds:INEXACT, 4	; SWITCHA

Exists:					; ...
		cmp	ds:NOWRITE, 0
		jnz	short NoChecking
		cmp	ds:plus_comma, 1
		jz	short NoChecking
		call	COMPNAME
		jnz	short NoChecking
		cmp	ds:SRCISDEV, 0
		jnz	short NoChecking
		mov	dx, offset LOSTERR_PTR
		call	std_eprintf
		mov	ds:NXTADD, 0
		inc	ds:TERMREAD

Ret60:					; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoChecking:				; ...
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		xor	cx, cx
		xchg	cx, ds:NXTADD
		jcxz	short Ret60
		inc	ds:WRITTEN
		cmp	ds:NOWRITE, 0
		jnz	short SeekEnd
		xor	dx, dx
		push	ds
		mov	ds, ds:TPA
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		mov	dx, offset NOSPACE_PTR
		jnb	short NoChecking2
		jmp	Xa_Set_Error
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NoChecking2:				; ...
		sub	cx, ax
		jz	short Ret60
		test	ds:DESTISDEV, 80h ; devid_ISDEV
		jz	short COPYERR
		test	ds:DESTISDEV, 20h ; devid_RAW
		jnz	short DevWrtErr
		cmp	ds:INEXACT, 0
		jnz	short Ret60
		dec	cx
		jz	short Ret60

DevWrtErr:				; ...
		mov	dx, offset DEVWMES_PTR
		jmp	short COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SeekEnd:				; ...
		xor	dx, dx
		xchg	dx, cx
		mov	ax, 4201h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from present location
		mov	ds:OFilePtr_Lo,	ax
		mov	ds:OFilePtr_Hi,	dx
		cmp	ds:IFNOTFLAG, 0	; cmp byte [RDEOF],0
		jz	short Ret60
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		jb	short Xa_Set_Error_Jmp
		mov	ds:OCtrlZ, 1Ah
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

COPYERR:				; ...
		call	std_eprintf

CopErrP:				; inc byte [DestClosed]
		inc	ds:SPECDRV
		cmp	ds:CFLAG, 0
		jz	short EndCopyJ
		mov	bx, ds:EndDestBuf ; [DESTHAND]
		cmp	bx, 0
		jle	short NoClose
		mov	cx, ds:OFilePtr_Hi
		mov	dx, ds:OFilePtr_Lo
		mov	ax, cx
		or	ax, dx
		jz	short ceClose
		mov	ax, 4200h
		int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
					; AL = method: offset from beginning of	file
		xor	cx, cx
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		cmp	ds:OCtrlZ, 0
		jz	short ceClose0
		inc	cx
		mov	dx, offset OCtrlZ
		mov	ah, 40h
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

ceClose0:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ceClose:				; ...
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle

NoClose:				; ...
		mov	dx, offset DestBuf
		mov	ah, 41h
		int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
					; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
		mov	ds:CFLAG, 0

EndCopyJ:				; ...
		jmp	ENDCOPY
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Xa_Set_Error_Jmp:			; ...
		jmp	Xa_Set_Error
FlshFil		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETASC		proc near		; ...
		and	al, 0Ch		; SWITCHA+SWITCHB
		jp	short LOADSW
		push	ax
		and	al, 8
		mov	ds:BINARY, al	; SWITCHB
		pop	ax
		and	al, 4		; SWITCHA
		mov	ds:ASCII, al
		or	ds:INEXACT, al

LOADSW:					; ...
		mov	al, ds:ASCII
		or	al, al
		retn
SETASC		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDDEST	proc near		; ...
		cmp	ds:DestIsDir, 0FFh ; -1
		jnz	short KNOWABOUTDEST
		mov	di, offset USERDIR1
		mov	bp, offset DestIsDir ; offset DestVars
		call	BUILDPATH
		call	RestUDir1

KNOWABOUTDEST:				; ...
		xor	al, al
		xchg	al, ds:FIRSTDEST
		or	al, al
		jnz	short FIRSTDST
		jmp	NOFIRSTDEST
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FIRSTDST:				; ...
		mov	si, ds:DestTail
		mov	di, offset DESTDIR ; offset DestFcb
		mov	ax, 2900h
		int	21h		; DOS -	PARSE FILENAME
					; DS:SI	-> string to parse
					; ES:DI	-> buffer to fill with unopened	FCB
					; AL = bit mask	to control parsing
		cmp	byte ptr [si], 0
		jz	short GOODPARSE
		mov	dx, offset FULLDIR_PTR
		jmp	COPYERR
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

GOODPARSE:				; ...
		mov	ax, word ptr ds:DestBuf
		cmp	ah, ':'
		jz	short DRVSPEC4
		mov	al, 40h	; '@'

DRVSPEC4:				; ...
		mov	cl, ds:ASCII
		or	al, 20h
		sub	al, 60h
		mov	ds:DESTDIR, al	; [DestFcb]
		mov	al, ds:DestInfo
		mov	ah, ds:SrcInfo
		and	ax, 202h
		or	al, al
		jz	short NOTMELCOPY
		cmp	al, ah
		jnz	short NOTMELCOPY
		cmp	ds:PLUS, 0
		jz	short NOTMELCOPY
		inc	ds:MELCOPY
		xor	al, al
		jmp	short SETCONC
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTMELCOPY:				; ...
		xor	al, 2
		and	al, ah
		shr	al, 1

SETCONC:				; ...
		or	al, ds:PLUS
		mov	ds:PARM1, al	; [Concat]
		shl	al, 1
		shl	al, 1
		mov	ds:INEXACT, al
		cmp	ds:BINARY, 0
		jnz	short NOFIRSTDEST
		or	ds:ASCII, al
		or	cl, cl
		jnz	short NOFIRSTDEST
		or	al, al
		jz	short NOFIRSTDEST
		mov	cx, ds:NXTADD
		jcxz	short NOFIRSTDEST
		mov	al, 1Ah
		push	es
		xor	di, di
		mov	es, ds:TPA
		repne scasb
		pop	es
		jnz	short NOFIRSTDEST
		dec	di
		mov	ds:NXTADD, di

NOFIRSTDEST:				; ...
		mov	bx, (offset BWDBUF+1) ;	DIRBUF+1
		cmp	ds:PARM1, 0	; [Concat]
		jz	short GOTCHRSRC
		mov	bx, (offset SDIRBUF+1)

GOTCHRSRC:				; ...
		mov	si, (offset DESTDIR+1)
		mov	di, ds:DestTail
BUILDDEST	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDNAME	proc near		; ...
		mov	cx, 8

BUILDMAIN:				; ...
		lodsb
		cmp	al, '?'
		jnz	short NOTAMBIG
		mov	al, [bx]

NOTAMBIG:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTORE
		stosb

NOSTORE:				; ...
		inc	bx
		loop	BUILDMAIN
		mov	cl, 3
		mov	al, 20h	; ' '
		cmp	[si], al
		jz	short ENDDEST
		mov	al, '.'         ; 2Eh ; dot_chr
		stosb

BUILDEXT:				; ...
		lodsb
		cmp	al, '?'         ; 3Fh
		jnz	short NOTAMBIGE
		mov	al, [bx]

NOTAMBIGE:				; ...
		cmp	al, 20h	; ' '
		jz	short NOSTOREE
		stosb

NOSTOREE:				; ...
		inc	bx
		loop	BUILDEXT

ENDDEST:				; ...
		xor	al, al
		stosb
		retn
BUILDNAME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BUILDPATH	proc near		; ...

; FUNCTION CHUNK AT 2078 SIZE 00000011 BYTES

		test	byte ptr [bp+4], 2 ; [bp+VARSTRUC.INFO]
		jnz	short NOTPFILE
		mov	dx, bp
		add	dx, 5		; add dx,VARSTRUC.BUF
		push	di
		mov	ax, 6C00h
		mov	bx, 40h		; deny_none or read_open_mode
		xor	cx, cx
		mov	si, dx
		mov	dx, 101h	; read_open_flag
		int	21h		; DOS -	4.0 - EXTENDED OPEN/CREATE
					; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
					; BH = flags, CX = create attribute, DL	= action if file exists/does not exists
					; DH = 00h (reserved), DS:SI ->	ASCIZ file name
		pop	di
		jnb	short PURE_FILE
		call	get_ext_error_number
		cmp	ax, 2		; ERROR_FILE_NOT_FOUND
		jz	short NOTPFILE
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short NOTPFILE
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jz	short NOTPFILE
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

PURE_FILE:				; ...
		mov	bx, ax
		mov	ax, 4400h
		int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
					; BX = file or device handle
		mov	ah, 3Eh
		int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
					; BX = file handle
		test	dl, 80h
		jnz	short ISADEV
		test	byte ptr [bp+4], 4 ; [bp+VARSTRUC.INFO]
		jz	short ISADEV

NOTPFILE:				; ...
		mov	dx, [bp+5]	; [bp+VARSTRUC.BUF]
		cmp	dl, 0
		jz	short SET_DRIVE_SPEC
		cmp	dh, 3Ah	; ':'
		jz	short DRVSPEC5

SET_DRIVE_SPEC:				; ...
		mov	dl, 40h	; '@'

DRVSPEC5:				; ...
		or	dl, 20h
		sub	dl, 60h		; A = 1
		call	SAVUDIR1
		jnb	short CURDIR_OK
		call	get_ext_error_number
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CURDIR_OK:				; ...
		mov	dx, bp
		add	dx, 5		; add dx,VARSTRUC.BUF
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		and	bh, 6
		cmp	bh, 6
		jnz	short CHECKAMB
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		mov	bl, 3Ah	; ':'
		cmp	[si-2],	bl
		jnz	short KNOWNOTSPEC
		mov	byte ptr [bp+0], 2 ; [bp+VARSTRUC.ISDIR]
		jmp	short DOPCDJ
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

KNOWNOTSPEC:				; ...
		mov	byte ptr [bp+0], 1
		dec	si

DOPCDJ:					; ...
		jmp	DOPCD
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKAMB:				; ...
		cmp	bh, 2
		jnz	short CHECKCD

ISADEV:					; ...
		mov	byte ptr [bp+0], 0
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

CHECKCD:				; ...
		call	SetRest1
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		jb	short NOTPDIR
		mov	di, dx
		xor	ax, ax
		mov	cx, ax
		dec	cx

Kloop:					; ...
		mov	al, es:[di]
		inc	di
		or	al, al
		jz	short DONE
		xor	ah, ah
		call	testkanj
		jz	short Kloop
		inc	di
		inc	ah
		jmp	short Kloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

DONE:					; ...
		dec	di
		mov	al, ds:DIRCHAR
		mov	byte ptr [bp+0], 2 ; [bp+VARSTRUC.ISDIR]
		or	ah, ah
		jnz	short _STORE_PCHAR
		cmp	al, [di-1]
		jz	short GOTSRCSLSH

_STORE_PCHAR:				; ...
		stosb
		mov	byte ptr [bp+0], 1

GOTSRCSLSH:				; ...
		or	byte ptr [bp+4], 6 ; [bp+VARSTRUC.INFO]
		call	SETSTARS

NOTPDIR_RETN:				; ...
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTPDIR:				; ...
		call	get_ext_error_number
		cmp	ax, 3		; ERROR_PATH_NOT_FOUND
		jz	short NOTPDIR_TRY
		cmp	ax, 5		; ERROR_ACCESS_DENIED
		jnz	short EXTEND_SETUPJ

NOTPDIR_TRY:				; ...
		mov	byte ptr [bp+0], 0 ; [bp+VARSTRUC.ISDIR]
		mov	bh, [bp+4]	; [bp+VARSTRUC.INFO]
		test	bh, 4
		jz	short NOTPDIR_RETN
		mov	byte ptr [bp+0], 2
		mov	si, [bp+2]	; [bp+VARSTRUC.TTAIL]
		cmp	byte ptr [si], 0
		jz	short BADCDERRJ2
		mov	bl, 2Eh	; '.'
		cmp	[si], bl
		jz	short BADCDERRJ2
		mov	bl, 3Ah	; ':'
		cmp	[si-2],	bl
		jz	short DOPCD
		mov	byte ptr [bp+0], 1
		dec	si

DOPCD:					; ...
		xor	bl, bl
		xchg	bl, [si]
		call	SetRest1
		cmp	dx, si
		jnb	short LookBack
		push	si
		push	cx
		mov	cx, si
		mov	si, dx

Kloop2:					; ...
		lodsb
		call	testkanj
		jz	short NotKanj4
		lodsb
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si
		jmp	short DoCdr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NotKanj4:				; ...
		cmp	si, cx
		jb	short Kloop2
		pop	cx
		pop	si

LookBack:				; ...
		cmp	bl, [si-1]
		jz	short BADCDERRJ2

DoCdr:					; ...
		mov	ah, 3Bh
		int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
					; DS:DX	-> ASCIZ directory name	(may include drive)
		xchg	bl, [si]
		jnb	short NOTPDIR_RETN
		call	get_ext_error_number

EXTEND_SETUPJ:				; ...
		jmp	extend_setup
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADCDERRJ2:				; ...
		jmp	badpath_err
BUILDPATH	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SETSTARS	proc near		; ...
		mov	[bp+2],	di	; [bp+VARSTRUC.TTAIL]
		add	byte ptr [bp+1], 12 ; [bp+VARSTRUC.SIZ]
		mov	ax, '.?'        ;  "?." ; dot_qmark ; 2E3Fh
		mov	cx, 8
		rep stosb
		xchg	al, ah
		stosb
		xchg	al, ah
		mov	cl, 3
		rep stosb
		xor	al, al
		stosb
		retn
SETSTARS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


COMPNAME	proc near		; ...
		mov	si, offset DestBuf
		mov	di, offset TRGXNAME
		mov	ah, 60h		; xNameTrans
		int	21h		; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
					; DS:SI	-> ASCIZ relative path string or directory name
					; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
		mov	si, offset SRCXNAME
		mov	di, offset TRGXNAME
		call	STRCOMP
		retn
COMPNAME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cparse		proc near		; ...
		xor	ax, ax
		mov	ds:STARTEL, di
		mov	ds:ELPOS, al
		mov	ds:SKPDEL, al
		mov	bh, al
		pushf
		push	di
		xor	cx, cx
		mov	ds:comma, cl

moredelim:				; ...
		lodsb
		call	DELIM
		jnz	short SCANCDONE
		cmp	al, 20h	; ' '
		jz	short moredelim
		cmp	al, 9
		jz	short moredelim
		xchg	al, ds:SKPDEL
		or	al, al
		jz	short moredelim
		test	bh, 80h
		jz	short no_comma
		mov	ds:comma, 1

no_comma:				; ...
		jmp	x_done
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

SCANCDONE:				; ...
		cmp	al, bl
		jnz	short nospec
		or	bh, 80h
		jmp	short moredelim
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

nospec:					; ...
		cmp	al, 0Dh
		jnz	short ncperror
		jmp	cperror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ncperror:				; ...
		cmp	al, ds:SWITCHAR
		jnz	short na_switch
		jmp	a_switch
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

na_switch:				; ...
		mov	dl, ':'
		cmp	[si], dl
		jnz	short anum_chard
		cmp	ds:cpyflag, 1
		jnz	short cpcont2
		call	UPCONV

cpcont2:				; ...
		call	move_char
		lodsb
		call	move_char
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0
		jmp	anum_test
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

anum_chard:				; ...
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0
		cmp	ds:cpyflag, 1
		jnz	short anum_char
		call	pathchrcmp
		jnz	short anum_char
		push	ax
		mov	al, ds:CURDRV
		add	al, 41h	; 'A'
		call	move_char
		mov	al, 3Ah	; ':'
		call	move_char
		pop	ax
		mov	ds:STARTEL, di
		mov	ds:ELCNT, 0

anum_char:				; ...
		call	testkanj
		jz	short NOTKANJ
		call	move_char
		lodsb
		jmp	short notspecial
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

NOTKANJ:				; ...
		cmp	ds:cpyflag, 1
		jnz	short TESTDOT
		call	UPCONV

TESTDOT:				; ...
		cmp	al, 2Eh	; '.'   ; dot_chr
		jnz	short testquest
		inc	ds:ELPOS
		mov	ds:ELCNT, 0FFh

testquest:				; ...
		cmp	al, 3Fh	; '?'
		jnz	short testsplat
		or	bh, 2

testsplat:				; ...
		cmp	al, 2Ah	; '*'   ; star
		jnz	short testpath
		or	bh, 2
		cmp	ds:expand_star,	0
		jnz	short expand_filename
		jmp	short testpath
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR2J:				; ...
		jmp	short BADPERR2
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

expand_filename:			; ...
		mov	ah, 7
		cmp	ds:ELPOS, 0
		jz	short gotelcnt
		mov	ah, 2

gotelcnt:				; ...
		mov	al, 3Fh	; '?'
		sub	ah, ds:ELCNT
		jb	short BADPERR2J
		xchg	ah, cl
		jcxz	short testpathx

qmove:					; ...
		xchg	ah, cl
		call	move_char
		xchg	ah, cl
		loop	qmove

testpathx:				; ...
		xchg	ah, cl

testpath:				; ...
		call	pathchrcmp
		jnz	short notspecial
		or	bh, 4
		cmp	ds:expand_star,	0
		jz	short no_err_check
		test	bh, 2
		jnz	short BADPERR

no_err_check:				; ...
		mov	ds:STARTEL, di
		inc	ds:STARTEL
		mov	ds:ELCNT, 0FFh
		mov	ds:ELPOS, 0

notspecial:				; ...
		call	move_char

anum_test:				; ...
		lodsb

cpcont3:
		call	DELIM
		jz	short x_done
		cmp	al, 0Dh
		jz	short x_done
		cmp	al, ds:SWITCHAR
		jz	short x_done
		cmp	al, bl
		jz	short x_done
		cmp	al, 3Ah	; ':'
		jz	short FOO15
		jmp	anum_char
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

FOO15:					; ...
		cmp	ds:cpyflag, 2
		jnz	short cpcont4
		call	move_char
		jmp	short anum_test
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cpcont4:				; ...
		inc	si
		jmp	short x_done
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		jmp	anum_char
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR2:				; ...
		mov	dx, offset BADCPMES_PTR
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

BADPERR:				; ...
		mov	dx, offset badcd_ptr
		jmp	cerror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

cperror:				; ...
		dec	si
		pop	di
		popf
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

x_done:					; ...
		dec	si
		jmp	short out_token
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

a_switch:				; ...
		or	bh, 1
		or	bp, 8000h	; FSWITCH
		call	scanoff
		inc	si
		call	testkanj
		jz	short a_switch_notkanj
		call	move_char
		lodsb
		call	move_char
		or	bp, 4000h	; FBADSWITCH
		jmp	short out_token
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

a_switch_notkanj:			; ...
		cmp	al, 0Dh
		jnz	short Store_swt
		mov	al, 0
		stosb
		or	bp, 4000h
		jmp	short cperror
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Store_swt:				; ...
		call	move_char
		call	UPCONV
		push	es
		push	di
		push	cx
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	di, offset switch_list ; "-Y?VBAPW"
		mov	cx, 8		; SWCOUNT
		or	bp, 4000h	; FBADSWITCH
		repne scasb
		jnz	short out_tokenp
		and	bp, 0BFFFh	; ~FBADSWITCH ;	not FBADSWITCH
		mov	ax, 1
		shl	ax, cl
		or	bp, ax

out_tokenp:				; ...
		pop	cx
		pop	di
		pop	es
		assume es:nothing

out_token:				; ...
		mov	al, 0
		stosb
		pop	di
		popf
		clc
		retn
cparse		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


move_char	proc near		; ...
		stosb
		inc	cx
		inc	ds:ELCNT
		retn
move_char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


sysparse	proc near		; ...
		mov	word ptr cs:$P_Flags, 0	; mov psdata_seg:$P_Flags,0
		mov	cs:$P_ORIG_ORD,	cx ; MOV PSDATA_SEG:$P_ORIG_ORD,CX
		mov	cs:$P_ORIG_STACK, sp
		mov	cs:$P_ORIG_SI, si

$P_Redo_Time:				; ...
		cld
		mov	cs:$P_ORDINAL, cx ; mov	psdata_seg:$P_ordinal,cx
		mov	cs:$P_RC, 0	; mov psdata_seg:$P_RC,$P_No_Error
		mov	cs:$P_Found_SYNONYM, 0 ; mov psdata_seg:$P_Found_SYNONYM,0
		mov	cs:$P_DX, 0	; mov word ptr psdata_seg:$P_DX,0
		mov	word ptr cs:$P_FileSp_Char, '][' ; "[]|<>+=;\""
		mov	word ptr cs:$P_FileSp_Char+2, '<|'
		mov	word ptr cs:$P_FileSp_Char+4, '+>'
		mov	word ptr cs:$P_FileSp_Char+6, ';='
		call	$P_Skip_Delim
		jnb	short $P_Start
		mov	ax, 0FFFFh	; $P_RC_EOL
		push	bx
		mov	bx, es:[di]	; es:[di].$P_PARMSX_Address
		cmp	cl, es:[bx]	; es:[bx].$P_MinP
		jnb	short $P_Fin
		mov	ax, 2		; $P_Op_Missing

$P_Fin:					; ...
		pop	bx
		jmp	$P_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Start:				; ...
		mov	cs:$P_SaveSI_Cmpx, si ;	mov psdata_seg:$P_SaveSI_Cmpx,si
		push	bx
		push	di
		push	bp
		lea	bx, $P_STRING_BUF
		test	cs:$P_Flags2, 20h ; $P_Extra
		jnz	short $P_Pack_End

$P_Pack_Loop:				; ...
		lodsb
		call	$P_Chk_Switch
		jb	short $P_Pack_End_BY_EOL
		call	$P_Chk_EOL
		jz	short $P_Pack_End_BY_EOL
		call	$P_Chk_Delim
		jnz	short $P_PL01
		test	cs:$P_Flags2, 20h ; test psdata_seg:$P_Flags2,$P_Extra
		jnz	short $P_Pack_End_backup_si
		call	$P_Skip_Delim
		jmp	short $P_Pack_End
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Pack_End_backup_si:			; ...
		test	cs:$P_Flags2, 41h ; test psdata_seg:$P_Flags2,$P_SW+$P_equ
		jz	short $P_Pack_End
		dec	si
		jmp	short $P_Pack_End
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_PL01:				; ...
		mov	cs:[bx], al	; mov psdata_seg:[bx],al
		cmp	al, '='         ; cmp al,$P_Keyword
		jnz	short $P_PL00
		or	cs:$P_Flags2, 1	; or psdata_seg:$P_Flags2,$P_equ

$P_PL00:				; ...
		inc	bx
		call	$P_Chk_DBCS
		jnb	short $P_Pack_Loop
		lodsb
		mov	cs:[bx], al	; mov psdata_seg:[bx],al
		inc	bx
		jmp	short $P_Pack_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Pack_End_BY_EOL:			; ...
		dec	si

$P_Pack_End:				; ...
		mov	cs:$P_SI_Save, si
		mov	byte ptr cs:[bx], 0 ; mov byte ptr psdata_seg:[bx],$P_NULL
		mov	cs:$P_Save_EOB,	bx
		mov	bx, es:[di]	; es:[di].$P_PARMSX_Address
		lea	si, $P_STRING_BUF ; lea	si,psdata_seg:$P_STRING_BUF
					; (lea si,ds:9E6Ah)
		cmp	byte ptr cs:[si], '/' ; psdata_seg:[si],$P_Switch
		jz	short $P_SW_Manager
		cmp	byte ptr cs:[si], '"' ; psdata_seg:[si],$P_DQuote
		jz	short $P_Positional_Manager
		test	cs:$P_Flags2, 1	; test psdata_seg:$P_Flags2,$P_equ
		jnz	short $P_Key_Manager

$P_Positional_Manager:			; ...
		mov	al, es:[bx+1]	; es:[bx].$P_MaxP
		xor	ah, ah
		cmp	cs:$P_ORDINAL, ax ; psdata_seg:$P_ORDINAL,ax
		jnb	short $P_Too_Many_Error
		mov	ax, cs:$P_ORDINAL ; psdata_seg:$P_ORDINAL
		shl	ax, 1
		inc	bx
		inc	bx
		add	bx, ax
		mov	bx, es:[bx]
		call	$P_Chk_Pos_Control
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Too_Many_Error:			; ...
		mov	cs:$P_RC, 1	; psdata_seg:$P_RC,$P_Too_Many
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SW_Manager:				; ...
		mov	al, es:[bx+1]	; mov al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short $P_SW_Not_Found
		inc	bx

$P_SW_Mgr_Loop:				; ...
		push	bx
		mov	bx, es:[bx]
		call	$P_Chk_SW_Control
		pop	bx
		jnb	short $P_Return_to_Caller
		inc	bx
		inc	bx
		loop	$P_SW_Mgr_Loop

$P_SW_Not_Found:			; ...
		mov	cs:$P_RC, 3
		jmp	short $P_Return_to_Caller
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Key_Manager:				; ...
		mov	al, es:[bx+1]	; es:[bx].$P_MaxP
		xor	ah, ah
		inc	ax
		shl	ax, 1
		add	bx, ax
		mov	al, es:[bx]
		xor	ah, ah
		shl	ax, 1
		inc	ax
		add	bx, ax
		mov	cl, es:[bx]
		xor	ch, ch
		or	cx, cx
		jz	short $P_Key_Not_Found
		inc	bx

$P_Key_Mgr_Loop:			; ...
		push	bx
		mov	bx, es:[bx]
		call	$P_Chk_Key_Control
		pop	bx
		jnb	short $P_Return_to_Caller
		inc	bx
		inc	bx
		loop	$P_Key_Mgr_Loop

$P_Key_Not_Found:			; ...
		mov	cs:$P_RC, 4	; psdata_seg:$P_RC,$P_Not_In_Key

$P_Return_to_Caller:			; ...
		pop	bp
		pop	di
		pop	bx
		mov	cx, cs:$P_ORDINAL ; mov	cx,psdata_seg:$P_Ordinal
		mov	ax, cs:$P_RC
		mov	si, cs:$P_SI_Save ; mov	si,psdata_seg:$P_SI_Sav
		mov	dx, cs:$P_DX
		mov	bl, cs:$P_Terminator

$P_Single_Exit:				; ...
		clc
		retn
sysparse	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Pos_Control proc	near		; ...
		push	ax
		mov	ax, es:[bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		test	ax, 2
		jnz	short $P_CPC00
		inc	cs:$P_ORDINAL

$P_CPC00:				; ...
		cmp	byte ptr cs:[si], 0 ; $P_NULL
		jnz	short $P_CPC01
		test	ax, 1		; $P_Optional
		jnz	short $P_CPC02
		mov	cs:$P_RC, 2	; $P_Op_Missing
		jmp	short $P_CPC_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CPC02:				; ...
		push	ax
		mov	al, 3		; $P_String
		mov	ah, 0FFh	; $P_No_Tag
		call	$P_Fill_Result
		pop	ax
		jmp	short $P_CPC_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CPC01:				; ...
		call	$P_Check_Match_Flags

$P_CPC_Exit:				; ...
		pop	ax
		retn
$P_Chk_Pos_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Key_Control proc	near		; ...
		stc
		retn
$P_Chk_Key_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Search_KEYorSW proc near		; ...
		push	bp
		push	cx
		mov	cl, es:[bx+8]	; [es:bx+$P_CONTROL_BLK.$P_nid]
		xor	ch, ch
		or	cx, cx
		jz	short $P_KEYorSW_Not_Found
		lea	bp, [bx+9]	; [es:bx+$P_CONTROL_BLK.$P_KEYorSW]

$P_KEYorSW_Loop:			; ...
		call	$P_String_Comp
		jnb	short P_KEYorSW_Found
		call	$P_MoveBP_NUL
		loop	$P_KEYorSW_Loop

$P_KEYorSW_Not_Found:			; ...
		stc
		jmp	short $P_KEYorSW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

P_KEYorSW_Found:			; ...
		mov	cs:$P_Found_SYNONYM, bp
		clc

$P_KEYorSW_Exit:			; ...
		pop	cx
		pop	bp
		retn
$P_Search_KEYorSW endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_MoveBP_NUL	proc near		; ...
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jz	short $P_MBP_Exit
		inc	bp
		jmp	short $P_MoveBP_NUL
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_MBP_Exit:				; ...
		inc	bp
		retn
$P_MoveBP_NUL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_SW_Control proc near		; ...
		or	cs:$P_Flags2, 10h ; or psdata_seg:$P_Flags2,$P_Sw_Cmp
		call	$P_Search_KEYorSW
		jb	short $P_Chk_SW_Err0
		and	cs:$P_Flags2, 0EFh ; and psdata_seg:$P_Flags2,0ffh-$P_Sw_Cmp
		push	ax
		mov	ax, cs:$P_KEYorSW_Ptr ;	psdata_seg:$P_KEYorSW_Ptr
		sub	ax, si
		add	cs:$P_SaveSI_Cmpx, ax
		pop	ax
		mov	si, cs:$P_KEYorSW_Ptr
		cmp	byte ptr cs:[si], 0 ; psdata_seg:[si],$P_NULL
		jnz	short $P_CSW00
		cmp	byte ptr cs:[si-1], ':' ; psdata_seg:[si-1],$P_Colon
		jnz	short $P_Chk_if_data_required
		mov	cs:$P_RC, 9	; $P_Syntax
		jmp	short $P_Chk_SW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_if_data_required:		; ...
		cmp	word ptr es:[bx], 0 ; cmp es:[bx].$P_Match_Flag,0
		jz	short $P_Chk_SW_Exit
		test	word ptr es:[bx], 1 ; test es:[bx].$P_Match_Flag,$P_Optional
		jnz	short $P_Chk_SW_Exit
		mov	cs:$P_RC, 2	; mov psdata_seg:$P_RC,$P_Op_Missing
		jmp	short $P_Chk_SW_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_CSW00:				; ...
		call	$P_Check_Match_Flags
		clc
		jmp	short P_Chk_SW_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_SW_Err0:				; ...
		stc
		jmp	short P_Chk_SW_Single_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_SW_Exit:				; ...
		push	ax
		mov	al, 3		; mov al,$P_String
		mov	ah, 0FFh	; mov ah,$P_No_Tag
		call	$P_Fill_Result
		pop	ax
		clc

P_Chk_SW_Single_Exit:			; ...
		retn
$P_Chk_SW_Control endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Fill_Result	proc near		; ...
		push	di
		mov	di, es:[bx+4]	; [es:bx+$P_CONTROL_BLK.$P_Result_Buf]
		mov	cs:$P_DX, di
		mov	es:[di], al	; [es:di+$P_RESULT_BLK.$P_Type]
		mov	es:[di+1], ah	; [es:di+$P_RESULT_BLK.$P_Item_Tag]
		push	ax
		mov	ax, cs:$P_Found_SYNONYM
		mov	es:[di+2], ax	; [es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr]
		pop	ax
		cmp	al, 1		; $P_Number
		jnz	short $P_RLT00

$P_RLT02:				; ...
		mov	es:[di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	es:[di+6], cx	; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT00:				; ...
		cmp	al, 2		; $P_List_Idx
		jnz	short $P_RLT01
		mov	es:[di+4], dx	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT01:				; ...
		cmp	al, 7		; $P_Date_F
		jz	short $P_RLT02
		cmp	al, 8		; $P_Time_F
		jz	short $P_RLT02
		cmp	al, 6		; $P_Drive
		jnz	short $P_RLT03
		mov	es:[di+4], dl	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT03:				; ...
		cmp	al, 4		; $P_Complex
		jnz	short $P_RLT05
		mov	ax, cs:$P_SaveSI_Cmpx
		inc	ax
		mov	es:[di+4], ax	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	word ptr es:[di+6], ds ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		jmp	short $P_RLT_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT05:				; ...
		mov	es:[di+4], si	; [es:di+$P_RESULT_BLK.$P_Picked_Val]
		mov	word ptr es:[di+6], cs ; [es:di+2+$P_RESULT_BLK.$P_Picked_Val]
		push	ax
		test	byte ptr es:[bx+2], 1 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
		jz	short $P_RLT_CAP00
		mov	al, 4		; $P_DOSTBL_File
		jmp	short P_RLT_CAP02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RLT_CAP00:				; ...
		test	byte ptr es:[bx+2], 2 ;	[es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
		jz	short $P_RLT_CAP01
		mov	al, 2		; $P_DOSTBL_Char

P_RLT_CAP02:				; ...
		call	$P_Do_CAPS_String

$P_RLT_CAP01:				; ...
		pop	ax
		test	byte ptr es:[bx+2], 10h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
		jz	short $P_RLT_Exit
		call	$P_Remove_Colon

$P_RLT_Exit:				; ...
		pop	di
		retn
$P_Fill_Result	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Check_Match_Flags proc near		; ...
		mov	cs:$P_err_flag,	0 ; $P_NULL
		push	ax
		mov	ax, es:[bx]	; [es:bx+$P_CONTROL_BLK.$P_Match_Flag]
		or	ax, ax
		jnz	short $P_Mat
		push	ax
		push	bx
		push	dx
		push	di
		mov	cs:$P_RC, 9	; $P_Syntax
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		jmp	short $P_Bridge
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Mat:					; ...
		test	ax, 1000h	; $P_Date_S
		jz	short $P_Match02
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Date_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Bridge

$P_Match02:				; ...
		test	ax, 800h
		jz	short $P_Match03
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Time_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Bridge
		jmp	short $P_Match03
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Bridge:				; ...
		jmp	short $P_Match_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nop

$P_Match03:				; ...
		test	ax, 8000h	; $P_Num_Val
		jz	short $P_Match04
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_Value
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match04:				; ...
		test	ax, 4000h	; $P_SNum_Val
		jz	short $P_Match05
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_SValue
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match05:				; ...
		test	ax, 100h	; $P_Drv_Only
		jz	short $P_Match06
		mov	cs:$P_RC, 0	; $P_No_Error
		call	$P_File_Format
		call	$P_Drive_Format
		cmp	cs:$P_RC, 9	; $P_Syntax
		jnz	short $P_Match_Exit

$P_Match06:				; ...
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Match07
		mov	cs:$P_RC, 0
		call	$P_File_Format
		cmp	cs:$P_RC, 9
		jnz	short $P_Match_Exit

$P_Match07:				; ...
		test	ax, 2000h	; $P_Simple_S
		jz	short $P_Match_Exit
		mov	cs:$P_RC, 0
		call	$P_Simple_String

$P_Match_Exit:				; ...
		cmp	cs:$P_err_flag,	1 ; $P_error_filespec
		jnz	short $P_Match2_Exit
		cmp	cs:$P_RC, 0	; $P_No_Error
		jnz	short $P_Match2_Exit
		mov	cs:$P_RC, 9	; $P_Syntax

$P_Match2_Exit:				; ...
		pop	ax
		retn
$P_Check_Match_Flags endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Remove_Colon	proc near		; ...
		push	ax
		push	si

$P_RCOL_Loop:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_RCOL_Exit
		cmp	al, ':'         ; $P_Colon
		jnz	short $P_RCOL00
		cmp	byte ptr cs:[si+1], 0 ;	$P_NULL
		jnz	short $P_RCOL00
		mov	byte ptr cs:[si], 0
		jmp	short $P_RCOL_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RCOL00:				; ...
		call	$P_Chk_DBCS
		jnb	short $P_RCOL01
		inc	si

$P_RCOL01:				; ...
		inc	si
		jmp	short $P_RCOL_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_RCOL_Exit:				; ...
		pop	si
		pop	ax
		retn
$P_Remove_Colon	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Do_CAPS_String proc near		; ...
		push	si
		push	dx
		mov	dl, al

$P_DCS_Loop:				; ...
		mov	al, cs:[si]
		call	$P_Chk_DBCS
		jb	short $P_DCS0
		or	al, al
		jz	short $P_DCS_Exit
		call	$P_Do_CAPS_Char
		mov	cs:[si], al
		jmp	short $P_DCS01
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCS0:				; ...
		inc	si

$P_DCS01:				; ...
		inc	si
		jmp	short $P_DCS_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCS_Exit:				; ...
		pop	dx
		pop	si
		retn
$P_Do_CAPS_String endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Do_CAPS_Char	proc near		; ...
		cmp	al, 80h		; $P_ASCII80
		jnb	short $P_DCC_Go
		cmp	al, 61h	; 'a'
		jb	short $P_CAPS_Ret
		cmp	al, 7Ah	; 'z'
		ja	short $P_CAPS_Ret
		and	al, 0DFh	; $P_Make_Upper
		jmp	short $P_CAPS_Ret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DCC_Go:				; ...
		push	bx
		push	es
		push	di
		lea	di, $P_File_CAP_Ptr
		cmp	dl, 4		; $P_DOSTBL_File
		jz	short $P_DCC00
		lea	di, $P_Char_CAP_Ptr

$P_DCC00:				; ...
		cmp	cs:[di], dl
		jz	short $P_DCC01
		push	ax
		push	cx
		push	dx
		push	cs
		pop	es
		assume es:TRANGROUP
		mov	ah, 65h		; $P_DOS_Get_TBL
		mov	al, dl
		mov	bx, 0FFFFh	; -1 ; get active CON
		mov	cx, 5		; buffer length
		mov	dx, 0FFFFh	; -1 ; get for default code page
		int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
					; AL = function	-
		pop	dx
		pop	cx
		pop	ax

$P_DCC01:				; ...
		mov	bx, cs:[di+1]	; [cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
		mov	es, word ptr cs:[di+3] ; [cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
		assume es:nothing
		inc	bx
		inc	bx
		sub	al, 80h
		xlat	byte ptr es:[bx] ; $P_ASCII80
		pop	di
		pop	es
		pop	bx

$P_CAPS_Ret:				; ...
		retn
$P_Do_CAPS_Char	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_SValue	proc near		; ...
		push	ax
		or	cs:$P_Flags2, 80h ; $P_Signed
		and	cs:$P_Flags2, 0FDh ; 0FFh-$P_Neg
		mov	al, cs:[si]
		cmp	al, 2Bh	; '+'   ; $P_Plus
		jz	short $P_SVal00
		cmp	al, 2Dh	; '-'   ; $P_Minus
		jnz	short $P_Sval01
		or	cs:$P_Flags2, 2	; $P_Neg

$P_SVal00:				; ...
		inc	si

$P_Sval01:				; ...
		call	$P_Value
		pop	ax
		retn
$P_SValue	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Value	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		xor	cx, cx
		xor	dx, dx
		push	bx

$P_Value_Loop:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_Value00
		call	$P_0099
		jb	short $P_Value_Err0
		xor	ah, ah
		mov	bp, ax
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		mov	bx, dx
		mov	ax, cx
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		shl	dx, 1
		rcl	cx, 1
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		add	dx, bx
		adc	cx, ax
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		add	dx, bp
		adc	cx, 0
		call	$P_Check_OVF
		jb	short $P_Value_Err0
		inc	si
		jmp	short $P_Value_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value_Err0:				; ...
		pop	bx
		jmp	$P_Value_Err
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value00:				; ...
		pop	bx
		test	cs:$P_Flags2, 2	; $P_Neg
		jz	short $P_Value01
		not	cx
		not	dx
		add	dx, 1
		adc	cx, 0

$P_Value01:				; ...
		mov	si, es:[bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, es:[si]
		cmp	al, 0		; $P_nval_None
					;
		jnz	short $P_Value02
		mov	al, 1
		mov	ah, 0FFh
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nop

$P_Value02:				; ...
		inc	si
		mov	al, es:[si]
		cmp	al, 0
		jz	short $P_Value_Err ; $P_Value03
		inc	si

$P_Val02_Loop:				; ...
		test	cs:$P_Flags2, 80h ; $P_Signed
		jnz	short $P_Val02_Sign
		cmp	cx, es:[si+3]	; [es:si+$P_VAL_LIST.$P_Val_XH]
		jb	short $P_Val02_Next
		ja	short $P_Val_In
		cmp	dx, es:[si+1]	; [es:si+$P_VAL_LIST.$P_Val_XL]
		jb	short $P_Val02_Next

$P_Val_In:				; ...
		cmp	cx, es:[si+7]	; [es:si+$P_VAL_LIST.$P_Val_YH]
		ja	short $P_Val02_Next
		jb	short $P_Val_Found
		cmp	dx, es:[si+5]	; [es:si+$P_VAL_LIST.$P_Val_YL]
		ja	short $P_Val02_Next
		jmp	short $P_Val_Found
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val02_Sign:				; ...
		cmp	cx, es:[si+3]
		jl	short $P_Val02_Next
		jg	short $P_SVal_In
		cmp	dx, es:[si+1]
		jl	short $P_Val02_Next

$P_SVal_In:				; ...
		cmp	cx, es:[si+7]
		jg	short $P_Val02_Next
		jl	short $P_Val_Found
		cmp	dx, es:[si+5]
		jg	short $P_Val02_Next
		jmp	short $P_Val_Found
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val02_Next:				; ...
		add	si, 9		; $P_Len_Range
		dec	al
		jnz	short $P_Val02_Loop
		mov	cs:$P_RC, 6	; $P_Out_Of_Range
		mov	al, 1		; $P_Number
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Val_Found:				; ...
		mov	al, 1
		mov	ah, es:[si]
		jmp	short $P_Value_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Value_Err:				; ...
		mov	cs:$P_RC, 9	; $P_Syntax
		mov	al, 3		; $P_String
		mov	ah, 0FFh	; $P_No_Tag

$P_Value_Exit:				; ...
		call	$P_Fill_Result
		pop	si
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Value	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Check_OVF	proc near		; ...
		pushf
		test	cs:$P_Flags2, 2	; $P_Neg
		jnz	short $P_COVF
		popf
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_COVF:				; ...
		popf
		jo	short $P_COVF00
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_COVF00:				; ...
		stc
		retn
$P_Check_OVF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_0099		proc near		; ...
		cmp	al, 30h	; '0'
		jb	short $P_0099Err
		cmp	al, 39h	; '9'
		ja	short $P_0099Err
		sub	al, 30h	; '0'
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_0099Err:				; ...
		stc
		retn
$P_0099		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Simple_String proc near		; ...
		push	ax
		push	bx
		push	dx
		push	di
		mov	di, es:[bx+6]	; [es:bx+$P_CONTROL_BLK.$P_Value_List]
		mov	al, es:[di]
		or	al, al
		jnz	short $P_Sim00
		mov	ah, 0FFh
		jmp	short $P_Sim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim00:				; ...
		cmp	al, 3		; $P_nval_String
		jnz	short $P_Sim01
		inc	di
		mov	al, es:[di]
		mov	ah, 9		; $P_Len_Range
		mul	ah
		inc	ax
		add	di, ax
		mov	al, es:[di]
		mov	ah, 5		; $P_Len_Value
		mul	ah
		inc	ax
		add	di, ax
		mov	al, es:[di]
		inc	di
		inc	di

$P_Sim_Loop:				; ...
		mov	bp, es:[di]
		call	$P_String_Comp
		jnb	short $P_Sim_Found
		add	di, 3		; $P_Len_String
		dec	al
		jnz	short $P_Sim_Loop
		mov	cs:$P_RC, 8	; $P_Not_In_Str
		mov	ah, 0FFh	; $P_No_Tag
		jmp	short $P_Sim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim_Found:				; ...
		mov	ah, es:[di-1]
		mov	al, 2		; $P_List_Idx
		mov	dx, es:[di]
		jmp	short $P_Sim_Exit0
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Sim01:				; ...
		mov	cs:$P_RC, 9	; $P_Syntax
		mov	ah, 0FFh	; $P_No_Tag

$P_Sim_Exit:				; ...
		mov	al, 3		; $P_String

$P_Sim_Exit0:				; ...
		call	$P_Fill_Result
		pop	di
		pop	dx
		pop	bx
		pop	ax
		retn
$P_Simple_String endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_String_Comp	proc near		; ...
		push	ax
		push	bp
		push	dx
		push	si
		mov	dl, 2		; $P_DOSTBL_Char

$P_SCOM_Loop:				; ...
		mov	al, cs:[si]	; 1st string
		call	$P_Chk_DBCS
		jb	short $P_SCOM00
		call	$P_Do_CAPS_Char
		test	cs:$P_Flags2, 8	; $P_Key_Cmp
		jz	short $P_SCOM04
		cmp	al, 3Dh	; '='   ; $P_Keyword
		jnz	short $P_SCOM03
		cmp	byte ptr es:[bp+1], 0
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM05
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM04:				; ...
		test	cs:$P_Flags2, 10h ; $P_SW_Cmp
		jz	short $P_SCOM03
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_SCOM03
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ

$P_SCOM05:				; ...
		inc	si
		jmp	short $P_SCOM_Same
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM03:				; ...
		cmp	al, es:[bp+0]	; 2nd string (must be upper case)
		jnz	short $P_SCOM_Differ0
		or	al, al
		jz	short $P_SCOM_Same
		inc	si
		inc	bp
		jmp	short $P_SCOM01
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM00:				; ...
		cmp	al, es:[bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		mov	al, cs:[si]
		inc	bp
		cmp	al, es:[bp+0]
		jnz	short $P_SCOM_Differ
		inc	si
		inc	bp

$P_SCOM01:				; ...
		jmp	short $P_SCOM_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM_Differ0:			; ...
		test	cs:$P_Flags2, 40h ; $P_SW
		jz	short $P_not_applicable
		test	word ptr es:[bx+2], 20h	; [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
		jz	short $P_not_applicable
		cmp	byte ptr es:[bp+0], 0
		jz	short $P_SCOM_Same

$P_not_applicable:			; ...
		test	word ptr es:[bx], 10h ;	[es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
		jz	short $P_SCOM_Differ
		cmp	al, 3Ah	; ':'   ; $P_Colon
		jnz	short $P_SCOM02
		cmp	byte ptr es:[bp+0], 0 ;	$P_NULL
		jnz	short $P_SCOM_Differ
		jmp	short $P_SCOM_Same
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM02:				; ...
		cmp	al, 0
		jnz	short $P_SCOM_Differ
		cmp	byte ptr es:[bp+0], 3Ah	; ':'
		jz	short $P_SCOM_Same

$P_SCOM_Differ:				; ...
		stc
		jmp	short $P_SCOM_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_SCOM_Same:				; ...
		mov	cs:$P_KEYorSW_Ptr, si
		clc

$P_SCOM_Exit:				; ...
		pop	si
		pop	dx
		pop	bp
		pop	ax
		retn
$P_String_Comp	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Date_Format	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI
		pop	si
		mov	cs:$P_1st_Val, 0
		mov	cs:$P_2nd_Val, 0 ; mov psdata_seg:$P_2nd_Val,0
		mov	cs:$P_3rd_Val, 0
		call	$P_Get_DecNum
		jb	short $P_DateF_Err0
		mov	cs:$P_1st_Val, ax
		or	bl, bl
		jz	short $P_DateF_YMD
		call	$P_Get_DecNum
		jb	short $P_DateF_Error
		mov	cs:$P_2nd_Val, ax
		or	bl, bl
		jz	short $P_DateF_YMD
		call	$P_Get_DecNum

$P_DateF_Err0:				; ...
		jb	short $P_DateF_Error
		mov	cs:$P_3rd_Val, ax
		or	bl, bl
		jnz	short $P_DateF_Error

$P_DateF_YMD:				; ...
		mov	bx, cs:$P_Country_Info ; [cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
					; mov bx,psdata_seg:$P_Country_Info.$P_CDI_DateF
		cmp	bx, 2		; bx,$P_Date_YMD
		jz	short $P_DateF00
		mov	ax, cs:$P_1st_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	cl, al
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	ch, al
		mov	dx, cs:$P_3rd_Val
		cmp	bx, 1		; bx,$P_Date_DMY
		jnz	short $P_DateF01
		xchg	ch, cl

$P_DateF01:				; ...
		jmp	short $P_DateF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DateF00:				; ...
		mov	dx, cs:$P_1st_Val
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	cl, al
		mov	ax, cs:$P_3rd_Val
		or	ah, ah
		jnz	short $P_DateF_Error
		mov	ch, al

$P_DateF02:				; ...
		cmp	dx, 100
		jnb	short $P_DateF03
		add	dx, 1900

$P_DateF03:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 7		; $P_Date_F
		call	$P_Fill_Result
		jmp	short $P_Date_Format_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DateF_Error:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		mov	cs:$P_RC, 9	; mov psdata_seg:$P_RC,$P_Syntax

$P_Date_Format_Exit:			; ...
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Date_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Set_CDI	proc near		; ...
		lea	si, $P_Country_Info ; (lea si,ds:9EF1h)
					; lea si,psdata_seg:$P_Country_Info
		cmp	word ptr cs:[si], 0FFFFh ;
					; cmp psdata_seg:[si].$P_CDI_DateF,$P_NeedToBeRead
		jz	short $P_Read_CDI
		jmp	short $P_Set_CDI_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Read_CDI:				; ...
		push	ds
		push	dx
		push	ax
		push	cs
		pop	ds
		assume ds:TRANGROUP
		mov	ax, 3800h	; $P_DOS_Get_CDI
		mov	dx, si
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		pop	ax
		pop	dx
		pop	ds
		assume ds:nothing

$P_Set_CDI_Exit:			; ...
		retn
$P_Set_CDI	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Get_DecNum	proc near		; ...
		push	cx
		push	dx
		xor	cx, cx

$P_GetNum_Loop:				; ...
		mov	al, cs:[si]	; mov al,psdata_seg:[si]
		or	al, al
		jz	short $P_GetNum00
		cmp	cs:$P_Got_Time,	0 ; cmp	psdata_seg:$P_Got_Time,0
		jz	short $P_Do_Date_Delims
		cmp	bl, 1		; cmp bl,$P_colon_period
		jnz	short $P_Do_Time_Delim1
		cmp	al, ':'         ; $P_Colon
		jz	short $P_GetNum01

$P_Do_Time_Delim1:			; ...
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01
		jmp	short $P_Neither_Delims
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Do_Date_Delims:			; ...
		cmp	al, '-'         ; $P_Minus
		jz	short $P_GetNum01
		cmp	al, '/'         ; $P_Slash
		jz	short $P_GetNum01
		cmp	al, '.'         ; $P_Period
		jz	short $P_GetNum01

$P_Neither_Delims:			; ...
		call	$P_0099
		jb	short $P_GetNum_Exit
		mov	ah, 0
		xchg	ax, cx
		mov	dx, 10
		mul	dx
		or	dx, dx
		jnz	short $P_GetNum02
		add	ax, cx
		jb	short $P_GetNum_Exit
		xchg	ax, cx
		inc	si
		jmp	short $P_GetNum_Loop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum00:				; ...
		mov	bl, al
		clc
		jmp	short $P_GetNum_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum01:				; ...
		inc	si
		clc
		jmp	short $P_GetNum_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_GetNum02:				; ...
		stc

$P_GetNum_Exit:				; ...
		mov	ax, cx
		pop	dx
		pop	cx
		retn
$P_Get_DecNum	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Time_Format	proc near		; ...
		push	ax
		push	cx
		push	dx
		push	si
		push	bx
		push	si
		call	$P_Set_CDI
		test	byte ptr cs:[si+11h], 1	;
					; test byte ptr	psdata_seg:[si].$P_CDI_TimeF,1
		pop	si
		jnz	short $P_TimeF00
		call	$P_Time_2412

$P_TimeF00:				; ...
		mov	cs:$P_1st_Val, 0
		mov	cs:$P_2nd_Val, 0
		mov	cs:$P_3rd_Val, 0 ; mov psdata_seg:$P_3rd_Val,0
		mov	cs:$P_4th_Val, 0
		mov	cs:$P_Got_Time,	1 ; mov	psdata_seg:$P_Got_Time,1
		mov	bl, 1		; $P_colon_period
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_1st_Val, ax
		or	bl, bl
		jz	short $P_TimeF_Rlt
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_2nd_Val, ax
		or	bl, bl
		jz	short $P_TimeF_Rlt
		mov	bl, 2		; mov bl,$P_period_only
		call	$P_Get_DecNum
		jb	short $P_TimeF_Err0
		mov	cs:$P_3rd_Val, ax
		or	bl, bl
		jnz	short $P_Time_4
		test	cs:$P_Flags, 2	; test psdata_seg:$P_Flags1,$P_Time_Again
		jnz	short $P_TimeF_Rlt
		mov	si, cs:$P_SI_Save ; mov	si,psdata_seg:$P_SI_Save
		cmp	byte ptr [si-1], ',' ; cmp byte ptr [si-1],$P_Comma
		jnz	short $P_TimeF_Rlt
		mov	byte ptr [si-1], '.' ; mov byte ptr [si-1],$P_Period
		mov	word ptr cs:$P_Flags, 0
		or	cs:$P_Flags, 2	; or psdata_seg:$P_Flags1,$P_Time_Again
		mov	cx, cs:$P_ORIG_ORD
		mov	sp, cs:$P_ORIG_STACK
		mov	si, cs:$P_ORIG_SI
		jmp	$P_Redo_Time
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Time_4:				; ...
		call	$P_Get_DecNum

$P_TimeF_Err0:				; ...
		jb	short $P_TimeF_Error
		mov	cs:$P_4th_Val, ax
		or	bl, bl
		jnz	short $P_TimeF_Error

$P_TimeF_Rlt:				; ...
		mov	ax, cs:$P_1st_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		test	cs:$P_Flags, 1	; test psdata_seg:$P_Flags1,$P_Time12am
		jz	short $P_Time_notAM
		cmp	al, 12
		ja	short $P_TimeF_Error
		jnz	short $P_Time_notAM
		xor	al, al

$P_Time_notAM:				; ...
		test	cs:$P_Flags2, 4	; test psdata_seg:$P_Flags2,$P_Time12
		jz	short $P_TimeSkip00
		cmp	al, 12
		jz	short $P_TimeSkip00
		add	al, 12
		jb	short $P_TimeF_Error
		cmp	al, 24
		ja	short $P_TimeF_Error

$P_TimeSkip00:				; ...
		mov	dl, al
		mov	ax, cs:$P_2nd_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	dh, al
		mov	ax, cs:$P_3rd_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	cl, al
		mov	ax, cs:$P_4th_Val ; mov	ax,psdata_seg:$P_4th_Val
		or	ah, ah
		jnz	short $P_TimeF_Error
		mov	ch, al
		pop	bx
		pop	si
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 8		; $P_Time_F
		call	$P_Fill_Result
		jmp	short $P_Time_Format_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_TimeF_Error:				; ...
		pop	bx
		pop	si
		mov	ah, 0FFh
		mov	al, 3		; $P_String
		call	$P_Fill_Result
		mov	cs:$P_RC, 9	; mov psdata_seg:$P_RC,$P_Syntax

$P_Time_Format_Exit:			; ...
		mov	cs:$P_Got_Time,	0 ; mov	psdata_seg:$P_Got_Time,0
		pop	dx
		pop	cx
		pop	ax
		retn
$P_Time_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Time_2412	proc near		; ...
		push	ax
		push	si

$P_T12_Loop:				; ...
		mov	al, cs:[si]	; mov al,psdata_seg:[si]
		inc	si
		or	al, al
		jnz	short $P_T12_Loop
		mov	al, cs:[si-2]	; mov al,psdata_seg:[si-word]
		or	al, 20h		; or al,$P_Make_Lower
		cmp	al, 'p'
		jz	short $P_T1200
		cmp	al, 'a'
		jz	short $P_T1201
		cmp	al, 'm'
		jnz	short $P_T12_Exit
		dec	si
		mov	al, cs:[si-2]
		or	al, 20h
		cmp	al, 'p'
		jz	short $P_T1200
		cmp	al, 'a'
		jz	short $P_T1201
		jmp	short $P_T12_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_T1200:				; ...
		or	cs:$P_Flags2, 4	; or psdata_seg:$P_Flags2,$P_Time12
		jmp	short $P_Tclr_chr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_T1201:				; ...
		or	cs:$P_Flags, 1	; or psdata_seg:$P_Flags1,$P_Time12AM

$P_Tclr_chr:				; ...
		mov	byte ptr cs:[si-2], 0 ;	psdata_seg:[si-2],$P_NULL

$P_T12_Exit:				; ...
		pop	si
		pop	ax
		retn
$P_Time_2412	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_File_Format	proc near		; ...
		push	ax
		push	di
		push	si
		mov	di, cs:$P_SaveSI_Cmpx
		mov	al, cs:[si]
		or	al, al
		jz	short $P_FileF_Err
		call	$P_FileSp_Chk
		jnz	short $P_FileF03
		mov	cs:$P_err_flag,	1 ; $P_error_filespec
		pop	si
		mov	byte ptr cs:[si], 0 ; $P_NULL
		pop	di
		jmp	short $P_FileF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF_Err:				; ...
		pop	si
		mov	byte ptr cs:[si], 0
		pop	di
		test	word ptr es:[bx], 1 ; [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
		jnz	short $P_FileF02
		mov	cs:$P_RC, 2	; $P_Op_Missing
		jmp	short $P_FileF02
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF03:				; ...
		pop	ax
		push	si

$P_FileF_Loop1:				; ...
		mov	al, cs:[si]
		or	al, al
		jz	short $P_FileF_RLT
		call	$P_FileSp_Chk
		jz	short $P_FileF00
		call	$P_Chk_DBCS
		jnb	short $P_FileF01
		inc	di
		inc	si

$P_FileF01:				; ...
		inc	di
		inc	si
		jmp	short $P_FileF_Loop1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_FileF00:				; ...
		mov	cs:$P_Terminator, al
		mov	byte ptr cs:[si], 0
		inc	di
		mov	cs:$P_SI_Save, di

$P_FileF_RLT:				; ...
		pop	si
		pop	di

$P_FileF02:				; ...
		pop	ax
		test	ax, 200h	; $P_File_Spc
		jz	short $P_Drv_Only_Exit
		push	ax
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 5		; $P_File_Spec
		call	$P_Fill_Result
		pop	ax

$P_Drv_Only_Exit:			; ...
		retn
$P_File_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_FileSp_Chk	proc near		; ...
		push	bx
		push	cx
		lea	bx, $P_FileSp_Char ; "[]|<>+=;\""
		mov	cx, 9		; $P_FileSp_Len

$P_FileSp_Loop:				; ...
		cmp	al, cs:[bx]
		jz	short $P_FileSp_Exit
		inc	bx
		loop	$P_FileSp_Loop
		inc	cx

$P_FileSp_Exit:				; ...
		pop	cx
		pop	bx
		retn
$P_FileSp_Chk	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Drive_Format	proc near		; ...
		push	ax
		push	dx
		mov	al, cs:[si]
		or	al, al
		jz	short $P_Drv_Exit
		call	$P_Chk_DBCS
		jb	short $P_Drv_Err
		cmp	word ptr cs:[si+1], 3Ah	; ':' ; $P_Colon
		jz	short $P_DrvF00
		test	word ptr es:[bx], 10h ;	$P_Ig_Colon
		jz	short $P_Drv_Err
		cmp	byte ptr cs:[si+1], 0
		jnz	short $P_Drv_Err

$P_DrvF00:				; ...
		or	al, 20h		; $P_Make_Lower
		cmp	al, 61h	; 'a'
		jb	short $P_Drv_Err
		cmp	al, 7Ah	; 'z'
		ja	short $P_Drv_Err
		sub	al, 60h	; '`'
		mov	dl, al
		mov	ah, 0FFh	; $P_No_Tag
		mov	al, 6		; $P_Drive
		call	$P_Fill_Result
		jmp	short $P_Drv_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Drv_Err:				; ...
		mov	cs:$P_RC, 9	; $P_Syntax

$P_Drv_Exit:				; ...
		pop	dx
		pop	ax
		retn
$P_Drive_Format	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Skip_Delim	proc near		; ...
		lodsb
		call	$P_Chk_EOL
		jz	short $P_Skip_Delim_CY
		call	$P_Chk_Delim
		jnz	short $P_Skip_Delim_NCY
		test	cs:$P_Flags2, 20h ; $P_Extra
		jz	short $P_Skip_Delim
		test	cs:$P_Flags2, 41h
		jz	short $P_Exit_At_Extra
		dec	si
		jmp	short $P_Exit_At_Extra
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Skip_Delim_CY:			; ...
		stc
		jmp	short $P_Skip_Delim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Skip_Delim_NCY:			; ...
		clc

$P_Skip_Delim_Exit:			; ...
		dec	si
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Exit_At_Extra:			; ...
		clc
		retn
$P_Skip_Delim	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_EOL	proc near		; ...
		push	bx
		push	cx
		cmp	al, 0Dh		; $P_CR
		jz	short $P_Chk_EOL_Exit
		cmp	al, 0		; $P_NULL
		jz	short $P_Chk_EOL_Exit
		cmp	byte ptr es:[di+2], 2 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
		jb	short $P_Chk_EOL_Exit
		xor	bx, bx
		mov	bl, es:[di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		add	bx, 4		; $P_Len_PARMS
		cmp	byte ptr es:[bx+di], 0 ; $P_I_Use_Default
		jz	short $P_Chk_EOL_NZ
		xor	cx, cx
		mov	cl, es:[bx+di]

$P_Chk_EOL_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short $P_Chk_EOL_Exit
		loop	$P_Chk_EOL_Loop

$P_Chk_EOL_NZ:				; ...
		cmp	al, 0Dh

$P_Chk_EOL_Exit:			; ...
		pop	cx
		pop	bx
		retn
$P_Chk_EOL	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Delim	proc near		; ...
		push	bx
		push	cx
		mov	cs:$P_Terminator, 20h ;	' ' ; $P_Space
		and	cs:$P_Flags2, 0DFh ; 0FFh-$P_Extra
		cmp	al, 20h	; ' '   ; $P_Space
		jz	short $P_Chk_Delim_Exit
		cmp	al, 9		; $P_TAB
		jz	short $P_Chk_Delim_Exit
		cmp	al, 2Ch	; ','   ; $P_Comma
		jz	short $P_Chk_Delim_Exit0
		cmp	al, 20h	; ' '   ; $P_DBSP1
		jnz	short $P_Chk_Delim01
		cmp	byte ptr [si], 20h ; ' ' ; $P_DBSP2
		jnz	short $P_Chk_Delim01
		mov	al, 20h	; ' '
		inc	si
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_Delim01:				; ...
		cmp	byte ptr es:[di+2], 1 ;	[es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
		jb	short $P_Chk_Delim_Exit
		xor	cx, cx
		mov	cl, es:[di+3]	; [es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
		or	cx, cx
		jz	short $P_Chk_Delim_NZ
		mov	bx, 3		; $P_Len_PARMS-1

$P_Chk_Delim_Loop:			; ...
		inc	bx
		cmp	al, es:[bx+di]
		jz	short $P_Chk_Delim_Exit0
		loop	$P_Chk_Delim_Loop

$P_Chk_Delim_NZ:			; ...
		cmp	al, 20h	; ' '   ; $P_Space

$P_Chk_Delim_Exit:			; ...
		pop	cx
		pop	bx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_Chk_Delim_Exit0:			; ...
		mov	cs:$P_Terminator, al
		test	cs:$P_Flags2, 1	; $P_equ
		jnz	short $P_No_Set_Extra
		or	cs:$P_Flags2, 20h ; $P_Extra

$P_No_Set_Extra:			; ...
		cmp	al, al
		jmp	short $P_Chk_Delim_Exit
$P_Chk_Delim	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_Switch	proc near		; ...
		lea	bp, $P_STRING_BUF
		cmp	bx, bp
		jz	short $P_STRUC_L2
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L5
		stc
		push	ax
		mov	al, cs:[bx-1]
		call	$P_0099
		jb	short $P_STRUC_L7
		mov	al, [si]
		call	$P_0099

$P_STRUC_L7:				; ...
		pop	ax
		jmp	short $P_STRUC_L1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_STRUC_L5:				; ...
		clc
		jmp	short $P_STRUC_L1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_STRUC_L2:				; ...
		cmp	al, 2Fh	; '/'   ; $P_Switch
		jnz	short $P_STRUC_L12
		or	cs:$P_Flags2, 40h ; $P_SW

$P_STRUC_L12:				; ...
		clc

$P_STRUC_L1:				; ...
		retn
$P_Chk_Switch	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$P_Chk_DBCS	proc near		; ...
		push	ds
		push	si
		push	bx
		cmp	cs:$P_DBCSEV_SEG, 0 ; cmp psdata_seg:$P_DBCSEV_SEG
		jnz	short $P_DBCS00
		push	ax
		push	ds
		push	cx
		push	dx
		push	di
		push	bp
		push	es
		xor	si, si
		mov	ds, si
		assume ds:RESGROUP
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		mov	bx, ds
		or	bx, bx
		pop	es
		pop	bp
		pop	di
		pop	dx
		pop	cx
		pop	ds
		assume ds:nothing
		pop	ax
		jz	short $P_NON_DBCS
		mov	cs:$P_DBCSEV_OFF, si
		mov	cs:$P_DBCSEV_SEG, bx ; psdata_seg:$P_DBCSEV_SEG,bx

$P_DBCS00:				; ...
		mov	si, cs:$P_DBCSEV_OFF ; psdata_seg:$P_DBCSEV_OFF
		mov	ds, cs:$P_DBCSEV_SEG

$P_DBCS_LOOP:				; ...
		cmp	word ptr [si], 0
		jz	short $P_NON_DBCS
		cmp	al, [si]
		jb	short $P_DBCS01
		cmp	al, [si+1]
		ja	short $P_DBCS01
		stc
		jmp	short $P_DBCS_EXIT
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_DBCS01:				; ...
		inc	si
		inc	si
		jmp	short $P_DBCS_LOOP
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$P_NON_DBCS:				; ...
		clc

$P_DBCS_EXIT:				; ...
		pop	bx
		pop	si
		pop	ds
		retn
$P_Chk_DBCS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


cmd_parse	proc near		; ...
		call	sysparse
		retn
cmd_parse	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

append_parse:				; ...
		call	sysparse
		retf
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

Printf_Init:				; ...
		call	std_printf
		retf

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


Printf_Crlf	proc near		; ...
		call	std_printf
		call	CRLF2
		retn
Printf_Crlf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


std_eprintf	proc near		; ...
		mov	ds:PRINTF_HANDLE, 2
		jmp	short new_printf
std_eprintf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


std_printf	proc near		; ...
		mov	ds:PRINTF_HANDLE, 1

new_printf:				; ...
		push	ax
		push	bx
		push	cx
		push	es
		push	ds
		pop	es
		push	di
		push	si
		push	dx
		mov	ds:print_err_flag, 0 ; mov word	[print_err_flag],0
		mov	si, dx
		lodsw
		push	ax
		lodsb
		mov	cl, al
		xor	ch, ch
		pop	ax
		cmp	cx, 0
		jz	short ready_to_print
		mov	di, offset subst_buffer
		push	di
		push	cx

move_subst:				; ...
		push	cx
		mov	bx, si
		mov	cx, 11		; parm_block_size
		rep movsb
		test	byte ptr [bx+7], 4 ; [bx.$M_S_FLAG],date_type
		jz	short move_subst_cont
		mov	word ptr [bx+2], 0 ; [bx.$M_S_VALUE],0
		mov	word ptr [bx+4], 0 ; [bx.$M_S_VALUE+2],0

move_subst_cont:			; ...
		pop	cx
		loop	move_subst
		pop	cx		; (number of substitutions)
		push	ax		; (Message Number)
		cmp	ds:msg_disp_class, 0FFh	; Util_Msg_Class
		jz	short check_fix
		mov	ds:msg_flag, 1	; ext_msg_class
		mov	di, offset extend_buf_ptr
		xor	ax, ax
		stosw
		stosb

check_fix:				; ...
		pop	ax		; (Message Number)
		pop	di		; (subst_buffer)
		mov	si, di
		mov	bx, si
		push	cx

set_subst:				; ...
		cmp	word ptr [bx+4], 0 ; [bx.$M_S_VALUE+2],0
		jnz	short subst_seg_set
		test	byte ptr [bx+7], 4 ; [bx.$M_S_FLAG],date_type
		jnz	short subst_seg_set
		mov	word ptr [bx+4], cs ; [bx.$M_S_VALUE+2],cs

subst_seg_set:				; ...
		add	bx, 11		; parm_block_size
		loop	set_subst
		pop	cx
		mov	bx, si
		cmp	word ptr [bx+2], offset	string_ptr_2 ;
					; [bx.$M_S_VALUE],offset trangroup:string_ptr_2
		jnz	short ready_to_print
		mov	dx, ds:string_ptr_2
		mov	[bx+2],	dx	; [bx.$M_S_VALUE],dx

ready_to_print:				; ...
		mov	bx, ds:PRINTF_HANDLE
		mov	dl, ds:msg_cont_flag
		mov	dh, ds:msg_disp_class
		mov	ds:msg_cont_flag, 0 ; no_cont_flag (no control flag)
		mov	ds:msg_disp_class, 0FFh	; Util_Msg_Class
		push	ds
		push	es
		call	SYSDISPMSG
		pop	es
		pop	ds
		jnb	short print_success
		mov	ds:print_err_flag, ax ;	cmp word [print_err_flag],0

print_success:				; ...
		pop	dx
		pop	si
		pop	di
		pop	es
		pop	cx
		pop	bx
		pop	ax
		cmp	ds:print_err_flag, 0
		jnz	short print_err
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

print_err:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		cmp	ds:PRINTF_HANDLE, 2
		jnz	short not_stderr
		jmp	TCOMMAND
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

not_stderr:				; ...
		mov	ax, ds:print_err_flag
		mov	es, ds:RESSEG
		assume es:nothing
		test	es:PipeFlag, 0FFh ; -1
		jz	short _go_to_error
		call	PipeOff
		mov	dx, offset PIPEEMES_PTR
		jmp	short print_err_exit
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

_go_to_error:				; ...
		mov	ds:msg_disp_class, 1 ; ext_msg_class
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax

print_err_exit:				; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		jmp	cerror
std_printf	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TSYSLOADMSG	proc near		; ...
		push	bx
		call	SYSLOADMSG
		pop	bx
		retn
TSYSLOADMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


TSYSGETMSG	proc near		; ...
		push	cx
		call	SYSGETMSG
		pop	cx
		retn
TSYSGETMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSLOADMSG	proc near		; ...
		push	ax
		push	bx
		push	dx
		push	es
		push	di
		xor	cx, cx
		mov	es, cx
		assume es:RESGROUP
		xor	di, di
		mov	ax, 122Eh	; DOS_GET_EXT_PARSE_ADD
		mov	dl, 0		; DOS_GET_EXTENDED
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
					; Return: ES:DI	-> error table
		mov	ds:$M_RT_$M_EXT_COMMAND+2, es ;	[$M_RT+10]
		mov	ds:$M_RT_$M_EXT_COMMAND, di ; [$M_RT+8]
		mov	ax, 122Eh
		mov	dl, 2		; DOS_GET_PARSE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get parameter error table (errors 00h-0Ah)
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_PARSE_COMMAND+2, es	; [$M_RT+18]
		mov	ds:$M_RT_$M_PARSE_COMMAND, di ;	[$M_RT+16]
		mov	ax, 122Eh
		mov	dl, 4		; DOS_GET_CRITICAL
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get critical/SHARE	error table (errors 13h-2Bh)
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_CRIT_COMMAND+2, es ; [$M_RT+34]
		mov	ds:$M_RT_$M_CRIT_COMMAND, di ; [$M_RT+32]
		mov	ax, 122Eh
		mov	dl, 6		; DOS_GET_FILE
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; ES:DI	-> error table
		mov	ds:$M_RT_$M_EXT_FILE+2,	es ; [$M_RT+6]
		mov	ds:$M_RT_$M_EXT_FILE, di ; [$M_RT+4]
		call	$M_MSGSERV_1
		mov	ds:$M_RT_$M_EXT_ERR_ADDRS+2, es	; [$M_RT+2]
		mov	ds:$M_RT_$M_EXT_ERR_ADDRS, di ;	[$M_RT+0]
		mov	ds:$M_RT_$M_CRIT_ADDRS+2, es ; [$M_RT+30]
		mov	ds:$M_RT_$M_CRIT_ADDRS,	di ; [$M_RT+28]
		call	$M_MSGSERV_2
		mov	ds:$M_RT_$M_PARSE_ADDRS+2, es ;	[$M_RT+22]
		mov	ds:$M_RT_$M_PARSE_ADDRS, di ; [$M_RT+20]
		mov	ax, 122Eh
		mov	dl, 8
		int	2Fh		; Multiplex - DOS 3+ internal -	GET OR SET ERROR TABLE ADDRESSES
					; DL = subfunction - get ??? error table
					; Return: ES:DI	-> error table
		mov	word ptr ds:$M_RT_$M_DISK_PROC_ADDR+2, es ; [$M_RT+42]
		mov	word ptr ds:$M_RT_$M_DISK_PROC_ADDR, di	; [$M_RT+40]
		mov	ds:$M_RT_$M_CRLF, 0A0Dh	; CRLF
		mov	ds:$M_RT_$M_BUF_TERM, 24h ; '$'
		mov	ds:$M_RT_$M_MSG_NUM, 0 ; $M_NULL
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_BASE10
		call	$M_CLS_3	; Get addressibilty to class F
		mov	ds:$M_RT_$M_CLASS_ADDRS, di ; $M_RT.$M_CLASS_ADDRS+$M_INDEX ; $M_INDEX = 0
					; [$M_RT+44]
		call	$M_GET_DBCS_VEC
		clc
		jb	short $MIF20
		pop	di
		pop	es
		assume es:nothing
		pop	dx
		pop	bx
		pop	ax
		jmp	short $MEN20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF20:					; ...
		add	sp, 10
		stc

$MEN20:					; ...
		retn
SYSLOADMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_DBCS_VEC	proc near		; ...
		push	ax
		push	si
		push	ds
		mov	ax, 6300h
		int	21h		; DOS -	3.2+ only - GET	DOUBLE BYTE CHARACTER SET LEAD TABLE
		push	ds
		pop	es
		pop	ds
		jb	short $MIF23
		mov	ds:$M_RT_$M_DBCS_VEC, si ; $M_RT.$M_DBCS_VEC
					; [$M_RT+60]
		mov	ds:$M_RT_$M_DBCS_VEC+2,	es ; [$M_RT+62]

$MIF23:					; ...
		pop	si
		pop	ax
		retn
$M_GET_DBCS_VEC	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSGETMSG	proc near		; ...
		push	ax
		push	es
		push	di
		push	bp
		call	$M_GET_MSG_ADDRESS
		jb	short $MIF31
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		clc
		jz	short $MIF32
		push	es
		pop	ds
		jmp	short $MEN32
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF32:					; ...
		push	cs
		pop	ds
		assume ds:TRANGROUP

$MEN32:					; ...
		mov	si, di

$MIF31:					; ...
		pop	bp
		pop	di
		pop	es
		pop	ax
		retn
SYSGETMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_MSG_ADDRESS proc	near		; ...

; FUNCTION CHUNK AT 5A3C SIZE 00000007 BYTES

		push	si
		push	bx
		xor	si, si
		xor	cx, cx

$MDO36:					; ...
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jnz	short $MIF37
		mov	di, $M_RT_$M_CLASS_ADDRS[si] ;
					; mov di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
		mov	bx, di
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF37:					; ...
		test	dh, 2		; PARSE_ERR_CLASS
		jz	short $MIF39
		les	di, dword ptr $M_RT_$M_PARSE_COMMAND[si] ;
					; les di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
		mov	bx, es
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF39:					; ...
		cmp	ax, 19		; $M_CRIT_LO
		jb	short $MIF41
		cmp	ax, 39		; $M_CRIT_HI
		ja	short $MIF41
		les	di, dword ptr $M_RT_$M_CRIT_ADDRS[si] ;
					; les di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
		mov	bx, es
		jmp	short $MEN37
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF41:					; ...
		les	di, dword ptr $M_RT_$M_EXT_ERR_ADDRS[si] ;
					; les di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
		mov	bx, es

$MEN37:					; ...
		cmp	bx, 0FFFFh	; $M_TERMINATING_FLAG
		jnz	short $MIF46
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jnz	short $MIF47
		stc
		jmp	short $MEN47
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF47:					; ...
		mov	$M_RT_$M_MSG_NUM, ax ; $M_RT.$M_MSG_NUM
					; [$M_RT+72]
		mov	ax, 0FFFFh	; $M_SPECIAL_MSG_NUM
		mov	bp, 1		; $M_ONE_REPLACE
		xor	si, si
		clc

$MEN47:					; ...
		jmp	short $MEN46
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF46:					; ...
		cmp	bx, 0		; $M_CLASS_NOT_EXIST
		jz	short $MIF51
		call	$M_FIND_SPECIFIED_MSG

$MIF51:					; ...
		add	si, 4		; $M_ADDR_SZ_FAR
		clc

$MEN46:					; ...
		jb	short $MEN36
		or	cx, cx
		jnz	short $MEN36
		jmp	short $MDO36
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN36:					; ...
		pushf
		cmp	dh, 1		; EXT_ERR_CLASS
		jnz	short $MIF56
		push	dx
		push	bp
		push	cx
		push	es
		push	di
		push	ax
		mov	ax, 500h	; IFSFUNC_INSTALL_CHECK
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
					; Return: AL = 00h not installed, OK to	install
					; 01h not installed, can't install
					; FFh installed
		cmp	al, 0FFh	; IFSFUNC_INSTALLED
		pop	ax
		jnz	short $MIF57
		mov	bx, ax
		mov	ax, 502h	; IFS_GET_ERR_TEXT
		int	2Fh		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
		jmp	short $MEN57
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF57:					; ...
		stc

$MEN57:					; ...
		jnb	short $MIF60
		pop	di
		pop	es
		pop	cx
		jmp	short $MEN60
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF60:					; ...
		add	sp, 6
		call	$M_SET_LEN_IN_CX

$MEN60:					; ...
		pop	bp
		pop	dx

$MIF56:					; ...
		jmp	short $M_MYRET
$M_GET_MSG_ADDRESS endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

m_popf_iret:				; ...
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR $M_GET_MSG_ADDRESS

$M_MYRET:				; ...
		push	cs		; $M_POPF (macro)
		call	m_popf_iret
		pop	bx
		pop	si
		retn
; END OF FUNCTION CHUNK	FOR $M_GET_MSG_ADDRESS

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_SET_LEN_IN_CX proc near		; ...
		push	di
		push	ax
		mov	cx, 0FFFFh	; -1 ; 65535
		xor	al, al
		repne scasb
		not	cx
		dec	cx
		pop	ax
		pop	di
		retn
$M_SET_LEN_IN_CX endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_FIND_SPECIFIED_MSG proc near		; ...
		cmp	bx, 1
		jnz	short $MIF64
		cmp	word ptr $M_RT_$M_DISK_PROC_ADDR, 0FFFFh ; [$M_RT+40],-1
		jz	short $MIF64
		cmp	ax, 0FFFFh
		jnz	short $MIF65
		push	ax
		mov	ax, $M_RT_$M_MSG_NUM ; $M_RT.$M_MSG_NUM
					; [$M_RT+72]
		call	$M_RT_$M_DISK_PROC_ADDR	; DWORD	PTR $M_RT.$M_DISK_PROC_ADDR
					; call far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
		pop	ax
		jmp	short $MEN65
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF65:					; ...
		call	$M_RT_$M_DISK_PROC_ADDR	;
					; call far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]

$MEN65:					; ...
		jmp	short $MEN64
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF64:					; ...
		xor	cx, cx
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF69
		mov	cl, es:[di+3]	; BYTE PTR ES:[DI].$M_NUM_CLS_MSG
		jmp	short $MEN69
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF69:					; ...
		cmp	cs:[di], dh	; BYTE PTR CS:[DI].$M_CLASS_ID,DH
		jnz	short $MEN69
		mov	cl, cs:[di+3]	; BYTE PTR CS:[DI].$M_NUM_CLS_MSG

$MEN69:					; ...
		add	di, 4		; $M_CLASS_ID_SZ
		stc

$MEN64:					; ...
		jnb	short $MIF75
		clc

$MDO76:					; ...
		or	cx, cx
		jz	short $MEN76
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF78
		cmp	ax, es:[di]	; WORD PTR ES:[DI].$M_NUM
		jmp	short $MEN78
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF78:					; ...
		cmp	ax, cs:[di]	; WORD PTR CS:[DI].$M_NUM

$MEN78:					; ...
		jnz	short $MIF76
		jmp	short $MSR76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF76:					; ...
		dec	cx
		jz	short $MEN76
		add	di, 4
		jmp	short $MDO76
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN76:					; ...
		stc

$MSR76:					; ...
		jb	short $MIF75
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		clc
		jnz	short $MIF87
		push	cs
		pop	es
		assume es:TRANGROUP

$MIF87:					; ...
		add	di, es:[di+2]	; WORD PTR ES:[DI].$M_TXT_PTR

$MIF75:					; ...
		jb	short $MIF91
		xor	ch, ch
		mov	cl, es:[di]
		inc	di

$MIF91:					; ...
		mov	$M_RT_$M_SIZE, 0 ; $M_RT.$M_SIZE,$M_NULL
					; [$M_RT+66]
		retn
$M_FIND_SPECIFIED_MSG endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SYSDISPMSG	proc near		; ...
		push	ax
		push	bx
		push	cx
		push	bp
		push	di
		push	es
		push	dx
		mov	bp, cx
		mov	$M_RT_$M_HANDLE, bx ; [$M_RT+$M_RES_ADDRS.$M_HANDLE]
					; [$M_RT+64],bx
		mov	$M_RT_$M_CLASS,	dh ; [$M_RT+$M_RES_ADDRS.$M_CLASS]
					; [$M_RT+69],dh
		call	$M_GET_MSG_ADDRESS
		or	cx, cx		; (message length)
		jz	short $MIF93
		or	bp, bp
		jnz	short $MIF94
		call	$M_DISPLAY_STRING ; (es:di = message/text address)
		jmp	short $MEN94
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF94:					; ...
		call	$M_DISPLAY_MESSAGE

$MEN94:					; ...
		jb	short $MIF97
		pop	dx
		call	$M_ADD_CRLF
		pop	es
		assume es:nothing
		pop	di
		or	dl, dl
		jz	short $MIF98
		call	$M_WAIT_FOR_INPUT ; MSDOS 6.0 (to 6.22)

$MIF98:					; ...
		jmp	short $MEN97
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF97:					; ...
		add	sp, 6
		stc

$MEN97:					; ...
		jmp	short $MEN93
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF93:					; ...
		pop	es
		pop	di
		pop	dx
		stc

$MEN93:					; ...
		jb	short $MIF104
		pop	bp
		pop	cx
		pop	bx
		add	sp, 2
		jmp	short $MEN104
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF104:				; ...
		add	sp, 8
		stc

$MEN104:				; ...
		retn
SYSDISPMSG	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_STRING proc near		; ...
		push	ax
		push	bx
		push	dx
		mov	bx, $M_RT_$M_HANDLE ; $M_RT.$M_HANDLE
					; [$M_RT+64]
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jnz	short $MIF107
		call	$M_DISPLAY_$_STRING
		jmp	short $MEN107
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF107:				; ...
		call	$M_DISPLAY_H_STRING

$MEN107:				; ...
		jnb	short $MIF110
		mov	ah, 59h		; DOS_GET_EXT_ERROR
		mov	bx, 0
		int	21h		; DOS -	3+ - GET EXTENDED ERROR	CODE
					; BX = version code (0000h for DOS 3.x)
		xor	ah, ah
		add	sp, 6
		stc
		jmp	short $MEN110
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF110:				; ...
		cmp	bx, 0FFFFh	; $M_NO_HANDLE
		jz	short $MEN110
		cmp	ax, cx
		jz	short $MEN110
		call	$M_GET_EXT_ERR_39
		add	sp, 6
		stc

$MEN110:				; ...
		jb	short $MIF117
		pop	dx
		pop	bx
		pop	ax

$MIF117:				; ...
		retn
$M_DISPLAY_STRING endp ; sp =  6


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_$_STRING proc near		; ...
		push	ds
		push	es
		pop	ds
		assume ds:nothing
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF119
		mov	ah, 2		; DOS_DISP_CHAR
		mov	dl, es:[di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		pop	ds
		mov	al, dl
		call	$M_IS_IT_DBCS
		push	ds
		push	es
		pop	ds
		jnb	short $MIF120
		mov	dl, es:[di+1]
		int	21h		; DOS -
		clc

$MIF120:				; ...
		jmp	short $MEN119
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF119:				; ...
		mov	ah, 2		; DOS_DISP_CHAR

$MDO123:				; ...
		or	cx, cx
		jz	short $MEN119
		mov	dl, es:[di]
		int	21h		; DOS -	DISPLAY	OUTPUT
					; DL = character to send to standard output
		inc	di
		dec	cx
		jnz	short $MDO123

$MEN119:				; ...
		clc
		pop	ds
		retn
$M_DISPLAY_$_STRING endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


scan_ctrlz	proc near		; ...
		push	di
		push	ax
		push	es
		push	bx
		mov	di, dx
		push	ds
		pop	es
		mov	bx, cx
		mov	al, 1Ah		; Ctrl-Z
		cld
		repne scasb
		jnz	short noCtrlz
		sub	bx, cx
		dec	bx

noCtrlz:				; ...
		mov	cx, bx
		pop	bx
		pop	es
		pop	ax
		pop	di
		retn
scan_ctrlz	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_H_STRING proc near		; ...

; FUNCTION CHUNK AT 5BD8 SIZE 00000006 BYTES

		xor	ax, ax
		or	cx, cx
		jz	short $MIF127
		push	ds
		push	es
		pop	ds
		mov	ah, 40h
		mov	dx, di
		cmp	cx, 1		; $M_SINGLE_CHAR
		jnz	short $MIF128
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
		pop	ds
		push	ax
		mov	al, es:[di]
		call	$M_IS_IT_DBCS
		pop	ax
		push	ds
		push	es
		pop	ds
		jnb	short $MIF129
		clc
		mov	ah, 40h
		inc	dx
		int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
					; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer

$MIF129:				; ...
		pushf
		cmp	byte ptr es:[di], 1Ah ;	Ctrl-Z?
		jnz	short m_popf_j	; @@:
		mov	ax, cx

m_popf_j:				; ...
		jmp	short m_popf
$M_DISPLAY_H_STRING endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

intret:					; ...
		iret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
; START	OF FUNCTION CHUNK FOR $M_DISPLAY_H_STRING

m_popf:					; ...
		push	cs		; $M_Popf (macro)
		call	intret
		jmp	short $MEN128
; END OF FUNCTION CHUNK	FOR $M_DISPLAY_H_STRING
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF128:				; ...
		push	bp
		push	cx
		call	scan_ctrlz
		mov	bp, cx
		pop	cx
		int	21h		; DOS -
		jnb	short chk_count
		jmp	short m_cnt_ok
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

chk_count:				; ...
		cmp	cx, ax
		jz	short m_cnt_ok
		cmp	bp, ax
		clc
		jnz	short m_cnt_ok
		mov	ax, cx

m_cnt_ok:				; ...
		pop	bp

$MEN128:				; ...
		pop	ds

$MIF127:				; ...
		retn

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_EXT_ERR_39 proc near		; ...
		mov	ax, 27h		; EXT_ERR_39
		mov	bx, 4		; (ERROR_CLASS_39 SHR 8) + ACTION_39
		mov	ch, 1		; LOCUS_39
		retn
$M_GET_EXT_ERR_39 endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_ADD_CRLF	proc near		; ...
		cmp	dh, 0FFh	; UTILITY_MSG_CLASS
		jz	short $MIF134
		test	dh, 80h		; $M_NO_CRLF_MASK
		jnz	short $MIF134
		push	ds
		pop	es
		lea	di, $M_RT_$M_CRLF ; $M_RT.$M_CRLF
					; [$M_RT+67]
		mov	cx, 2		; $M_CRLF_SIZE
		call	$M_DISPLAY_STRING

$MIF134:				; ...
		retn
$M_ADD_CRLF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_IS_IT_DBCS	proc near		; ...
		push	es
		push	di
		les	di, dword ptr ds:$M_RT_$M_DBCS_VEC ; $M_RT.$M_DBCS_VEC
					; [$M_RT+60]
					; les di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
		or	di, di
		jz	short $MIF138

$MDO139:				; ...
		cmp	word ptr es:[di], 0 ; $M_DBCS_TERM
		clc
		jz	short $MIF138
		cmp	al, es:[di]
		jb	short $MIF141
		cmp	al, es:[di+1]
		ja	short $MIF141
		stc

$MIF141:				; ...
		inc	di
		inc	di
		jmp	short $MDO139
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF138:				; ...
		pop	di
		pop	es
		retn
$M_IS_IT_DBCS	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERT2ASC	proc near		; ...
		pop	ds:$M_RT_$M_RETURN_ADDR	; pop word [$M_RT+70]
		xor	bx, bx
		xchg	ax, bx
		xchg	ax, dx

$MDO145:				; ...
		div	ds:$M_RT_$M_DIVISOR ; div word [$M_RT+74]
		xchg	ax, bx
		div	ds:$M_RT_$M_DIVISOR ; [$M_RT+74]
		cmp	dx, 9
		jbe	short $MIF146
		add	dl, 55		; add dl,37h
		jmp	short $MEN146
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF146:				; ...
		add	dl, '0'         ; 30h

$MEN146:				; ...
		push	dx
		inc	cx
		or	ax, ax
		jnz	short $MLL149
		or	bx, bx
		jz	short $MEN145

$MLL149:				; ...
		cmp	cx, 3		; $M_FIRST_THOU
		jnz	short $MIF150
		cmp	byte ptr [si+0Ah], ',' ;
					; $M_SL.$M_S_PAD,$M_COMMA ($M_SL = [DS:SI])
		jnz	short $MIF151
		push	ds:$M_RT_$M_THOU_SEPARA	; word $M_RT.$M_THOU_SEPARA
		inc	cx

$MIF151:				; ...
		jmp	short $MEN154
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF150:				; ...
		cmp	cx, 7		; $M_SECOND_THOU
					; (It was 'cmp cx,6' in MSDOS 5.0 COMMAND.COM!)
		jnz	short $MIF154
		cmp	byte ptr [si+0Ah], ','
		jnz	short $MIF155
		push	ds:$M_RT_$M_THOU_SEPARA	; [$M_RT+83]
		inc	cx

$MIF155:				; ...
		jmp	short $MEN154
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF154:				; ...
		cmp	cx, 11		; $M_THIRD_THOU
					; (It was 'cmp cx,9' in MSDOS 5.0 COMMAND.COM!)
		jnz	short $MEN154
		cmp	byte ptr [si+0Ah], ',' ; $M_SL.$M_S_PAD,$M_COMMA
		jnz	short $MEN154
		push	ds:$M_RT_$M_THOU_SEPARA	; [$M_RT+83]
		inc	cx

$MEN154:				; ...
		xchg	ax, bx
		xor	dx, dx
		jmp	short $MDO145
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN145:				; ...
		xor	dx, dx
		xor	ax, ax
		push	ds:$M_RT_$M_RETURN_ADDR	; [$M_RT+70]
		retn
$M_CONVERT2ASC	endp ; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_MESSAGE proc	near		; ...
		xor	dx, dx		; $MDO165
		or	cx, cx		; (byte	count of the message/text)
		jz	short $MIF166
		mov	ah, '%'
		mov	al, 0

$MDO167:				; ...
		cmp	es:[di], ah
		jnz	short $MLL168
		cmp	es:[di+1], ah
		jz	short $MLL168
		cmp	al, ah
		jnz	short $MIF166

$MLL168:				; ...
		mov	al, es:[di]
		call	$M_IS_IT_DBCS
		jnb	short $MIF169
		inc	di

$MIF169:				; ...
		inc	di
		inc	dx
		dec	cx
		jnz	short $MDO167

$MIF166:				; ...
		push	si
		xchg	cx, dx
		or	bp, bp
		jz	short $MIF173
		dec	bp
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NULL
					; [$M_RT+72]],0
		jnz	short $MIF173

$MDO175:				; ...
		mov	al, [si+6]	; $M_SL.$M_S_ID
		add	al, 30h
		cmp	al, es:[di+1]
		jnz	short $MIF175
		jmp	short $MIF173
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF175:				; ...
		cmp	al, 30h		; $M_SPECIAL_CASE
		jnz	short $MLL178
		or	dx, dx
		jz	short $MEN175

$MLL178:				; ...
		add	si, [si]	; add si,[si+$M_SUBLIST_STRUC.$M_S_SIZE]
					; add si,[si+0]
		jmp	short $MDO175
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN175:				; ...
		cmp	ds:$M_RT_$M_CLASS, 0FFh	; $M_RT.$M_CLASS,UTILITY_MSG_CLASS
					; cmp byte [$M_RT+69],0FFh
		jnz	short $MIF180
		inc	dx
		inc	dx
		dec	cx
		dec	cx
		dec	di
		dec	di
		jmp	short $MIF173
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF180:				; ...
		mov	dx, -1		; 0FFFFh

$MIF173:				; ...
		push	di
		sub	di, cx
		call	$M_DISPLAY_STRING
		pop	di
		pop	cx
		jnb	short $MXL3
		jmp	$MEN165
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MXL3:					; ...
		push	cx
		mov	cx, dx
		cmp	byte ptr [si+6], 0 ; $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
		jz	short $MIF187
		or	cx, cx
		jz	short $MIF188
		dec	cx
		dec	cx
		inc	di
		inc	di
		jmp	short $MEN188
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF188:				; ...
		pop	si

$MEN188:				; ...
		jmp	short $MEN187
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF187:				; ...
		or	cx, cx
		jnz	short $MIF192
		pop	si
		jmp	short $MEN187
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF192:				; ...
		cmp	cx, -1
		jnz	short $MIF194
		xor	cx, cx

$MIF194:				; ...
		or	di, di

$MEN187:				; ...
		jz	short $MEN165
		push	bp
		push	di
		push	es
		push	cx
		xor	cx, cx
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NULL
					; [$M_RT+72],0
		jnz	short $MIF199
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF200
		les	di, [si+2]	; $M_SL.$M_S_VALUE
		call	$M_CHAR_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF200:				; ...
		test	byte ptr [si+7], 0Dh ;
					; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type AND $M_TYPE_MASK
		jz	short $MLL202
		test	byte ptr [si+7], 0Eh ;
					; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jz	short $MLL202
		test	byte ptr [si+7], 0Ch ;
					; $M_SL.$M_S_FLAG,NOT Bin_Hex_Type AND $M_TYPE_MASK
		jnz	short $MIF202

$MLL202:				; ...
		les	di, [si+2]
		call	$M_BIN2ASC_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF202:				; ...
		test	byte ptr [si+7], 0Bh ; $M_SL.$M_S_FLAG,NOT Date_Type AND $M_TYPE_MASK
					; ($M_SL = [ds:si])
		jnz	short $MIF204
		call	$M_DATE_REPLACE
		jmp	short $MEN200
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF204:				; ...
		call	$M_TIME_REPLACE

$MEN200:				; ...
		call	$M_DISPLAY_REPLACE
		jmp	short $MEN199
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF199:				; ...
		call	$M_EXT_PAR_REPLACE

$MEN199:				; ...
		jb	short $MIF211
		pop	cx
		pop	es
		pop	di
		pop	bp
		pop	si
		jmp	short $MEN211
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF211:				; ...
		add	sp, 10
		stc

$MEN211:				; ...
		cmp	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,$M_NUL
					; cmp word [$M_RT+72],0
		jnz	short $MEN165
		jb	short $MEN165
		jmp	$M_DISPLAY_MESSAGE ; jmp $MDO165
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN165:				; ...
		mov	ds:$M_RT_$M_MSG_NUM, 0 ; $M_RT.$M_MSG_NUM,0
					; mov word [$M_RT+72],0
		retn
$M_DISPLAY_MESSAGE endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_EXT_PAR_REPLACE proc	near		; ...
		xor	dx, dx
		mov	ax, ds:$M_RT_$M_MSG_NUM	; $M_RT.$M_MSG_NUM
					; mov ax,[$M_RT+72]
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; [$M_RT+74],10
		call	$M_CONVERT2ASC

$MDO215:				; ...
		pop	ax
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al ;	[bx+$M_RT+76]
					; [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF216
		call	$M_FLUSH_BUF

$MIF216:				; ...
		dec	cl
		jnz	short $MDO215
		mov	ax, 0A0Dh	; $M_CR_LF
		mov	ds:$M_RT_$M_TEMP_BUF[bx], ax ; $M_RT.$M_TEMP_BUF[BX],AX
		inc	bx
		inc	bx
		call	$M_FLUSH_BUF
		retn
$M_EXT_PAR_REPLACE endp	; sp =	2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DISPLAY_REPLACE proc	near		; ...
		xor	bx, bx
		cmp	byte ptr [si+6], 0 ; $M_SL.$M_S_ID,$M_SPECIAL_CASE-30H
		jnz	short $MIF276
		mov	ds:$M_RT_$M_TEMP_BUF[bx], 2D20h	;
					; $M_RT.$M_TEMP_BUF[BX],$M_SPACE_HYP
		inc	bx
		inc	bx
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], 20h ;
					; $M_RT.$M_TEMP_BUF[BX],$M_SPACE
		inc	bx
		call	$M_FLUSH_BUF

$MIF276:				; ...
		pop	bp
		xor	bx, bx
		xor	dx, dx
		mov	ds:$M_RT_$M_SIZE, cl ; $M_RT.$M_SIZE
					; mov [$M_RT+66],cl
		mov	al, [si+9]	; $M_SL.$M_S_MINW
		cmp	al, cl
		jbe	short $MIF278
		sub	al, cl
		mov	dh, al
		test	byte ptr [si+7], 80h ; BYTE PTR	$M_SL.$M_S_FLAG,Right_Align
		jz	short $MIF278

MDO280:					; ...
		mov	al, [si+0Ah]	; $M_SL.$M_S_PAD
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF281
		call	$M_FLUSH_BUF

$MIF281:				; ...
		dec	dh
		jnz	short MDO280

$MIF278:				; ...
		cmp	byte ptr [si+8], 0 ; $M_SL.$M_S_MAXW,$M_UNLIM_W
		jz	short $MIF286
		cmp	[si+8],	cl	; $M_SL.$M_S_MAXW
		jnb	short $MIF286
		sub	cl, [si+8]
		mov	dl, cl
		mov	cl, [si+8]

$MIF286:				; ...
		or	cx, cx
		jz	short $MIF290

$MDO291:				; ...
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF292
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND	$M_SIZE_MASK
		jz	short $MIF292
		mov	al, es:[di]
		inc	di
		jmp	short $MEN292
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF292:				; ...
		pop	ax

$MEN292:				; ...
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al ;
					; MOV BYTE PTR $M_RT.$M_TEMP_BUF[BX],AL
					; mov [bx+$M_RT+76],al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF295
		call	$M_FLUSH_BUF

$MIF295:				; ...
		dec	cl
		jnz	short $MDO291

$MIF290:				; ...
		test	byte ptr [si+7], 80h ; $M_SL.$M_S_FLAG,Right_Align
		jnz	short $MIF299
		or	dh, dh
		jz	short $MIF299

$MDO301:				; ...
		mov	al, [si+0Ah]	; $M_SL.$M_S_PAD
					; (ds:si+$M_SUBLIST_STRUC.$M_S_PAD)
		mov	byte ptr ds:$M_RT_$M_TEMP_BUF[bx], al
		inc	bx
		cmp	bx, 64		; $M_TEMP_BUF_SZ
		jnz	short $MIF302
		call	$M_FLUSH_BUF

$MIF302:				; ...
		dec	dh
		jnz	short $MDO301

$MIF299:				; ...
		test	byte ptr [si+7], 0Fh ;
					; $M_SL.$M_S_FLAG,NOT Char_Type	AND $M_TYPE_MASK
		jnz	short $MIF307
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Char_field_ASCIIZ AND	$M_SIZE_MASK
		jz	short $MIF307
		jmp	short $MEN307
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF307:				; ...
		or	dl, dl
		jz	short $MEN307

$MDO310:				; ...
		pop	ds:$M_RT_$M_RETURN_ADDR	; pop [$M_RT.$M_RETURN_ADDR]
					; pop word [$M_RT+70]
		dec	dl
		jnz	short $MDO310

$MEN307:				; ...
		call	$M_FLUSH_BUF
		push	bp
		retn
$M_DISPLAY_REPLACE endp	; sp =	4


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_FLUSH_BUF	proc near		; ...
		push	cx
		push	es
		push	di
		push	ds
		pop	es
		mov	cx, bx
		xor	bx, bx
		lea	di, $M_RT_$M_TEMP_BUF ;	$M_RT.$M_TEMP_BUF
					; lea di,[$M_RT+76]
		call	$M_DISPLAY_STRING
		jb	short $MIF314
		pop	di
		pop	es
		pop	cx
		jmp	short $MEN314
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF314:				; ...
		add	sp, 6
		stc

$MEN314:				; ...
		retn
$M_FLUSH_BUF	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CHAR_REPLACE	proc near		; ...
		pop	bp
		test	byte ptr [si+7], 30h ;
					; $M_SL.$M_S_FLAG,NOT Char_Field_Char AND $M_SIZE_MASK
		jnz	short $MIF317
		mov	al, es:[di]
		push	ax
		inc	cx
		call	$M_IS_IT_DBCS
		jnb	short $MIF318
		mov	al, es:[di+1]
		push	ax
		clc

$MIF318:				; ...
		jmp	short $MEN317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF317:				; ...
		mov	al, es:[di]
		or	al, al
		jz	short $MEN321
		inc	di
		inc	cx
		jmp	short $MIF317
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MEN321:				; ...
		sub	di, cx

$MEN317:				; ...
		push	bp
		retn
$M_CHAR_REPLACE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_BIN2ASC_REPLACE proc	near		; ...
		pop	bp
		xor	dx, dx
		xor	ax, ax
		mov	ds:$M_RT_$M_DIVISOR, 10h ; $M_RT.$M_DIVISOR,$M_BASE16
					; mov word [$M_RT+74],16
		xor	bx, bx
		test	byte ptr [si+7], 20h ; $M_SL.$M_S_FLAG,NOT $M_BYTE AND $M_SIZE_MASK
		jnz	short $MIF325
		mov	al, es:[di]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF326
		test	al, 80h		; test al,10000000b
		jz	short $MIF327
		inc	bx		; negative number
		and	al, 7Fh		; and al,01111111b

$MIF327:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10

$MIF326:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jnz	short $MIF330
		mov	ds:$M_RT_$M_DIVISOR, 10	; mov word [$M_RT+74],10

$MIF330:				; ...
		jmp	short $MEN333
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF325:				; ...
		test	byte ptr [si+7], 10h ; $M_SL.$M_S_FLAG,NOT $M_WORD AND $M_SIZE_MASK
		jnz	short $MIF333
		mov	ax, es:[di]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF334
		test	ah, 80h		; test ah,10000000b
		jz	short $MIF335
		inc	bx
		and	ah, 7Fh		; and ah,01111111b

$MIF335:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10

$MIF334:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
		jnz	short $MIF338
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10

$MIF338:				; ...
		jmp	short $MEN333
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF333:				; ...
		mov	ax, es:[di]
		mov	dx, es:[di+2]
		test	byte ptr [si+7], 0Dh ; $M_SL.$M_S_FLAG,NOT Sgn_Bin_Type	AND $M_TYPE_MASK
		jnz	short $MIF341
		test	dh, 80h		; test dh,10000000b
		jz	short $MIF342
		inc	bx
		and	dh, 7Fh		; and dh,01111111b

$MIF342:				; ...
		mov	ds:$M_RT_$M_DIVISOR, 10	; mov word [$M_RT+74],10

$MIF341:				; ...
		test	byte ptr [si+7], 0Eh ; $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
					; ($M_SL = [ds:si]) ($M_SUBLIST_STRUC.$M_S_FLAG	= 7)
		jnz	short $MEN333
		mov	ds:$M_RT_$M_DIVISOR, 10

$MEN333:				; ...
		test	byte ptr [si+7], 40h ; MSDOS 6.22
					; (Custom/International	flag for thousand separator)
		jz	short $MEN325
		push	ax		; MSDOS	6.22
		push	dx
		mov	ah, 38h		; International
		xor	al, al
		lea	dx, $M_RT_$M_TEMP_BUF
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MEN341	; (use country depended	thousand separator)
		mov	byte ptr ds:$M_RT_$M_THOU_SEPARA, ','

$MEN341:				; ...
		mov	al, [si+0Ah]	; (save	pad character)
		mov	di, ax
		pop	dx
		pop	ax
		mov	byte ptr [si+0Ah], ',' ; (comma is needed for converting procedure)
		call	$M_CONVERT2ASC
		mov	ax, di
		mov	[si+0Ah], al	; (restore pad character)
		jmp	short $MEN345	; MSDOS	6.22
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
		nop

$MEN325:				; ...
		call	$M_CONVERT2ASC

$MEN345:				; ...
		or	bx, bx
		jz	short $MIF349
		xor	dx, dx
		mov	dl, '-'         ; $M_NEG_SIGN
		push	dx

$MIF349:				; ...
		push	bp
		retn
$M_BIN2ASC_REPLACE endp	; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_DATE_REPLACE	proc near		; ...
		pop	bp
		mov	ds:$M_RT_$M_DIVISOR, 10	; $M_RT.$M_DIVISOR,$M_BASE10
					; mov word [$M_RT+74],10
		call	$M_GET_DATE
		xor	dx, dx
		xor	ax, ax
		cmp	ds:$M_RT_$M_TEMP_BUF, 0	; $M_RT.$M_DATE_FORMAT,0
					; cmp word [$M_RT+76],0
		jnz	short $MIF351
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; $M_RT.$M_DATE_SEPARA
					; push word [$M_RT+87]
		inc	cx
		xor	ax, ax
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTDATE

$MIF351:				; ...
		cmp	ds:$M_RT_$M_TEMP_BUF, 1	; $M_RT.$M_DATE_FORMAT,1
		jnz	short $MIF353
		call	$M_YEAR
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; push word [$M_RT+87]
		inc	cx
		xor	ax, ax
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3
		call	$M_CONVERTDATE

$MIF353:				; ...
		cmp	ds:$M_RT_$M_TEMP_BUF, 2	; $M_RT.$M_DATE_FORMAT,2
		jnz	short $MIF355
		mov	al, [si+5]
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA
		inc	cx
		mov	al, [si+4]
		call	$M_CONVERTDATE
		push	ds:$M_RT_$M_DATE_SEPARA	; $M_RT.$M_DATE_SEPARA
		inc	cx
		call	$M_YEAR
		call	$M_CONVERTDATE

$MIF355:				; ...
		push	bp
		retn
$M_DATE_REPLACE	endp ; sp = -0Ch


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_DATE	proc near		; ...
		mov	ah, 38h		; DOS_GET_COUNTRY
		mov	al, 0
		lea	dx, $M_RT_$M_TEMP_BUF ;	lea dx,[$M_RT+76]
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF357
		mov	ds:$M_RT_$M_TEMP_BUF, 0	; $M_RT.$M_DATE_FORMAT,$M_DEF_DATE_FORM
		mov	byte ptr ds:$M_RT_$M_DATE_SEPARA, '-' ;
					; $M_RT.$M_DATE_SEPARA,$M_DEF_DATE_SEP
					; mov byte [$M_RT+87],'-'

$MIF357:				; ...
		retn
$M_GET_DATE	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_YEAR		proc near		; ...
		mov	ax, [si+2]	; $M_SL.$M_S_VALUE
					; ($M_SUBLIST_STRUC.$M_S_VALUE = 2)
		test	byte ptr [si+7], 10h ; $M_SL.$M_S_FLAG,Date_MDY_4 AND $M_DATE_MASK
		jnz	short $MIF360
		cmp	ax, 99		; $M_MAX_2_YEAR
		jbe	short $MIF360
		mov	ax, 99

$MIF360:				; ...
		retn
$M_YEAR		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERTDATE	proc near		; ...
		pop	ds:$M_RT_$M_TEMP_BUF ; $M_RT.$M_TEMP_BUF
					; pop word [$M_RT+76]
		mov	ds:$M_RT_$M_SIZE, cl ; $M_RT.$M_SIZE
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, ds:$M_RT_$M_SIZE
		jnz	short $MIF363
		mov	ax, '0'         ; $M_TIMEDATE_PAD
		push	ax
		inc	cx

$MIF363:				; ...
		inc	cx
		push	ds:$M_RT_$M_TEMP_BUF ; push word [$M_RT+76]
		retn
$M_CONVERTDATE	endp ; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_TIME_REPLACE	proc near		; ...
		pop	bp
		mov	ds:$M_RT_$M_DIVISOR, 10	; MOV $M_RT.$M_DIVISOR,$M_BASE10
		call	$M_GET_TIME
		test	byte ptr [si+7], 1 ; $M_SL.$M_S_FLAG,Time_Cty_Type AND $M_TIME_MASK
		jz	short $MIF365
		cmp	ds:$M_RT_$M_TIME_FORMAT, 0 ; $M_RT.$M_TIME_FORMAT
					; cmp byte [$M_RT+93],0
		jnz	short $MIF365
		mov	al, [si+2]	; $M_SL.$M_S_VALUE ($M_SL = [ds:si])
		cmp	al, 12
		jl	short $MLL367
		cmp	al, 23
		jle	short MIF367

$MLL367:				; ...
		mov	al, 'a'         ; $M_AM
		push	ax
		inc	cx
		jmp	short $MIF365
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

MIF367:					; ...
		mov	al, 'p'         ; $M_PM
		push	ax
		inc	cx

$MIF365:				; ...
		xor	ax, ax
		xor	dx, dx
		test	byte ptr [si+7], 20h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND	$M_SIZE_MASK
		jz	short $MIF372
		mov	al, [si+5]	; $M_SL.$M_S_VALUE+3 ($M_SUBLIST_STRUC.$M_S_VALUE = 2)
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_DECI_SEPARA	; $M_RT.$M_DECI_SEPARA
					; push word [$M_RT+85]
		inc	cx

$MIF372:				; ...
		test	byte ptr [si+7], 20h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty AND	$M_SIZE_MASK
		jnz	short $MLL374
		test	byte ptr [si+7], 10h ;
					; $M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
		jz	short $MIF374

$MLL374:				; ...
		mov	al, [si+4]	; $M_SL.$M_S_VALUE+2
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_TIME_SEPARA	; $M_RT.$M_TIME_SEPARA
					; push word [$M_RT+89]
		inc	cx

$MIF374:				; ...
		mov	al, [si+3]	; $M_SL.$M_S_VALUE+1
		call	$M_CONVERTTIME
		push	ds:$M_RT_$M_TIME_SEPARA
		inc	cx
		mov	al, [si+2]	; $M_SL.$M_S_VALUE
		test	byte ptr [si+7], 1 ;
					; $M_SL.$M_S_FLAG,Time_Cty_Type	AND $M_TIME_MASK
		jz	short $MIF376
		cmp	ds:$M_RT_$M_TIME_FORMAT, 0 ; $M_RT.$M_TIME_FORMAT
					; cmp byte [$M_RT+93],0
		jnz	short $MIF376
		cmp	al, 13
		jl	short $MIF378
		sub	al, 12

$MIF378:				; ...
		cmp	al, 0
		jnz	short $MIF376
		mov	al, 12

$MIF376:				; ...
		call	$M_CONVERT2ASC
		push	bp
		retn
$M_TIME_REPLACE	endp ; sp = -8


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_GET_TIME	proc near		; ...
		mov	ah, 38h		; DOS_GET_COUNTRY
		mov	al, 0
		lea	dx, $M_RT_$M_TEMP_BUF
		int	21h		; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
					; get current-country info
					; DS:DX	-> buffer for returned info
		jnb	short $MIF384
		mov	word ptr ds:$M_RT_$M_TIME_FORMAT, 1 ; $M_DEF_TIME_FORM
		mov	byte ptr ds:$M_RT_$M_TIME_SEPARA, ':' ; $M_DEF_TIME_SEP
		mov	byte ptr ds:$M_RT_$M_DECI_SEPARA, '.' ; $M_DEF_DECI_SEP

$MIF384:				; ...
		retn
$M_GET_TIME	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CONVERTTIME	proc near		; ...
		pop	ds:$M_RT_$M_TEMP_BUF ; $M_RT.$M_TEMP_BUF
					; pop word [$M_RT+76]
		mov	ds:$M_RT_$M_SIZE, cl
		call	$M_CONVERT2ASC
		dec	cx
		cmp	cl, ds:$M_RT_$M_SIZE ; $M_RT.$M_SIZE
		jnz	short $MIF386
		mov	ax, '0'         ; $M_TIMEDATE_PAD
		push	ax
		inc	cx

$MIF386:				; ...
		inc	cx
		push	ds:$M_RT_$M_TEMP_BUF
		retn
$M_CONVERTTIME	endp ; sp = -2


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_WAIT_FOR_INPUT proc near		; ...
		push	cx
		push	dx
		push	ds
		cmp	dl, 0C0h	; DOS_CLR_KEYB_BUF_MASK
		jbe	short $MIF388
		mov	al, dl
		and	al, 0Fh		; LOW_NIB_MASK
		mov	ah, 0Ch		; DOS_CLR_KEYB_BUF
		jmp	short $MEN388
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF388:				; ...
		mov	ah, dl

$MEN388:				; ...
		push	es
		pop	ds
		mov	dx, di
		int	21h		; DOS -
		pop	ds
		cmp	dl, 0Ah		; DOS_BUF_KEYB_INP
		clc
		jz	short $MIF391
		call	$M_IS_IT_DBCS
		jnb	short $MIF392
		mov	cl, al
		mov	ah, dl
		int	21h		; DOS -
		mov	ah, cl
		clc
		jmp	short $MIF391
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF392:				; ...
		mov	ah, 0

$MIF391:				; ...
		jb	short $MIF396
		pop	dx
		pop	cx
		jmp	short $MEN396
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

$MIF396:				; ...
		add	sp, 4
		stc

$MEN396:				; ...
		retn
$M_WAIT_FOR_INPUT endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


InitVar		proc near		; ...
		push	ax
		push	cx
		push	di
		push	es
		mov	es, ds:RESSEG
		xor	ax, ax
		mov	es:fUmbTiny, al
		mov	es:fInHigh, al
		mov	es:SegLoad, ax
		mov	es:UmbLoad, 0FFh ; UNSPECIFIED
		mov	es:fm_argc, al
		cld
		mov	cx, 16		; MAXUMB
		mov	di, offset UmbUsed
		rep stosb
		mov	cx, 16		; MAXUMB
		mov	di, offset UmbSize
		rep stosw
		pop	es
		pop	di
		pop	cx
		pop	ax
		retn
InitVar		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FixMem		proc near		; ...
		push	ax
		push	bx
		push	cx
		push	dx
		push	es
		call	fm_link
		call	UmbHead
		jb	short fmX
		mov	es, ax
		xor	dx, dx
		mov	cx, dx
		inc	dx

fm10:					; ...
		mov	al, es:0	; es:[arena_signature]
		mov	bx, es:1	; es:[arena_owner]
		or	bx, dx
		jnz	short fm30

fm20:
		mov	bx, es:3
		mov	es, cx
		assume es:RESGROUP
		mov	es:0, al
		add	bx, es:3	; es:[arena_size]
		add	bx, 1
		mov	es:3, bx

fm30:					; ...
		mov	cx, es
		mov	dx, es:1
		mov	bx, es
		add	bx, es:3
		inc	bx
		mov	es, bx
		assume es:nothing
		cmp	al, 5Ah	; 'Z'
		jnz	short fm10

fmX:					; ...
		call	fm_unlink
		pop	es
		pop	dx
		pop	cx
		pop	bx
		pop	ax
		retn
FixMem		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


fm_link		proc near		; ...
		mov	ax, 5802h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) get UMB link state
		push	es
		mov	es, ds:RESSEG
		mov	es:fm_umb, al
		pop	es
		mov	ax, 5803h
		mov	bx, 1
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
fm_link		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


fm_unlink	proc near		; ...
		xor	bx, bx
		push	ds
		mov	ds, ds:RESSEG
		mov	bl, ds:fm_umb
		pop	ds
		mov	ax, 5803h
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		retn
fm_unlink	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseVar	proc near		; ...
		push	di
		push	ds
		push	es
		push	es
		pop	ds
		cld

pv10:					; ...
		lodsb
		call	isWhite
		jz	short pv10
		cmp	al, '/'         ; SWTCH
		jz	short pv20
		dec	si
		clc
		jmp	short pvX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pv20:					; ...
		lodsb
		and	al, 0DFh	; toUpper (macro)
		cmp	al, 'S'         ; optS ; just read 'S'?
		jnz	short pv30
		call	incArgc		; it is	/S, another arg	for LH is skipped
		push	es
		mov	es, ds:RESSEG
		mov	es:fUmbTiny, 1
		pop	es
		jmp	short pv10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pv30:					; ...
		cmp	al, 'L'         ; optL ; If it's not 'L', it is a bad switch
		jnz	short pvE1
		call	incArgc		; it is	/L, another arg	for LH is skipped
		call	parseL
		jnb	short pv10
		dec	si
		jmp	short pvErr
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

pvE1:					; ...
		mov	ax, 3		; PV_InvSwt ; Unrecognized switch passed

pvErr:					; ...
		dec	si
		dec	si
		stc

pvX:					; ...
		pop	es
		pop	ds
		pop	di
		retn
ParseVar	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


parseL		proc near		; ...
		lodsb
		cmp	al, ':'         ; Make sure they did /L:
		jnz	short plE1

pl10:					; ...
		call	GetXNum
		jb	short plE2
		call	convUMB		; Convert any address to a UMB number
		mov	cl, al
		call	stowUMB		; Mark this UMB	# as used
		jb	short plE2
		call	incArgc		; Each UMB number is another arg for LH	to skip
		lodsb
		cmp	al, ';'         ; Did "umb;" ?
		jz	short pl10	; get another UMB
		call	isWhite		; Did "umb " ?
		jz	short plX	; return
		call	isEOL		; Did "umb" ?
		jz	short plSwX	; backup and exit
		cmp	al, '/'         ; Did "umb/" ? (as in, "/L:1,100;2/S")
		jz	short plSwX	; backup one character and return
		cmp	al, ','         ; Did "umb," ?
		jnz	short plE1	; return error
		call	GetXNum		; Stop on "size;" or "size " or	anything else
		jb	short plE1	; bad size
		call	toPara		; Convert from bytes to	paragraphs
		call	stowSiz		; CL still has the UMB number for this routine
		call	incArgc		; Each UMB size	is another arg for LH to skip
		lodsb
		cmp	al, ';'         ; They did "umb,size;", so get another UMB.
		jz	short pl10
		call	isWhite		; Did it end with whitespace?
		jz	short plX	; we're done here--go back
		call	isEOL		; Did they do "umb,size" and end??? (stupid)
		jz	short plSwX	; backup and exit like everything's ok
		cmp	al, '/'         ; Did they do "umb,size/" ?
		jz	short plSwX	; we're done here

plE1:					; ...
		mov	ax, 1		; PV_InvArg ; we don't know WHAT they did..
		dec	si
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plE2:					; ...
		mov	ax, 2		; PV_BadUMB ; they've specified a UMB twice
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plSwX:					; ...
		dec	si		; we hit a '/' character, back up one char

plX:					; ...
		clc
		retn
parseL		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


incArgc		proc near		; ...
		push	ax
		push	ds		; getdata (macro)
					; getdata al, fm_argc
		mov	ds, ds:RESSEG
		mov	al, ds:fm_argc	; Obtain previous value	of fm_argc,
		pop	ds
		inc	al		; increment it,
		push	es		; putdata (macro)
					; putdata fm_argc, al
		mov	es, ds:RESSEG
		mov	es:fm_argc, al	; and store it right back.
		pop	es
		pop	ax
		retn
incArgc		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isEOL		proc near		; ...
		cmp	al, 0		; Null-terminator
		jz	short ieX
		cmp	al, 0Dh		; Carriage Return
		jz	short ieX
		cmp	al, 0Ah		; LineFeed

ieX:					; ...
		retn
isEOL		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isWhite		proc near		; ...
		cmp	al, 20h	; ' '   ; Space
		jz	short iwX
		cmp	al, 3Dh	; '='   ; Equals (treat as whitespace)
		jz	short iwX
		cmp	al, 9		; Tab

iwX:					; ...
		retn
isWhite		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


unMarkUMB	proc near		; ...
		push	ax
		push	bx
		push	di
		push	es
		mov	es, ds:RESSEG
		xor	ah, ah
		mov	bx, ax
		mov	es:UmbUsed[bx],	0 ; marks the UMB as unused
		cmp	es:UmbLoad, al
		jnz	short umu10
		mov	es:UmbLoad, 0

umu10:					; ...
		pop	es
		pop	di
		pop	bx
		pop	ax
		retn
unMarkUMB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


stowUMB		proc near		; ...
		cmp	al, 16		; MAXUMB
		jb	short su10
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

su10:					; ...
		push	bx
		push	di
		push	si
		push	ds
		push	es
		mov	es, ds:RESSEG
		mov	ds, ds:RESSEG
		cmp	ds:UmbLoad, 0FFh ; UNSPECIFIED
		jnz	short su20
		mov	ds:UmbLoad, al	; remember this	UMB as the load	UMB slot

su20:					; ...
		or	al, al
		jz	short su30	; umb number is	0, nothing to do
		mov	bl, al
		xor	bh, bh
		mov	ax, 1		; Now, AX = 1 and BX = UMB Number
		xchg	al, es:UmbUsed[bx] ; mark the UMB as used
		or	al, al		; If it	was already 1, that means an error
		jz	short su30
		stc			; OOOPS! This one's been used before.

su30:					; ...
		pop	es
		pop	ds
		pop	si
		pop	di
		pop	bx
		retn
stowUMB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


stowSiz		proc near		; ...
		push	bx
		push	di
		push	es
		mov	es, ds:RESSEG
		mov	bl, cl		; bl==UMB number, AX==size
		mov	bh, 0
		shl	bl, 1
		mov	es:UmbSize[bx],	ax ; bx==offset	into array, AX=size
		pop	es
		pop	di
		pop	bx
		retn
stowSiz		endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
gnradix		dw 0			; ...
					; Must be a word--16x16	multiplication

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


toDigit		proc near		; ...
		cmp	ds:gnradix, 16
		jnz	short td20	; Don't check hex digits if radix isn't 16
		cmp	cl, 'a'
		jb	short td10
		cmp	cl, 'f'
		ja	short tdE
		sub	cl, 57h		; 'a'-10 ; 87 ; make 'a' == 10
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

td10:					; ...
		cmp	cl, 'A'
		jb	short td20
		cmp	cl, 'F'
		ja	short tdE
		sub	cl, 37h		; 'A'-10 ; 55 ; make 'A' == 10
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

td20:					; ...
		cmp	cl, '0'
		jb	short tdE
		cmp	cl, '9'
		ja	short tdE
		sub	cl, '0'         ; 30h ;  make '0' == 0
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

tdE:					; ...
		stc
		retn
toDigit		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetXNum		proc near		; ...
		push	bx
		push	cx
		push	ds
		cld
		xor	ax, ax
		xor	bx, bx
		xor	cx, cx
		xor	dx, dx
		mov	ds:gnradix, 10	; default radix	is 10
		mov	cl, es:[si]
		call	toDigit
		jb	short gxnE	; it is	not a digit
		or	cl, cl
		jnz	short gxn20	; Doesn't have '0x'
		mov	cl, es:[si+1]
		cmp	cl, 'x'         ; 'x' means it's hexadecimal
		jz	short gxn10
		cmp	cl, 'X'         ; 'X' means it's hexadecimal
		jnz	short gxn20

gxn10:					; ...
		mov	ds:gnradix, 16	; Since	we read	"0x", march over it.
		inc	si
		inc	si

gxn20:					; ...
		mov	cl, es:[si]	; Now DX:AX=current total,
					; CH=0,	CL=number <=15
		inc	si
		call	toDigit
		jb	short gxnQ	; not a	digit, stop
		call	mul32		; Multiply DX:AX by gnradix
		jb	short gxnX	; (if it's too big, error out)
		add	ax, cx
		adc	dx, bx		; bx = 0
		jb	short gxnX
		jmp	short gxn20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gxnE:					; ...
		stc
		jmp	short gxnX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

gxnQ:					; ...
		dec	si
		clc

gxnX:					; ...
		pop	ds
		pop	cx
		pop	bx
		retn
GetXNum		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


mul32		proc near		; ...
		push	ax
		mov	ax, dx
		mul	ds:gnradix
		jb	short m32E	; too big?
		mov	dx, ax
		pop	ax
		xchg	dx, bx
		mul	ds:gnradix
		xchg	dx, bx
		add	dx, bx
		xor	bx, bx
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

m32E:					; ...
		pop	ax
		retn
mul32		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


toPara		proc near		; ...
		push	cx		; divide DX:AX by 16; result in	AX only
					; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
		mov	cl, 4
		shr	ax, cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
		xchg	ax, dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
		mov	cl, 12
		shl	ax, cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
		or	ax, dx		;    AX=hhhh LLLL llll llll
		pop	cx
		retn
toPara		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UmbHead		proc near		; ...
		push	si
		push	ds
		push	es
		mov	ah, 52h		; DOS_GET_DOS_LISTS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:8Ch	; [DOS_UMB_HEAD]
		cmp	ax, 0FFFFh
		jz	short uhE	; error	(ax = 0FFFFh)
		clc
		jmp	short uhX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

uhE:					; ...
		stc

uhX:					; ...
		pop	es
		pop	ds
		pop	si
		retn
UmbHead		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isSysMCB	proc near		; ...
		push	ax		; sets ZF
					; if ES	points to an MCB owned by "SC"+(8or9)
		mov	ax, es:1	; mov ax, es:[arena_owner]
		cmp	ax, 8		; SystemPSPOwner (for US or Japan)
		jz	short ism10
		cmp	ax, 9		; JapanPSPOwner	(for Japan)
		jz	short ism10
		jmp	short ismX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ism10:					; ...
		mov	ax, es:8	; mov ax, word ptr es:[arena_name]
		cmp	ax, 'CS'        ; 'SC'

ismX:					; ...
		pop	ax
		retn
isSysMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


AddrToUmb	proc near		; ...
		push	cx		; convert segment addr in AX to	UMB number
		push	dx
		push	es
		mov	dx, ax
		call	UmbHead
		jb	short atuE
		mov	es, ax
		xor	cx, cx		; cx = UMB# = 0

atu10:					; ...
		mov	ax, es
		cmp	ax, dx		; Present segment >= given segment?
		jnb	short atuX
		call	isSysMCB
		jnz	short atu20
		inc	cx		; If it	_was_ a	system MCB,
					; we're in a new UMB.

atu20:					; ...
		mov	al, es:0	; mov al, es:[arena_signature]
		cmp	al, 'Z'         ; arena_signature_end
		jz	short atu30	; 'Z' means this was the last MCB
		mov	ax, es
		add	ax, es:3	; NextMCB (macro)
		inc	ax
		mov	es, ax
		jmp	short atu10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

atu30:					; ...
		mov	ax, es
		add	ax, es:3	; add ax, es:[arena_size]
		cmp	ax, dx		; Present >= given?
		jnb	short atuX	; Yes, it _was_	inside

atuE:					; ...
		xor	cx, cx		; Else,	fall through with UMB #	== -1
		dec	cx

atuX:					; ...
		mov	ax, cx		; Return the UMB number	in AX
		pop	es
		pop	dx
		pop	cx
		retn
AddrToUmb	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


convUMB		proc near		; ...
		cmp	ds:gnradix, 16
		jnz	short cu10	; If it	didn't read in hex, it's not an address
		call	AddrToUmb	; convert the address to a UMB number
		cmp	ax, 0FFFFh
		jnz	short cu10
		inc	ax		; If too high, ignore it (make it conventional)

cu10:					; ...
		retn
convUMB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


setUMBs		proc near		; ...
		push	ax
		push	bx
		call	fm_link
		mov	ax, 5800h	; DOS_CHECK_STRATEGY
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: get allocation strategy
		push	es
		mov	es, ds:RESSEG
		mov	es:fm_strat, al	; store	the current strategy
		pop	es
		and	ax, 7Fh		; 0000.0000.0111.1111 == All that other	stuff
		push	ax
		call	loadLow		; returns al==0	if load	low, al==1 if loadhigh
		ror	al, 1		; shift	that to	al==0 or al==0x80
		pop	bx		; restore pushed ax above
		or	bl, al		; now we have 0000.0000.?111.1111 in BX
		mov	ax, 5801h	; DOS_SET_STRATEGY ; with ? ==1	if load	highfirs
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		pop	bx
		pop	ax
		retn
setUMBs		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


loadLow		proc near		; ...
		push	ds		; returns AL==0	if UMB0	== 0, else AL==1
		mov	ds, ds:RESSEG
		mov	al, ds:UmbLoad
		cmp	al, 0FFh	; UNSPECIFIED
		jnz	short ll10
		mov	al, 1		; Return with AL==1 && STC if no UMBs specified
		stc
		jmp	short llX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ll10:					; ...
		or	al, al		; AL=the load UMB: Is it == 0?
		jz	short llX	; yes, CF==0 (from OR) && AL=0,	so just	exit
		mov	al, 1
		clc

llX:					; ...
		pop	ds
		retn
loadLow		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


HideUMBs	proc near		; ...
		push	ax
		push	cx
		push	ds
		push	es
		call	UmbTest		; see if we REALLY linked in anything...
		jb	short husX	; if not, there's nothing for us to do.
		call	FixMem		; concatenate adjacent free MCBs in upper mem
		call	setUMBs		; link UMBs and	set memory-allocation strategy
		push	es
		mov	es, ds:RESSEG
		mov	es:fInHigh, 1	; remember that	we're now running high
		pop	es
		call	GetLoadUMB	; see if they gave us a	list to	leave free
		cmp	al, 0FFh	; UNSPECIFIED ;	if they	didn't,
		jz	short husX	; then we shouldn't do this loop
		xor	cx, cx

hus10:					; ...
		inc	cx		; for each UMB
		cmp	cx, 16
		jnb	short hus20
		mov	al, cl		; stopping as soon as we're outside of the
					; valid	range of UMBs
		push	es
		call	findumb
		pop	es
		jb	short hus20
		call	hideUMB?	; hide what we need to hide
		jmp	short hus10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

hus20:					; ...
		call	GetLoadUMB	; now check if they offered /L:0
		or	al, al		; is the load UMB 0? (-1==unspecified)
		jnz	short husX	; if not, we're done
		call	hl_unlink	; if so, however, fix UMBs and strategy

husX:					; ...
		pop	es
		pop	ds
		pop	cx
		pop	ax
		retn
HideUMBs	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetLoadUMB	proc near		; ...
		push	ds
		mov	ds, ds:RESSEG	; getdata (macro)
					; getdata al,UmbLoad
		mov	al, ds:UmbLoad
		pop	ds
		retn
GetLoadUMB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetLoadSize	proc near
		push	bx
		push	si
		push	ds
		mov	ds, ds:RESSEG
		mov	al, ds:UmbLoad
		xor	ah, ah		; ax==UMB
		mov	bx, offset UmbSize
		shl	al, 1
		add	ax, bx
		mov	si, ax		; ds:si==element index
		lodsw			; ax==size
		pop	ds
		pop	si
		pop	bx
		retn
GetLoadSize	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


GetSize		proc near		; ...
		push	bx
		push	si
		push	ds
		mov	ds, ds:RESSEG
		xor	ah, ah		; ax==UMB
		mov	bx, offset UmbSize
		shl	al, 1
		add	ax, bx
		mov	si, ax		; ds:si==element index
		lodsw			; ax==size
		pop	ds
		pop	si
		pop	bx
		retn
GetSize		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


StoLoadUMB	proc near
		push	es
		mov	es, ds:RESSEG
		mov	es:UmbLoad, al
		pop	es
		retn
StoLoadUMB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


StoLoadSize	proc near
		push	dx
		push	ds
		mov	ds, ds:RESSEG
		mov	dl, ds:UmbLoad	; Put UMB# in DL and size in AX
		pop	ds
		cmp	dl, 0FFh	; UNSPECIFIED
		jz	short sls10
		call	stowSiz

sls10:					; ...
		pop	dx
		retn
StoLoadSize	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


hideUMB		proc near		; ...
		push	ax
		push	es
		call	findumb
		jb	short huX

hu10:					; ...
		call	isSysMCB
		jz	short huX
		call	isFreeMCB	; ZF = 1 if owner is 0
		jnz	short hu20	; ZF = 0
		call	hideMCB

hu20:					; ...
		mov	al, es:0	; mov al, es:[arena_signature]
		cmp	al, 'Z'         ; arena_signature_end
		jz	short huX	; 'Z' means this was the last MCB
		mov	ax, es		; NextMCB (macro)
					; NextMCB es, ax
		add	ax, es:3
		inc	ax
		mov	es, ax
		jmp	short hu10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

huX:					; ...
		pop	es
		pop	ax
		retn
hideUMB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isTiny		proc near		; ...
		push	ax
		push	ds
		mov	ds, ds:RESSEG	; getdata (macro)
					; getdata al, fUmbTiny
		mov	al, ds:fUmbTiny
		pop	ds
		or	al, al
		pop	ax
		retn
isTiny		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isFreeMCB	proc near		; ...
		or	word ptr es:1, 0 ; or es:[arena_owner],	0
		retn
isFreeMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


hideMCB		proc near		; ...
		mov	word ptr es:1, 8 ; mov es:[arena_owner], SystemPSPOwner
		mov	word ptr es:8, 4948h ; 'HIDDEN  '
					; mov word ptr es:[arena_name+0], 'IH'
		mov	word ptr es:0Ah, 4444h ; mov word ptr es:[arena_name+2], 'DD'
		mov	word ptr es:0Ch, 4E45h ; mov word ptr es:[arena_name+4], 'NE'
		mov	word ptr es:0Eh, 2020h ; mov word ptr es:[arena_name+6], '  '
		retn
hideMCB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


unHideMCB	proc near		; ...
		push	ax
		mov	word ptr es:1, 0 ; mov es:[arena_owner], FreePSPOwner
		mov	ax, 2020h	; mov ax, '  '
		mov	es:8, ax	; mov word ptr es:[arena_name+0], ax
		mov	es:0Ah,	ax	; mov word ptr es:[arena_name+2], ax
		mov	es:0Ch,	ax	; mov word ptr es:[arena_name+4], ax
		mov	es:0Eh,	ax	; mov word ptr es:[arena_name+6], ax
		pop	ax
		retn
unHideMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


findumb		proc near		; ...
		push	ax		; makes	ES:0 point to the first	MCB in UMB given as AL
		push	cx
		push	dx
		xor	ah, ah
		mov	dx, ax		; Store	the to-be-found	UMB number in DX
		call	UmbHead		; Returns first	UMB segment in AX
		mov	es, ax
		xor	cx, cx		; Pretend we're on UMB 0 for now.

fu10:					; ...
		cmp	cx, dx
		jz	short fuX
		call	isSysMCB	; Returns with ZF set if owner is SYSTEM
		jnz	short fu20
		inc	cx		; If it	_was_ SYSTEM, we're in a new UMB

fu20:					; ...
		mov	al, es:0	; mov al, es:[arena_signature]
		cmp	al, 5Ah	; 'Z'   ; cmp al, arena_signature_end
		jz	short fuE	; 'Z' means this was the last MCB
		mov	ax, es		; NextMCB (macro)
					; NextMCB es, ax
		add	ax, es:3
		inc	ax
		mov	es, ax
		jmp	short fu10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fuE:					; ...
		stc

fuX:					; ...
		pop	dx
		pop	cx
		pop	ax
		retn
findumb		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


BigFree		proc near		; ...
		push	bx		; makes	ES:0 point to the largest free MCB in UMB given	as AL
		push	cx
		call	findumb
		jb	short bfX
		xor	bx, bx		; Segment address of largest free MCB
		xor	cx, cx		; Size of largest free MCB

bf10:					; ...
		call	isSysMCB	; If we've left the MCB, we're done
		jz	short bf30
		call	isFreeMCB	; Returns with ZF set if owner is 0
		jnz	short bf20
		cmp	cx, es:3	; es:[arena_size]
		jg	short bf20
		mov	bx, es
		mov	cx, es:3

bf20:					; ...
		mov	al, es:0	; es:[arena_signature]
		cmp	al, 5Ah	; 'Z'   ; arena_signature_end
		jz	short bf30
		mov	ax, es		; NextMCB es, ax
		add	ax, es:3
		inc	ax
		mov	es, ax
		jmp	short bf10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

bf30:					; ...
		mov	es, bx
		mov	ax, cx
		or	bx, bx
		jnz	short bfX	; (if size==0, there's nothing free)
		stc

bfX:					; ...
		pop	cx
		pop	bx
		retn
BigFree		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isSpecified	proc near		; ...
		push	ax		; sets ZF if UMB in AL wasn't specified in DH/LH line
		xor	bh, bh
		mov	bl, al
		push	ds		; getdata al, ds:UmbUsed[bx]
		mov	ds, ds:RESSEG
		mov	al, ds:UmbUsed[bx]
		pop	ds
		or	al, al		; Sets ZF if al==0 (ie,	if unspecified)
		pop	ax
		retn
isSpecified	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


shrinkMCB	proc near		; ...
		push	bx		; breaks an MCB	into two pieces,
					; the lowest one's size==AX
		push	cx
		push	es
		mov	bx, ax
		mov	ax, es
		mov	cx, es:3	; es:[arena_size]
		sub	cx, 32		; MIN_SPLIT_SIZE
		cmp	bx, cx		; {New size} vs	{Current Size-20h}
		ja	short smE	; if wanted_size > cur-20h, abort.
		mov	dl, es:0	; es:[arena_signature]
		mov	cx, es:3	; es:[arena_size]
		mov	es:3, bx
		mov	byte ptr es:0, 'M' ; 4Dh
		add	ax, bx
		inc	ax
		mov	es, ax		; move to new arena area
		mov	ax, cx
		sub	ax, bx
		dec	ax		; and prepare the new size
		mov	es:0, dl
		mov	word ptr es:1, 0 ; es:[arena_owner]
		mov	es:3, ax	; es:[arena_size]
		mov	ax, 2020h
		mov	es:8, ax	; es:[arena_name+0]
		mov	es:0Ah,	ax
		mov	es:0Ch,	ax
		mov	es:0Eh,	ax	; es:[arena_name+6]
		clc
		jmp	short smX
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

smE:					; ...
		stc

smX:					; ...
		pop	es
		pop	cx
		pop	bx
		retn
shrinkMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


hideUMB?	proc near		; ...
		push	bx		; hides	as appropriate the UMB in CL
		push	dx
		push	es
		mov	al, cl
		call	isSpecified	; Returns ZF set if al's umb was NOT specified.
		jz	short hu?20
		mov	al, cl		; Retrieve the size of the largest
		call	BigFree		; free element in AX; put its address in ES.
		jb	short hu?20	; Oops.	Errors mean skip this part.
		push	ax
		mov	al, cl
		call	GetSize		; Retrieve the user's specified
					; minimum size for this	umb (into AX).
		pop	bx		; Now BX==BigFree, AX==Specified Size
		or	ax, ax
		jz	short hu?20	; If they didn't specify one,
					; skip over all	this.
		cmp	ax, bx		; if (specified	> max free)
		jbe	short hu?10
		mov	al, cl		; Then mark that UMB as	unused.
		call	unMarkUMB
		jmp	short hu?20
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

hu?10:					; ...
		call	isTiny		; Returns ZF clear if user specified /S.
		jz	short hu?20
		call	shrinkMCB	; They specified /S, so	shrink the MCB to AX.
		jb	short hu?20	; if didn't shrink after all, skip this
		mov	dx, es
		jmp	short hu?30	; Skip the spec	check.
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

hu?20:					; ...
		mov	ax, cx
		call	isSpecified	; If they specified this UMB, we're done.
		jnz	short hu?X
		xor	dx, dx

hu?30:					; ...
		mov	al, cl
		call	hideUMB		; Hides	everything in UMB #al
		or	dx, dx		; Did we shrink	a UMB? If not, DX==0,
		jz	short hu?X	; So we	should leave.
		mov	es, dx		; DX==the MCB's address
		call	unHideMCB	; Un-hides the lower portion of	that MCB.

hu?X:					; ...
		pop	es
		pop	dx
		pop	bx
		retn
hideUMB?	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UnFreeze	proc near
		push	ax		; Marks	FROZEN elements	as FREE
		push	es
		call	UmbHead		; Returns with carry if	err, else ES ==	MCB
		jb	short ufX
		mov	es, ax

uf10:					; ...
		call	isFrozMCB	; Returns with ZF set if MCB is	FROZEN
		jnz	short uf20
		call	unHideMCB

uf20:					; ...
		mov	al, es:0	; es:[arena_signature]
		cmp	al, 5Ah	; 'Z'   ; 'Z' means this was the last MCB.
		jz	short ufX
		mov	ax, es		; NextMCB es, ax
					; Go on	forward.
		add	ax, es:3	; es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short uf10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

ufX:					; ...
		pop	es
		pop	ax
		retn
UnFreeze	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


isFrozMCB	proc near		; ...
		push	ax
		mov	ax, es:1	; es:[arena_owner]
		cmp	ax, 8		; SystemPSPOwner
		jnz	short ifmX
		mov	ax, es:8	; 'FROZEN  '
					; mov ax, word ptr es:[arena_name]
		cmp	ax, 'RF'        ; 4256h
		jnz	short ifmX
		mov	ax, es:0Ah
		cmp	ax, 'ZO'        ; 5A4Fh
		jnz	short ifmX
		mov	ax, es:0Ch
		cmp	ax, 'NE'        ; 4E45h
		jnz	short ifmX
		mov	ax, es:0Eh
		cmp	ax, '  '        ; 2020h

ifmX:					; ...
		pop	ax
		retn
isFrozMCB	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


frezMCB		proc near		; ...
		mov	word ptr es:1, 8 ; mov es:[arena_owner], SystemPSPOwner
		mov	word ptr es:8, 'RF' ; 'FROZEN  '
					; mov word ptr es:[arena_name+0], 'RF'
		mov	word ptr es:0Ah, 'ZO'
		mov	word ptr es:0Ch, 'NE'
		mov	word ptr es:0Eh, '  ' ;
					; mov word ptr es:[arena_name+6], 2020h
		retn
frezMCB		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


FreezeUM	proc near
		push	ax
		push	cx
		push	dx
		push	es
		call	GetLoadUMB
		xor	ah, ah
		mov	dx, ax		; Store	the load UMB in	DX, so we can skip it
		call	UmbHead		; Returns first	UMB segment in AX
		mov	es, ax
		xor	cx, cx

fum10:					; ...
		call	isSysMCB	; Returns with ZF set if owner is SYSTEM
		jnz	short fum20
		inc	cx		; If it	_was_ SYSTEM, we're in a new UMB.

fum20:					; ...
		cmp	cx, dx
		jz	short fum30
		call	isFreeMCB	; If it's not free, we can't freeze it.
		jnz	short fum30
		call	frezMCB

fum30:					; ...
		mov	al, es:0	; es:[arena_signature]
		cmp	al, 'Z'         ; arena_signature_end
		jz	short fumX	; 'Z' means this was the last MCB.
		mov	ax, es		; NextMCB es, ax
					; Go on	forward.
		add	ax, es:3	; es:[arena_size]
		inc	ax
		mov	es, ax
		jmp	short fum10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

fumX:					; ...
		pop	es
		pop	dx
		pop	cx
		pop	ax
		retn
FreezeUM	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


UmbTest		proc near		; ...
		push	ax		; returns with carry set if UMBs are not available,
					; else CF==false
		push	bx
		push	ds
		push	es
		call	fm_link		; Link in UMBs (if not already linked)
		call	WalkMem		; Check	to see if they're really linked
		pushf			; remember what	we found out.
		call	fm_unlink	; Unlink UMBs (if WE have linked them)
		popf			; restore what we found	out.
		pop	es
		pop	ds
		pop	bx
		pop	ax
		retn
UmbTest		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


WalkMem		proc near		; ...
		push	ax		; travels memory chain
					; and returns carry clear if UMBs are linked
		push	bx
		push	es
		mov	ah, 52h		; DOS_GET_DOS_LISTS
		int	21h		; DOS -	2+ internal - GET LIST OF LISTS
					; Return: ES:BX	-> DOS list of lists
		mov	ax, es:[bx-2]
		mov	es, ax

um10:					; ...
		mov	al, es:0	; es:[arena_signature]
		cmp	al, 'Z'         ; 5Ah, arena_signature_end
		jz	short um20
		mov	bx, es		; NextMCB es, bx
		add	bx, es:3
		inc	bx
		mov	es, bx
		jmp	short um10
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

um20:					; ...
		mov	ax, es
		cmp	ax, 9FFFh	;  This	sets CF	if ax <	9FFF.
		pop	es
		pop	bx
		pop	ax
		retn
WalkMem		endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


hl_unlink	proc near		; ...
		xor	bh, bh
		push	ds
		mov	ds, ds:RESSEG
		mov	bl, ds:fm_umb	; Restore original link-state
		pop	ds
		mov	ax, 5803h	; DOS_SET_UMBLINK
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: (DOS 5beta) set UMB link state
		xor	bh, bh
		push	ds
		mov	ds, ds:RESSEG
		mov	bl, ds:fm_strat	; Restore original mem-alloc strategy
		pop	ds
		mov	ax, 5801h	; DOS_SET_STRATEGY
		int	21h		; DOS -	3+ - GET/SET MEMORY ALLOCATION STRATEGY
					; AL = function	code: set allocation strategy
		retn
hl_unlink	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LoadHigh:				; ...
		push	ds
		pop	es
		call	ParseLhCmd	; parse	the command line
		jb	short LhErr
		call	SetupCmdLine	; setup	pgm's command line
		call	SetupPath	; setup	path for file
		jb	short LhErr
		call	HideUMBs	; prepare upper-memory for load
		jmp	LH_EXECUTE	; go and exec file
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

LhErr:					; ...
		jmp	cerror		; print	error message and recycle

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


ParseLhCmd	proc near		; ...
		mov	si, 81h		; iCmdLine
					; ds:si	points at command line
		push	es
		push	ds
		pop	es
		call	InitVar		; Initialize data for ParseVar
		call	ParseVar	; And parse the	command	line
		pop	es
		jnb	short plcC
		cmp	ax, 2		; PV_BadUMB ; Bad UMB passed?
		jnz	short plc10
		mov	dx, offset LhBadUMB_Ptr
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plc10:					; ...
		mov	dx, offset LhInvSwt_Ptr
		cmp	ax, 3		; PV_InvSwt ; Unrecognized switch passed?
		jz	short plc20
		mov	dx, offset LhInvArg_Ptr

plc20:					; ...
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

plcC:					; ...
		call	LhCopyFilename	; copy filename	into our buffer
		retn
ParseLhCmd	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LhCopyFilename	proc near		; ...
		mov	di, offset EXECPATH
		mov	cx, 0

lhcpfn1:				; ...
		lodsb
		cmp	al, '*'         ; wildcard? (*)
		jz	short lhfilerr
		cmp	al, '?'         ; wildcard? (?)
		jz	short lhfilerr
		cmp	al, 0Dh		; carriage return?
		jz	short lhcpfn2
		cmp	al, ds:SWITCHAR	; '/'?
		jz	short lhcpfn2
		or	al, al		; EOS?
		jz	short lhcpfn2
		cmp	al, 20h	; ' '   ; Space?
		jz	short lhcpfn2
		or	al, al
		jz	short lhcpfn2
		stosb			; store	char
		inc	cx		; number of chars stored
		jmp	short lhcpfn1
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lhcpfn2:				; ...
		xor	al, al
		stosb
		or	cx, cx		; If we	didn't copy any characters,
		jz	short lhmissing	; they didn't give a filename.
		dec	si
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lhfilerr:				; ...
		mov	dx, offset LhInvFil_Ptr	; "Invalid Filename"
		stc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

lhmissing:				; ...
		mov	dx, offset ReqParmMiss ; "Required parm	missing"
		stc
		retn
LhCopyFilename	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupCmdLine	proc near		; ...
		mov	di, 81h		; iCmdLine
		xor	cl, cl
		dec	cl		; just CR means	count =	0

scmdl1:					; ...
		lodsb
		stosb
		inc	cl		; update count
		or	al, al
		jz	short scmdl2
		cmp	al, 0Dh		; carriage return?
		jnz	short scmdl1	; no, continue storing

scmdl2:					; ...
		mov	es:80h,	cl	; store	new cmd	line length
		retn
SetupCmdLine	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


LhSetupErrMsg	proc near		; ...
		mov	ds:msg_disp_class, 1 ; EXT_MSG_CLASS
		mov	dx, offset extend_buf_ptr
		mov	ds:extend_buf_ptr, ax
		retn
LhSetupErrMsg	endp


; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


SetupPath	proc near		; ...
		mov	ax, ds:ARG_ARGVCNT ; arg.argvcnt
					; total	number of arguments
		dec	ax
		mov	bx, 11		; SIZE Argv_ele
		mul	bx		; dx:ax	= size of argument lists
		push	ds		; getdata (macro)
					; getdata cl, fm_argc
					; CL = number of arguments to skip
		mov	ds, ds:RESSEG
		mov	cl, ds:fm_argc
		pop	ds
		inc	cl		; Skip one arg,	to get over "lh"

argloop:				; ...
		jcxz	short argdone
		dec	cx
		push	ax
		push	cx
		mov	cx, ax
		mov	di, offset ARG_ARGV ; offset TRANGROUP:Arg
					; Copy TO argv[0]
		mov	si, di
		add	si, 11		; SIZE Argv_ele
					; Copy FROM argv[1]
		cld
		rep movsb		; Move the argument list
		dec	ds:ARG_ARGVCNT	; arg.argvcnt
					; Fake one less	argument, and
		sub	ax, 11		; there's one argument we don't copy.
		pop	cx
		pop	ax
		jmp	short argloop
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

argdone:				; ...
		call	path_search	; look in the path
					;
					; ax = 0, no file found
					; ax < 4, batch	file found -- cant be executed
					; ax = 4,8 => .com or .exe file	found
					;
		or	ax, ax		; any file found?
		jz	short no_exec_file ; no, error
		cmp	ax, 4		; executable file?
		jl	short no_exec_bat ; no,	indicate fail
		clc
		retn
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_exec_bat:				; ...
		mov	dx, offset NoExecBat_Ptr ; offset TRANGROUP:NoExecBat_Ptr
					; Setup	message	ptr
		jmp	short lhsp_errret
; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ

no_exec_file:				; ...
		mov	ax, 2		; ERROR_FILE_NOT_FOUND
		call	LhSetupErrMsg	; setup	error message

lhsp_errret:				; ...
		stc
		retn
SetupPath	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_3_STRUC db 0FFh		; ...
		dw 1606h		; $M_COMMAND_VER (COMMAND.COM version)
		db 187			; Total	number of messages
$M_ID_3_1	dw 1020
		dw 748
$M_ID_3_2	dw 1015
		dw 760
$M_ID_3_3	dw 1004, 792,1026, 814,1031, 830,1035, 841,1062, 852
		dw 1028, 863,1045, 893,1041, 918,1042, 948,1043, 971
		dw 1002, 999,1003,1035,1007,1059,1008,1082,1009,1100
		dw 1010,1117,1011,1145,1014,1168,1016,1181,1017,1219
		dw 1018,1252,1019,1268,1021,1276,1022,1302,1023,1337
		dw 1024,1377,1025,1396,1027,1416,1029,1445,1030,1459
		dw 1032,1470,1033,1490,1034,1508,1036,1526,1037,1543
		dw 1038,1556,1039,1571,1040,1628,1044,1645,1046,1661
		dw 1047,1712,1048,1733,1049,1747,1050,1753,1051,1780
		dw 1052,1793,1053,1812,1054,1846,1055,1881,1056,1891
		dw 1057,1902,1059,1911,1060,1912,1061,1912,1063,1934
		dw 1064,1933,1065,1932,1066,1931,1067,1930,1068,1928
		dw 1069,1935,1070,1935,1071,1934,1072,1933,1073,1939
		dw 1074,1945,1075,1951,1076,1953,1077,1952,1078,1956
		dw 1079,1979,1080,1986,1081,2004,1082,2043,1083,2047
		dw 1084,2046,1090,2058,1091,2068,1092,2078,1093,2088
		dw 1094,2105,1095,2130,1096,2155,1097,2200,1098,2225
		dw 1099,2250,1100,2268,1101,2302,1102,2313,1103,2367
		dw 1104,2390,1105,2390,1200,2391,1300,2388,1320,2519
		dw 1321,2579,1340,2688,1341,2776,1342,2871,1360,3013
		dw 1400,3037,1401,3190,1402,3291,1403,3406,1404,3466
		dw 1405,3579,1406,3690,1407,3753,1420,3885,1440,4020
		dw 1441,4110,1460,4238,1461,4335,1462,4463,1480,4539
		dw 1481,4673,1482,4700,1483,4777,1484,4863,1485,4986
		dw 1486,5106,1487,5252,1488,5319,1489,5443,1490,5505
		dw 1491,5529,1492,5608,1493,5751,1494,5770,1500,5796
		dw 1520,5855,1540,5913,1541,6003,1542,6107,1560,6163
		dw 1561,6215,1562,6336,1563,6380,1564,6419,1565,6477
		dw 1566,6526,1567,6567,1568,6685,1580,6758,1600,6826
		dw 1601,6851,1602,6931,1620,7088,1621,7172,1622,7298
		dw 1640,7370,1641,7412,1660,7540,1680,7607,1700,7641
		dw 1720,7815,1740,7894,1741,7982,1760,8093,1780,8166
		dw 1800,8270,1801,8344,1820,8428,1821,8496,1840,8631
		dw 1860,8702,1861,8789,1862,8856,1863,8978,1864,9137
		dw 1865,9236,1866,9339,1880,9439,1881,9555,1882,9677
		dw 1883,9760,1900,9919,1920,9939,1921,9983,1922,10137
		dw 1923,10316,1924,10446,1925,10570,1926,10698
$M_ID_3_187	dw 1927			; Message Number = 1927
		dw 10782		; Message offset from message number
MSG_1020	db 0Fh
		db '%1 bytes free',0Dh,0Ah
MSG_1015	db 23h
		db 'File cannot be copied onto itself',0Dh,0Ah
MSG_1004	db 19h
		db 'Insufficient disk space',0Dh,0Ah
MSG_1026	db 13h
		db 'Invalid code page',0Dh,0Ah
MSG_1031	db 0Eh
		db 'Invalid date',0Dh,0Ah
MSG_1035	db 0Eh
		db 'Invalid time',0Dh,0Ah
MSG_1062	db 0Eh
		db 'Invalid path',0Dh,0Ah
MSG_1028	db 21h
		db 'Press any key to continue . . .',0Dh,0Ah
MSG_1045	db 1Ch
		db 'Unable to create directory',0Dh,0Ah
MSG_1041	db 21h
		db 'Volume in drive %1 has no label',0Dh,0Ah
MSG_1042	db 1Ah
		db 'Volume in drive %1 is %2',0Dh,0Ah
MSG_1043	db 1Fh
		db 'Volume Serial Number is %1-%2',0Dh,0Ah
MSG_1002	db 27h
		db 'Duplicate file name or file not found',0Dh,0Ah
MSG_1003	db 1Bh
		db 'Invalid path or file name',0Dh,0Ah
MSG_1007	db 1Ah
		db 'Out of environment space',0Dh,0Ah
MSG_1008	db 15h
		db 'File creation error',0Dh,0Ah
MSG_1009	db 14h
		db 'Batch file missing',0Dh,0Ah
MSG_1010	db 1Fh
		db 0Dh,0Ah
		db 'Insert disk with batch file',0Dh,0Ah
MSG_1011	db 1Ah
		db 'Bad command or file name',0Dh,0Ah
MSG_1014	db 10h
		db 'Access denied ',0Dh,0Ah
MSG_1016	db 29h
		db 'Content of destination lost before copy',0Dh,0Ah
MSG_1017	db 24h
		db 'Invalid filename or file not found',0Dh,0Ah
		db 13h
		db '%1 file(s) copied',0Dh,0Ah
		db 0Bh
		db '%1 file(s) '
		db 1Dh
		db 'Invalid drive specification',0Dh,0Ah
		db 26h
		db 'Code page %1 not prepared for system',0Dh,0Ah
		db 2Bh
		db 'Code page %1 not prepared for all devices',0Dh,0Ah
		db 16h
		db 'Active code page: %1',0Dh,0Ah
		db 17h
		db 'NLSFUNC not installed',0Dh,0Ah
		db 20h
		db 'Current drive is no longer valid'
		db 11h
		db 'Label not found',0Dh,0Ah
		db 0Eh
		db 'Syntax error',0Dh,0Ah
		db 17h
		db 'Current date is %1 %2',0Dh,0Ah
		db 15h
		db 'SunMonTueWedThuFriSat'
		db 15h
		db 'Enter new date (%1): '
		db 14h
		db 'Current time is %1',0Dh,0Ah
		db 10h
		db 'Enter new time: '
		db 12h
		db ',    Delete (Y/N)?'
		db 3Ch
		db 'All files in directory will be deleted!',0Dh,0Ah
		db 'Are you sure (Y/N)?'
		db 14h
		db 'MS-DOS Version %1.%2'
		db 13h
		db 'Invalid directory',0Dh,0Ah
		db 36h
		db 'Invalid path, not directory,',0Dh,0Ah
		db 'or directory not empty',0Dh,0Ah
		db 18h
		db 'Must specify ON or OFF',0Dh,0Ah
		db 11h
		db 'Directory of %1',0Dh,0Ah
		db 9
		db 'No Path',0Dh,0Ah
		db 1Eh
		db 'Invalid drive in search path',0Dh,0Ah
		db 10h
		db 'Invalid device',0Dh,0Ah
		db 16h
		db 'FOR cannot be nested',0Dh,0Ah
		db 25h
		db 'Intermediate file error during pipe',0Dh,0Ah
		db 26h
		db 'Cannot do binary reads from a device',0Dh,0Ah
MSG_1055	db 0Dh
		db 'BREAK is %1',0Dh,0Ah
		db 0Eh
		db 'VERIFY is %1',0Dh,0Ah
		db 0Ch
		db 'ECHO is %1',0Dh,0Ah
		db 4
		db 'off',0
		db 3
		db 'on',0
MSG_1061	db 19h
		db 'Error writing to device',0Dh,0Ah
MSG_1063	db 2
		db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
		db 2
		db '%1'
MSG_1067	db 1
		db 9
MSG_1068	db 10
		db ' <DIR>    '
		db 3
		db    8, 20h,	8
MSG_1070	db 2
		db  0Dh, 0Ah
		db 2
		db '%1'
MSG_1072	db 9
		db 'mm-dd-yy',0
MSG_1073	db 9
		db 'dd-mm-yy',0
MSG_1074	db 9
		db 'yy-mm-dd',0
MSG_1075	db 5
		db '%1 %2'
		db 2
		db '%1'
		db 7
		db ' %1  %2'
MSG_1078	db 1Ah
		db 'Directory already exists',0Dh,0Ah
MSG_1079	db 10
		db '%1 bytes',0Dh,0Ah
MSG_1080	db 15h
		db 'Total files listed:',0Dh,0Ah
		db 2Ah
		db '(Error occurred in environment variable)',0Dh,0Ah
MSG_1082	db 7
		db ' [Y/N]?'
MSG_1083	db 2
		db 'YN'
MSG_1084	db 0Fh
		db '(continuing %1)'
		db 0Dh
		db 'Revision %1',0Dh,0Ah
		db 0Dh
		db 'DOS is in ROM'
		db 0Dh
		db 'DOS is in HMA'
		db 14h
		db 'DOS is in low memory'
		db 1Ch
		db 'Cannot Loadhigh batch file',0Dh,0Ah
MSG_1095	db 28
		db 'LoadHigh: Invalid filename',0Dh,0Ah
		db 30h
		db 'Cannot open specified country information file',0Dh,0Ah
MSG_1097	db 28
		db 'LoadHigh: Invalid argument',0Dh,0Ah
MSG_1098	db 28
		db 'Required parameter missing',0Dh,0Ah
		db 21
		db 'Unrecognized switch',0Dh,0Ah
		db 37
		db 'A bad UMB number has been specified',0Dh,0Ah
MSG_1101	db 14
		db '  %1.%2 to 1.0'
MSG_1102	db 57
		db '                 %1.%2 to 1.0 average compression ratio',0Dh,0Ah
MSG_1103	db 26
		db 'Overwrite %1 (Yes/No/All)?'
MSG_1104	db 3			; ...
_Y_es		db 'Y'                  ; ...
_N_o		db 'N'                  ; ...
_A_ll		db 'A'                  ; ...
MSG_1105	db 4
		db '    '
MSG_1200	db 0
MSG_1300	db 86h
		db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
		db 0Dh,0Ah
		db 'BREAK [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type BREAK without a parameter to display the current BREAK setti'
		db 'ng.',0Dh,0Ah
		db 3Fh
		db 'Displays or sets the active code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHCP [nnn]',0Dh,0Ah
		db 0Dh,0Ah
		db 70h
		db '  nnn   Specifies a code page number.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type CHCP without a parameter to display the active code page num'
		db 'ber.',0Dh,0Ah
		db 5Bh
		db 'Displays the name of or changes the current directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CHDIR [drive:][path]',0Dh,0Ah
		db 'CHDIR[..]',0Dh,0Ah
		db 62h
		db 'CD [drive:][path]',0Dh,0Ah
		db 'CD[..]',0Dh,0Ah
		db 0Dh,0Ah
		db '  ..   Specifies that you want to change to the parent directory.'
		db 0Dh,0Ah
		db 0Dh,0Ah
		db 91h
		db 'Type CD drive: to display the current directory in the specified '
		db 'drive.',0Dh,0Ah
		db 'Type CD without parameters to display the current drive and direc'
		db 'tory.',0Dh,0Ah
		db 1Bh
		db 'Clears the screen.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CLS',0Dh,0Ah
MSG_1400	db 156
		db 'Copies one or more files to another location.',0Dh,0Ah
		db 0Dh,0Ah
		db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [des'
		db 'tination',0Dh,0Ah
		db '  [/A | /B]] [/V] [/Y | /-Y]',0Dh,0Ah
		db 0Dh,0Ah
		db 68h
		db '  source       Specifies the file or files to be copied.',0Dh,0Ah
		db '  /A           Indicates an ASCII text file.',0Dh,0Ah
		db 76h
		db '  /B           Indicates a binary file.',0Dh,0Ah
		db '  destination  Specifies the directory and/or filename for the ne'
		db 'w file(s).',0Dh,0Ah
MSG_1403	db 63
		db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
MSG_1404	db 116
		db '  /Y           Suppresses prompting to confirm you want to overwr'
		db 'ite an',0Dh,0Ah
		db '               existing destination file.',0Dh,0Ah
MSG_1405	db 114
		db '  /-Y          Causes prompting to confirm you want to overwrite '
		db 'an',0Dh,0Ah
		db '               existing destination file.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1406	db 66
		db 'The switch /Y may be preset in the COPYCMD environment variable.',0Dh
		db 0Ah
MSG_1407	db 135
		db 'To append files, specify a single file for destination, but multi'
		db 'ple files',0Dh,0Ah
		db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
MSG_1420	db 8Ah
		db 'Changes the terminal device used to control your system.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CTTY device',0Dh,0Ah
		db 0Dh,0Ah
		db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
MSG_1440	db 93
		db 'Displays or sets the date.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DATE [mm-dd-yy]',0Dh,0Ah
		db 0Dh,0Ah
		db '  mm-dd-yy    Sets the date you specify.',0Dh,0Ah
		db 0Dh,0Ah
		db 83h
		db 'Type DATE without parameters to display the current date setting '
		db 'and',0Dh,0Ah
		db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
MSG_1460	db 64h
		db 'Deletes one or more files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
		db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
		db 0Dh,0Ah
		db 83h
		db '  [drive:][path]filename  Specifies the file(s) to delete.  Speci'
		db 'fy multiple',0Dh,0Ah
		db '                          files by using wildcards.',0Dh,0Ah
		db 4Fh
		db '  /P                      Prompts for confirmation before deletin'
		db 'g each file.',0Dh,0Ah
MSG_1480	db 137
		db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attribs]] [/O[[:]so'
		db 'rtord]]',0Dh,0Ah
		db 30
		db '    [/S] [/B] [/L] [/C[H]]',0Dh,0Ah
		db 0Dh,0Ah
		db 80
		db '  [drive:][path][filename]   Specifies drive, directory, and/or f'
		db 'iles to list.',0Dh,0Ah
		db 89
		db '  /P      Pauses after each screenful of information.',0Dh,0Ah
		db '  /W      Uses wide list format.',0Dh,0Ah
		db 126
		db '  /A      Displays files with specified attributes.',0Dh,0Ah
		db '  attribs   D  Directories   R  Read-only files         H  Hidden'
		db ' files',0Dh,0Ah
MSG_1485	db 123
		db '            S  System files  A  Files ready to archive  -  Prefix'
		db ' meaning "not"',0Dh,0Ah
		db '  /O      List by files in sorted order.',0Dh,0Ah
		db 149
		db '  sortord   N  By name (alphabetic)       S  By size (smallest fi'
		db 'rst)',0Dh,0Ah
		db '            E  By extension (alphabetic)  D  By date & time (earl'
		db 'iest first)',0Dh,0Ah
MSG_1487	db 70
		db '            G  Group directories first    -  Prefix to reverse or'
		db 'der',0Dh,0Ah
		db 127
		db '            C  By compression ratio (smallest first)',0Dh,0Ah
		db '  /S      Displays files in specified directory and all subdirect'
		db 'ories.',0Dh,0Ah
		db 65
		db '  /B      Uses bare format (no heading information or summary).',0Dh
		db 0Ah
MSG_1490	db 27
		db '  /L      Uses lowercase.',0Dh,0Ah
		db 82
		db '  /C[H]   Displays file compression ratio; /CH uses host allocati'
		db 'on unit size.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1492	db 146
		db 'Switches may be preset in the DIRCMD environment variable.  Overr'
		db 'ide',0Dh,0Ah
		db 'preset switches by prefixing any switch with - (hyphen)--for exam'
		db 'ple, /-W.',0Dh,0Ah
		db 22
		db '    [/S] [/B] [/L]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1494	db 29
		db '  /L      Uses lowercase.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1500	db 3Eh
		db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
		db 0Dh,0Ah
		db 'EXIT',0Dh,0Ah
MSG_1520	db 3Dh
		db 'Creates a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'MKDIR [drive:]path',0Dh,0Ah
		db 'MD [drive:]path',0Dh,0Ah
MSG_1540	db 5Dh
		db 'Displays or sets a search path for executable files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PATH [[drive:]path[;...]]',0Dh,0Ah
		db 'PATH ;',0Dh,0Ah
		db 0Dh,0Ah
		db 6Bh
		db 'Type PATH ; to clear all search-path settings and direct MS-DOS t'
		db 'o search',0Dh,0Ah
		db 'only in the current directory.',0Dh,0Ah
		db 3Bh
		db 'Type PATH without parameters to display the current path.',0Dh,0Ah
MSG_1560	db 37h
		db 'Changes the MS-DOS command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'PROMPT [text]',0Dh,0Ah
		db 0Dh,0Ah
		db 7Ch
		db '  text    Specifies a new command prompt.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Prompt can be made up of normal characters and the following spec'
		db 'ial codes:',0Dh,0Ah
		db 0Dh,0Ah
		db 2Fh
		db '  $Q   = (equal sign)',0Dh,0Ah
		db '  $$   $ (dollar sign)',0Dh,0Ah
		db 2Ah
		db '  $T   Current time',0Dh,0Ah
		db '  $D   Current date',0Dh,0Ah
		db 3Dh
		db '  $P   Current drive and path',0Dh,0Ah
		db '  $V   MS-DOS version number',0Dh,0Ah
MSG_1565	db 34h
		db '  $N   Current drive',0Dh,0Ah
		db '  $G   > (greater-than sign)',0Dh,0Ah
		db 2Ch
		db '  $L   < (less-than sign)',0Dh,0Ah
		db '  $B   | (pipe)',0Dh,0Ah
		db 79h
		db '  $H   Backspace (erases previous character)',0Dh,0Ah
		db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
		db '  $_   Carriage return and linefeed',0Dh,0Ah
		db 0Dh,0Ah
		db 4Ch
		db 'Type PROMPT without parameters to reset the prompt to the default'
		db ' setting.',0Dh,0Ah
MSG_1580	db 47h
		db 'Removes (deletes) a directory.',0Dh,0Ah
		db 0Dh,0Ah
		db 'RMDIR [drive:]path',0Dh,0Ah
		db 'RD [drive:]path',0Dh,0Ah
MSG_1600	db 1Ch
		db 'Renames a file or files.',0Dh,0Ah
		db 0Dh,0Ah
		db 53h
		db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
		db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
		db 0Dh,0Ah
MSG_1602	db 160
		db 'Note that you cannot specify a new drive or path for your destina'
		db 'tion file.',0Dh,0Ah
		db 0Dh,0Ah
		db 'Use MOVE to rename a directory, or to move files from one directo'
		db 'ry to another.',0Dh,0Ah
MSG_1620	db 57h
		db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
		db 0Dh,0Ah
		db 'SET [variable=[string]]',0Dh,0Ah
		db 0Dh,0Ah
		db 81h
		db '  variable  Specifies the environment-variable name.',0Dh,0Ah
		db '  string    Specifies a series of characters to assign to the var'
		db 'iable.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1622	db 4Bh
		db 'Type SET without parameters to display the current environment va'
		db 'riables.',0Dh,0Ah
MSG_1640	db 45
		db 'Displays or sets the time.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TIME [time]',0Dh,0Ah
		db 0Dh,0Ah
		db 83h
		db 'Type TIME without parameters to display the current time setting '
		db 'and',0Dh,0Ah
		db 'a prompt for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
MSG_1660	db 46h
		db 'Displays the contents of a text file.',0Dh,0Ah
		db 0Dh,0Ah
		db 'TYPE [drive:][path]filename',0Dh,0Ah
MSG_1680	db 25h
		db 'Displays the MS-DOS version.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VER',0Dh,0Ah
MSG_1700	db 177
		db 'Tells MS-DOS whether to verify that your files are written correc'
		db 'tly to a',0Dh,0Ah
		db 'disk.',0Dh,0Ah
		db 0Dh,0Ah
		db 'VERIFY [ON | OFF]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type VERIFY without a parameter to display the current VERIFY set'
		db 'ting.',0Dh,0Ah
MSG_1720	db 52h
		db 'Displays the disk volume label and serial number, if they exist.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'VOL [drive:]',0Dh,0Ah
MSG_1740	db 5Bh
		db 'Calls one batch program from another.',0Dh,0Ah
		db 0Dh,0Ah
		db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1741	db 72h
		db '  batch-parameters   Specifies any command-line information requi'
		db 'red by the',0Dh,0Ah
		db '                     batch program.',0Dh,0Ah
MSG_1760	db 4Ch
		db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
		db 0Dh,0Ah
		db 'REM [comment]',0Dh,0Ah
MSG_1780	db 6Bh
		db 'Suspends processing of a batch program and displays the message "'
		db 'Press any',0Dh,0Ah
		db 'key to continue...."',0Dh,0Ah
		db 0Dh,0Ah
		db 'PAUSE',0Dh,0Ah
MSG_1800	db 4Dh
		db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
		db 0Dh,0Ah
		db '  ECHO [ON | OFF]',0Dh,0Ah
MSG_1801	db 57h
		db '  ECHO [message]',0Dh,0Ah
		db 0Dh,0Ah
		db 'Type ECHO without parameters to display the current echo setting.'
		db 0Dh,0Ah
		db 47h
		db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
		db 0Dh,0Ah
		db 'GOTO label',0Dh,0Ah
		db 0Dh,0Ah
		db 8Ah
		db '  label   Specifies a text string used in the batch program as a '
		db 'label.',0Dh,0Ah
		db 0Dh,0Ah
		db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
MSG_1840	db 4Ah
		db 'Changes the position of replaceable parameters in a batch file.',0Dh
		db 0Ah
		db 0Dh,0Ah
		db 'SHIFT',0Dh,0Ah
MSG_1860	db 5Ah
		db 'Performs conditional processing in batch programs.',0Dh,0Ah
		db 0Dh,0Ah
		db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
		db 46h
		db 'IF [NOT] string1==string2 command',0Dh,0Ah
		db 'IF [NOT] EXIST filename command',0Dh,0Ah
		db 0Dh,0Ah
		db 7Dh
		db '  NOT               Specifies that MS-DOS should carry out the co'
		db 'mmand only',0Dh,0Ah
		db '                    if the condition is false.',0Dh,0Ah
MSG_1863	db 0A2h
		db '  ERRORLEVEL number Specifies a true condition if the last progra'
		db 'm run returned',0Dh,0Ah
		db '                    an exit code equal to or greater than the num'
		db 'ber specified.',0Dh,0Ah
		db 66h
		db '  command           Specifies the command to carry out if the con'
		db 'dition is',0Dh,0Ah
		db '                    met.',0Dh,0Ah
		db 6Ah
		db '  string1==string2  Specifies a true condition if the specified t'
		db 'ext strings',0Dh,0Ah
		db '                    match.',0Dh,0Ah
		db 67h
		db '  EXIST filename    Specifies a true condition if the specified f'
		db 'ilename',0Dh,0Ah
		db '                    exists.',0Dh,0Ah
MSG_1880	db 77h
		db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
		db 0Dh,0Ah
		db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
		db 0Dh,0Ah
		db 7Dh
		db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
		db '  (set)      Specifies a set of one or more files.  Wildcards may'
		db ' be used.',0Dh,0Ah
		db 56h
		db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
		db '  command-parameters',0Dh,0Ah
MSG_1883	db 0A2h
		db '             Specifies parameters or switches for the specified c'
		db 'ommand.',0Dh,0Ah
		db 0Dh,0Ah
		db 'To use the FOR command in a batch program, specify %%variable ins'
		db 'tead of',0Dh,0Ah
		db '%variable.',0Dh,0Ah
MSG_1900	db 17h
		db 'Reserved command name',0Dh,0Ah
MSG_1920	db 2Fh
		db 'Loads a program into the upper memory area.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1921	db 157
		db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
		db 'LOADHIGH [/L:region1[,minsize1][;region2[,minsize2]...] [/S]]',0Dh,0Ah
		db '         [drive:][path]filename [parameters]',0Dh,0Ah
		db 0Dh,0Ah
MSG_1922	db 182
		db '/L:region1[,minsize1][;region2[,minsize2]]...',0Dh,0Ah
		db '            Specifies the region(s) of memory into which to load',0Dh
		db 0Ah
		db '            the program.  Region1 specifies the number of the fir'
		db 'st',0Dh,0Ah
MSG_1923	db 133
		db '            memory region; minsize1 specifies the minimum size, i'
		db 'f',0Dh,0Ah
		db '            any, for region1.  Region2 and minsize2 specify the',0Dh
		db 0Ah
		db 127
		db '            number and minimum size of the second region, if any.'
		db 0Dh,0Ah
		db '            You can specify as many regions as you want.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1925	db 131
		db '/S          Shrinks a UMB to its minimum size while the program',0Dh
		db 0Ah
		db '            is loading.  /S is normally used only by MemMaker.',0Dh,0Ah
		db 0Dh,0Ah
		db 87
		db '[drive:][path]filename',0Dh,0Ah
		db '            Specifies the location and name of the program.',0Dh,0Ah
		db 0Dh,0Ah
MSG_1927	db 90
		db 'parameters  Specifies any command-line information required by',0Dh,0Ah
		db '            the program.',0Dh,0Ah

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_CLS_3	proc near		; ...
		push	cs
		pop	es
		assume es:TRANGROUP
		lea	di, $M_CLASS_3_STRUC
		add	cx, 11627	; ADD CX,$-$M_CLASS_3_STRUC
		retn
$M_CLS_3	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_1_STRUC db 1			; ...
					; $M_CLASS_ID
		dw 1606h		; EXPECTED_VERSION (COMMAND.COM	version)
		db 4			; Class_1_MessageCount
$M_ID_1_1	dw 2			; Message Number = 2
		dw 10h			; Message offset from message number
$M_ID_1_2	dw 3			; Message Number = 3
		dw 1Bh			; Message offset from message number
$M_ID_1_3	dw 8			; Message Number = 8
		dw 26h			; Message offset from message number
$M_ID_1_4	dw 0FFFFh		; Message Number = -1
		dw 36h			; Message offset from message number
EXTEND2		db 0Eh
		db 'File not found'
EXTEND3		db 0Eh
		db 'Path not found'
EXTEND8		db 13h
		db 'Insufficient memory'
EXTEND999	db 11h
		db 'Extended Error %1'

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_MSGSERV_1	proc near		; ...
		push	cs
		pop	es
		lea	di, $M_CLASS_1_STRUC
		add	cx, 94		; $-$M_CLASS_1_STRUC
		retn
$M_MSGSERV_1	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
$M_CLASS_2_STRUC db 2			; ...
					; $M_CLASS_ID
		dw 1606h		; EXPECTED_VERSION (COMMAND.COM	version)
		db 1			; Class_2_MessageCount
$M_ID_2_1	dw 0FFFFh
		dw 4			; Message Number = -1
PARSE999	db 0Eh			; Message offset from message number
		db 'Parse Error %1'

; ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ S U B	R O U T	I N E ÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛÛ


$M_MSGSERV_2	proc near		; ...
		push	cs
		pop	es
		lea	di, $M_CLASS_2_STRUC
		add	cx, 29
		retn
$M_MSGSERV_2	endp

; ÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄÄ
msg_disp_class	db 0FFh			; ...
msg_cont_flag	db 0			; ...
extend_buf_ptr	dw 0			; ...
extend_buf_sub	db 0			; ...
		db 11
		db 0
		dw offset string_ptr_2
extend_buf_seg	dw 0
		db 0
		db 10h
		db 128
		db 0
		db 20h
RENERR_PTR	dw 1002			; ...
		db 0
BADCPMES_PTR	dw 1003			; ...
		db 0
NOSPACE_PTR	dw 1004			; ...
		db 0
ENVERR_PTR	dw 1007			; ...
		db 0
FULLDIR_PTR	dw 1008			; ...
		db 0
BADBAT_PTR	dw 1009			; ...
		db 0
NEEDBAT_PTR	dw 1010			; ...
		db 0
BADNAM_PTR	dw 1011			; ...
		db 0
ACCDEN_PTR	dw 1014			; ...
		db 0
OVERWR_PTR	dw 1015			; ...
		db 0
LOSTERR_PTR	dw 1016			; ...
		db 0
INORNOT_PTR	dw 1017			; ...
		db 0
copied_ptr	dw 1018			; ...
		db 1
		db 0Bh
		db 0
		dw offset Copy_num
		dw 0
		db 1
		db 0A1h
		db 9
		db 9
		db 20h
dirmes_ptr	dw 1019			; ...
		db 1
		db 0Bh			; parm_block_size
		db 0
		dw offset Dir_Num
		dw 0
		db 1
screen_f_3	db 0E1h			; ...
					; Right_Align+Unsgn_Bin_Word (binary to	decimal)
					; + 40h	(for 80	columns	per row)
		db 9
		db 9
		db 20h
bytmes_ptr	dw 1020			; ...
		db 1
		db 0Bh
		db 0
		dw offset Bytes_Free
		dw 0
		db 1
screen_f_6	db 0F1h			; ...
					; Right_Align+Unsgn_Bin_DWord (long binary to decimal)
					; + 40h	(for 80	columns	per row)
screen_f_7	db 32			; ...
		db 32
		db 20h
baddrv_ptr	dw 1021			; ...
		db 0
cp_not_set_ptr	dw 1022			; ...
		db 1
		db 0Bh
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
cp_not_all_ptr	dw 1023			; ...
		db 1
		db 0Bh
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
cp_active_ptr	dw 1024			; ...
		db 1
		db 0Bh
		db 0
		dw offset system_cpage
		dw 0
		db 1
		db 0A1h
		db 5
		db 1
		db 20h
NLSFUNC_PTR	dw 1025			; ...
		db 0
INV_CODE_PAGE	dw 1026			; ...
		db 0
BADCURDRV	dw 1027			; ...
		db 0
PAUSEMES_PTR	dw 1028			; ...
		db 0
BADLAB_PTR	dw 1029			; ...
		db 0
SYNTMES_PTR	dw 1030			; ...
		db 0
BADDAT_PTR	dw 1031			; ...
		db 0
CurDat_Ptr	dw 1032			; ...
		db 2
		db 0Bh
		db 0
		dw offset Arg_Buf
		dw 0
		db 1
		db 10h
		db 3
		db 3
		db 20h
		db 0Bh
		db 0
CurDat_yr	dw 0			; ...
CurDat_mo_day	dw 0			; ...
		db 2
		db 34h
		db 10
		db 10
		db 20h
WeekTab		dw 1033			; ...
		db 0
NewDat_Ptr	dw 1034			; ...
		db 1
		db 0Bh
		db 0
NewDat_Format	dw 0			; ...
		dw 0
		db 1
		db 10h
		db 8
		db 8
		db 20h
BadTim_Ptr	dw 1035			; ...
		db 0
CurTim_Ptr	dw 1036			; ...
		db 1
		db 0Bh
		db 0
CurTim_hr_min	dw 0			; ...
CurTim_Sec_hn	dw 0			; ...
		db 1
		db 0A5h
		db 12
		db 12
		db 20h
NewTim_Ptr	dw 1037			; ...
		db 0
Del_Y_N_Ptr	dw 1038			; ...
		db 0
SureMes_Ptr	dw 1039			; ...
		db 0
VerMes_Ptr	dw 1040			; ...
		db 2
		db 11
		db 0
		dw offset Major_Ver_Num
		dw 0
		db 1
		db 0A1h
		db 1
		db 1
		db 20h			; blank	(pad character)
		db 11
		db 0
		dw offset Minor_Ver_Num
		dw 0
		db 2
		db 0A1h
		db 2
		db 2
		db 30h			; "0" (pad character)
VolMes_Ptr_2	dw 1041			; ...
					; message number
		db 1
		db 11			; 0Bh
		db 0
		dw offset vol_drv
		dw 0
		db 1
		db 0			; Char_field_Char (character)
		db 128
		db 1
		db 20h
VolMes_Ptr	dw 1042			; ...
					; "Volume in drive %1 is %2",13,10
		db 2			; number of subst
		db 11			; size of sublist
		db 0			; reserved
		dw offset vol_drv	; offset of drive
		dw 0			; segment of arg
		db 1			; first	subst
		db 0			; character (Char_field_Char)
		db 128			; maximum width
		db 1			; minimum width
		db 20h			; pad character	(blank)
		db 11			; size of sublist
		db 0			; reserved
		dw offset CHARBUF	; offset of string
		dw 0			; segment of arg
		db 2			; second subst
		db 10h			; Char_field_ASCIIZ (character string)
		db 128			; maximum width
		db 1			; minimum width
		db 20h			; pad character	(blank)
VolSerMes_Ptr	dw 1043			; ...
					; "Volume Serial Number	is %1-%2",13,10
		db 2
		db 11			; 11
		db 0
		dw offset vol_serial+2
		dw 0
		db 1
		db 0A3h			; Right_Align+Bin_Hex_Word (binary to hex)
		db 4
		db 4
		db 30h			; "0"
		db 11
		db 0
		dw offset vol_serial
		dw 0
		db 2
		db 0A3h
		db 4
		db 4
		db 30h
badcd_ptr	dw 1044			; ...
		db 0
badmkd_ptr	dw 1045			; ...
		db 0
badrmd_ptr	dw 1046			; ...
		db 0
bad_on_off_ptr	dw 1047			; ...
		db 0
dirhead_ptr	dw 1048			; ...
		db 1
		db 0Bh
		db 0
		dw offset BWDBUF
		dw 0
		db 1
		db 10h
		db 128
		db 0
		db 20h
NULLPATH_PTR	dw 1049			; ...
		db 0
BADPMES_PTR	dw 1050			; ...
		db 0
BADDEV_PTR	dw 1051			; ...
		db 0
FORNESTMES_PTR	dw 1052			; ...
		db 0
PIPEEMES_PTR	dw 1053			; ...
		db 0
INBDEV_PTR	dw 1054			; ...
		db 0
CtrlcMes_Ptr	dw 1055			; ...
		db 1
		db 11
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 128
		db 1
		db 20h
VeriMes_Ptr	dw 1056			; ...
		db 1
		db 0Bh
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 80h
		db 1
		db 20h
EchoMes_Ptr	dw 1057			; ...
		db 1
		db 0Bh
		db 0
		dw 0
		dw 0
		db 1
		db 10h
		db 80h
		db 1
		db 20h
OFFMES_PTR	dw 1059			; ...
		db 0
ONMES_PTR	dw 1060			; ...
		db 0
DEVWMES_PTR	dw 1061			; ...
		db 0
INVAL_PATH_PTR	dw 1062
		db 0
arg_buf_ptr	dw 1063			; ...
		db 1
		db 0Bh
		db 0
		dw offset Arg_Buf
		dw 0
		db 1
		db 10h
		db 80h
		db 0
		db 20h
file_name_ptr	dw 1064			; ...
		db 1
		db 0Bh
		db 0
		dw offset SrcBuf
		dw 0
		db 1
		db 10h
		db 80h
		db 0
		db 20h
disp_file_size_ptr dw 1065		; ...
		db 1
		db 0Bh
		db 0
		dw offset File_Size_Low
		dw 0
		db 1
screen_f_1	db 0F1h			; ...
screen_f_2	db 14			; ...
		db 14
		db 20h
string_buf_ptr	dw 1066			; ...
		db 1
		db 11
		db 0
		dw offset string_ptr_2
		dw 0
		db 1
		db 10h
		db 128
		db 0
		db 20h
		db 0
tab_ptr		dw 1067			; ...
		db 0
dmes_ptr	dw 1068			; ...
		db 0
space_4_ptr	dw 1105			; ...
		db 0
dback_ptr	dw 1069			; ...
		db 0
acrlf_ptr	dw 1070			; ...
		db 0
usadat_Ptr	dw 1072			; ...
		db 0
eurdat_ptr	dw 1073			; ...
		db 0
japdat_ptr	dw 1074			; ...
		db 0
promptdat_ptr	dw 1075			; ...
		db 2
		db 11
		db 0
		dw offset Arg_Buf
		dw 0
		db 1
		db 10h
		db 3
		db 3
		db 20h
		db 11
		db 0
promptDat_yr	dw 0			; ...
promptDat_moday	dw 0			; ...
		db 2
		db 34h
		db 10
		db 8
		db 20h
promtim_ptr	dw 1076			; ...
		db 1
		db 0Bh
		db 0
PromTim_hr_min	dw 0			; ...
PromTim_Sec_hn	dw 0			; ...
		db 1
		db 0A6h
		db 11
		db 11
		db 20h
dirdattim_ptr	dw 1077			; ...
		db 2
		db 0Bh
		db 0
DirDat_Yr	dw 0			; ...
DirDat_Mo_Day	dw 0			; ...
		db 1
		db 0A4h
		db 10
		db 8
		db 20h
		db 0Bh
		db 0
DirTim_Hr_Min	dw 0			; ...
DirTim_Sec_hn	dw 0
		db 2
		db 85h
		db 6
		db 6
		db 20h
MD_EXISTS_PTR	dw 1078			; ...
		db 0
bytes_ptr	dw 1079			; ...
		db 1
		db 0Bh
		db 0
		dw offset FileSiz
		dw 0
		db 1
screen_f_4	db 0F1h			; ...
screen_f_5	db 14			; ...
		db 14
		db 20h
total_ptr	dw 1080			; ...
		db 0
errparsenv_ptr	dw 1081			; ...
		db 0
cox_Y_quest_ptr	dw 1082			; ...
		db 0
cox_Y_answ_ptr	dw 1083
		db 0
dircont_ptr	dw 1084			; ...
		db 1
		db 0Bh
		db 0
		dw offset BWDBUF
		dw 0
		db 1
		db 10h
		db 80h
		db 0
		db 20h
dosrev_ptr	dw 1090			; ...
		db 1
		dw 0Bh
		dw offset One_Char_Val
		dw 0
		db 1
		db 0
		db 1
		db 1
		db 20h
DosRom_Ptr	dw 1091			; ...
		db 0
DosHma_Ptr	dw 1092			; ...
		db 0
DosLow_Ptr	dw 1093			; ...
		db 0
NoExecBat_Ptr	dw 1094			; ...
		db 0
LhInvFil_Ptr	dw 1095			; ...
		db 0
NoCntry_Ptr	dw 1096			; ...
		db 0
LhInvArg_Ptr	dw 1097			; ...
		db 0
ReqParmMiss	dw 1098			; ...
		db 0
LhInvSwt_Ptr	dw 1099			; ...
		db 0
LhBadUMB_Ptr	dw 1100			; ...
		db 0
DirCompRatio_Ptr dw 1101		; ...
		db 2
		db 0Bh
		db 0
		dw offset Dir_CRatio_1
		dw 0
		db 1
		db 91h
		db 2
		db 2
		db 20h
		db 0Bh
		db 0
		dw offset Dir_CRatio_2
		dw 0
		db 2
		db 11h
		db 1
		db 1
		db 20h
AveCompRatio_Ptr dw 1102		; ...
		db 2
		db 0Bh
		db 0
		dw offset Dir_CRatio_1
		dw 0
		db 1
		db 91h
		db 2
		db 2
		db 20h
		db 0Bh
		db 0
		dw offset Dir_CRatio_2
		dw 0
		db 2
		db 11h
		db 1
		db 1
		db 20h
PATH_TEXT	db 'PATH='              ; ...
PROMPT_TEXT	db 'PROMPT='            ; ...
COMSPECSTR	db 'COMSPEC='           ; ...
DirEnvVar	db 'DIRCMD='            ; ...
BreakHelpMsgs	dw 1300,   0		; ...
ChcpHelpMsgs	dw 1320,1321,	0	; ...
CdHelpMsgs	dw 1340,1341,1342,   0	; ...
ClsHelpMsgs	dw 1360,   0		; ...
CopyHelpMsgs	dw 1400,1401,1402,1403,1404,1405,1406,1407,   0	; ...
CttyHelpMsgs	dw 1420,   0		; ...
DateHelpMsgs	dw 1440,1441,	0	; ...
DelHelpMsgs	dw 1460,1461,1462,   0	; ...
DirHelpMsgs	dw 1480,1481,1482,1483,1484,1485,1486,1487,1488,1489,1490 ; ...
		dw 1491,1492
		dw 0
ExitHelpMsgs	dw 1500,   0		; ...
MdHelpMsgs	dw 1520,   0		; ...
PathHelpMsgs	dw 1540,1541,1542,   0	; ...
PromptHelpMsgs	dw 1560,1561,1562,1563,1564,1565,1566,1567,1568,   0 ; ...
RdHelpMsgs	dw 1580,   0		; ...
RenHelpMsgs	dw 1600,1601,1602,   0	; ...
SetHelpMsgs	dw 1620,1621,1622,   0	; ...
TimeHelpMsgs	dw 1640,1641,	0	; ...
TypeHelpMsgs	dw 1660,   0		; ...
VerHelpMsgs	dw 1680,   0		; ...
VerifyHelpMsgs	dw 1700,   0		; ...
VolHelpMsgs	dw 1720,   0		; ...
CallHelpMsgs	dw 1740,1741,	0	; ...
RemHelpMsgs	dw 1760,   0		; ...
PauseHelpMsgs	dw 1780,   0		; ...
EchoHelpMsgs	dw 1800,1801,	0	; ...
GotoHelpMsgs	dw 1820,1821,	0	; ...
ShiftHelpMsgs	dw 1840,   0		; ...
IfHelpMsgs	dw 1860,1861,1862,1863,1864,1865,1866,	 0 ; ...
ForHelpMsgs	dw 1880,1881,1882,1883,	  0 ; ...
TruenameHelpMsgs dw 1900,   0		; ...
LoadhighHelpMsgs dw 1920,1921,1922,1923,1924,1925,1926,1927,   0 ; ...
CLSSTRING	db 4			; ...
		db 1Bh			; ESC
clsstring_2	db '[2J'                ; ...
PROMPT_TABLE	db 'B'
		dw offset Print_B
		db 'D'
		dw offset PRINT_DATE
		db 'E'
		dw offset PRINT_ESC
		db 'G'
		dw offset PRINT_G
		db 'H'
		dw offset PRINT_BACK
		db 'L'
		dw offset PRINT_L
		db 'N'
		dw offset PRINT_DRIVE
		db 'P'
		dw offset build_dir_for_prompt
		db 'Q'
		dw offset PRINT_EQ
		db 'T'
		dw offset PRINT_TIME
		db 'V'
		dw offset PRINT_VERSION
		db '_'
		dw offset CRLF2
		db '$'
		dw offset PRINT_CHAR
		db 0
IFTAB		db 3			; ...
		db 'NOT'
		dw offset IFNOT
		db 10
		db 'ERRORLEVEL'
		dw offset IFERLEV
		db 5
		db 'EXIST'
		dw offset IFEXISTS
		db 0
COMTAB		db 3			; ...
		db 'DIR'
		db 3
		dw offset CATALOG
		dw offset DirHelpMsgs
		db 4
		db 'CALL'
		db 2
		dw offset _$CALL
		dw offset CallHelpMsgs
		db 4
		db 'CHCP'
		db 2
		dw offset CHCP
		dw offset ChcpHelpMsgs
		db 6
		db 'RENAME'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 3
		db 'REN'
		db 3
		dw offset CRENAME
		dw offset RenHelpMsgs
		db 5
		db 'ERASE'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 3
		db 'DEL'
		db 3
		dw offset ERASE
		dw offset DelHelpMsgs
		db 4
		db 'TYPE'
		db 3
		dw offset TYPEFIL
		dw offset TypeHelpMsgs
		db 3
		db 'REM'
		db 6
		dw offset TCOMMAND
		dw offset RemHelpMsgs
		db 4
		db 'COPY'
		db 3
		dw offset COPY
		dw offset CopyHelpMsgs
		db 5
		db 'PAUSE'
		db 6
		dw offset PAUSE
		dw offset PauseHelpMsgs
		db 4
		db 'DATE'
		db 2
		dw offset DATE
		dw offset DateHelpMsgs
		db 4
		db 'TIME'
		db 2
		dw offset CTIME
		dw offset TimeHelpMsgs
		db 3
		db 'VER'
		db 2
		dw offset VERSION
		dw offset VerHelpMsgs
		db 3
		db 'VOL'
		db 3
		dw offset VOLUME
		dw offset VolHelpMsgs
		db 2
		db 'CD'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 5
		db 'CHDIR'
		db 3
		dw offset _$CHDIR
		dw offset CdHelpMsgs
		db 2
		db 'MD'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 5
		db 'MKDIR'
		db 3
		dw offset _$MKDIR
		dw offset MdHelpMsgs
		db 2
		db 'RD'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'RMDIR'
		db 3
		dw offset _$RMDIR
		dw offset RdHelpMsgs
		db 5
		db 'BREAK'
		db 2
		dw offset CNTRLC
		dw offset BreakHelpMsgs
		db 6
		db 'VERIFY'
		db 2
		dw offset VERIFY
		dw offset VerifyHelpMsgs
		db 3
		db 'SET'
		db 6
		dw offset ADD_NAME_TO_ENVIRONMENT
		dw offset SetHelpMsgs
		db 6
		db 'PROMPT'
		db 6
		dw offset ADD_PROMPT
		dw offset PromptHelpMsgs
		db 4
		db 'PATH'
		db 2
		dw offset PATH
		dw offset PathHelpMsgs
		db 4
		db 'EXIT'
		db 0
		dw offset _$EXIT
		dw offset ExitHelpMsgs
		db 4
		db 'CTTY'
		db 3
		dw offset CTTY
		dw offset CttyHelpMsgs
		db 4
		db 'ECHO'
		db 6
		dw offset ECHO
		dw offset EchoHelpMsgs
		db 4
		db 'GOTO'
		db 6
		dw offset GOTO
		dw offset GotoHelpMsgs
		db 5
		db 'SHIFT'
		db 2
		dw offset SHIFT
		dw offset ShiftHelpMsgs
		db 2
		db 'IF'
		db 6
		dw offset _$IF
		dw offset IfHelpMsgs
		db 3
		db 'FOR'
		db 6
		dw offset _$FOR
		dw offset ForHelpMsgs
		db 3
		db 'CLS'
		db 0
		dw offset CLS
		dw offset ClsHelpMsgs
		db 8
		db 'TRUENAME'
		db 3
		dw offset TRUENAME
		dw offset TruenameHelpMsgs
		db 8
		db 'LOADHIGH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 2
		db 'LH'
		db 2
		dw offset LoadHigh
		dw offset LoadhighHelpMsgs
		db 0
comext		db '.COM'               ; ...
exeext		db '.EXE'               ; ...
batext		db '.BAT'               ; ...
switch_list	db '-Y?VBAPW'           ; ...
AttrLtrs	db 'RHSvDA'             ; ...
OrderLtrs	db 'NEDSGC'             ; ...
comspec_flag	db 0			; ...
BATBUFLEN	dw 32			; ...
NO_VALUES	dw 0			; ...
NULL_VALUE_LIST	db 0			; ...
FILE_REQUIRED	dw 200h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL	dw 301h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
FILE_OPTIONAL2	dw 201h			; ...
		dw 1
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
SLASH_P_SWITCH	dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
SLASH_P_SYN	db '/P',0               ; ...
PARSE_BREAK	dw offset BREAK_PARMS	; ...
		db 0
BREAK_PARMS	db 0			; ...
		db 1
		dw offset BREAK_CONTROL1
		db 0
		db 0
BREAK_CONTROL1	dw 2001h		; ...
		db 2
		db 0
		dw offset PARSE1_OUTPUT
		dw offset BREAK_VALUES
		db 0
BREAK_VALUES	db 3			; ...
		db 0
		db 0
		db 2
		db 0
		dw offset BREAK_ON	; "ON"
		db 'f'
		dw offset BREAK_OFF	; "OFF"
BREAK_ON	db 'ON',0               ; ...
BREAK_OFF	db 'OFF',0              ; ...
PARSE_CHCP	dw offset CHCP_PARMS	; ...
		db 0
CHCP_PARMS	db 0			; ...
		db 1
		dw offset CHCP_CONTROL1
		db 0
		db 0
CHCP_CONTROL1	dw 8001h		; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset CHCP_VALUES
		db 0
CHCP_VALUES	db 1			; ...
		db 1
		db 1
		dd 100
		dd 999
		db 0
		db 0
PARSE_DATE	dw offset DATE_PARMS	; ...
		db 0
DATE_PARMS	db 0			; ...
		db 1
		dw offset DATE_CONTROL1
		db 0
		db 0
DATE_CONTROL1	dw 1001h		; ...
		dw 0
		dw offset DATE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_TIME	dw offset TIME_PARMS	; ...
		db 0
TIME_PARMS	db 0			; ...
		db 1
		dw offset TIME_CONTROL1
		db 0
		db 0
TIME_CONTROL1	dw 801h			; ...
		dw 0
		dw offset TIME_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VOL	dw offset VOL_PARMS	; ...
		db 0
VOL_PARMS	db 0			; ...
		db 1
		dw offset DRIVE_CONTROL1
		db 0
		db 0
DRIVE_CONTROL1	dw 101h			; ...
		dw 1
		dw offset DRIVE_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_MRDIR	dw offset MRDIR_PARMS	; ...
		db 0
MRDIR_PARMS	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CHDIR	dw offset CHDIR_PARMS	; ...
		db 0
CHDIR_PARMS	db 0			; ...
		db 1
		dw offset FILE_OPTIONAL
		db 0
		db 0
PARSE_ERASE	dw offset ERASE_PARMS	; ...
		db 0
ERASE_PARMS	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 1
		dw offset SLASH_P_SWITCH
		db 0
PARSE_DIR	dw offset DIR_PARMS	; ...
		db 0
DIR_PARMS	db 0			; ...
		db 1
		dw offset FILE_OPTIONAL2
		db 2
		dw offset DIR_SW_VALUED
		dw offset DIR_SW_UNVALUED
		db 0
DIR_SW_VALUED	dw 2001h		; ...
		dw 21h
		dw offset PARSE1_OUTPUT
		dw offset NULL_VALUE_LIST
		db 3
DIR_SW_A	db '/A',0               ; ...
DIR_SW_O	db '/O',0               ; ...
DIR_SW_C	db '/C',0               ; ...
DIR_SW_UNVALUED	dw 0			; ...
		dw 0
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 13
DIR_SW_NEG_A	db '/-A',0              ; ...
DIR_SW_NEG_O	db '/-O',0              ; ...
DIR_SW_S	db '/S',0               ; ...
DIR_SW_NEG_S	db '/-S',0              ; ...
DIR_SW_B	db '/B',0               ; ...
DIR_SW_NEG_B	db '/-B',0              ; ...
DIR_SW_W	db '/W',0               ; ...
DIR_SW_NEG_W	db '/-W',0              ; ...
DIR_SW_P	db '/P',0               ; ...
DIR_SW_NEG_P	db '/-P',0              ; ...
DIR_SW_L	db '/L',0               ; ...
DIR_SW_NEG_L	db '/-L',0              ; ...
DIR_SW_NEG_C	db '/-C',0              ; ...
Dir_Sw_Ptrs	dw offset DIR_SW_NEG_C	; ...
					; "/-C"
Dir_Sw_Ptrs_2	dw offset DIR_SW_C	; ...
					; "/C"
		dw offset DIR_SW_NEG_W	; "/-W"
		dw offset DIR_SW_W	; "/W"
		dw offset DIR_SW_NEG_P	; "/-P"
		dw offset DIR_SW_P	; "/P"
		dw offset DIR_SW_NEG_S	; "/-S"
		dw offset DIR_SW_S	; "/S"
		dw offset DIR_SW_NEG_B	; "/-B"
		dw offset DIR_SW_B	; "/B"
		dw offset DIR_SW_NEG_L	; "/-L"
		dw offset DIR_SW_L	; "/L"
		dw offset DIR_SW_NEG_O	; "/-O"
		dw offset DIR_SW_O	; "/O"
		dw offset DIR_SW_NEG_A	; "/-A"
		dw offset DIR_SW_A	; "/A"
PARSE_RENAME	dw offset RENAME_PARMS	; ...
		db 0
RENAME_PARMS	db 2			; ...
		db 2
		dw offset FILE_REQUIRED
		dw offset FILE_REQUIRED
		db 0
		db 0
PARSE_CTTY	dw offset CTTY_PARMS	; ...
		db    0
CTTY_PARMS	db 1			; ...
		db 1
		dw offset CTTY_CONTROL1
		db 0
		db 0
CTTY_CONTROL1	dw 2000h		; ...
		dw 11h
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 0
PARSE_VER	dw offset VER_PARMS	; ...
		db 0
VER_PARMS	db 0			; ...
		db 0
		db 1
		dw offset SLASH_R
		db 0
SLASH_R		dw 0			; ...
		dw 2
		dw offset PARSE1_OUTPUT
		dw offset NO_VALUES
		db 1
SLASH_R_SYN	db '/R',0
Parse_LoadHi	dw offset LoadHi_Parms
		db 0
LoadHi_Parms	db 1			; ...
		db 1
		dw offset FILE_REQUIRED
		db 0
		db 0
TempVarName	db 'TEMP=',0            ; ...
copycmd		db 'COPYCMD='           ; ...
sCVFRoot	db '\DBLSPACE.'         ; ...
$P_ORDINAL	dw 0			; ...
$P_RC		dw 0			; ...
$P_SI_Save	dw 0			; ...
$P_DX		dw 0			; ...
$P_Terminator	db 0			; ...
$P_DBCSEV_OFF	dw 0			; ...
$P_DBCSEV_SEG	dw 0			; ...
$P_Flags	db 0			; ...
$P_Flags2	db 0			; ...
$P_SaveSI_Cmpx	dw 0			; ...
$P_KEYorSW_Ptr	dw 0			; ...
$P_Save_EOB	dw 0			; ...
$P_Found_SYNONYM dw 0			; ...
$P_STRING_BUF	db 128 dup(0)		; ...
$P_ORIG_ORD	dw 0			; ...
$P_ORIG_STACK	dw 0			; ...
$P_ORIG_SI	dw 0			; ...
$P_Got_Time	db 0			; ...
$P_Country_Info	dw 0FFFFh		; ...
		db 32 dup(0)
$P_1st_Val	dw 0			; ...
$P_2nd_Val	dw 0			; ...
$P_3rd_Val	dw 0			; ...
$P_4th_Val	dw 0			; ...
$P_Char_CAP_Ptr	db 0FFh			; ...
		dd 0
$P_File_CAP_Ptr	db 0FFh			; ...
		dd 0
$P_FileSp_Char	db '[]|<>+=;"'          ; ...
$P_err_flag	db 0			; ...
$M_RT_$M_EXT_ERR_ADDRS dw 2 dup(   0)	; ...
$M_RT_$M_EXT_FILE dw 2 dup(   0)	; ...
$M_RT_$M_EXT_COMMAND dw	2 dup(	 0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_PARSE_COMMAND dw 2 dup(   0)	; ...
$M_RT_$M_PARSE_ADDRS dw	2 dup(	 0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_CRIT_ADDRS dw 2 dup(	0)	; ...
$M_RT_$M_CRIT_COMMAND dw 2 dup(	  0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_DISK_PROC_ADDR	dd 0FFFFFFFFh	; ...
$M_RT_$M_CLASS_ADDRS dw	6 dup(	 0)	; ...
		dd 0FFFFFFFFh
$M_RT_$M_DBCS_VEC dw 2 dup(   0)	; ...
$M_RT_$M_HANDLE	dw 0			; ...
$M_RT_$M_SIZE	db 0			; ...
$M_RT_$M_CRLF	dw 0A0Dh		; ...
$M_RT_$M_CLASS	db 0			; ...
$M_RT_$M_RETURN_ADDR dw	0		; ...
$M_RT_$M_MSG_NUM dw 0			; ...
$M_RT_$M_DIVISOR dw 10			; ...
$M_RT_$M_TEMP_BUF dw 2424h		; ...
$M_RT_$M_CURR_SEPARA db	5 dup( '$')
$M_RT_$M_THOU_SEPARA dw	2424h		; ...
$M_RT_$M_DECI_SEPARA dw	2424h		; ...
$M_RT_$M_DATE_SEPARA dw	2424h		; ...
$M_RT_$M_TIME_SEPARA dw	2424h		; ...
$M_RT_$M_CURR_FORMAT db	24h		; $
$M_RT_$M_SIG_DIGS_CU db	24h		; $
$M_RT_$M_TIME_FORMAT db	24h		; ...
					; $
		db '$'                  ; 24h
		db 2Dh dup( '$')
$M_RT_$M_BUF_TERM db '$'                ; ...
MsDosVer6_CCopy	db 'MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp Licensed M'
		db 'aterial - Property of Microsoft All rights reserved '
PRINTF_HANDLE	dw 0			; ...
SRCXNAME	db 87 dup(0)		; ...
TRGXNAME	db 87 dup(0)		; ...
UCOMBUF		db 131 dup(0)		; ...
COMBUF		db 131 dup(0)		; ...
USERDIR1	db 70 dup(0)		; ...
EXECPATH	db 131 dup(0)		; ...
RE_INSTR	db 83 dup(0)		; ...
HEADCALL	dw 0			; ...
RESSEG		dw 0			; ...
TPA		dw 0			; ...
SWITCHAR	db 0			; ...
DIRCHAR		db 0			; ...
EXEC_ADDR	dd 0			; ...
RCH_ADDR	dd 0			; ...
		dw 0
TRAN_TPA	dw 0			; ...
CHKDRV		db 0			; ...
IFNOTFLAG	db 0			; ...
CURDRV		db 0			; ...
PARM1		db 0			; ...
PARM2		db 0			; ...
COMSW		dw 0			; ...
ARG1S		dw 0			; ...
ARG2S		dw 0			; ...
ARGTS		dw 0			; ...
CFLAG		db 0			; ...
SPECDRV		db 0			; ...
BYTCNT		dw 0			; ...
savBytCnt	dw 0			; ...
NXTADD		dw 0			; ...
FRSTSRCH	db 0			; ...
LeftOnLine	db 0			; ...
PerLine		db 0			; ...
LeftOnPage	dw 0			; ...
FileCnt		dw 0			; ...
FileSiz		dw 2 dup(   0)		; ...
FileCntTotal	dw 2 dup(   0)		; ...
FileSizTotal	dd 0			; ...
ccluUsed	dw 0			; ...
ccluUsedDir	dw 0			; ...
ccluUsedTotal	dw 0			; ...
csecUsed	dw 2 dup(   0)		; ...
csecUsedDir	dw 2 dup(   0)		; ...
csecUsedTotal	dd 0			; ...
fhCVF		dw 0			; ...
szCVF		db 16 dup(   0)		; ...
MDBPB		db 64 dup(   0)		; ...
csecPerCluster	db 0			; ...
fUseHostSize	db 0			; ...
cFATEntries	dw 0			; ...
entInBuf	dw 0			; ...
segFATBuf	dw 0			; ...
pbufDOSFAT	dw 0			; ...
pbufMDFAT	dw 0			; ...
bufDOSFAT	db 64 dup(   0)		; ...
bufMDFAT	db 128 dup(   0)	; ...
CHARBUF		db 80 dup(   0)		; ...
IDLEN		db 0			; ...
ID		db 8 dup(0)		; ...
COM		db 3 dup(   0)
DEST		db 37 dup(   0)		; ...
DESTNAME	db 11 dup(   0)
DESTDIR		db 67 dup(   0)		; ...
BWDBUF		dw 4 dup(   0)		; ...
DIRBUF_8	db 11 dup(   0)		; ...
DIRBUF_8_DIR_ATTR db 0			; ...
		db 0
DIRBUF_find_buf_attr db	0		; ...
		db 8 dup(   0)
DIRBUF_find_buf_pname db 13 dup(   0)	; ...
		db 27 dup(   0)
SDIRBUF		db 12 dup(   0)		; ...
_Bits		dw 0			; ...
PathCnt		dw 0			; ...
PathPos		dw 0			; ...
PathSw		dw 0			; ...
AttrSpecified	db 0			; ...
AttrSelect	db 0			; ...
comma		db 0			; ...
plus_comma	db 0			; ...
DirFlag		db 0			; ...
parse_last	dw 0			; ...
system_cpage	dw 0			; ...
Arg_Buf		db 128 dup(0)		; ...
File_Size_Low	dw 0			; ...
File_Size_High	dw 0			; ...
string_ptr_2	dw 0			; ...
Copy_num	dw 0			; ...
cpyflag		db 0			; ...
Dir_Num		dw 0			; ...
Dir_CRatio_1	db 0			; ...
Dir_CRatio_2	db 0			; ...
Bytes_Free	dd 0			; ...
Major_Ver_Num	dw 0			; ...
Minor_Ver_Num	dw 0			; ...
One_Char_Val	db 0			; ...
		db 0
vol_drv		db 0			; ...
ROM_CALL	db 0			; ...
ROM_IP		dw 0			; ...
ROM_CS		dw 0			; ...
DestIsDir	db 0			; ...
DestSiz		db 0			; ...
DestTail	dw 0			; ...
DestInfo	db 0			; ...
DestBuf		db 87 dup(   0)		; ...
EndDestBuf	dw 0			; ...
DESTISDEV	db 0			; ...
FIRSTDEST	db 0			; ...
MELCOPY		db 0			; ...
MELSTART	dw 0			; ...
SrcIsDir	db 0			; ...
SrcSiz		db 0			; ...
SrcTail		dw 0			; ...
SrcInfo		db 0			; ...
SrcBuf		db 87 dup(0)		; ...
SRCHAND		dw 0			; ...
SRCISDEV	db 0			; ...
ScanBuf		db 87 dup(   0)		; ...
SRCPT		dw 0			; ...
INEXACT		db 0			; ...
NOWRITE		db 0			; ...
BINARY		db 0			; ...
WRITTEN		dw 0			; ...
TERMREAD	db 0			; ...
ASCII		db 0			; ...
PLUS		db 0			; ...
ObjCnt		db 0			; ...
CPDATE		dw 0			; ...
CPTIME		dw 0			; ...
OFilePtr_Lo	dw 0			; ...
OFilePtr_Hi	dw 0			; ...
OCtrlZ		db 0			; ...
cox_sublist_buff db 11 dup(   0)	; ...
cox_y_override	db 0			; ...
cox_dest_file	db 0			; ...
cox_src_file	db 0			; ...
BATHAND		dw 0			; ...
STARTEL		dw 0			; ...
ELCNT		db 0			; ...
ELPOS		db 0			; ...
SKPDEL		db 0			; ...
		db 11 dup(   0)
ext_entered	db 0			; ...
Display_Ioctl	db 0			; ...
		db 0
		dw 14			; crt_ioctl_ln
		dw 0
display_mode	db 0
		db 0
		dw 0
		dw 0
		dw 0
display_width	dw 0			; ...
LinPerPag	dw 25			; ...
vol_ioctl_buf	dw 0			; ...
vol_serial	dd 0			; ...
		db 0Bh dup( 20h)
		db 8 dup( 20h)
expand_star	db 0			; ...
msg_flag	db 0			; ...
Msg_Numb	dw 0			; ...
append_exec	db 0			; ...
print_err_flag	dw 0			; ...
subst_buffer	db 22 dup(   0)		; ...
KPARSE		db 0			; ...
ARG_ARGV	dw 0			; ...
ARGV0_ARG_FLAGS	db 0			; ...
ARGV0_ARGSTARTEL dw 0			; ...
ARGV0_ARGLEN	dw 0			; ...
ARGV0_ARGSW_WORD dw 0			; ...
ARGV0_OCOMPTR	dw 0			; ...
ARGV1_ARGPOINTER dw 0			; ...
		dw 0
		dw 0
		db 0
ARGV1_ARGSW_WORD dw 0			; ...
		dw 0
ARGV2_ARGPOINTER dw 0			; ...
		db 5 dup(0)
ARGV2_ARGSW_WORD dw 0			; ...
		db 673 dup(0)
ARG_ARGVCNT	dw 0			; ...
ARG_ARGSWINFO	dw 0			; ...
ARG_ARGBUF	db 512 dup(   0)	; ...
ARG_ARGFORCOMBUF db 128	dup(   0)	; ...
ARGBUF_PTR	dw 0			; ...
TPBUF		db 128 dup(   0)	; ...
LASTARG		dw 0			; ...
COMPTR		dw 0			; ...
FBUF		db 43 dup(   0)		; ...
pathinfo	dw 3 dup(   0)		; ...
psep_char	db 0			; ...
search_best	db 0			; ...
search_best_buf	db 13 dup(   0)		; ...
search_curdir_buf db 64	dup(   0)	; ...
search_error	dw 0			; ...
IF_NOT_COUNT	dw 0			; ...
zflag		db 0			; ...
		db 256 dup(   0)
STACK		db 32 dup(0)		; ...
CountryPtrInfo	db 0			; ...
CountryPtr	dd 0			; ...
OldCtrlCHandler	dd 0			; ...
BATBUFPOS	dw 0			; ...
BATBUF		db 32 dup(   0)		; ...
BATBUFEND	dw 0			; ...
TypeFilSiz	dw 2 dup(   0)		; ...
PARSE1_OUTPUT	db 0			; ...
PARSE1_CODE	db 0			; ...
PARSE1_SYN	dw 0			; ...
PARSE1_ADDR	dd 0			; ...
DATE_OUTPUT	db 0			; ...
		db 0
		dw 0
DATE_YEAR	dw 0			; ...
DATE_MONTH	db 0			; ...
DATE_DAY	db 0			; ...
TIME_OUTPUT	db 0			; ...
		db 0
		dw 0
TIME_HOUR	db 0			; ...
TIME_MINUTES	db 0			; ...
TIME_SECONDS	db 0			; ...
TIME_FRACTION	db 0			; ...
DRIVE_OUTPUT	db 0			; ...
DRIVE_VALUE	db 0
		dw 0
DRIVE_NUMBER	db 0
		db 3 dup(   0)
TRANGROUP	ends


		end StartCode
