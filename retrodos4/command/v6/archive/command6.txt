     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 6.22 Command Interpreter) - RETRO DOS v4.2 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 19/06/2023 (v6.22) ((Previous: 05/05/2023 COMMAND.COM v5.0))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15 (2.11)
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command6.s -l command6.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND5.S' (MSDOS 5.0 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 05/05/2023
    17                                  ; ----------------------------------------------------------------------------
    18                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    19                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    20                                  ; ----------------------------------------------------------------------------
    21                                  ;; 11/09/2018 - Erdogan Tan
    22                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    23                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    24                                  ; ----------------------------------------------------------------------------
    25                                  ; MSDOS 6.0 source files:
    26                                  ;;============================================================================
    27                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    28                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    29                                  ;;============================================================================
    30                                  ;
    31                                  ; COMMAND.COM v6.0 source files:
    32                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    33                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    34                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    35                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    36                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    37                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    38                                  ;
    39                                  ; COMMAND.COM v2.11 source files:
    40                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    41                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    42                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    43                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    44                                  ;
    45                                  ; ----------------------------------------------------------------------------
    46                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    47                                  
    48                                  ;============================================================================
    49                                  ; MSDOS 6.22 COMMAND.COM, DISASSEMBLED by Erdogan Tan, 17/05/2023-05/06/2023
    50                                  ;============================================================================
    51                                  
    52                                  ; -=========================================================================¬
    53                                  ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦
    54                                  ; ¦     Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>           ¦
    55                                  ; ¦                      Licensed to: Freeware version                      ¦
    56                                  ; L=========================================================================-
    57                                  ;
    58                                  ; Input MD5   : FAF051453F215165981F10BD73071D88
    59                                  ;
    60                                  ; File Name   : C:\Users\Erdo­an\Desktop\COMMAND.COM
    61                                  ; Format      : MS-DOS COM-file
    62                                  ; Base Address: 0h Range: 100h-D675h Loaded length: D575h
    63                                  
    64                                  ;============================================================================
    65                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    66                                  ;============================================================================
    67                                  ; 21/09/2018 - Retro DOS v3.0
    68                                  
    69                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    70                                  ;BREAK <system call definitions>
    71                                  
    72                                  ;
    73                                  ;	Microsoft Confidential
    74                                  ;	Copyright (C) Microsoft Corporation 1991
    75                                  ;	All Rights Reserved.
    76                                  ;
    77                                  
    78                                  ;SUBTTL	system call definitions
    79                                  ;PAGE
    80                                  
    81                                  Abort				EQU 0	;  0	  0
    82                                  STD_CON_INPUT			EQU 1	;  1	  1
    83                                  Std_Con_Output			EQU 2	;  2	  2
    84                                  Std_Aux_Input			EQU 3	;  3	  3
    85                                  Std_Aux_Output			EQU 4	;  4	  4
    86                                  Std_Printer_Output		EQU 5	;  5	  5
    87                                  Raw_Con_IO			EQU 6	;  6	  6
    88                                  RAW_CON_INPUT			EQU 7	;  7	  7
    89                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    90                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    91                                  Std_Con_String_Input		EQU 10	; 10	  A
    92                                  Std_Con_Input_Status		EQU 11	; 11	  B
    93                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    94                                  DISK_RESET			EQU 13	; 13	  D
    95                                  Set_Default_Drive		EQU 14	; 14	  E
    96                                  FCB_Open			EQU 15	; 15	  F
    97                                  FCB_Close			EQU 16	; 16	 10
    98                                  Dir_Search_First		EQU 17	; 17	 11
    99                                  Dir_Search_Next 		EQU 18	; 18	 12
   100                                  FCB_Delete			EQU 19	; 19	 13
   101                                  FCB_Seq_Read			EQU 20	; 20	 14
   102                                  FCB_Seq_Write			EQU 21	; 21	 15
   103                                  FCB_Create			EQU 22	; 22	 16
   104                                  FCB_Rename			EQU 23	; 23	 17
   105                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   106                                  Set_DMA 			EQU 26	; 26	 1A
   107                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   108                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   109                                  ;									   ;
   110                                  Get_Default_DPB 		EQU 31	; 31	 1F
   111                                  ;									   ;
   112                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  FCB_Random_Read 		EQU 33	; 33	 21
   115                                  FCB_Random_Write		EQU 34	; 34	 22
   116                                  Get_FCB_File_Length		EQU 35	; 35	 23
   117                                  Get_FCB_Position		EQU 36	; 36	 24
   118                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   119                                  Create_Process_Data_Block	EQU 38	; 38	 26
   120                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   121                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   122                                  Parse_File_Descriptor		EQU 41	; 41	 29
   123                                  Get_Date			EQU 42	; 42	 2A
   124                                  Set_Date			EQU 43	; 43	 2B
   125                                  Get_Time			EQU 44	; 44	 2C
   126                                  Set_Time			EQU 45	; 45	 2D
   127                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   128                                  ; Extended functionality group
   129                                  Get_DMA 			EQU 47	; 47	 2F
   130                                  GET_VERSION			EQU 48	; 48	 30
   131                                  Keep_Process			EQU 49	; 49	 31
   132                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   133                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   134                                  ;									   ;
   135                                  Get_DPB 			EQU 50	; 50	 32
   136                                  ;									   ;
   137                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   138                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   139                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   140                                  Get_InDOS_Flag			EQU 52	; 52	 34
   141                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   142                                  Get_Drive_Freespace		EQU 54	; 54	 36
   143                                  CHAR_OPER			EQU 55	; 55	 37
   144                                  International			EQU 56	; 56	 38
   145                                  ;   Directory Group
   146                                  MKDir				EQU 57	; 57	 39
   147                                  RMDir				EQU 58	; 58	 3A
   148                                  CHDir				EQU 59	; 59	 3B
   149                                  ;   File Group
   150                                  Creat				EQU 60	; 60	 3C
   151                                  OPEN				EQU 61	; 61	 3D
   152                                  CLOSE				EQU 62	; 62	 3E
   153                                  READ				EQU 63	; 63	 3F
   154                                  Write				EQU 64	; 64	 40
   155                                  Unlink				EQU 65	; 65	 41
   156                                  LSEEK				EQU 66	; 66	 42
   157                                  CHMod				EQU 67	; 67	 43
   158                                  IOCTL				EQU 68	; 68	 44
   159                                  XDUP				EQU 69	; 69	 45
   160                                  XDup2				EQU 70	; 70	 46
   161                                  Current_Dir			EQU 71	; 71	 47
   162                                  ;    Memory Group
   163                                  ALLOC				EQU 72	; 72	 48
   164                                  DEALLOC				EQU 73	; 73	 49
   165                                  SETBLOCK			EQU 74	; 74	 4A
   166                                  ;    Process Group
   167                                  Exec				EQU 75	; 75	 4B
   168                                  EXIT				EQU 76	; 76	 4C
   169                                  WAITPROCESS			EQU 77	; 77	 4D
   170                                  Find_First			EQU 78	; 78	 4E
   171                                  ;   Special Group
   172                                  Find_Next			EQU 79	; 79	 4F
   173                                  ; SPECIAL SYSTEM GROUP
   174                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   175                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   176                                  ;									   ;
   177                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   178                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   179                                  Get_In_Vars			EQU 82	; 82	 52
   180                                  SetDPB				EQU 83	; 83	 53
   181                                  ;									   ;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   184                                  Get_Verify_On_Write		EQU 84	; 84	 54
   185                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   186                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   187                                  ;									   ;
   188                                  Dup_PDB 			EQU 85	; 85	 55
   189                                  ;									   ;
   190                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   191                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   192                                  Rename				EQU 86	; 86	 56
   193                                  File_Times			EQU 87	; 87	 57
   194                                  AllocOper			EQU 88	; 88	 58
   195                                  ; Network extention system calls
   196                                  GetExtendedError		EQU 89	; 89	 59
   197                                  CreateTempFile			EQU 90	; 90	 5A
   198                                  CreateNewFile			EQU 91	; 91	 5B
   199                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   200                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   201                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   202                                  ;									   ;
   203                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   204                                  					;	    CloseByName, CloseUser,
   205                                  					;	    CloseUserProcess,
   206                                  					;	    GetOpenFileList
   207                                  ;									   ;
   208                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   209                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   210                                  UserOper			EQU 94	; 94	 5E Get and Set
   211                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   212                                  xNameTrans			EQU 96	; 96	 60
   213                                  PathParse			EQU 97	; 97	 61
   214                                  GetCurrentPSP			EQU 98	; 98	 62
   215                                  Hongeul 			EQU 99	; 99	 63
   216                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   217                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   218                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   219                                  ;									   ;
   220                                  Set_Printer_Flag		EQU 100 ; 100	 64
   221                                  ;									   ;
   222                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   223                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   224                                  GetExtCntry			EQU 101 ; 101	 65
   225                                  GetSetCdPg			EQU 102 ; 102	 66
   226                                  ExtHandle			EQU 103 ; 103	 67
   227                                  Commit				EQU 104 ; 104	 68
   228                                  GetSetMediaID			EQU 105 ; 105	 69
   229                                  IFS_IOCTL			EQU 107 ; 107	 6B
   230                                  ExtOpen 			EQU 108 ; 108	 6C
   231                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   232                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   233                                  ;                                                                          ;
   234                                  ;ifdef ROMEXEC
   235                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   236                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   237                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   238                                  ;endif
   239                                  ;                                                                          ;
   240                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   241                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   242                                  ;
   243                                  ;
   244                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   245                                  OEM_C1				EQU 249 ; 249	 F9
   246                                  OEM_C2				EQU 250 ; 250	 FA
   247                                  OEM_C3				EQU 251 ; 251	 FB
   248                                  OEM_C4				EQU 252 ; 252	 FC
   249                                  OEM_C5				EQU 253 ; 253	 FD
   250                                  OEM_C6				EQU 254 ; 254	 FE
   251                                  OEM_C7				EQU 255 ; 255	 FF
   252                                  
   253                                  ;============================================================================
   254                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   255                                  ;============================================================================
   256                                  ; 21/09/2018 - Retro DOS v3.0
   257                                  
   258                                  ;BREAK <Control character definitions>
   259                                  
   260                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   261                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   262                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   263                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   264                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   265                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   266                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   267                                  c_HT	    EQU     09h 	; ^I ASCII tab
   268                                  
   269                                  ;============================================================================
   270                                  ; DIRENT.INC, MSDOS 6.0, 1991
   271                                  ;============================================================================
   272                                  ; 21/09/2018 - Retro DOS v3.0
   273                                  
   274                                  ;Break <Directory entry>
   275                                  
   276                                  ;	NOTE:  These offsets are also used in the DTA for
   277                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   278                                  ;	with the FCB filename field, and the rest of the
   279                                  ;	DIR_ENTRY fields follow. -DavidOls
   280                                  
   281                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   282                                  ;
   283                                  ;	+---------------------------+
   284                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   285                                  ;	+---------------------------+
   286                                  ;	|     (BYTE) attributes     |	    11	    B
   287                                  ;	+---------------------------+
   288                                  ;	|    (10 BYTE) reserved     |	    12	    C
   289                                  ;	+---------------------------+
   290                                  ;	| (WORD) time of last write |	    22	    16
   291                                  ;	+---------------------------+
   292                                  ;	| (WORD) date of last write |	    24	    18
   293                                  ;	+---------------------------+
   294                                  ;	|   (WORD) First cluster    |	    26	    1A
   295                                  ;	+---------------------------+
   296                                  ;	|     (DWORD) file size     |	    28	    1C
   297                                  ;	+---------------------------+
   298                                  ;
   299                                  ;   First byte of filename  = E5 -> free directory entry
   300                                  ;			    = 00 -> end of allocated directory
   301                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   302                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   303                                  ;
   304                                  
   305                                  STRUC DIR_ENTRY
   306 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   307 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   308 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   309 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   310 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   311 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   312 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   313 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   314 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   315 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   316 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   317                                  .size:
   318                                  
   319                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   320                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   321                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   322                                  ;	    this field is zero for subdirectory files.
   323                                  
   324                                  ENDSTRUC
   325                                  
   326                                  ATTR_READ_ONLY	equ	 1h
   327                                  ATTR_HIDDEN	equ	 2h
   328                                  ATTR_SYSTEM	equ	 4h
   329                                  ATTR_VOLUME_ID	equ	 8h
   330                                  ATTR_DIRECTORY	equ	10h
   331                                  ATTR_ARCHIVE	equ	20h
   332                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   333                                  				;   NO directory entry on a disk EVER
   334                                  				;   has this bit set. It is set non-zero
   335                                  				;   when a device is found by GETPATH
   336                                  
   337                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   338                                  				; OR of hard attributes for FINDENTRY
   339                                  
   340                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   341                                  				; ignore this(ese) attribute(s) during
   342                                  				; search first/next
   343                                  
   344                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   345                                  				; changeable via CHMOD
   346                                  
   347                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   348                                  
   349                                  ;============================================================================
   350                                  ; ERROR.INC, MSDOS 6.0, 1991
   351                                  ;============================================================================
   352                                  ; 21/09/2018 - Retro DOS v3.0
   353                                  
   354                                  ;**	ERROR.INC - DOS Error Codes
   355                                  ;
   356                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   357                                  ;    return error codes through AX.	If an error occurred then
   358                                  ;    the carry bit will be set and the error code is in AX.	If no error
   359                                  ;    occurred then the carry bit is reset and AX contains returned info.
   360                                  ;
   361                                  ;    Since the set of error codes is being extended as we extend the operating
   362                                  ;    system, we have provided a means for applications to ask the system for a
   363                                  ;    recommended course of action when they receive an error.
   364                                  ;
   365                                  ;    The GetExtendedError system call returns a universal error, an error
   366                                  ;    location and a recommended course of action.	The universal error code is
   367                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   368                                  ;    is issued.
   369                                  
   370                                  
   371                                  ;	2.0 error codes
   372                                  
   373                                  error_invalid_function		EQU	1
   374                                  ERROR_FILE_NOT_FOUND		EQU	2
   375                                  ERROR_PATH_NOT_FOUND		EQU	3
   376                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   377                                  ERROR_ACCESS_DENIED		EQU	5
   378                                  error_invalid_handle		EQU	6
   379                                  error_arena_trashed		EQU	7
   380                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   381                                  error_invalid_block		EQU	9
   382                                  error_bad_environment		EQU	10
   383                                  ERROR_BAD_FORMAT		EQU	11
   384                                  error_invalid_access		EQU	12
   385                                  ERROR_INVALID_DATA		EQU	13
   386                                  ;**** reserved			EQU	14	; *****
   387                                  error_invalid_drive		EQU	15
   388                                  error_current_directory 	EQU	16
   389                                  error_not_same_device		EQU	17
   390                                  ERROR_NO_MORE_FILES		EQU	18
   391                                  
   392                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   393                                  
   394                                  ERROR_WRITE_PROTECT		EQU	19
   395                                  error_bad_unit			EQU	20
   396                                  error_not_ready 		EQU	21
   397                                  error_bad_command		EQU	22
   398                                  error_CRC			EQU	23
   399                                  error_bad_length		EQU	24
   400                                  error_Seek			EQU	25
   401                                  error_not_DOS_disk		EQU	26
   402                                  error_sector_not_found		EQU	27
   403                                  error_out_of_paper		EQU	28
   404                                  error_write_fault		EQU	29
   405                                  error_read_fault		EQU	30
   406                                  ERROR_GEN_FAILURE		EQU	31
   407                                  
   408                                  ;	the new 3.0 error codes reported through INT 24
   409                                  
   410                                  error_sharing_violation 	EQU	32
   411                                  error_lock_violation		EQU	33
   412                                  error_wrong_disk		EQU	34
   413                                  ERROR_FCB_UNAVAILABLE		EQU	35
   414                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   415                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   416                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   417                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   418                                  
   419                                  ;	New OEM network-related errors are 50-79
   420                                  
   421                                  error_not_supported		EQU	50
   422                                  
   423                                  error_net_access_denied		EQU	65	;M028
   424                                  
   425                                  ;	End of INT 24 reportable errors
   426                                  
   427                                  error_file_exists		EQU	80
   428                                  error_DUP_FCB			EQU	81	; *****
   429                                  error_cannot_make		EQU	82
   430                                  error_FAIL_I24			EQU	83
   431                                  
   432                                  ;	New 3.0 network related error codes
   433                                  
   434                                  error_out_of_structures 	EQU	84
   435                                  error_Already_assigned		EQU	85
   436                                  error_invalid_password		EQU	86
   437                                  error_invalid_parameter 	EQU	87
   438                                  error_NET_write_fault		EQU	88
   439                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   440                                  
   441                                  ;============================================================================
   442                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   443                                  ;============================================================================
   444                                  ; 22/09/2018 - Retro DOS v3.0
   445                                  
   446                                  ;**	DevSym.inc - Device Symbols
   447                                  
   448                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   449                                  
   450                                  STRUC SYSDEV
   451 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   452 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   453 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   454 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   455 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   456                                  .size:
   457                                  ENDSTRUC
   458                                  
   459                                  ; 24/09/2018
   460                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   461                                  
   462                                  ;============================================================================
   463                                  ; CURDIR.INC, MSDOS 6.0, 1991
   464                                  ;============================================================================
   465                                  ; 21/09/2018 - Retro DOS v3.0
   466                                  
   467                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   468                                  
   469                                  ;============================================================================
   470                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   471                                  ;============================================================================
   472                                  ; 21/09/2018 - Retro DOS v3.0
   473                                  
   474                                  ;/*
   475                                  ; *                      Microsoft Confidential
   476                                  ; *                      Copyright (C) Microsoft Corporation 1991
   477                                  ; *                      All Rights Reserved.
   478                                  ; */
   479                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   480                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   481                                  ;*************************************
   482                                  ; COMMAND EQUs which are not switch dependant
   483                                  
   484                                  ;		include	curdir.inc	; to get DIRSTRLEN
   485                                  ;		Note dossym.inc must already have been included!
   486                                  
   487                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   488                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   489                                  
   490                                  SYM		EQU	">"
   491                                  
   492                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   493                                  
   494                                  NORMPERLIN	EQU	1
   495                                  WIDEPERLIN	EQU	5
   496                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   497                                  BatLen		EQU	32		; buffer for batch files
   498                                  YES_ECHO	EQU	1		; echo line
   499                                  NO_ECHO 	EQU	0		; don't echo line
   500                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   501                                  call_in_progress EQU	1		; indicate we're in the CALL command
   502                                  length_call	EQU	4		; length of CALL
   503                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   504                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   505                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   506                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   507                                  nullcommand	EQU     1		; no command on command line
   508                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   509                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   510                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   511                                  result_number	EQU	1		;AN000; number returned from parser
   512                                  result_string	EQU	3		;AN000; string returned from parser
   513                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   514                                  result_drive	EQU	6		;AN000; drive returned from parser
   515                                  result_date	EQU	7		;AN000; date returned from parser
   516                                  result_time	EQU	8		;AN000; time returned from parser
   517                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   518                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   519                                  util_msg_class	EQU	-1		;AN000; message class for utility
   520                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   521                                  parse_msg_class EQU	2		;AN000; message class for parse error
   522                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   523                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   524                                  colon_char	EQU	":"             ;AN000; colon character
   525                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   526                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   527                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   528                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   529                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   530                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   531                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   532                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   533                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   534                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   535                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   536                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   537                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   538                                  parm_block_size equ	11		;AN000; size of message subst block
   539                                  blank		equ	" "             ;AN000; blank character
   540                                  no_subst	equ	0		;AN000; no substitutions for messages
   541                                  one_subst	equ	1		;AN000; one substitution for messages
   542                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   543                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   544                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   545                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   546                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   547                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   548                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   549                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   550                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   551                                  capital_A	equ	'A'             ;AC000;
   552                                  vbar		equ	'|'             ;AC000;
   553                                  labracket	equ	'<'             ;AC000;
   554                                  rabracket	equ	'>'             ;AC000;
   555                                  dollar		equ	'$'             ;AC000;
   556                                  lparen		equ	'('             ;AC000;
   557                                  rparen		equ	')'             ;AC000;
   558                                  nullrparen	equ	29h		;AC000;
   559                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   560                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   561                                  star		equ	'*'             ;AC000;
   562                                  plus_chr	equ	'+'             ;AC000;
   563                                  small_a 	equ	'a'             ;AC000;
   564                                  small_z 	equ	'z'             ;AC000;
   565                                  dot_chr 	equ	'.'             ;AC000;
   566                                  tab_chr 	equ	9		;AN032;
   567                                  equal_chr	equ	'='             ;AN032;
   568                                  semicolon	equ	';'             ;AN049;
   569                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   570                                  dot_colon	equ	2e3ah		;AC000; '.:'
   571                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   572                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   573                                  AppendInstall	equ	0B700H		;AN020; append install check
   574                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   575                                  AppendGetState	equ	0B706H		;AN020; append get current state
   576                                  AppendSetState	equ	0B707H		;AN020; append set current state
   577                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   578                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   579                                  
   580                                  ;*************************************
   581                                  ;* PARSE ERROR MESSAGES
   582                                  ;*************************************
   583                                  
   584                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   585                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   586                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   587                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   588                                  
   589                                  ;*************************************
   590                                  ;* EQUATES FOR MESSAGE RETRIEVER
   591                                  ;*************************************
   592                                  
   593                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   594                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   595                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   596                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   597                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   598                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   599                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   600                                  
   601                                  ;*********************************
   602                                  ;* EQUATES FOR INT 10H
   603                                  ;*********************************
   604                                  
   605                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   606                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   607                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   608                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   609                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   610                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   611                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   612                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   613                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   614                                  
   615                                  AltPipeChr	equ	"|"             ; alternate pipe character
   616                                  
   617                                  FCB		equ	5Ch
   618                                  
   619                                  STRUC VARSTRUC
   620 00000000 ??                      .ISDIR:		RESB	1
   621 00000001 ??                      .SIZ:		RESB	1
   622 00000002 ????                    .TTAIL:		RESW	1
   623 00000004 ??                      .INFO:		RESB	1
   624 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   625                                  .size:
   626                                  ENDSTRUC
   627                                  ;
   628                                  ; Flags for internal command parsing
   629                                  ;
   630                                  fCheckDrive	equ	00000001b	; validate drive letter
   631                                  fSwitchAllowed	equ	00000010b	; switches allowed
   632                                  fLimitHelp	equ	00000100b	; /? must appear alone
   633                                  
   634                                  ;
   635                                  ; Test switches
   636                                  ;
   637                                  fParse		EQU	0001h		; display results of parseline
   638                                  
   639                                  ;
   640                                  ; Batch segment structure
   641                                  ;
   642                                  ;   BYTE    type of segment
   643                                  ;   BYTE    echo state of parent on entry to batch file
   644                                  ;   WORD    segment of last batch file
   645                                  ;   WORD    segment for FOR command
   646                                  ;   BYTE    FOR flag state on entry to batch file
   647                                  ;   DWORD   offset for next line
   648                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   649                                  ;   ASCIZ   file name (with . and ..)
   650                                  ;   BYTES   CR-terminated parameters
   651                                  ;   BYTE    0 flag to indicate end of parameters
   652                                  ;
   653                                  
   654                                  BATCHTYPE   equ 0
   655                                  
   656                                  STRUC BATCHSEGMENT
   657 00000000 ??                      .BatType:	RESB	1		; signature
   658 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   659                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   660 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   661 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   662 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   663 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   664 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   665 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   666 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   667                                  .SIZE:
   668                                  ENDSTRUC
   669                                  
   670                                  ANULL		equ	0		; terminates an argv string
   671                                  ARGMAX		equ	64		; max args on a command line
   672                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   673                                  tplen		equ	64		; max size of one argument
   674                                  arg_cnt_error	equ	1		; number of args > MAXARG
   675                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   676                                  
   677                                  STRUC ARGV_ELE				; elements in the argv array
   678 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   679 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   680 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   681 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   682 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   683 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   684                                  .SIZE:
   685                                  ENDSTRUC
   686                                  
   687                                  STRUC ARG_UNIT
   688 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   689 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   690 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   691 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   692 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   693                                  .SIZE:
   694                                  ENDSTRUC
   695                                  
   696                                  ; Equates for initialization
   697                                  ;
   698                                  INITINIT	equ	01h		; initialization in progress
   699                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   700                                  INITCTRLC	equ	04h		; already in ^C handler
   701                                  
   702                                  ;============================================================================
   703                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   704                                  ;============================================================================
   705                                  ; 16/04/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   706                                  
   707                                  ; Current structure of the data returned by the international call
   708                                  
   709                                  struc INTERNAT_BLOCK
   710 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   711 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   712 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   713 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   714 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   715 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   716 0000000F ??                      .bit_field:	resb 1			; Bit values
   717                                  					;   Bit 0 = 0 if currency symbol first
   718                                  					;	  = 1 if currency symbol last
   719                                  					;   Bit 1 = 0 if No space after currency symbol
   720                                  					;	  = 1 if space after currency symbol
   721                                  .currency_cents:
   722 00000010 ??                      		resb 1			; Number of places after currency dec point
   723 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   724 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   725                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   726                                  					;  in pieces.
   727 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   728 00000017 ??                      		resb 1
   729                                  endstruc
   730                                  
   731                                  ; Max size of the block returned by the INTERNATIONAL call
   732                                  
   733                                  internat_block_max equ 32
   734                                  
   735                                  ;============================================================================
   736                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   737                                  ;============================================================================
   738                                  ; 13/10/2018 - Retro DOS v3.0
   739                                  ; 16/02/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   740                                  
   741                                  ;Break	<find first/next buffer>
   742                                  
   743                                  	; MSDOS 3.3 & MSDOS 6.0
   744                                  
   745                                  struc FIND_BUF
   746 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   747 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   748 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   749 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   750 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   751 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   752 00000015 ??                      .ATTR:	    resb 1	; attribute found
   753 00000016 ????                    .TIMR:	    resw 1	; time
   754 00000018 ????                    .DATE:	    resw 1	; date
   755 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   756 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   757 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   758                                  .size:
   759                                  endstruc
   760                                  
   761                                  ;=============================================================================
   762                                  ; PDB.INC, MSDOS 6.0, 1991
   763                                  ;=============================================================================
   764                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   765                                  
   766                                  ;**	Process data block (otherwise known as program header)
   767                                  
   768                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   769                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   770                                  ;	for use.
   771                                  
   772                                  FILPERPROC	EQU     20
   773                                  
   774                                  struc PDB	; Process_data_block
   775 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   776 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   777 00000004 ??                                      resb 1
   778 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   779 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   780 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   781 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   782 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   783 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   784 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   785 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   786 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   787 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   788 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   789 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   790 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   791 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   792 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   793 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   794 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   795 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   796                                  				;  an extended FCB
   797                                  ;endstruc 	; MSDOS 3.3
   798                                  	  	; MSDOS 6.0
   799 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   800 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   801 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   802 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   803                                  endstruc
   804                                  
   805                                  ;=============================================================================
   806                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   807                                  ;=============================================================================
   808                                  ; 24/09/2018 - Retro DOS v3.0
   809                                  
   810                                  ;major_version	equ 6		; Major DOS version
   811                                  ;minor_version	equ 0		; Minor DOS Version
   812                                  
   813                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   814                                  
   815                                  ; MSDOS 3.3 COMMAND.COM
   816                                  ;MAJOR_VERSION	EQU 3
   817                                  ;MINOR_VERSION	EQU 30
   818                                  
   819                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   820                                  ;MAJOR_VERSION	EQU 5		; Major DOS version
   821                                  ;MINOR_VERSION	EQU 0		; Minor DOS version
   822                                  
   823                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
   824                                  MAJOR_VERSION	EQU 6		; Major DOS version
   825                                  MINOR_VERSION	EQU 22		; Minor DOS version
   826                                  
   827                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   828                                  
   829                                  ;-----------------------------------------------------------------------------
   830                                  ; 21/09/2018
   831                                  ;-----------------------------------------------------------------------------
   832                                  ; Retro DOS v3.0 NOTE:  
   833                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   834                                  ;	with minor modifications which are done by me (Erdogan Tan).
   835                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   836                                  ;	source code files (written by using MASM syntax).
   837                                  ;-----------------------------------------------------------------------------
   838                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   839                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   840                                  ;----------------------------------------------------------------------------- 	
   841                                  
   842                                  ;=============================================================================
   843                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   844                                  ;=============================================================================
   845                                  ; 21/09/2018 - Retro DOS v3.0
   846                                  
   847                                  ;	page ,132
   848                                  ;	title	COMMAND - resident code for COMMAND.COM
   849                                  ;	name	COMMAND
   850                                  
   851                                  ;/*
   852                                  ; *                      Microsoft Confidential
   853                                  ; *                      Copyright (C) Microsoft Corporation 1991
   854                                  ; *                      All Rights Reserved.
   855                                  ; */
   856                                  
   857                                  ;*****************************************************************************
   858                                  ;
   859                                  ; MODULE:	       COMMAND.COM
   860                                  ;
   861                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   862                                  ;
   863                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   864                                  ;		       parts.  First is the resident portion, which includes
   865                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   866                                  ;		       error), and 2EH (command line execute); it also has
   867                                  ;		       code to test and, if necessary, reload the transient
   868                                  ;		       portion. Following the resident is the init code, which
   869                                  ;		       is overwritten after use.  Then comes the transient
   870                                  ;		       portion, which includes all command processing (whether
   871                                  ;		       internal or external).  The transient portion loads at
   872                                  ;		       the end of physical memory, and it may be overlayed by
   873                                  ;		       programs that need as much memory as possible. When the
   874                                  ;		       resident portion of command regains control from a user
   875                                  ;		       program, a check sum is performed on the transient
   876                                  ;		       portion to see if it must be reloaded.  Thus programs
   877                                  ;		       which do not need maximum memory will save the time
   878                                  ;		       required to reload COMMAND when they terminate.
   879                                  ;
   880                                  ; ENTRY POINT:	       PROGSTART
   881                                  ;
   882                                  ; INPUT:	       command line at offset 81H
   883                                  ;
   884                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   885                                  ;		       from a secondary command processor via the EXIT
   886                                  ;		       internal command.
   887                                  ;
   888                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   889                                  ;		       hang the system.
   890                                  ;
   891                                  ; INTERNAL REFERENCES:
   892                                  ;
   893                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   894                                  ;		       (COMMAND.DOC)
   895                                  ;
   896                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   897                                  ;		       (COMMAND.DOC)
   898                                  ;
   899                                  ; EXTERNAL REFERENCES:
   900                                  ;
   901                                  ;      ROUTINES:       none
   902                                  ;
   903                                  ;      DATA AREAS:     none
   904                                  ;
   905                                  ;*****************************************************************************
   906                                  ;
   907                                  ;			      REVISION HISTORY
   908                                  ;			      ----------------
   909                                  ;
   910                                  ; DOS 1.00 to DOS 3.30
   911                                  ; --------------------------
   912                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   913                                  ;
   914                                  ; REV 1.17
   915                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   916                                  ;	       resident since the EXELOAD may have overwritten the transient.
   917                                  ;
   918                                  ; REV 1.18
   919                                  ;    05/21/82  IBM version always looks on drive A
   920                                  ;	       MSVER always looks on default drive
   921                                  ;
   922                                  ; REV 1.19
   923                                  ;    06/03/82  Drive spec now entered in command line
   924                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   925                                  ;	       (print volume label)
   926                                  ;
   927                                  ; REV 1.20
   928                                  ;    06/09/82  Prints "directory" after directories
   929                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   930                                  ;
   931                                  ; REV 1.50
   932                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   933                                  ;	       do it right.
   934                                  ;
   935                                  ; REV 1.70
   936                                  ;	       EXEC used to fork off new processes
   937                                  ;
   938                                  ; REV 1.80
   939                                  ;	       C switch for single command execution
   940                                  ;
   941                                  ; REV 1.90
   942                                  ;	       Batch uses XENIX
   943                                  ;
   944                                  ; Rev 2.00
   945                                  ;	       Lots of neato stuff
   946                                  ;	       IBM 2.00 level
   947                                  ;
   948                                  ; Rev 2.01
   949                                  ;	       'D' switch for date time suppression
   950                                  ;
   951                                  ; Rev 2.02
   952                                  ;	       Default userpath is NUL rather than BIN
   953                                  ;		       same as IBM
   954                                  ;	       COMMAND split into pieces
   955                                  ;
   956                                  ; Rev 2.10
   957                                  ;	       INTERNATIONAL SUPPORT
   958                                  ;
   959                                  ; Rev 2.50
   960                                  ;	       all the 2.x new stuff -MU
   961                                  ;
   962                                  ; Rev 3.30     (Ellen G)
   963                                  ;	       CALL internal command (TBATCH2.ASM)
   964                                  ;	       CHCP internal command (TCMD2B.ASM)
   965                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   966                                  ;	       @ sign suppression of batch file line
   967                                  ;	       Replaceable environment value support in batch files
   968                                  ;	       INT 2FH calls for APPEND
   969                                  ;	       Lots of PTR fixes!
   970                                  ;
   971                                  ; Beyond 3.30 to forever  (Ellen G)
   972                                  ; ----------------------
   973                                  ;
   974                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   975                                  ;			Use Message Retriever services
   976                                  ;			/MSG switch for resident extended error msg
   977                                  ;			Convert to new capitalization support
   978                                  ;			Better error recovery on CHCP command
   979                                  ;			Code page file tag support
   980                                  ;			TRUENAME internal command
   981                                  ;			Extended screen line support
   982                                  ;			/P switch on DEL/ERASE command
   983                                  ;			Improved file redirection error recovery
   984                                  ;	(removed)	Improved batch file performance
   985                                  ;			Unconditional DBCS support
   986                                  ;			Volume serial number support
   987                                  ;	(removed)	COMMENT=?? support
   988                                  ;
   989                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   990                                  ;
   991                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   992                                  ;			require delimiters.
   993                                  ;
   994                                  ; A003	PTM P5,P9,P111	Included in A000 development
   995                                  ;
   996                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   997                                  ;			executing
   998                                  ;
   999                                  ; A005	DCR D17 	If user specifies an extension on the command
  1000                                  ;			line search for that extension only.
  1001                                  ;
  1002                                  ; A006	DCR D15 	New message for MkDir - "Directory already
  1003                                  ;			exists"
  1004                                  ;
  1005                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
  1006                                  ;
  1007                                  ; A008	PTM P182	Change COPY to set default if invalid function
  1008                                  ;			returned from code page call.
  1009                                  ;
  1010                                  ; A009	PTM P179	Add CRLF to invalid disk change message
  1011                                  ;
  1012                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
  1013                                  ;			transient COMMAND.
  1014                                  ;
  1015                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
  1016                                  ;			before appending to a file.
  1017                                  ;
  1018                                  ; A012	PTM P189	Fix redirection error recovery.
  1019                                  ;
  1020                                  ; A013	PTM P330	Change date format
  1021                                  ;
  1022                                  ; A014	PTM P455	Fix echo parsing
  1023                                  ;
  1024                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1025                                  ;
  1026                                  ; A016	PTM P354	Fix extended error message addressing
  1027                                  ;
  1028                                  ; A017	PTM P448	Fix appending to 0 length files
  1029                                  ;
  1030                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1031                                  ;			the parser fails on. Fail on duplicate switches.
  1032                                  ;
  1033                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1034                                  ;			critical error
  1035                                  ;
  1036                                  ; A020	DCR D43 	Set append state off while in DIR
  1037                                  ;
  1038                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1039                                  ;
  1040                                  ; A022	DCR D209	Enhanced error recovery
  1041                                  ;
  1042                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1043                                  ;
  1044                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1045                                  ;
  1046                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1047                                  ;
  1048                                  ; A026	DCR D191	Change redirection error recovery support.
  1049                                  ;
  1050                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1051                                  ;			with a carriage return.
  1052                                  ;
  1053                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1054                                  ;			date and invalid time messages.
  1055                                  ;
  1056                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1057                                  ;			and TIME.
  1058                                  ;
  1059                                  ; A030	DCR D201	New extended attribute format.
  1060                                  ;
  1061                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1062                                  ;
  1063                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1064                                  ;
  1065                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1066                                  ;
  1067                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1068                                  ;
  1069                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1070                                  ;			do a read to determine eof.
  1071                                  ;
  1072                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1073                                  ;			so that ASSIGN works correctly.
  1074                                  ;
  1075                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1076                                  ;
  1077                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1078                                  ;
  1079                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1080                                  ;
  1081                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1082                                  ;			specified.
  1083                                  ;
  1084                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1085                                  ;			executes.
  1086                                  ;
  1087                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1088                                  ;			files causing loss of batch file.
  1089                                  ;
  1090                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1091                                  ;			CALL'ed batch files.
  1092                                  ;
  1093                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1094                                  ;			as an end of line character
  1095                                  ;
  1096                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1097                                  ;			and extended message pointers when we EXIT if
  1098                                  ;			COMMAND /P is the top level process.
  1099                                  ;
  1100                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1101                                  ;			"File not found - fn"
  1102                                  ;
  1103                                  ; A047	PTM P2819	Fix transient reload prompt message
  1104                                  ;
  1105                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1106                                  ;			when DBCS code was added.
  1107                                  ;
  1108                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1109                                  ;			on line.
  1110                                  ;
  1111                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1112                                  ;
  1113                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1114                                  ;
  1115                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1116                                  ;
  1117                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1118                                  ;
  1119                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1120                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1121                                  ;
  1122                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1123                                  ;			problems with breaking out of INT 24h
  1124                                  ;
  1125                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1126                                  ;
  1127                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1128                                  ;			before the "string".  EX: COMMAND /CDIR
  1129                                  ;
  1130                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1131                                  ;			DBCS switch.
  1132                                  ;
  1133                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1134                                  ;			the time.
  1135                                  ;
  1136                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1137                                  ;			messages to be disk based.  Only keep them if /MSG
  1138                                  ;			is used.
  1139                                  ;
  1140                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1141                                  ;			out of internal commands, due to substitution blocks
  1142                                  ;			not being reset.
  1143                                  ;
  1144                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1145                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1146                                  ;			secondary copy of environment.	Change default slash in
  1147                                  ;			default comspec string to backslash.
  1148                                  ;
  1149                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1150                                  ;			text for critical error messages.
  1151                                  ;
  1152                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1153                                  ;	5/20/88 	with Microsoft product already shipped.
  1154                                  ;
  1155                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1156                                  ;	 5/20/88	with Microsoft product already shipped.
  1157                                  ;
  1158                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1159                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1160                                  ;			header and space remaining.
  1161                                  ;
  1162                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1163                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1164                                  ;			environment was putting a "Z block" marker in the old
  1165                                  ;			environment.  The fix is to move to the old environment
  1166                                  ;			to the new environment before doing the SETBLOCK.
  1167                                  ;
  1168                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1169                                  ;        09/19/88       because the check for APPEND needed to be performed
  1170                                  ;                       before the DIR's findfirst.
  1171                                  ;
  1172                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1173                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1174                                  ;                       loading trans w/new comspec with no user change comspec.
  1175                                  ;
  1176                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1177                                  ;        11/05/88       Expansion of environment variables into batch line of
  1178                                  ;                       128 chars was not being counted and "%" which should be
  1179                                  ;                       ignored were being counted.
  1180                                  ;
  1181                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1182                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1183                                  ;                       ing included in checksum and was being overwritten by
  1184                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1185                                  ;                       Also removed fix A069 (because flag now protected).
  1186                                  ;
  1187                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1188                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1189                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1190                                  ;
  1191                                  ;***********************************************************************************
  1192                                  
  1193                                  ;
  1194                                  ;	Revision History
  1195                                  ;	================
  1196                                  ;
  1197                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1198                                  ;					at init time (date/time prompt)
  1199                                  ;
  1200                                  
  1201                                  ;
  1202                                  ;.xcref
  1203                                  ;.xlist
  1204                                  ;	include dossym.inc		; basic DOS symbol set
  1205                                  ;	include syscall.inc		; DOS function names
  1206                                  ;	include comsw.asm		; build version info
  1207                                  ;	include comequ.asm		; common command.com symbols
  1208                                  ;	include resmsg.equ		; resident message names
  1209                                  ;
  1210                                  ;	include comseg.asm		;segment ordering
  1211                                  ;.list
  1212                                  ;.cref
  1213                                  
  1214                                  ;CODERES segment public byte
  1215                                  ;CODERES ends
  1216                                  ;
  1217                                  ;DATARES 	segment public byte
  1218                                  ;		extrn	AccDen:byte
  1219                                  ;		extrn	Batch:word
  1220                                  ;		extrn	EchoFlag:byte
  1221                                  ;		extrn	ExeBad:byte
  1222                                  ;		extrn	ExecEMes:byte
  1223                                  ;		extrn	ExecErrSubst:byte
  1224                                  ;		extrn	ExtCom:byte
  1225                                  ;		extrn	ForFlag:byte
  1226                                  ;		extrn	IfFlag:byte
  1227                                  ;		extrn	InitFlag:BYTE
  1228                                  ;		extrn	Nest:word
  1229                                  ;		extrn	PipeFlag:byte
  1230                                  ;		extrn	RBadNam:byte
  1231                                  ;		extrn	RetCode:word
  1232                                  ;		extrn	SingleCom:word
  1233                                  ;		extrn	TooBig:byte
  1234                                  ;
  1235                                  ;		extrn	OldDS:word
  1236                                  ;
  1237                                  ;DATARES 	ends
  1238                                  ;
  1239                                  ;
  1240                                  ;INIT		segment public para
  1241                                  ;		extrn	ConProc:near
  1242                                  ;		extrn	Init_Contc_SpecialCase:near
  1243                                  ;INIT		ends
  1244                                  
  1245                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1246                                  ; --------------------------------------
  1247                                  ; 'command5.s' source code reference(s):
  1248                                  
  1249                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1250                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1251                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1252                                  ; ----------------------------------------------------------------------				 	 	
  1253                                  
  1254                                  ; -----------------------------------------------------------------------------
  1255                                  ; START OF RESIDENT PORTION
  1256                                  ; -----------------------------------------------------------------------------
  1257                                  ; SEGMENT - DATARES
  1258                                  ; -----------------------------------------------------------------------------
  1259                                  
  1260                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1261                                  
  1262                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1263                                  
  1264                                  ;==============================================================================
  1265                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1266                                  ;==============================================================================
  1267                                  
  1268                                  ;This file contains the low memory stub for command.com which hooks all the
  1269                                  ;entry points into the resident command.com and directs the calls to the
  1270                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1271                                  ;
  1272                                  ;The stub has been made part of the resident data and will always
  1273                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1274                                  ;that actually hook the interrupt vectors belong to either the first 
  1275                                  ;command.com or to any other command.com executed with the /p switch. 
  1276                                  ;
  1277                                  ;The stub also keeps track of the current active data segment. The 
  1278                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1279                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1280                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1281                                  ;the exit code picks up the previous data segment pointer from the current
  1282                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1283                                  ;
  1284                                  ;Right now the stub does not bother about A20 switching. We assume
  1285                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1286                                  ;value of the current data segment in one of the registers. A20 toggle 
  1287                                  ;support maybe added as a future enhancement, if the need is felt.
  1288                                  
  1289                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1290                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1291                                  
  1292                                  	[ORG 100H]
  1293                                  
  1294                                  	; 21/09/2018 - Retro DOS v3.0
  1295                                  StartCode:
  1296 00000000 E91D15                  	jmp	ConProc	; 10/01/2023 
  1297                                  
  1298                                  	; 09/01/2023
  1299                                  
  1300                                  ; Make following table word-aligned, and at the same time, provide a
  1301                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1302                                  
  1303                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1304 00000003 66                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1305                                  
  1306                                  ;All the entry points declared below are patched in at INIT time with the
  1307                                  ;proper segment and offset values after the resident code segment has been
  1308                                  ;moved to its final location
  1309                                  
  1310                                  ;!!!WARNING!!!
  1311                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1312                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1313                                  ;in the correct segments and offsets
  1314                                  
  1315                                  Int2f_Entry:
  1316 00000004 [3314]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1317 00000006 0000                    	dw	0
  1318                                  Int2e_Entry:
  1319 00000008 [860E]                  	dw	Int_2e			; Address of int 2eh handler
  1320 0000000A 0000                    	dw	0
  1321                                  Ctrlc_Entry:
  1322 0000000C [430D]                  	dw	ContC			; Address of Ctrl-C handler
  1323 0000000E 0000                    	dw	0
  1324                                  CritErr_Entry:
  1325 00000010 [4711]                  	dw	DSKERR			; Address of critical error handler
  1326 00000012 0000                    	dw	0
  1327                                  
  1328                                  Exec_Entry:
  1329 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1330                                  RemCheck_Entry:
  1331 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1332                                  TrnLodCom1_Entry:
  1333 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1334                                  LodCom_Entry:
  1335 00000020 00000000                	dd	0			; Entry after exit from command.com
  1336                                  MsgRetrv_Entry:
  1337 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1338                                  HeadFix_Entry:
  1339 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1340                                  UMBOff_Entry:
  1341 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1342                                  XMMCallAddr:
  1343 00000030 00000000                	dd	0			; Call address for XMM functions
  1344                                  ComInHMA:
  1345 00000034 00                      	db	0			; Flags if command.com in HMA
  1346                                  
  1347                                  Int2f_Trap:
  1348                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1349 00000035 E86400                  	call	CheckA20
  1350 00000038 1E                      	push	ds			; push current ds value
  1351 00000039 0E                      	push	cs			; push resident data segment value
  1352                                  	;jmp	cs:Int2f_Entry
  1353 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1354                                  
  1355                                  Int2e_Trap:
  1356 0000003F FB                      	sti
  1357 00000040 E85900                  	call	CheckA20
  1358 00000043 1E                      	push	ds			; push current ds value
  1359 00000044 0E                      	push	cs			; push resident data segment value
  1360                                  	;jmp	cs:Int2e_Entry
  1361 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1362                                  
  1363                                  Ctrlc_Trap:
  1364 0000004A FB                      	sti
  1365 0000004B E84E00                  	call	CheckA20
  1366 0000004E 1E                      	push	ds			; push current ds value
  1367 0000004F 0E                      	push	cs			; push resident data segment value
  1368                                  	;jmp	cs:Ctrlc_Entry
  1369 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1370                                  
  1371                                  CritErr_Trap:
  1372 00000055 FB                      	sti
  1373 00000056 E84300                  	call	CheckA20
  1374 00000059 1E                      	push	ds			; push current ds value
  1375 0000005A 0E                      	push	cs			; push resident data segment value
  1376                                  	;jmp	cs:CritErr_Entry
  1377 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1378                                  
  1379                                  Exec_Trap:
  1380 00000060 E83900                  	call	CheckA20
  1381 00000063 1E                      	push	ds			; push current ds value
  1382 00000064 0E                      	push	cs			; push resident data segment value
  1383                                  	;jmp	cs:Exec_Entry
  1384 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1385                                  
  1386                                  RemCheck_Trap:
  1387 0000006A E82F00                  	call	CheckA20
  1388 0000006D 1E                      	push	ds			; push current ds value
  1389 0000006E 0E                      	push	cs			; push resident data segment value
  1390                                  	;jmp	cs:RemCheck_Entry
  1391 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1392                                  
  1393                                  TrnLodCom1_Trap:
  1394 00000074 E82500                  	call	CheckA20
  1395 00000077 1E                      	push	ds			; push current ds value
  1396 00000078 0E                      	push	cs			; push resident data segment value
  1397                                  	;jmp	cs:TrnLodCom1_Entry
  1398 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1399                                  
  1400                                  LodCom_Trap:
  1401 0000007E E81B00                  	call	CheckA20
  1402 00000081 1E                      	push	ds			; push current ds value
  1403 00000082 0E                      	push	cs			; push resident data segment value
  1404                                  	;jmp	cs:LodCom_Entry
  1405 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1406                                  
  1407                                  MsgRetrv_Trap:
  1408 00000088 E81100                  	call	CheckA20
  1409 0000008B 1E                      	push	ds			; push current ds value
  1410 0000008C 0E                      	push	cs			; push resident data segment value
  1411                                  	;jmp	cs:MsgRetrv_Entry
  1412 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1413                                  
  1414                                  HeadFix_Trap:
  1415 00000092 E80700                  	call	CheckA20
  1416 00000095 1E                      	push	ds			; push current ds value
  1417 00000096 0E                      	push	cs			; push resident data segment value
  1418                                  	;jmp	cs:HeadFix_Entry
  1419 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1420                                  
  1421                                  ; ----------------------------------------------------------------------------
  1422                                  
  1423                                  	; 09/01/2023
  1424                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1425                                  
  1426                                  	; 05/06/2023
  1427                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1428                                  CheckA20:
  1429 0000009C 9C                      	pushf				; save current flags
  1430 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1431 000000A3 7408                    	jz	short A20_on		; no, jump to resident
  1432                                  
  1433 000000A5 E80C00                  	call	QueryA20
  1434 000000A8 7303                    	jnc	short A20_on		; A20 is on, jump to resident
  1435                                  
  1436 000000AA E81800                  	call	EnableA20		; turn A20 on
  1437                                  A20_on:
  1438 000000AD 9D                      	popf				; flags have to be unchanged
  1439 000000AE C3                      	retn
  1440                                  
  1441                                  ; ----------------------------------------------------------------------------
  1442                                  
  1443                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1444                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1445                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1446                                  ; M005; pointers because our cs is going to be different. The segment to
  1447                                  ; M005; jump to is patched in at init time. (in init.asm)
  1448                                  
  1449                                  Carousel_i2f_Hook:			; M005
  1450 000000AF EA                      	db	0EAh			; far jump opcode; M005
  1451 000000B0 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1452 000000B2 0000                    	dw	0			; int 2fh segment; M005
  1453                                  
  1454                                  ; ----------------------------------------------------------------------------
  1455                                  
  1456                                  XMM_QUERY_A20 equ 7 ; 09/01/2023
  1457                                  
  1458                                  QueryA20:
  1459 000000B4 53                      	push	bx
  1460 000000B5 50                      	push	ax
  1461                                  	;mov	ah,7
  1462 000000B6 B407                    	mov	ah,XMM_QUERY_A20
  1463                                  	;call	cs:XMMCallAddr
  1464 000000B8 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1465 000000BD 09C0                    	or	ax,ax
  1466 000000BF 58                      	pop	ax
  1467 000000C0 5B                      	pop	bx
  1468                                  	; 16/04/2023
  1469 000000C1 7501                    	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1470                                  
  1471 000000C3 F9                      	stc					; OFF
  1472                                  	;retn
  1473                                  QA20_ON:
  1474                                  	;clc					; ON
  1475 000000C4 C3                      	retn
  1476                                  
  1477                                  ; ----------------------------------------------------------------------------
  1478                                  
  1479                                  XMM_LOCAL_ENABLE_A20 equ 5
  1480                                  
  1481                                  EnableA20:
  1482 000000C5 53                      	push	bx
  1483 000000C6 50                      	push	ax
  1484                                  	;mov	ah,5
  1485 000000C7 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20
  1486                                  	;call	cs:XMMCallAddr
  1487 000000C9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1488 000000CE 09C0                    	or	ax,ax
  1489 000000D0 7403                    	jz	short XMMerror			; AX = 0 fatal error
  1490 000000D2 58                      	pop	ax
  1491 000000D3 5B                      	pop	bx
  1492 000000D4 C3                      	retn
  1493                                  
  1494                                  ;If we get an error, we just loop forever
  1495                                  
  1496                                  XMMerror:
  1497 000000D5 EBFE                    	jmp	short XMMerror
  1498                                  
  1499                                  ; -----------------------------------------------------------------------------
  1500                                  
  1501                                  ; 05/06/2023
  1502                                  ;HV_Extern	equ	1
  1503                                  ;HV_LoadHigh	equ	1
  1504                                  ;HV_Stub	equ	1
  1505                                  ;	include	highvar.inc	; Make high-memory variables external here
  1506                                  ;	include	highexit.inc	; And add code for UnHideUMBs
  1507                                  
  1508                                  ;==============================================================================
  1509                                  ; HIGHEXIT.INC, MSDOS 6.0, 1992
  1510                                  ;==============================================================================
  1511                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1512                                  
  1513                                  DOS_STRATEGY_GET equ  5800h	; Int 21h, Func 58h, Svc 0 = get alloc strategy
  1514                                  DOS_STRATEGY_SET equ  5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
  1515                                  DOS_UMBLINK_GET	equ   5802h	; Int 21h, Func 58h, Svc 2 = get link state
  1516                                  DOS_UMBLINK_SET	equ   5803h	; Int 21h, Func 58h, Svc 3 = set link state
  1517                                  DOS_GET_LISTS	equ     52h	; Int 21h, Func 52h = get list of lists
  1518                                  
  1519                                  UMB_HeadIdx	equ     8Ch	; Offset from ES (after func52h) to get UMBHead
  1520                                  
  1521                                  	; 05/06/2023
  1522                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:01D9h
  1523                                  
  1524                                  ; -----------------------------------------------------------------------------
  1525                                  ;*** UnHideUMBs - Marks HIDDEN elements as FREE
  1526                                  ; -----------------------------------------------------------------------------
  1527                                  ; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
  1528                                  ;               very little to do, as no elelments will be marked as HIDDEN.
  1529                                  ; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
  1530                                  ; ERROR:  None
  1531                                  ; USES:   fInHigh (from highvar.inc), carry flag
  1532                                  ; -----------------------------------------------------------------------------
  1533                                  
  1534                                  UnHideUMBs:
  1535 000000D7 50                      	push	ax		; Save ax for what we're about to do
  1536                                  
  1537                                  ; -----------------------------------------------------------------------------
  1538                                  ; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
  1539                                  ;    length of time. Those six constitute a check of whether or not we should
  1540                                  ;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
  1541                                  ;    will destroy the current link-state and memory-allocation strategy after
  1542                                  ;    every command execution.
  1543                                  ; -----------------------------------------------------------------------------
  1544                                  
  1545                                  	; 05/06/2023
  1546                                  	;getdata al,fInHigh	; Get InHigh from data segment
  1547                                  	;
  1548                                  	;push	ds
  1549 000000D8 A0[F604]                	mov	al,[fInHigh]
  1550                                  	;pop	ds
  1551                                  
  1552                                  	;or	al, al
  1553                                  	;jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
  1554                                  
  1555                                  	;pop	ax		; then there's nothing to do here... so
  1556                                  	;stc			; restore everything and return.  Just like
  1557                                  	;retn			; that.
  1558                                  
  1559                                  	; 05/06/2023
  1560 000000DB 3C01                    	cmp	al,1
  1561 000000DD 720F                    	jb	short uhu20	; cf=1
  1562                                  uhu10:	
  1563 000000DF E8A600                  	call	linkumb		; Make sure UMBs are linked in.
  1564 000000E2 E82000                  	call	FreeUMBs
  1565                                  
  1566                                  	;putdata fInHigh, 0	; We're leaving, so update fInHigh.
  1567                                  	;
  1568                                  	;push	es
  1569                                  	;mov	byte [es:fInHigh],0
  1570                                  	;pop	es
  1571                                  	; 05/06/2023
  1572 000000E5 C606[F604]00            	mov	byte [fInHigh],0
  1573                                  
  1574 000000EA E80300                  	call	he_unlink	; Unlink UMBs
  1575                                  
  1576                                  	;pop	ax
  1577                                  	;clc
  1578                                  	;retn
  1579                                  
  1580 000000ED F8                      	clc
  1581                                  uhu20:
  1582 000000EE 58                      	pop	ax
  1583 000000EF C3                      	retn
  1584                                  
  1585                                  ; -----------------------------------------------------------------------------
  1586                                  ;*** he_unlink - unlinks UMBs if fm_umb is set to 0
  1587                                  ; -----------------------------------------------------------------------------
  1588                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
  1589                                  ; EXIT:     None
  1590                                  ; ERROR:    None
  1591                                  ; USES:     AX, BX
  1592                                  ; -----------------------------------------------------------------------------
  1593                                  
  1594                                  	; 05/06/2023
  1595                                  he_unlink:
  1596 000000F0 30FF                    	xor	bh, bh
  1597                                  	
  1598                                  	;getdata bl,fm_umb		; Restore original link-state
  1599                                  	;
  1600                                  	;push	ds
  1601 000000F2 8A1E[2B05]              	mov     bl,[fm_umb]
  1602                                  	;pop	ds
  1603                                  
  1604 000000F6 B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1605 000000F9 CD21                    	int	21h
  1606                                  
  1607                                  	;xor	bh, bh
  1608                                  	
  1609                                  	;getdata bl,fm_strat		; Restore original mem-alloc strategy
  1610                                  	;push	ds
  1611 000000FB 8A1E[2C05]              	mov     bl,[fm_strat]
  1612                                  	;pop	ds
  1613                                  
  1614 000000FF B80158                  	mov	ax,DOS_STRATEGY_SET ; 5801h
  1615 00000102 CD21                    	int	21h
  1616                                  
  1617 00000104 C3                      	retn
  1618                                  
  1619                                  ; -----------------------------------------------------------------------------
  1620                                  ;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
  1621                                  ; -----------------------------------------------------------------------------
  1622                                  ; ENTRY:    None
  1623                                  ; EXIT:     None; HIDDEN memory elements returned to FREE
  1624                                  ; ERROR:    None (ignore CF)
  1625                                  ; USES:     Flags
  1626                                  ; -----------------------------------------------------------------------------
  1627                                  
  1628                                  	; 05/06/2023
  1629                                  arena_signature_end equ 5Ah ; 'Z'
  1630                                  arena_signature equ 0
  1631                                  arena_size equ 3
  1632                                  
  1633                                  FreeUMBs:
  1634 00000105 50                      	push	ax
  1635 00000106 06                      	push	es
  1636                                  
  1637 00000107 E86B00                  	call	HeadUmb		; Returns with carry if err, else ES == MCB
  1638 0000010A 721E                    	jc	short fusX
  1639                                  
  1640 0000010C 8EC0                    	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
  1641                                  fus10:	
  1642 0000010E E81C00                  	call	isHideMCB	; Returns with ZF set if owner is 0
  1643 00000111 7503                    	jnz	short fus20
  1644 00000113 E84400                  	call	freeMCB
  1645                                  fus20:	
  1646 00000116 26A00000                	mov	al,[es:arena_signature] ; mov al,[es:0]
  1647 0000011A 3C5A                    	cmp	al,arena_signature_end ; 'Z' ; 5Ah
  1648 0000011C 740C                    	jz	short fusX	; That means this was the last MCB--that's it.
  1649                                  
  1650 0000011E 8CC0                    	mov	ax,es
  1651 00000120 2603060300              	add	ax,[es:arena_size] ; add ax,[es:3]
  1652 00000125 40                      	inc	ax
  1653 00000126 8EC0                    	mov	es,ax		; Go on forward.
  1654 00000128 EBE4                    	jmp	short fus10
  1655                                  fusX:
  1656 0000012A 07                      	pop	es
  1657 0000012B 58                      	pop	ax
  1658 0000012C C3                      	retn
  1659                                  
  1660                                  ; -----------------------------------------------------------------------------
  1661                                  ;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
  1662                                  ; -----------------------------------------------------------------------------
  1663                                  ; ENTRY:    ES:0 should point to an MCB
  1664                                  ; EXIT:     ZF set if MCB is hidden, else !ZF
  1665                                  ; ERROR:    None
  1666                                  ; USES:     Flags
  1667                                  ; -----------------------------------------------------------------------------
  1668                                  
  1669                                  	; 05/06/2023
  1670                                  SystemPSPOwner	equ 8
  1671                                  arena_owner	equ 1
  1672                                  arena_name	equ 8
  1673                                  
  1674                                  isHideMCB:
  1675 0000012D 50                      	push	ax
  1676                                  
  1677 0000012E 26833E010008            	cmp	word [es:arena_owner],SystemPSPOwner ; If the owner's SYSTEM
  1678 00000134 7522                    	jne	short ihm_x			     ; then check for HIDDEN
  1679                                  
  1680 00000136 26A10800                	mov	ax,[es:arena_name]   ; [es:8]
  1681 0000013A 3D4849                  	cmp	ax,'HI' ; 4948h
  1682 0000013D 7519                    	jne	short ihm_x
  1683 0000013F 26A10A00                	mov	ax,[es:arena_name+2] ; [es:10]
  1684 00000143 3D4444                  	cmp	ax,'DD' ; 4444h
  1685 00000146 7510                    	jne	short ihm_x
  1686 00000148 26A10C00                	mov	ax,[es:arena_name+4] ; [es:12]
  1687 0000014C 3D454E                  	cmp	ax,'EN' ; 4E45h
  1688 0000014F 7507                    	jne	short ihm_x
  1689 00000151 26A10E00                	mov	ax,[es:arena_name+6] ; [es:14]
  1690 00000155 3D2020                  	cmp	ax,'  ' ; 2020h
  1691                                  ihm_x:
  1692 00000158 58                      	pop	ax
  1693 00000159 C3                      	retn
  1694                                  
  1695                                  ; -----------------------------------------------------------------------------
  1696                                  ;*** freeMCB - marks as free the MCB at ES:0
  1697                                  ; -----------------------------------------------------------------------------
  1698                                  ; ENTRY:    ES:0 should point to an MCB
  1699                                  ; EXIT:     None; MCB free'd
  1700                                  ; ERROR:    None
  1701                                  ; USES:     AX
  1702                                  ; -----------------------------------------------------------------------------
  1703                                  
  1704                                  	; 05/06/2023
  1705                                  freeMCB:
  1706 0000015A 26C70601000000          	mov	word [es:arena_owner],0	; [es:1]
  1707 00000161 B82020                  	mov	ax,'  '
  1708 00000164 26A30800                	mov	[es:arena_name+0],ax	; [es:8]
  1709 00000168 26A30A00                	mov	[es:arena_name+2],ax
  1710 0000016C 26A30C00                	mov	[es:arena_name+4],ax
  1711 00000170 26A30E00                	mov	[es:arena_name+6],ax	; [es:14]
  1712 00000174 C3                      	retn
  1713                                  
  1714                                  ; -----------------------------------------------------------------------------
  1715                                  ;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
  1716                                  ; -----------------------------------------------------------------------------
  1717                                  ; ENTRY:  Nothing
  1718                                  ; EXIT:   AX contains 0x9FFF for most systems
  1719                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
  1720                                  ; USES:   Flags, AX
  1721                                  ; -----------------------------------------------------------------------------
  1722                                  
  1723                                  	; 05/06/2023
  1724                                  HeadUmb:
  1725 00000175 56                      	push	si
  1726 00000176 1E                      	push	ds
  1727 00000177 06                      	push	es
  1728                                  
  1729 00000178 B452                    	mov	ah,DOS_GET_LISTS	; Call int 21h, function 52h...
  1730 0000017A CD21                    	int	21h
  1731                                  
  1732 0000017C 26A18C00                	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008Ch
  1733 00000180 83F8FF                  	cmp	ax,0FFFFh
  1734                                  	;je	short xhu_e		; If it's 0xFFFF, it's an error...
  1735                                  	;clc				; Else, it isn't.
  1736                                  	;jmp	short xhu_x
  1737                                  ;xhu_e:
  1738                                  	;stc
  1739                                  	; 05/06/2023
  1740 00000183 F5                      	cmc	; cf=0 -> cf=1
  1741                                  ;xhu_x:
  1742 00000184 07                      	pop	es
  1743 00000185 1F                      	pop	ds
  1744 00000186 5E                      	pop	si
  1745 00000187 C3                      	retn
  1746                                  
  1747                                  ; -----------------------------------------------------------------------------
  1748                                  ;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
  1749                                  ; -----------------------------------------------------------------------------
  1750                                  ; ENTRY:    None
  1751                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
  1752                                  ; ERROR:    None
  1753                                  ; USES:     AX, BX, fm_umb
  1754                                  ; -----------------------------------------------------------------------------
  1755                                  
  1756                                  	; 05/06/2023
  1757                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:029Dh
  1758                                  linkumb:
  1759 00000188 B80258                  	mov	ax,DOS_UMBLINK_GET ; 5802h
  1760 0000018B CD21                    	int	21h			; Current link-state is now in al
  1761                                  
  1762 0000018D 08C0                    	or	al,al			; BUGBUG: proper check?
  1763 0000018F 7508                    	jnz	short lumbX		; Jumps if UMBs already linked in
  1764                                  
  1765 00000191 B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1766 00000194 BB0100                  	mov	bx,1
  1767 00000197 CD21                    	int	21h
  1768                                  lumbX:
  1769 00000199 C3                      	retn
  1770                                  
  1771                                  ;==============================================================================
  1772                                  ; STUB.ASM, MSDOS 6.0, 1991
  1773                                  ;==============================================================================
  1774                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1775                                  
  1776                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1777                                  	; 05/06/2023 - Retro DOS 4.2
  1778                                  
  1779                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1780                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1781                                  ;returns with all registers preserved and so all our segment registers are
  1782                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1783                                  ;comes back here. In this case the segment registers and the stack are
  1784                                  ;not set up and random things can happen. The only way to setup all the 
  1785                                  ;registers is to use the cs value and this can only be done when we are in
  1786                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1787                                  ;the code segment to the data segment.
  1788                                  
  1789                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02AFh
  1790                                  Issue_Exec_Call:
  1791 0000019A CD21                    	int 	21h
  1792                                  
  1793                                  ;We disable interrupts while changing the stack because there is a bug in 
  1794                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1795                                  ;are being changed.
  1796                                  
  1797 0000019C FA                      	cli
  1798 0000019D 0E                      	push	cs
  1799 0000019E 17                      	pop	ss
  1800                                  
  1801                                  	;;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1802                                  	;mov	sp,60Ah	; MSDOS 6.22 COMMAND.COM RESGROUP:02B4h
  1803                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1804 0000019F BC[F404]                	mov	sp,RStack		; stack is set up
  1805                                  
  1806                                  ; 05/06/2023	
  1807                                  %if 0	
  1808                                  	; 20/04/2023
  1809                                  	;sti
  1810                                  	;push	cs
  1811                                  	;pop	ds			; ds = DATARES
  1812                                  
  1813                                  ; M009; Restore UMB state to that before Exec
  1814                                  
  1815                                  	;pushf				;    This call frees HIDDEN umb's,
  1816                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1817                                  	;popf				;    strategy and link state, as app.
  1818                                  
  1819                                  	; 09/01/2023 - Retro DOS v4.0
  1820                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1821                                  	; ----------------------
  1822                                  	sti
  1823                                  	push    cs
  1824                                  	pop     ds
  1825                                  	pushf
  1826                                  	;mov	al,[cs:fInHigh]
  1827                                  	; 18/04/2023
  1828                                  	mov	al,[fInHigh]
  1829                                  	test	al,80h
  1830                                  	jz      short uhu10
  1831                                  	and     al,7Fh
  1832                                  	;;call	cs:UMBOff_Entry
  1833                                  	;call	far [cs:UMBOff_Entry]
  1834                                  	call	far [UMBOff_Entry]
  1835                                  uhu10:
  1836                                  	;and	byte [cs:fInHigh],7Fh
  1837                                  	; 18/04/2023
  1838                                  	and	byte [fInHigh],7Fh
  1839                                  	popf
  1840                                  	; ----------------------
  1841                                  
  1842                                  %endif
  1843                                  	; 05/06/2023 - Retro DOS 4.2
  1844                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02B7h
  1845 000001A2 FB                      	sti
  1846 000001A3 0E                      	push	cs
  1847 000001A4 1F                      	pop	ds			; ds = DATARES
  1848                                  
  1849                                  ; M009; Restore UMB state to that before Exec
  1850                                  
  1851 000001A5 9C                      	pushf				;    This call frees HIDDEN umb's,
  1852 000001A6 E82EFF                  	call	UnHideUMBs		; <- restores the memory-allocation
  1853 000001A9 9D                      	popf				;    strategy and link state, as app
  1854                                  
  1855                                  ;We now jump to the stub trap which returns us to the resident code. All
  1856                                  ;flags are preserved by the stub code.
  1857                                  
  1858 000001AA E9B3FE                  	jmp	Exec_Trap
  1859                                  
  1860                                  ;==============================================================================
  1861                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1862                                  ;==============================================================================
  1863                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1864                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1865                                  
  1866                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:02C2h (DATARES:02C2h) (*)
  1867                                  ; -----------------------------------------------------------------------------
  1868 000001AD 636F78                  cox_location:	db 'cox' ; (*)	
  1869 000001B0 0000                    cox_Y_option:	dw 0     ; (*)
  1870                                  ; -----------------------------------------------------------------------------
  1871                                  
  1872                                  ;***	Message substitution blocks
  1873                                  
  1874                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1875                                  
  1876                                  ;BlkDevErrSubst	label	byte
  1877                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1878                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1879                                  
  1880 000001B2 02                      BlkDevErrSubst: db	2
  1881 000001B3 0000                    BlkDevErrRw:	dw	0
  1882 000001B5 01                      		db	1
  1883 000001B6 [B801]                  		dw	DrvLet
  1884                                  
  1885 000001B8 41                      DrvLet:		db	'A'			; drive letter
  1886                                  
  1887                                  
  1888                                  ;CharDevErrSubst label	byte
  1889                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1890                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1891                                  
  1892 000001B9 02                      CharDevErrSubst: db	2
  1893 000001BA 0000                    CharDevErrRw:	dw	0
  1894 000001BC 02                      		db	2
  1895 000001BD [BF01]                  		dw	DevName
  1896                                  
  1897 000001BF 00<rep 8h>              DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1898 000001C7 00                      		db	0
  1899                                  
  1900                                  ;NeedVolSubst	label	byte
  1901                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1902                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1903                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1904                                  
  1905 000001C8 02                      NeedVolSubst:	db	2
  1906 000001C9 [D101]                  		dw	VolName
  1907 000001CB 03                      		db	3
  1908 000001CC [DF01]                  		dw	VolSer+2
  1909 000001CE 03                      		db	3
  1910 000001CF [DD01]                  		dw	VolSer
  1911                                  
  1912                                  	; NOTE:	VolName and VolSer must be adjacent
  1913 000001D1 00<rep Bh>              VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1914 000001DC 00                      		db	0
  1915 000001DD 00000000                VolSer:		dd	0			; volume serial #
  1916                                  
  1917 000001E1 00                      CDevAt:		db	0
  1918                                  
  1919                                  ;BadFatSubst	label	byte
  1920                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1921                                  
  1922 000001E2 01                      BadFatSubst:	db	1
  1923 000001E3 [B801]                  		dw	DrvLet
  1924                                  
  1925                                  ;PutBackSubst	label	byte
  1926                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1927                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1928                                  
  1929 000001E5 02                      PutBackSubst:	db	2
  1930 000001E6 0000                    PutBackComSpec:	dw	0
  1931 000001E8 01                      		db	1
  1932 000001E9 [EB01]                  		dw	PutBackDrv
  1933                                  
  1934 000001EB 20                      PutBackDrv:	db	' '	; db 20h	; drive letter
  1935                                  
  1936                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1937                                  
  1938 000001EC 02                      ExecErrSubst:	db	2
  1939 000001ED [2004]                  		dw	SafePathBuffer
  1940                                  
  1941 000001EF 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1942 000001F3 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1943                                  
  1944 000001F4 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1945 000001F8 0000                    Save_Pdb:	dw	0
  1946 000001FA 0000                    Parent:		dw	0
  1947 000001FC 00000000                OldTerm:	dd	0
  1948 00000200 0000                    ErrCd_24:	dw	0
  1949 00000202 0000                    Handle01:	dw	0
  1950 00000204 00                      Loading:	db	0
  1951 00000205 0000                    Batch:		dw	0	; assume no batch mode initially
  1952                                  
  1953                                  ;;;;SR;
  1954                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1955                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1956                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1957                                  ;;;;
  1958                                  ;;;BatchEOF:	db	0
  1959                                  
  1960                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1961                                  	; What's this comspec_end about?
  1962 00000207 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1963 00000247 0000                    ComSpec_End:	dw	0
  1964                                  
  1965                                  ;Trans		label	dword
  1966                                  ;		dw	TRANGROUP:Command
  1967                                  
  1968                                  Trans:		;dw	12Ch
  1969                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1970 00000249 [2C01]                  		dw	COMMAND ; 16/04/2023
  1971 0000024B 0000                    TrnSeg:		dw	0
  1972                                  
  1973 0000024D 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1974                                  
  1975 0000024E 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1976 0000024F 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1977                                  
  1978 00000250 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1979 00000251 0000                    MemSiz:		dw	0
  1980 00000253 0000                    Sum:		dw	0
  1981 00000255 01                      ExtCom:		db	1	; for init, pretend just did an external
  1982 00000256 0000                    RetCode: 	dw	0
  1983 00000258 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1984                                  
  1985                                  
  1986                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1987                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1988                                  
  1989 00000259 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1990 0000025A 01                      Suppress:	db	1	; used for echo, 1=echo line
  1991 0000025B 0000                    Io_Save: 	dw	0
  1992 0000025D 00                      RestDir: 	db	0
  1993 0000025E 00                      PermCom: 	db	0	; true => permanent command
  1994                                  ; 05/06/2023
  1995 0000025F FFFF                    SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1996                                  				; true => semi-permanent command (/K)
  1997 00000261 0000                    SingleCom:	dw	0	; true => single command version
  1998 00000263 FFFF                    VerVal:		dw	-1
  1999 00000265 00                      fFail:		db	0	; true => fail all int 24s
  2000 00000266 00                      IfFlag:		db	0	; true => IF statement in progress
  2001                                  
  2002 00000267 00                      ForFlag: 	db	0	; true => FOR statement in progress
  2003 00000268 0000                    ForPtr:		dw	0
  2004                                  
  2005 0000026A 0000                    Nest:		dw	0	; nested batch file counter
  2006 0000026C 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  2007 0000026D 00                      Call_Batch_Flag: db	0
  2008 0000026E 0000                    Next_Batch:	dw	0	; address of next batch segment
  2009 00000270 00                      NullFlag:	db	0	; flag if no command on command line
  2010 00000271 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  2011                                  				; buffer for file ucase address
  2012                                  ; Bugbug: don't need crit_msg_ anymore?
  2013                                  
  2014 00000276 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  2015 00000278 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  2016 0000027A 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  2017 0000027C 0000                    		 dw	0	; DBCS vector segment
  2018 0000027E 0000                    Append_State:	dw	0	; current state of append
  2019                                  				;  (if Append_Flag is set)
  2020 00000280 00                      Append_Flag:	db	0	; set if append state is valid
  2021 00000281 00                      Re_Out_App:	db	0
  2022 00000282 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  2023                                  
  2024                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  2025                                  ; various times. Here is the breakdown:
  2026                                  ;
  2027                                  ;   INITINIT	We are in the init code.
  2028                                  ;   INITSPECIAL We are in the date/time prompt
  2029                                  ;   INITCTRLC	We are handling a ^C already.
  2030                                  ;
  2031                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  2032                                  ; ignore the ^C. This is so the system calls work on nested commands.
  2033                                  ;
  2034                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  2035                                  ; input buffer with a CR to pretend an empty response.
  2036                                  ;
  2037                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  2038                                  ; (ourselves). We can then detect the carry set and properly retry the
  2039                                  ; operation.
  2040                                  
  2041                                  InitFlag:	;db	1
  2042 000002D2 01                      		db	INITINIT
  2043                                  
  2044                                  ; Note: these two bytes are referenced as a word
  2045 000002D3 00                      PipeFlag:	db	0
  2046 000002D4 00                      PipeFiles:	db	0
  2047                                  
  2048                                  ; (rdata.asm, msdos 6.0, 1992)
  2049                                  ; ----------------------------------------------------------------------------
  2050                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  2051                                  
  2052                                  ;;SR
  2053                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  2054                                  ;;
  2055                                  ;
  2056                                  ;; Bugbug: can we find any way around maintaining these
  2057                                  ;; large buffers?
  2058                                  ;
  2059                                  ;Pipe1		db	67+12 dup (?)
  2060                                  ;Pipe2		db	67+12 dup (?)
  2061                                  ;
  2062                                  ;PipePtr 	dw	?
  2063                                  ;
  2064                                  ;PipeStr 	db	129 dup (?)
  2065                                  ;
  2066                                  ;EndPipe	label	byte	; marks end of buffers; M004
  2067                                  ;
  2068                                  ;;SR;
  2069                                  ;; We can move our EndInit code into above buffers. This way, the code will
  2070                                  ;;automatically be discarded after init.
  2071                                  ;;
  2072                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  2073                                  ;; M004; the origin.
  2074                                  ;;
  2075                                  ;	ORG	Pipe1	; M004
  2076                                  ;
  2077                                  ;; Bugbug: really need a procedure header for EndInit, describing
  2078                                  ;; what it expects, what it does.
  2079                                  ;
  2080                                  
  2081                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2082                                  
  2083                                  Pipe1	equ	EndInit
  2084                                  Pipe2	equ	Pipe1+67+12
  2085                                  PipePtr	equ	Pipe2+67+12
  2086                                  PipeStr	equ	PipePtr+2
  2087                                  EndPipe	equ	PipeStr+129	; EndInit+289
  2088                                  
  2089                                  ; Bugbug: really need a procedure header for EndInit, describing
  2090                                  ; what it expects, what it does.
  2091                                  
  2092                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h
  2093                                  
  2094                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (compatible with MSDOS 6.22)
  2095                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:03EAh 
  2096                                  
  2097                                  EndInit:
  2098 000002D5 1E                      	push	ds
  2099 000002D6 06                      	push	es		; save segments
  2100 000002D7 0E                      	push	cs
  2101 000002D8 1F                      	pop	ds		
  2102                                  	;assume	ds:RESGROUP
  2103                                  
  2104                                  ; M004; Save size of transient here before INIT segment is deallocated
  2105                                  
  2106 000002D9 8B16[8E1F]              	mov	dx,[TrnSize]		; M004
  2107                                  ;M027
  2108                                  ; These variables are also defined in the INIT segment and need to be saved
  2109                                  ;before we resize
  2110                                  ;
  2111 000002DD A1[821F]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  2112 000002E0 8B1E[7E1F]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  2113 000002E4 8B0E[841F]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  2114 000002E8 50                      	push	ax		; Save all these values ;M027
  2115 000002E9 53                      	push	bx		; M027
  2116 000002EA 51                      	push	cx		; M027
  2117                                  
  2118                                  
  2119                                  ; Bugbug: push ds, pop es here.
  2120                                  	;mov	bx,ds
  2121                                  	;mov	es,bx		; es = RESGROUP
  2122                                  	; 09/01/2023
  2123 000002EB 1E                      	push	ds
  2124 000002EC 07                      	pop	es
  2125                                  
  2126                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2127                                  ; code + data for low COMMAND
  2128                                  
  2129 000002ED 8B1E[7604]              	mov	bx,[ResSize]	; Total size of resident
  2130 000002F1 B44A                    	mov	ah,4Ah
  2131                                  	;mov	ah,SETBLOCK
  2132 000002F3 CD21                    	int	21h		; Set block to resident size
  2133                                  
  2134                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2135                                  		; ES = segment address of block to change
  2136                                  		; BX = new size in paragraphs
  2137                                  
  2138                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  2139                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  2140                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  2141                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  2142                                  ;
  2143                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  2144                                  	
  2145 000002F5 803E[5E02]01            	cmp	byte [PermCom],1 ; permanent command.com?
  2146 000002FA 7530                    	jne	short adjust_env ; no, do not free batchseg
  2147                                  
  2148 000002FC 833E[0502]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  2149 00000301 7429                    	je	short adjust_env ; no, dont juggle
  2150                                  
  2151                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  2152                                  	; 21/01/2023
  2153 00000303 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  2154                                  	;mov	bx,4	; 09/01/2023
  2155                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  2156 00000306 B448                    	mov	ah,48h
  2157                                  	;mov	ah,ALLOC
  2158 00000308 CD21                    	int	21h
  2159                                  
  2160                                  		; DOS - 2+ - ALLOCATE MEMORY
  2161                                  		; BX = number of 16-byte paragraphs desired
  2162                                  
  2163                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  2164                                  ; a hole, the batch segment COULD already be in the ideal place. We
  2165                                  ; could be making it worse! We're second-guessing where memory
  2166                                  ; allocations go, which might not be such a great idea. Is there
  2167                                  ; a strategy, short of doing something even worse like diddling
  2168                                  ; arena headers, where we can minimize the possibility of fragmentation
  2169                                  ; under all cases? Hmm..
  2170                                  	
  2171 0000030A 7220                    	jc	short adjust_env ; no memory, use old batchseg
  2172                                  
  2173 0000030C 8EC0                    	mov	es,ax		 ; es = New batch segment
  2174 0000030E 31FF                    	xor	di,di
  2175 00000310 31F6                    	xor	si,si
  2176                                  
  2177 00000312 1E                      	push	ds
  2178 00000313 8E1E[0502]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  2179                                  	;assume	ds:nothing
  2180                                  	;mov	cx,SIZE BatchSegment
  2181                                  	; 23/01/2023
  2182                                  	;mov	cx,BATCHSEGMENT.SIZE
  2183                                  	;;mov	cx,33	; 09/01/2023
  2184                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  2185                                  	;
  2186                                  	;add	cx,16		 ; for the filename
  2187                                  	; 20/04/2023
  2188 00000317 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16 
  2189                                  
  2190                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  2191                                  	; It's sure be bad if we copied more bytes than the batch segment
  2192                                  	; holds!
  2193                                  	
  2194 0000031A FC                      	cld
  2195 0000031B F3A4                    	rep	movsb
  2196 0000031D 1F                      	pop	ds
  2197                                  	;assume	ds:RESGROUP
  2198                                  
  2199 0000031E 8CC1                    	mov	cx,es		; save new batch segment 
  2200 00000320 8E06[0502]              	mov	es,[Batch]
  2201 00000324 B449                    	mov	ah,49h
  2202                                  	;mov	ah,DEALLOC
  2203 00000326 CD21                    	int	21h		; free the old batch segment
  2204                                  
  2205                                  	; Bugbug: should we check for error?
  2206                                  
  2207 00000328 890E[0502]              	mov	[Batch],cx	; store new batch segment address
  2208                                  
  2209                                  adjust_env:
  2210 0000032C 59                      	pop	cx		; cx = size of old env ;M027
  2211 0000032D 5B                      	pop	bx		; bx = size of new env needed ;M027
  2212 0000032E 5D                      	pop	bp		; bp = old env seg ;M027
  2213                                  
  2214                                  ;Allocate the correct size for the environment
  2215                                  
  2216 0000032F B448                    	mov	ah,48h
  2217                                  	;mov	ah,ALLOC
  2218 00000331 CD21                    	int	21h		; get memory
  2219 00000333 7264                    	jc	short nomem_err	; out of memory,signal error
  2220                                  	
  2221                                  	; Bugbug: why not continue, leaving environment where it is?
  2222                                  
  2223 00000335 A3[FA03]                	mov	[EnvirSeg],ax	; Store new environment segment
  2224                                  	;;mov	[ds:2Ch],ax
  2225                                  	;mov	[2Ch],ax
  2226                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  2227 00000338 A32C00                  	mov	[PDB.ENVIRON],ax
  2228 0000033B 8EC0                    	mov	es,ax		; es = address of allocated memory
  2229                                  	;assume	es:nothing
  2230                                  
  2231                                  ;Copy the environment to the newly allocated segment
  2232                                  
  2233 0000033D 1E                      	push	ds
  2234 0000033E 8EDD                    	mov	ds,bp		; ds = Old environment segment
  2235                                  	;assume	ds:nothing
  2236                                  
  2237 00000340 31F6                    	xor	si,si
  2238 00000342 89F7                    	mov	di,si		; Start transfer from 0
  2239                                  
  2240 00000344 FC                      	cld
  2241 00000345 F3A4                    	rep	movsb		; Do the copy
  2242                                  
  2243 00000347 1F                      	pop	ds		; ds = RESGROUP
  2244                                  	;assume	ds:RESGROUP
  2245                                  
  2246                                  ; We have to free the old environment block if it was allocated by INIT
  2247                                  
  2248                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  2249                                  ; or does it also apply to passed environments?
  2250                                  
  2251                                  ;M036
  2252                                  ; Free up old env segment always because this is a copy passed by Exec and
  2253                                  ; takes up memory that is never used
  2254                                  
  2255                                  ;M044
  2256                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  2257                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  2258                                  ; errors if it gets a memory alloc that it is below its load segment. The
  2259                                  ; freed environment creates a large enough hole for some of its allocs to fit
  2260                                  ; in
  2261                                  
  2262                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  2263                                          ;je	short no_free	    ; no, do not free it
  2264                                  	; 21/01/2023
  2265                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  2266 00000348 803E[441F]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment	
  2267 0000034D 7506                    	jne	short no_free 
  2268                                  
  2269 0000034F 8EC5                    	mov	es,bp
  2270 00000351 B449                    	mov	ah,49h
  2271                                  	;mov	ah,DEALLOC	
  2272 00000353 CD21                    	int	21h		    ; Free it
  2273                                  no_free:
  2274                                  
  2275                                  ; M004; Start of changes 
  2276                                  
  2277                                  ; Move the transient now. We will allocate the biggest block available
  2278                                  ; now and move the transient to the top of the block. We will then
  2279                                  ; deallocate this block. When the resident starts executing, it will
  2280                                  ; hopefully allocate this block again and find the transient intact.
  2281                                  
  2282 00000355 C606[4D02]01            	mov	byte [TrnMvFlg],1   ; Indicate that transient has been moved
  2283 0000035A 06                      	push	es
  2284                                  	;;mov	si,offset ResGroup:TranStart
  2285                                  	; 09/01/2023
  2286                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2287                                  	; 05/06/2023
  2288                                  	;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM RESGROUP:0475h
  2289 0000035B BE1026                  	mov	si,TRANSTART	    ; (End of the resident portion)
  2290                                  	;mov	di,0
  2291 0000035E 31FF                    	xor	di,di ; 0
  2292                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2293                                  	;mov	cx,98C5h
  2294                                  	; 05/06/2023 - MSDOS 6.22 COMMAND.COM RESGROUP:047Bh
  2295                                  	;mov	cx,0AF95h	; TRANSIENT portion size
  2296 00000360 B977AA                  	mov	cx,TRANSPACEEND
  2297                                  	
  2298                                  ; Find the largest block available
  2299                                  
  2300 00000363 BBFFFF                  	mov	bx,0FFFFh
  2301 00000366 B448                    	mov	ah,48h
  2302                                  	;mov	ah,ALLOC
  2303 00000368 CD21                    	int	21h
  2304                                  
  2305                                  ; dx = size of transient saved previously 
  2306                                  
  2307 0000036A 39D3                    	cmp	bx,dx		; enough memory?
  2308 0000036C 722B                    	jb	short nomem_err	; not enough memory for transient
  2309                                  
  2310 0000036E B448                    	mov	ah,48h
  2311                                  	;mov	ah,ALLOC
  2312 00000370 CD21                    	int	21h		; get the largest block
  2313 00000372 7225                    	jc	short nomem_err	; something is really screwed up
  2314                                  
  2315 00000374 50                      	push	ax		; save memory address
  2316 00000375 01D8                    	add	ax,bx		; ax = top of my memory block
  2317 00000377 29D0                    	sub	ax,dx		; less size of transient
  2318 00000379 A3[4B02]                	mov	[TrnSeg],ax	; save transient segment
  2319 0000037C 8EC0                    	mov	es,ax		;
  2320 0000037E 58                      	pop	ax		; restore our seg addr
  2321                                  
  2322                                  ; Everything is set for a move. We need to move in the reverse direction to
  2323                                  ; make sure we dont overwrite ourselves while copying
  2324                                  
  2325 0000037F 01CE                    	add	si,cx
  2326 00000381 4E                      	dec	si
  2327 00000382 01CF                    	add	di,cx
  2328 00000384 4F                      	dec	di
  2329 00000385 FD                      	std
  2330 00000386 F3A4                    	rep	movsb
  2331 00000388 FC                      	cld
  2332                                  
  2333                                  ; Now we have to free up this block so that resident can get hold of it
  2334                                  
  2335 00000389 8EC0                    	mov	es,ax
  2336 0000038B B449                    	mov	ah,49h
  2337                                  	;mov	ah,DEALLOC
  2338 0000038D CD21                    	int	21h		; release the memory block
  2339                                  
  2340                                  ; M004; End of changes
  2341                                  
  2342                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2343                                  	; 09/01/2023
  2344 0000038F C606[D202]00            	mov	byte [InitFlag],0	
  2345                                  
  2346 00000394 07                      	pop	es
  2347 00000395 1F                      	pop	ds
  2348                                  	;assume	ds:nothing
  2349                                  	
  2350                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2351                                  	
  2352 00000396 E9E5FC                  	jmp	LodCom_Trap	; allocate transient
  2353                                  
  2354                                  nomem_err:
  2355                                  
  2356                                  ;We call the error routine which will never return. It will either exit
  2357                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2358                                  ;message ( if first COMMAND )
  2359                                  
  2360 00000399 E9021B                  	jmp	Alloc_error
  2361                                  
  2362                                  ;EndCodeInit:	; label	byte		; M004
  2363                                  
  2364                                  	; 16/04/2023
  2365                                  	EndCodeInit equ $
  2366                                  
  2367                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2368                                  ;; M004; If not, we signal an assembly error
  2369                                  ;
  2370                                  ;IF2
  2371                                  ;	IF ($ GT EndPipe)
  2372                                  ;		.err
  2373                                  ;		%out	"ENDINIT CODE TOO BIG"
  2374                                  ;	ENDIF
  2375                                  ;ENDIF
  2376                                  
  2377                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2378                                  ;;
  2379                                  ;		ORG	EndPipe		; M004
  2380                                  
  2381                                  ; 09/01/2023
  2382                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2383                                  ; 05/06/2023
  2384                                  ; MSDOS 6.22 COMMAND.COM - CODERES:04B7h
  2385                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2386                                  
  2387                                  ; 16/04/2023
  2388                                  	FillBytes equ EndPipe - EndCodeInit			
  2389                                  
  2390                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2391                                  ; 16/04/2023
  2392                                  %if FillBytes>0
  2393                                  	;times EndPipe - EndCodeInit db 0
  2394 0000039C 00<rep 5Ah>             	times FillBytes db 0   
  2395                                  %endif
  2396                                  
  2397                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2398                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289 
  2399                                  
  2400                                  ; 05/06/2023 - Retrodos v4.2
  2401                                  ; MSDOS 6.22 COMMAND.COM - CODERES:050Bh ; EndInit+289 
  2402                                  
  2403                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h 
  2404                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2405                                  
  2406 000003F6 [D502]                  InPipePtr:	dw	Pipe1 ;; 320h for MSDOS 5.0 COMMAND.COM
  2407                                  			      ; 3EAh for MSDOS 6.22 COMMAND.COM	
  2408 000003F8 [2403]                  OutPipePtr:	dw	Pipe2 ;; 36Fh for MSDOS 5.0 COMMAND.COM
  2409                                  			      ; 439h for MSDOS 6.22 COMMAND.COM	
  2410                                  
  2411                                  Exec_Block:	; label	byte	; the data block for exec calls
  2412 000003FA 0000                    EnvirSeg:	dw	0
  2413                                  Com_Ptr:	; label	dword
  2414 000003FC 8000                    		dw	80h	; point at unformatted parameters
  2415 000003FE 0000                    		dw	0
  2416                                  Com_Fcb1:	; label	dword
  2417 00000400 5C00                    		dw	5Ch
  2418 00000402 0000                    		dw	0
  2419                                  Com_Fcb2:	; label	dword
  2420 00000404 6C00                    		dw	6Ch
  2421 00000406 0000                    		dw	0
  2422                                  
  2423                                  ; variables passed to transient
  2424                                  TranVars:	; label	byte			
  2425                                  		;dw	offset DATARES:HeadFix_Trap
  2426 00000408 [9200]                  		dw	HeadFix_Trap
  2427 0000040A 0000                    MySeg:		dw	0	; put our own segment here
  2428 0000040C 0000                    LTpa:		dw	0	; will store tpa segment here
  2429 0000040E 2F                      RSwitChar:	db	"/"
  2430 0000040F 5C                      RDirChar:	db	"\"
  2431                                  		;dw	offset DATARES:Issue_Exec_Call
  2432 00000410 [9A01]                  		dw	Issue_Exec_Call
  2433 00000412 0000                    MySeg1:		dw	0
  2434                                  		;dw	offset DATARES:RemCheck_Trap
  2435 00000414 [6A00]                  		dw	RemCheck_Trap
  2436 00000416 0000                    MySeg2:		dw	0
  2437 00000418 0000                    ResTest: 	dw	0
  2438 0000041A 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2439                                  
  2440                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  2441 0000041C 0000                    Y_Flag:		dw	0	
  2442                                  
  2443                                  TranVarEnd:	; label	byte
  2444                                  
  2445 0000041E 0000                    OldErrNo:	dw	0
  2446                                  
  2447                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2448                                  ;  MsgBuffer is only used while a command is being executed.
  2449                                  ;  SafePathBuffer is no longer needed, since it is used for
  2450                                  ;  unsuccessful program launches.
  2451                                  
  2452                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2453                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2454                                  	;Bugbug: Why so big a buffer?
  2455                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2456 00000420 00<rep 50h>             		times	64+3+13 db 0		
  2457                                  
  2458                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2459                                  
  2460 00000470 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2461 00000474 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2462                                  
  2463                                  ;SR;
  2464                                  ; The three vars below have been added for a pure COMMAND.COM
  2465                                  
  2466 00000476 0000                    ResSize:	dw	0
  2467                                  
  2468                                  ;SR;
  2469                                  ; Moved the stack here from the code segment
  2470                                  ;
  2471                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2472                                  	
  2473                                  		;db	(80h - 3) dup (?)
  2474                                  align 2
  2475 00000478 00<rep 7Ch>             		times	124 db 0		
  2476                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2477                                  ; 05/06/2023
  2478                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Ah (offset RStack)
  2479                                  RStack:		; label	word
  2480 000004F4 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2481                                  				; resident code segments
  2482                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2483                                  
  2484                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2485                                  ; -------------------------------
  2486                                  
  2487                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2488                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2489                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2490                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2491                                  ;            given a command-line like "/L:3,500;4"
  2492                                  ; UmbUsed  - An array of characters, each of which is 1 iff the UMB
  2493                                  ;            matching its index number was specified on the command-line;
  2494                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2495                                  ;            will be set to 1.  All others will be set to 0.
  2496                                  ; UmbSize  - An array of words, each of which is interpereted as a size
  2497                                  ;            specified by the user for a UMB (in the above example, all
  2498                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2499                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2500                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2501                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2502                                  ;            for details).
  2503                                  
  2504                                  ; - MSDOS 6.0 COMMAND.COM -
  2505                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2506                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2507                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2508                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2509                                  ;; space problem (it's just such a nice round number, eh?).
  2510                                  
  2511                                  ; 05/06/2023
  2512                                  MAXUMB	equ	16
  2513                                  
  2514                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2515                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2516                                  
  2517 000004F6 00                      fInHigh:	db	0
  2518                                  
  2519                                  ; MSDOS 6.0 COMMAND.COM
  2520                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2521                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Dh (DATARES:060Dh)
  2522 000004F7 00                      fUmbTiny:	db	0
  2523 000004F8 0000                    SegLoad:	dw	0
  2524 000004FA 00                      UmbLoad:	db	0
  2525 000004FB 00<rep 10h>             UmbUsed:	times MAXUMB db 0 ; db MAXUMB dup (?)
  2526 0000050B 0000<rep 10h>           UmbSize:	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2527 0000052B 00                      fm_umb:		db	0
  2528 0000052C 00                      fm_strat:	db	0
  2529 0000052D 00                      fm_argc:	db	0
  2530                                  
  2531                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2532                                  ; UmbLoad is set to the UMB number given.
  2533                                  
  2534                                  ;*** MESSAGES
  2535                                  ;    and other translatable text
  2536                                  
  2537                                  ; include comrmsg.inc	; M00
  2538                                  ; ------------------------------
  2539                                  
  2540                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2541                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2542                                  
  2543                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2544                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0644h (DATARES:0644h)
  2545                                  
  2546 0000052E 41                      ABORT_CHAR:	db 'A'
  2547 0000052F 52                      RETRY_CHAR:	db 'R'
  2548 00000530 49                      IGNORE_CHAR:	db 'I'
  2549 00000531 46                      FAIL_CHAR:	db 'F'
  2550 00000532 59                      YES_CHAR:	db 'Y'
  2551 00000533 4E                      NO_CHAR:	db 'N'
  2552 00000534 05                      REQ_ABORT:	db 5
  2553 00000535 41626F7274              		db 'Abort'
  2554 0000053A 07                      REQ_RETRY:	db 7
  2555 0000053B 2C205265747279          		db ', Retry'
  2556 00000542 08                      REQ_IGNORE:	db 8
  2557 00000543 2C2049676E6F7265        		db ', Ignore'
  2558 0000054B 06                      REQ_FAIL:	db 6
  2559 0000054C 2C204661696C            		db ', Fail'
  2560 00000552 01                      REQ_END:	db 1
  2561 00000553 3F                      		db '?'
  2562 00000554 08                      MREAD:		db 8
  2563 00000555 72656164696E6700        		db 'reading', 0
  2564 0000055D 08                      MWRITE:		db 8
  2565 0000055E 77726974696E6700        		db 'writing', 0
  2566 00000566 0E                      MDRIVE:		db 14
  2567 00000567 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2567 00000570 2025320D0A         
  2568 00000575 0F                      MDEVICE:	db 15
  2569 00000576 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2569 0000057F 652025320D0A       
  2570 00000585 26                      MVOLSERIAL:	db 38
  2571 00000586 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2571 0000058F 7365727420766F6C75-
  2571 00000598 6D6520253120736572-
  2571 000005A1 69616C2025322D2533-
  2571 000005AA 0D0A               
  2572 000005AC 25                      BADFATMSG:	db 37
  2573 000005AD 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2573 000005B6 636174696F6E207461-
  2573 000005BF 626C65206261642C20-
  2573 000005C8 64726976652025310D-
  2573 000005D1 0A                 
  2574 000005D2 15                      COMBAD:		db 21
  2575 000005D3 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2575 000005DC 4F4D4D414E442E434F-
  2575 000005E5 4D0D0A             
  2576 000005E8 21                      PUTBACKMSG:	db 33
  2577 000005E9 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2577 000005F2 736B20776974682025-
  2577 000005FB 3120696E2064726976-
  2577 00000604 652025320D0A       
  2578 0000060A 21                      PROMPT:		db 33
  2579 0000060B 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2579 00000614 206B657920746F2063-
  2579 0000061D 6F6E74696E7565202E-
  2579 00000626 202E202E0D0A       
  2580 0000062C 1C                      ENDBATMES:	db 28
  2581 0000062D 0D0A                    		db 0Dh,0Ah
  2582 0000062F 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2582 00000638 206261746368206A6F-
  2582 00000641 622028592F4E293F   
  2583 00000649 13                      EXECEMES:	db 19
  2584 0000064A 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2584 00000653 65637574652025310D-
  2584 0000065C 0A                 
  2585 0000065D 13                      EXEBAD:		db 19
  2586 0000065E 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2586 00000667 4558452066696C650D-
  2586 00000670 0A                 
  2587 00000671 22                      TOOBIG:		db 34
  2588 00000672 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2588 0000067B 6F6F2062696720746F-
  2588 00000684 2066697420696E206D-
  2588 0000068D 656D6F72790D0A     
  2589 00000694 16                      NOHANDMES:	db 22
  2590 00000695 0D0A                    		db 0Dh,0Ah
  2591 00000697 4E6F20667265652066-     		db 'No free file handles'
  2591 000006A0 696C652068616E646C-
  2591 000006A9 6573               
  2592 000006AB 1A                      RBADNAM:	db 26
  2593 000006AC 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2593 000006B5 6E64206F722066696C-
  2593 000006BE 65206E616D650D0A   
  2594                                  ACCDENIED:	; 14/01/2023
  2595                                  		; 10/01/2023
  2596 000006C6 0E                      ACCDEN:		db 14
  2597 000006C7 416363657373206465-     		db 'Access denied '
  2597 000006D0 6E69656420         
  2598 000006D5 19                      BMEMMES:	db 25
  2599 000006D6 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2599 000006DF 616C6C6F636174696F-
  2599 000006E8 6E206572726F72     
  2600 000006EF 26                      HALTMES:	db 38
  2601 000006F0 0D0A                    		db 0Dh,0Ah
  2602 000006F2 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2602 000006FB 616420434F4D4D414E-
  2602 00000704 442C2073797374656D-
  2602 0000070D 2068616C7465640D0A 
  2603 00000716 21                      FRETMES:	db 33
  2604 00000717 0D0A                    		db 0Dh,0Ah,
  2605 00000719 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2605 00000722 61727420434F4D4D41-
  2605 0000072B 4E442C206578697469-
  2605 00000734 6E670D0A           
  2606 00000738 2E                      PATRICIDE:	db 46
  2607 00000739 0D0A                    		db 0Dh,0Ah
  2608 0000073B 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2608 00000744 2070726F6365737320-
  2608 0000074D 61626F727465642C20-
  2608 00000756 63616E6E6F7420636F-
  2608 0000075F 6E74696E7565       
  2609 00000765 0D0A                    		db 0Dh,0Ah
  2610 00000767 02                      NEWLINE:	db 2
  2611 00000768 0D0A                    		db 0Dh, 0Ah
  2612                                  
  2613                                  ; 10/01/2023
  2614                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2615                                  ; 05/06/2023
  2616                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0880h
  2617                                  
  2618 0000076A [4E0C]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2619 0000076C 0100                    		dw 1
  2620 0000076E [090A]                  		dw PARSMSGPTRS		; parse	error messages
  2621 00000770 0100                    		dw 1
  2622 00000772 [4E0C]                  		dw EXTMSGPTRS		; critical error messages
  2623 00000774 0100                    		dw 1
  2624 00000776 0000                    		dw 0			; File system error messages
  2625 00000778 0000                    		dw 0			; are not supported.
  2626 0000077A [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2627 0000077C 0000                    MySeg3:		dw 0			; segment of retriever routine
  2628                                  
  2629                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2630                                  ; 05/06/2023
  2631                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0894h
  2632                                  
  2633 0000077E 13                      CRMSG0:		db 19
  2634 0000077F 57726974652070726F-     		db 'Write protect error'
  2634 00000788 74656374206572726F-
  2634 00000791 72                 
  2635 00000792 0C                      CRMSG1:		db 12
  2636 00000793 496E76616C69642075-     		db 'Invalid unit'
  2636 0000079C 6E6974             
  2637 0000079F 09                      CRMSG2:		db 9
  2638 000007A0 4E6F74207265616479      		db 'Not ready'
  2639 000007A9 16                      CRMSG3:		db 22
  2640 000007AA 496E76616C69642064-     		db 'Invalid device request'
  2640 000007B3 657669636520726571-
  2640 000007BC 75657374           
  2641 000007C0 0A                      CRMSG4:		db 10
  2642 000007C1 44617461206572726F-     		db 'Data error'
  2642 000007CA 72                 
  2643 000007CB 21                      CRMSG5:		db 33
  2644 000007CC 496E76616C69642064-     		db 'Invalid device request parameters'
  2644 000007D5 657669636520726571-
  2644 000007DE 756573742070617261-
  2644 000007E7 6D6574657273       
  2645 000007ED 0A                      CRMSG6:		db 10
  2646 000007EE 5365656B206572726F-     		db 'Seek error'
  2646 000007F7 72                 
  2647 000007F8 12                      CRMSG7:		db 18
  2648 000007F9 496E76616C6964206D-     		db 'Invalid media type'
  2648 00000802 656469612074797065 
  2649 0000080B 10                      CRMSG8:		db 16
  2650 0000080C 536563746F72206E6F-     		db 'Sector not found'
  2650 00000815 7420666F756E64     
  2651 0000081C 1A                      CRMSG9:		db 26
  2652 0000081D 5072696E746572206F-     		db 'Printer out of paper error'
  2652 00000826 7574206F6620706170-
  2652 0000082F 6572206572726F72   
  2653 00000837 11                      CRMSG10:	db 17
  2654 00000838 577269746520666175-     		db 'Write fault error'
  2654 00000841 6C74206572726F72   
  2655 00000849 10                      CRMSG11:	db 16
  2656 0000084A 52656164206661756C-     		db 'Read fault error'
  2656 00000853 74206572726F72     
  2657 0000085A 0F                      CRMSG12:	db 15
  2658 0000085B 47656E6572616C2066-     		db 'General failure'
  2658 00000864 61696C757265       
  2659 0000086A 11                      CRMSG13:	db 17
  2660 0000086B 53686172696E672076-     		db 'Sharing violation'
  2660 00000874 696F6C6174696F6E   
  2661 0000087C 0E                      CRMSG14:	db 14
  2662 0000087D 4C6F636B2076696F6C-     		db 'Lock violation'
  2662 00000886 6174696F6E         
  2663 0000088B 13                      CRMSG15:	db 19
  2664 0000088C 496E76616C69642064-     		db 'Invalid disk change'
  2664 00000895 69736B206368616E67-
  2664 0000089E 65                 
  2665 0000089F 0F                      CRMSG16:	db 15
  2666 000008A0 46434220756E617661-     		db 'FCB unavailable'
  2666 000008A9 696C61626C65       
  2667 000008AF 19                      CRMSG17:	db 25
  2668 000008B0 53797374656D207265-     		db 'System resource exhausted'
  2668 000008B9 736F75726365206578-
  2668 000008C2 68617573746564     
  2669 000008C9 12                      CRMSG18:	db 18
  2670 000008CA 436F64652070616765-     		db 'Code page mismatch'
  2670 000008D3 206D69736D61746368 
  2671 000008DC 0C                      CRMSG19:	db 12
  2672 000008DD 4F7574206F6620696E-     		db 'Out of input'
  2672 000008E6 707574             
  2673 000008E9 17                      CRMSG20:	db 23
  2674 000008EA 496E73756666696369-     		db 'Insufficient disk space'
  2674 000008F3 656E74206469736B20-
  2674 000008FC 7370616365         
  2675                                  
  2676                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2677                                  ; 05/06/2023
  2678                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0A17h
  2679                                  
  2680 00000901 [7E07]                  CRITMSGPTRS:	dw CRMSG0
  2681 00000903 [9207]                  		dw CRMSG1
  2682 00000905 [9F07]                  		dw CRMSG2
  2683 00000907 [A907]                  		dw CRMSG3
  2684 00000909 [C007]                  		dw CRMSG4
  2685 0000090B [CB07]                  		dw CRMSG5
  2686 0000090D [ED07]                  		dw CRMSG6
  2687 0000090F [F807]                  		dw CRMSG7
  2688 00000911 [0B08]                  		dw CRMSG8
  2689 00000913 [1C08]                  		dw CRMSG9
  2690 00000915 [3708]                  		dw CRMSG10
  2691 00000917 [4908]                  		dw CRMSG11
  2692 00000919 [5A08]                  		dw CRMSG12
  2693 0000091B [6A08]                  		dw CRMSG13
  2694 0000091D [7C08]                  		dw CRMSG14
  2695 0000091F [8B08]                  		dw CRMSG15
  2696 00000921 [9F08]                  		dw CRMSG16
  2697 00000923 [AF08]                  		dw CRMSG17
  2698 00000925 [C908]                  		dw CRMSG18
  2699 00000927 [DC08]                  		dw CRMSG19
  2700 00000929 [E908]                  		dw CRMSG20
  2701                                  
  2702                                  		; 14/01/2023
  2703                                  ;DataresEnd:	;; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2704                                  		; 05/06/2023
  2705                                  DataresEnd:	; MSDOS 6.22 COMMAND.COM - DATARES:0A41h (RESGROUP:0A41h)
  2706                                  
  2707 0000092B 13                      PAERRMSG0:	db 19
  2708 0000092C 546F6F206D616E7920-     		db 'Too many parameters'
  2708 00000935 706172616D65746572-
  2708 0000093E 73                 
  2709 0000093F 1A                      PAERRMSG1:	db 26
  2710 00000940 526571756972656420-     		db 'Required parameter missing'
  2710 00000949 706172616D65746572-
  2710 00000952 206D697373696E67   
  2711 0000095A 0E                      PAERRMSG2:	db 14
  2712 0000095B 496E76616C69642073-     		db 'Invalid switch'
  2712 00000964 7769746368         
  2713 00000969 0F                      PAERRMSG3:	db 15
  2714 0000096A 496E76616C6964206B-     		db 'Invalid keyword'
  2714 00000973 6579776F7264       
  2715 00000979 01                      PAERRMSG4:	db 1
  2716 0000097A 20                      		db 20h
  2717 0000097B 24                      PAERRMSG5:	db 36
  2718 0000097C 506172616D65746572-     		db 'Parameter value not in allowed range'
  2718 00000985 2076616C7565206E6F-
  2718 0000098E 7420696E20616C6C6F-
  2718 00000997 7765642072616E6765 
  2719                                  PAERRMSG6:	; 10/01/2023
  2720 000009A0 1B                      PAERRMSG7:	db 27
  2721 000009A1 506172616D65746572-     		db 'Parameter value not allowed'
  2721 000009AA 2076616C7565206E6F-
  2721 000009B3 7420616C6C6F776564 
  2722                                  ;PAERRMSG7:	db 27
  2723                                  ;		db 'Parameter value not allowed'
  2724 000009BC 1C                      PAERRMSG8:	db 28
  2725 000009BD 506172616D65746572-     		db 'Parameter format not correct'
  2725 000009C6 20666F726D6174206E-
  2725 000009CF 6F7420636F72726563-
  2725 000009D8 74                 
  2726 000009D9 11                      PAERRMSG9:	db 17
  2727 000009DA 496E76616C69642070-     		db 'Invalid parameter'
  2727 000009E3 6172616D65746572   
  2728 000009EB 1D                      PAERRMSG10:	db 29
  2729 000009EC 496E76616C69642070-     		db 'Invalid parameter combination'
  2729 000009F5 6172616D6574657220-
  2729 000009FE 636F6D62696E617469-
  2729 00000A07 6F6E               
  2730                                  
  2731                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2732                                  ; 05/06/2023
  2733                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0B3Bh
  2734                                  
  2735 00000A09 [2B09]                  PARSMSGPTRS:	dw PAERRMSG0
  2736 00000A0B [3F09]                  		dw PAERRMSG1
  2737 00000A0D [5A09]                  		dw PAERRMSG2
  2738 00000A0F [6909]                  		dw PAERRMSG3
  2739 00000A11 [7909]                  		dw PAERRMSG4
  2740 00000A13 [7B09]                  		dw PAERRMSG5
  2741 00000A15 [A009]                  		dw PAERRMSG6
  2742 00000A17 [A009]                  		dw PAERRMSG7
  2743 00000A19 [BC09]                  		dw PAERRMSG8
  2744 00000A1B [D909]                  		dw PAERRMSG9
  2745 00000A1D [EB09]                  		dw PAERRMSG10
  2746                                  ; 21/04/2023
  2747                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2748                                  
  2749 00000A1F 10                      INVLFUNCT:	db 16
  2750 00000A20 496E76616C69642066-     		db 'Invalid function'
  2750 00000A29 756E6374696F6E     
  2751 00000A30 0E                      FNOTFOUND:	db 14
  2752 00000A31 46696C65206E6F7420-     		db 'File not found'
  2752 00000A3A 666F756E64         
  2753 00000A3F 0E                      PNOTFOUND:	db 14
  2754 00000A40 50617468206E6F7420-     		db 'Path not found'
  2754 00000A49 666F756E64         
  2755 00000A4E 13                      TOOMANYOF:	db 19
  2756 00000A4F 546F6F206D616E7920-     		db 'Too many open files'
  2756 00000A58 6F70656E2066696C65-
  2756 00000A61 73                 
  2757                                  ; 14/01/2023
  2758                                  ;ACCDEN:	; 10/01/2023
  2759                                  ;ACCDENIED:	db 14
  2760                                  ;		db 'Access denied '
  2761 00000A62 0E                      INVHANDLE:	db 14
  2762 00000A63 496E76616C69642068-     		db 'Invalid handle'
  2762 00000A6C 616E646C65         
  2763 00000A71 1F                      MEMCBDEST:	db 31
  2764 00000A72 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2764 00000A7B 6E74726F6C20626C6F-
  2764 00000A84 636B73206465737472-
  2764 00000A8D 6F796564           
  2765 00000A91 13                      INSUFFMEM:	db 19
  2766 00000A92 496E73756666696369-     		db 'Insufficient memory'
  2766 00000A9B 656E74206D656D6F72-
  2766 00000AA4 79                 
  2767 00000AA5 1C                      INVMEMBLA:	db 28
  2768 00000AA6 496E76616C6964206D-     		db 'Invalid memory block address'
  2768 00000AAF 656D6F727920626C6F-
  2768 00000AB8 636B20616464726573-
  2768 00000AC1 73                 
  2769 00000AC2 13                      INVENVIRO:	db 19
  2770 00000AC3 496E76616C69642045-     		db 'Invalid Environment'
  2770 00000ACC 6E7669726F6E6D656E-
  2770 00000AD5 74                 
  2771 00000AD6 0E                      INVFORMAT:	db 14
  2772 00000AD7 496E76616C69642066-     		db 'Invalid format'
  2772 00000AE0 6F726D6174         
  2773 00000AE5 1A                      INVFNPARM:	db 26
  2774 00000AE6 496E76616C69642066-     		db 'Invalid function parameter'
  2774 00000AEF 756E6374696F6E2070-
  2774 00000AF8 6172616D65746572   
  2775 00000B00 0C                      INVLDDATA:	db 12
  2776 00000B01 496E76616C69642064-     		db 'Invalid data'
  2776 00000B0A 617461             
  2777 00000B0D 1B                      INVDRVSPC:	db 27
  2778 00000B0E 496E76616C69642064-     		db 'Invalid drive specification'
  2778 00000B17 726976652073706563-
  2778 00000B20 696669636174696F6E 
  2779 00000B29 23                      ATRCURDIR:	db 35
  2780 00000B2A 417474656D70742074-     		db 'Attempt to remove current directory'
  2780 00000B33 6F2072656D6F766520-
  2780 00000B3C 63757272656E742064-
  2780 00000B45 69726563746F7279   
  2781 00000B4D 0F                      NOTSAMDEV:	db 15
  2782 00000B4E 4E6F742073616D6520-     		db 'Not same device'
  2782 00000B57 646576696365       
  2783 00000B5D 0D                      NOMOREFIL:	db 13
  2784 00000B5E 4E6F206D6F72652066-     		db 'No more files'
  2784 00000B67 696C6573           
  2785 00000B6B 0B                      FILEXISTS:	db 11
  2786 00000B6C 46696C652065786973-     		db 'File exists'
  2786 00000B75 7473               
  2787 00000B77 1B                      CANTMKDIR:	db 27
  2788 00000B78 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2788 00000B81 6B6520646972656374-
  2788 00000B8A 6F727920656E747279 
  2789 00000B93 0E                      FAILINT24:	db 14
  2790 00000B94 4661696C206F6E2049-     		db 'Fail on INT 24'
  2790 00000B9D 4E54203234         
  2791 00000BA2 15                      TOOMANYRD:	db 21
  2792 00000BA3 546F6F206D616E7920-     		db 'Too many redirections'
  2792 00000BAC 726564697265637469-
  2792 00000BB5 6F6E73             
  2793 00000BB8 15                      DUPLREDIR:	db 21
  2794 00000BB9 4475706C6963617465-     		db 'Duplicate redirection'
  2794 00000BC2 207265646972656374-
  2794 00000BCB 696F6E             
  2795 00000BCE 10                      INVPASSWD:	db 16
  2796 00000BCF 496E76616C69642070-     		db 'Invalid password'
  2796 00000BD8 617373776F7264     
  2797 00000BDF 11                      INVLDPARM:	db 17
  2798 00000BE0 496E76616C69642070-     		db 'Invalid parameter'
  2798 00000BE9 6172616D65746572   
  2799 00000BF1 12                      NETDATFAU:	db 18
  2800 00000BF2 4E6574776F726B2064-     		db 'Network data fault'
  2800 00000BFB 617461206661756C74 
  2801 00000C04 21                      FNOSUPNET:	db 33
  2802 00000C05 46756E6374696F6E20-     		db 'Function not supported by network'
  2802 00000C0E 6E6F7420737570706F-
  2802 00000C17 72746564206279206E-
  2802 00000C20 6574776F726B       
  2803 00000C26 27                      RSCNOTINS:	db 39
  2804 00000C27 526571756972656420-     		db 'Required system component not installed'
  2804 00000C30 73797374656D20636F-
  2804 00000C39 6D706F6E656E74206E-
  2804 00000C42 6F7420696E7374616C-
  2804 00000C4B 6C6564             
  2805                                  
  2806                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2807                                  ; 05/06/2023
  2808                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0D8Fh
  2809                                  
  2810 00000C4E [1F0A]                  EXTMSGPTRS:	dw INVLFUNCT
  2811 00000C50 [300A]                  		dw FNOTFOUND
  2812 00000C52 [3F0A]                  		dw PNOTFOUND
  2813 00000C54 [4E0A]                  		dw TOOMANYOF
  2814 00000C56 [C606]                  		dw ACCDENIED
  2815 00000C58 [620A]                  		dw INVHANDLE
  2816 00000C5A [710A]                  		dw MEMCBDEST
  2817 00000C5C [910A]                  		dw INSUFFMEM
  2818 00000C5E [A50A]                  		dw INVMEMBLA
  2819 00000C60 [C20A]                  		dw INVENVIRO
  2820 00000C62 [D60A]                  		dw INVFORMAT
  2821 00000C64 [E50A]                  		dw INVFNPARM
  2822 00000C66 [000B]                  		dw INVLDDATA
  2823 00000C68 0000                    		dw 0
  2824 00000C6A [0D0B]                  		dw INVDRVSPC
  2825 00000C6C [290B]                  		dw ATRCURDIR
  2826 00000C6E [4D0B]                  		dw NOTSAMDEV
  2827 00000C70 [5D0B]                  		dw NOMOREFIL
  2828 00000C72 [7E07]                  		dw CRMSG0
  2829 00000C74 [9207]                  		dw CRMSG1
  2830 00000C76 [9F07]                  		dw CRMSG2
  2831 00000C78 [A907]                  		dw CRMSG3
  2832 00000C7A [C007]                  		dw CRMSG4
  2833 00000C7C [CB07]                  		dw CRMSG5
  2834 00000C7E [ED07]                  		dw CRMSG6
  2835 00000C80 [F807]                  		dw CRMSG7
  2836 00000C82 [0B08]                  		dw CRMSG8
  2837 00000C84 [1C08]                  		dw CRMSG9
  2838 00000C86 [3708]                  		dw CRMSG10
  2839 00000C88 [4908]                  		dw CRMSG11
  2840 00000C8A [5A08]                  		dw CRMSG12
  2841 00000C8C [6A08]                  		dw CRMSG13
  2842 00000C8E [7C08]                  		dw CRMSG14
  2843 00000C90 [8B08]                  		dw CRMSG15
  2844 00000C92 [9F08]                  		dw CRMSG16
  2845 00000C94 [AF08]                  		dw CRMSG17
  2846 00000C96 [C908]                  		dw CRMSG18
  2847 00000C98 [DC08]                  		dw CRMSG19
  2848 00000C9A [E908]                  		dw CRMSG20
  2849 00000C9C 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2850 00000CEC [6B0B]                  		dw FILEXISTS
  2851 00000CEE 0000                    		dw 0
  2852 00000CF0 [770B]                  		dw CANTMKDIR
  2853 00000CF2 [930B]                  		dw FAILINT24
  2854 00000CF4 [A20B]                  		dw TOOMANYRD
  2855 00000CF6 [B80B]                  		dw DUPLREDIR
  2856 00000CF8 [CE0B]                  		dw INVPASSWD
  2857 00000CFA [DF0B]                  		dw INVLDPARM
  2858 00000CFC [F10B]                  		dw NETDATFAU
  2859 00000CFE [040C]                  		dw FNOSUPNET
  2860 00000D00 [260C]                  		dw RSCNOTINS
  2861                                  ; ----------------------------------------------------------------------------
  2862                                  	; 17/04/2023
  2863                                  ExtMsgEnd:
  2864                                  
  2865                                  ; 21/04/2023
  2866                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2867                                  
  2868                                  ; ----------------------------------------------------------------------------
  2869                                  
  2870                                  ; 20/04/2023
  2871                                  
  2872 00000D02 90<rep Eh>              align 16
  2873                                  
  2874                                  ; ----------------------------------------------------------------------------
  2875                                  
  2876                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2877                                  ;; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2878                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2879                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:0E50h (CODERES:0000h)
  2880                                  
  2881                                  ; ----------------------------------------------------------------------------
  2882                                  ; SEGMENT - CODERES
  2883                                  ; ----------------------------------------------------------------------------
  2884                                  
  2885                                  ; 11/01/2023
  2886                                  RCODE_START:	
  2887                                  
  2888                                  ; ----------------------------------------------------------------------------
  2889                                  ;***	EXEC error handling
  2890                                  ;
  2891                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2892                                  ;	We examine the error code and select an appropriate message.
  2893                                  ; --------------------------
  2894                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2895                                  ;	Condense the error scan?
  2896                                  ;	RBADNAM is checked by transient, no need here?
  2897                                  ;	Move below Ext_Exec.
  2898                                  ; ----------------------------------------------------------------------------
  2899                                  
  2900                                  Exec_Err:
  2901                                  ;SR;
  2902                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2903                                  ; in order here
  2904                                  
  2905                                  ;	Bugbug:	can we use byte compares here?
  2906                                  ;	Might be able to use byte msg#s, too.
  2907                                  
  2908                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2909                                  ;	Speed not high priority here.
  2910                                  
  2911                                  ;	Move this to transient.
  2912                                  
  2913                                  	; 10/01/2023
  2914                                  
  2915                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2916 00000D10 BA[AB06]                	mov	dx,RBADNAM
  2917 00000D13 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2918 00000D15 741B                    	je	short GotExecEMes		; bad command
  2919                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2920 00000D17 BA[7106]                	mov	dx,TOOBIG
  2921 00000D1A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2922 00000D1C 7414                    	je	short GotExecEMes		; file not found
  2923                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2924 00000D1E BA[5D06]                	mov	dx,EXEBAD
  2925 00000D21 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2926 00000D23 740D                    	je	short GotExecEMes		; bad exe file
  2927                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2928 00000D25 BA[C606]                	mov	dx,ACCDEN
  2929 00000D28 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2930 00000D2A 7406                    	je	short GotExecEMes		; access denied
  2931                                  
  2932                                  Default_Message:
  2933                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2934 00000D2C BA[4906]                	mov	dx,EXECEMES
  2935                                  						; default message
  2936 00000D2F BE[EC01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2937                                  						; get address of subst block
  2938                                  GotExecEMes:
  2939                                  	;mov	dx,bx				; DX = ptr to msg
  2940 00000D32 E85C06                  	call	RPrint ; invoke	RPrint
  2941 00000D35 EB09                    	jmp	short NoExec
  2942                                  
  2943                                  ; ----------------------------------------------------------------------------
  2944                                  ;***	EXEC call
  2945                                  ;
  2946                                  ;	The transient has set up everything for an EXEC system call.
  2947                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2948                                  ;	so that we may be able to recover cleanly upon success.
  2949                                  ;
  2950                                  ;	CS,DS,ES,SS = DATARES seg addr
  2951                                  ; ----------------------------------------------------------------------------
  2952                                  
  2953                                  Ext_Exec:
  2954                                  ;SR;
  2955                                  ; The words put on the stack by the stub will be popped off when we finally
  2956                                  ;jump to LodCom (by LodCom).
  2957                                  
  2958                                  	; 10/01/2023
  2959                                  	;int	21h			; do the exec
  2960                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2961                                  Exec_Ret:
  2962 00000D37 72D7                    	jc	short Exec_Err		; exec failed
  2963                                  
  2964                                  ;	The exec has completed. Retrieve the exit code.
  2965                                  
  2966                                  Exec_Wait:
  2967 00000D39 B44D                    	mov	ah,4Dh
  2968                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2969 00000D3B CD21                    	int	21h			; get the return code
  2970                                  	;mov	[cs:RetCode],ax
  2971                                  	; 11/01/2023
  2972 00000D3D A3[5602]                	mov	[RetCode],ax
  2973                                  
  2974                                  ;	See if we can reload the transient. The external command
  2975                                  ;	may have overwritten part of the transient.
  2976                                  
  2977                                  NoExec:
  2978                                  ;SR;
  2979                                  ; ds = es = ss = DATARES when we jump to LodCom
  2980                                  ;
  2981 00000D40 E97A01                  	jmp	LodCom
  2982                                  
  2983                                  ; ----------------------------------------------------------------------------
  2984                                  ;***	Int 23 (ctrl-c) handler
  2985                                  ;
  2986                                  ;	This is the default system INT 23 handler. All processes
  2987                                  ;	(including COMMAND) get it by default. There are some
  2988                                  ;	games that are played: We ignore ^C during most of the
  2989                                  ;	INIT code. This is because we may perform an ALLOC and
  2990                                  ;	diddle the header! Also, if we are prompting for date/time
  2991                                  ;	in the init code, we are to treat ^C as empty responses.
  2992                                  ; ---------------------------
  2993                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2994                                  ; ----------------------------------------------------------------------------
  2995                                  
  2996                                  ;SR;
  2997                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2998                                  ;both these values off the stack now
  2999                                  ;
  3000                                  ;ContC	proc	far
  3001                                  
  3002                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3003                                  
  3004                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  3005                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  3006                                  ContC:
  3007 00000D43 1F                      	pop	ds			; ds = DATARES
  3008                                  ;	assume	ds:DATARES
  3009                                  ;;	pop	word [OldDS]		; OldDS = old ds
  3010                                  
  3011 00000D44 F606[D202]01            	test	byte [InitFlag],INITINIT ; 1
  3012                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  3013 00000D49 740D                    	jz	short NotAtInit		; no
  3014 00000D4B F606[D202]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  3015                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  3016 00000D50 7404                    	jz	short CmdIret		; no, ignore ^C
  3017 00000D52 1F                      	pop	ds			; restore before jumping; M021
  3018                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  3019 00000D53 E9830E                  	jmp	init_contc_specialcase
  3020                                  CmdIret:
  3021                                  ;SR;
  3022                                  ; Restore ds to its previous value
  3023                                  ;
  3024                                  
  3025                                  ;;	mov	ds,[OLdDS]		;
  3026 00000D56 1F                      	pop	ds
  3027 00000D57 CF                      	iret				; yes, ignore the ^C
  3028                                  
  3029                                  NotAtInit:
  3030 00000D58 F606[D202]04            	test	byte [InitFlag],INITCTRLC ; 4
  3031                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  3032 00000D5D 7412                    	jz	short NotInit 		; nope too.
  3033                                  
  3034                                  ;*	We are interrupting ourselves in this ^C handler. We need
  3035                                  ;	to set carry and return to the user sans flags only if the
  3036                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  3037                                  
  3038 00000D5F 80FC01                  	cmp	ah,1
  3039 00000D62 72F2                    	jb	short CmdIret
  3040 00000D64 80FC0C                  	cmp	ah,12
  3041 00000D67 77ED                    	ja	short CmdIret
  3042                                  
  3043 00000D69 1F                      	pop	ds			;restore ds to old value
  3044 00000D6A 83C406                  	add	sp,6			; remove int frame
  3045 00000D6D F9                      	stc
  3046                                  
  3047                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  3048 00000D6E CA0200                  	retf	2			; remove those flags...
  3049                                  
  3050                                  NotInit:
  3051                                  
  3052                                  ;*	We have now received a ^C for some process (maybe ourselves
  3053                                  ;	but not at INIT).
  3054                                  ;	
  3055                                  ;	Note that we are running on the user's stack!!! Bad news if
  3056                                  ;	any of the system calls below go and issue another INT
  3057                                  ;	24... Massive stack overflow! Another bad point is that
  3058                                  ;	SavHand will save an already saved handle, thus losing a
  3059                                  ;	possible redirection...
  3060                                  ;	
  3061                                  ;	All we need to do is set the flag to indicate nested ^C. 
  3062                                  ;	The above code will correctly flag the ^C diring the
  3063                                  ;	message output and prompting while ignoring the ^C the rest
  3064                                  ;	of the time.
  3065                                  ;	
  3066                                  ;	Clean up: flush disk. If we are in the middle of a batch
  3067                                  ;	file, we ask if he wants to terminate it. If he does, then
  3068                                  ;	we turn off all internal flags and let the DOS abort.
  3069                                  
  3070 00000D71 800E[D202]04            	or	byte [InitFlag],INITCTRLC ; 4
  3071                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  3072 00000D76 FB                      	sti
  3073                                  
  3074                                  ;	push	cs			; el yucko! change the user's ds!!
  3075                                  ;	pop	ds
  3076                                  
  3077                                  ;	assume	ds:RESGROUP
  3078                                  
  3079 00000D77 58                      	pop	ax			; discard the old ds value
  3080                                  
  3081 00000D78 A1[6102]                	mov	ax,[SingleCom]
  3082 00000D7B 09C0                    	or	ax,ax
  3083 00000D7D 7506                    	jnz	short NoReset
  3084 00000D7F 50                      	push	ax
  3085 00000D80 B40D                    	mov	ah,DISK_RESET ; 0Dh
  3086 00000D82 CD21                    	int	21h			; reset disks in case files were open
  3087 00000D84 58                      	pop	ax
  3088                                  
  3089                                  NoReset:
  3090                                  
  3091                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  3092                                  ;	walk the entire active list and free each segment. Here,
  3093                                  ;	we just free the single batch segment.
  3094                                  
  3095 00000D85 F706[0502]FFFF          	test	word [Batch],-1 ; 0FFFFh
  3096 00000D8B 7453                    	jz	short ContCTerm
  3097 00000D8D 09C0                    	or	ax,ax
  3098 00000D8F 754F                    	jnz	short ContCTerm
  3099 00000D91 E88602                  	call	SavHand
  3100 00000D94 E89403                  	call	AskEnd			; ask if user wants to end batch
  3101                                  
  3102                                  ;	If the carry flag is clear, we do NOT free up the batch file
  3103                                  
  3104 00000D97 7341                    	jnc	short ContBatch
  3105 00000D99 8A0E[5902]              	mov	cl,[EchoFlag]		; get current echo flag
  3106 00000D9D 53                      	push	bx
  3107                                  
  3108                                  ClearBatch:
  3109 00000D9E 8E06[0502]              	mov	es,[Batch]		; get batch segment
  3110                                  	;mov	di,20h
  3111 00000DA2 8B3E2000                	mov	di,[BATCHSEGMENT.BatFile] ; get offset of batch file name
  3112                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  3113                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  3114 00000DA6 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  3115                                  	; MSDOS 3.3 ([ES:4])
  3116                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  3117                                  	;
  3118 00000DAB 83FB00                  	cmp	bx,0			; is a FOR in progress
  3119 00000DAE 7408                    	je	short No_Bat_For	; no - don't deallocate
  3120 00000DB0 06                      	push	es			;
  3121 00000DB1 8EC3                    	mov	es,bx			; yes - free it up...
  3122 00000DB3 B449                    	mov	ah,49h
  3123                                  	;mov	ah,DEALLOC ; 49h	;
  3124 00000DB5 CD21                    	int	21h			;
  3125 00000DB7 07                      	pop	es			; restore to batch segment
  3126                                  
  3127                                  No_Bat_For:
  3128                                  	;mov	cl,[es:1]
  3129 00000DB8 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  3130                                  	;mov	bx,[es:3]
  3131 00000DBD 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  3132 00000DC2 B449                    	mov	ah,49h
  3133                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  3134 00000DC4 CD21                    	int	21h
  3135 00000DC6 891E[0502]              	mov	[Batch],bx		; get ready to deallocate next batch
  3136 00000DCA FF0E[6A02]              	dec	word [Nest]		; is there another batch file?
  3137 00000DCE 75CE                    	jnz	short ClearBatch	; keep going until no batch file
  3138                                  
  3139                                  ;	We are terminating a batch file; restore the echo status
  3140                                  
  3141                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  3142 00000DD0 5B                      	pop	bx
  3143 00000DD1 880E[5902]              	mov	[EchoFlag],cl		; reset echo status
  3144                                  	; 29/05/2018
  3145 00000DD5 C606[D302]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  3146                                  
  3147                                  ContBatch:
  3148 00000DDA E8B105                  	call	crlf			; print out crlf before returning
  3149 00000DDD E86302                  	call	RestHand
  3150                                  
  3151                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  3152                                  
  3153                                  ContCTerm:
  3154 00000DE0 31C0                    	xor	ax,ax			; indicate no read
  3155 00000DE2 89C5                    	mov	bp,ax
  3156                                  
  3157                                  ;	The following resetting of the state flags is good for the
  3158                                  ;	generalized batch processing.
  3159                                  
  3160 00000DE4 A2[6602]                	mov	[IfFlag],al		; turn off iffing
  3161 00000DE7 A2[6702]                	mov	[ForFlag],al		; turn off for processing
  3162 00000DEA E81C00                  	call	ResPipeOff
  3163 00000DED 3906[6102]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  3164 00000DF1 7406                    	jz	short NoSetSing
  3165 00000DF3 C706[6102]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  3166                                  					;  pipe, batch, for
  3167                                  NoSetSing:
  3168                                  
  3169                                  ;	If we are doing an internal command, go through the reload process.
  3170                                  ;	If we are doing an external, let DOS abort the process.
  3171                                  ;	In both cases, we are now done with the ^C processing.
  3172                                  
  3173 00000DF9 8026[D202]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  3174 00000DFE 3806[5502]              	cmp	[ExtCom],al
  3175 00000E02 7503                    	jnz	short DoDAb		; internal ^c
  3176 00000E04 E94501                  	jmp	LodCom1
  3177                                  DoDAb:
  3178 00000E07 F9                      	stc				; tell dos to abort
  3179                                  
  3180                                  ;SR;
  3181                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  3182                                  ;by setting carry and leaving flags on the stack
  3183                                  
  3184 00000E08 CB                      	retf				; Leave flags on stack
  3185                                  
  3186                                  ;ContC	endp
  3187                                  
  3188                                  ;SR;
  3189                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  3190                                  ;both have ds = DATARES
  3191                                  
  3192                                  	; 11/01/2023
  3193                                  ResPipeOff:
  3194 00000E09 50                      	push	ax
  3195 00000E0A 31C0                    	xor	ax,ax
  3196                                  	;xchg	al,[cs:PIPEFLAG]
  3197 00000E0C 8606[D302]              	xchg	al,[PipeFlag]
  3198 00000E10 08C0                    	or	al,al
  3199 00000E12 7404                    	jz	short NoPipePop
  3200                                  	;shr	byte [cs:ECHOFLAG],1
  3201 00000E14 D02E[5902]              	shr	byte [EchoFlag],1
  3202                                  NoPipePop:
  3203 00000E18 58                      	pop	ax
  3204 00000E19 C3                      	retn
  3205                                  
  3206                                  ;CODERES ends
  3207                                  
  3208                                  ;=============================================================================
  3209                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  3210                                  ;=============================================================================
  3211                                  ; 21/09/2018 - Retro DOS v3.0
  3212                                  
  3213                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  3214                                  ;	name	COMMAND2
  3215                                  
  3216                                  ;/*
  3217                                  ; *                      Microsoft Confidential
  3218                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3219                                  ; *                      All Rights Reserved.
  3220                                  ; */
  3221                                  
  3222                                  ;
  3223                                  ;	Revision History
  3224                                  ;	================
  3225                                  ;
  3226                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  3227                                  ;			reserve memory by changing int 12h and then give it
  3228                                  ;			back to DOS by changing arenas in autoexec.bat.
  3229                                  ;			This makes command.com reload transient and this
  3230                                  ;			cannot be done at this stage.
  3231                                  ;
  3232                                  
  3233                                  ;CODERES segment public byte
  3234                                  
  3235                                  ;*	If we cannot allocate enough memory for the transient or there
  3236                                  ;	was some other allocation error, we display a message and
  3237                                  ;	then die.
  3238                                  
  3239                                  ;SR;
  3240                                  ; We will have to make sure that at this entry point and at FatalC, 
  3241                                  ;ds = DATARES. All jumps to these points are made from only within this file
  3242                                  ;and so we should be able to do this
  3243                                  
  3244                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3245                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  3246                                  
  3247                                  	;assume	ds:DATARES
  3248                                  BadMemErr:
  3249 00000E1A BA[D506]                	mov	dx,BMEMMES			; DX = ptr to msg
  3250                                  FatalC:
  3251                                  	; 12/01/2023
  3252                                  ;;	push	cs
  3253                                  ;;	pop	ds
  3254                                  ;;	assume	ds:ResGroup
  3255                                  ;	invoke	RPrint
  3256                                  
  3257                                  	; 12/01/2023
  3258                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3259 00000E1D E87105                  	call	RPrint
  3260                                  
  3261                                  	; MSDOS 3.3
  3262                                  	;call	RDISPMSG
  3263                                  
  3264                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  3265                                  ;	we can't do anything else!
  3266                                  
  3267 00000E20 803E[5E02]00            	cmp	byte [PermCom],0
  3268 00000E25 7410                    	je	short FatalRet
  3269                                  
  3270                                  ;	We are a permanent command. If we are in the process of the
  3271                                  ;	magic interrupt (Singlecom) then exit too.
  3272                                  
  3273 00000E27 833E[6102]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  3274 00000E2C 7509                    	jne	short FatalRet			; must take int_2e exit
  3275                                  
  3276                                  ;	Permanent command. We can't do ANYthing except halt.
  3277                                  
  3278 00000E2E BA[EF06]                	mov	dx,HALTMES			; DX = ptr to msg
  3279                                  	;invoke	RPrint
  3280                                  	; 12/01/2023	
  3281                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3282 00000E31 E85D05                  	call	RPrint	
  3283                                  	; MSDOS 3.3
  3284                                  	;call	RDISPMSG
  3285 00000E34 FB                      	sti
  3286                                  Stall:
  3287 00000E35 EBFE                    	jmp	short Stall			; crash the system nicely
  3288                                  
  3289                                  FatalRet:
  3290 00000E37 BA[1607]                	mov	dx,FRETMES			; DX = ptr to msg
  3291                                  	;call	RDISPMSG
  3292                                  	; 12/01/2023	
  3293 00000E3A E85405                  	call	RPrint	
  3294                                  FatalRet2:
  3295 00000E3D 803E[5E02]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  3296 00000E42 7517                    	jne	short Ret_2e			; must be int_2e
  3297                                  
  3298                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3299                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3300                                  ;	case we decide to do that.)
  3301                                  
  3302 00000E44 A1[FA01]                	mov	ax,[Parent]
  3303                                  	;mov	[16h],ax
  3304 00000E47 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3305 00000E4A A1[FC01]                	mov	ax,[OldTerm]
  3306                                  	;mov	[0Ah],ax
  3307 00000E4D A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3308 00000E50 A1[FE01]                	mov	ax,[OldTerm+2]
  3309                                  	;mov	[0Ch],ax
  3310 00000E53 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3311 00000E56 B8004C                  	mov	ax,4C00h
  3312                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3313 00000E59 CD21                    	int	21h
  3314                                  Ret_2e:
  3315                                  ;SR;
  3316                                  ; We will ensure that ds = DATARES for all entries to this place
  3317                                  ;
  3318                                  
  3319                                  ;;	push	cs
  3320                                  ;;	pop	ds
  3321                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3322                                    	
  3323                                  ;	assume	ds:DATARES
  3324                                  
  3325                                  	;PUSH	CS
  3326                                  	;POP	DS
  3327                                  
  3328 00000E5B C706[6102]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3329 00000E61 8E06[1A04]              	mov	es,[Res_Tpa]
  3330                                  	;mov	ah,49h	; 12/01/2023
  3331 00000E65 B449                    	mov	ah,DEALLOC
  3332 00000E67 CD21                    	int	21h			; free up space used by transient
  3333 00000E69 8B1E[F801]              	mov	bx,[Save_Pdb]
  3334 00000E6D B450                    	mov	ah,50h
  3335                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3336 00000E6F CD21                    	int	21h			; current process is user
  3337 00000E71 A1[5602]                	mov	ax,[RetCode]
  3338 00000E74 803E[5502]00            	cmp	byte [ExtCom],0
  3339 00000E79 7502                    	jne	short GotECode
  3340 00000E7B 31C0                    	xor	ax,ax			; internals always return 0
  3341                                  GotECode:
  3342 00000E7D C606[5502]01            	mov	byte [ExtCom],1		; force external
  3343                                  
  3344                                  ;SR; This is actually returning to the caller. However, the old code had
  3345                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3346                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3347                                  
  3348                                  	; 12/01/2023
  3349 00000E82 FF2E[F401]              	jmp	far [Int_2e_Ret]	; "iret"
  3350                                  
  3351                                  ;***	Int_2e, magic command executer
  3352                                  
  3353                                  Int_2e:
  3354                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3355                                  ;SR;
  3356                                  ;We are going to come here from the stub with the old ds and DATARES value
  3357                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3358                                  
  3359                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3360                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3361                                  
  3362 00000E86 1F                      	pop	ds			; ds = DATARES
  3363                                  	;assume	ds:DATARES
  3364 00000E87 58                      	pop	ax
  3365                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3366                                  
  3367                                  	;pop	word [cs:Int_2e_Ret]
  3368                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3369                                  	;pop	ax			; chuck flags
  3370 00000E88 8F06[F401]              	pop	word [Int_2e_Ret]
  3371 00000E8C 8F06[F601]              	pop	word [Int_2e_Ret+2]
  3372                                  	
  3373 00000E90 83C402                  	add	sp,2
  3374                                  
  3375                                  ;;	push	cs
  3376                                  ;;	pop	es
  3377                                  
  3378 00000E93 1E                      	push	ds
  3379 00000E94 07                      	pop	es			; es = DATARES
  3380                                  ;	;mov	ds,OldDS
  3381 00000E95 8ED8                    	mov	ds,ax
  3382                                  	;assume	ds:nothing		; ds = old value
  3383                                  
  3384 00000E97 BF8000                  	mov	di,80h
  3385 00000E9A B94000                  	mov	cx,64
  3386                                  ;	Bugbug:	cld
  3387 00000E9D F3A5                    	rep	movsw
  3388 00000E9F B451                    	mov	ah,51h
  3389                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3390 00000EA1 CD21                    	int	21h			; get user's header
  3391                                  	; 12/01/2023
  3392 00000EA3 26891E[F801]            	mov	[es:Save_Pdb],bx
  3393                                  	;mov	[cs:Save_Pdb],bx
  3394 00000EA8 B450                    	mov	ah,50h
  3395                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3396                                  
  3397                                  ;;	mov	bx,cs
  3398                                  ;SR;
  3399                                  ;Set ds = DATARES because BadMemErr expects this
  3400                                  
  3401                                  	; 12/01/2023
  3402 00000EAA 06                      	push	es
  3403 00000EAB 1F                      	pop	ds
  3404                                  	;assume	ds:DATARES
  3405                                  
  3406 00000EAC 8CDB                    	mov	bx,ds			; es = our PSP now
  3407                                  	;mov	bx,cs
  3408                                  
  3409 00000EAE CD21                    	int	21h			; current process is me
  3410                                  	;mov	word [cs:SingleCom],81h
  3411                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3412                                  	; 12/01/2023
  3413 00000EB0 C706[6102]8100          	mov	word [SingleCom],81h
  3414 00000EB6 C606[5502]01            	mov	byte [ExtCom],1		; make sure this case forced
  3415                                  
  3416                                  ;SR;
  3417                                  ;We can enter LodCom directly after a command shell is terminated or we
  3418                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3419                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3420                                  ;be properly set. To fake this, we push dummy values here.
  3421                                  
  3422                                  	; 12/01/2023
  3423 00000EBB 1E                      	push	ds			; old value of ds
  3424 00000EBC 1E                      	push	ds			; data seg value, ds = DATARES
  3425                                  LodCom: 				; termination handler
  3426 00000EBD 1F                      	pop	ds			; ds = DATARES
  3427                                  	;assume	ds:DATARES
  3428 00000EBE 83C402                  	add	sp,2
  3429                                  ;	;pop	OldDS			; store old ds
  3430                                  	;cmp	ExtCom,0
  3431 00000EC1 803E[5502]00            	cmp	byte [ExtCom],0
  3432                                  	;cmp	byte [cs:ExtCom],0
  3433                                  	;jne	short @f	 	; internal cmd - memory allocated
  3434                                  	; 16/04/2023
  3435 00000EC6 7503                    	jne	short LodCom0 ; 24/09/2018
  3436 00000EC8 E98100                  	jmp	LodCom1
  3437                                  	;je	short LodCom1 ; 25/09/2018	
  3438                                  ;@@:
  3439                                  LodCom0: ; 24/09/2018
  3440 00000ECB BBFFFF                  	mov	bx,0FFFFh
  3441 00000ECE B448                    	mov	ah,48h	; 12/01/2023
  3442                                  	;mov	ah,ALLOC ; 48h	
  3443 00000ED0 CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3444                                  				; BX = number of 16-byte paragraphs desired
  3445 00000ED2 E80A00                  	call	SetSize
  3446 00000ED5 83C020                  	add	ax,20h
  3447 00000ED8 39C3                    	cmp	bx,ax
  3448 00000EDA 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3449                                  BadMemErrJ:
  3450 00000EDC E93BFF                  	jmp	BadMemErr		; not enough memory
  3451                                  
  3452                                  ;***	SetSize - get transient size in paragraphs
  3453                                  
  3454                                  SetSize:
  3455                                  	; 12/01/2023
  3456                                  	;;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3457                                  	;;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3458                                  	; 05/06/2023
  3459                                  	;mov	ax,0AFA4h		; MSDOS 6.22 COMMAND.COM
  3460 00000EDF B886AA                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3461 00000EE2 B104                    	mov	cl,4
  3462 00000EE4 D3E8                    	shr	ax,cl
  3463 00000EE6 C3                      	retn
  3464                                  
  3465                                  MemOk:
  3466                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3467                                  
  3468 00000EE7 B448                    	mov	ah,48h
  3469                                  	;mov	ah,ALLOC  ; 48h
  3470 00000EE9 CD21                    	int	21h
  3471 00000EEB 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3472                                  	;mov	byte [cs:ExtCom],0
  3473                                  	;mov	[cs:Res_Tpa],ax
  3474                                  	; 12/01/2023
  3475 00000EED C606[5502]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3476 00000EF2 A3[1A04]                	mov	[Res_Tpa],ax		; save current tpa segment
  3477                                  
  3478 00000EF5 2500F0                  	and	ax,0F000h
  3479 00000EF8 050010                  	add	ax,1000h		; round up to next 64k boundary
  3480 00000EFB 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3481                                  
  3482                                  ;	Make sure that new boundary is within allocated range
  3483                                  
  3484                                  	;mov	dx,[cs:Res_Tpa]
  3485                                  	; 12/01/2023
  3486 00000EFD 8B16[1A04]              	mov	dx,[Res_Tpa]
  3487 00000F01 01DA                    	add	dx,bx			; compute maximum address
  3488 00000F03 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3489 00000F05 7608                    	jbe	short Bad_Tpa
  3490                                  
  3491                                  ;	Must have 64K of usable space.
  3492                                  
  3493 00000F07 29C2                    	sub	dx,ax			; compute the usable space
  3494 00000F09 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3495 00000F0D 7303                    	jae	short LTpaSet
  3496                                  Bad_Tpa:
  3497                                  	;mov	ax,[cs:Res_Tpa]
  3498                                  	; 12/01/2023
  3499 00000F0F A1[1A04]                	mov	ax,[Res_Tpa]
  3500                                  LTpaSet:
  3501                                  	;mov	[cs:LTPA],ax
  3502                                  	;mov	ax,[cs:Res_Tpa]
  3503                                  	; 12/01/2023
  3504 00000F12 A3[0C04]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3505 00000F15 A1[1A04]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3506 00000F18 01C3                    	add	bx,ax
  3507                                  	;mov	[cs:MemSiz],bx
  3508 00000F1A 891E[5102]              	mov	[MemSiz],bx
  3509 00000F1E E8BEFF                  	call	SetSize
  3510 00000F21 29C3                    	sub	bx,ax
  3511                                  
  3512                                  	; MSDOS 6.0
  3513                                  
  3514                                  ;M038; Start of changes
  3515                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3516                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3517                                  ;running a program that changes arenas. This changes the largest block that
  3518                                  ;command.com gets and so changes the transient segment. So, command.com does
  3519                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3520                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3521                                  ;reload fails, hanging the system. To get around this we just copy the
  3522                                  ;transient from the previous address to the new address(if changed) and
  3523                                  ;then let command.com do the checksum. So, if the transient area is not
  3524                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3525                                  ;is not really corrupted and so this should work.
  3526                                  
  3527                                  	; 12/01/2023
  3528                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3529                                  
  3530 00000F23 3B1E[4B02]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3531 00000F27 7423                    	je	short LodCom1		; yes, dont copy
  3532                                  
  3533                                  ;Check if the new segment is above or below the current move. If the new
  3534                                  ;segment is above (i.e new block is larger than previous block), then we
  3535                                  ;have to move in the reverse direction
  3536                                  
  3537                                  	;;mov	cx,98C5h
  3538                                  	; 05/06/2023
  3539                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:106Ah (CODERES:021Ah)
  3540                                  	;mov	cx,0AF95h
  3541 00000F29 B977AA                  	mov	cx,TRANSPACEEND		; cx = length to move
  3542 00000F2C 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3543 00000F2E 31F6                    	xor	si,si			; normal move
  3544 00000F30 89F7                    	mov	di,si
  3545 00000F32 FC                      	cld
  3546 00000F33 EB06                    	jmp	short copy_trans
  3547                                  mov_down:
  3548 00000F35 89CE                    	mov	si,cx			; reverse move, start from end
  3549 00000F37 4E                      	dec	si
  3550 00000F38 89F7                    	mov	di,si
  3551 00000F3A FD                      	std
  3552                                  copy_trans:
  3553 00000F3B 1E                      	push	ds
  3554 00000F3C 06                      	push	es
  3555 00000F3D 8EC3                    	mov	es,bx			; dest segment
  3556 00000F3F 8E1E[4B02]              	mov	ds,[TrnSeg]		; source segment
  3557                                  	;assume	ds:nothing
  3558                                  
  3559 00000F43 F3A4                    	rep	movsb			; copy transient
  3560 00000F45 FC                      	cld
  3561 00000F46 07                      	pop	es
  3562 00000F47 1F                      	pop	ds
  3563                                  	;assume	ds:DATARES
  3564                                  
  3565                                  ;M038; End of changes
  3566                                  
  3567                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3568                                  	; 12/01/2023
  3569 00000F48 891E[4B02]              	mov	[TrnSeg],bx
  3570                                  
  3571                                  LodCom1:
  3572                                  ;;	mov	ax,cs
  3573                                  ;;	mov	ss,ax
  3574                                  ;SR; At this point ds = DATARES which is where the stack is located
  3575                                  
  3576                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3577                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3578 00000F4C 8CD8                    	mov	ax,ds
  3579 00000F4E 8ED0                    	mov	ss,ax
  3580                                  	;assume	ss:DATARES
  3581                                  	;;;mov	sp,offset DATARES:RStack
  3582                                  	;;mov	sp,53Eh
  3583                                  	; 05/06/2023
  3584                                  	;mov	sp,60Ah ; MSDOS 6.22 COMMAND.COM
  3585 00000F50 BC[F404]                	mov	sp,RStack
  3586                                  
  3587                                  ;;	mov	ds,ax
  3588                                  
  3589                                  	;assume	ds:DATARES
  3590                                  	
  3591                                  	; MSDOS 3.3
  3592                                  	;mov	ax,cs
  3593                                  	;mov	ss,ax
  3594                                  	;mov	sp,RSTACK
  3595                                  	;mov	ds,ax
  3596                                  
  3597 00000F53 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3598 00000F56 31ED                    	xor	bp,bp			; flag command ok
  3599 00000F58 B8FFFF                  	mov	ax,-1
  3600 00000F5B 8706[6302]              	xchg	ax,[VerVal]
  3601 00000F5F 83F8FF                  	cmp	ax,-1
  3602 00000F62 7404                    	je	short NoSetVer
  3603 00000F64 B42E                    	mov	ah,2Eh
  3604                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3605 00000F66 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3606                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3607                                  NoSetVer:
  3608 00000F68 833E[6102]FF            	cmp	word [SingleCom],-1
  3609 00000F6D 7503                    	jne	short NoSng
  3610 00000F6F E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3611                                  NoSng:
  3612 00000F72 E87201                  	call	ChkSum			; check the transient
  3613                                  	;cmp	dx,[Sum]
  3614                                  	;je	short HavCom		; transient ok
  3615                                  	; 12/01/2023
  3616 00000F75 7412                    	jz	short HavCom
  3617                                  Bogus_Com:
  3618 00000F77 C606[0402]01            	mov	byte [Loading],1	; flag DskErr routine
  3619 00000F7C E81E01                  	call	LoadCom
  3620                                  ChkSame:
  3621 00000F7F E86501                  	call	ChkSum
  3622                                  	;cmp	dx,[Sum]
  3623                                  	;je	short HavCom		; same command
  3624                                  	; 12/01/2023
  3625 00000F82 7405                    	jz	short HavCom
  3626                                  Also_Bogus:
  3627 00000F84 E85801                  	call	WrongCom
  3628 00000F87 EBF6                    	jmp	short ChkSame
  3629                                  
  3630                                  	; 12/01/2023
  3631                                  ;HavCom:
  3632                                  ;	; 25/09/2018
  3633                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3634                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3635                                  ;			; Return: AL = FFh unsupported subfunction
  3636                                  ;			; DL = current switch character
  3637                                  ;	mov     [RSWITCHAR],dl
  3638                                  ;	cmp     dl,'/'
  3639                                  ;	jnz     short USESLASH
  3640                                  ;	;mov	cl,'\'
  3641                                  ;	;mov	[RDIRCHAR],cl
  3642                                  ;	mov	byte [RDIRCHAR],'\'
  3643                                  ;USESLASH:
  3644                                  
  3645                                  HavCom:
  3646                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3647 00000F89 C606[0402]00            	mov	byte [Loading],0		; flag to DskErr
  3648                                  	;;;mov	si,offset DATARES:TranVars
  3649                                  	;;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3650                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  3651                                  	;mov	si,51Dh		; MSDOS 6.22 COMMAND.COM
  3652 00000F8E BE[0804]                	mov	si,TranVars
  3653                                  	;;;mov	di,offset TRANGROUP:HeadCall
  3654                                  	;;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3655                                  	; 05/06/2023
  3656                                  	;mov	di,0A303h	; MSDOS 6.22 COMMAND.COM
  3657 00000F91 BF[E29D]                	mov	di,HEADCALL
  3658 00000F94 8E06[4B02]              	mov	es,[TrnSeg]
  3659 00000F98 FC                      	cld
  3660                                  	;;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3661                                  	;mov	cx,533h		; MSDOS 6.22 COMMAND.COM	
  3662 00000F99 B9[1E04]                	mov	cx,TranVarEnd
  3663 00000F9C 29F1                    	sub	cx,si
  3664 00000F9E F3A4                    	rep	movsb			; transfer info to transient
  3665 00000FA0 A1[5102]                	mov	ax,[MemSiz]
  3666 00000FA3 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3667                                  
  3668                                  ;***	TJmp - jump-off to transient
  3669                                  ;
  3670                                  ;	Public label so debugger can find this spot.
  3671                                  
  3672                                  TJmp:	; 12/01/2023
  3673 00000FA6 FF2E[4902]              	jmp	far [Trans]		; jmp dword ptr Trans
  3674                                  
  3675                                  ;***	TRemCheck - far version of RemCheck for transient
  3676                                  
  3677                                  TRemCheck:
  3678                                  	; 12/01/2023
  3679 00000FAA 1F                      	pop	ds			; ds = DATARES
  3680 00000FAB 83C402                  	add	sp,2			; discard old value of ds
  3681                                  
  3682 00000FAE E80100                  	call	RemCheck
  3683 00000FB1 CB                      	retf
  3684                                  
  3685                                  ;***	RemCheck
  3686                                  ;
  3687                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3688                                  ;
  3689                                  ;	EXIT	ZR set if removeable media
  3690                                  ;		ZR clear if fixed media
  3691                                  ;
  3692                                  ;	USED	none
  3693                                  
  3694                                  	; 12/01/2023
  3695                                  RemCheck:
  3696 00000FB2 50                      	push	ax
  3697 00000FB3 53                      	push	bx
  3698 00000FB4 89C3                    	mov	bx,ax
  3699 00000FB6 B80844                  	mov	ax,4408h
  3700                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3701 00000FB9 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3702 00000FBB 7304                    	jnc	short rcCont		
  3703                                  
  3704                                  ;	If an error occurred, assume the media is non-removable.
  3705                                  ;	AX contains the non-zero error code from the int 21, so
  3706                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3707                                  ;	appear to be non-removable.				
  3708                                  					
  3709 00000FBD 09C0                    	or	ax,ax			
  3710 00000FBF EB05                    	jmp	short ResRegs
  3711                                  rcCont:
  3712 00000FC1 83E001                  	and	ax,1
  3713 00000FC4 F7D0                    	not	ax
  3714                                  ResRegs:
  3715 00000FC6 5B                      	pop	bx
  3716 00000FC7 58                      	pop	ax
  3717 00000FC8 C3                      	retn
  3718                                  
  3719                                  ;***	THeadFix
  3720                                  ;
  3721                                  ;	Far version of HeadFix, called from transient.
  3722                                  
  3723                                  THeadFix:
  3724                                  	; 12/01/2023
  3725 00000FC9 1F                      	pop	ds			; ds = DATARES
  3726 00000FCA 83C402                  	add	sp,2			; discard old ds value on stack
  3727                                  
  3728 00000FCD E80100                  	call	HeadFix
  3729 00000FD0 CB                      	retf
  3730                                  
  3731                                  ;***	HeadFix
  3732                                  
  3733                                  	; 12/01/2023
  3734                                  HeadFix:
  3735 00000FD1 E83101                  	call	SetVect			; set vectors to our values
  3736                                  
  3737                                  ;	Clean up header
  3738                                  
  3739                                  ;	Bugbug:	optimize:
  3740                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3741                                  
  3742 00000FD4 31DB                    	xor	bx,bx			; BX = handle = 0
  3743 00000FD6 8B0E[5B02]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3744                                  	;mov	dx,[18h] 
  3745 00000FDA 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3746 00000FDE 38D1                    	cmp	cl,dl
  3747 00000FE0 7408                    	je	short Chk1		; stdin matches
  3748 00000FE2 B43E                    	mov	ah,3Eh
  3749                                  	;mov	ah,CLOSE  ; 3Eh
  3750 00000FE4 CD21                    	int	21h			; close stdin
  3751                                  	;mov	[18h],cl
  3752 00000FE6 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3753                                  Chk1:
  3754 00000FEA 43                      	inc	bx			; BX = handle = 1
  3755 00000FEB 38F5                    	cmp	ch,dh			
  3756 00000FED 7408                    	je	short ChkOtherHand	; stdout matches
  3757 00000FEF B43E                    	mov	ah,3Eh
  3758                                  	;mov	ah,CLOSE
  3759 00000FF1 CD21                    	int	21h			; close stdout
  3760                                  	;mov	[19h],ch
  3761 00000FF3 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3762                                  ChkOtherHand:
  3763 00000FF7 83C304                  	add	bx,4			; skip handles 2,3,4
  3764 00000FFA B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3765                                  					; (handles 0-4 already done)
  3766                                  CloseLoop:
  3767 00000FFD B43E                    	mov	ah,3Eh
  3768                                  	;mov	ah,CLOSE ; 3Eh
  3769 00000FFF CD21                    	int	21h			; close each handle
  3770 00001001 43                      	inc	bx			; BX = next handle
  3771 00001002 E2F9                    	loop	CloseLoop
  3772                                  
  3773                                  	; MSDOS 6.0
  3774                                  ;	Bugbug:	since this is for transient code, move it there
  3775                                  	
  3776                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3777                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3778                                  
  3779                                  ;	M012: remove this CS -> DS. Must've been missed during
  3780                                  ;	purification.
  3781                                  ;;	push	ds			; save data segment
  3782                                  ;;	push	cs			; get local segment into DS
  3783                                  ;;	pop	ds			;
  3784 00001004 803E[8002]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3785 00001009 750E                    	jne	short Append_Fix_End	; no - just exit
  3786 0000100B B807B7                  	mov	ax,0B707h
  3787                                  	;mov	ax,AppendSetState	; set the state of Append
  3788 0000100E 8B1E[7E02]              	mov	bx,[Append_State] 	; back to the original state
  3789 00001012 CD2F                    	int	2Fh			;
  3790 00001014 C606[8002]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3791                                  Append_Fix_End: 			;
  3792                                  ;;	pop	ds			; get data segment back
  3793 00001019 C3                      	retn
  3794                                  
  3795                                  	; MSDOS 3.3
  3796                                  	;retn
  3797                                  
  3798                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3799                                  ;
  3800                                  ;	ENTRY	nothing
  3801                                  ;
  3802                                  ;	EXIT	nothing
  3803                                  ;
  3804                                  ;	USED	flags
  3805                                  ;
  3806                                  ;	EFFECTS
  3807                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3808                                  ;	  current program's stdin,stdout set to our stderr
  3809                                  ;
  3810                                  
  3811                                  ;SR;
  3812                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3813                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3814                                  
  3815                                  SavHand:
  3816                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3817                                  
  3818                                  	; 12/01/2023
  3819                                  	;push	ds ; MSDOS 3.3
  3820                                  
  3821 0000101A 53                      	push	bx			;preserve registers
  3822 0000101B 50                      	push	ax
  3823                                  	; 12/01/2023
  3824 0000101C 06                      	push	es
  3825 0000101D 1E                      	push	ds			; save DATARES value
  3826                                  
  3827 0000101E B451                    	mov	ah,51h
  3828                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3829 00001020 CD21                    	int	21h			; BX = user's header seg addr
  3830 00001022 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3831                                  	;lds	bx,[34h]	
  3832 00001024 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3833 00001028 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3834                                  	; 12/01/2023
  3835 0000102A 07                      	pop	es			; es = DATARES
  3836 0000102B 06                      	push	es			; save it back on stack
  3837 0000102C 26A3[0202]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3838                                  	;mov	[cs:HANDLE01],ax
  3839                                  
  3840                                  ;SR;
  3841                                  ; Use es to address Handle01 & our JFN_Table
  3842                                  
  3843                                  	; 12/01/2023
  3844                                  	;mov	al,[es:1Ah]
  3845 00001030 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3846                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3847 00001034 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3848 00001036 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3849                                  	; 12/01/2023
  3850 00001038 1F                      	pop	ds			; restore registers
  3851 00001039 07                      	pop	es
  3852 0000103A 58                      	pop	ax
  3853 0000103B 5B                      	pop	bx
  3854                                  	;pop	ds ; MSDOS 3.3
  3855 0000103C C3                      	retn
  3856                                  
  3857                                  	;assume	ds:DATARES
  3858                                  GetComDsk2:
  3859 0000103D E81F00                  	call	GetComDsk
  3860 00001040 E909FF                  	jmp	LodCom1			; memory already allocated
  3861                                  
  3862                                  RestHand:
  3863 00001043 1E                      	push	ds
  3864 00001044 53                      	push	bx			; restore stdin, stdout to user
  3865 00001045 50                      	push	ax
  3866                                  	; 12/01/2023
  3867 00001046 B451                    	mov	ah,51h
  3868                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3869 00001048 CD21                    	int	21h			; point to user's header
  3870 0000104A A1[0202]                	mov	ax,[Handle01]
  3871 0000104D 8EDB                    	mov	ds,bx
  3872                                  	;assume ds:NOTHING
  3873                                  	;lds	bx,[34h] 
  3874 0000104F C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3875 00001053 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3876 00001055 58                      	pop	ax
  3877 00001056 5B                      	pop	bx
  3878 00001057 1F                      	pop	ds
  3879 00001058 C3                      	retn
  3880                                  
  3881                                  	;assume ds:DATARES,ss:DATARES
  3882                                  Hopeless:
  3883 00001059 BA[D205]                	mov	dx,COMBAD
  3884 0000105C E9BEFD                  	jmp	FatalC
  3885                                  
  3886                                  GetComDsk:
  3887 0000105F A0[5002]                	mov	al,[ComDrv]
  3888 00001062 E84DFF                  	call	RemCheck
  3889 00001065 75F2                    	jnz	short Hopeless		; non-removable media
  3890                                  GetComDsk3:
  3891 00001067 81FA[D205]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3892 0000106B 7503                    	jne	short GetComDsk4
  3893                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3894                                  	; 12/01/2023
  3895                                  	;;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3896                                  	; 05/06/2023
  3897                                  	;mov	dx,COMBAD ; (MSDOS 6.22 COMMAND.COM - RESGROUP:11B6h)
  3898                                  	;invoke	RPrint			; say COMMAND is invalid
  3899 0000106D E82103                  	call	RPrint
  3900                                  	;call	RDISPMSG
  3901                                  
  3902                                  GetComDsk4:
  3903                                  
  3904                                  ;	Bugbug:	there's always a drive here? No need to check?
  3905                                  
  3906 00001070 803E[EB01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3907 00001075 7509                    	jne	short Users_Drive	; yes - use it
  3908 00001077 B419                    	mov	ah,19h
  3909                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3910 00001079 CD21                    	int	21h
  3911 0000107B 0441                    	add	al,"A"                  ; convert to ascii
  3912 0000107D A2[EB01]                	mov	[PutBackDrv],al		; put in message to print out
  3913                                  
  3914                                  Users_Drive:
  3915                                  	; 12/01/2023
  3916                                  	; MSDOS 6.0
  3917 00001080 BA[E805]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3918                                  	;mov	si,offset DATARES:PutBackSubst
  3919                                  	;invoke	RPrint
  3920 00001083 BE[E501]                	mov	si,PutBackSubst		; containing COMMAND
  3921 00001086 E80803                  	call	RPrint
  3922                                  	;mov	dx,offset DATARES:Prompt
  3923                                  	;invoke	RPrint
  3924 00001089 BA[0A06]                	mov	dx,PROMPT		; "Press any key"
  3925 0000108C E80203                  	call	RPrint
  3926                                  
  3927                                  	; MSDOS 3.3
  3928                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3929                                  	;call	RDISPMSG
  3930                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3931                                  	;mov	si,[COMSPEC_END]
  3932                                  	;mov	byte [si+1],'$'
  3933                                  	;call	RDISPMSG
  3934                                  	;mov	byte [si+1],0
  3935                                  	;mov	dx,PROMPT
  3936                                  	;call	RDISPMSG
  3937                                  
  3938                                  	;call	GetRawFlushedByte
  3939                                  	;retn
  3940                                  	; 12/01/2023
  3941                                  	;jmp	short GetRawFlushedByte
  3942                                  
  3943                                  ;***	GetRawFlushedByte - flush world and get raw input
  3944                                  
  3945                                  GetRawFlushedByte:
  3946                                  	; 12/01/2023
  3947 0000108F B8070C                  	mov	ax,0C07h
  3948                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3949 00001092 CD21                    	int	21h			; get char without testing or echo
  3950 00001094 B8000C                  	mov	ax,0C00h
  3951                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3952 00001097 CD21                    	int	21h
  3953                                  
  3954                                  ;	Bugbug:	get rid of this return and the following retz.
  3955                                  
  3956                                  LoadCom_retn:
  3957 00001099 C3                      	retn
  3958                                  
  3959                                  	; 21/04/2023
  3960                                  TryDoOpen:
  3961 0000109A E8C2FF                  	call	GetComDsk
  3962                                  	;jmp	short LoadCom
  3963                                  
  3964                                  ;***	LoadCom - load in transient
  3965                                  
  3966                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3967                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3968                                  
  3969                                  LoadCom:
  3970                                  	;assume	ds:DATARES
  3971                                  	
  3972 0000109D 45                      	inc	bp				; flag command read
  3973                                  
  3974 0000109E BA[0702]                	mov	dx,ComSpec
  3975 000010A1 B8003D                  	mov	ax,3D00h
  3976                                  	;mov	ax,OPEN<<8	; 3D00h
  3977 000010A4 CD21                    	int	21h				; open command.com
  3978 000010A6 730B                    	jnc	short ReadCom
  3979                                  	;cmp	ax,4
  3980 000010A8 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3981 000010AB 75ED                    	jnz	short TryDoOpen
  3982 000010AD BA[9406]                	mov	dx,NOHANDMES
  3983 000010B0 E96AFD                  	jmp	FatalC				; will never find a handle
  3984                                  
  3985                                  	; 21/04/2023
  3986                                  ;TryDoOpen:
  3987                                  	;call	GetComDsk
  3988                                  	;jmp	short LoadCom
  3989                                  
  3990                                  ReadCom:
  3991 000010B3 89C3                    	mov	bx,ax				; BX = handle
  3992                                  	;mov	dx,offset RESGROUP:TranStart
  3993                                  	; 05/06/2023
  3994                                  	;mov	dx,26E0h ; MSDOS 6.22 COMMAND.COM
  3995 000010B5 BA1026                  	mov	dx,TRANSTART
  3996 000010B8 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3997 000010BA B80042                  	mov	ax,4200h
  3998                                  	;mov	ax,LSEEK<<8	; 4200h
  3999 000010BD CD21                    	int	21h
  4000 000010BF 7210                    	jc	short WrongCom1
  4001                                  	; 12/01/2023
  4002                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  4003                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  4004                                  	; 05/06/2023
  4005                                  	;mov	cx,0AE95h		 ; MSDOS 6.22 COMMAND.COM
  4006 000010C1 B977A9                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  4007 000010C4 1E                      	push	ds
  4008 000010C5 8E1E[4B02]              	mov	ds,[TrnSeg]
  4009                                  	;assume	ds:NOTHING
  4010 000010C9 BA0001                  	mov	dx,100h
  4011 000010CC B43F                    	mov	ah,3Fh
  4012                                  	;mov	ah,READ	; 3Fh	
  4013 000010CE CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  4014                                  			; BX = file handle, CX = number of bytes to read
  4015                                  			; DS:DX -> buffer
  4016 000010D0 1F                      	pop	ds
  4017                                  	;assume	ds:DATARES
  4018                                  WrongCom1:
  4019 000010D1 9C                      	pushf
  4020 000010D2 50                      	push	ax
  4021 000010D3 B43E                    	mov	ah,3Eh
  4022                                  	;mov	ah,CLOSE ; 3Eh
  4023 000010D5 CD21                    	int	21h			; close command.com
  4024 000010D7 58                      	pop	ax
  4025 000010D8 9D                      	popf
  4026 000010D9 7204                    	jc	short WrongCom		; error on read
  4027 000010DB 39C8                    	cmp	ax,cx
  4028                                  	;retz				; size matched
  4029 000010DD 74BA                    	jz	short LoadCom_retn
  4030                                  WrongCom:
  4031 000010DF BA[D205]                	mov	dx,COMBAD
  4032 000010E2 E87AFF                  	call	GetComDsk
  4033 000010E5 EBB6                    	jmp	short LoadCom		; try again
  4034                                  
  4035                                  ;***	ChkSum - compute transient checksum
  4036                                  
  4037                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4038                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  4039                                  	
  4040                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4041                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1239h
  4042                                  ChkSum:
  4043 000010E7 1E                      	push	ds
  4044 000010E8 8E1E[4B02]              	mov	ds,[TrnSeg]
  4045 000010EC BE0001                  	mov	si,100h
  4046                                  	;;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  4047                                  	;;mov	cx,87C2h ; MSDOS 5.0
  4048                                  	; 05/06/2023
  4049                                  	;mov	cx,9D53h ; MSDOS 6.22
  4050 000010EF B9[3298]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  4051                                  Check_Sum:
  4052 000010F2 FC                      	cld
  4053 000010F3 D1E9                    	shr	cx,1
  4054 000010F5 31D2                    	xor	dx,dx
  4055                                  Chk:
  4056 000010F7 AD                      	lodsw
  4057 000010F8 01C2                    	add	dx,ax
  4058 000010FA 83D200                  	adc	dx,0
  4059 000010FD E2F8                    	loop	Chk
  4060                                  
  4061                                  	; 04/05/2023
  4062 000010FF 1F                      	pop	ds
  4063                                  
  4064                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4065 00001100 3B16[5302]              	cmp	dx,[Sum]
  4066                                  
  4067                                  	;pop	ds ; 04/05/2023
  4068 00001104 C3                      	retn
  4069                                  
  4070                                  ;***	SetVect - set interrupt vectors
  4071                                  
  4072                                  SetVect:
  4073                                  	;mov	dx,offset DATARES:LodCom_Trap 
  4074                                  	; 12/01/2023
  4075 00001105 BA[7E00]                	mov	dx,LodCom_Trap
  4076                                  	;mov	dx,LODCOM ; MSDOS 3.3
  4077 00001108 B82225                  	mov	ax,2522h
  4078                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  4079 0000110B 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  4080 0000110F 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  4081 00001113 CD21                    	int	21h
  4082                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  4083 00001115 BA[4A00]                	mov	dx,Ctrlc_Trap
  4084                                  	;mov	dx,CONTC ; MSDOS 3.3
  4085 00001118 FEC0                    	inc	al	; 23h
  4086 0000111A CD21                    	int	21h
  4087                                  	;mov	dx,offset DATARES:CritErr_Trap
  4088 0000111C BA[5500]                	mov	dx,CritErr_Trap
  4089                                  	;mov	dx,CRITERR ; MSDOS 3.3
  4090 0000111F FEC0                    	inc	al	; 24h
  4091 00001121 CD21                    	int	21h
  4092 00001123 C3                      	retn
  4093                                  
  4094                                  	; MSDOS 6.0
  4095                                  ;;SR;
  4096                                  ;We have this to take care of the extra values pushed on the stack by 
  4097                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  4098                                  ;Lodcom1
  4099                                  
  4100                                  ;public	TrnLodCom1
  4101                                  	; 12/01/2023
  4102                                  TrnLodCom1:
  4103 00001124 1F                      	pop	ds			; ds = DATARES
  4104 00001125 83C402                  	add	sp,2
  4105                                  ;	pop	ds:OldDS
  4106 00001128 E921FE                  	jmp	LodCom1
  4107                                  
  4108                                  ;=============================================================================
  4109                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  4110                                  ;=============================================================================
  4111                                  ; 22/09/2018 - Retro DOS v3.0
  4112                                  
  4113                                  ;	title	Localizable code for resident COMMAND
  4114                                  
  4115                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4116                                  
  4117                                  ; ----------------------------------------------------------------------------
  4118                                  ;***	AskEnd - ask user to confirm batch file termination
  4119                                  ;
  4120                                  ;	Confirm with user before freeing batch ...
  4121                                  ;
  4122                                  ;	ENTRY	nothing
  4123                                  ;
  4124                                  ;	EXIT	CY = set if batch termination is confirmed
  4125                                  ;
  4126                                  ;		CY = clear if batch should continue
  4127                                  ;
  4128                                  ;	USED	AX,DX,...
  4129                                  ;
  4130                                  ;	Bugbug:	move this to transient, copy to batch segment.
  4131                                  ;	Bugbug:	or move it to command1 1st.
  4132                                  ;
  4133                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  4134                                  ; ----------------------------------------------------------------------------
  4135                                  
  4136                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4137                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  4138                                  
  4139                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4140                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1279h (CODERES:0429h)
  4141                                  AskEnd:
  4142                                  	;assume	ds:DATARES
  4143                                  
  4144 0000112B BA[2C06]                	mov	dx,ENDBATMES			; DX = message #
  4145 0000112E E86002                  	call	RPrint
  4146                                  	;call	RDISPMSG  ; MSDOS 3.3
  4147 00001131 B8010C                  	mov	ax,0C01h
  4148                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  4149 00001134 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  4150                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  4151 00001136 E8F102                  	call	CharToUpper			; change to upper case
  4152 00001139 3A06[3305]              	cmp	al,[NO_CHAR]
  4153 0000113D 7407                    	je	short aeRet			; answer is no (CY is clear)
  4154 0000113F 3A06[3205]              	cmp	al,[YES_CHAR]
  4155 00001143 75E6                    	jne	short AskEnd			; invalid response, try again
  4156 00001145 F9                      	stc					; answer is yes
  4157                                  aeRet:	
  4158 00001146 C3                      	retn
  4159                                  
  4160                                  ; ----------------------------------------------------------------------------
  4161                                  ;***	DskErr - critical error handler
  4162                                  ;
  4163                                  ;	Default critical error handler unless user intercepts int 24h.
  4164                                  ;
  4165                                  ;	ENTRY	int 24h
  4166                                  ;
  4167                                  ;	EXIT
  4168                                  ;
  4169                                  ;	USED
  4170                                  ;
  4171                                  ;	EFFECTS
  4172                                  ; ----------------------------------------------------------------------------
  4173                                  
  4174                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4175                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4176                                  
  4177                                  ;SR; 
  4178                                  ;The stub is going to push the old ds value and the resident data segment
  4179                                  ;onto the stack in that order. Get it off the stack
  4180                                  
  4181                                  ;DskErr	proc	far
  4182                                  DSKERR:
  4183                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4184                                  	; 12/01/2023
  4185 00001147 1F                      	pop	ds			; ds = DATARES
  4186                                  	;assume ds:DATARES
  4187 00001148 8F06[F404]              	pop	word [OldDS]		; save old ds value
  4188                                  
  4189                                  ;CRITERR: ; MSDOS 3.3
  4190 0000114C FB                      	sti
  4191                                  	; 12/01/2023
  4192                                  	;push	ds ; 25/09/2018
  4193 0000114D 06                      	push	es
  4194 0000114E 56                      	push	si
  4195 0000114F 51                      	push	cx
  4196 00001150 57                      	push	di
  4197 00001151 51                      	push	cx
  4198 00001152 50                      	push	ax
  4199                                  
  4200 00001153 1E                      	push	ds			;save our data segment
  4201                                  	;push	cs ; 25/09/2018
  4202 00001154 07                      	pop	es			;es = DATARES
  4203                                  
  4204 00001155 8EDD                    	mov	ds,bp
  4205                                  	;assume	ds:nothing
  4206                                  
  4207                                  	;mov	ax,[si].SDEVATT
  4208 00001157 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4209 0000115A 268826[E101]            	mov	[es:CDevAt],ah
  4210                                  
  4211                                  	;push	cs
  4212                                  	;pop	es
  4213                                  
  4214 0000115F BF[BF01]                	mov	di,DevName
  4215 00001162 B90800                  	mov	cx,8
  4216                                  	;add	si,SDEVNAME  ; add si,10
  4217 00001165 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4218                                  				
  4219 00001168 FC                      	cld
  4220 00001169 F3A4                    	rep	movsb
  4221 0000116B 58                      	pop	ax
  4222 0000116C 59                      	pop	cx
  4223 0000116D 5F                      	pop	di
  4224                                  
  4225                                  ;	Stack still contains DS and ES.
  4226                                  
  4227                                  ;SR;
  4228                                  ;We need ds = DATARES for SavHand
  4229                                  
  4230                                  	 ;12/01/2023
  4231 0000116E 06                      	push	es
  4232 0000116F 1F                      	pop	ds
  4233                                  	;assume	ds:DATARES
  4234                                  
  4235                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4236 00001170 E8A7FE                  	call	SavHand
  4237                                  
  4238                                  	; 12/01/2023
  4239                                  	; 25/09/2018
  4240                                  	;;push	cs
  4241                                  	;push	es
  4242                                  	;pop	ds		; set up local data segment
  4243                                  	;assume	ds:resgroup
  4244                                  
  4245 00001173 52                      	push	dx
  4246 00001174 E81702                  	call	crlf
  4247 00001177 5A                      	pop	dx
  4248                                  
  4249                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4250                                  
  4251 00001178 8826[5802]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4252                                  
  4253                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4254                                  
  4255 0000117C 0441                    	add	al,'A'
  4256 0000117E A2[B801]                	mov	[DrvLet],al
  4257                                  
  4258                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4259                                  
  4260 00001181 F6C480                  	test	ah,80h
  4261 00001184 740A                    	jz	short NoHardE		; it's a disk-device error
  4262 00001186 F606[E101]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4263 0000118B 7503                    	jnz	short NoHardE		; it's a character device
  4264 0000118D E9F101                  	jmp	FatErr			; it's a FAT error
  4265                                  
  4266                                  NoHardE:
  4267 00001190 BE[5405]                	mov	si,MREAD		; SI = "read" msg #
  4268 00001193 F6C401                  	test	ah,1
  4269 00001196 7403                    	jz	short SavMes		; it's a read error
  4270 00001198 BE[5D05]                	mov	si,MWRITE		; SI = "write" msg #
  4271                                  SavMes:
  4272 0000119B 893E[1E04]              	mov	[OldErrNo],di		; save critical error code
  4273                                  
  4274                                  ;	Bugbug:	don't need to save/restore all here?
  4275                                  
  4276 0000119F 06                      	push	es
  4277 000011A0 1E                      	push	ds			; GetExtendedError likes to STOMP
  4278                                  	; 12/01/2023
  4279                                  	; (all registers are changed -in dos service- except bp) *
  4280                                  	;push	bp
  4281 000011A1 56                      	push	si
  4282 000011A2 52                      	push	dx
  4283 000011A3 51                      	push	cx
  4284 000011A4 53                      	push	bx
  4285                                  	; 05/06/2023
  4286 000011A5 B459                    	mov	ah,59h ; *
  4287                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4288 000011A7 CD21                    	int	21h
  4289 000011A9 5B                      	pop	bx
  4290 000011AA 59                      	pop	cx
  4291 000011AB 5A                      	pop	dx
  4292 000011AC 5E                      	pop	si
  4293                                  	; 12/01/2023
  4294                                  	;pop	bp
  4295 000011AD 1F                      	pop	ds
  4296 000011AE 893E[EF01]              	mov	[NeedVol],di		; save possible ptr to volume label
  4297 000011B2 8C06[F101]              	mov	[NeedVol+2],es
  4298 000011B6 07                      	pop	es
  4299                                  
  4300                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4301                                  
  4302 000011B7 30E4                    	xor	ah,ah
  4303 000011B9 89C7                    	mov	di,ax			; DI = error code
  4304                                  
  4305                                  ; Bugbug: somewhat obsolete documentation?
  4306                                  ;
  4307                                  ; DI is now the correct error code. Classify things to see what we are
  4308                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4309                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4310                                  ; the like) are contiguous.
  4311                                  
  4312                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4313                                  ;	Check use of ErrCd_24, though.
  4314                                  
  4315 000011BB 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4316 000011BE 7303                    	jae	short HavCod
  4317                                  
  4318                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4319                                  ;	even though it's not a critical error?
  4320                                  
  4321 000011C0 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4322                                  
  4323                                  ; DI now has the mapped error code. Old style errors are:
  4324                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4325                                  ; New style errors are:
  4326                                  ;   FOOBAR
  4327                                  ; We need to figure out which the particular error belongs to.
  4328                                  
  4329                                  HavCod:
  4330 000011C3 C606[F301]00            	mov	byte [ErrType],0	; assume old style
  4331 000011C8 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4332 000011CB 7405                    	je	short SetStyle
  4333 000011CD 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4334 000011D0 7504                    	jne	short GotStyle
  4335                                  
  4336                                  SetStyle:
  4337                                  ;	Bugbug:	use INC
  4338                                  	;mov	byte [ErrType],1		; must be new type
  4339 000011D2 FE06[F301]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4340                                  
  4341                                  GotStyle:
  4342 000011D6 893E[0002]              	mov	[ErrCd_24],di
  4343                                  	; 12/01/2023
  4344                                  	; 25/09/2018
  4345                                  	; MSDOS 6.0
  4346 000011DA 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4347                                  	; MSDOS 3.3
  4348                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4349                                  
  4350                                  						; If the error message is unknown
  4351 000011DD 7642                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4352                                  
  4353                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4354                                  ; how to handle things
  4355                                  
  4356                                  ;input to IFSFUNC:    AL=1
  4357                                  ;		      BX=extended error number
  4358                                  ;
  4359                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4360                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4361                                  ;			   Abort, Retry, Ignore
  4362                                  ;			 1=<message>
  4363                                  ;			   Abort, Retry, Ignore
  4364                                  ;		      ES:DI=pointer to message text
  4365                                  ;		      carry set=>no message
  4366                                  
  4367 000011DF 89C7                    	mov	di,ax			; retrieve correct extended error...
  4368 000011E1 B80005                  	mov	ax,0500h		; is the redir there?
  4369 000011E4 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4370                                  			; Return: AL = 00h not installed, OK to install
  4371                                  			; 01h not installed, can't install
  4372                                  			; FFh installed
  4373 000011E6 3CFF                    	cmp	al,0FFh
  4374 000011E8 752A                    	jne	short NoHandler		; no, go to NoHandler
  4375                                  
  4376                                  	; 12/01/2023
  4377                                  	; MSDOS 6.0
  4378 000011EA 53                      	push	bx
  4379 000011EB 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4380 000011ED B80105                  	mov	ax,0501h
  4381 000011F0 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4382 000011F2 5B                      	pop	bx 
  4383 000011F3 721F                    	jc	short NoHandler
  4384                                  	
  4385                                  	; MSDOS 3.3
  4386                                  	;mov     ax,di
  4387                                  	;mov     ah,5
  4388                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4389                                  	;jc      short NOHANDLER
  4390                                  
  4391                                  ;	Bugbug:	need to record error type?
  4392                                  
  4393 000011F5 A2[F301]                	mov	[ErrType],al
  4394                                  
  4395 000011F8 1E                      	push	ds
  4396 000011F9 06                      	push	es
  4397 000011FA 1F                      	pop	ds
  4398 000011FB 89FA                    	mov	dx,di
  4399 000011FD B9FFFF                  	mov	cx,-1			; find end of msg
  4400 00001200 30C0                    	xor	al,al
  4401                                  
  4402 00001202 FC                      	cld
  4403 00001203 F2AE                    	repnz	scasb
  4404                                  
  4405                                  ;	Bugbug:	we can do better than this.
  4406                                  
  4407 00001205 C645FF24                	mov	byte [di-1],'$'
  4408                                  	
  4409                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4410                                  	
  4411 00001209 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4412 0000120B CD21                    	int	21h
  4413                                  
  4414 0000120D C645FF00                	mov	byte [di-1],0			; restore terminal byte
  4415                                  
  4416 00001211 1F                      	pop	ds				; clean up and continue
  4417 00001212 EB15                    	jmp	short CheckErrType
  4418                                  
  4419                                  ;*	Redir isn't available or doesn't recognize the error.
  4420                                  ;	Restore regs to unextended error.
  4421                                  
  4422                                  NoHandler:
  4423 00001214 C606[F301]00            	mov	byte [ErrType],0
  4424                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4425 00001219 8B3E[1E04]              	mov	di,[OldErrNo]
  4426 0000121D 893E[0002]              	mov	[ErrCd_24],di
  4427                                  
  4428                                  NormalError:
  4429                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4430                                  	; MSDOS 6.0
  4431 00001221 83C713                  	add	di,ERROR_WRITE_PROTECT
  4432 00001224 87FA                    	xchg	di,dx			; may need dx later
  4433 00001226 E88101                  	call	RPrintCrit		; print error type
  4434                                  
  4435                                  	; MSDOS 3.3
  4436                                  	;shl     di,1
  4437                                  	;mov     di,[CRMSGTBL+di]
  4438                                  	;xchg    di,dx
  4439                                  	;call    RDISPMSG
  4440                                  
  4441                                  CheckErrType:
  4442 00001229 803E[F301]00            	cmp	byte [ErrType],0	; Check error style...
  4443 0000122E 7405                    	je	short ContOld
  4444 00001230 E85B01                  	call	crlf			; if new style then done printing
  4445 00001233 EB31                    	jmp	short Ask
  4446                                  
  4447                                  ContOld:
  4448                                  	; 12/01/2023
  4449                                  	; MSDOS 6.0
  4450 00001235 46                      	inc	si			; DS:SI = ptr to asciiz string
  4451                                  
  4452                                  ;	Bugbug:	combine some of the following two sections?
  4453                                  
  4454                                  	; 12/01/2023
  4455 00001236 F606[E101]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4456                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4457 0000123B 740F                    	jz	short BlkErr
  4458                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4459                                  	;mov	dx,ChardevErr
  4460 0000123D BA[7505]                	mov	dx,MDEVICE
  4461                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4462 00001240 8936[BA01]              	mov	[CharDevErrRw],si
  4463                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4464 00001244 BE[B901]                	mov	si,CharDevErrSubst
  4465                                  
  4466 00001247 E84701                  	call	RPrint				; print the message
  4467 0000124A EB1A                    	jmp	short Ask			; don't ralph on command
  4468                                  
  4469                                  	; 12/01/2023
  4470                                  	; MSDOS 3.3
  4471                                  	;mov	dx,ERRMES
  4472                                  	;call	RDISPMSG
  4473                                  	;mov	dx,si
  4474                                  	;call	RDISPMSG
  4475                                  	;
  4476                                  	;test	byte [CDevAt],80h
  4477                                  	;jz	short BLKERR
  4478                                  	;mov	dx,CHARDEVERR	; " device "
  4479                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4480                                  	;int	21h		; DOS - PRINT STRING
  4481                                  	;			; DS:DX -> string terminated by "$"
  4482                                  	;jmp	short ASK
  4483                                  
  4484                                  BlkErr:
  4485                                  	; 12/01/2023
  4486                                  	; MSDOS 6.0
  4487                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4488                                  	;mov	dx,BlkDevErr
  4489 0000124C BA[6605]                	mov	dx,MDRIVE
  4490                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4491 0000124F 8936[B301]              	mov	[BlkDevErrRw],si
  4492                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4493 00001253 BE[B201]                	mov	si,BlkDevErrSubst
  4494 00001256 E83801                  	call	RPrint
  4495                                  
  4496                                  	; MSDOS 3.3
  4497                                  	;mov	dx,BLKDEVERR
  4498                                  	;call	RDISPMSG
  4499                                  
  4500 00001259 803E[0402]00            	cmp	byte [Loading],0
  4501 0000125E 7406                    	jz	short Ask
  4502 00001260 E8E0FD                  	call	RestHand
  4503 00001263 E9D7FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4504                                  Ask:
  4505 00001266 833E[0002]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4506 0000126B 751E                    	jne	short Not15		; not error 15
  4507                                  
  4508                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4509                                  
  4510 0000126D 51                      	push	cx
  4511                                  
  4512                                  ;	Bugbug:	does this push/pop need to be done?
  4513                                  
  4514 0000126E 1E                      	push	ds
  4515 0000126F 07                      	pop	es
  4516 00001270 C536[EF01]              	lds	si,[NeedVol]
  4517                                  	;assume	ds:NOTHING
  4518 00001274 57                      	push	di
  4519 00001275 BF[D101]                	mov	di,VolName
  4520                                  	; 12/01/2023
  4521                                  	; MSDOS 6.0
  4522 00001278 B91000                  	mov	cx,16			; copy volume name & serial #
  4523                                  	; MSDOS 3.3
  4524                                  	;mov	cx,11			; copy volume name
  4525 0000127B FC                      	cld
  4526 0000127C F3A4                    	rep	movsb
  4527 0000127E 5F                      	pop	di
  4528 0000127F 06                      	push	es
  4529 00001280 1F                      	pop	ds
  4530 00001281 59                      	pop	cx
  4531                                  	;assume	ds:DATARES
  4532                                  	; 12/01/2023
  4533                                  	; MSDOS 6.0
  4534                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4535                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4536                                  	;mov	dx,NeedVolMsg
  4537 00001282 BA[8505]                	mov	dx,MVOLSERIAL
  4538 00001285 BE[C801]                	mov	si,NeedVolSubst
  4539 00001288 E80601                  	call	RPrint
  4540                                  
  4541                                  	; MSDOS 3.3
  4542                                  	;mov	dx,NEEDVOLMSG
  4543                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4544                                  	;int	21h		; DOS - PRINT STRING
  4545                                  	;			; DS:DX -> string terminated by "$"
  4546                                  Not15:
  4547                                  ;*	Print abort, retry, ignore, fail message.
  4548                                  ;	Print only options that are valid.
  4549                                  
  4550                                  ;	Bugbug:	sizzle this.
  4551                                  
  4552                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4553 0000128B BA[3405]                	mov	dx,REQ_ABORT
  4554 0000128E E80001                  	call	RPrint
  4555                                  	;call	RDISPMSG
  4556 00001291 F606[5802]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4557 00001296 7406                    	jz	short Try_Ignore
  4558 00001298 BA[3A05]                	mov	dx,REQ_RETRY
  4559 0000129B E8F300                  	call	RPrint
  4560                                  	;call	RDISPMSG
  4561                                  Try_Ignore:
  4562 0000129E F606[5802]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4563 000012A3 7406                    	jz	short Try_Fail
  4564 000012A5 BA[4205]                	mov	dx,REQ_IGNORE
  4565 000012A8 E8E600                  	call	RPrint
  4566                                  	;call	RDISPMSG
  4567                                  Try_Fail:
  4568 000012AB F606[5802]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4569 000012B0 7406                    	jz	short Term_Question
  4570 000012B2 BA[4B05]                	mov	dx,REQ_FAIL
  4571 000012B5 E8D900                  	call	RPrint
  4572                                  	;call	RDISPMSG
  4573                                  Term_Question:
  4574 000012B8 BA[5205]                	mov	dx,REQ_END
  4575 000012BB E8D300                  	call	RPrint
  4576                                  	;call	RDISPMSG
  4577                                  
  4578                                  ;	If the /f switch was given, we fail all requests.
  4579                                  
  4580 000012BE F606[6502]FF            	test	byte [fFail],-1
  4581 000012C3 741B                    	jz	short DoPrompt
  4582 000012C5 B403                    	mov	ah,3				; signal fail
  4583 000012C7 E9A800                  	jmp	EExit
  4584                                  
  4585                                  	; 16/04/2023
  4586                                  Abort_Process:
  4587 000012CA F606[D202]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4588 000012CF 745D                    	jz	short AbortCont			; no, handle it normally
  4589 000012D1 803E[5E02]00            	cmp	byte [PermCom],0		; are we top level process?
  4590 000012D6 744B                    	jz	short JustExit			; yes, just exit
  4591                                  
  4592 000012D8 BA[3807]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4593                                  	; 12/01/2023
  4594 000012DB E8B300                  	call	RPrint				; print it
  4595                                  	;call	RDISPMSG
  4596                                  DeadInTheWater:
  4597 000012DE EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4598                                  
  4599                                  DoPrompt:
  4600                                  	; 12/01/2023
  4601 000012E0 B8010C                  	mov	ax,0C01h
  4602                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4603 000012E3 CD21                    	int	21h				; get response
  4604                                  
  4605 000012E5 E8A600                  	call	crlf
  4606 000012E8 E83F01                  	call	CharToUpper			; convert to upper case
  4607 000012EB B400                    	mov	ah,0				; return code for ignore
  4608 000012ED F606[5802]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4609 000012F2 7406                    	jz	short User_Retry
  4610 000012F4 3A06[3005]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4611                                  	;jz	short EExitJ
  4612                                  	; 16/04/2023
  4613 000012F8 7478                    	jz	short EExit
  4614                                  
  4615                                  ;	Bugbug:	optimize following code.
  4616                                  
  4617                                  User_Retry:
  4618 000012FA FEC4                    	inc	ah				; return code for retry
  4619 000012FC F606[5802]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4620 00001301 7406                    	jz	short User_Abort
  4621 00001303 3A06[2F05]              	cmp	al,[RETRY_CHAR]			; retry?
  4622                                  	;jz	short EExitJ
  4623                                  	; 16/04/2023
  4624 00001307 7469                    	jz	short EExit
  4625                                  User_Abort:
  4626 00001309 FEC4                    	inc	ah				; return code for abort
  4627                                  						;  (abort always allowed)
  4628 0000130B 3A06[2E05]              	cmp	al,[ABORT_CHAR]			; abort?
  4629 0000130F 74B9                    	jz	short Abort_Process		; exit user program
  4630 00001311 FEC4                    	inc	ah				; return code for fail
  4631 00001313 F606[5802]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4632 00001318 7406                    	jz	short AskJ
  4633 0000131A 3A06[3105]              	cmp	al,[FAIL_CHAR]			; fail?
  4634                                  	;jz	short EExitJ
  4635                                  	; 16/04/2023
  4636 0000131E 7452                    	jz	short EExit
  4637                                  AskJ:
  4638 00001320 E943FF                  	jmp	Ask
  4639                                  
  4640                                  	; 12/01/2023
  4641                                  ;EExitJ:
  4642                                  	;jmp	short EExit
  4643                                  
  4644                                  JustExit:
  4645                                  	;assume	ds:DATARES
  4646                                  	; 12/01/2023
  4647 00001323 A1[FA01]                	mov	ax,[Parent]			; load real parent pid
  4648                                  	;mov	[16h],ax
  4649 00001326 A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4650 00001329 B8FF4C                  	mov	ax,4CFFh
  4651                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4652 0000132C CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4653                                  				; AL = exit code
  4654                                  AbortCont:
  4655 0000132E F606[4E02]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4656 00001333 7405                    	jz	short Not_Batch_Abort
  4657 00001335 C606[4F02]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4658                                  
  4659                                  Not_Batch_Abort:
  4660 0000133A 8A16[D302]              	mov	dl,[PipeFlag]
  4661 0000133E E8C8FA                  	call	ResPipeOff
  4662 00001341 08D2                    	or	dl,dl
  4663 00001343 740D                    	je	short CheckForA
  4664 00001345 833E[6102]00            	cmp	word [SingleCom],0
  4665 0000134A 7406                    	je	short CheckForA
  4666 0000134C C706[6102]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4667                                  
  4668                                  CheckForA:
  4669 00001352 833E[0002]00            	cmp	word [ErrCd_24],0		; write protect?
  4670 00001357 7407                    	je	short abortfor
  4671 00001359 833E[0002]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4672 0000135E 7512                    	jne	short EExit			; don't abort the FOR
  4673                                  
  4674                                  abortfor:
  4675 00001360 C606[6702]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4676 00001365 833E[6102]00            	cmp	word [SingleCom],0
  4677 0000136A 7406                    	je	short EExit
  4678 0000136C C706[6102]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4679                                  
  4680                                  EExit:
  4681 00001372 88E0                    	mov	al,ah
  4682 00001374 89FA                    	mov	dx,di
  4683                                  RestHd:
  4684 00001376 E8CAFC                  	call    RestHand
  4685 00001379 59                      	pop	cx
  4686 0000137A 5E                      	pop	si				; restore registers
  4687 0000137B 07                      	pop	es
  4688                                  
  4689                                  	; 12/01/2023	
  4690                                  	; MSDOS 6.0
  4691                                  ;;	pop	ds
  4692                                  ;SR;
  4693                                  ;ds has to be got from the variable we saved it in
  4694                                  
  4695 0000137C 8E1E[F404]               	mov	ds,[OldDS]			; restore old value of ds
  4696                                  
  4697                                  ;	pop	ds
  4698                                  ;	assume	ds:nothing
  4699                                  
  4700                                  	; MSDOS 3.3
  4701                                  	;pop	ds
  4702                                  
  4703 00001380 CF                      	iret
  4704                                  
  4705                                  FatErr:
  4706                                  	; 12/01/2023
  4707                                  	; MSDOS 6.0
  4708                                  	;mov	dx,offset DATARES:BadFatMsg
  4709                                  	;mov	si,offset DATARES:BadFatSubst
  4710 00001381 BA[AC05]                	mov	dx,BADFATMSG
  4711 00001384 BE[E201]                	mov	si,BadFatSubst
  4712 00001387 E80700                  	call	RPrint
  4713                                  
  4714                                  	; MSDOS 3.3
  4715                                  	;mov	dx,BADFATMSG
  4716                                  	;call	RDISPMSG
  4717                                  	;mov	dx,BLKDEVERR
  4718                                  	;call	RDISPMSG
  4719                                  
  4720 0000138A B002                    	mov	al,2				; abort
  4721 0000138C EBE8                    	jmp	short RestHd
  4722                                  
  4723                                  ;DskErr	endp
  4724                                  
  4725                                  	; MSDOS 6.0
  4726                                  ; ----------------------------------------------------------------------------
  4727                                  ;***	RPrint - print message
  4728                                  ;***	Crlf - display cr/lf
  4729                                  ;
  4730                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4731                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4732                                  ;		variable fields related to substitution blocks are set
  4733                                  ;
  4734                                  ;	EXIT	nothing
  4735                                  ;
  4736                                  ;	USED	flags
  4737                                  ;
  4738                                  ;	EFFECTS
  4739                                  ;	  Message is displayed on stdout.
  4740                                  ;
  4741                                  ;	NOTE
  4742                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4743                                  ;	  be greater than number of substition blocks present.
  4744                                  ; ----------------------------------------------------------------------------
  4745                                  
  4746                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4747                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4748                                  
  4749                                  crlf: 
  4750                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4751                                  	; 14/01/2023
  4752 0000138E BA[6707]                	mov	dx,NEWLINE
  4753                                  
  4754                                  ;RPrint	proc
  4755                                  ;
  4756                                  ;	assume	ds:DATARES,ss:DATARES
  4757                                  ;
  4758                                  	; 14/01/2023
  4759                                  RPrint:
  4760                                  
  4761                                  ;	Bugbug:	do we need to save all reg's?
  4762                                  
  4763 00001391 56                      	push	si			; preserve registers
  4764 00001392 50                      	push	ax
  4765 00001393 53                      	push	bx
  4766 00001394 51                      	push	cx
  4767 00001395 52                      	push	dx
  4768                                  
  4769 00001396 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4770 00001398 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4771 0000139A AC                      	lodsb				; AL = message length
  4772                                  					; DS:SI = ptr to message text
  4773 0000139B 31C9                    	xor	cx,cx
  4774 0000139D 88C1                    	mov	cl,al			; CX = message length
  4775 0000139F E303                    	jcxz	rpRet
  4776                                  
  4777 000013A1 E81900                  	call	RDispMsg
  4778                                  
  4779 000013A4 5A                      rpRet:	pop	dx
  4780 000013A5 59                      	pop	cx
  4781 000013A6 5B                      	pop	bx
  4782 000013A7 58                      	pop	ax
  4783 000013A8 5E                      	pop	si
  4784 000013A9 C3                      	retn
  4785                                  
  4786                                  ;RPrint	endp
  4787                                  
  4788                                  	; 14/01/2023
  4789                                  ;	; MSDOS 3.3
  4790                                  ;CRLF:
  4791                                  ;	mov     dx,NEWLIN
  4792                                  ;
  4793                                  ;RDISPMSG: ; Display message/text
  4794                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4795                                  ;	push    ax
  4796                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4797                                  ;	clc
  4798                                  ;	int     21h             ; DOS - PRINT STRING
  4799                                  ;				; DS:DX -> string terminated by "$"
  4800                                  ;	pop     ax
  4801                                  ;	retn
  4802                                  
  4803                                  
  4804                                  	; MSDOS 6.0
  4805                                  ; ----------------------------------------------------------------------------
  4806                                  ;***	RPrintCrit - print critical error message
  4807                                  ;
  4808                                  ;	ENTRY	DX = extended error # (19-39)
  4809                                  ;
  4810                                  ;	EXIT	nothing
  4811                                  ;
  4812                                  ;	USED	flags
  4813                                  ;
  4814                                  ;	EFFECTS
  4815                                  ;	  Message is displayed on stdout
  4816                                  ; ----------------------------------------------------------------------------
  4817                                  
  4818                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4819                                  
  4820                                  ;RPrintCrit	proc
  4821                                  ;	assume	ds:DATARES,ss:DATARES
  4822                                  
  4823                                  	; 14/01/2023
  4824                                  RPrintCrit:
  4825 000013AA 52                      	push	dx			; preserve DX
  4826 000013AB 87DA                    	xchg	bx,dx			; BX = extended error #
  4827                                  					; DX = saved BX
  4828 000013AD 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4829 000013B0 D1E3                    	shl	bx,1			; BX = offset in word table
  4830 000013B2 8B9F[0109]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4831 000013B6 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4832                                  					; BX = restored
  4833 000013B8 E8D6FF                  	call	RPrint			; print the message
  4834 000013BB 5A                      	pop	dx			; restore DX
  4835 000013BC C3                      	retn
  4836                                  
  4837                                  ;RPrintCrit	endp
  4838                                  
  4839                                  ; ----------------------------------------------------------------------------
  4840                                  ;***	RDispMsg - display message
  4841                                  ;
  4842                                  ;	Display message, with substitutions, for RPrint.
  4843                                  ;
  4844                                  ;	ENTRY	DS:SI = ptr to message text
  4845                                  ;		CX = message length
  4846                                  ;		DS:BX = ptr to substitution block, if any
  4847                                  ;
  4848                                  ;	EXIT	nothing
  4849                                  ;
  4850                                  ;	USED	AX,CX,DX,SI
  4851                                  ; ----------------------------------------------------------------------------
  4852                                  
  4853                                  ;RDispMsg	proc
  4854                                  ;	assume	ds:DATARES,ss:DATARES
  4855                                  
  4856                                  RDispMsg:
  4857                                  	; 14/01/2023
  4858                                  rdNextChar:
  4859 000013BD AC                      	lodsb				; AL = next char
  4860 000013BE 3C25                    	cmp	al,'%'
  4861 000013C0 7511                    	jne	short rdOutChar		; not a substitution
  4862 000013C2 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4863 000013C4 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4864 000013C7 80FA09                  	cmp	dl,9
  4865 000013CA 7307                    	jae	short rdOutChar		; not a substitution
  4866                                  
  4867                                  ;*	A substitution code %1 - %9 has been encountered.
  4868                                  ;	DL = 0-8, indicating %1-%9
  4869                                  ;	DS:BX = ptr to substitution block
  4870                                  
  4871 000013CC E80D00                  	call	SubstMsg		; display the substitution
  4872 000013CF 46                      	inc	si			; SI = ptr past %n
  4873 000013D0 49                      	dec	cx			; count extra character in %n
  4874 000013D1 EB06                    	jmp	short rdCharDone
  4875                                  
  4876                                  ;*	Normal character output.
  4877                                  
  4878                                  rdOutChar:
  4879 000013D3 88C2                    	mov	dl,al			; DL = char
  4880 000013D5 B402                    	mov	ah,2			; AH = DOS Character Output code
  4881 000013D7 CD21                    	int	21h			; call DOS
  4882                                  rdCharDone:
  4883 000013D9 E2E2                    	loop	rdNextChar
  4884 000013DB C3                      	retn
  4885                                  
  4886                                  ;RDispMsg	endp
  4887                                  
  4888                                  ; ----------------------------------------------------------------------------
  4889                                  ;***	SubstMsg - display message substitution
  4890                                  ;
  4891                                  ;	Display a substitution string within a message.
  4892                                  ;	Substitution can be a char, an ASCIIZ string, or
  4893                                  ;	a word to be displayed as hex digits.
  4894                                  ;
  4895                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4896                                  ;		DS:BX = ptr to substitution block
  4897                                  ;
  4898                                  ;	EXIT	nothing
  4899                                  ;
  4900                                  ;	USED	AX,DX
  4901                                  ; ----------------------------------------------------------------------------
  4902                                  
  4903                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4904                                  
  4905                                  ;SubstMsg	proc
  4906                                  ;	assume	ds:DATARES,ss:DATARES
  4907                                  	
  4908                                  	; 14/01/2023
  4909                                  SubstMsg:
  4910 000013DC 53                      	push	bx			; preserve BX
  4911 000013DD 51                      	push	cx			; preserve CX
  4912                                  
  4913                                  	;mov	al,size SUBST		; AL = size of substitution block
  4914 000013DE B003                    	mov	al,3
  4915 000013E0 F6E2                    	mul	dl			; AX = offset of desired subst block
  4916 000013E2 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4917                                  
  4918                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4919 000013E4 8A07                    	mov	al,[bx]
  4920                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4921 000013E6 8B5F01                  	mov	bx,[bx+1]
  4922                                  
  4923                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4924                                  
  4925 000013E9 FEC8                    	dec	al
  4926 000013EB 7428                    	jz	short smChar
  4927 000013ED FEC8                    	dec	al
  4928 000013EF 742C                    	jz	short smStr
  4929                                  
  4930                                  ;*	Hex number substitution.
  4931                                  
  4932                                  	;mov	ax,ds:[bx]		; AX = word value
  4933 000013F1 8B07                    	mov	ax,[bx]
  4934 000013F3 B90400                  	mov	cx,4			; CX = # digits to display
  4935                                  smDigit:
  4936 000013F6 D1C0                    	rol	ax,1
  4937 000013F8 D1C0                    	rol	ax,1
  4938 000013FA D1C0                    	rol	ax,1
  4939 000013FC D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4940                                  
  4941 000013FE 50                      	push	ax			; save other digits
  4942 000013FF 240F                    	and	al,0Fh			; AL = binary digit
  4943 00001401 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4944 00001403 3C39                    	cmp	al,'9'
  4945 00001405 7602                    	jbe	short smDigit09		; it's 0-9
  4946                                  	;add	al,7
  4947 00001407 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4948                                  smDigit09:
  4949 00001409 88C2                    	mov	dl,al			; DL = ascii digit
  4950 0000140B B402                    	mov	ah,2
  4951 0000140D CD21                    	int	21h			; output the ascii digit
  4952 0000140F 58                      	pop	ax			; restore all digits
  4953                                  
  4954 00001410 E2E4                    	loop	smDigit
  4955                                  	;jmp	short smRet
  4956                                  	; 14/01/2023
  4957                                  smRet:	
  4958 00001412 59                      	pop	cx
  4959 00001413 5B                      	pop	bx
  4960 00001414 C3                      	retn
  4961                                  
  4962                                  ;*	Char substitution.
  4963                                  
  4964                                  smChar:
  4965                                  	;mov	dl,ds:[bx]		; DL = char to output
  4966 00001415 8A17                    	mov	dl,[bx]
  4967 00001417 B402                    	mov	ah,2
  4968 00001419 CD21                    	int	21h
  4969 0000141B EBF5                    	jmp	short smRet
  4970                                  
  4971                                  ;*	String substitution.
  4972                                  
  4973                                  smStr:
  4974                                  	;mov	dl,ds:[bx]		; DL = next char
  4975 0000141D 8A17                    	mov	dl,[bx]
  4976 0000141F 08D2                    	or	dl,dl
  4977 00001421 74EF                    	jz	short smRet		; null char - we're done
  4978 00001423 B402                    	mov	ah,2
  4979 00001425 CD21                    	int	21h			; display char
  4980 00001427 43                      	inc	bx			; DS:BX = ptr to next char
  4981 00001428 EBF3                    	jmp	short smStr
  4982                                  
  4983                                  ;smRet:	pop	cx
  4984                                  ;	pop	bx
  4985                                  ;	retn
  4986                                  
  4987                                  ;SubstMsg	endp
  4988                                  
  4989                                  	; MSDOS 6.0
  4990                                  ; ----------------------------------------------------------------------------
  4991                                  ;***	CharToUpper - convert character to uppercase
  4992                                  ;
  4993                                  ;	ENTRY	AL = char
  4994                                  ;
  4995                                  ;	EXIT	AL = uppercase char
  4996                                  ;
  4997                                  ;	USED	AX
  4998                                  ; ----------------------------------------------------------------------------
  4999                                  
  5000                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5001                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  5002                                  
  5003                                  ;CharToUpper	proc
  5004                                  ;	assume	ds:DATARES
  5005                                  CharToUpper:
  5006 0000142A 50                      	push	ax		; put char on stack as arg to int 2F
  5007 0000142B B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  5008 0000142E CD2F                    	int	2Fh
  5009 00001430 44                      	inc	sp		; throw away old char on stack
  5010 00001431 44                      	inc	sp
  5011 00001432 C3                      	retn
  5012                                  
  5013                                  ;CharToUpper	endp
  5014                                  
  5015                                  	; 14/01/2023
  5016                                  ;	; MSDOS 3.3
  5017                                  ;CHARTOUPPER:
  5018                                  ;	cmp	al,80h
  5019                                  ;	jb	short CHARTOUPPER1
  5020                                  ;	sub	al,80h
  5021                                  ;	push	ds
  5022                                  ;	push	bx
  5023                                  ;	lds	bx,[UPPERCASETBL]
  5024                                  ;	add	bx,2
  5025                                  ;	xlat
  5026                                  ;	pop	bx
  5027                                  ;	pop	ds
  5028                                  ;	jmp	short CHARTOUPPER_RETN
  5029                                  ;CHARTOUPPER1:
  5030                                  ;	cmp	al,'a'
  5031                                  ;	jb	short CHARTOUPPER_RETN
  5032                                  ;	cmp	al,'z'
  5033                                  ;	ja	short CHARTOUPPER_RETN
  5034                                  ;	sub	al,20h
  5035                                  ;CHARTOUPPER_RETN:
  5036                                  ;	retn
  5037                                  
  5038                                  ;public	EndCode
  5039                                  ;EndCode label byte
  5040                                  
  5041                                  	; MSDOS 6.0
  5042                                  ; ----------------------------------------------------------------------------
  5043                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  5044                                  ;
  5045                                  ;	ENTRY	If we handle it -
  5046                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  5047                                  ;		  DL = operation =
  5048                                  ;		     0 = get extended error messages
  5049                                  ;		     1 = set extended error messages
  5050                                  ;		     2 = get parse error messages
  5051                                  ;		     3 = set parse error messages
  5052                                  ;		     4 = get critical error messages
  5053                                  ;		     5 = set critical error messages
  5054                                  ;		     6 = get file system error messages
  5055                                  ;		     7 = set file system error messages
  5056                                  ;		     8 = get disk retriever routine
  5057                                  ;		     9 = set disk retriever routine
  5058                                  ;		  ES:DI = address for 'set' operations
  5059                                  ;
  5060                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  5061                                  ;
  5062                                  ;	NOTE
  5063                                  ;	  This handler replaces the one that used to reside in DOS.
  5064                                  ;	  'Set' operations are ignored.
  5065                                  ;	  'File system error messages' are not supported.
  5066                                  ; ----------------------------------------------------------------------------
  5067                                  
  5068                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5069                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  5070                                  
  5071                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5072                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1588h (CODERES:0738h)
  5073                                  
  5074                                  ;SR;
  5075                                  ;At the int 2fh entry point we push the old ds value and the resident data
  5076                                  ;segment address. Get them off the stack
  5077                                  
  5078                                  ;MsgInt2fHandler proc	far
  5079                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5080                                  
  5081                                  	; 14/01/2023
  5082                                  MsgInt2fHandler:
  5083 00001433 1F                      	pop	ds			; ds = DATARES
  5084                                  	;assume	ds:DATARES
  5085                                  ;	pop	word [OldDS]		; save old value of ds
  5086                                  
  5087 00001434 3D2E12                  	cmp	ax,122Eh
  5088                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  5089                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  5090 00001437 742A                    	je	short miOurs		; it's ours
  5091                                  
  5092                                  ;ifndef ROMDOS
  5093                                  	;cmp	ax,5500h
  5094 00001439 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  5095                                  ;else
  5096                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  5097                                  ;endif	;ROMDOS
  5098 0000143C 741C                    	je	short fcOurs
  5099                                  
  5100                                  ;SR;
  5101                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  5102                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  5103                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  5104                                  ;current value of ds as it points at the data segment. So we do some kinky
  5105                                  ;stack manipulations.
  5106                                  
  5107 0000143E 50                      	push	ax
  5108 0000143F 50                      	push	ax			; create 2 words on stack for retf
  5109                                  
  5110 00001440 55                      	push	bp
  5111 00001441 50                      	push	ax
  5112                                  
  5113 00001442 89E5                    	mov	bp,sp			; bp can be used to address stack
  5114                                  
  5115                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  5116                                  ;do a 'pop ds' at the end to restore our ds
  5117                                  
  5118 00001444 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  5119 00001447 894604                  	mov	[bp+4],ax
  5120                                  	
  5121                                  	;mov	ax,word ptr ds:Int2fHandler+2
  5122 0000144A A1[7204]                	mov	ax,[Int2fHandler+2]
  5123 0000144D 894608                  	mov	[bp+8],ax		; put segment address
  5124                                  	;mov	ax,word ptr ds:Int2fHandler
  5125 00001450 A1[7004]                	mov	ax,[Int2fHandler]
  5126 00001453 894606                  	mov	[bp+6],ax		; put offset address
  5127                                  
  5128 00001456 58                      	pop	ax
  5129 00001457 5D                      	pop	bp
  5130 00001458 1F                      	pop	ds
  5131                                  
  5132 00001459 CB                      	retf				; chain on to next handler
  5133                                  
  5134                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  5135                                  
  5136                                  fcOurs:
  5137                                  
  5138                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  5139                                  
  5140 0000145A 58                      	pop	ax			; discard ds currently on stack
  5141 0000145B 1E                      	push	ds			; store our data segment
  5142                                  
  5143                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  5144 0000145C BE[0400]                	mov	si,Int2f_Entry
  5145                                  
  5146 0000145F 31C0                    	xor	ax,ax			; indicate COMMAND present
  5147 00001461 EB11                    	jmp	short miRet		; return to caller
  5148                                  
  5149                                  miOurs:
  5150 00001463 F6C201                  	test	dl,1
  5151 00001466 750C                    	jnz	short miRet		; ignore 'set' operations
  5152                                  
  5153 00001468 53                      	push	bx			; preserve BX
  5154 00001469 89D3                    	mov	bx,dx
  5155 0000146B 30FF                    	xor	bh,bh			; BX = index in word table
  5156 0000146D D1E3                    	shl	bx,1			; BX = index in dword table
  5157                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5158 0000146F C4BF[6A07]              	les	di,[bx+MsgPtrLists]
  5159 00001473 5B                      	pop	bx			; restore BX
  5160                                  miRet:
  5161                                  ;	mov	ds,[OldDS]		; restore ds
  5162 00001474 1F                      	pop	ds
  5163                                  	;assume	ds:nothing
  5164                                  
  5165 00001475 CF                      	iret
  5166                                  
  5167                                  ;MsgInt2fHandler endp
  5168                                  
  5169                                  	; MSDOS 6.0
  5170                                  ; ----------------------------------------------------------------------------
  5171                                  ;***	MsgRetriever - message retrieval routine for utilities
  5172                                  ;
  5173                                  ;	Address of this routine is passed to utility programs via 
  5174                                  ;	message services int 2f. We try to find the desired message
  5175                                  ;	in memory or in our disk image.
  5176                                  ;
  5177                                  ;	ENTRY	AX = message #
  5178                                  ;		DI = offset in RESGROUP of msg ptr list
  5179                                  ;		ComSpec = asciiz pathname to our disk image
  5180                                  ;
  5181                                  ;	EXIT	CY clear for success
  5182                                  ;		ES:DI = ptr to count byte, followed by message text
  5183                                  ;
  5184                                  ;		CY set for failure
  5185                                  ;		ES,DI undefined
  5186                                  ;
  5187                                  ;	USED	flags
  5188                                  ;
  5189                                  ;	NOTE
  5190                                  ;	  The message # in AX is used to compute an offset into
  5191                                  ;	  the message ptr list pointed to by DI. The lists must
  5192                                  ;	  start with message # 1 and proceed through consecutive
  5193                                  ;	  message #'s.  
  5194                                  ;
  5195                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5196                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5197                                  ;	  valid message #.  ;M033
  5198                                  ;
  5199                                  ;	  List positions with no corresponding message text are
  5200                                  ;	  indicated by null pointers, which this routine detects.
  5201                                  ; ----------------------------------------------------------------------------
  5202                                  
  5203                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5204                                  
  5205                                  ;SR; This routine will be called directly by the utilities. So, we have
  5206                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5207                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5208                                  
  5209                                  ;MsgRetriever	proc	far
  5210                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5211                                  
  5212                                  	; 14/01/2023
  5213                                  MsgRetriever:
  5214 00001476 1F                      	pop	ds			; ds = DATARES
  5215                                  	;assume	ds:DATARES
  5216                                  ;	pop	word [OldDS]		; save old ds
  5217                                  
  5218 00001477 50                      	push	ax			; preserve registers
  5219 00001478 53                      	push	bx
  5220 00001479 51                      	push	cx
  5221 0000147A 52                      	push	dx
  5222 0000147B 56                      	push	si
  5223                                  
  5224                                  ;;	push	ds
  5225                                  ;;	push	cs
  5226                                  ;;	pop	ds			; DS = DATARES seg addr
  5227                                  ;;	assume	ds:RESGROUP
  5228                                  ;;	push	cs
  5229                                  
  5230 0000147C 1E                      	push	ds			; get es from ds
  5231 0000147D 07                      	pop	es			; ES = DATARES seg addr
  5232                                  
  5233                                  ;	Begin modification M033.
  5234                                  
  5235                                  ;	Make sure msg # is valid.
  5236                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5237                                  
  5238                                  	;mov	bx,11
  5239 0000147E BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5240                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5241 00001481 81FF[090A]              	cmp	di,PARSMSGPTRS
  5242 00001485 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5243                                  	;mov	bx,90
  5244 00001487 BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5245                                  chkmsgnum:
  5246 0000148A 39C3                    	cmp	bx,ax
  5247 0000148C 725A                    	jc	short mrRet		; msg # too high, return carry
  5248                                  
  5249                                  ;	Msg # is valid.
  5250                                  
  5251                                  ;	End modification M033.
  5252                                  
  5253 0000148E 48                      	dec	ax
  5254 0000148F D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5255 00001491 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5256                                  
  5257 00001493 81FF[7404]              	cmp	di,ResMsgEnd
  5258 00001497 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5259                                  
  5260                                  ;*	Retrieve message from disk (or ROM) image.
  5261                                  ;	Read once to get the ptr to the message, then again for the message.
  5262                                  
  5263                                  ;ifndef	ROMDOS
  5264                                  	; 14/01/2023
  5265                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5266 00001499 BE[0702]                	mov	si,ComSpec
  5267 0000149C BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5268 0000149F BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5269 000014A2 B8006C                  	mov	ax,6C00h
  5270                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5271 000014A5 CD21                    	int	21h				; call DOS
  5272 000014A7 723F                    	jc	short mrRet			; return failure
  5273                                  
  5274 000014A9 89C3                    	mov	bx,ax				; BX = file handle
  5275 000014AB 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5276 000014AD 31F6                    	xor	si,si				; SI = read count
  5277                                  mrRead:
  5278 000014AF 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5279 000014B3 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5280 000014B5 B80042                  	mov	ax,4200h
  5281                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5282 000014B8 CD21                    	int	21h				; call DOS
  5283 000014BA 721A                    	jc	short mrCloseFile		; handle error
  5284                                  
  5285                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5286 000014BC BA[2004]                	mov	dx,MsgBuffer
  5287 000014BF B94000                  	mov	cx,64				; CX = # bytes to read
  5288 000014C2 B43F                    	mov	ah,3Fh
  5289                                  	;mov	ah,READ				; AH = 'Read File'
  5290 000014C4 CD21                    	int	21h				; call DOS
  5291 000014C6 720E                    	jc	short mrCloseFile		; handle error
  5292                                  
  5293 000014C8 09F6                    	or	si,si				; (CY cleared)
  5294 000014CA 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5295 000014CC 46                      	inc	si				; mark one read done
  5296 000014CD 8B16[2004]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5297 000014D1 09D2                    	or	dx,dx
  5298 000014D3 75DA                    	jnz	short mrRead			; go read the message
  5299 000014D5 F9                      	stc					; null ptr found- no msg
  5300                                  
  5301                                  mrCloseFile:
  5302 000014D6 9C                      	pushf				; save success/failure (CY)
  5303 000014D7 B43E                    	mov	ah,3Eh
  5304                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5305 000014D9 CD21                    	int	21h			; call DOS
  5306                                  ;	Bugbug: should we avoid this popf?
  5307 000014DB 9D                      	popf				; CY = success/failure
  5308 000014DC 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5309 000014DE EB08                    	jmp	short mrRet		; we're done
  5310                                  
  5311                                  ;else	;ROMDOS
  5312                                  ;
  5313                                  ;;	DI = ptr to msg ptr
  5314                                  ;
  5315                                  ;	mov	si,di			; SI = ptr to msg ptr
  5316                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5317                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5318                                  ;
  5319                                  ;;	ASSUME ES:NOTHING is still in effect.
  5320                                  ;
  5321                                  ;	push	ds
  5322                                  ;	pop	es				; ES = DATARES seg addr
  5323                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5324                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5325                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5326                                  ;	or	si,si
  5327                                  ;	jz	mrNoMsg			; null ptr- no message text
  5328                                  ;
  5329                                  ;	sub	si,100h			; SI = offset into image of msg
  5330                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5331                                  ;	mov	di,offset DATARES:MsgBuffer
  5332                                  ;	invoke	LoadFromROM
  5333                                  ;	clc					; success
  5334                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5335                                  ;	jmp	short mrRet
  5336                                  ;
  5337                                  ;mrNoMsg:
  5338                                  ;	stc
  5339                                  ;	jmp	short mrRet
  5340                                  ;
  5341                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5342                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5343                                  ;	assume	es:NOTHING
  5344                                  ;
  5345                                  ;endif	;ROMDOS
  5346                                  
  5347                                  ;*	Message ptr is in memory.
  5348                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5349                                  
  5350                                  mrInMem:
  5351                                  	; 14/01/2023
  5352 000014E0 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5353 000014E3 09FF                    	or	di,di			; (CY cleared)
  5354 000014E5 7501                    	jnz	short mrRet		; found message
  5355 000014E7 F9                      	stc				; null ptr found - no message
  5356                                  mrRet:	
  5357 000014E8 5E                      	pop	si			; restore all registers
  5358 000014E9 5A                      	pop	dx
  5359 000014EA 59                      	pop	cx
  5360 000014EB 5B                      	pop	bx
  5361 000014EC 58                      	pop	ax
  5362                                  
  5363                                  ;	mov	ds,[OldDS]		; restore ds
  5364 000014ED 1F                      	pop	ds
  5365                                  	;assume	ds:nothing
  5366                                  
  5367 000014EE CB                      	retf	; 21/04/2023
  5368                                  
  5369                                  ;MsgRetriever endp
  5370                                  
  5371                                  ; M003; Start of changes for UMB support
  5372                                  
  5373                                  ; ----------------------------------------------------------------------------
  5374                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5375                                  ;
  5376                                  ;	ENTRY	al = Saved alloc strat and link state
  5377                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5378                                  ;			b1 = 1 if link state to restore is Linked
  5379                                  ;
  5380                                  ;	EXIT	None
  5381                                  ;
  5382                                  ;	USED	ax, bx, cx
  5383                                  ; ----------------------------------------------------------------------------
  5384                                  
  5385                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5386                                  
  5387                                  ;public	Lh_OffUnlink
  5388                                  Lh_OffUnlink:	; proc	far
  5389                                  	; 14/01/2023
  5390 000014EF 88C5                    	mov	ch,al
  5391 000014F1 88C1                    	mov	cl,al
  5392                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5393                                  	;mov	ax,(ALLOCOPER<<8)
  5394 000014F3 B80058                  	mov	ax,5800h
  5395 000014F6 CD21                    	int	21h
  5396 000014F8 89C3                    	mov	bx,ax
  5397 000014FA D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5398 000014FC 80E180                  	and	cl,80h				; mask off b6-b0
  5399 000014FF 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5400 00001502 08CB                    	or	bl,cl				; set HighFirst bit state
  5401                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5402                                  	;mov	ax,(ALLOCOPER<<8)|1
  5403 00001504 B80158                  	mov	ax,5801h
  5404 00001507 CD21                    	int	21h				; set alloc strat
  5405                                  
  5406 00001509 88EB                    	mov	bl,ch
  5407 0000150B D0EB                    	shr	bl,1
  5408 0000150D 30FF                    	xor	bh,bh				; bx = linkstate
  5409                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5410                                  	;mov	ax,(ALLOCOPER<<8)|3
  5411 0000150F B80358                  	mov	ax,5803h
  5412 00001512 CD21                    	int	21h				; set linkstate
  5413                                  
  5414 00001514 CB                      	retf
  5415                                  
  5416                                  ;Lh_OffUnlink endp
  5417                                  
  5418                                  ; M003; End of changes for UMB support
  5419                                  ;public	EndCode
  5420                                  ; 14/01/2023
  5421                                  ;EndCode: ; label byte
  5422                                  ; 06/06/2023
  5423                                  ; 16/04/2023
  5424                                  EndCode equ ($-StartCode)+100h
  5425                                  ; 06/06/2023
  5426                                  ;EndCode equ $-StartCode
  5427                                  
  5428                                  ;CODERES ends
  5429                                  ;	end
  5430                                  
  5431                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5432                                  
  5433 00001515 00<rep Bh>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5434                                  
  5435                                  ;align 16
  5436                                  
  5437                                  ;=============================================================================
  5438                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5439                                  ;=============================================================================
  5440                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5441                                  
  5442                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5443                                  
  5444                                  ;TITLE   COMMAND Initialization
  5445                                  
  5446                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5447                                  ;ENVIRONSIZ2 EQU 092H
  5448                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5449                                  
  5450                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5451                                  ; 23/09/2018
  5452                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5453                                  ; 14/01/2023
  5454                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5455                                  
  5456                                  ; ----------------------------------------------------------------------------
  5457                                  
  5458                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5459                                  
  5460                                  ; 06/06/2023
  5461                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5462                                  ;ENVIRONSIZ equ 160
  5463                                  
  5464                                  ENVSML	equ 256	; minimum environment size
  5465                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5466                                  MAX_COMSPEC equ 146
  5467                                  ECOMSPEC equ 14
  5468                                  
  5469                                  ; 14/01/2023
  5470                                  TAB_CHAR equ 09h
  5471                                  SPACE_CHAR equ 20h	
  5472                                  
  5473                                  ; 06/06/2023
  5474                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5475                                  ENVIRONSIZ equ 180	; SIZE Environment 
  5476                                  
  5477                                  ;----------------------------------------------------
  5478                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5479                                  ;----------------------------------------------------
  5480                                  ;Environment Struc	; Default COMMAND environment
  5481                                  ;
  5482                                  ;Env_PathString  db	"path="
  5483                                  ;Env_PathSpec	 db	"c:\msdos"
  5484                                  ;                db	0
  5485                                  ;Env_PrmptString db	"prompt="
  5486                                  ;Env_PrmptSpec   db	"$p$g"
  5487                                  ;                db	0
  5488                                  ;Env_ComString   db	"comspec="
  5489                                  ;Env_ComSpec     db	"\command.com"
  5490                                  ;		 db	134 dup (0)
  5491                                  ;
  5492                                  ;Environment ends
  5493                                  ;----------------------------------------------------
  5494                                  
  5495                                  ;-----------------------------------------------------------------------------
  5496                                  
  5497                                  ;-----------------------------------------------------------------------------
  5498                                  ; START OF INIT PORTION
  5499                                  ; This code is deallocated after initialization.
  5500                                  ;-----------------------------------------------------------------------------
  5501                                  
  5502                                  ;INIT	SEGMENT PUBLIC PARA
  5503                                  
  5504                                  ; 	EXTRN   HEADER:BYTE
  5505                                  ;	EXTRN   BADCOMLKMES:BYTE
  5506                                  
  5507                                  ;	PUBLIC  CONPROC
  5508                                  
  5509                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5510                                  
  5511                                          ;ORG 0
  5512                                  ;ZERO = $
  5513                                  	; 23/09/2018
  5514                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5515                                  
  5516                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5517                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5518                                  
  5519                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5520                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1670h (CODERES:0820h)
  5521                                  ConProc:
  5522                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5523 00001520 BC[F404]                	mov	sp,RStack
  5524                                  
  5525                                  ; We need to set the PSP to us right at start because Carousel needs
  5526                                  ; to be lied to and it does not set PSP when it transfers control to
  5527                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5528                                  ; command.com is also not lied to.
  5529                                  
  5530                                  	; 14/01/2023
  5531                                  	; MSDOS 6.0
  5532 00001523 B450                            mov	ah,50h
  5533                                  	;mov	ah,SET_CURRENT_PDB
  5534 00001525 8CC3                            mov	bx,es
  5535 00001527 CD21                            int	21h
  5536                                  
  5537                                  	; 14/01/2023
  5538                                  	;mov	ah,30h 
  5539                                  	;;mov	ax,GET_VERSION<<8 ; 3000h
  5540                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5541 00001529 B80030                  	mov	ax,3000h
  5542 0000152C CD21                    	int	21h
  5543                                  	;;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5544                                  	;;cmp	ax,5
  5545                                  	;cmp	ax,EXPECTED_VERSION ; 0005h
  5546                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5547 0000152E 3D0616                  	cmp	ax,EXPECTED_VERSION ; 1606h
  5548 00001531 7411                    	je	short okdos			; DOS version is ok
  5549                                  
  5550 00001533 BA[4520]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5551 00001536 E858FE                  	call	RPrint
  5552                                  
  5553                                  	; MSDOS 3.3
  5554                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5555                                  	;int	21h             ; DOS - PRINT STRING
  5556                                  				; DS:DX -> string terminated by "$"
  5557 00001539 8CC0                    	mov	ax,es
  5558 0000153B 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5559                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5560                                  Here:	
  5561 00001540 74FE                    	jz	short Here			;  loop forever
  5562                                  	
  5563 00001542 CD20                    	int	20h				; otherwise, exit
  5564                                  okdos:
  5565                                  	; 23/09/2018
  5566                                  
  5567                                  ;  Calculate and save the end of the INIT segment (which is also
  5568                                  ;  the beginning of TRANGROUP).
  5569                                  
  5570                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5571                                  	; MSDOS 3.3
  5572                                  	;mov	ah,65h
  5573                                  	;mov	al,2
  5574                                  	;mov	dx,-1
  5575                                  	;mov	bx,-1
  5576                                  	;mov	cx,5
  5577                                  	;mov	di,UCASE_ADDR
  5578                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5579                                  	;		; AL = 02h : Get pointer to character translation table
  5580                                  	;		; BX = code page (-1 = current global code page)
  5581                                  	;		; DX = country ID (-1 = current country)
  5582                                  	;		; CX = amount of data to return
  5583                                  	;; ES:DI = pointer to output buffer
  5584                                  	;; Buffer offset :
  5585                                  	;;	00h -  byte,  country Id
  5586                                  	;;  	01h -  dword, pointer to uppercase table	
  5587                                  
  5588                                  	; 14/01/2023
  5589                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5590                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5591                                  	; 06/06/2023
  5592                                  	;mov	dx,26EFh     ; MSDOS 6.22 COMMAND.COM       	
  5593 00001544 BA1F26                  	mov	dx,TRANSTART+15			; get end of init code
  5594                                  	; 27/09/2018
  5595                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5596 00001547 B104                    	mov	cl,4				; change to paragraphs
  5597 00001549 D3EA                            shr	dx,cl				;
  5598 0000154B 8CC8                            mov     ax,cs                           ; get current segment
  5599 0000154D 01D0                            add     ax,dx                           ; calculate segment of end of init
  5600 0000154F A3[8C1F]                        mov     [initend],ax			; save this
  5601                                  
  5602                                  	; 14/01/2023
  5603                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5604                                  
  5605                                  ;  Check for /? on the command line. If found, display help text and exit.
  5606                                  ;  NOTE: this routine may terminate the program, never returning.
  5607                                  
  5608 00001552 E8F406                  	call	CheckHelp
  5609                                  
  5610                                  ; We have to patch the segment values for the various interrupt entry points.
  5611                                  ; This is because we need to have the default addresses of the handlers in our
  5612                                  ; stub before the relocation is done. These values will then be changed once
  5613                                  ; the resident is relocated
  5614                                  
  5615 00001555 E86409                  	call	patch_segs
  5616                                  
  5617                                  ;  Turn APPEND off during initialization processing
  5618                                  
  5619                                  	; 14/01/2023
  5620 00001558 B800B7                  	mov     ax,0B700h
  5621                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5622 0000155B CD2F                    	int	2Fh				;
  5623                                  	;cmp	al,0				; append installed?
  5624 0000155D 08C0                    	or	al,al
  5625 0000155F 7418                    	jz	short set_msg_addr		; no - continue
  5626                                  	
  5627 00001561 B802B7                  	mov	ax,0B702h
  5628                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5629 00001564 CD2F                    	int	2Fh				;
  5630                                  	;cmp	ax,-1				; append version correct?
  5631                                  	;jne	short set_msg_addr		; no - continue
  5632 00001566 40                      	inc	ax ; -1 -> 0
  5633 00001567 7510                    	jnz	short set_msg_addr        
  5634                                  	
  5635 00001569 B806B7                  	mov     ax,0B706h
  5636                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5637 0000156C CD2F                    	int	2Fh				;
  5638 0000156E 891E[7E02]                      mov     [Append_State],bx		; save append state
  5639                                         
  5640 00001572 31DB                    	xor	bx,bx                           ; clear out state
  5641 00001574 B807B7                  	mov	ax,0B707h
  5642                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5643 00001577 CD2F                    	int	2Fh				; set everything off
  5644                                  
  5645                                  set_msg_addr:
  5646                                  	; 14/01/2023
  5647                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5648                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5649                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5650                                  	; 06/06/2023
  5651                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:16CBh) 
  5652                                  	;mov	di,0A41h  ; mov di,PAERRMSG0 ; MSDOS 6.22 COMMAND.COM
  5653 00001579 BF[2B09]                	mov	di,DataresEnd
  5654 0000157C 893E[7404]              	mov	[ResMsgEnd],di			; save it
  5655                                  
  5656 00001580 E84B09                          call    get_XMMAddr                     ; get XMM call address
  5657                                  
  5658                                  ; Check if this is the first instance of command.com. If not, we just exit
  5659                                  ; this routine without moving any code.
  5660                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5661                                  ; stub. We just have to copy this over
  5662                                  	
  5663                                  ;ifndef ROMDOS
  5664 00001583 B80055                  	mov	ax,5500h
  5665                                  	;mov	ax,GET_COMMAND_STATE	
  5666                                  ;else
  5667                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5668                                  ;endif ; ROMDOS
  5669                                  
  5670 00001586 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5671                                  	;assume	ds:nothing
  5672                                  
  5673                                  	; 03/05/2023
  5674                                  	; Return:
  5675                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5676                                  	;   DS:SI -> entry point table
  5677                                  
  5678                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5679                                  
  5680 00001588 09C0                    	or	ax,ax
  5681 0000158A 750C                    	jnz	short first_com			; this is the first instance
  5682                                  
  5683                                  	; 14/01/2023
  5684 0000158C 268936[C924]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5685 00001591 268C1E[CB24]            	mov	[es:ResJmpTable+2],ds
  5686 00001596 EB06                    	jmp	short init_cntry
  5687                                  
  5688                                  first_com:
  5689 00001598 26C606[CD24]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5690                                  
  5691                                  init_cntry:
  5692                                  	; 14/01/2023
  5693 0000159E 06                      	push	es
  5694 0000159F 1F                      	pop	ds
  5695                                  	;assume	ds:RESGROUP
  5696                                  
  5697 000015A0 B465                    	mov	ah,65h
  5698                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5699 000015A2 B004                    	mov	al,4				; get file ucase table
  5700 000015A4 BAFFFF                  	mov	dx,-1				;
  5701                                  	;mov	bx,-1				;
  5702 000015A7 89D3                    	mov	bx,dx
  5703 000015A9 B90500                  	mov	cx,5				; number of bytes we want
  5704                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5705 000015AC BF[7102]                	mov	di,FUCase_Addr
  5706 000015AF CD21                    	int	21h
  5707                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5708                                  		; AL = function -
  5709                                  
  5710                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5711                                  
  5712 000015B1 1E                      	push	ds				;
  5713 000015B2 B80063                  	mov	ax,6300h
  5714                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5715 000015B5 CD21                    	int	21h				;
  5716                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5717                                  			
  5718 000015B7 8CDB                    	mov	bx,ds				; get segment to bx
  5719 000015B9 1F                      	pop	ds				;
  5720 000015BA 8936[7A02]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5721 000015BE 891E[7C02]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5722                                  
  5723                                  	;mov	ax,[16h]
  5724 000015C2 A11600                  	mov	ax,[PDB.PARENT_PID]
  5725                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5726 000015C5 A3[FA01]                	mov	[Parent],ax			;  correctly.
  5727 000015C8 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5728 000015CB A3[FC01]                	mov	[OldTerm],ax
  5729 000015CE A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5730 000015D1 A3[FE01]                	mov	[OldTerm+2],ax
  5731                                  
  5732                                  	; 14/01/2023
  5733                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5734                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5735                                  	; 06/06/2023
  5736                                  	;mov	ax,1679h	; MSDOS 6.22 COMMAND.COM
  5737                                  	;mov	ax,EndCode+15
  5738                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5739                                  	; 14/01/2023
  5740                                  	;mov	cl,4				; ax = size of resident part of
  5741                                  	;shr	ax,cl				;  command in paragraphs. Add
  5742                                  	;mov	cx,cs				;  this to CS and you get the
  5743                                  	;add	ax,cx				;  segment of the TPA.
  5744                                  
  5745 000015D4 8CC8                    	mov	ax,cs
  5746 000015D6 056201                  	add	ax,(EndCode+15)>>4
  5747                                  	
  5748 000015D9 A3[1A04]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5749 000015DC 2500F0                  	and     ax,0F000h
  5750 000015DF 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5751 000015E2 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5752 000015E4 A1[1A04]                	mov     ax,[Res_Tpa]
  5753                                  TpaSet:
  5754 000015E7 A3[0C04]                	mov	[LTpa],ax			; Good enough for the moment
  5755                                  	;mov	ax,[2]
  5756 000015EA A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5757                                  
  5758 000015ED 8C1E[1204]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5759 000015F1 8C1E[1604]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5760 000015F5 8C1E[0A04]              	mov	[MySeg],ds			;  use to call resident routines.
  5761                                  	; 19/04/2023
  5762                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5763 000015F9 8C1E[7C07]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5764                                  
  5765 000015FD A3[5102]                	mov	[MemSiz],ax			; Needed for execing other programs
  5766                                  
  5767                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5768                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5769                                  
  5770                                  ; First reallocate the COMMAND size to its memory image
  5771                                  	
  5772 00001600 50                      	push	ax    
  5773                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5774                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5775                                  	;mov	bx,TRANSTART
  5776                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5777                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5778                                  	;add	bx,15 ; *			; round up the size
  5779                                  	; 06/06/2023
  5780                                  	;mov	bx,26E0h  ; MSDOS 6.22 COMMAND.COM ; mov bx,offset RESGROUP:TranStart
  5781                                  	;add	bx,0AF95h ; MSDOS 6.22 COMMAND.COM ; add bx,offset TRANGROUP:TranSpaceEnd
  5782                                  	;add	bx,15 ; *			; round up the size
  5783                                  
  5784                                  	; 03/05/2023
  5785                                  	;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5786                                  	;add	bx,TRANSPACEEND
  5787                                  	; 06/06/2023
  5788                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5789                                          ;mov	cl,4				;
  5790                                          ;shr	bx,cl				; size of command.com
  5791 00001601 BB090D                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4	
  5792                                  
  5793 00001604 B44A                    	mov	ah,4Ah
  5794                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5795 00001606 CD21                            int     21h				;
  5796 00001608 58                              pop     ax				;
  5797                                  	
  5798                                  ; Compute maximum size of environment
  5799                                  
  5800                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5801                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5802                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5803                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5804                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5805 00001609 C706[801F]5300          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5806                                  					; 12+(((1B53h-1670h)+15)/16)-1 = 90	
  5807                                  ;
  5808                                  ; Compute minimum size of environment
  5809                                  ;
  5810                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5811                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5812 0000160F C706[7E1F]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5813                                  
  5814                                  	;;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5815                                  	;;mov	dx,98D4h	; MSDOS 5.0 COMMAND.COM
  5816                                  	; 06/06/2023
  5817                                  	;;mov	dx,0AFA4h	; MSDOS 6.22 COMMAND.COM
  5818                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5819                                  	;mov	cl,4				;  in paragraphs.
  5820                                  	;shr	dx,cl
  5821 00001615 BAA80A                  	mov	dx,(TRANSPACEEND+15)>>4
  5822                                  
  5823 00001618 8916[8E1F]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5824                                  
  5825 0000161C 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5826 0000161E A3[4B02]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5827                                  	;mov	ax,[2Ch]
  5828 00001621 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5829                                  
  5830                                  	; 14/01/2023
  5831                                          ; MSDOS 6.0
  5832                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5833 00001624 A3[FA03]                	mov	[EnvirSeg],ax
  5834                                          
  5835                                  	; 21/01/2023
  5836 00001627 09C0                    	or	ax,ax				; if there is no environment segment,
  5837 00001629 7407                    	jz	short buildenv			; make one
  5838                                    
  5839                                  	; 21/01/2023
  5840                                  	; MSDOS 3.3 & MSDOS 5.0
  5841                                  	;;inc	byte [CHUCKENV]
  5842                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5843                                  	;inc	byte [AllocedEnv]		; Flag - old environment segment
  5844                                  	
  5845                                  	; MSDOS 3.3 & MSDOS 5.0
  5846                                  	; 06/06/2023
  5847                                  	;jmp	short environpassed
  5848                                  	
  5849                                  	; MSDOS 6.0
  5850                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM	
  5851 0000162B 803E[CD24]00            	cmp	byte [FirstCom],0		; if this is the first command.com,
  5852 00001630 7403                    	je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5853                                  
  5854                                  	; MSDOS 6.0
  5855                                  
  5856                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5857                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5858                                  ; size and free this buffer. We need this buffer because we no longer have an
  5859                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5860                                  ; given on the command line before we know the environment size. This routine
  5861                                  ; will not return in case of an allocation error. It will either exit or hang
  5862                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5863                                  
  5864                                  	; 14/01/2023
  5865                                  buildenv:
  5866 00001632 E80207                  	call	alloc_env                       ; try to allocate buffer
  5867                                  environpassed:
  5868                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5869                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5870                                  	;mov	[EnvirSeg],ax
  5871                                  	;
  5872 00001635 8EC0                    	mov	es,ax                           ; and it load into es.
  5873                                  	;assume	es:nothing
  5874                                  
  5875                                  gottheenvir:
  5876                                  
  5877                                  ; Initialize the command drive
  5878                                  
  5879                                  	; 14/01/2023
  5880                                  	; MSDOS 3.3 & MSDOS 6.0
  5881 00001637 B419                    	mov	ah,19h
  5882                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5883 00001639 CD21                    	int	21h
  5884 0000163B FEC0                    	inc	al
  5885 0000163D A2[5002]                	mov	[ComDrv],al
  5886                                  
  5887                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5888 00001640 A05C00                          mov	al,[FCB]
  5889 00001643 08C0                    	or	al,al
  5890 00001645 7436                    	jz	short nocomdrv		; no drive specified
  5891                                  
  5892 00001647 B43A                    	mov	ah,':'
  5893 00001649 A2[5002]                	mov	[ComDrv],al
  5894 0000164C 0440                    	add	al,40h			; convert number to uppercase character
  5895                                  
  5896 0000164E FD                      	std
  5897                                  
  5898                                  	; MSDOS 6.0
  5899                                  	; 06/06/2023
  5900                                  	; MSDOS 6.22 - COMMAND.COM - RESGROUP:17B7h
  5901 0000164F 803E[441F]00            	cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5902 00001654 7420                    	je	short notwidenv		;  move the default comspec string in it
  5903                                  	; 14/01/2023
  5904                                  	; MSDOS 5.0 COMMAND.COM
  5905 00001656 8B3E[671F]              	mov	di,[ComspOffset]
  5906 0000165A 26807D013A                      cmp	byte [es:di+1],':'	; drive specifier already exist?
  5907 0000165F 7415                            je	short notwidenv		; yes, must have been inherited that way
  5908                                  
  5909                                  	; 06/06/2023
  5910                                  	; MSDOS 3.3
  5911                                  	;;cmp	byte [CHUCKENV],0
  5912                                  	;;jne	short NOTWIDENV
  5913                                  	; 21/01/2021
  5914                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5915                                   	;cmp	byte [AllocedEnv],0
  5916                                  	;ja	short notwidenv
  5917                                  
  5918 00001661 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5919 00001662 06                      	push	es			;  the drivespec is in ax and is copied
  5920 00001663 1F                      	pop	ds			;  on to the front of the string.
  5921                                  
  5922                                  ; 06/06/2023
  5923                                  %if 0
  5924                                  	; 21/01/2023
  5925                                  	; 14/01/2023
  5926                                  	; MSDOS 5.0 COMMAND.COM
  5927                                  	; MSDOS 3.3
  5928                                  	; 23/09/2018
  5929                                  	; 30/04/2018
  5930                                  	;mov	di,159
  5931                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5932                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5933                                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5934                                  	;mov	si,157
  5935                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5936                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5937                                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5938                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5939                                  	mov	cx,MAX_COMSPEC-2 ; 144
  5940                                  %endif
  5941                                  
  5942                                  	; MSDOS 6.0
  5943                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM - RESGROUP:17CCh
  5944 00001664 8DB58F00                        lea	si,[di+MAX_COMSPEC-3]	; lea si,[di+143]
  5945 00001668 8DBD9100                        lea	di,[di+MAX_COMSPEC-1]	; lea di,[di+145]
  5946                                  
  5947 0000166C B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5948                                  
  5949 0000166F F3A4                    	rep	movsb
  5950 00001671 1F                      	pop	ds
  5951                                  
  5952                                  	; MSDOS 6.0
  5953                                  	; 06/06/2023
  5954 00001672 268945FF                	mov	[es:di-1],ax
  5955                                  
  5956                                  	; MSDOS 3.3
  5957                                  	;mov	[es:0Eh],ax
  5958                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5959                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5960                                  	; 14/01/2023
  5961                                  	; 06/06/2023
  5962                                  	;mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5963                                  
  5964                                  	; MSDOS 3.3 & MSDOS 6.0
  5965                                  notwidenv:
  5966 00001676 FC                      	cld
  5967 00001677 A3[141F]                	mov	[AUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  5968                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5969                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5970                                  	; 06/06/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5971 0000167A A3[251F]                	mov	[KAUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  5972                                  nocomdrv:
  5973 0000167D E885FA                  	call	SetVect        ; Set the vectors
  5974                                  
  5975                                  ; parsing starts here
  5976                                  
  5977                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5978                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16C9h - CODERES:0989h)
  5979                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5980                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:17E8h - CODERES:0998h)
  5981                                  	; MSDOS 6.0
  5982 00001680 0E                      	push	cs
  5983 00001681 0E                      	push	cs
  5984 00001682 1F                      	pop	ds
  5985 00001683 07                      	pop	es
  5986                                  	;assume ds:ResGroup,es:ResGroup
  5987                                  
  5988 00001684 BE8000                  	mov	si,80h				; get command line
  5989 00001687 AC                      	lodsb					; get length of line
  5990 00001688 89F7                    	mov	di,si				; get line position in di
  5991 0000168A 30E4                    	xor	ah,ah				; ax = length of command line
  5992                                  
  5993                                  ; insure that the command line correctly ends with a cr
  5994                                  
  5995 0000168C 01C7                    	add	di,ax				; go to end of command line
  5996 0000168E C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5997 00001691 31C9                    	xor	cx,cx				; clear cx
  5998 00001693 890E[4120]                      mov	[num_positionals],cx		; initialize positionals
  5999                                  
  6000                                  ; Scan the command line looking for the parameters
  6001                                  
  6002                                  Parse_command_line:
  6003                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  6004 00001697 BF[971F]                	mov	di,PARSE_COMMAND
  6005 0000169A 8B0E[4120]              	mov	cx,[num_positionals]		; Get number of positionals
  6006 0000169E 31D2                    	xor	dx,dx				; clear dx
  6007 000016A0 8936[4320]                      mov	[old_parse_ptr],si		; save position before calling parser
  6008                                  	;call	dword ptr Init_Parse
  6009 000016A4 FF1E[8A1F]              	call	far [Init_Parse]		; call parser
  6010 000016A8 890E[4120]                      mov     [num_positionals],cx		; Save number of positionals
  6011                                  	; 29/01/2023
  6012                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  6013                                          ;cmp	ax,-1
  6014                                  	;jne	short t1
  6015                                  	; 10/06/2023
  6016 000016AC 40                      	inc	ax	 ; cmp ax,-1
  6017 000016AD 7503                    	jnz	short t1 ; 0FFFFh -> 0
  6018                                  	; ax = 0
  6019 000016AF E93202                  	jmp     ArgsDone                        ; yes - exit
  6020                                  t1:	
  6021                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  6022                                  	;;cmp	ax,0
  6023                                  	;and	ax,ax
  6024                                  	; 10/06/2023
  6025 000016B2 48                      	dec	ax  ; cmp ax,0
  6026 000016B3 7450                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  6027                                  
  6028                                  ; Before issuing error message - make sure switch is not /C
  6029                                  
  6030                                  parse_line_error:
  6031                                  	; 14/01/2023
  6032                                  	;push	si				; save line position
  6033                                  	;push	ax				; save error number
  6034                                  	;cmp	ax,3
  6035 000016B5 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  6036                                          ;jnz	short parse_line_error_disp	; No - just issue message
  6037 000016B8 7533                    	jne	short parse_line_error_disp2
  6038 000016BA 56                      	push	si ; **				; save line position
  6039 000016BB 50                      	push	ax ; *				; save error number
  6040 000016BC 89F7                    	mov	di,si				; Get terminating pointer in DI
  6041 000016BE 8B36[4320]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  6042                                  
  6043                                  init_chk_delim:
  6044 000016C2 39FE                    	cmp	si,di				; at end of parsed parameter?
  6045 000016C4 7425                            je	short parse_line_error_disp	; Yes - just display message
  6046 000016C6 AC                      	lodsb					;
  6047 000016C7 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  6048                                  	;cmp	al,space_chr ; 14/01/2023
  6049                                  	;;cmp	al,[space]			; Skip blank spaces
  6050 000016C9 74F7                    	je	short init_chk_delim		;
  6051                                  	;cmp	al,9
  6052 000016CB 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  6053 000016CD 74F3                    	je	short init_chk_delim		;
  6054                                  
  6055 000016CF 3A06[0E04]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  6056 000016D3 7516                            jne	short parse_line_error_disp	; No - just issue message
  6057 000016D5 AC                      	lodsb					; Get the char after the switch
  6058                                  
  6059 000016D6 E8E104                  	call	iupconv 			; upper case it
  6060                                  
  6061                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  6062                                          ;jne	short check_k_too ; MSDOS 6.0	;
  6063                                  	; 16/04/2023
  6064 000016D9 3C43                    	cmp	al,'C' ; scswitch
  6065                                  	;jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  6066                                  	; 06/06/2023
  6067                                  	; MSDOS 6.22 COMMAND.COM
  6068 000016DB 7505                    	jne	short check_k_too
  6069 000016DD 5A                      	pop	dx ; *				; even up stack
  6070 000016DE 5A                      	pop	dx ; **				; even up stack
  6071 000016DF E9B100                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  6072                                  
  6073                                  	; MSDOS 6.0
  6074                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6075                                  check_k_too:
  6076                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  6077                                          ;jne	short parse_line_error_disp	;
  6078                                  	; 06/06/2023
  6079 000016E2 3C4B                    	cmp	al,'K'
  6080 000016E4 7505                    	jne	short parse_line_error_disp
  6081 000016E6 5A                      	pop	dx ; *				; even up stack
  6082 000016E7 5A                      	pop	dx ; **				; even up stack
  6083 000016E8 E9A100                          jmp	SetKSwitch			; Yes - go set COMMAND /K
  6084                                  
  6085                                  parse_line_error_disp:
  6086                                  	; 14/01/2023
  6087 000016EB 58                      	pop	ax ; *				; restore error number
  6088 000016EC 5E                      	pop	si ; **				; restore line position
  6089                                  parse_line_error_disp2:
  6090 000016ED 89C2                    	mov	dx,ax				; get message number
  6091 000016EF E86C04                  	call	RPrintParse
  6092 000016F2 E899FC                  	call	crlf
  6093 000016F5 EBA0                            jmp     short Parse_command_line        ; continue parsing
  6094                                  
  6095                                  ; 16/04/2023
  6096                                  %if 1
  6097                                  SetMSwitch:
  6098                                          ;cmp	byte [ext_msg],1
  6099 000016F7 803E[921F]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6100                                  	; 16/04/2023
  6101                                  	;jnz	short setMswitchok		; no - set it
  6102                                  	;;mov	ax,1
  6103                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6104                                  	;jmp	parse_line_error                ; go issue error message
  6105                                  	; 16/04/2023
  6106 000016FC 7458                    	je	short parse_line_error_j
  6107                                  setMswitchok:
  6108                                          ;mov	byte [ext_msg],1
  6109 000016FE C606[921F]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6110                                  	; 06/06/2023
  6111 00001703 EB92                    	jmp	short Parse_command_line	; keep parsing
  6112                                  %endif
  6113                                  
  6114                                  parse_cont:
  6115                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6116                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6117                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6118                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:1869h - CODERES:0A19h)
  6119                                  
  6120                                  	; MSDOS 6.0
  6121                                  
  6122                                  ; See if a switch was entered
  6123                                  ;
  6124                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6125                                  
  6126 00001705 813E[3A20][D21F]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6127 0000170B 7433                    	je	short SetFSwitch		; yes go set fail switch
  6128 0000170D 813E[3A20][C61F]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6129 00001713 743A                    	Je	short SetPSwitch		; yes go set up PERMCOM
  6130 00001715 813E[3A20][DE1F]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6131 0000171B 745C                    	je	short SetDSwitch		; yes go set date switch
  6132 0000171D 813E[3A20][0320]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6133 00001723 746E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6134                                  	; 06/06/2023
  6135                                  	; MSDOS 6.0 only!
  6136 00001725 813E[3A20][2920]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6137 0000172B 745F                            je	short SetKSwitch		; yes go set up SINGLECOM
  6138                                  	;
  6139 0000172D 813E[3A20][EA1F]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6140 00001733 746F                    	je	short SetESwitch		; yes go set up environment
  6141 00001735 813E[3A20][0F20]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6142                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6143                                  	; 15/01/2023
  6144 0000173B 74BA                    	je	short SetMSwitch 
  6145 0000173D E98200                  	jmp	ChkOtherArgs		; Must be something else
  6146                                  
  6147                                  	; MSDOS 6.0
  6148                                  ;SetMSwitchjmp:
  6149                                  	;jmp	SetMSwitch
  6150                                  	
  6151                                  	; MSDOS 6.0
  6152                                  SetFSwitch:
  6153 00001740 803E[6502]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6154                                  	; 16/04/2023
  6155                                  	;jne	short failok		; no - set it
  6156                                  	;;mov	ax,1
  6157                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6158                                          ;jmp	parse_line_error        ; go issue error 
  6159                                  	; 16/04/2023
  6160 00001745 740F                    	je	short parse_line_error_j
  6161                                  
  6162                                  	; MSDOS 3.3 & MSDOS 6.0
  6163                                  failok:
  6164 00001747 C606[6502]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6165                                  	; MSDOS 3.3
  6166                                  	;jmp	short CHKARG
  6167                                  	; MSDOS 6.0
  6168 0000174C E948FF                  	jmp	Parse_command_line
  6169                                  
  6170                                  ;CHECKPSWITCH:
  6171                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6172                                  	;cmp	al,[letter_p]
  6173                                          ;jnz	short CHECKDSWITCH
  6174                                  
  6175                                  SetPSwitch:
  6176                                  
  6177                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6178                                  ; termination address.
  6179                                  
  6180                                  	; MSDOS 6.0
  6181 0000174F 803E[5E02]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6182 00001754 7406                    	jz	short permcomok		; no - set it
  6183                                  	; 16/04/2023
  6184                                  parse_line_error_j:
  6185                                          ;mov	ax,1
  6186 00001756 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6187 00001759 E959FF                          jmp	parse_line_error	; go issue error 
  6188                                  
  6189                                  permcomok:
  6190                                  	; MSDOS 3.3 & MSDOS 6.0
  6191 0000175C FE06[5E02]              	inc	byte [PermCom]
  6192                                  	;mov	word [OLDTERM],LODCOM
  6193 00001760 C706[FC01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6194                                  	;mov	[OLDTERM+2],ds
  6195 00001766 8C1E[FE01]              	mov	[OldTerm+2],ds
  6196                                  
  6197                                  ; make sure that we display the date and time. if the flag was not
  6198                                  ; initialized, set it to indicate yes, do prompt.
  6199                                  
  6200                                  	; MSDOS 3.3
  6201                                  	;cmp	byte [PRDATTM],-1
  6202                                  	;jnz	short CHKARG
  6203                                  	;mov	byte [PRDATTM],0
  6204                                  	;jmp	short CHKARG
  6205                                  
  6206                                  	; MSDOS 6.0
  6207 0000176A 803E[371F]FF            	cmp	byte [PRDATTM],-1
  6208 0000176F 7505                    	jne	short Parse_command_line_jmp
  6209 00001771 C606[371F]00            	mov	byte [PRDATTM],0
  6210                                  Parse_command_line_jmp:
  6211 00001776 E91EFF                  	jmp     Parse_command_line	; keep parsing
  6212                                  
  6213                                  ;COMRETURNSJ:
  6214                                  ;	; MSDOS 3.3
  6215                                  ;	JMP	ARGSDONE
  6216                                  
  6217                                  ;CHECKDSWITCH:
  6218                                  	;;cmp	al,'d'
  6219                                          ;cmp	al,[letter_d]
  6220                                  	;jnz	short CHECKCSWITCH
  6221                                  
  6222                                  SetDSwitch:
  6223                                  
  6224                                  ; Flag no date/time prompting.
  6225                                  
  6226                                  	; MSDOS 6.0
  6227 00001779 803E[941F]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6228                                  	; 16/04/2023
  6229                                  	;jz	short setdateok		; no - set it
  6230                                          ;;mov	ax,1
  6231                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6232                                          ;jmp	parse_line_error	; go issue error message
  6233                                  	; 16/04/2023
  6234 0000177E 75D6                    	jnz	short parse_line_error_j
  6235                                  setdateok:
  6236 00001780 FE06[941F]              	inc	byte  [dswitch]		; indicate /D entered
  6237                                  
  6238                                  	; MSDOS 3.3 & MSDOS 6.0
  6239 00001784 C606[371F]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6240                                  	; MSDOS 3.3
  6241                                  	;jmp	short CHKARG
  6242                                  	; MSDOS 6.0
  6243 00001789 E90BFF                  	jmp     Parse_command_line	; continue parsing
  6244                                  
  6245                                  	; 15/01/2023
  6246                                  	; MSDOS 6.0 
  6247                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6248                                  SetKSwitch:
  6249 0000178C C606[5F02]00            	mov	byte [SemiPermCom],0
  6250 00001791 EB05                    	jmp	short SetSorKSwitch
  6251                                  
  6252                                  ;CHECKCSWITCH:
  6253                                  	;;cmp	al,'c'
  6254                                  	;cmp	al,[letter_c]
  6255                                          ;jnz	short CHECKESWITCH
  6256                                  
  6257                                  SetSSwitch:
  6258                                  ;SETCSWITCH:
  6259                                  
  6260                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6261                                  
  6262 00001793 C606[5E02]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6263                                  SetSorKSwitch:	; 06/06/2023
  6264 00001798 8936[6102]              	mov	[SingleCom],si		; Point to the rest of the command line
  6265 0000179C C606[371F]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6266                                  ;COMRETURNSJ: ; 24/09/2018
  6267 000017A1 E94001                  	jmp     ArgsDone
  6268                                  
  6269                                  ;CHECKESWITCH:
  6270                                  	;cmp	al,'e'
  6271                                  	;jnz	short CHKARG
  6272                                  
  6273                                  ; Look for environment-size setting switch
  6274                                  
  6275                                  ; The environment size is represented in decimal bytes and is
  6276                                  ; converted into paragraphs (rounded up to the next paragraph).
  6277                                  
  6278                                  SetESwitch:
  6279                                  	; MSDOS 6.0
  6280 000017A4 803E[931F]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6281                                  	; 16/04/2023
  6282                                  	;jz	short eswitchok		; no - set it
  6283                                  	;;mov	ax,1
  6284                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6285                                          ;jmp	parse_line_error	; go issue error message
  6286                                  	; 16/04/2023
  6287 000017A9 75AB                    	jnz	short parse_line_error_j
  6288                                  eswitchok:
  6289 000017AB FE06[931F]              	inc	byte [eswitch]		; indicate /E entered 	
  6290                                  
  6291                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6292                                  	; 15/01/2023 - Retro DOS v4.1 (& v4.1) - MSDOS 5.0 COMMAND.COM
  6293                                  	; MSDOS 6.0
  6294                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6295 000017AF BF[3C20]                        mov	di,COMND1_ADDR
  6296 000017B2 8B1D                    	mov     bx,[di]				; into bx
  6297                                  
  6298 000017B4 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6299 000017B7 B104                    	mov	cl,4				; convert to pargraphs
  6300 000017B9 D3EB                    	shr	bx,cl				; by right 4
  6301                                  
  6302 000017BB 891E[7E1F]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6303 000017BF E9D5FE                  	jmp	Parse_command_line		; continue parsing command line
  6304                                  
  6305                                  ; 16/04/2023
  6306                                  %if 0
  6307                                  SetMSwitch:
  6308                                          ;cmp	byte [ext_msg],1
  6309                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6310                                  	jnz	short setMswitchok		; no - set it
  6311                                  	;mov	ax,1
  6312                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6313                                  	jmp	parse_line_error                ; go issue error message
  6314                                  setMswitchok:
  6315                                          ;mov	byte [ext_msg],1
  6316                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6317                                  	jmp	Parse_command_line              ; keep parsing
  6318                                  %endif
  6319                                  
  6320                                  ;ArgsDoneJ:
  6321                                  	;jmp	ArgsDone
  6322                                  
  6323                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6324                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6325                                  
  6326                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6327                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:196Dh - CODERES:0B1Dh)
  6328                                  ChkOtherArgs:
  6329                                  
  6330                                  ; We have a non-switch character here.
  6331                                  
  6332                                  	; MSDOS 6.0
  6333 000017C2 1E                      	push	ds ; ****			;
  6334 000017C3 56                      	push	si ; *** 			; save place in command line
  6335 000017C4 C536[3C20]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6336                                  	;assume	ds:nothing			;
  6337                                  
  6338 000017C8 89F2                    	mov	dx,si				; put in dx also
  6339 000017CA B8023D                  	mov	ax,3D02h
  6340                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6341 000017CD CD21                    	int	21h
  6342 000017CF 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6343 000017D1 89C3                    	mov	bx,ax
  6344 000017D3 B80044                  	mov	ax,4400h
  6345                                  	;mov	ax,IOCTL shl 8
  6346 000017D6 CD21                    	int	21h
  6347 000017D8 F6C280                  	test	dl,80h
  6348 000017DB 7506                    	jnz	short IsaDevice
  6349                                  BadSetCon:
  6350 000017DD B43E                    	mov	ah,3Eh
  6351                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6352 000017DF CD21                    	int	21h
  6353 000017E1 EB4E                    	jmp	short ChkSrchSpec
  6354                                  
  6355                                  	; 15/01/2023
  6356                                  IsaDevice:
  6357                                  	; MSDOS 3.3 & MSDOS 6.0
  6358 000017E3 30F6                    	xor	dh,dh
  6359 000017E5 80CA03                  	or	dl,3				; Make sure has CON attributes
  6360                                  	;mov	ax,(IOCTL shl 8) or 1
  6361 000017E8 B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6362 000017EB CD21                    	int	21h
  6363                                  	;
  6364                                  	; 15/01/2023
  6365 000017ED 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6366                                  	; 25/09/2018
  6367                                  	;pop	dx ; *
  6368                                  	;pop	dx ; **
  6369                                  	;
  6370                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6371                                  	
  6372 000017EF 89DA                    	mov	dx,bx				; Save new handle
  6373                                  
  6374                                  	; MSDOS 6.0
  6375 000017F1 26803E[CE24]01          	cmp	byte [es:DevFlag],1
  6376 000017F7 742A                    	jz	short DevErr
  6377                                  
  6378                                  	; MSDOS 3.3
  6379                                          ;pop	bx ; *				; Throw away saved SI
  6380                                          ;pop	bx ; **				; Throw away saved CX
  6381                                  
  6382                                  	; MSDOS 3.3 & MSDOS 6.0
  6383 000017F9 51                      	push	cx ; **
  6384 000017FA B90300                  	mov	cx,3
  6385 000017FD 31DB                    	xor	bx,bx
  6386                                  
  6387                                  	; 15/01/2023
  6388                                  rcclloop:
  6389 000017FF B43E                    	mov	ah,3Eh
  6390                                  	;mov	ah,CLOSE ; 3Eh
  6391 00001801 CD21                    	int	21h
  6392 00001803 43                      	inc	bx
  6393 00001804 E2F9                    	loop	rcclloop
  6394                                  
  6395 00001806 89D3                    	mov	bx,dx				; New device handle
  6396 00001808 B445                    	mov	ah,45h
  6397                                  	;mov	ah,XDUP ; 45h
  6398 0000180A CD21                    	int	21h				; Dup to 0
  6399 0000180C B445                    	mov	ah,45h
  6400                                  	;mov	ah,XDUP
  6401 0000180E CD21                    	int	21h				; Dup to 1
  6402 00001810 B445                    	mov	ah,45h
  6403                                  	;mov	ah,XDUP
  6404 00001812 CD21                    	int	21h				; Dup to 2
  6405 00001814 B43E                    	mov	ah,3Eh
  6406                                  	;mov	ah,CLOSE
  6407 00001816 CD21                    	int	21h				; Close initial handle
  6408                                  	
  6409 00001818 59                      	pop	cx ; **
  6410                                  	
  6411                                  	; MSDOS 6.0
  6412 00001819 5E                      	pop	si ; ***			; restore position of command line
  6413 0000181A 1F                      	pop	ds ; ****			;
  6414                                  
  6415                                  ; Register the fact that we already have redirected the output
  6416                                  ; and can not do it again
  6417                                  
  6418 0000181B 26FE06[CE24]            	inc	byte [es:DevFlag]		
  6419 00001820 E974FE                  	jmp	Parse_command_line		; continue parsing
  6420                                  
  6421                                  	; MSDOS 3.3
  6422                                  	;jcxz	ARGSDONEJ2
  6423                                  	;jmp	CHKARG
  6424                                  
  6425                                  	; MSDOS 6.0
  6426                                  DevErr:
  6427 00001823 5E                      	pop	si ; ***
  6428 00001824 1F                      	pop	ds ; ****
  6429 00001825 BA0100                  	mov	dx,1
  6430 00001828 E83303                          call	RPrintParse                     ; "Too many parameters"
  6431 0000182B E860FB                          call	crlf
  6432 0000182E E966FE                  	jmp	Parse_command_line
  6433                                  
  6434                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6435                                  	; MSDOS 6.0
  6436 00001831 26803E[CF24]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6437 00001837 74EA                            jz	short DevErr			; yes, error
  6438                                  	
  6439 00001839 26FE06[CF24]                    inc	byte [es:PathFlag]		; mark that we have a path
  6440                                  
  6441                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6442                                  ; This buffer will later be replaced by a proper environment
  6443                                  
  6444                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6445                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6446                                  	; 06/06/2023
  6447                                  	;mov	ax,[ss:EnvirSeg]
  6448                                  	
  6449                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6450                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19E9h
  6451                                  	;
  6452                                  	; MSDOS 6.0
  6453 0000183E E8F604                  	call	alloc_env                       ; environment buffer
  6454                                  
  6455                                  ; 06/06/2023
  6456                                  %if 0
  6457                                  	; 15/01/2023
  6458                                  	; MSDOS 5.0
  6459                                  	cmp	byte [ss:AllocedEnv],1
  6460                                  	mov	byte [ss:AllocedEnv],0
  6461                                  	jne     short env_alloced
  6462                                  	call	alloc_env
  6463                                  	mov	[ss:EnvirSeg],ax
  6464                                  %endif
  6465                                  
  6466                                  env_alloced:
  6467                                  	; MSDOS 5.0 & MSDOS 6.0
  6468 00001841 8EC0                    	mov	es,ax
  6469                                  	;assume	es:nothing
  6470 00001843 56                      	push	si ; **				; remember location of file
  6471 00001844 31C9                    	xor	cx,cx				; clear cx for counting
  6472                                  	
  6473                                  	; 15/01/2023
  6474                                  countloop:
  6475 00001846 AC                      	lodsb					; get a character
  6476 00001847 41                      	inc	cx				; increment counter
  6477                                          ;;cmp	al,0
  6478                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6479                                  	;jne	short countloop			; no - keep counting
  6480 00001848 08C0                    	or	al,al	
  6481 0000184A 75FA                    	jnz	short countloop
  6482                                  	; 06/03/2023
  6483                                  	; al = 0 ; (*) 
  6484                                  
  6485                                  	;;;;mov	al,[Space]
  6486                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6487                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6488                                  	; 16/04/2023
  6489                                  	;mov	al,20h ; ' ' 
  6490 0000184C 4E                      	dec	si				; move back one
  6491                                          ;mov	[si],al				; put a space at end of line
  6492 0000184D C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6493                                  
  6494                                  ; We now know how long the new pathspec for command.com is. Time to
  6495                                  ; figure out how long the current COMSPEC setting is, and then to move
  6496                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6497                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6498                                  ; where the filespec exists in the environment) is updated as well.
  6499                                  
  6500                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6501                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19FEh
  6502                                  
  6503                                  	; MSDOS 6.0
  6504 00001850 51                      	push	cx ; * 				;
  6505 00001851 B90080                          mov	cx,ENVBIG ; 32768		;
  6506 00001854 368B3E[671F]                    mov	di,[ss:ComspOffset]		; get location of COMSPEC
  6507                                          ;mov	al,0                            ;
  6508                                  	; 06/06/2023
  6509                                  	; al = 0 ; (*)
  6510 00001859 F2AE                    	repne	scasb                           ; find the end of COMSPEC
  6511 0000185B 89FE                            mov	si,di                           ;
  6512                                  comp_endenv:					;
  6513 0000185D AE                      	scasb					; end of env?
  6514 0000185E 7404                    	je	short got_endenv		; yes
  6515 00001860 F2AE                    	repne	scasb				;
  6516 00001862 EBF9                    	jmp	short comp_endenv		;
  6517                                  got_endenv:					;
  6518 00001864 89F9                    	mov	cx,di				;
  6519 00001866 29F1                    	sub	cx,si				;
  6520 00001868 368B3E[671F]            	mov	di,[ss:ComspOffset]		;
  6521 0000186D 83EF08                  	sub	di,ComspStrLen	; sub di,8	;
  6522 00001870 1E                      	push	ds ; +				;
  6523 00001871 06                      	push	es				;
  6524 00001872 1F                      	pop	ds				;
  6525 00001873 F3A4                    	rep	movsb				;
  6526 00001875 4F                      	dec	di				; copy in new COMSPEC=
  6527 00001876 0E                      	push	cs				;
  6528 00001877 1F                      	pop	ds				;
  6529                                          ;assume ds:RESGROUP			;
  6530                                  	;mov    si,offset RESGROUP:ComspString	;
  6531 00001878 BE[691F]                	mov	si,ComspString			; "COMSPEC=\COMMAND.COM"
  6532                                  	;mov	cx,ComspStrLen	; mov cx,8	;
  6533 0000187B B108                            mov	cl,ComspStrLen	; mov cl,8
  6534 0000187D F3A4                    	rep	movsb				;
  6535 0000187F 893E[671F]              	mov	[ComspOffset],di		;
  6536 00001883 1F                      	pop	ds ; + 				;
  6537                                          ;assume ds:nothing			;
  6538 00001884 59                      	pop	cx ; *				;
  6539                                  	;
  6540 00001885 5E                      	pop	si ; **				; get new comspec location back
  6541                                  
  6542                                  	;; MSDOS 3.3 COMMAND.COM
  6543                                  	;;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6544                                  	;;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6545                                  	;;mov	cl,4
  6546                                  	;;shr	ax,cl
  6547                                  	;;mov	dx,ds
  6548                                  	;;add	ax,dx
  6549                                  	;;mov	[ENVIRSEG],ax
  6550                                  	;;mov	es,ax
  6551                                  	;;;mov	al,' '
  6552                                  	;;mov	al,[SPACE_CHR]
  6553                                  	;;mov	[si-1],al
  6554                                  	;;pop	si ; **				; Remember location
  6555                                  	;;pop	cx ; *				; and count
  6556                                  	;;;mov	di,[ECOMLOC]
  6557                                  	;;mov	di,[COMSPOFFSET]
  6558                                  
  6559                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6560                                  	;; 15/01/2023
  6561                                  	;; MSDOS 5.0 COMMAND.COM
  6562                                  	;pop	si ; **
  6563                                  	;;mov	di,14
  6564                                  	;mov	di,ECOMSPEC ; mov di,0Eh
  6565                                  
  6566                                  ComtrLoop:
  6567                                  	; MSDOS 3.3 & MSDOS 6.0
  6568 00001886 AC                      	lodsb
  6569 00001887 49                      	dec	cx
  6570                                  	;;;;cmp	al,' '
  6571                                  	;;;cmp	al,[space_chr]
  6572                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6573                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6574                                  	; 16/04/2023
  6575 00001888 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6576 0000188A 7405                    	je	short SetComsr
  6577                                  	; MSDOS 3.3
  6578                                  	;cmp	al,9
  6579                                  	;je	short SetComsr
  6580                                  	; MSDOS 3.3 & MSDOS 6.0
  6581 0000188C AA                      	stosb
  6582 0000188D E302                    	jcxz	SetComsr
  6583 0000188F EBF5                    	jmp	short ComtrLoop
  6584                                  
  6585                                  SetComsr:
  6586                                  	; 15/01/2023
  6587                                  	; MSDOS 6.0
  6588 00001891 51                      	push	cx ; **
  6589 00001892 0E                      	push	cs				; Get local segment
  6590 00001893 1F                      	pop	ds				;
  6591                                  	;assume	ds:ResGroup			;
  6592 00001894 1E                      	push	ds ; *
  6593                                  	;mov	si,offset ResGroup:ComSpect
  6594 00001895 BE[061F]                	mov	si,COMSPECT ; "\COMMAND.COM"
  6595 00001898 B90E00                  	mov	cx,14
  6596 0000189B 268A45FF                	mov	al,[es:di-1]
  6597 0000189F 3A06[0F04]              	cmp	al,[RDirChar]
  6598 000018A3 7502                    	jne	short iNotRoot
  6599 000018A5 46                      	inc	si				; Don't make a double /
  6600 000018A6 49                      	dec	cx
  6601                                  	
  6602                                  	; MSDOS 3.3
  6603                                  	;push	si
  6604                                  	;push	cx
  6605                                  	;push	ds
  6606                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6607                                  	;mov	cx,14
  6608                                  	;mov	al,[es:di-1]
  6609                                  	;call	PATHCHRCMPR
  6610                                  	;jnz	short INOTROOT			
  6611                                  	;inc	si				; Don't make a double /
  6612                                  	;dec	cx
  6613                                  
  6614                                  iNotRoot:
  6615                                  	; MSDOS 3.3 & MSDOS 6.0
  6616 000018A7 F3A4                    	rep	movsb
  6617                                  
  6618                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6619                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6620                                  	; MSDOS 6.0 
  6621 000018A9 8B16[671F]              	mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6622                                  	; 15/01/2023
  6623                                  	;;mov	dx,14
  6624                                  	;mov	dx,ECOMSPEC ; mov dx,0Eh ; MSDOS 5.0 COMMAND.COM
  6625                                  
  6626 000018AD 06                      	push	es
  6627 000018AE 1F                      	pop	ds
  6628                                  	;;mov	ax,OPEN shl 8
  6629                                  	;mov	ax,OPEN*256 ; 3D00h
  6630 000018AF B8003D                  	mov	ax,3D00h ; 15/01/2023
  6631 000018B2 CD21                    	int	21h				; Open COMMAND.COM
  6632 000018B4 1F                      	pop	ds ; *
  6633 000018B5 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6634 000018B7 89C3                    	mov	bx,ax				; Handle
  6635 000018B9 B43E                    	mov	ah,3Eh ; 15/01/2023
  6636                                  	;mov	ah,CLOSE ; 3Eh
  6637 000018BB CD21                    	int	21h				; Close COMMAND.COM
  6638                                  SetComsrRet:
  6639                                  	; 15/01/2023
  6640 000018BD 59                      	pop	cx ; **
  6641 000018BE 5E                      	pop	si ; ***
  6642                                  
  6643                                  	; MSDOS 6.0
  6644 000018BF 1F                      	pop	ds ; ****			;
  6645                                  	;assume	ds:ResGroup			;
  6646                                  	;
  6647 000018C0 0E                      	push	cs				; Make sure local ES is
  6648 000018C1 07                      	pop	es				;  restored
  6649 000018C2 E9D2FD                  	jmp	Parse_command_line		; continue parsing command line
  6650                                  
  6651                                  	; MSDOS 3.3
  6652                                  ;ARGSDONEJ2:
  6653                                  	;jcxz	ARGSDONE
  6654                                  	;jmp	CHKARG
  6655                                  
  6656                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6657                                  SetComsrBad:
  6658                                  	; MSDOS 3.3 & MSDOS 6.0
  6659                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6660 000018C5 BA[D720]                	mov	dx,BADCOMLKMES
  6661                                  
  6662                                  ;	Note: we're about to make a near call to TriageError, which
  6663                                  ;	lives in a different segment and group. Some linkers will
  6664                                  ;	generate a warning like "Possible fix-up overflow". We're
  6665                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6666                                  ;	we're still all together.
  6667                                  
  6668                                  	; 16/01/2023
  6669                                  	;TRIAGEERROR equ TRANSTART+TriageError
  6670                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6671                                  
  6672                                  	; 06/06/2023
  6673                                  	TRIAGEERROR equ TRANSTART+TriageError
  6674                                  	;(MSDOS 6.22 COMMAND.COM, 26E0h+333Ch)
  6675                                  
  6676                                  	;;call	50B2h ; MSDOS 5.0 COMMAND.COM
  6677                                  	;call	5A1Ch ; MSDOS 6.22 COMMAND.COM
  6678 000018C8 E8(D757)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6679                                  				; in original MSDOS 3.3 COMMAND.COM
  6680                                  
  6681                                  			; TriageError procedure is at offset 50B2h
  6682                                  			; in original MSDOS 5.0 COMMAND.COM	
  6683 000018CB 83F841                  	cmp	ax,65
  6684 000018CE 7503                    	jne	short doprt
  6685                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6686 000018D0 BA[0021]                	mov	dx,BADCOMACCMSG
  6687                                  doprt:
  6688 000018D3 E8BBFA                  	call	RPrint
  6689                                  	;mov	si,offset ResGroup:ComSpect
  6690 000018D6 BE[061F]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6691                                  	;;mov	di,[ECOMLOC]
  6692                                  	; 06/06/2023
  6693 000018D9 8B3E[671F]              	mov	di,[ComspOffset] ; MSDOS 6.22 COMMAND.COM
  6694                                  	; 16/01/2023
  6695                                  	;mov	di,ECOMSPEC ; mov di,0Eh ; MSDOS 5.0 COMMAND.COM
  6696 000018DD B90E00                  	mov	cx,14
  6697 000018E0 F3A4                    	rep	movsb				; get my default back
  6698                                  
  6699 000018E2 EBD9                    	jmp	short SetComsrRet
  6700                                  
  6701                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6702                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6703                                  
  6704                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6705                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1A99h (CODERES:0C49h)
  6706                                  ArgsDone:
  6707                                  	; MSDOS 6.0
  6708 000018E4 8E06[FA03]              	mov	es,[EnvirSeg]			; get environment back
  6709                                  	;assume	es:nothing			;
  6710                                  
  6711                                  	; MSDOS 3.3 & MSDOS 6.0
  6712 000018E8 803E[5E02]00                    cmp	byte [PermCom],0
  6713 000018ED 742E                            jz	short ComReturns
  6714                                  
  6715 000018EF 06                      	push	es				; Save environment pointer
  6716 000018F0 B450                    	mov	ah,50h
  6717                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6718 000018F2 8CDB                    	mov	bx,ds
  6719 000018F4 8EC3                    	mov	es,bx
  6720 000018F6 CD21                    	int	21h				; current process is me
  6721 000018F8 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6722                                  	;;mov	ax,offset RESGROUP:LODCOM
  6723                                  	;mov	ax,LODCOM
  6724                                  	; 16/01/2023
  6725 000018FB B8[7E00]                	mov	ax,LodCom_Trap
  6726 000018FE AB                              stosw
  6727 000018FF 8CD8                            mov	ax,ds
  6728 00001901 AB                              stosw
  6729                                  	;;mov	ax,offset RESGROUP:CONTC
  6730                                  	;mov	ax,CONTC
  6731                                  	; 16/01/2023
  6732 00001902 B8[4A00]                	mov	ax,Ctrlc_Trap
  6733 00001905 AB                              stosw
  6734 00001906 8CD8                            mov	ax,ds
  6735 00001908 AB                              stosw
  6736                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6737                                  	;mov	ax,CRITERR
  6738                                  	; 16/01/2023
  6739 00001909 B8[5500]                	mov	ax,CritErr_Trap
  6740 0000190C AB                      	stosw
  6741 0000190D 8CD8                    	mov     ax,ds
  6742 0000190F AB                      	stosw
  6743                                  	;;mov	word ptr ds:16h,ds
  6744                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6745 00001910 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6746                                          ;;mov	dx,offset RESGROUP:Int_2e
  6747                                  	;mov	dx,Int_2e
  6748                                          ; 16/01/2023
  6749 00001914 BA[3F00]                	mov	dx,Int2e_Trap
  6750 00001917 B82E25                  	mov	ax,252Eh
  6751                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6752                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6753 0000191A CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6754                                  			; AL = interrupt number
  6755                                  			; DS:DX = new vector to be used for specified interrupt
  6756 0000191C 07                              pop	es				; Remember environment
  6757                                  	
  6758                                  ComReturns:
  6759                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6760 0000191D A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6761                                  	; 16/01/2023
  6762 00001920 A3[FA01]                	mov	[Parent],ax			; Save parent
  6763                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6764 00001923 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6765                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6766 00001927 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6767 0000192A A3[5B02]                        mov	[Io_Save],ax		; Get the default stdin and out
  6768 0000192D 8C1E[FE03]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6769 00001931 8C1E[0204]                      mov	[Com_Fcb1+2],ds
  6770 00001935 8C1E[0604]              	mov	[Com_Fcb2+2],ds
  6771                                          ;mov	di,offset ResGroup:ComSpec
  6772 00001939 BF[0702]                        mov	di,ComSpec
  6773                                  
  6774                                  	;;mov	si,[ECOMLOC]
  6775                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  6776 0000193C 8B36[671F]              	mov	si,[ComspOffset]
  6777                                  	; 16/01/2023 - MSDOS 5.0 COMMAND.COM
  6778                                  	;mov	si,ECOMSPEC ; mov si,0Eh
  6779                                  
  6780 00001940 803E[441F]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6781                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6782                                  	
  6783 00001945 8CD8                    	mov	ax,ds				; Xchg es,ds
  6784 00001947 06                      	push	es
  6785 00001948 1F                      	pop	ds
  6786 00001949 8EC0                    	mov	es,ax
  6787                                  
  6788                                  	; 06/06/2023
  6789 0000194B 7517                    	jne	short CopyComsp ; MSDOS 6.0
  6790                                  	; 16/01/2023	
  6791                                  	;je	short CopyComsp ; MSDOS 5.0
  6792                                  	;;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6793                                  
  6794 0000194D 0E                              push	cs
  6795 0000194E 1F                              pop	ds
  6796                                  
  6797                                          ;mov	si,offset ResGroup:ComspString
  6798 0000194F BE[691F]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6799 00001952 06                      	push	es
  6800 00001953 57                      	push	di
  6801 00001954 E81802                  	call	IfindE
  6802 00001957 89FE                    	mov	si,di
  6803 00001959 06                      	push	es
  6804 0000195A 1F                      	pop	ds
  6805 0000195B 5F                      	pop	di
  6806 0000195C 07                      	pop	es
  6807 0000195D 7305                            jnc	short CopyComsp
  6808                                  
  6809                                  	; 06/06/2023
  6810                                  	; MSDOS 6.0
  6811                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1B04h
  6812                                  ComSpecNofnd:
  6813                                  	;;mov	si,offset ResGroup:ComspString
  6814                                  	;mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6815                                  	;add	si,ComspStrLen ; add si,8
  6816 0000195F BE[711F]                	mov	si,ComspString+ComspStrLen
  6817                                  	
  6818                                  	;; 21/01/2023
  6819                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6820                                  	;;mov	si,0Eh
  6821                                  	;mov	si,ECOMSPEC
  6822                                  	
  6823 00001962 0E                      	push	cs
  6824 00001963 1F                      	pop	ds	
  6825                                  
  6826                                  	; 21/01/2023
  6827                                  ;COMSPECNOFND:
  6828                                  	; MSDOS 3.3
  6829                                          ;;mov	si,[es:ECOMLOC]
  6830                                          ;mov	si,[es:COMSPOFFSET]
  6831                                  	;;add	si,offset RESGROUP:PATHSTRING
  6832                                          ;add	si,PATHSTRING ; "PATH="
  6833                                  	;push	cs
  6834                                  	;pop	ds
  6835                                  
  6836                                  CopyComsp:
  6837                                  	; 21/01/2023
  6838                                  ;COPYCOMSP:
  6839                                  	; MSDOS 3.3 & MSDOS 6.0
  6840                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6841                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6842 00001964 26893E[E601]            	mov	[es:PutBackComSpec],di
  6843 00001969 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6844 0000196D 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6845                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6846                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6847 0000196F 268306[E601]02          	add	word [es:PutBackComSpec],2
  6848                                  CopyComspLoop:
  6849 00001975 AC                      	lodsb
  6850 00001976 AA                      	stosb
  6851 00001977 08C0                    	or	al,al
  6852 00001979 75FA                    	jnz	short CopyComspLoop
  6853                                  
  6854 0000197B 26893E[4702]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6855 00001980 26FF0E[4702]            	dec	word [es:ComSpec_End]
  6856 00001985 268A26[5002]            	mov	ah,[es:ComDrv]
  6857 0000198A 80C440                  	add	ah,'A'-1 ; 40h
  6858 0000198D 268826[EB01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6859                                  
  6860                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6861                                  	
  6862                                  	; MSDOS 6.0
  6863 00001992 E85102                  	call	setup_for_messages		; set up parse and extended error messages
  6864                                  
  6865                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6866                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6867                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6868                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6869                                  ; the data otherwise it is just the data.
  6870                                   
  6871 00001995 E8F002                  	call	Setup_res_end			; put resident size in ResSize
  6872                                  
  6873 00001998 0E                      	push	cs
  6874 00001999 1F                      	pop	ds
  6875                                  	;assume	ds:RESGROUP
  6876                                  
  6877                                  ;Public EnvMaximum
  6878                                          ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6879                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6880                                          ; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6881                                  		; MSDOS 6.22 COMMAND.COM - RESGROUP:1B53h
  6882                                  
  6883                                  	; 21/01/2023
  6884                                  	; MSDOS 6.0
  6885                                  	;;mov	si,offset RESGROUP:TranStart
  6886                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6887                                  	; 06/06/2023
  6888                                  	;;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM
  6889                                  	;mov	si,TRANSTART
  6890                                  	;add	si,100h
  6891                                  	; 23/04/2023
  6892 0000199A BE1027                  	mov	si,TRANSTART+100h
  6893                                  
  6894                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6895                                  	;;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6896                                  	; 06/06/2023
  6897                                  	;;mov	cx,9D53h	; MSDOS 6.22 COMMAND.COM	
  6898 0000199D B9[3298]                	mov	cx,TRANDATAEND-100h
  6899                                  
  6900 000019A0 FC                      	cld
  6901 000019A1 D1E9                    	shr	cx,1
  6902 000019A3 31D2                    	xor	dx,dx
  6903                                  Ichksum:
  6904 000019A5 AD                      	lodsw
  6905 000019A6 01C2                    	add	dx,ax
  6906 000019A8 83D200                  	adc	dx,0
  6907 000019AB E2F8                    	loop	Ichksum
  6908                                  
  6909 000019AD 8916[5302]                      mov	[Sum],dx			; store checksum
  6910                                  
  6911 000019B1 803E[371F]00                    cmp     byte [PRDATTM],0
  6912 000019B6 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6913                                  	
  6914                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6915                                  
  6916                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6917                                  	; 21/01/2023
  6918                                  	;mov	bx,4
  6919 000019B8 BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  6920 000019BB B448                    	mov	ah,48h
  6921                                  	;mov	ah,ALLOC                        ;
  6922 000019BD CD21                            int	21h                             ;
  6923 000019BF 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  6924 000019C1 A3[0502]                        mov	[Batch],ax			; save batch segment
  6925                                  
  6926                                  NoBatchSeg:
  6927                                  	; 21/01/2023
  6928                                  	; MSDOS 6.0 (& MSDOS 5.0)
  6929 000019C4 8B1E[FA03]              	mov	bx,[EnvirSeg]			; get old environment segment
  6930 000019C8 891E[821F]              	mov	[OldEnv],bx			; save it
  6931 000019CC C706[841F]0000          	mov	word [UsedEnv],0		; initialize env size counter
  6932 000019D2 8EDB                    	mov	ds,bx
  6933                                  	;assume	ds:nothing
  6934                                  	
  6935 000019D4 31F6                    	xor	si,si
  6936 000019D6 89F7                    	mov	di,si
  6937                                  
  6938                                  ; This is the maximum allowed size for the environment
  6939                                  
  6940                                  	; 21/01/2023
  6941                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  6942                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  6943                                  	;;mov	[ss:EnvMax],bx
  6944                                  	;shl	bx,1
  6945                                  	;shl	bx,1
  6946                                  	;shl	bx,1
  6947                                  	;shl	bx,1
  6948 000019D8 BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  6949 000019DB 36891E[801F]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  6950 000019E0 4B                      	dec	bx				; dec by one to leave room for double 0
  6951 000019E1 31D2                    	xor	dx,dx				; use dx to indicate that there was
  6952                                  						; no environment size error.
  6953                                  ;public NxtStr
  6954                                  NxtStr:
  6955 000019E3 E85F01                  	call	GetStrLen			; get the size of the current env string
  6956                                  
  6957                                  ;Bugbug: Can use ss here to address UsedEnv
  6958                                  
  6959 000019E6 1E                      	push	ds                              ; get addressability to environment
  6960 000019E7 0E                              push	cs                              ;                       counter
  6961 000019E8 1F                              pop	ds                              ;
  6962                                  	;assume	ds:ResGroup
  6963 000019E9 010E[841F]                      add	[UsedEnv],cx			; add the string length to env size
  6964 000019ED 1F                      	pop	ds                              ;
  6965                                  	;assume	ds:nothing
  6966                                  	
  6967 000019EE 83F901                  	cmp	cx,1				; end of environment was encountered.
  6968 000019F1 7405                    	je	short EnvExit
  6969 000019F3 29CB                    	sub	bx,cx
  6970                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  6971                                  	; 21/01/2023
  6972 000019F5 73EC                    	jae	short NxtStr
  6973 000019F7 42                      	inc	dx				; out of env space msg must be displayed
  6974                                  	;jmp	short EnvExit
  6975                                  
  6976                                  ;OkCpyStr:
  6977                                  	;jmp	short NxtStr
  6978                                  
  6979                                  EnvExit:
  6980 000019F8 0E                      	push	cs
  6981 000019F9 1F                      	pop	ds
  6982                                  	;assume	ds:ResGroup
  6983 000019FA 09D2                    	or	dx,dx				; dx will be non-zero if error
  6984 000019FC 7406                    	jz	short EnvNoErr
  6985                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  6986 000019FE BA[5D20]                	mov	dx,OUTENVMSG
  6987 00001A01 E88DF9                  	call 	RPrint
  6988                                  EnvNoErr:
  6989 00001A04 A1[7E1F]                	mov	ax,[EnvSiz]			; env size previously set
  6990 00001A07 B104                    	mov	cl,4
  6991 00001A09 D3E0                    	shl	ax,cl				; get size in bytes
  6992 00001A0B 3B06[841F]              	cmp	ax,[UsedEnv]			; is it a new env?
  6993 00001A0F 7706                    	ja	short st_envsize		; yes, store the size
  6994 00001A11 A1[841F]                	mov	ax,[UsedEnv]
  6995 00001A14 83C00F                  	add	ax,15				; round up
  6996                                  st_envsize:	
  6997 00001A17 D3E8                    	shr	ax,cl
  6998 00001A19 A3[7E1F]                	mov	[EnvSiz],ax			; store env size needed(paras)
  6999                                  
  7000                                  ;if MSVER
  7001                                  	;cmp	SingleCom,0
  7002                                  	;jnz	nophead 			; don't print header if SingleCom
  7003                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7004                                  	;call	RPrint
  7005                                  ;nophead:
  7006                                  ;endif
  7007                                  	; 21/01/2023
  7008                                  
  7009                                  	; MSDOS 3.3 & 6.0
  7010 00001A1C 833E[0502]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7011 00001A21 7503                    	jnz     short DoDate		; yes - go initialize it
  7012 00001A23 E9CF00                  	jmp     NoDttm			; don't do autoexec or date time
  7013                                  
  7014                                  DoDate:
  7015                                  
  7016                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7017                                  
  7018 00001A26 A1[0502]                	mov	ax,[Batch]		; get batch segment
  7019 00001A29 C606[5902]03            	mov	byte [EchoFlag],3	; set batch echo
  7020 00001A2E C706[6A02]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7021 00001A34 8EC0                    	mov	es,ax
  7022                                  
  7023                                  ; initialize the segment
  7024                                  
  7025 00001A36 31FF                    	xor	di,di
  7026                                  	;;mov	al,0
  7027                                  	;mov	al,BATCHTYPE ; 0
  7028                                  	; 06/06/2023
  7029 00001A38 31C0                    	xor	ax,ax
  7030 00001A3A AA                      	stosb
  7031                                  	;mov	al,1			; initialize echo for batch exit
  7032 00001A3B FEC0                    	inc	al
  7033 00001A3D AA                      	stosb
  7034                                  
  7035                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7036                                  
  7037                                  	;xor	ax,ax			; initialize to zero
  7038                                  	; 06/06/2023
  7039 00001A3E FEC8                    	dec	al ; ax = 0	
  7040                                  
  7041                                  	; 21/01/2023
  7042 00001A40 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7043                                  
  7044 00001A41 AB                      	stosw				; batch segment of last job - batlast
  7045 00001A42 AB                      	stosw				; segment for FOR
  7046 00001A43 AA                      	stosb				; FOR flag
  7047 00001A44 AB                      	stosw				; position in file - batseek
  7048 00001A45 AB                      	stosw
  7049                                  
  7050                                  ; clean out the parameters
  7051                                  
  7052                                  	;mov	ax,-1			; initialize to no parameters
  7053                                  	; 06/06/2023
  7054 00001A46 48                      	dec	ax ; ax = -1
  7055                                  
  7056 00001A47 B90A00                  	mov	cx,10
  7057 00001A4A F3AB                    	rep	stosw
  7058                                  
  7059                                  ; decide whether we should grab the default drive
  7060                                  
  7061 00001A4C 803E[141F]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7062 00001A51 750C                    	jne	short NoAutSet
  7063 00001A53 B419                    	mov	ah,19h	; 21/01/2023
  7064                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7065 00001A55 CD21                    	int	21h
  7066                                  	;;add	al,'A'
  7067                                  	;add	al,[letter_A] ; Ucasea
  7068                                  	;add	al,[ucasea] ; 21/01/2023
  7069                                  	; 21/01/2023
  7070 00001A57 0441                    	add	al,'A'
  7071 00001A59 A2[141F]                	mov	[AUTOBAT],al
  7072                                  	; 21/01/2023
  7073                                  	; 06/06/2023
  7074 00001A5C A2[251F]                	mov	[KAUTOBAT],al
  7075                                  NoAutSet:
  7076                                  
  7077                                  ; copy in the batch file name (including nul)
  7078                                  
  7079                                  	;mov	si,offset ResGroup:AutoBat
  7080 00001A5F BE[141F]                	mov	si,AUTOBAT
  7081 00001A62 B90800                  	mov	cx,8
  7082 00001A65 F3A5                    	rep	movsw
  7083                                  	; 23/04/2023
  7084 00001A67 A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7085                                  
  7086                                  	;mov	dx,offset ResGroup:AutoBat
  7087 00001A68 BA[141F]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7088                                  
  7089                                  	;;mov	ax,OPEN shl 8
  7090 00001A6B B8003D                  	mov	ax,3D00h ; 21/01/2023
  7091                                  	;mov	ax,OPEN*256 ; 3D00h	; open for read
  7092 00001A6E CD21                    	int	21h			; see if autoexec.bat exists
  7093 00001A70 7209                    	jc	short noabat
  7094 00001A72 89C3                    	mov	bx,ax
  7095 00001A74 B43E                    	mov	ah,3Eh ; 21/01/2023
  7096                                  	;mov	ah,CLOSE  ; 3Eh
  7097 00001A76 CD21                    	int	21h
  7098 00001A78 E98700                  	jmp	Drv0			; go process autoexec
  7099                                  
  7100                                  noabat:
  7101 00001A7B 50                      	push	ax
  7102 00001A7C E8CF00                  	call	Setup_Seg
  7103 00001A7F A3[421F]                	mov	[triage_add+2],ax
  7104 00001A82 58                      	pop	ax
  7105 00001A83 FF1E[401F]              	call	far [triage_add]	; get extended error
  7106 00001A87 83F841                  	cmp	ax,65			; network access denied?
  7107                                  	;jne	short OPENERR		; no - go deallocate batch
  7108                                  	; 21/01/2023
  7109                                  	;;je	short AccDenErr
  7110                                  	;jne	short OpenErr 
  7111                                  	; 06/06/2023
  7112 00001A8A 7436                    	je	short AccDenErr 
  7113                                  
  7114                                  	; 21/01/2023
  7115                                  ;_ACCDENERROR:					; yes - put out message
  7116                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7117                                  ;	mov	dx,ACCDENERR
  7118                                  ;	call	RPRINT
  7119                                  
  7120                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7121                                  
  7122                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7123                                  
  7124                                  ; 06/06/2023
  7125                                  ; 21/01/2023
  7126                                  ;%if 0
  7127                                  
  7128                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7129                                  ; by Ellen to check only when in Korea. The country information
  7130                                  ; returned will overlay the old parse data area, but we don't care
  7131                                  ; since we won't need the parse information or country information.
  7132                                  ; We only care about the country code returned in BX.
  7133                                  
  7134                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7135                                  	; 06/06/2023
  7136                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1C5Eh
  7137                                  
  7138                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7139 00001A8C BA[971F]                	mov	dx,INTERNAT_INFO
  7140 00001A8F B80038                  	mov	ax,3800h
  7141                                  	;mov	ax,INTERNATIONAL<<8
  7142                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7143 00001A92 CD21                    	int	21h				;
  7144 00001A94 7223                    	jc	short NoKabat 			; error - don't bother with it
  7145 00001A96 83FB52                  	cmp	bx,52h
  7146                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7147 00001A99 752D                    	jne	short OpenErr 			; no, don't check for kautoexe
  7148                                  
  7149                                  	;mov	di,BatFile			; 3/3/kk
  7150 00001A9B BF2000                  	mov	di,20h
  7151                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7152 00001A9E BE[251F]                	mov	si,KAUTOBAT
  7153 00001AA1 B90800                  	mov	cx,8				; auto execution for the 3/3/kk
  7154 00001AA4 F3A5                    	rep	movsw				; non-english country	3/3/kk
  7155 00001AA6 A4                      	movsb					; move in carraige return to terminate string
  7156                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7157 00001AA7 BA[251F]                	mov	dx,KAUTOBAT
  7158 00001AAA B8003D                  	mov	ax,3D00h
  7159                                  	;mov	ax,OPEN<<8
  7160                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7161 00001AAD CD21                    	int	21h				; see if kautoexe.bat exists  3/3/kk
  7162 00001AAF 7208                    	jc	short NoKabat 			; 3/3/kk
  7163 00001AB1 89C3                    	mov	bx,ax				; 3/3/kk
  7164 00001AB3 B43E                    	mov	ah,3Eh
  7165                                  	;mov	ah,CLOSE			; 3/3/kk
  7166 00001AB5 CD21                    	int	21h				; 3/3/kk
  7167 00001AB7 EB49                    	jmp	short Drv0			; 3/3/kk
  7168                                  
  7169                                  NoKabat:					; 3/3/kk
  7170 00001AB9 FF1E[401F]              	call	far [triage_add]		; get extended error
  7171 00001ABD 83F841                  	cmp	ax,65				; network access denied?
  7172 00001AC0 7506                    	jnz	short OpenErr 			; no - go deallocate batch
  7173                                  
  7174                                  ;%endif ; 06/06/2023 - Retro DOS 4.2 COMMAND.COM
  7175                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7176                                  
  7177                                  AccDenErr:					; yes - put out message
  7178                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7179 00001AC2 BA[C606]                	mov	dx,ACCDEN
  7180 00001AC5 E8C9F8                  	call	RPrint
  7181                                  OpenErr:
  7182                                  ;OPENERR:
  7183 00001AC8 8E06[0502]              	mov	es,[Batch]		; not found--turn off batch job
  7184 00001ACC B449                    	mov	ah,49h
  7185                                  	;mov	ah,DEALLOC ; 49h
  7186 00001ACE CD21                    	int	21h
  7187 00001AD0 C706[0502]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7188 00001AD6 C606[5902]01            	mov	byte [EchoFlag],1
  7189 00001ADB C706[6A02]0000          	mov	word [Nest],0		; indicate no batch in progress
  7190                                  ;DoDttm:
  7191                                  	;mov	ax,offset TranGroup:Datinit
  7192 00001AE1 B8[AE33]                	mov	ax,DATINIT
  7193 00001AE4 A3[381F]                	mov	[INITADD],ax
  7194                                  
  7195                                  	; MSDOS 6.0
  7196                                  ;;M004;;mov	ax,TrnSeg	
  7197                                  ;
  7198                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7199                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7200                                  ; M004; We use TranStart to get the start of the transient segment.
  7201                                  
  7202                                  	; 21/01/2023
  7203                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7204                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7205                                  	; 06/06/2023
  7206                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7207                                  	;
  7208                                  	;mov	ax,TRANSTART
  7209                                  	;mov	cl,4				; M004
  7210                                  	;shr	ax,cl				; get relative seg ; M004
  7211                                  	; 06/06/2023
  7212 00001AE7 B86102                  	mov	ax,TRANSTART>>4	
  7213                                  
  7214 00001AEA 8CC9                    	mov	cx,cs
  7215 00001AEC 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7216                                  
  7217                                  	; 21/01/2023
  7218                                  	; MSDOS 3.3
  7219                                  	; 25/09/2018
  7220                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7221                                  
  7222                                  	; MSDOS 3.3 & MSDOS 6.0
  7223 00001AEE A3[3A1F]                	mov	[INITADD+2],ax
  7224                                  	;call	dword ptr InitAdd
  7225 00001AF1 FF1E[381F]              	call	far [INITADD]
  7226                                  
  7227                                  NoDttm:
  7228                                  	; MSDOS 6.0
  7229                                  	; 21/01/2023
  7230                                  ;Copyright:
  7231                                  	;public	Copyright
  7232                                  ;	Bugbug:	remove Copyright label.
  7233                                  
  7234                                  ;if IBMVER
  7235 00001AF5 833E[6102]00            	cmp	word [SingleCom],0
  7236 00001AFA 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7237                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7238 00001AFC BA[7820]                	mov	dx,COPYRIGHTMSG
  7239 00001AFF E88FF8                  	call	RPrint
  7240                                  ;endif
  7241                                  	; 21/01/2023
  7242                                  	; MSDOS 3.3
  7243                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7244                                  	;jnz	short DRV0
  7245                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7246                                  	;call	RPRINT
  7247                                  ;DRV0:
  7248                                  	; MSDOS 3.3
  7249                                  	;mov	byte [INITFLAG],0
  7250                                  	;jmp	ENDINIT
  7251                                  
  7252                                  	; 21/01/2023
  7253                                  	; MSDOS 6.0
  7254                                  Drv0:						; Reset APPEND state
  7255 00001B02 1E                      	push	ds				; save data segment
  7256 00001B03 0E                      	push	cs				; Get local segment into DS
  7257 00001B04 1F                      	pop	ds				;
  7258 00001B05 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7259                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7260 00001B08 8B1E[7E02]              	mov	bx,[Append_State] 		;  back to the original state
  7261 00001B0C CD2F                    	int	2Fh				;
  7262 00001B0E 1F                      	pop	ds				; get data segment back
  7263                                  
  7264                                  ;Check FirstCom set previously to see if this is the first instance of
  7265                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7266                                  ;jump table from the previous stub to the current stub.
  7267                                  
  7268 00001B0F 803E[CD24]01            	cmp	byte [FirstCom],1		; first command.com?
  7269 00001B14 7429                    	jz	short move_code			; yes, move it
  7270                                  
  7271 00001B16 06                      	push	es
  7272 00001B17 1E                      	push	ds
  7273                                  
  7274 00001B18 1E                      	push	ds
  7275 00001B19 07                      	pop	es
  7276                                  	;mov	di,offset DATARES:Int2f_Entry
  7277 00001B1A BF[0400]                	mov	di,Int2f_Entry	
  7278                                  
  7279 00001B1D 268E1E[CB24]            	mov	ds,[es:ResJmpTable+2]		; get segment address
  7280 00001B22 268B36[C924]            	mov	si,[es:ResJmpTable]		; get offset address
  7281                                  
  7282                                  	;mov	cx,11
  7283                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7284                                  	;shl	cx,1
  7285                                  	;shl	cx,1				; size of table in bytes
  7286                                  	; 21/01/2023
  7287 00001B27 B92C00                  	mov	cx,44				; size of table in bytes
  7288                                  
  7289 00001B2A FC                      	cld
  7290 00001B2B F3A4                    	rep	movsb				; copy the jump table
  7291                                  
  7292                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7293                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7294                                  
  7295 00001B2D 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7296 00001B33 7206                    	jb	short res_low			; no, dont set flag
  7297                                  
  7298 00001B35 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7299                                  res_low:
  7300 00001B3B 1F                      	pop	ds
  7301 00001B3C 07                      	pop	es
  7302 00001B3D EB03                    	jmp	short finish_init
  7303                                  
  7304                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7305                                  ;or to overlay the messages in the data segment if the user has not used the
  7306                                  ;/msg switch.
  7307                                  
  7308                                  move_code:
  7309 00001B3F E88F01                  	call	Move_res_code			; move the code
  7310                                  
  7311                                  finish_init:
  7312                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7313 00001B42 E990E7                  	jmp	EndInit
  7314                                  
  7315                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7316                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7317                                  
  7318                                  GetStrLen:
  7319                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7320                                  ;	Length is returned in CX
  7321                                  
  7322                                  	; MSDOS 3.3 & MSDOS 6.0
  7323 00001B45 31C9                    	xor	cx,cx
  7324                                  NxtChar:
  7325 00001B47 AC                      	lodsb
  7326 00001B48 41                      	inc	cx
  7327 00001B49 08C0                    	or	al,al
  7328 00001B4B 75FA                    	jnz	short NxtChar
  7329 00001B4D C3                      	retn
  7330                                  
  7331                                  	; 29/01/2023
  7332                                  Setup_Seg:
  7333                                  
  7334                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7335                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7336                                  ; code segment is used
  7337                                  ; Segment returned in AX.
  7338                                  
  7339                                  	; MSDOS 3.3 & MSDOS 6.0
  7340 00001B4E A1[4B02]                	mov	ax,[TrnSeg]
  7341 00001B51 803E[4D02]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7342 00001B56 7405                    	je	short setup_end
  7343                                  
  7344                                  ;06/06/2023
  7345                                  %if 0
  7346                                  	push	bx
  7347                                  	mov	bx,cs
  7348                                  	;mov	ax,offset ResGroup:TranStart
  7349                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7350                                  	; 06/06/2023
  7351                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7352                                  	;mov	ax,TRANSTART
  7353                                  	;shr	ax,1
  7354                                  	;shr	ax,1
  7355                                  	;shr	ax,1
  7356                                  	;shr	ax,1
  7357                                  	; 29/01/2023
  7358                                  	mov	ax,TRANSTART>>4
  7359                                  	add	ax,bx
  7360                                  	pop	bx
  7361                                  %endif
  7362                                  	; 06/06/2023
  7363 00001B58 8CC8                    	mov	ax,cs
  7364 00001B5A 056102                  	add	ax,TRANSTART>>4
  7365                                  
  7366                                  setup_end:
  7367 00001B5D C3                      	retn
  7368                                  
  7369                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7370                                  ;RPRINT:
  7371                                  	; MSDOS 3.3
  7372                                  	;push	ax
  7373                                  	;call	SETUP_SEG
  7374                                  	;mov	[PRINTADD+2], ax
  7375                                  	;;call	dword ptr PRINTADD
  7376                                  	;call	far [PRINTADD]
  7377                                  	;pop	ax
  7378                                  	;retn
  7379                                  
  7380                                  	; 29/01/2023
  7381                                  	; MSDOS 6.0
  7382                                  ;***	RPrintParse - display parse error message
  7383                                  ;
  7384                                  ;	ENTRY	DX = parse error #
  7385                                  ;
  7386                                  ;	EXIT	nothing
  7387                                  ;
  7388                                  ;	USED	flags
  7389                                  ;
  7390                                  ;	EFFECTS
  7391                                  ;	  Message is displayed on stdout.
  7392                                  
  7393                                  RPrintParse:	;proc
  7394                                  	;assume	ds:ResGroup,ss:ResGroup
  7395                                  
  7396 00001B5E 52                      	push	dx				; preserve DX
  7397 00001B5F 87DA                    	xchg	bx,dx				; bx = parse error #
  7398                                  						; dx = saved BX
  7399 00001B61 4B                      	dec	bx				; bx = parse error index, from 0
  7400 00001B62 D1E3                    	shl	bx,1				; bx = offset in word table
  7401                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7402 00001B64 8B9F[090A]              	mov	bx,[bx+PARSMSGPTRS]
  7403 00001B68 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7404                                  						; bx = restored
  7405 00001B6A E824F8                  	call	RPrint				; print the message
  7406 00001B6D 5A                      	pop	dx				; restore DX
  7407 00001B6E C3                      	retn
  7408                                  
  7409                                  ;RPrintParse	endp
  7410                                  
  7411                                  	; 29/01/2023
  7412                                  ;PATHCHRCMPR:
  7413                                  	; MSDOS 3.3
  7414                                  	;push	dx
  7415                                  	;mov	dl,[slash_chr]
  7416                                  	;;cmp	byte [RSWITCHAR],'/'
  7417                                          ;cmp	[RSWITCHAR],dl
  7418                                  	;je	short RNOSLASHT
  7419                                  	;;cmp	al,'/'
  7420                                  	;cmp	al,dl
  7421                                  	;je	short RET41 ; zf = 1 
  7422                                  ;RNOSLASHT:
  7423                                          ;;cmp	al,'\'
  7424                                  	;cmp	al,[bslash_chr]
  7425                                  ;RET41:
  7426                                  	;pop	dx
  7427                                  	;retn
  7428                                  
  7429                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7430                                  IfindE:
  7431                                  	; MSDOS 3.3 & MSDOS 6.0
  7432 00001B6F E80300                  	call	ifind				; find the name
  7433                                  	;jc	short ifind2			; carry means not found
  7434                                  	;jmp	short Iscasb1 			; scan for = sign
  7435                                  	; 29/01/2023
  7436 00001B72 733A                    	jnc	short Iscasb1
  7437                                  ifind2:
  7438 00001B74 C3                      	retn
  7439                                  
  7440                                  	; 29/01/2023
  7441                                  
  7442                                  ; on return of find1, es:di points to beginning of name
  7443                                  
  7444                                  ifind:
  7445 00001B75 FC                      	cld
  7446 00001B76 E82700                  	call	Icount0				; cx = length of name
  7447 00001B79 8E06[FA03]              	mov	es,[EnvirSeg]
  7448 00001B7D 31FF                    	xor	di,di
  7449                                  ifind1:
  7450 00001B7F 51                      	push	cx
  7451 00001B80 56                      	push	si
  7452 00001B81 57                      	push	di
  7453                                  ifind11:
  7454 00001B82 AC                      	lodsb
  7455 00001B83 E83400                  	call	iupconv
  7456 00001B86 47                      	inc	di
  7457 00001B87 263A45FF                	cmp	al,[es:di-1]
  7458 00001B8B 7502                    	jnz	short ifind12
  7459 00001B8D E2F3                    	loop	ifind11
  7460                                  ifind12:
  7461 00001B8F 5F                      	pop	di
  7462 00001B90 5E                      	pop	si
  7463 00001B91 59                      	pop	cx
  7464 00001B92 74E0                    	jz	short ifind2
  7465 00001B94 51                      	push	cx
  7466 00001B95 E81A00                  	call	Iscasb2 			; scan for a nul
  7467 00001B98 59                      	pop	cx
  7468                                  	;cmp	byte [es:di],0
  7469                                  	;jnz	short ifind1
  7470                                  	;stc					; indicate not found
  7471 00001B99 26803D01                	cmp	byte [es:di],1
  7472 00001B9D 73E0                    	jnb	short ifind1
  7473                                  	; cf=1					; indicate not found
  7474                                  ;ifind2:
  7475 00001B9F C3                      	retn
  7476                                  
  7477                                  	; 29/01/2023
  7478                                  Icount0:
  7479 00001BA0 1E                      	push	ds
  7480 00001BA1 07                      	pop	es
  7481 00001BA2 89F7                    	mov	di,si
  7482                                  
  7483 00001BA4 57                      	push	di				; count number of chars until "="
  7484 00001BA5 E80600                  	call	Iscasb1
  7485                                  	; 25/09/2018
  7486                                  	;jmp	short Icountx
  7487                                  	;push	di				; count number of chars until nul
  7488                                  	;call	Iscasb2
  7489                                  ;Icountx:
  7490 00001BA8 59                      	pop	cx
  7491 00001BA9 29CF                    	sub	di,cx
  7492 00001BAB 87F9                    	xchg	di,cx
  7493 00001BAD C3                      	retn
  7494                                  
  7495                                  Iscasb1:
  7496                                  	; 29/01/2023
  7497 00001BAE B03D                    	mov	al,"="
  7498                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7499 00001BB0 EB02                    	jmp	short Iscasbx
  7500                                  Iscasb2:
  7501 00001BB2 30C0                    	xor	al,al				; scan for a nul
  7502                                  Iscasbx:
  7503 00001BB4 B90001                  	mov	cx,256 ; 100h
  7504 00001BB7 F2AE                    	repnz	scasb
  7505 00001BB9 C3                      	retn
  7506                                  
  7507                                  	; 29/01/2023
  7508                                  ;IUPCONV:
  7509                                  	; MSDOS 3.3
  7510                                          ;;cmp	al,"a"
  7511                                  	;cmp	al,[letter_a]
  7512                                          ;jb	short IRET22
  7513                                          ;;cmp	al,"z"
  7514                                          ;cmp	al,[letter_z]
  7515                                  	;ja	short IRET22
  7516                                          ;sub	al,20h			; Lower-case changed to upper-case
  7517                                  ;IRET22:
  7518                                  	;retn
  7519                                  
  7520                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7521                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7522                                  
  7523                                  	; MSDOS 6.0
  7524                                  ; *****************************************************************
  7525                                  ; *
  7526                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7527                                  ; *
  7528                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7529                                  ; *		 the character in AL from the file upper case table
  7530                                  ; *		 in DOS if character if above ascii 128, else
  7531                                  ; *		 subtracts 20H if between "a" and "z".
  7532                                  ; *
  7533                                  ; * INPUT:	 DS	      set to resident
  7534                                  ; *		 AL	      char to be upper cased
  7535                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7536                                  ; *
  7537                                  ; * OUTPUT:	 AL	      upper cased character
  7538                                  ; *
  7539                                  ; *****************************************************************
  7540                                  
  7541                                  iupconv:	;proc	near				
  7542                                  	;assume	ds:ResGroup			;
  7543                                  
  7544 00001BBA 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7545 00001BBC 7210                    	jb	short other_fucase		; no - upper case math
  7546 00001BBE 2C80                    	sub	al,80h				; only upper 128 chars in table
  7547 00001BC0 1E                      	push	ds				;
  7548 00001BC1 53                      	push	bx				;
  7549                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7550 00001BC2 C51E[7202]              	lds     bx,[FUCase_Addr+1]
  7551 00001BC6 83C302                  	add	bx,2				; skip over first word
  7552                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7553 00001BC9 D7                      	xlat
  7554 00001BCA 5B                      	pop	bx				;
  7555 00001BCB 1F                      	pop	ds				;
  7556 00001BCC EB0A                    	jmp	short iupconv_end		; we finished - exit
  7557                                  
  7558                                  other_fucase:					;
  7559                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7560 00001BCE 3C61                    	cmp	al,'a'
  7561 00001BD0 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7562                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7563 00001BD2 3C7A                    	cmp	al,'z'
  7564 00001BD4 7702                    	ja	short iupconv_end		;
  7565 00001BD6 2C20                    	sub	al,20h				; Change lower-case to upper
  7566                                  iupconv_end:					;
  7567 00001BD8 C3                      	retn
  7568                                  
  7569                                  ;iupConv endp
  7570                                  
  7571                                  	; 29/01/2023
  7572                                  init_contc_specialcase:
  7573                                  	; MSDOS 3.3 & MSDOS 6.0
  7574                                  						; This routine is called if control-C
  7575 00001BD9 83C406                  	add	sp,6				;  is type during the date/time prompt
  7576 00001BDC 56                      	push	si				;  at initialization time.  The desired
  7577 00001BDD 89D6                    	mov	si,dx				;  response is to make it look like the
  7578 00001BDF C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7579 00001BE4 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7580 00001BE5 CF                      	iret					;  a <CR> in the user's buffer, and
  7581                                  						;  returning directly to the user.
  7582                                  						; In this case the user is TCODE.
  7583                                  
  7584                                  ; ----------------------------------------------------------------------------
  7585                                  
  7586                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7587                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7588                                  
  7589                                  	; MSDOS 6.0
  7590                                  ; ****************************************************************
  7591                                  ; *
  7592                                  ; * ROUTINE:	 Setup_for_messages
  7593                                  ; *
  7594                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7595                                  ; *		 messages as follows:
  7596                                  ; *
  7597                                  ; *		 IF /P and /MSG are entered
  7598                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7599                                  ; *		 ELSE IF /P is entered
  7600                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7601                                  ; *		    remove PARSE ERRORS from memory
  7602                                  ; *		 ELSE
  7603                                  ; *		    remove PARSE ERRORS from memory
  7604                                  ; *		 ENDIF
  7605                                  ; *
  7606                                  ; * INPUT:	 PERMCOM	Set up with user input
  7607                                  ; *		 EXT_MSG	Set up with user input
  7608                                  ; *		 System set up to retain PARSE ERRORS
  7609                                  ; *
  7610                                  ; * OUTPUT:	 registers unchanged
  7611                                  ; *
  7612                                  ; ****************************************************************
  7613                                  
  7614                                  setup_for_messages: ;proc near		
  7615                                  
  7616 00001BE6 53                      	push	bx
  7617 00001BE7 1E                      	push	ds				; save data segment
  7618 00001BE8 06                      	push	es				; save environment segment
  7619 00001BE9 50                      	push	ax				;
  7620 00001BEA 52                      	push	dx				;
  7621 00001BEB 57                      	push	di				;
  7622 00001BEC 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7623 00001BEE 8ED8                    	mov	ds,ax				;
  7624 00001BF0 8EC0                    	mov	es,ax				;
  7625                                  
  7626 00001BF2 803E[5E02]00            	cmp	byte [PermCom],0		; was permcom set?
  7627 00001BF7 743C                    	jz	short no_permcom		; No - don't worry about messages
  7628                                  
  7629                                  ;*	We're permanent. Install our message services int 2f handler.
  7630                                  
  7631 00001BF9 06                      	push	es
  7632                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7633 00001BFA B82F35                  	mov	ax,352Fh
  7634 00001BFD CD21                    	int	21h
  7635                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7636                                  			; AL = interrupt number
  7637                                  			; Return: ES:BX = value of interrupt vector
  7638 00001BFF 891E[7004]              	mov	[Int2fHandler],bx
  7639 00001C03 8C06[7204]              	mov	[Int2fHandler+2],es
  7640 00001C07 07                      	pop	es
  7641                                  
  7642                                  ;	DS = RESGROUP seg addr
  7643                                  
  7644                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7645                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7646                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7647                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7648                                  ; M005; call) goes off into space.
  7649                                  
  7650 00001C08 803E[CD24]00            	cmp	byte [FirstCom],0		; M005
  7651 00001C0D 7416                    	je	short no_msg_hook		; M005
  7652                                  ;
  7653                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7654                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7655                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7656                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7657                                  ; M005; segment matches the command.com PSP and then updates these segments
  7658                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7659                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7660                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7661                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7662                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7663                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7664                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7665                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7666                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7667                                  ; M005; jump to the actual int 2fh entry point.
  7668                                  ;
  7669 00001C0F 1E                      	push	ds				; M005
  7670                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7671 00001C10 BA[AF00]                	mov     dx,Carousel_i2f_Hook
  7672 00001C13 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7673 00001C16 8CD8                    	mov	ax,ds				; M005
  7674 00001C18 40                      	inc	ax				; Relocated cs ; M005
  7675 00001C19 8ED8                    	mov	ds,ax				; M005
  7676                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7677 00001C1B B82F25                  	mov	ax,252Fh
  7678 00001C1E CD21                    	int	21h
  7679                                  			; DOS - SET INTERRUPT VECTOR
  7680                                  			; AL = interrupt number
  7681                                  			; DS:DX = new vector to be used for specified interrupt
  7682 00001C20 1F                      	pop	ds				; M005
  7683                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7684 00001C21 8C1E[B200]              	mov	[Carousel_i2f_Hook+3],ds
  7685                                  						; patch in the cs for jump
  7686                                  no_msg_hook:					; M005
  7687 00001C25 803E[921F]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7688 00001C2A 7516                    	jne	short permcom_end		; no /msg - exit
  7689                                  
  7690                                  permcom_slash_msg:				; Keep messages in memory
  7691                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7692 00001C2C BF[020D]                	mov     di,ExtMsgEnd
  7693 00001C2F 893E[7404]              	mov	[ResMsgEnd],di			; save it
  7694 00001C33 EB0D                    	jmp	short permcom_end		; exit
  7695                                  
  7696                                  no_permcom:					
  7697                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7698 00001C35 803E[921F]01            	cmp	byte [ext_msg],1
  7699 00001C3A 7506                    	jne	short permcom_end		; no - no error
  7700                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7701 00001C3C BA0200                  	mov	dx,2
  7702 00001C3F E81CFF                  	call	RPrintParse
  7703                                  
  7704                                  permcom_end:
  7705 00001C42 5F                      	pop	di				;
  7706 00001C43 5A                      	pop	dx				;
  7707 00001C44 58                      	pop	ax				;
  7708 00001C45 07                      	pop	es				; get environment back
  7709 00001C46 1F                      	pop	ds				;
  7710 00001C47 5B                      	pop	bx
  7711                                  
  7712 00001C48 C3                      	retn					;
  7713                                  
  7714                                  ;setup_for_messages	endp
  7715                                  
  7716                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7717                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7718                                  
  7719                                  	; MSDOS 6.0
  7720                                  
  7721                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7722                                  ;
  7723                                  ;	ENTRY	command-line tail at 81h
  7724                                  ;
  7725                                  ;	EXIT	return if /? not found
  7726                                  ;		terminate if /? found
  7727                                  ;
  7728                                  ;	USED	AX,BX,CX,DX,SI,DI
  7729                                  ;
  7730                                  ;	EFFECTS	Help text displayed if /? found on command line
  7731                                  
  7732                                  CheckHelp:	; proc
  7733                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7734                                  
  7735 00001C49 BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7736                                  	;mov	di,offset RESGROUP:Parse_Command
  7737 00001C4C BF[971F]                	mov	di,PARSE_COMMAND
  7738                                  					; ES:DI = ptr to primary parse block
  7739 00001C4F 31C9                    	xor	cx,cx			; CX = # positional param's found
  7740 00001C51 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7741                                  chParse:
  7742                                  	;call	dword ptr Init_Parse
  7743 00001C53 FF1E[8A1F]              	call	far [Init_Parse]	; call system parser
  7744                                  
  7745                                  	;;cmp	ax,END_OF_LINE
  7746                                  	;cmp	ax,-1 ; 0FFFFh	
  7747                                  	;je	short chRet		; end of command line, no /? found
  7748                                  	;;cmp	ax,RESULT_NO_ERROR
  7749                                  	;;cmp	ax,0
  7750                                  	;;je	short chWhich		; valid syntax element found
  7751                                  	;;jmp	short chParse		; go parse more
  7752                                  	;and	ax,ax ; cmp ax,0
  7753                                  	;jnz	short chParse ; jne
  7754                                  	; 10/06/2023
  7755 00001C57 40                      	inc	ax	; cmp ax,-1
  7756 00001C58 741B                    	jz	short chRet   ; 0FFFFh -> 0
  7757 00001C5A 48                      	dec	ax	; cmp ax,0
  7758 00001C5B 75F6                    	jnz	short chParse ; 1 -> 0
  7759                                  	; ax = 0
  7760                                  chWhich:
  7761                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7762 00001C5D 813E[3A20][1D20]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7763 00001C63 7411                    	je	short chHelp		; /? found - display help & exit
  7764                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7765 00001C65 813E[3A20][0320]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7766                                  	; 06/06/2023
  7767 00001C6B 7408                    	je	short chRet		; /c found - ignore rest of line
  7768                                  	; 29/01/2023
  7769                                  	;jne	short chParse
  7770                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  7771                                  	; MSDOS 6.0
  7772                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7773 00001C6D 813E[3A20][2920]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7774                                  	;je	short chRet		; /k found - ignore rest of line
  7775                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7776                                  	; 06/06/2023
  7777 00001C73 75DE                    	jne	short chParse
  7778                                  chRet:
  7779 00001C75 C3                      	retn
  7780                                  chHelp:
  7781                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7782 00001C76 BE[9724]                	mov	si,HelpMsgs
  7783                                  chHelpNext:
  7784 00001C79 AD                      	lodsw					; AX = ptr to msg
  7785 00001C7A 09C0                    	or	ax,ax
  7786 00001C7C 7407                    	jz	short chHelpDone		; end of list - all done
  7787 00001C7E 89C2                    	mov	dx,ax				; DX = ptr to msg
  7788 00001C80 E80EF7                  	call	RPrint				; display msg
  7789 00001C83 EBF4                    	jmp	short chHelpNext		; go do next msg
  7790                                  
  7791                                  chHelpDone:
  7792 00001C85 CD20                    	int	20h				; terminate program
  7793                                  ;chRet:
  7794 00001C87 C3                      	retn
  7795                                  
  7796                                  ;CheckHelp	endp
  7797                                  
  7798                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7799                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7800                                  
  7801                                  	; MSDOS 6.0
  7802                                  
  7803                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7804                                  ;
  7805                                  ; It determines based on 2 factors:
  7806                                  ;	1. Is this is the first COMMAND?
  7807                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7808                                  ;   The strategy works as follows:
  7809                                  ;
  7810                                  ;	if (First COMMAND)
  7811                                  ;	then if (COMMAND in HIMEM)
  7812                                  ;		ResSize = resident_data;
  7813                                  ;	     else
  7814                                  ;		ResSize = resident_data + resident_code;
  7815                                  ;	else
  7816                                  ;	   ResSize = resident_data;
  7817                                  ;
  7818                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7819                                  ; COMMAND and whether DOS is in HIMEM.
  7820                                  ;
  7821                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7822                                  ;
  7823                                  ;	EXIT:  ResSize = resident size in low memory
  7824                                  ;
  7825                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7826                                  ;
  7827                                  
  7828                                  GET_HMA_ADDR	equ	4A02h
  7829                                  
  7830                                  Setup_res_end:	;proc near
  7831                                  	
  7832 00001C88 1E                      	push	ds
  7833 00001C89 8CC8                    	mov	ax,cs
  7834 00001C8B 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7835                                  	;assume	ds:RESGROUP
  7836                                  
  7837 00001C8D 8B0E[7404]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7838                                  
  7839                                  ;ifndef	ROMDOS
  7840                                  
  7841                                  ;M042 -- Begin changes
  7842                                  ;If messages are to be kept behind, we need to round up the messages to
  7843                                  ;the next para boundary. This is because we have a dummy segment between the
  7844                                  ;data and the resident code segment so that the code segment starts on a
  7845                                  ;para boundary
  7846                                  
  7847                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7848 00001C91 81F9[020D]              	cmp	cx,ExtMsgEnd
  7849 00001C95 7506                    	jne	short calc_res			;no, continue
  7850 00001C97 83C10F                  	add	cx,15				;round up
  7851 00001C9A 83E1F0                  	and	cx,0FFF0h
  7852                                  calc_res:
  7853                                  
  7854                                  ;M042 -- End changes
  7855                                  
  7856 00001C9D 31C0                    	xor	ax,ax
  7857 00001C9F 803E[CD24]01                   	cmp	byte [FirstCom],1		;is it first command.com?
  7858                                  	;jne	short not_first			;no, do not keep code
  7859                                  	; 06/06/2023
  7860 00001CA4 751A                    	jne	short not_first2
  7861                                  
  7862                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7863                                  ;bit 4 of dh is set
  7864                                  
  7865 00001CA6 53                      	push	bx
  7866 00001CA7 51                      	push	cx
  7867                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7868 00001CA8 B80633                  	mov	ax,3306h
  7869 00001CAB CD21                    	int	21h
  7870                                  		; DOS - 5+ Get TRUE Version Number
  7871                                  		; (BL major, BH minor, DL revision, DH flags)
  7872 00001CAD 59                      	pop	cx
  7873                                  
  7874                                  ;bugbug: remove version check after testing
  7875                                  
  7876 00001CAE 80FB05                  	cmp	bl,5				;bl has true version ; M013
  7877 00001CB1 7207                    	jb	short oldver
  7878                                  
  7879 00001CB3 31C0                    	xor	ax,ax
  7880 00001CB5 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  7881                                  	;pop	bx
  7882                                  	;jnz	short not_first			;DOS in HIMEM, code not
  7883                                  						;	resident
  7884                                  	; 29/01/2023
  7885 00001CB8 7503                    	jnz	short not_first_pop
  7886                                  oldver:
  7887                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7888                                  	; 06/06/2023
  7889                                  	;;mov	ax,81Ah ; MSDOS 5.0 and MSDOS 6.22 COMMAND.COM
  7890                                  	; 06/06/2023
  7891                                  	; 29/01/2023
  7892                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  7893                                  	; 03/05/2023
  7894 00001CBA B8(0509)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  7895                                  
  7896                                  not_first_pop:
  7897                                  	; 29/01/2023
  7898 00001CBD 5B                      	pop	bx
  7899                                  
  7900                                  not_first:
  7901                                  
  7902                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  7903                                  
  7904 00001CBE 01C1                    	add	cx,ax
  7905                                  
  7906                                  not_first2:	; 06/06/2023
  7907                                  
  7908                                  ;endif	;not ROMDOS
  7909                                  
  7910 00001CC0 83C10F                  	add	cx,15				;round up to next para
  7911 00001CC3 D1E9                    	shr	cx,1
  7912 00001CC5 D1E9                    	shr	cx,1
  7913 00001CC7 D1E9                    	shr	cx,1
  7914 00001CC9 D1E9                    	shr	cx,1				;ax = para size of res code
  7915 00001CCB 890E[7604]              	mov	[ResSize],cx			;store resident size
  7916                                  
  7917 00001CCF 1F                      	pop	ds
  7918                                  	;assume	ds:nothing
  7919 00001CD0 C3                      	retn
  7920                                  
  7921                                  ;ifndef	ROMDOS
  7922                                  
  7923                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  7924                                  
  7925                                  	; 29/01/2023
  7926                                  ;oldver:
  7927                                  ;	pop	bx
  7928                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7929                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  7930                                  ;	; 29/01/2023
  7931                                  ;	mov	ax,EndCode-RCODE_START
  7932                                  ;	jmp	short not_first
  7933                                  
  7934                                  ;endif	;not ROMDOS
  7935                                  
  7936                                  ;setup_res_end	endp
  7937                                  
  7938                                  ;ifndef	ROMDOS
  7939                                  
  7940                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7941                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  7942                                  
  7943                                  	; MSDOS 6.0
  7944                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  7945                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  7946                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  7947                                  ; the correct resident size. When remaining low, we have to check if we 
  7948                                  ; need to overlay the messages part of the data segment which is determined
  7949                                  ; by the /msg switch.
  7950                                  ;
  7951                                  ;	ENTRY: ResMsgEnd = end of resident data
  7952                                  ;
  7953                                  ;	EXIT:  The resident code is either up high or in its final location
  7954                                  ;		down low.
  7955                                  ;
  7956                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  7957                                  	
  7958                                  Move_res_code:	;proc near
  7959                                  
  7960 00001CD1 1E                      	push	ds
  7961 00001CD2 06                      	push	es
  7962                                  
  7963 00001CD3 8CC8                    	mov	ax,cs
  7964 00001CD5 8ED8                    	mov	ds,ax
  7965                                  	;assume	ds:RESGROUP
  7966                                  
  7967                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  7968 00001CD7 B80633                  	mov	ax,3306h
  7969 00001CDA CD21                    	int	21h				;DOS in HIMEM?
  7970                                  		; DOS - 5+ Get TRUE Version Number
  7971                                  		; (BL major, BH minor, DL revision, DH flags)
  7972                                  
  7973 00001CDC 80E610                  	and	dh,10h				; M013
  7974 00001CDF 750E                    	jnz	short move_high			;yes, move code high
  7975                                  
  7976                                  ;Check if messages have been discarded or not
  7977                                  
  7978                                  load_low:
  7979 00001CE1 1E                      	push	ds
  7980 00001CE2 07                      	pop	es				;es = RESGROUP
  7981 00001CE3 8B3E[7404]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  7982                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  7983                                  	;mov	bx,ExtMsgEnd
  7984                                  	; 29/01/2023
  7985 00001CE7 81FF[020D]              	cmp	di,ExtMsgEnd
  7986                                  	;cmp	di,bx				;are messages to be kept?
  7987 00001CEB 7431                    	je	short no_move			;yes, dont move code
  7988                                  
  7989 00001CED EB37                    	jmp	short setup_move		;es:di points at dest.
  7990                                  
  7991                                  move_high:
  7992                                  
  7993                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  7994                                  ;We pass in bx the number of bytes we need
  7995                                  
  7996                                  	;mov	bx,offset CODERES:EndCode
  7997                                  	; 29/01/2023
  7998                                  	;;mov	bx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  7999                                  	; 06/06/2023
  8000                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8001                                  	; 03/05/2023
  8002 00001CEF BB(0509)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8003                                  
  8004                                  ;M030;
  8005                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8006                                  
  8007 00001CF2 BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8008                                  						;this ; M030
  8009 00001CF5 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8010 00001CF8 CD2F                    	int	2Fh
  8011                                  
  8012                                  ;If the offset = 0xffff, then no HMA available
  8013                                  
  8014 00001CFA 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8015 00001CFD C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8016 00001D02 7522                    	jne	short setup_move		;no error, es:di = memory
  8017                                  
  8018                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8019                                  	; 29/01/2023	
  8020 00001D04 FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8021                                  
  8022                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8023                                  ;ResSize to reflect this
  8024                                  
  8025 00001D08 8B0E[7404]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8026                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8027                                  	;;mov	ax,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8028                                  	;mov	ax,EndCode-RCODE_START
  8029                                  	;add	cx,ax
  8030                                  	; 06/06/2023
  8031                                  	; 29/01/2023
  8032                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8033                                  	;add	cx,15				;round up to next para
  8034                                  	; 03/05/2023
  8035 00001D0C 81C1(1409)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8036 00001D10 D1E9                    	shr	cx,1
  8037 00001D12 D1E9                    	shr	cx,1
  8038 00001D14 D1E9                    	shr	cx,1
  8039 00001D16 D1E9                    	shr	cx,1				;ax = para size of res code
  8040 00001D18 890E[7604]              	mov	[ResSize],cx			;store resident size
  8041 00001D1C EBC3                    	jmp	short load_low			;let code remain low
  8042                                  
  8043                                  no_move:
  8044                                  	; 05/05/2023
  8045                                  	;mov	cl,4
  8046 00001D1E 83C70F                  	add	di,0Fh
  8047 00001D21 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8048 00001D24 EB0B                    	jmp	short patch_up
  8049                                  
  8050                                  setup_move:
  8051                                  	;mov	si,offset RESGROUP:StartCode
  8052                                  	; 03/05/2023
  8053 00001D26 BE[100D]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8054                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8055                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8056                                  	;mov	cx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8057                                  	; 06/06/2023
  8058                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8059                                  	; 03/05/2023
  8060 00001D29 B9(0509)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8061                                  
  8062 00001D2C FC                      	cld
  8063 00001D2D 57                      	push	di				;need di for patching offset
  8064 00001D2E F3A4                    	rep	movsb
  8065 00001D30 5F                      	pop	di
  8066                                  
  8067                                  patch_up:
  8068 00001D31 E86D01                  	call	patch_stub
  8069 00001D34 07                      	pop	es
  8070 00001D35 1F                      	pop	ds
  8071                                  	;assume	ds:nothing
  8072 00001D36 C3                      	retn
  8073                                  
  8074                                  ;Move_res_code endp
  8075                                  
  8076                                  ;else	;ROMDOS
  8077                                  ;
  8078                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8079                                  ;
  8080                                  ;Move_res_code	proc
  8081                                  ;
  8082                                  ;	push	es
  8083                                  ;
  8084                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8085                                  ;	call	patch_stub
  8086                                  ;
  8087                                  ;	pop	es
  8088                                  ;	ret
  8089                                  ;
  8090                                  ;Move_res_code	endp
  8091                                  ;
  8092                                  ;	assume	ds:NOTHING		; to match ending assume above
  8093                                  ;
  8094                                  ;endif	;ROMDOS
  8095                                  
  8096                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8097                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8098                                  
  8099                                  	; MSDOS 6.0
  8100                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8101                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8102                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8103                                  ; the contents of this temporary environment are copied to it. This routine
  8104                                  ; will not be called in case a valid environment is passed to command.com
  8105                                  ;
  8106                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8107                                  ;
  8108                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8109                                  ;
  8110                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8111                                  
  8112                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8113                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1F3Fh
  8114                                  
  8115                                  alloc_env:	;proc near
  8116                                  	;assume ds:nothing
  8117                                  	
  8118 00001D37 1E                              push    ds
  8119 00001D38 06                      	push	es
  8120 00001D39 56                      	push	si
  8121 00001D3A 57                      	push	di
  8122                                  
  8123                                  ; 07/06/2023
  8124                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8125                                  ;%if 0
  8126                                  %if 1 
  8127 00001D3B 16                              push    ss
  8128 00001D3C 1F                              pop     ds
  8129                                  	;assume ds:RESGROUP
  8130                                  
  8131 00001D3D A1[FA03]                        mov     ax,[EnvirSeg]
  8132                                  
  8133 00001D40 803E[441F]00                    cmp	byte [AllocedEnv],0
  8134 00001D45 7403                            je	short alloc_cont
  8135 00001D47 E94C01                          jmp     alloc_done
  8136                                  
  8137                                  alloc_cont:
  8138 00001D4A 29FF                            sub     di,di                           ; default start
  8139                                          ;mov	bx,SIZE Environment             ; default size needed
  8140                                  	; 29/01/2023
  8141 00001D4C BBB400                  	mov	bx,ENVIRONSIZ	; mov bx,180 ; 07/06/2023
  8142                                  
  8143 00001D4F 803E[CD24]00                    cmp	byte [FirstCom],0		; first COMMAND.COM?
  8144 00001D54 747E                            je	short alloc_seg			; no
  8145                                  
  8146                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8147                                  ;   Record their respective locations and do not add the default vars.
  8148                                  
  8149 00001D56 09C0                    	or      ax,ax
  8150 00001D58 7476                    	jz	short alloc_new			; no previous environment
  8151                                  
  8152 00001D5A 8EC0                            mov     es,ax
  8153                                  	;assume es:nothing
  8154                                  
  8155                                  _find_path:
  8156 00001D5C B000                            mov     al,0
  8157 00001D5E 29FF                            sub     di,di
  8158                                  comp_path:
  8159 00001D60 AE                              scasb                                   ; end of env?
  8160 00001D61 7417                    	je	short _find_prompt		; yes
  8161 00001D63 4F                              dec     di
  8162 00001D64 B90500                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8163                                          ;mov	si,offset RESGROUP:PathString
  8164 00001D67 BE[451F]                	mov	si,PathString	; "PATH="
  8165 00001D6A F3A6                            repe    cmpsb
  8166 00001D6C 7407                            je	short got_path
  8167 00001D6E B90001                          mov	cx,256
  8168 00001D71 F2AE                            repne   scasb                           ; find next NULL
  8169 00001D73 EBEB                            jmp     short comp_path
  8170                                  
  8171                                  got_path:
  8172 00001D75 C606[451F]00                    mov	byte [PathString],0		; don't add it
  8173                                  
  8174                                  _find_prompt:
  8175 00001D7A 29FF                            sub     di,di
  8176                                  comp_prompt:
  8177 00001D7C AE                      	scasb                                   ; end of env?
  8178 00001D7D 7417                    	je	short find_comspec		; yes
  8179 00001D7F 4F                      	dec     di
  8180 00001D80 B90700                  	mov     cx,PrmptStrLen2	; mov cx,7
  8181                                  	;mov	si,offset RESGROUP:PrmptString
  8182 00001D83 BE[5B1F]                	mov	si,PrmptString	; "PROMPT=$P$G"   
  8183 00001D86 F3A6                            repe    cmpsb
  8184 00001D88 7407                            je	short got_prompt
  8185 00001D8A B90001                          mov     cx,256
  8186 00001D8D F2AE                            repne   scasb                           ; find next NULL
  8187 00001D8F EBEB                            jmp	short comp_prompt
  8188                                  
  8189                                  got_prompt:
  8190 00001D91 C606[5B1F]00            	mov	byte [PrmptString],0		; don't add it
  8191                                  
  8192                                  find_comspec:
  8193 00001D96 29FF                            sub     di,di
  8194                                  comp_comspec:
  8195 00001D98 AE                              scasb                                   ; end of env?
  8196 00001D99 7423                            je	short got_envend		; yes
  8197 00001D9B 4F                              dec     di
  8198 00001D9C B90800                          mov	cx,ComspStrLen	; mov cx,8
  8199                                  	;mov	si,offset RESGROUP:ComspString
  8200 00001D9F BE[691F]                	mov	si,ComspString	; "COMSPEC=\COMMAND.COM"
  8201 00001DA2 F3A6                            repe    cmpsb
  8202 00001DA4 7407                            je	short got_comspec
  8203 00001DA6 B90001                          mov     cx,256
  8204 00001DA9 F2AE                            repne   scasb                           ; find next NULL
  8205 00001DAB EBEB                            jmp	short comp_comspec
  8206                                  
  8207                                  got_comspec:
  8208 00001DAD 893E[671F]                      mov     [ComspOffset],di
  8209                                  
  8210                                  find_envend:
  8211 00001DB1 29FF                            sub     di,di
  8212 00001DB3 B90080                          mov     cx,ENVBIG	; 32768		; max env size
  8213                                  comp_envend:
  8214 00001DB6 49                              dec     cx                              ;
  8215 00001DB7 AE                              scasb                                   ; end of env?
  8216 00001DB8 7404                            je	short got_envend		; yes
  8217 00001DBA F2AE                            repne   scasb
  8218 00001DBC EBF8                            jmp	short comp_envend
  8219                                  
  8220                                  got_envend:
  8221 00001DBE 4F                              dec     di
  8222                                  	; 07/06/2023
  8223 00001DBF 8D9DB400                	lea     bx,[di+ENVIRONSIZ]		; add room for the basics
  8224                                  
  8225                                  ;   We want to fall through to alloc_new and set up default
  8226                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8227                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8228                                  
  8229 00001DC3 1E                              push    ds
  8230                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8231 00001DC4 8E1E1600                        mov	ds,[PDB.PARENT_PID]
  8232                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8233 00001DC8 833E160000              	cmp	word [PDB.PARENT_PID],0
  8234 00001DCD 1F                      	pop     ds
  8235 00001DCE 7504                            jne	short alloc_seg			; no, we're not the first process
  8236                                                                                  ; so don't muck with the env.
  8237                                  alloc_new:
  8238 00001DD0 FE06[441F]              	inc	byte [AllocedEnv]		; note we have virgin env.
  8239                                  
  8240                                  alloc_seg:
  8241                                  
  8242                                  ; Allocate default environment size
  8243                                  
  8244 00001DD4 89D9                            mov     cx,bx                           ; save byte-granular size in CX
  8245 00001DD6 83C30F                          add     bx,15
  8246 00001DD9 D1EB                            shr     bx,1
  8247 00001DDB D1EB                            shr     bx,1
  8248 00001DDD D1EB                            shr     bx,1
  8249 00001DDF D1EB                            shr     bx,1                            ; BX = # paras
  8250 00001DE1 B448                    	mov	ah,ALLOC ; 48h
  8251 00001DE3 CD21                    	int	21h
  8252 00001DE5 7303                            jnc	short init_ok
  8253 00001DE7 E9B100                          jmp     init_nomem                      ; insufficient memory, error
  8254                                  
  8255                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8256                                  ; the new buffer
  8257                                  
  8258                                  init_ok:
  8259 00001DEA 8EC0                    	mov	es,ax
  8260                                  	;assume	es:nothing                      ; es = temp env segment
  8261                                  
  8262 00001DEC 09FF                    	or      di,di
  8263 00001DEE 7412                            jz	short copy_path
  8264                                  
  8265 00001DF0 51                              push    cx
  8266 00001DF1 1E                              push    ds
  8267 00001DF2 8E1E[FA03]                      mov     ds,[EnvirSeg]
  8268                                          ;assume ds:nothing
  8269 00001DF6 29F6                            sub     si,si
  8270 00001DF8 89F9                            mov     cx,di
  8271 00001DFA 29FF                            sub     di,di
  8272 00001DFC F3A4                            rep     movsb
  8273 00001DFE 1F                              pop     ds
  8274                                          ;assume ds:RESGROUP
  8275 00001DFF 59                              pop     cx
  8276 00001E00 29F9                            sub     cx,di
  8277                                  
  8278                                  copy_path:
  8279                                  
  8280                                  ; First clear out (the rest of) the buffer
  8281                                  
  8282 00001E02 57                              push    di
  8283 00001E03 29C0                            sub     ax,ax
  8284 00001E05 F3AA                            rep     stosb
  8285 00001E07 5F                              pop     di
  8286                                  
  8287                                  ; Initialize the path string (PATH=) first
  8288                                  
  8289                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8290 00001E08 BE[451F]                	mov	si,PathString
  8291 00001E0B 3804                            cmp     byte [si],al			; add it?
  8292 00001E0D 7450                            je	short init_prompt		; no
  8293                                  	;mov	cx,PathStrLen+1                 ;
  8294 00001E0F B90600                  	mov	cx,6 ; db "PATH=",0
  8295 00001E12 F3A4                            rep     movsb                           ;
  8296 00001E14 3806[441F]                      cmp     [AllocedEnv],al			; virgin env?
  8297 00001E18 7445                            je	short init_prompt		; no
  8298                                  
  8299                                  ; Establish a more reasonable default for the PATH
  8300                                  
  8301                                  	;mov	ah,GET_DEFAULT_DRIVE
  8302 00001E1A B419                    	mov	ah,19h
  8303 00001E1C CD21                    	int	21h
  8304 00001E1E 0441                            add     al,'A'                          ; convert to letter
  8305 00001E20 A2[4B1F]                        mov     [DefPathString],al              ;
  8306 00001E23 A2[541F]                        mov     [DefPath2String],al             ; now our default paths are complete
  8307                                  
  8308 00001E26 B200                            mov     dl,0                            ; get dir for default drive
  8309 00001E28 1E                              push    ds                              ;
  8310 00001E29 06                              push    es                              ;
  8311 00001E2A 1F                              pop     ds                              ;
  8312 00001E2B C6055C                          mov     byte [di],'\'			;
  8313 00001E2E 8D7501                          lea     si,[di+1]                       ; set DS:SI -> available space
  8314                                  	;mov	ah,Current_Dir                  ;
  8315 00001E31 B447                            mov	ah,47h
  8316 00001E33 CD21                    	int     21h                             ;
  8317 00001E35 1F                              pop     ds                              ;
  8318                                  
  8319                                  	;mov	cx,DefPathStrLen+1              ;
  8320 00001E36 B90900                  	mov	cx,9 ; db "C:\MSDOS",0
  8321                                  	;mov	dx,offset RESGROUP:DefPathString
  8322 00001E39 BA[4B1F]                	mov	dx,DefPathString	; "C:\MSDOS"
  8323 00001E3C 89D6                    	mov	si,dx                           ;
  8324                                          ;mov	ah,CHDir                        ;
  8325 00001E3E B43B                            mov	ah,3Bh
  8326 00001E40 CD21                    	int     21h                             ;
  8327 00001E42 730E                            jnc	short init_setpath		; DefPathString exists!
  8328                                  
  8329                                  	;mov	cx,DefPath2StrLen+1		;
  8330 00001E44 B90700                          mov	cx,7 ; db "C:\DOS",0
  8331                                  	;mov	dx,offset RESGROUP:DefPath2String
  8332 00001E47 BA[541F]                	mov	dx,DefPath2String	; "C:\DOS"
  8333 00001E4A 89D6                            mov     si,dx                           ;
  8334                                          ;mov	ah,CHDir                        ;
  8335 00001E4C B43B                            mov	ah,3Bh
  8336 00001E4E CD21                            int     21h                             ;
  8337 00001E50 720D                            jc	short init_prompt		; DefPath2String doesn't exist
  8338                                  
  8339                                  init_setpath:
  8340 00001E52 89FA                            mov     dx,di                           ; success
  8341 00001E54 1E                              push    ds                              ; so restore prev dir
  8342 00001E55 06                              push    es                              ;
  8343 00001E56 1F                              pop     ds                              ; DS:DX -> prev dir
  8344                                          ;mov	ah,CHDir                        ;
  8345 00001E57 B43B                            mov	ah,3Bh			
  8346 00001E59 CD21                            int     21h                             ;
  8347 00001E5B 1F                              pop     ds                              ;
  8348                                  
  8349 00001E5C 4F                              dec     di                              ; then copy in DefPathString
  8350 00001E5D F3A4                            rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8351                                  
  8352                                  ; Initialize the default prompt
  8353                                  
  8354                                  init_prompt:
  8355 00001E5F 57                              push    di                              ;
  8356 00001E60 29C0                            sub     ax,ax                           ;
  8357 00001E62 B94000                          mov     cx,64                           ; insure any data read in
  8358 00001E65 F3AA                            rep     stosb                           ; from Current_Dir is zapped
  8359 00001E67 5F                              pop     di                              ;
  8360                                  
  8361 00001E68 3806[441F]              	cmp	[AllocedEnv],al			; virgin env?
  8362 00001E6C 740B                            je	short init_comspec		; no
  8363                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8364 00001E6E BE[5B1F]                        mov	si,PrmptString
  8365 00001E71 3804                    	cmp     [si],al				; add it?
  8366 00001E73 7404                            je      short init_comspec		; no
  8367                                  	;mov	cx,PrmptStrLen+1                ;
  8368 00001E75 B10C                            mov	cl,12  ; db "PROMPT=$P$G",0
  8369 00001E77 F3A4                    	rep     movsb                           ;
  8370                                  
  8371                                  ; Initialize the Comspec string
  8372                                  
  8373                                  init_comspec:
  8374 00001E79 3906[671F]                      cmp	[ComspOffset],ax		; add it?
  8375 00001E7D 750E                            jne	short init_done			; no
  8376                                          ;lea	ax,[di+8]
  8377 00001E7F 8D4508                  	lea     ax,[di+ComspStrLen]             ;
  8378 00001E82 A3[671F]                        mov	[ComspOffset],ax		;
  8379                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8380 00001E85 BE[691F]                        mov	si,ComspString
  8381                                  	;mov	cx,ComspStrLen2+1               ;
  8382 00001E88 B91500                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8383 00001E8B F3A4                    	rep     movsb                           ;
  8384                                  
  8385                                  init_done:
  8386 00001E8D 8CC0                            mov     ax,es                           ; return env seg in ax
  8387 00001E8F A3[FA03]                        mov     [EnvirSeg],ax			; save env seg
  8388 00001E92 FE06[441F]                      inc	byte [AllocedEnv]		; remember that *we* alloced it
  8389                                  %endif
  8390                                  
  8391                                  ; 07/06/2023
  8392                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8393                                  ;%if 1
  8394                                  %if 0
  8395                                  	;mov	bx,10
  8396                                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8397                                  	mov	ah,48h
  8398                                  	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8399                                  			; BX = number of 16-byte paragraphs desired
  8400                                  	jc	short init_nomem
  8401                                  
  8402                                  init_ok:
  8403                                  	mov	es,ax
  8404                                  	;assume	es:nothing                      ; es = temp env segment
  8405                                  
  8406                                  	xor	di,di
  8407                                  	mov	ax,di
  8408                                  	;mov	cx,160	
  8409                                          mov     cx,ENVIRONSIZ
  8410                                          rep	stosb
  8411                                  
  8412                                  init_pathstr:
  8413                                  
  8414                                  ; Initialize the path string (PATH=) first
  8415                                  
  8416                                  	push	ss
  8417                                  	pop	ds
  8418                                  
  8419                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8420                                  	mov	si,PathString
  8421                                  	mov	di,0
  8422                                  init_cp_pathstr:
  8423                                  	lodsb
  8424                                  	stosb
  8425                                  	or	al,al
  8426                                  	jnz	short init_cp_pathstr
  8427                                  
  8428                                  ; Initialize the Comspec string
  8429                                  
  8430                                  init_comspec:
  8431                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8432                                          mov	si,ComspString
  8433                                  	; 05/05/2023
  8434                                  	mov	di,6
  8435                                  init_cp_compstr:
  8436                                  	lodsb
  8437                                  	stosb
  8438                                  	or	al,al
  8439                                  	jnz	short init_cp_compstr
  8440                                  
  8441                                  init_done:
  8442                                          mov     ax,es                           ; return env seg in ax
  8443                                          ;mov	[EnvirSeg],ax			; save env seg
  8444                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8445                                  %endif	
  8446                                  
  8447                                  	; 29/01/2023
  8448                                  alloc_done:
  8449 00001E96 5F                      	pop	di
  8450 00001E97 5E                      	pop	si
  8451 00001E98 07                      	pop	es
  8452 00001E99 1F                              pop     ds
  8453                                  	;assume	ds:nothing
  8454 00001E9A C3                      	retn
  8455                                  
  8456                                  	; 29/01/2023
  8457                                  init_nomem:
  8458                                  
  8459                                  ;We call the error routine from here. This routine never returns. It either
  8460                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8461                                  ;the system ( if it is the first COMMAND.COM ).
  8462                                  
  8463 00001E9B E80000                  	call	Alloc_error
  8464                                  
  8465                                  ;Alloc_env	endp
  8466                                  
  8467                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8468                                  ; check if this is a permanent or secondary command.com and take the 
  8469                                  ; appropriate action.
  8470                                  ;
  8471                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8472                                  ;
  8473                                  ;	EXIT:	None - does not return
  8474                                  ;
  8475                                  ;	REGISTERS AFFECTED: Does not matter
  8476                                  ;
  8477                                  
  8478                                  ;public Alloc_error
  8479                                  Alloc_error:	;proc	near
  8480                                  
  8481                                  	;jmp	RESGROUP:BadMemErr
  8482                                  	; 29/01/2023
  8483 00001E9E E979EF                  	jmp	BadMemErr	
  8484                                  	
  8485                                  ;Alloc_error	endp
  8486                                  
  8487                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8488                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8489                                  
  8490                                  	; MSDOS 6.0
  8491                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8492                                  ; the stub table of the various entry points in the resident code segment.
  8493                                  ; Some of them are interrupt entry points and some of them are entries from
  8494                                  ; the transient to the resident code segment.
  8495                                  ;
  8496                                  ;	ENTRY:	ds = RESGROUP
  8497                                  ;		es:di = segment:offset of final location of resident code
  8498                                  ;
  8499                                  ;	EXIT:	All segments and offsets patched into the stub table
  8500                                  ;
  8501                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8502                                  
  8503                                  patch_stub:	;proc near
  8504                                  	;assume	ds:RESGROUP
  8505                                  	
  8506 00001EA1 06                      	push	es
  8507                                  
  8508 00001EA2 8CC3                    	mov	bx,es			;bx = resident code segment
  8509 00001EA4 89FA                    	mov	dx,di
  8510                                  	;mov	di,offset DATARES:Int2f_Entry
  8511 00001EA6 BF[0400]                	mov	di,Int2f_Entry
  8512                                  	;mov	si,offset RESGROUP:Reloc_Table
  8513 00001EA9 BE[B324]                	mov	si,Reloc_Table
  8514 00001EAC 1E                      	push	ds
  8515 00001EAD 07                      	pop	es			;es = RESGROUP = DATARES
  8516                                  
  8517                                  ;bx:dx = segment:offset of resident code segment
  8518                                  ;es:di = entry point table in stub
  8519                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8520                                  
  8521                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8522 00001EAE B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8523                                  patchlp:
  8524 00001EB1 AD                      	lodsw				;get current offset
  8525 00001EB2 01D0                    	add	ax,dx			;offset it by code seg location 
  8526 00001EB4 AB                      	stosw				;store offset
  8527 00001EB5 89D8                    	mov	ax,bx			
  8528 00001EB7 AB                      	stosw				;store segment 
  8529 00001EB8 E2F7                    	loop	patchlp
  8530                                  
  8531 00001EBA 07                      	pop	es
  8532 00001EBB C3                      	retn
  8533                                  
  8534                                  ;Patch_stub	endp
  8535                                  
  8536                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8537                                  
  8538                                  	; MSDOS 6.0
  8539                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8540                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8541                                  ; are temporarily needed to handle these interrupts if they occur before
  8542                                  ; the resident is relocated to its final position and all the addresses of
  8543                                  ; the handlers have been updated.
  8544                                  ;
  8545                                  ;	ENTRY:	es = PSP segment = code segment
  8546                                  ;
  8547                                  ;	EXIT:	Current segment values patched into the jump table in the
  8548                                  ;		stub.
  8549                                  ;
  8550                                  ;	REGISTERS AFFECTED: ax, cx, di
  8551                                  
  8552                                  patch_segs:	;proc near
  8553                                  
  8554                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8555 00001EBC BF[0400]                	mov	di,Int2f_Entry 
  8556 00001EBF B90400                  	mov	cx,4			;we have to patch 4 handlers
  8557 00001EC2 83C702                  	add	di,2
  8558 00001EC5 8CC0                    	mov	ax,es
  8559                                  pseglp:
  8560 00001EC7 AB                      	stosw				;store the segment value
  8561 00001EC8 83C702                  	add	di,2			;skip the next offset value
  8562 00001ECB E2FA                    	loop	pseglp
  8563                                  
  8564 00001ECD C3                      	retn
  8565                                  
  8566                                  ;Patch_segs	endp
  8567                                  
  8568                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8569                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8570                                  
  8571                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8572                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:20D8h
  8573                                  
  8574                                  	; MSDOS 6.0
  8575                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8576                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8577                                  ; and is used by the stub when we have to jump to the resident in HMA
  8578                                  ;
  8579                                  ;	ENTRY:	ds = RESGROUP
  8580                                  ;
  8581                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8582                                  ;
  8583                                  ;	REGISTERS AFFECTED:
  8584                                  ;
  8585                                  
  8586                                  get_XMMAddr:	;proc near
  8587                                  	;assume	ds:RESGROUP
  8588                                  
  8589 00001ECE 06                      	push	es
  8590                                  
  8591                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8592 00001ECF B80043                  	mov	ax,4300h
  8593 00001ED2 CD2F                    	int	2Fh
  8594                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8595                                  		; Return: AL = 80h XMS driver installed
  8596                                  		; AL <> 80h no driver
  8597 00001ED4 3C80                    	cmp	al,80h			; Q: installed
  8598 00001ED6 750D                    	jne	short cXMMexit		; N: set error, quit
  8599                                  ;
  8600                                  ; get the XMM control functions entry point, save it, we
  8601                                  ; need to call it later.
  8602                                  ;
  8603                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8604 00001ED8 B81043                  	mov	ax,4310h
  8605 00001EDB CD2F                    	int	2Fh
  8606                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8607                                  		; Return: ES:BX -> driver entry point
  8608                                  
  8609 00001EDD 891E[3000]              	mov	[XMMCallAddr], bx
  8610 00001EE1 8C06[3200]              	mov	[XMMCallAddr+2],es
  8611                                  cXMMexit:
  8612 00001EE5 07                      	pop	es
  8613 00001EE6 C3                      	retn				; done
  8614                                  
  8615                                  ;get_XMMAddr	endp
  8616                                  
  8617                                  ;=============================================================================
  8618                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8619                                  ;=============================================================================
  8620                                  ; 24/09/2018 - Retro DOS v3.0
  8621                                  
  8622                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8623                                  
  8624                                  ; TITLE	COMMAND Initialization messages
  8625                                  
  8626                                  ;INIT	SEGMENT PUBLIC PARA
  8627                                  
  8628                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8629                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8630                                  
  8631                                  	; 25/09/2018
  8632                                  	; (15 bytes filler)
  8633 00001EE7 00                      	db 0
  8634                                  	;db "25/9/2018 ETAN"
  8635                                  	; 30/01/2023
  8636                                  	;db "30/1/2023 ETAN"	
  8637                                  	; 19/06/2023
  8638 00001EE8 31392F362F32303233-     	db "19/6/2023 ETAN"	
  8638 00001EF1 204554414E         
  8639 00001EF6 00                      	db 0
  8640                                  
  8641                                  ; 30/01/2023
  8642                                  %if 0
  8643                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8644                                  	;dw 0
  8645                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8646                                  	db 0Dh,0Ah
  8647                                  	db 0Dh,0Ah
  8648                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8649                                  	db 0Dh,0Ah
  8650                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8651                                  	db ' ',0Dh,0Ah
  8652                                  	db '                                                   ',
  8653                                  	db 0Dh,0Ah,0
  8654                                  
  8655                                  	times	43 db 20h
  8656                                  
  8657                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8658                                  BADCOMLKMES:
  8659                                  	dw _152Fh
  8660                                  
  8661                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8662                                  BADCOMACCMSG:
  8663                                  	dw _155Ah
  8664                                  
  8665                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8666                                  ACCDENERR:
  8667                                  	dw _1593h
  8668                                  
  8669                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8670                                  OUTENVMSG:
  8671                                  	dw _15A5h
  8672                                  
  8673                                  BADVERMSG:
  8674                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8675                                  
  8676                                  BADENVSIZMSG:
  8677                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8678                                  
  8679                                  HEADERPTR:
  8680                                  	dw COPYRIGHTMSG
  8681                                  %endif
  8682                                  
  8683                                  ; 30/01/2023
  8684                                  ;align 16
  8685                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8686                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8687                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8688                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:2100h 
  8689                                  ICONDEV:
  8690 00001EF7 2F4445562F                      db '/DEV/'
  8691 00001EFC 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8692                                  BADCSPFL:
  8693 00001F05 00                      	db 0
  8694                                  COMSPECT:
  8695 00001F06 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8695 00001F0F 434F4D00           
  8696 00001F13 00                      	db 0
  8697                                  AUTOBAT:
  8698 00001F14 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8698 00001F1D 45432E424154000D   
  8699                                  ; 07/06/2023
  8700                                  KAUTOBAT:
  8701 00001F25 003A5C4B4155544F45-     	db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8701 00001F2E 5845432E424154000D 
  8702                                  PRDATTM:
  8703 00001F37 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8704                                  INITADD:
  8705 00001F38 00000000                	dd 0
  8706                                  print_add:
  8707 00001F3C [2B55]                  	dw Printf_Init
  8708 00001F3E 0000                    	dw 0
  8709                                  triage_add:
  8710 00001F40 [EE31]                  	dw Triage_Init
  8711 00001F42 0000                    	dw 0
  8712                                  ;CHUCKENV:
  8713                                  AllocedEnv:
  8714 00001F44 00                      	db 0
  8715                                  
  8716                                  ; 30/01/2023 - MSDOS 3.3
  8717                                  ;COMSPOFFSET:
  8718                                  ;ECOMLOC:
  8719                                  ;	;dw 0Eh
  8720                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8721                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8722                                  ;COMSPSTRING:
  8723                                  ;	db 'COMSPEC='
  8724                                  
  8725                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8726                                  PathString:
  8727 00001F45 504154483D00            	db 'PATH=',0
  8728                                  PathStrLen equ $-PathString-1
  8729                                  ;;;
  8730                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8731                                  ; MSDOS 6.0
  8732                                  DefPathString:
  8733 00001F4B 433A5C4D53444F5300      	db 'C:\MSDOS',0
  8734                                  DefPathStrLen equ $-DefPathString-1
  8735                                  DefPath2String:
  8736 00001F54 433A5C444F5300          	db 'C:\DOS',0
  8737                                  DefPath2StrLen equ $-DefPath2String-1
  8738                                  
  8739                                  PrmptString:
  8740 00001F5B 50524F4D50543D2450-     	db 'PROMPT=$P$G',0
  8740 00001F64 244700             
  8741                                  PrmptStrLen equ $-PrmptString-1
  8742                                  PrmptStrLen2 equ 7		; length of PROMPT=
  8743                                  ComspOffset:
  8744 00001F67 0000                    	dw 0
  8745                                  ;;;
  8746                                  ComspString:
  8747 00001F69 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8747 00001F72 434F4D4D414E442E43-
  8747 00001F7B 4F4D00             
  8748                                  ComspStrLen equ 8		; length of COMSPEC=
  8749                                  ComspStrLen2 equ $-ComspString-1
  8750                                  				; length of full COMSPEC
  8751                                  	; 29/01/2023
  8752                                  ;equal_sign:
  8753                                  ;equalsign:
  8754                                  ;	db '='
  8755                                  ;letter_a:
  8756                                  ;lcasea:
  8757                                  ;	db 'a'
  8758                                  ;letter_z:
  8759                                  ;lcasez:
  8760                                  ;	db 'z'
  8761                                  	; 30/01/2023
  8762                                  ;;slash_chr:
  8763                                  ;;	db '/'
  8764                                  ;;bslash_chr:
  8765                                  ;;	db '\'
  8766                                  ;space_chr:
  8767                                  ;;space:
  8768                                  ;	db 20h
  8769                                  ;;letter_p:
  8770                                  ;;	db 'p'
  8771                                  ;;letter_d:
  8772                                  ;;	db 'd'
  8773                                  ;;letter_c:
  8774                                  ;;	db 'c'
  8775                                  	; 16/04/2023
  8776                                  ; MSDOS 5.0 & MSDOS 6.0
  8777                                  ;scswitch:
  8778                                  ;	db 'C'		; Single command
  8779                                  ;;skswitch:
  8780                                  ;	db 'K' ; MSDOS 6.0
  8781                                  ;;letter_A:
  8782                                  ;ucasea: ; 21/01/2023 
  8783                                  ;	db 'A'
  8784                                  
  8785                                  	; 30/01/2023
  8786                                  EnvSiz:
  8787 00001F7E 0000                    	dw 0		; size user wants to allocate
  8788                                  EnvMax:
  8789 00001F80 0000                    	dw 0		; maximum size allowed
  8790                                  OldEnv:
  8791 00001F82 0000                    	dw 0		; envirseg at initialization
  8792                                  UsedEnv:
  8793 00001F84 0000                    	dw 0		; amount of envirseg used
  8794                                  	; MSDOS 5.0 & MSDOS 6.0
  8795                                  PARS_MSG_OFF:
  8796 00001F86 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8797                                  PARS_MSG_SEG:
  8798 00001F88 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8799                                  
  8800                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8801                                  
  8802                                  Init_Parse:
  8803                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8804                                  init_p:
  8805 00001F8A [2755]                  	dw append_parse
  8806                                  initend:
  8807 00001F8C 0000                    	dw 0		; segment address of end of init
  8808                                  TrnSize:
  8809 00001F8E 0000                    	dw 0		; size of transient in paragraphs
  8810                                  resetenv:
  8811 00001F90 0000                    	dw 0		; set if we need to setblck env at endinit
  8812                                  
  8813                                  ext_msg:
  8814 00001F92 00                      	db 0		; set if /MSG switch entered
  8815                                  eswitch:
  8816 00001F93 00                      	db 0		; set if /e was entered
  8817                                  dswitch:
  8818 00001F94 00                      	db 0		; set if /d was entered
  8819                                  parsemes_ptr:
  8820 00001F95 0000                    	dw 0		; word to store parse error number
  8821                                  
  8822                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8823                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h
  8824                                  
  8825                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8826                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:21A5h 
  8827                                  
  8828                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8829                                  ;  The following parse control block is used for COMMAND. This block is
  8830                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8831                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8832                                  ;
  8833                                  ;  Anything on the command line after the /C switch will be passed to the
  8834                                  ;  executable command, so if /C is used, it must be specified last. The
  8835                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8836                                  ;
  8837                                  ;  The /? switch causes help text to be displayed. Any other options
  8838                                  ;  on the command line are ignored. Command.com will not load if /?
  8839                                  ;  is specified.
  8840                                  
  8841                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8842                                  PARSE_COMMAND:
  8843 00001F97 [9A1F]                  	dw COMMAND_PARMS
  8844 00001F99 00                      	db 0			; no extra delimiter
  8845                                  COMMAND_PARMS:
  8846 00001F9A 0002                    	db 0,2			; 1 positional parm
  8847 00001F9C [B41F]                  	dw COMMAND_FILE
  8848 00001F9E [B41F]                  	dw COMMAND_FILE
  8849                                          ; MSDOS 5.0
  8850                                  	;db 7			; 7 switches
  8851                                  	; MSDOS 6.0
  8852                                  	;db 8 			; 8 switches
  8853                                  	; 07/06/2023
  8854                                  	; MSDOS 6.22
  8855 00001FA0 09                      	db 9			; 9 switches
  8856 00001FA1 [BD1F]                  	dw COMMAND_SWITCH1
  8857 00001FA3 [C91F]                  	dw COMMAND_SWITCH2
  8858 00001FA5 [D51F]                  	dw COMMAND_SWITCH3
  8859 00001FA7 [E11F]                  	dw COMMAND_SWITCH4
  8860 00001FA9 [FA1F]                  	dw COMMAND_SWITCH5
  8861 00001FAB [0620]                  	dw COMMAND_SWITCH6
  8862 00001FAD [1420]                  	dw COMMAND_SWITCH7
  8863                                  	; 07/06/2023
  8864 00001FAF [2020]                  	dw COMMAND_SWITCH8 ; MSDOS 6.0
  8865 00001FB1 [2C20]                  	dw COMMAND_SWITCH9 ; MSDOS 6.22
  8866 00001FB3 00                      	db 0			; no keywords
  8867                                  
  8868                                  COMMAND_FILE:
  8869 00001FB4 0102                    	dw 0201h		; filespec - optional
  8870 00001FB6 0100                    	dw 1			; capitalize - file table
  8871 00001FB8 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8872 00001FBA [4020]                  	dw NO_VAL 		;
  8873 00001FBC 00                      	db 0			; no keywords
  8874                                  
  8875                                  COMMAND_SWITCH1:
  8876 00001FBD 0000                    	dw 0			; no match flags
  8877 00001FBF 0200                    	dw 2			; capitalize by char table
  8878 00001FC1 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8879 00001FC3 [4020]                  	dw NO_VAL 		;
  8880 00001FC5 01                      	db 1			; 1 keyword
  8881                                  COMMAND_P_SYN:
  8882 00001FC6 2F5000                  	db '/P',0		; /P switch
  8883                                  
  8884                                  COMMAND_SWITCH2:
  8885 00001FC9 0000                    	dw 0			; no match flags
  8886 00001FCB 0200                    	dw 2			; capitalize by char table
  8887 00001FCD [3820]                  	dw COMND1_OUTPUT	; result buffer
  8888 00001FCF [4020]                  	dw NO_VAL 		;
  8889 00001FD1 01                      	db 1			; 1 keyword
  8890                                  COMMAND_F_SYN:
  8891 00001FD2 2F4600                  	db '/F',0		; /F switch
  8892                                  
  8893                                  COMMAND_SWITCH3:
  8894 00001FD5 0000                    	dw 0			; no match flags
  8895 00001FD7 0200                    	dw 2			; capitalize by char table
  8896 00001FD9 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8897 00001FDB [4020]                  	dw NO_VAL 		;
  8898 00001FDD 01                      	db 1			; 1 keyword
  8899                                  COMMAND_D_SYN:
  8900 00001FDE 2F4400                  	db '/D',0		; /D switch
  8901                                  
  8902                                  COMMAND_SWITCH4:
  8903 00001FE1 0080                    	dw 8000h		; numeric value - required
  8904 00001FE3 0000                    	dw 0			; no function flags
  8905 00001FE5 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8906 00001FE7 [ED1F]                  	dw COMMAND_E_VAL	; pointer to value list
  8907 00001FE9 01                      	db 1			; 1 keyword
  8908                                  COMMAND_E_SYN:
  8909 00001FEA 2F4500                  	db '/E',0		; /E switch
  8910                                  
  8911                                  COMMAND_E_VAL:
  8912 00001FED 01                      	db 1			;
  8913 00001FEE 01                      	db 1			; 1 range
  8914 00001FEF 01                      	db 1			; returned if result
  8915                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  8916                                  	; MSDOS 5.0 COMMAND.COM
  8917                                  	; (RESGROUP:1F2Bh)
  8918 00001FF0 A0000000                	dd 160	 ; ENVSML
  8919 00001FF4 00800000                	dd 32768 ; ENVBIG
  8920 00001FF8 00                      	db 0			; no numeric values
  8921 00001FF9 00                      	db 0			; no string values
  8922                                  
  8923                                  COMMAND_SWITCH5:
  8924 00001FFA 0000                    	dw 0			; no match flags
  8925 00001FFC 0200                    	dw 2			; capitalize by char table
  8926 00001FFE [3820]                  	dw COMND1_OUTPUT	; result buffer
  8927 00002000 [4020]                  	dw NO_VAL 		;
  8928 00002002 01                      	db 1			; 1 keyword
  8929                                  COMMAND_C_SYN:
  8930 00002003 2F4300                  	db '/C',0		; /C switch
  8931                                  
  8932                                  COMMAND_SWITCH6:
  8933 00002006 0000                    	dw 0			; no match flags
  8934 00002008 0200                    	dw 2			; capitalize by char table
  8935 0000200A [3820]                  	dw COMND1_OUTPUT	; result buffer
  8936 0000200C [4020]                  	dw NO_VAL 		;
  8937 0000200E 01                      	db 1			; 1 keyword
  8938                                  COMMAND_M_SYN:
  8939 0000200F 2F4D534700              	db '/MSG',0		; /MSG switch
  8940                                  
  8941                                  COMMAND_SWITCH7:
  8942 00002014 0000                    	dw 0			; no match flags
  8943 00002016 0200                    	dw 2			; capitalize by char table
  8944 00002018 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8945 0000201A [4020]                  	dw NO_VAL 		;
  8946 0000201C 01                      	db 1			; 1 keyword
  8947                                  COMMAND_?_SYN:
  8948 0000201D 2F3F00                  	db '/?',0 		; /? switch
  8949                                  
  8950                                  	; 07/06/2023
  8951                                  	; MSDOS 6.0
  8952                                  COMMAND_SWITCH8:
  8953 00002020 0000                    	dw 0			; no match flags
  8954 00002022 0200                    	dw 2			; capitalize by char table
  8955 00002024 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8956 00002026 [4020]                  	dw NO_VAL 		;
  8957 00002028 01                      	db 1			; 1 keyword
  8958                                  COMMAND_K_SYN:
  8959 00002029 2F4B00                  	db '/K',0		; /K switch
  8960                                  
  8961                                  	; 07/06/2023
  8962                                  	; MSDOS 6.22
  8963                                  COMMAND_SWITCH9:
  8964 0000202C 0000                    	dw 0			; no match flags
  8965 0000202E 0200                    	dw 2			; capitalize by char table
  8966 00002030 [3820]                  	dw COMND1_OUTPUT	; result buffer
  8967 00002032 [4020]                  	dw NO_VAL 		;
  8968 00002034 01                      	db 1			; 1 keyword
  8969                                  COMMAND_Y_SYN:
  8970 00002035 2F5900                  	db '/Y',0		; /Y switch
  8971                                  
  8972                                  COMND1_OUTPUT:
  8973                                  COMND1_TYPE:
  8974 00002038 00                      	db 0			; type
  8975                                  COMND1_CODE:
  8976 00002039 00                      	db 0			; return value
  8977                                  COMND1_SYN:
  8978 0000203A 0000                    	dw 0			; synonym pointer
  8979                                  COMND1_ADDR:
  8980 0000203C 00000000                	dd 0			; numeric value / address
  8981                                  					; of string value
  8982                                  NO_VAL:
  8983 00002040 00                      	db 0			; no values
  8984                                  num_positionals:
  8985 00002041 0000                    	dw 0			; counter for positionals
  8986                                  old_parse_ptr:
  8987 00002043 0000                    	dw 0			; SI position before calling parser
  8988                                  
  8989                                  	; 30/01/2023
  8990                                  ;***	INITIALIZATION MESSAGES
  8991                                  ;	-------------------------
  8992                                  ;	include	comimsg.inc	;M00
  8993                                  ;-----------------------------------------------------------------------------	
  8994                                  
  8995                                  BADVERMSG:
  8996 00002045 17                      	db 23
  8997 00002046 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  8997 0000204F 20444F532076657273-
  8997 00002058 696F6E0D0A         
  8998                                  OUTENVMSG:
  8999 0000205D 1A                      	db 26
  9000 0000205E 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9000 00002067 7669726F6E6D656E74-
  9000 00002070 2073706163650D0A   
  9001                                  
  9002                                  ; 07/06/2023
  9003                                  ;COPYRIGHTMSG:
  9004                                  ;	db 94
  9005                                  ;	db 0Dh,0Ah
  9006                                  ;	db 0Dh,0Ah
  9007                                  ;	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9008                                  ;	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9009                                  
  9010                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9011                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:2286h
  9012                                  COPYRIGHTMSG:
  9013 00002078 5E                      	db 94
  9014 00002079 0D0A                    	db 0Dh,0Ah
  9015 0000207B 0D0A                    	db 0Dh,0Ah
  9016 0000207D 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 6.22',0Dh,0Ah
  9016 00002086 285229204D532D444F-
  9016 0000208F 532852292056657273-
  9016 00002098 696F6E20362E32320D-
  9016 000020A1 0A                 
  9017 000020A2 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1994.',0Dh,0Ah
  9017 000020AB 20202020284329436F-
  9017 000020B4 70797269676874204D-
  9017 000020BD 6963726F736F667420-
  9017 000020C6 436F72702031393831-
  9017 000020CF 2D313939342E0D0A   
  9018                                  
  9019                                  BADCOMLKMES:
  9020 000020D7 28                      	db 40
  9021 000020D8 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9021 000020E1 20434F4D4D414E4420-
  9021 000020EA 736561726368206469-
  9021 000020F3 726563746F72792062-
  9021 000020FC 61640D0A           
  9022                                  	; 07/06/2023
  9023                                  BADCOMACCMSG:
  9024 00002100 37                      	db 55
  9025 00002101 537065636966696564-     	db 'Specified COMMAND search directory bad, access denied',0Dh,0Ah
  9025 0000210A 20434F4D4D414E4420-
  9025 00002113 736561726368206469-
  9025 0000211C 726563746F72792062-
  9025 00002125 61642C206163636573-
  9025 0000212E 732064656E6965640D-
  9025 00002137 0A                 
  9026                                  HELPMSG1:
  9027 00002138 38                      	db 56
  9028 00002139 537461727473206120-     	db 'Starts a new copy of the MS-DOS command interpreter.',0Dh,0Ah
  9028 00002142 6E657720636F707920-
  9028 0000214B 6F6620746865204D53-
  9028 00002154 2D444F5320636F6D6D-
  9028 0000215D 616E6420696E746572-
  9028 00002166 7072657465722E0D0A 
  9029 0000216F 0D0A                    	db 0Dh,0Ah
  9030                                  
  9031                                  ;HELPMSG2:
  9032                                  ;	db 70
  9033                                  ;	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9034                                  ;	db 0Dh,0Ah
  9035                                  ;	db 0Dh,0Ah
  9036                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9037                                  HELPMSG2:
  9038 00002171 38                      	db 56
  9039 00002172 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P [/MSG]]',0Dh,0Ah
  9039 0000217B 5B64726976653A5D70-
  9039 00002184 6174685D205B646576-
  9039 0000218D 6963655D205B2F453A-
  9039 00002196 6E6E6E6E6E5D205B2F-
  9039 0000219F 50205B2F4D53475D5D-
  9039 000021A8 0D0A               
  9040                                  HELPMSG3:
  9041 000021AA 2A                      	db 42
  9042 000021AB 20202020202020205B-     	db '        [/Y [/C command | /K command]]',0Dh,0Ah
  9042 000021B4 2F59205B2F4320636F-
  9042 000021BD 6D6D616E64207C202F-
  9042 000021C6 4B20636F6D6D616E64-
  9042 000021CF 5D5D0D0A           
  9043 000021D3 0D0A                    	db 0Dh,0Ah
  9044                                  
  9045                                  ;HELPMSG3:
  9046                                  HELPMSG4:
  9047 000021D5 48                              db 72
  9048 000021D6 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9048 000021DF 5D7061746820202020-
  9048 000021E8 537065636966696573-
  9048 000021F1 207468652064697265-
  9048 000021FA 63746F727920636F6E-
  9048 00002203 7461696E696E672043-
  9048 0000220C 4F4D4D414E442E434F-
  9048 00002215 4D20               
  9049 00002217 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9050                                  ;HELPMSG4:
  9051                                  HELPMSG5:
  9052 0000221E 4D                      	db 77
  9053 0000221F 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9053 00002228 202020202020202020-
  9053 00002231 537065636966696573-
  9053 0000223A 207468652064657669-
  9053 00002243 636520746F20757365-
  9053 0000224C 20666F7220636F6D6D-
  9053 00002255 616E6420696E707574-
  9053 0000225E 20616E6420         
  9054 00002263 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9055                                  ;HELPMSG5:
  9056                                  HELPMSG6:
  9057 0000226C 45                      	db 69
  9058 0000226D 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9058 00002276 6E2020202020202020-
  9058 0000227F 536574732074686520-
  9058 00002288 696E697469616C2065-
  9058 00002291 6E7669726F6E6D656E-
  9058 0000229A 742073697A6520746F-
  9058 000022A3 206E6E6E6E6E206279-
  9058 000022AC 7465732E           
  9059 000022B0 0D0A                    	db 0Dh,0Ah
  9060                                  ;HELPMSG6:
  9061                                  HELPMSG7:
  9062 000022B2 4D                      	db 77
  9063 000022B3 20202F502020202020-     	db '  /P              Makes the new Command Interpreter permanent '
  9063 000022BC 202020202020202020-
  9063 000022C5 4D616B657320746865-
  9063 000022CE 206E657720436F6D6D-
  9063 000022D7 616E6420496E746572-
  9063 000022E0 707265746572207065-
  9063 000022E9 726D616E656E7420   
  9064 000022F1 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9064 000022FA 6974292E0D0A       
  9065                                  ;HELPMSG7:
  9066                                  HELPMSG8:
  9067                                  	;db 80
  9068                                  	;db '  /C string       Carries out the command specified by string, and '
  9069                                  	;db 'then stops.',0Dh,0Ah
  9070                                  	; 07/06/2023
  9071 00002300 46                      	db 70
  9072 00002301 20202F4D5347202020-     	db '  /MSG            Stores all error messages in memory (requires /P).'
  9072 0000230A 202020202020202020-
  9072 00002313 53746F72657320616C-
  9072 0000231C 6C206572726F72206D-
  9072 00002325 657373616765732069-
  9072 0000232E 6E206D656D6F727920-
  9072 00002337 287265717569726573-
  9072 00002340 202F50292E         
  9073 00002345 0D0A                    	db 0Dh,0Ah
  9074                                  ;HELPMSG8:
  9075                                  HELPMSG9:
  9076                                  	;db 78
  9077                                  	;db '  /MSG            Specifies that all error messages be stored in '
  9078                                  	;db 'memory. You',0Dh,0Ah
  9079                                  ;HELPMSG9:
  9080                                  	;db 56
  9081                                  	;db '                  need to specify /P with this switch.',0Dh,0Ah
  9082 00002347 4A                      	db 74
  9083 00002348 20202F592020202020-     	db '  /Y              Steps through the batch program specified by /C'
  9083 00002351 202020202020202020-
  9083 0000235A 537465707320746872-
  9083 00002363 6F7567682074686520-
  9083 0000236C 62617463682070726F-
  9083 00002375 6772616D2073706563-
  9083 0000237E 696669656420627920-
  9083 00002387 2F43               
  9084 00002389 206F72202F4B2E0D0A      	db ' or /K.',0Dh,0Ah
  9085                                  
  9086                                  	; 07/06/2023
  9087                                  HELPMSG10:
  9088 00002392 3F                      	db 63
  9089 00002393 20202F4320636F6D6D-     	db '  /C command      Executes the specified command and returns.',0Dh,0Ah
  9089 0000239C 616E64202020202020-
  9089 000023A5 457865637574657320-
  9089 000023AE 746865207370656369-
  9089 000023B7 6669656420636F6D6D-
  9089 000023C0 616E6420616E642072-
  9089 000023C9 657475726E732E0D0A 
  9090                                  HELPMSG11:
  9091 000023D2 4B                      	db 75
  9092 000023D3 20202F4B20636F6D6D-     	db '  /K command      Executes the specified command and continues running.'
  9092 000023DC 616E64202020202020-
  9092 000023E5 457865637574657320-
  9092 000023EE 746865207370656369-
  9092 000023F7 6669656420636F6D6D-
  9092 00002400 616E6420616E642063-
  9092 00002409 6F6E74696E75657320-
  9092 00002412 72756E6E696E672E   
  9093 0000241A 0D0A                    	db 0Dh,0Ah
  9094 0000241C 0D0A                    	db 0Dh,0Ah
  9095                                  HELPMSG12:
  9096 0000241E 4C                      	db 76
  9097 0000241F 546865202F5020616E-     	db 'The /P and /MSG switches may be used only when COMMAND is started'
  9097 00002428 64202F4D5347207377-
  9097 00002431 697463686573206D61-
  9097 0000243A 792062652075736564-
  9097 00002443 206F6E6C7920776865-
  9097 0000244C 6E20434F4D4D414E44-
  9097 00002455 206973207374617274-
  9097 0000245E 6564               
  9098 00002460 206279207573696E67-     	db ' by using',0Dh,0Ah
  9098 00002469 0D0A               
  9099                                  HELPMSG13:
  9100 0000246B 2B                      	db 43
  9101 0000246C 746865205348454C4C-     	db 'the SHELL command in the CONFIG.SYS file.',0Dh,0Ah
  9101 00002475 20636F6D6D616E6420-
  9101 0000247E 696E2074686520434F-
  9101 00002487 4E4649472E53595320-
  9101 00002490 66696C652E0D0A     
  9102                                  
  9103                                  HelpMsgs:
  9104 00002497 [3821]                          dw HELPMSG1
  9105 00002499 [7121]                  	dw HELPMSG2
  9106 0000249B [AA21]                  	dw HELPMSG3
  9107 0000249D [D521]                  	dw HELPMSG4
  9108 0000249F [1E22]                  	dw HELPMSG5
  9109 000024A1 [6C22]                  	dw HELPMSG6
  9110 000024A3 [B222]                  	dw HELPMSG7
  9111 000024A5 [0023]                  	dw HELPMSG8
  9112 000024A7 [4723]                  	dw HELPMSG9
  9113                                  
  9114                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9115 000024A9 [9223]                  	dw HELPMSG10
  9116 000024AB [D223]                  	dw HELPMSG11
  9117 000024AD [1E24]                  	dw HELPMSG12
  9118 000024AF [6B24]                  	dw HELPMSG13
  9119                                  
  9120                                  	; 23/04/2023
  9121 000024B1 0000                    	dw 0
  9122                                  
  9123                                  ;-----------------------------------------------------------------------------
  9124                                  
  9125                                  ;SR;
  9126                                  ; This table of offsets is used by the init code to calculate the new offsets
  9127                                  ;for these labels after the resident code has been relocated
  9128                                  
  9129                                  ;Reloc_Table:
  9130                                  	;dw offset CODERES:MsgInt2fHandler
  9131                                  	;dw offset CODERES:Int_2e
  9132                                  	;dw offset CODERES:ContC
  9133                                  	;dw offset CODERES:DskErr
  9134                                  	;dw offset CODERES:Exec_Ret
  9135                                  	;dw offset CODERES:TRemCheck
  9136                                  	;dw offset CODERES:TrnLodCom1
  9137                                  	;dw offset CODERES:LodCom
  9138                                  	;dw offset CODERES:MsgRetriever
  9139                                  	;dw offset CODERES:THeadFix
  9140                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9141                                  
  9142                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9143                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9144                                  
  9145                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9146                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26C1h
  9147                                  
  9148                                  Reloc_Table:			          ; MSDOS 5.0 - 6.22 CODERES address
  9149 000024B3 2307                    	dw MsgInt2fHandler - RCODE_START  ; 738h (RESGROUP:738h+X) *
  9150 000024B5 7601                    	dw Int_2e - RCODE_START		  ; 177h (RESGROUP:177h+X) *	
  9151 000024B7 3300                    	dw ContC - RCODE_START		  ; 035h (RESGROUP:035h+X) *
  9152 000024B9 3704                    	dw DSKERR - RCODE_START		  ; 445h (RESGROUP:445h+X) *
  9153 000024BB 2700                    	dw Exec_Ret - RCODE_START	  ; 029h (RESGROUP:029h+X) *
  9154 000024BD 9A02                    	dw TRemCheck - RCODE_START	  ; 2A3h (RESGROUP:2A3h+X) *
  9155 000024BF 1404                    	dw TrnLodCom1 - RCODE_START	  ; 422h (RESGROUP:422h+X) *
  9156 000024C1 AD01                    	dw LodCom - RCODE_START		  ; 1AEh (RESGROUP:1AEh+X) *
  9157 000024C3 6607                    	dw MsgRetriever - RCODE_START	  ; 77Bh (RESGROUP:77Bh+X) *
  9158 000024C5 B902                    	dw THeadFix - RCODE_START	  ; 2C2h (RESGROUP:2C2h+X) *
  9159 000024C7 DF07                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h (RESGROUP:7F4h+X) *
  9160                                  
  9161                                  	; 07/06/2023
  9162                                  	; X = 0D40h for MSDOS 5.0 COMMAND.COM
  9163                                  	; X = 0E50h for MSDOS 6.22 COMMAND.COM
  9164                                  	;; example:
  9165                                  	;;	MsgIn2FHandler is at RESGROUP:1588h or at CODERES:0738h
  9166                                  	;;				(in MSDOS 6.22 COMMAND.COM)
  9167                                  
  9168                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9169                                  
  9170                                  ResJmpTable:
  9171 000024C9 00000000                	dd 0			; stores prev stub jump table addr
  9172                                  FirstCom:
  9173 000024CD 00                      	db 0			; flag set if first command.com
  9174                                  DevFlag:
  9175 000024CE 00                      	db 0
  9176                                  PathFlag:
  9177 000024CF 00                      	db 0
  9178                                  
  9179                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9180                                  	;;times 13 db 0
  9181                                  
  9182                                  	; 07/06/2023
  9183                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26DEh
  9184                                  	;times 2 db 0
  9185                                  
  9186                                  ; 30/01/2023
  9187                                  coderes_end equ $
  9188                                  
  9189                                  ;INIT	ENDS
  9190                                  
  9191                                  ;	END
  9192                                  
  9193                                  ;-----------------------------------------------------------------------------
  9194                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9195                                  ;-----------------------------------------------------------------------------
  9196                                  
  9197                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9198                                  	; 30/01/2023
  9199 000024D0 00                      db	0
  9200                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9201                                  	; 07/06/2023
  9202 000024D1 526574726F20444F53-     db	"Retro DOS v4.2 COMMAND.COM by Erdogan Tan [2023]"
  9202 000024DA 2076342E3220434F4D-
  9202 000024E3 4D414E442E434F4D20-
  9202 000024EC 6279204572646F6761-
  9202 000024F5 6E2054616E205B3230-
  9202 000024FE 32335D             
  9203 00002501 00                      db	0
  9204                                  
  9205                                  ;-----------------------------------------------------------------------------
  9206                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9207                                  ;-----------------------------------------------------------------------------
  9208                                  
  9209                                  ;TAIL    SEGMENT PUBLIC PARA
  9210                                  ;        ORG     0
  9211                                  ;TRANSTART LABEL WORD
  9212                                  ;TAIL    ENDS
  9213                                  
  9214                                  ;ALIGN 16  ; 25/09/2018
  9215                                  
  9216                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9217                                  
  9218                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9219                                  numbertomod equ (numbertodiv % 16)
  9220                                  
  9221                                  %if numbertomod>0 & numbertomod<16
  9222 00002502 00<rep Eh>              	times (16-numbertomod) db 0
  9223                                  %endif
  9224                                  
  9225                                  ; 30/01/2023
  9226                                  ;TRANSTART:
  9227                                  
  9228                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9229                                  ;	times	128 db 0	
  9230                                  
  9231                                  ;-----------------------------------------------------------------------------
  9232                                  ; SEGMENT - TRANSCODE
  9233                                  ;-----------------------------------------------------------------------------
  9234                                  
  9235                                  ;TRANGROUP: ; 21/04/2018
  9236                                  
  9237                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9238                                  ;-----------------------------------------------------------------------------
  9239                                  
  9240                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9241                                  
  9242                                  ; 21/04/2018 - Retro DOS v2.0
  9243                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9244                                  ; (these values must be changed when transcom.s source code is changed
  9245                                  ; and data offsets are changed)
  9246                                  ;
  9247                                  ; 30/04/2018
  9248                                  ; 29/04/2018
  9249                                  
  9250                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9251                                  ;COMMAND      EQU  012CH
  9252                                  ;DATINIT      EQU  2091H
  9253                                  ;HEADCALL     EQU  428FH
  9254                                  ;TRANSPACEEND EQU  4D5CH
  9255                                  ;TRANDATAEND  EQU  3F44H
  9256                                  
  9257                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9258                                  ;TRIAGE_INIT  EQU  1F15H
  9259                                  ;PRINTF_INIT  EQU  34E0H 
  9260                                  
  9261                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9262                                  
  9263                                  ;TPA	EQU  4293H
  9264                                  ;TRNLEN	EQU  04D6H
  9265                                  
  9266                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9267                                  ;COMMAND      EQU  012CH
  9268                                  ;DATINIT      EQU  206FH
  9269                                  ;HEADCALL     EQU  426FH
  9270                                  ; 09/01/2023
  9271                                  ;TRANSPACEEND EQU  4D3CH
  9272                                  ;TRANDATAEND  EQU  3F24H
  9273                                  ;TRIAGE_INIT  EQU  1EF3H
  9274                                  ;PRINTF_INIT  EQU  34BFH 
  9275                                  ;
  9276                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9277                                  
  9278                                  ;-----------------------------------------------------------------------------
  9279                                  ; ARENA.INC, MSDOS 6.0, 1991
  9280                                  ;-----------------------------------------------------------------------------
  9281                                  ; 13/10/2018 - Retro DOS 3.0
  9282                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9283                                  
  9284                                  ;BREAK <Memory arena structure>
  9285                                  
  9286                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9287                                  
  9288                                  ; arena item
  9289                                  
  9290                                  struc ARENA
  9291 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9292 00000001 ????                      .owner:	resw 1		; owner of arena item
  9293 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9294                                  endstruc
  9295                                  
  9296                                  ;-----------------------------------------------------------------------------
  9297                                  ;START OF TRANSIENT PORTION
  9298                                  ;This code is loaded at the end of memory and may be overwritten by
  9299                                  ;memory-intensive user programs.
  9300                                  ;-----------------------------------------------------------------------------
  9301                                  
  9302                                  ; 16/04/2023
  9303                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9304                                  ; 29/09/2018
  9305                                  ; 31/01/2023 
  9306                                  ;TRANSTART:	; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9307                                  			
  9308                                  		; 09/01/2023
  9309                                  		; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9310                                  			
  9311                                  		; 07/06/2023
  9312                                  		; Offset 26E0h in original MSDOS 6.22 COMMAND.COM
  9313                                  
  9314                                  ; 25/09/2018
  9315                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9316                                  ;
  9317                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9318                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9319                                  ;
  9320                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9321                                  ;
  9322                                  ;
  9323                                  ;COMTRANS:
  9324                                  ;
  9325                                  ; 20/10/2018 - Retro DOS v3.0	
  9326                                  ;INCBIN	"TRANCOM3.BIN"
  9327                                  ;
  9328                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9329                                  ;
  9330                                  ; 29/04/2018
  9331                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9332                                  ;
  9333                                  ;TIMES BSS_SIZE db 0
  9334                                  ;
  9335                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9336                                  
  9337                                  ;COMMANDCOMSIZE equ $ - 100h
  9338                                  
  9339                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9340                                  ; ============================================================================
  9341                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9342                                  ; ============================================================================
  9343                                  
  9344                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22 COMMAND.COM)
  9345                                  
  9346                                  ; ----------------------------------------------------------------------------
  9347                                  ; START OF TRANSIENT PORTION
  9348                                  ; ----------------------------------------------------------------------------
  9349                                  ; SEGMENT - TRANSCODE
  9350                                  ; ----------------------------------------------------------------------------
  9351                                  
  9352                                  ; 18/04/2023
  9353                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9354                                  
  9355                                  ; 18/04/2023
  9356                                  ;-----------------------------------------------------------------------------
  9357                                  ; TRANSCODE segment offset 0
  9358                                  TRANSIENTSTART:
  9359                                  
  9360                                  	; 31/01/2023
  9361 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9362                                  
  9363                                  ;============================================================================
  9364                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9365                                  ;============================================================================
  9366                                  ; 12/10/2018 - Retro DOS v3.0
  9367                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9368                                  
  9369                                  ;[ORG 100h]
  9370                                  
  9371                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9372                                  
  9373                                  ; ---------------------------------------------------------------------------
  9374                                  		
  9375                                  	; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9376                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:0100h)
  9377                                  
  9378                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9379                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0100h)
  9380                                  SETDRV:
  9381 00000100 B40E                    	mov	ah,0Eh
  9382                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9383 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9384                                  			; DL = new default drive number
  9385                                  			;		(0 = A, 1 = B, ..)
  9386                                  			; Return: AL = number of logical drives
  9387                                  
  9388                                  ; ---------------------------------------------------------------------------
  9389                                  
  9390                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9391                                  ; No registers (CS:IP) no flags, nothing.
  9392                                  
  9393                                  TCOMMAND:
  9394 00000104 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
  9395 00000109 B8FFFF                  	mov	ax,-1
  9396 0000010C 8706[6302]              	xchg	ax,[VerVal]
  9397 00000110 83F8FF                  	cmp	ax,-1
  9398 00000113 7404                    	je	short NOSETVER2
  9399 00000115 B42E                    	mov	ah,2Eh
  9400                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9401 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9402                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9403                                  NOSETVER2:
  9404 00000119 2EFF1E[E29D]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9405 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9406 00000120 833E[6102]FF            	cmp	word [SingleCom],-1
  9407 00000125 7505                    	jne	short COMMAND
  9408                                  _$EXITPREP:
  9409 00000127 0E                      	push	cs
  9410 00000128 1F                      	pop	ds
  9411 00000129 E96B25                  	jmp	_$EXIT		; Have finished the single command
  9412                                  
  9413                                  ; ---------------------------------------------------------------------------
  9414                                  ;
  9415                                  ; Main entry point from resident portion.
  9416                                  ;
  9417                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9418                                  ;   just beginning the processing of another command.
  9419                                  ;
  9420                                  ; ---------------------------------------------------------------------------
  9421                                  
  9422                                  ; We are not always sure of the state of the world at this time. We presume
  9423                                  ; worst case and initialize the relevant registers: segments and stack.
  9424                                  
  9425                                  COMMAND:
  9426 0000012C FC                      	cld
  9427 0000012D 8CC8                    	mov	ax,cs
  9428 0000012F FA                      	cli
  9429 00000130 8ED0                    	mov	ss,ax
  9430                                  	;mov	sp,offset TRANGROUP:STACK
  9431                                  				; 07/06/2023
  9432 00000132 BC[06AA]                	mov	sp,STACK	; 0AF24h for MSDOS 6.22 COMMAND.COM
  9433                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9434 00000135 FB                      	sti
  9435                                  		
  9436 00000136 8EC0                    	mov	es,ax
  9437                                  		
  9438                                  	; MSDOS 6.0
  9439 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9440                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9441                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9442                                  	; 31/01/2023
  9443 0000013A E8DF54                  	call	TSYSLOADMSG
  9444 0000013D C606[9CA2]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9445                                  
  9446                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9447                                  	;mov	ds,[ss:RESSEG]
  9448                                  	; 31/01/2023
  9449 00000142 8E1E[E49D]              	mov	ds,[RESSEG]
  9450 00000146 36C606[C09B]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9451 0000014C 36C606[439C]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9452                                  
  9453                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9454                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9455                                  ; I guess not: the only circumstances in which we reload the command processor
  9456                                  ; is after a transient program execution. In this case, we let the current
  9457                                  ; directory lie where it may.
  9458                                  
  9459 00000152 09ED                    	or	bp,bp		; See if just read
  9460 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9461 00000156 36C706[C19B]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9462 0000015D EB17                    	jmp	short NOSETBUF
  9463                                  TESTRDIR:
  9464 0000015F 803E[5D02]00            	cmp	byte [RestDir],0
  9465 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9466 00000166 1E                      	push	ds
  9467                                  
  9468                                  ; We have an unusual situation to handle. The user *may* have changed his
  9469                                  ; directory as a result of an internal command that got aborted. Restoring it
  9470                                  ; twice may not help us: the problem may never go away. We just attempt it
  9471                                  ; once and give up.
  9472                                  
  9473 00000167 C606[5D02]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9474                                  
  9475                                  	; Restore users directory
  9476 0000016C 0E                      	push	cs
  9477 0000016D 1F                      	pop	ds
  9478 0000016E BA[C69C]                	mov	dx,USERDIR1
  9479 00000171 B43B                    	mov	ah,3Bh
  9480                                  	;mov	ah,CHDir ; 3Bh
  9481 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9482                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9483 00000175 1F                      	pop	ds
  9484                                  NOSETBUF:
  9485 00000176 803E[D402]00            	cmp	byte [PipeFiles],0
  9486 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9487 0000017D 803E[D302]00            	cmp	byte [PipeFlag],0
  9488 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9489 00000184 E8B330                  	call	PIPEDEL
  9490                                  NOPCLOSE:
  9491                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9492                                  	; 31/01/2023
  9493 00000187 C606[5502]00            	mov	byte [ExtCom],0 ; Flag internal command
  9494 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9495 0000018E 8ED8                    	mov	ds,ax
  9496 00000190 50                      	push	ax
  9497                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9498 00000191 BA[06AA]                	mov	dx,INTERNATVARS ; 0AF24h for MSDOS 6.22 COMMAND.COM
  9499                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9500 00000194 B80038                  	mov	ax,3800h
  9501                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9502 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9503                                  			; get current-country info
  9504                                  			; DS:DX	-> buffer for returned info
  9505 00000199 58                      	pop	ax
  9506 0000019A 2B06[E69D]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9507 0000019E 53                      	push	bx
  9508 0000019F BB1000                  	mov	bx,16
  9509 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9510 000001A4 5B                      	pop	bx
  9511 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9512 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9513 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9514                                  SAVSIZ:
  9515                                  
  9516                                  ; AX is the number of bytes free in the buffer between the resident and the
  9517                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9518                                  
  9519 000001AC 3D0002                  	cmp	ax,512
  9520 000001AF 7603                    	jbe	short GOTSIZE
  9521                                  	;and	ax,~1FFh
  9522 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9523                                  GOTSIZE:
  9524 000001B4 A3[059E]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9525 000001B7 8E1E[E49D]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9526                                  
  9527 000001BB F606[5902]01            	test	byte [EchoFlag],1 
  9528 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9529 000001C2 E85430                  	call	SINGLETEST
  9530 000001C5 7219                    	jb	short GETCOM
  9531 000001C7 F606[D302]FF            	test	byte [PipeFlag],0FFh ; -1
  9532 000001CC 7512                    	jnz	short GETCOM
  9533                                  				; G  Don't print prompt in FOR
  9534 000001CE F606[6702]FF            	test	byte [ForFlag],0FFh ; -1
  9535 000001D3 750B                    	jnz	short GETCOM
  9536                                  				; G  Don't print prompt if in batch
  9537 000001D5 F706[0502]FFFF          	test	word [Batch],0FFFFh ; -1
  9538 000001DB 7503                    	jnz	short GETCOM
  9539 000001DD E83C29                  	call	CRLF2
  9540                                  
  9541                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9542                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:01E0h
  9543                                  GETCOM:
  9544 000001E0 833E[6102]00            	cmp     word [SingleCom],0
  9545 000001E5 750D                    	jnz     short GETCOM2
  9546 000001E7 F706[0502]FFFF          	test    word [Batch],0FFFFh
  9547 000001ED 7505                    	jnz     short GETCOM2
  9548 000001EF 8026[1C04]EF            	and     byte [Y_Flag],0EFh ; Y/N question overwrite flag ; ~10h
  9549                                  
  9550                                  ;GETCOM:	; MSDOS 5.0 COMMAND.COM
  9551                                  GETCOM2:
  9552 000001F4 C606[6C02]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9553 000001F9 C606[6D02]00            	mov	byte [Call_Batch_Flag],0
  9554 000001FE B419                    	mov	ah,19h
  9555                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9556 00000200 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9557 00000202 36A2[F89D]              	mov	[ss:CURDRV],al
  9558 00000206 F606[D302]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9559 0000020B 7403                    	jz	short NOPIPE
  9560 0000020D E9F530                  	jmp	PIPEPROC	; Continue the pipeline
  9561                                  NOPIPE:
  9562 00000210 F606[5902]01            	test	byte [EchoFlag],1
  9563 00000215 7417                    	jz	short NOPDRV	; No prompt if echo off
  9564 00000217 E8FF2F                  	call	SINGLETEST
  9565 0000021A 7212                    	jb	short NOPDRV
  9566 0000021C F606[6702]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9567 00000221 750B                    	jnz	short NOPDRV
  9568 00000223 F706[0502]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9569 00000229 750D                    	jnz	short TESTFORBAT
  9570 0000022B E8B020                  	call	PRINT_PROMPT	; Prompt the user
  9571                                  NOPDRV:
  9572 0000022E F606[6702]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9573 00000233 7403                    	jz	short TESTFORBAT
  9574 00000235 E97C0C                  	jmp	FORPROC		; Continue the FOR
  9575                                  
  9576                                  TESTFORBAT:
  9577 00000238 36C606[8F9D]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9578 0000023E C606[8202]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9579 00000243 C606[8102]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9580 00000248 C606[6602]00            	mov	byte [IfFlag],0	; no more ifs...
  9581 0000024D F706[0502]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9582 00000253 7441                    	jz	short ISNOBAT
  9583                                  
  9584                                  	; 31/01/2023
  9585                                  
  9586                                  	; MSDOS 6.0
  9587                                  
  9588                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9589                                  
  9590 00000255 06                      	push	es			;AN000; save ES
  9591 00000256 1E                      	push	ds			;AN000; save DS
  9592                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9593                                  	; 05/02/2023
  9594 00000257 B80219                  	mov	ax,1902h
  9595 0000025A 8E06[0502]              	mov	es,[Batch]		;AN000; get batch segment
  9596                                  	;mov	di,20h
  9597 0000025E BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9598 00000261 0E                      	push	cs			;AN000; get local segment to DS
  9599 00000262 1F                      	pop	ds			;AN000;
  9600                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9601 00000263 BA[439C]                	mov	dx,COMBUF
  9602 00000266 CD2F                    	int	2Fh			;AN000; call the shell
  9603                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9604                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9605                                  		; final filename element uppercased
  9606                                  		; DS:DX -> buffer for results
  9607                                  	;cmp	al,0FFh
  9608 00000268 3CFF                    	cmp	al,shell_action		;AN000; does shell have a commmand?
  9609 0000026A 1F                      	pop	ds			;AN000; restore DS
  9610 0000026B 07                      	pop	es			;AN000; restore ES
  9611 0000026C 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9612                                  
  9613                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9614 0000026E 1E                      	push	ds
  9615 0000026F E8D503                  	call	READBAT			; Continue BATCH
  9616 00000272 1F                      	pop	ds
  9617 00000273 C606[7002]00            	mov	byte [NullFlag],0	;G reset no command flag
  9618 00000278 F706[0502]FFFF          	test	word [Batch],0FFFFh
  9619 0000027E 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9620 00000280 8B1E[6E02]              	mov	bx,[Next_Batch]
  9621                                  	; 31/01/2023
  9622 00000284 09DB                    	or	bx,bx
  9623                                  	;cmp	bx,0			;G see if there is a new batch file
  9624 00000286 740A                    	jz	short JDOCOM1		;G no - go do command
  9625 00000288 891E[0502]              	mov	[Batch],bx		;G get segment of next batch file
  9626 0000028C C706[6E02]0000          	mov	word [Next_Batch],0	;G reset next batch
  9627                                  JDOCOM1:
  9628 00000292 0E                      	push	cs
  9629 00000293 1F                      	pop	ds
  9630                                  	;jmp	short DOCOM1
  9631                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9632 00000294 EB5D                    	jmp	short DOCOM0
  9633                                  ISNOBAT:
  9634 00000296 833E[6102]00            	cmp	word [SingleCom],0
  9635 0000029B 741D                    	jz	short REGCOM
  9636                                  	; 07/06/2023 - MSDOS 6.22 COMMAND.COM
  9637 0000029D 8B36[5F02]              	mov	si,[SemiPermCom] ;  MSDOS 6.0
  9638                                  	;mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9639 000002A1 8736[6102]              	xchg	si,[SingleCom]
  9640 000002A5 BF[459C]                	mov	di,COMBUF+2
  9641 000002A8 31C9                    	xor	cx,cx
  9642                                  SINGLELOOP:
  9643 000002AA AC                      	lodsb
  9644 000002AB AA                      	stosb
  9645 000002AC 41                      	inc	cx
  9646 000002AD 3C0D                    	cmp	al,0Dh
  9647 000002AF 75F9                    	jnz	short SINGLELOOP
  9648 000002B1 49                      	dec	cx
  9649 000002B2 0E                      	push	cs
  9650 000002B3 1F                      	pop	ds
  9651 000002B4 880E[449C]              	mov	[COMBUF+1],cl
  9652                                  
  9653                                  ; do NOT issue a trailing CRLF...
  9654                                  
  9655                                  	;jmp	short DOCOM1
  9656                                  	; 07/06/2023
  9657                                  	; MSDOS 6.22 COMMAND.COM
  9658 000002B8 EB39                    	jmp	short DOCOM0
  9659                                  
  9660                                  	;nop
  9661                                  
  9662                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9663                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9664                                  
  9665                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9666                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02BBh
  9667                                  
  9668                                  ; We have a normal command.  
  9669                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9670                                  ; sometimes they aren't. At this point, we automatically close all spool
  9671                                  ; files and turn on truncation mode.
  9672                                  
  9673                                  REGCOM:
  9674                                  	;mov	ax,(ServerCall shl 8) + 9
  9675                                  	; 31/01/2023
  9676 000002BA B8095D                  	mov	ax,5D09h
  9677                                  	;mov	ax,(SERVERCALL<<8)+9
  9678 000002BD CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9679                                  	;mov	ax,(ServerCall shl 8) + 8
  9680 000002BF B8085D                  	mov	ax,5D08h
  9681                                  	;mov	ax,(SERVERCALL<<8)+8
  9682 000002C2 B201                    	mov	dl,1
  9683 000002C4 CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9684                                  			; DL = 00h redirected output is	combined
  9685                                  			;      01h redirected output placed in separate	jobs
  9686                                  			; start	new print job now
  9687 000002C6 0E                      	push	cs
  9688 000002C7 1F                      	pop	ds	; Need local segment to point to buffer
  9689 000002C8 BA[C09B]                	mov	dx,UCOMBUF
  9690                                  
  9691                                  	; MSDOS 6.0
  9692                                  ;	Try to read interactive command line via DOSKey.
  9693                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9694                                  
  9695                                  	; 31/01/2023
  9696 000002CB B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9697 000002CE CD2F                    	int	2Fh
  9698 000002D0 09C0                    	or	ax,ax
  9699 000002D2 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9700                                  
  9701 000002D4 B40A                    	mov	ah,0Ah
  9702                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9703 000002D6 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9704                                  			; DS:DX	-> buffer
  9705                                  GOTCOM:
  9706 000002D8 8A0E[C09B]              	mov	cl,[UCOMBUF]
  9707 000002DC 30ED                    	xor	ch,ch
  9708 000002DE 83C103                  	add	cx,3
  9709 000002E1 BE[C09B]                	mov	si,UCOMBUF
  9710 000002E4 BF[439C]                	mov	di,COMBUF
  9711 000002E7 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9712                                  
  9713                                  	; -------------
  9714                                  
  9715                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9716                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02EDh
  9717                                  
  9718 000002E9 E83028                  	call	CRLF2
  9719 000002EC 31C0                    	xor	ax,ax
  9720 000002EE EB06                    	jmp	short DOCOM2
  9721                                  	; -------------
  9722                                  
  9723                                  DOCOM:
  9724 000002F0 E82928                  	call	CRLF2
  9725                                  
  9726                                  	; -------------
  9727                                  
  9728                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9729                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02F4h
  9730                                  DOCOM0:
  9731 000002F3 B80100                  	mov	ax,1
  9732                                  DOCOM2:
  9733 000002F6 1E                      	push	ds
  9734 000002F7 8E1E[E49D]              	mov     ds,[RESSEG]
  9735 000002FB A3[B001]                	mov	[cox_Y_option],ax
  9736 000002FE 1F                      	pop	ds
  9737 000002FF BE[439C]                	mov	si,COMBUF
  9738 00000302 8A4C01                  	mov	cl,[si+1]
  9739 00000305 30ED                    	xor	ch,ch
  9740 00000307 83C602                  	add	si,2
  9741 0000030A E82501                  	call	get_cox_y_n_opt
  9742 0000030D 7303                    	jnc	short DOCOM1    ; YES answer
  9743                                  	; 07/06/2023
  9744                                  NULLCOMJ:
  9745 0000030F E90201                  	jmp	NULLCOM         ; NO answer
  9746                                  	; -------------
  9747                                  
  9748                                  	; MSDOS 5.0 & MSDOS 6.0 COMMAND.COM
  9749                                  DOCOM1:
  9750 00000312 E88E2B                  	call	PRESCAN		; Cook the input buffer
  9751 00000315 7403                    	jz	short NOPIPEPROC
  9752 00000317 E96A2F                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9753                                  
  9754                                  	; 07/06/2023
  9755                                  ;NULLCOMJ:
  9756                                  	;jmp	NULLCOM
  9757                                  
  9758                                  NOPIPEPROC:
  9759 0000031A E86532                  	call	PARSELINE
  9760 0000031D 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9761                                  BADPARSE:
  9762 0000031F 0E                      	push	cs
  9763 00000320 1F                      	pop	ds
  9764 00000321 BA[2692]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9765 00000324 E80E52                  	call	std_eprintf
  9766 00000327 E9DAFD                  	jmp	TCOMMAND
  9767                                  
  9768                                  OKPARSE:
  9769                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9770                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9771                                  	; 01/02/2023
  9772 0000032A F606[B8A2]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9773 0000032F 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9774                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9775 00000331 833E[76A5]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9776 00000336 74D7                    	jz	short NULLCOMJ
  9777                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9778 00000338 833E[BBA2]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9779 0000033D 74D0                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9780                                  
  9781 0000033F BE[459C]                	mov	si,COMBUF+2
  9782 00000342 BF[A09F]                	mov	di,IDLEN
  9783                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9784                                  				; Make FCB with blank scan-off
  9785                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9786 00000345 B80129                  	mov	ax,2901h
  9787 00000348 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9788                                  			; DS:SI	-> string to parse
  9789                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9790                                  			; AL = bit mask	to control parsing
  9791                                  	;mov	bx,[ARG_ARGV]
  9792 0000034A 8B1E[B6A2]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9793 0000034E 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9794 00000352 751B                    	jne	short DRVGD	; no, use default of zero...
  9795 00000354 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9796                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9797                                  	;and	dl,~20h
  9798 00000356 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9799                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9800                                  	; 31/01/2023
  9801 00000359 80EA41                  	sub	dl,'A'
  9802 0000035C 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9803 0000035E 740C                    	je	short DRVBADJ	; It was invalid.
  9804                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9805 00000360 8B3E[B9A2]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9806 00000364 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9807 00000367 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9808 00000369 E994FD                  	jmp	SETDRV		; and set drive to new drive spec
  9809                                  DRVBADJ:
  9810 0000036C E9362A                  	jmp	DRVBAD
  9811                                  DRVGD:
  9812 0000036F 8A05                    	mov	al,[di]
  9813 00000371 A2[049E]                	mov	[SPECDRV],al
  9814 00000374 B020                    	mov	al,' '
  9815 00000376 B90900                  	mov	cx,9
  9816 00000379 47                      	inc	di
  9817 0000037A F2AE                    	repne	scasb		; Count number of letters in command name
  9818 0000037C B008                    	mov	al,8
  9819 0000037E 28C8                    	sub	al,cl
  9820 00000380 A2[A09F]                	mov	[IDLEN],al	; IDLEN is truly the length
  9821 00000383 BF8100                  	mov	di,81h
  9822 00000386 56                      	push	si
  9823 00000387 BE[459C]                	mov	si,COMBUF+2	; Skip over all leading delims
  9824 0000038A E89C27                  	call	scanoff
  9825                                  
  9826                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9827                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9828                                  
  9829                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9830                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0391h
  9831                                  
  9832                                  	; MSDOS 6.0
  9833                                  ;SR;
  9834                                  ; We are going to skip over the first char always. The logic is that the
  9835                                  ;command tail can never start from the first character. The code below is 
  9836                                  ;trying to figure out the command tail and copy it to the command line 
  9837                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9838                                  ;character and the user given command line is a full 128 bytes, we try to
  9839                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9840                                  ;char overwrites the code and leads to a crash on future commands.
  9841                                  
  9842 0000038D 46                      	inc	si ;  MSDOS 6.0
  9843                                  
  9844                                  DO_SKIPCOM:
  9845 0000038E AC                      	lodsb			; move command line pointer over
  9846 0000038F E89F27                  	call	DELIM		; pathname -- have to do it ourselves
  9847 00000392 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9848 00000394 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9849 00000396 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9850 00000398 3A06[E89D]              	cmp	al,[SWITCHAR]	; specified command string
  9851 0000039C 75F0                    	jnz	short DO_SKIPCOM 
  9852                                  DO_SKIPPED:
  9853 0000039E 4E                      	dec	si
  9854 0000039F 31C9                    	xor	cx,cx
  9855                                  COMTAIL:
  9856 000003A1 AC                      	lodsb
  9857 000003A2 AA                      	stosb			; Move command tail to 80h
  9858 000003A3 3C0D                    	cmp	al,0Dh
  9859 000003A5 E0FA                    	loopne	COMTAIL
  9860 000003A7 4F                      	dec	di
  9861 000003A8 89FD                    	mov	bp,di
  9862 000003AA F6D1                    	not	cl
  9863 000003AC 880E8000                	mov	[80h],cl
  9864 000003B0 5E                      	pop	si
  9865                                  ;-----
  9866                                  ; Some of these comments are sadly at odds with this brave new code.
  9867                                  ;-----
  9868                                  ; If the command has 0 parameters must check here for
  9869                                  ; any switches that might be present.
  9870                                  ; SI -> first character after the command.
  9871                                  
  9872                                  	;mov	di,arg.argv[0].argsw_word
  9873                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9874 000003B1 8B3E[BDA2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9875 000003B5 893E[FB9D]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9876                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9877                                  				; s = argv[1];
  9878                                  	;mov	si,[ARGV1_ARGPOINTER]
  9879 000003B9 8B36[C1A2]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9880 000003BD 09F6                    	or	si,si		;   if (s == NULL)
  9881 000003BF 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9882 000003C1 89EE                    	mov	si,bp
  9883                                  DOPARSE:
  9884 000003C3 BF5C00                  	mov	di,FCB ; 5Ch
  9885                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9886                                  	; 01/02/2023
  9887 000003C6 B80129                  	mov	ax,2901h
  9888                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9889 000003C9 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9890                                  			; DS:SI	-> string to parse
  9891                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9892                                  			; AL = bit mask	to control parsing
  9893 000003CB A2[F99D]                	mov	[PARM1],al	; Save result of parse
  9894                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9895                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9896 000003CE 8B3E[C8A2]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9897 000003D2 893E[FD9D]              	mov	[ARG1S],di
  9898                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9899                                  				; s = argv[2];
  9900                                  	;mov	si,[ARGV2_ARGPOINTER]
  9901 000003D6 8B36[CCA2]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9902 000003DA 09F6                    	or	si,si		; if (s == NULL)
  9903 000003DC 7502                    	jnz	short DOPARSE2
  9904 000003DE 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9905                                  DOPARSE2:			
  9906 000003E0 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9907                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9908 000003E3 B80129                  	mov	ax,2901h
  9909                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9910 000003E6 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9911                                  			; DS:SI	-> string to parse
  9912                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9913                                  			; AL = bit mask	to control parsing
  9914 000003E8 A2[FA9D]                	mov	[PARM2],al	; Save result
  9915                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9916                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9917 000003EB 8B3E[D3A2]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9918 000003EF 893E[FF9D]              	mov	[ARG2S],di
  9919                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9920                                  	;mov	di,arg.argv[0].argsw_word
  9921 000003F3 8B3E[BDA2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9922 000003F7 F7D7                    	not	di		; ARGTS doesn't include the flags
  9923                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9924                                  	;and	di,arg.argswinfo	
  9925 000003F9 233E[78A5]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9926 000003FD 893E[019E]              	mov	[ARGTS],di
  9927                                  
  9928 00000401 A0[A09F]                	mov	al,[IDLEN]
  9929 00000404 8A16[049E]              	mov	dl,[SPECDRV]
  9930 00000408 08D2                    	or	dl,dl		; if a drive was specified...
  9931 0000040A 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9932 0000040C FEC8                    	dec	al		; (I don't know why -- old code did it)
  9933 0000040E E9E728                  	jmp	FNDCOM		; otherwise, check internal com table
  9934                                  EXTERNALJ1:
  9935 00000411 E9E929                  	jmp	EXTERNAL
  9936                                  NULLCOM:
  9937 00000414 8E1E[E49D]              	mov	ds,[RESSEG]
  9938 00000418 F706[0502]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9939 0000041E 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9940 00000420 C606[7002]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9941                                  	;mov	byte [NullFlag],nullcommand ; 1
  9942                                  NOSETFLAG:
  9943 00000425 833E[6102]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9944 0000042A 7403                    	je	short EXITJ
  9945 0000042C E9B1FD                  	jmp	GETCOM
  9946                                  EXITJ:
  9947 0000042F E9F5FC                  	jmp	_$EXITPREP
  9948                                  
  9949                                  ; 07/06/2023
  9950                                  ; ---------------------------------------------------------------------------
  9951                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
  9952                                  ; -----------------------------------------
  9953                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
  9954                                  ; ---------------------------------------------------------------------------
  9955                                  
  9956                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9957                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0436h
  9958                                  
  9959                                  get_cox_y_n_opt:
  9960 00000432 E339                    	jcxz	ccydp4	; empty	input buffer
  9961                                  ccydp0:
  9962 00000434 803C0D                  	cmp	byte [si],0Dh
  9963 00000437 7434                    	je	short ccydp4
  9964 00000439 803C0A                  	cmp	byte [si],0Ah
  9965 0000043C 742F                    	je	short ccydp4
  9966 0000043E 06                      	push	es
  9967 0000043F 8E06[E49D]              	mov	es,[RESSEG]
  9968 00000443 26A0[1C04]              	mov	al,[es:Y_Flag]
  9969 00000447 A810                    	test	al,10h		; bit 1	= 1 -> Y/N answer is needed
  9970 00000449 7421                    	jz	short ccydp3 ; cf=0 ; 07/06/2023
  9971 0000044B 26803E[6D02]01          	cmp	byte [es:Call_Batch_Flag],1 ; (in) Batch file ?
  9972 00000451 7419                    	je	short ccydp3	; yes, don't check for ESCAPE
  9973 00000453 A840                    	test	al,40h		; ESCAPE status
  9974                                  				; (bit 4 is zero if Y/N	is excaped)
  9975 00000455 7417                    	jz	short ccydp5
  9976                                  ccydp1:
  9977 00000457 26F706[0502]FFFF        	test	word [es:Batch],0FFFFh
  9978 0000045E 740B                    	jz	short ccydp2
  9979 00000460 268E06[0502]            	mov	es,[es:Batch]
  9980                                  	;mov	byte [es:2],1 ; [es:BATCHSEGMENT.BatchEOF]
  9981 00000465 26C606020001            	mov	byte [es:BATCHSEGMENT.BatchEOF],1
  9982                                  ccydp2:
  9983 0000046B F9                      	stc
  9984                                  ccydp3:		; 07/06/2023 ; cf = 0
  9985 0000046C 07                      	pop	es
  9986                                  ccydp4:		; 07/06/2023 ; cf = 0
  9987 0000046D C3                      	retn
  9988                                  
  9989                                  ;ccydp3:
  9990                                  ;	pop	es
  9991                                  ;ccydp4:
  9992                                  ;	clc
  9993                                  ;	retn
  9994                                  
  9995                                  ccydp5:
  9996 0000046E 89F2                    	mov	dx,si
  9997 00000470 BB0200                  	mov	bx,2
  9998 00000473 B440                    	mov	ah,40h
  9999 00000475 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 10000                                  			; BX = file handle, CX = number	of bytes to write
 10001                                  			; DS:DX -> buffer
 10002 00000477 BA[4894]                	mov	dx,cox_Y_quest_ptr ; msg number	pointer	of ' [Y/N]?'
 10003                                  				   ; (is 1082)
 10004 0000047A E8B850                  	call	std_eprintf
 10005 0000047D 1E                      	push	ds
 10006 0000047E B83B04                  	mov	ax,1083	; cox_Y_answer number (overwrite Y/N answer letter)
 10007 00000481 B6FF                    	mov	dh,0FFh		; utility_msg_class
 10008 00000483 E89C51                  	call	TSYSGETMSG
 10009                                  	;mov	cx,'NY' ; MASM word format
 10010                                  	; NASM word format
 10011 00000486 B9594E                  	mov	cx,'YN'        ; 'YN' Yes/No (CL=Y)
 10012 00000489 7202                    	jc	short ccydp6
 10013 0000048B 8B0C                    	mov	cx,[si]
 10014                                  ccydp6:
 10015 0000048D 1F                      	pop	ds
 10016                                  ccydp7:
 10017 0000048E B408                    	mov	ah,8
 10018 00000490 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10019                                  			; Return: AL = character
 10020 00000492 84C0                    	test	al,al
 10021 00000494 7510                    	jnz	short ccydp8
 10022 00000496 B408                    	mov	ah,8
 10023 00000498 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10024                                  			; Return: AL = character
 10025 0000049A 3C3F                    	cmp	al,'?'
 10026 0000049C 75F0                    	jne	short ccydp7
 10027 0000049E 26800E[1C04]40          	or	byte [es:Y_Flag],40h ; bit 4, question flag
 10028 000004A4 EBB1                    	jmp	short ccydp1
 10029                                  ccydp8:
 10030 000004A6 3C1B                    	cmp	al,1Bh		; ESCAPE ?
 10031 000004A8 7509                    	jne	short ccydp9
 10032 000004AA 268026[1C04]EF          	and	byte [es:Y_Flag],0EFh ; (ESCAPE) Clear bit 4 ; ~10h
 10033                                  	;jmp	short ccydp12
 10034                                  	; 07/06/2023
 10035 000004B0 9C                      	pushf
 10036 000004B1 EB14                    	jmp	short ccydp12
 10037                                  ccydp9:
 10038 000004B3 24DF                    	and	al,0DFh		; uppercase
 10039 000004B5 38E8                    	cmp	al,ch		; NO character (N)
 10040 000004B7 7503                    	jne	short ccydp10
 10041 000004B9 F9                      	stc
 10042 000004BA EB04                    	jmp	short ccydp11	; cf = 1 -> overwrite NO answer
 10043                                  ccydp10:
 10044 000004BC 38C8                    	cmp	al,cl		; YES character	(Y)
 10045 000004BE 75CE                    	jne	short ccydp7
 10046                                  ccydp11:
 10047 000004C0 9C                      	pushf			; cf = 0 -> overwrite YES answer
 10048 000004C1 88C2                    	mov	dl,al
 10049 000004C3 B402                    	mov	ah,2
 10050 000004C5 CD21                    	int	21h	; DOS -	DISPLAY	OUTPUT
 10051                                  			; DL = character to send to standard output
 10052                                  	; 07/06/2023
 10053                                  	;popf
 10054                                  ccydp12:
 10055                                  	;pushf
 10056 000004C7 E85226                  	call	CRLF2
 10057 000004CA 9D                      	popf
 10058 000004CB 07                      	pop	es
 10059 000004CC C3                      	retn
 10060                                  
 10061                                  ;============================================================================
 10062                                  ; MSHALO.ASM, MSDOS 6.0, 1991
 10063                                  ;============================================================================
 10064                                  ; 12/10/2018 - Retro DOS v3.0
 10065                                  
 10066                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
 10067                                  
 10068                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
 10069                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
 10070                                  ;   there is a header that describes a block of rom program.  This header
 10071                                  ;   contains information needed to initialize a module and to provide PCDOS
 10072                                  ;   with a set of reserved names for execution.
 10073                                  ;
 10074                                  ;   This header has the following format:
 10075                                  ;
 10076                                  ;   rom_header	STRUC
 10077                                  ;	Signature1  DB	55h
 10078                                  ;	Signature2  DB	AAh
 10079                                  ;	rom_length  DB	?		; number of 512 byte pieces
 10080                                  ;	init_jmp    DB	3 dup (?)
 10081                                  ;	name_list   name_struc <>
 10082                                  ;   rom_header	ENDS
 10083                                  ;
 10084                                  ;   name_struc	STRUC
 10085                                  ;	name_len    DB	?
 10086                                  ;	name_text   DB	? DUP (?)
 10087                                  ;	name_jmp    DB	3 DUP (?)
 10088                                  ;   name_struc	ENDS
 10089                                  ;
 10090                                  ;   The name list is a list of names that are reserved by a particular section
 10091                                  ;   of a module.  This list of names is terminated by a null name (length
 10092                                  ;   is zero).
 10093                                  ;
 10094                                  ;   Consider now, the PCDOS action when a user enters a command:
 10095                                  ;
 10096                                  ;	COMMAND.COM has control.
 10097                                  ;	o   If location FFFFEh has FDh then
 10098                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
 10099                                  ;		    by AAh, stop scan if we get above or = F0000H
 10100                                  ;	o	When we've found one, compare the name entered by the user
 10101                                  ;		    with the one found in the rom.  If we have a match, then
 10102                                  ;		    set up the environment for execution and do a long jump
 10103                                  ;		    to the near jump after the found name.
 10104                                  ;	o	If no more names in the list, then continue scanning the module
 10105                                  ;		    for more 55h followed by AAh.
 10106                                  ;	o   We get to this point only if there is no matching name in the
 10107                                  ;		rom.  We now look on disk for the command.
 10108                                  ;
 10109                                  ;   This gives us the flexibility to execute any rom cartridge without having
 10110                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10111                                  ;   want to be invisible to the DOS should not have any names in their lists
 10112                                  ;   (i.e. they have a single null name).
 10113                                  ;
 10114                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10115                                  ;   Clearly this version will be available on disk.  How does a user actually
 10116                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10117                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10118                                  ;   solution:
 10119                                  ;
 10120                                  ;   o	Keep things consistent and force the user to have his software named
 10121                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10122                                  
 10123                                  struc ROM_HEADER
 10124 00000000 ??                          .signature1: resb 1
 10125 00000001 ??                          .signature2: resb 1
 10126 00000002 ??                          .rom_length: resb 1
 10127 00000003 ??????                      .init_jmp:	 resb 3
 10128 00000006 ??                          .name_list:	 resb 1
 10129                                      .size:
 10130                                  endstruc
 10131                                  
 10132                                  struc NAME_STRUC
 10133 00000000 ??                          .name_len:	resb 1
 10134 00000001 ??                          .name_text:	resb 1
 10135 00000002 ??????                      .name_jmp:	resb 3
 10136                                      .size:	
 10137                                  endstruc
 10138                                  
 10139                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10140                                  
 10141                                  ; =============== S U B	R O U T	I N E =======================================
 10142                                  
 10143                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10144                                  
 10145                                  ; 05/02/2023
 10146                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10147                                  
 10148                                  ; 07/06/2023
 10149                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:04D5h
 10150                                  
 10151                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10152                                  
 10153                                  ROM_SCAN:
 10154 000004CD 06                      	push	es
 10155 000004CE 56                      	push	si
 10156 000004CF 57                      	push	di
 10157 000004D0 51                      	push	cx
 10158 000004D1 50                      	push	ax
 10159 000004D2 53                      	push	bx
 10160                                  
 10161                                  	; check for PC Jr signature in rom
 10162                                  
 10163 000004D3 B800F0                  	mov	ax,0F000h
 10164 000004D6 8EC0                    	mov	es,ax
 10165 000004D8 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10166 000004DE 7408                    	je	short SCAN_IT
 10167                                  NO_ROM:
 10168 000004E0 F8                      	clc
 10169                                  ROM_RET:
 10170 000004E1 5B                      	pop	bx
 10171 000004E2 58                      	pop	ax
 10172 000004E3 59                      	pop	cx
 10173 000004E4 5F                      	pop	di
 10174 000004E5 5E                      	pop	si
 10175 000004E6 07                      	pop	es
 10176 000004E7 C3                      	retn
 10177                                  
 10178                                  	; start scanning at C000h
 10179                                  SCAN_IT:
 10180 000004E8 B800C0                  	mov	ax,0C000h
 10181                                  SCAN_ONE:
 10182 000004EB 8EC0                    	mov	es,ax
 10183 000004ED 31FF                    	xor	di,di
 10184                                  
 10185                                  	; check for a valid header
 10186                                  SCAN_MODULE:
 10187 000004EF 26813D55AA              	cmp	word [es:di],0AA55h
 10188 000004F4 740A                    	je	short SCAN_LIST
 10189 000004F6 058000                  	add	ax,80h
 10190                                  SCAN_END:
 10191 000004F9 3D00F0                  	cmp	ax,0F000h
 10192 000004FC 72ED                    	jb	short SCAN_ONE
 10193 000004FE EBE0                    	jmp	short NO_ROM
 10194                                  
 10195                                  	; trundle down list of names
 10196                                  SCAN_LIST:
 10197                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10198 00000500 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10199 00000504 30FF                    	xor	bh,bh		; nothing in the high byte
 10200 00000506 D1E3                    	shl	bx,1
 10201 00000508 D1E3                    	shl	bx,1		; number of paragraphs
 10202 0000050A 83C37F                  	add	bx,7Fh
 10203 0000050D 83E380                  	and	bx,0FF80h	; round to 2k
 10204                                  	;mov	di,6
 10205                                  	; 05/05/2023
 10206 00000510 BF0600                  	mov	di,ROM_HEADER.name_list
 10207                                  	;nop
 10208                                  SCAN_NAME:
 10209 00000513 268A0D                  	mov	cl,[es:di]	; length of name
 10210 00000516 47                      	inc	di		; point to name
 10211 00000517 30ED                    	xor	ch,ch
 10212 00000519 09C9                    	or	cx,cx		; zero length name
 10213 0000051B 7504                    	jnz	short SCAN_TEST	; nope... compare
 10214 0000051D 01D8                    	add	ax,bx		; yep, skip to next block
 10215 0000051F EBD8                    	jmp	short SCAN_END
 10216                                  
 10217                                  	; compare a single name
 10218                                  SCAN_TEST:
 10219 00000521 89D6                    	mov	si,dx
 10220 00000523 46                      	inc	si
 10221 00000524 F3A6                    	repe	cmpsb		 ; compare name
 10222 00000526 7407                    	jz	short SCAN_FOUND ; success!
 10223                                  SCAN_NEXT:
 10224 00000528 01CF                    	add	di,cx		; failure, next name piece
 10225 0000052A 83C703                  	add	di,3
 10226 0000052D EBE4                    	jmp	short SCAN_NAME
 10227                                  
 10228                                  	; found a name. save entry location
 10229                                  SCAN_FOUND:	
 10230 0000052F 803C3F                  	cmp	byte [si],'?'
 10231 00000532 7405                    	je	short SCAN_SAVE
 10232 00000534 803C20                  	cmp	byte [si],' '
 10233 00000537 75EF                    	jne	short SCAN_NEXT
 10234                                  SCAN_SAVE:
 10235 00000539 2E8C06[1DA1]            	mov	[cs:ROM_CS],es
 10236 0000053E 2E893E[1BA1]            	mov	[cs:ROM_IP],di
 10237 00000543 F9                      	stc
 10238 00000544 EB9B                    	jmp	short ROM_RET
 10239                                  
 10240                                  ; ---------------------------------------------------------------------------
 10241                                  
 10242                                  ; execute a rom-placed body of code. allocate largest block
 10243                                  
 10244                                  ROM_EXEC:
 10245 00000546 BBFFFF                  	mov	bx,0FFFFh
 10246                                  	; 05/02/2023
 10247 00000549 B448                    	mov	ah,48h
 10248                                  	;mov	ah,ALLOC ; 48h
 10249 0000054B CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10250                                  			; BX = number of 16-byte paragraphs desired
 10251 0000054D B448                    	mov	ah,48h
 10252                                  	;mov	ah,ALLOC ; 48h
 10253 0000054F CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10254                                  			; BX = number of 16-byte paragraphs desired
 10255 00000551 53                      	push	bx
 10256 00000552 50                      	push	ax
 10257                                  
 10258                                  	; set terminate addresses
 10259                                  
 10260 00000553 B82225                  	mov	ax,2522h
 10261                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10262                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10263 00000556 1E                      	push	ds
 10264 00000557 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 10265                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10266                                  	;mov	dx,131h ; MSDOS 3.3
 10267                                  	; 05/02/2023
 10268                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10269 0000055C BA[390D]                	mov	dx,Exec_Wait
 10270 0000055F CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10271                                  			; AL = interrupt number
 10272                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10273 00000561 8CDA                    	mov	dx,ds
 10274 00000563 8EC2                    	mov	es,dx
 10275 00000565 1F                      	pop	ds
 10276                                  		
 10277                                  	; and create program header and dup all jfn's
 10278                                  
 10279 00000566 5A                      	pop	dx
 10280 00000567 B455                    	mov	ah,55h
 10281                                  	;mov	ah,DUP_PDB ; 55h
 10282 00000569 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10283                                  			; DX = segment number at which to set up PSP
 10284                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10285                                  		
 10286                                  	; set up dma address
 10287                                  
 10288 0000056B 8EDA                    	mov	ds,dx
 10289 0000056D BA8000                  	mov	dx,80h
 10290 00000570 B41A                    	mov	ah,1Ah
 10291                                  	;mov	ah,Set_DMA ; 1Ah
 10292 00000572 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10293                                  			; DS:DX	-> disk	transfer buffer
 10294                                  
 10295                                  	; copy in environment info
 10296                                  
 10297 00000574 26A1[FA03]              	mov	ax,[es:EnvirSeg]
 10298                                  	;mov	[2Ch],ax
 10299 00000578 A32C00                  	mov	[PDB.ENVIRON],ax
 10300                                  
 10301                                  	; set up correct size of block
 10302                                  
 10303 0000057B 5B                      	pop	bx		; BX has size, DS has segment
 10304 0000057C 8CDA                    	mov	dx,ds
 10305 0000057E 01DA                    	add	dx,bx
 10306                                  	;mov	[2],dx
 10307 00000580 89160200                	mov	[PDB.BLOCK_LEN],dx
 10308                                  
 10309                                  	; change ownership of block
 10310                                  
 10311 00000584 8CDA                    	mov	dx,ds
 10312 00000586 4A                      	dec	dx
 10313 00000587 8EDA                    	mov	ds,dx
 10314 00000589 42                      	inc	dx	
 10315                                  	;mov	[1],dx
 10316 0000058A 89160100                	mov	[ARENA.owner],dx
 10317 0000058E 8EDA                    	mov	ds,dx
 10318                                  
 10319                                  	; set up correct stack
 10320                                  
 10321 00000590 81FB0010                	cmp	bx,1000h
 10322 00000594 7202                    	jb	short GOT_STACK
 10323 00000596 31DB                    	xor	bx,bx
 10324                                  GOT_STACK:
 10325 00000598 B104                    	mov	cl,4
 10326 0000059A D3E3                    	shl	bx,cl
 10327 0000059C 8CDA                    	mov	dx,ds
 10328 0000059E 8ED2                    	mov	ss,dx
 10329 000005A0 89DC                    	mov	sp,bx
 10330 000005A2 31C0                    	xor	ax,ax
 10331 000005A4 50                      	push	ax
 10332                                  
 10333                                  	; set up initial registers and go to the guy
 10334                                  
 10335 000005A5 F7D0                    	not	ax
 10336 000005A7 2EFF36[1DA1]            	push	word [cs:ROM_CS]
 10337 000005AC 2EFF36[1BA1]            	push	word [cs:ROM_IP]
 10338 000005B1 8EC2                    	mov	es,dx
 10339 000005B3 CB                      	retf	; far return
 10340                                  
 10341                                  ;============================================================================
 10342                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10343                                  ;============================================================================
 10344                                  ; 12/10/2018 - Retro DOS v3.0
 10345                                  
 10346                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10347                                  
 10348                                  ; =============== S U B	R O U T	I N E =======================================
 10349                                  
 10350                                  ;Break	<PromptBat - Open or wait for batch file>
 10351                                  
 10352                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10353                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10354                                  
 10355                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10356                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:05BCh
 10357                                  
 10358                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10359                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10360                                  ; file. Leave segment registers alone.
 10361                                  
 10362                                  PROMPTBAT:
 10363 000005B4 E84D08                  	call	BATOPEN
 10364 000005B7 7201                    	jc	short PROMPTBAT1
 10365 000005B9 C3                      	retn
 10366                                  PROMPTBAT1:
 10367                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10368                                  	; MSDOS 6.0 COMMAND.COM
 10369 000005BA 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10370 000005BD 740A                    	je	short BAT_REMCHECK	;AN022;
 10371 000005BF 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10372 000005C2 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10373                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10374 000005C4 E83500                  	call	output_batch_name
 10375 000005C7 EB13                    	jmp	short BATDIE		;AN022;
 10376                                  
 10377                                  	; 05/02/2023
 10378                                  	; MSDOS 3.3 COMMAND.COM
 10379                                  	;cmp	dx,ACCDENPTR
 10380                                  	;jz	short BATDIE
 10381                                  
 10382                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10383                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10384 000005C9 2EFF1E[EE9D]            	call	far [cs:RCH_ADDR]	; DX has error number
 10385 000005CE 7417                    	jz	short ASKFORBAT		; Media is removable
 10386                                  
 10387                                  ; The media is not changeable. Turn everything off.
 10388                                  
 10389 000005D0 E8450B                  	call	FOROFF
 10390 000005D3 E8DF2E                  	call	PipeOff
 10391 000005D6 A2[6602]                	mov	[IfFlag],al	; No If in progress.	
 10392 000005D9 BA[2092]                	mov	dx,BADBAT_PTR
 10393                                  BATDIE:
 10394 000005DC E8F203                  	call	BATCHOFF
 10395 000005DF 0E                      	push	cs
 10396 000005E0 1F                      	pop	ds
 10397                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10398                                  	; 05/02/2023
 10399 000005E1 E8514F                  	call	std_eprintf	; MSDOS 6.0
 10400                                  	;call	STD_PRINTF	; MSDOS 3.3
 10401                                  
 10402                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10403                                  
 10404 000005E4 E91DFB                  	jmp	TCOMMAND
 10405                                  
 10406                                  ; Ask the user to reinsert the batch file
 10407                                  
 10408                                  ASKFORBAT:
 10409 000005E7 1E                      	push	ds
 10410 000005E8 0E                      	push	cs
 10411 000005E9 1F                      	pop	ds
 10412                                  
 10413                                  	; MSDOS 6.0
 10414                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10415 000005EA BA[2392]                	mov	dx,NEEDBAT_PTR
 10416                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10417                                  	; 05/02/2023
 10418 000005ED E8454F                  	call	std_eprintf
 10419                                  	;mov	dx,offset trangroup:pausemes_ptr
 10420 000005F0 BA[9592]                	mov	dx,PAUSEMES_PTR
 10421                                  	;invoke std_eprintf		;AN000; get second part of message
 10422 000005F3 E83F4F                  	call	std_eprintf
 10423                                  					;AN000; print it to stderr
 10424                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10425                                  	;call	STD_EPRINTF
 10426 000005F6 E82E00                  	call	GETKEYSTROKE
 10427 000005F9 1F                      	pop	ds
 10428 000005FA EBB8                    	jmp	short PROMPTBAT
 10429                                  
 10430                                  
 10431                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10432                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10433                                  
 10434                                  	; MSDOS 6.0
 10435                                  ;****************************************************************
 10436                                  ;*
 10437                                  ;* ROUTINE:	Output_batch_name
 10438                                  ;*
 10439                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10440                                  ;*
 10441                                  ;* INPUT:	DX - extended error number
 10442                                  ;*
 10443                                  ;* OUTPUT:	Ready to call print routine
 10444                                  ;*
 10445                                  ;****************************************************************
 10446                                  ;
 10447                                  ;public	output_batch_name		;AN022;
 10448                                  
 10449                                  output_batch_name:	;proc near	;AN022;
 10450                                  
 10451 000005FC 1E                      	push	ds			;AN022; save resident segment
 10452 000005FD 8E1E[0502]              	mov	ds,[Batch]		;AN022; get batch file segment
 10453                                  	;assume	DS:nothing		;AN022;
 10454                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10455                                  	; 05/02/2023
 10456                                  	;mov	si,20h
 10457                                  	; 24/04/2023
 10458 00000601 BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10459                                  	;invoke	dstrlen 		;AN022; get length of string
 10460 00000604 E8B22B                  	call	dstrlen
 10461                                  	;mov	di,offset Trangroup:bwdbuf
 10462                                  					;AN022; target for batch name
 10463 00000607 BF[1FA0]                	mov	di,BWDBUF
 10464 0000060A F3A4                    	rep	movsb			;AN022; move the name
 10465                                  
 10466 0000060C 0E                      	push	cs			;AN022; get local segment
 10467 0000060D 1F                      	pop	ds			;AN022;
 10468                                  	;assume	DS:trangroup		;AN022;
 10469                                  	; 05/02/2023
 10470 0000060E 8916[0392]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10471                                  	;mov	byte [msg_disp_class],1
 10472 00000612 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 10473                                  					;AN022; set up extended error msg class
 10474                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10475 00000617 BA[0392]                	mov	dx,extend_buf_ptr	
 10476                                  					;AN022; get extended message pointer
 10477                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10478 0000061A C706[06A1][1FA0]        	mov	word [string_ptr_2],BWDBUF	
 10479                                  					;AN022; point to substitution
 10480                                  	;mov	byte [extend_buf_sub],1
 10481 00000620 C606[0592]01            	mov	byte [extend_buf_sub],one_subst
 10482                                  					;AN022; set up for one subst
 10483 00000625 1F                      	pop	ds			;AN022; restore data segment
 10484 00000626 C3                      	retn				;AN022; return
 10485                                  
 10486                                  ;output_batch_name    endp		;AN022;
 10487                                  
 10488                                  
 10489                                  ; =============== S U B	R O U T	I N E =======================================
 10490                                  
 10491                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10492                                  
 10493                                  ; Read the next keystroke. Since there may be several characters in the queue
 10494                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10495                                  ; AFTER waiting.
 10496                                  
 10497                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10498                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10499                                  
 10500                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10501                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:062Fh
 10502                                  
 10503                                  GETKEYSTROKE:
 10504                                  	; 05/02/2023
 10505                                  	; MSDOS 3.3
 10506                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10507                                  	;;mov	ax,0C08h
 10508                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10509                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10510                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10511                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10512                                  	;;mov	ax,0C00h
 10513                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10514                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10515                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10516                                  	;retn
 10517                                  
 10518                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10519                                  	; MSDOS 6.0
 10520 00000627 52                      	push	dx			;AN000;  3/3/KK
 10521                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10522                                  					;AN000;  3/3/KK
 10523 00000628 B80263                  	mov	ax,6302h
 10524 0000062B CD21                    	int	21h			;AN000;  3/3/KK
 10525                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10526                                  	
 10527 0000062D 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10528                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10529                                  					;AN000;  3/3/KK
 10530 0000062E B80163                  	mov	ax,6301h
 10531 00000631 B201                    	mov	dl,1
 10532                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10533 00000633 CD21                    	int	21h			;AN000;  3/3/KK
 10534                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10535                                  		; DL = new mode
 10536                                  		; 00h return only full characters on DOS keyboard input functions
 10537                                  		; 01h return partially-formed characters also
 10538                                  	
 10539                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10540 00000635 B8080C                  	mov	ax,0C08h
 10541 00000638 CD21                    	int	21h			; Get character with KB buffer flush
 10542                                  		; DOS - CLEAR KEYBOARD BUFFER
 10543                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10544                                  
 10545                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10546 0000063A B8000C                  	mov	ax,0C00h
 10547 0000063D CD21                    	int	21h
 10548                                  		; DOS - CLEAR KEYBOARD BUFFER
 10549                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10550                                  
 10551                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10552                                  					;AN000;  3/3/KK
 10553 0000063F B80163                  	mov	ax,6301h
 10554 00000642 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10555 00000643 CD21                    	int	21h			;AN000;  3/3/KK
 10556 00000645 5A                      	pop	dx			;AN000;  3/3/KK
 10557                                  	
 10558 00000646 C3                      	retn
 10559                                  
 10560                                  ; =============== S U B	R O U T	I N E =======================================
 10561                                  
 10562                                  ; Break	<ReadBat - read 1 line from batch file>
 10563                                  
 10564                                  ; ReadBat - read a single line from the batch file. 
 10565                                  ; Perform all substitutions as appropriate.
 10566                                  
 10567                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10568                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10569                                  
 10570                                  READBAT:
 10571                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10572                                  		
 10573                                  	;mov	byte [Suppress],1
 10574                                  				; initialize line suppress status
 10575 00000647 C606[5A02]01            	mov	byte [Suppress],YES_ECHO 
 10576 0000064C F606[4F02]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10577 00000651 751F                    	jnz	short TRYING_TO_ABORT
 10578 00000653 C606[4E02]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10579                                  
 10580                                  	; MSDOS 6.0
 10581                                  
 10582                                  ;M037; Start of changes
 10583                                  ; We check here if we have set the flag indicating that the batchfile is at
 10584                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10585                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10586                                  ;batch file gets closed etc. and then return as if everything is done.
 10587                                  
 10588                                  	; 05/02/2023
 10589 00000658 1E                      	push	ds
 10590 00000659 8E1E[0502]              	mov	ds,[Batch]
 10591                                  	;cmp	byte [2],0
 10592 0000065D 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10593                                  				; are we at EOF in batchfile
 10594 00000662 1F                      	pop	ds
 10595 00000663 740A                    	jz	short CONTBAT	; no, continue normal processing
 10596                                  	;invoke	GetBatByt	; frees up batchseg
 10597 00000665 E8D803                  	call	GETBATBYT
 10598 00000668 26A2[459C]              	mov	[es:COMBUF+2],al
 10599                                  				; stuff CR into command buffer
 10600                                  				; as a dummy command
 10601                                  	;;invoke CrLf2		; print a CR-LF
 10602                                  	;call	CRLF2
 10603                                  	;;return		; done batch processing
 10604                                  	;retn
 10605                                  	; 24/04/2023
 10606 0000066C E9AD24                  	jmp	CRLF2
 10607                                  
 10608                                  ;M037; End of changes
 10609                                  		
 10610                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10611                                  CONTBAT:
 10612 0000066F E842FF                  	call	PROMPTBAT
 10613                                  
 10614                                  TRYING_TO_ABORT:
 10615 00000672 BF[459C]                	mov	di,COMBUF+2
 10616                                  
 10617                                  ; Save position and try to scan for first non delimiter.
 10618                                  
 10619                                  TESTNOP:
 10620 00000675 8CD8                    	mov	ax,ds
 10621 00000677 8E1E[0502]              	mov	ds,[Batch]
 10622 0000067B FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10623 0000067F FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10624                                  				; save current location.
 10625 00000683 8ED8                    	mov	ds,ax
 10626 00000685 E85006                  	call	SKIPDELIM	; skip to first non-delim
 10627                                  
 10628                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10629                                  ; beginning and read the line.
 10630                                  
 10631 00000688 3C3A                    	cmp	al,':'		; is it a label?
 10632 0000068A 59                      	pop	cx
 10633 0000068B 5A                      	pop	dx		; restore position in bat file
 10634 0000068C 7431                    	jz	short NOPLINE	; yes, resync everything.
 10635 0000068E F706[0502]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10636 00000694 7438                    	jz	short RDBAT	; no, go read batch file
 10637                                  
 10638                                  	;cmp	al,'@'
 10639 00000696 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10640 00000698 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10641                                  	;mov	byte [Suppress],0
 10642 0000069A C606[5A02]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10643 0000069F EB2D                    	jmp	short RDBAT	; go read batch file
 10644                                  	;nop
 10645                                  SET_BAT_POS:
 10646 000006A1 1E                      	push	ds
 10647 000006A2 8E1E[0502]              	mov	ds,[Batch]
 10648                                  	;mov	[8],dx
 10649 000006A6 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10650                                  	;mov	[10],cx
 10651 000006AA 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10652 000006AE 1F                      	pop	ds
 10653                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10654                                  	; 05/02/2023
 10655 000006AF B80042                  	mov	ax,4200h
 10656                                  	;mov	ax,(LSEEK*256) ; 4200h ; seek back
 10657 000006B2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10658                                  			; AL = method: offset from beginning of	file
 10659                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10660                                  	; 24/04/2023
 10661                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10662 000006B4 26C706[2FAA]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10663                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10664 000006BB 31C9                    	xor	cx,cx		; Initialize line length to zero
 10665 000006BD EB0F                    	jmp	short RDBAT
 10666                                  
 10667                                  	;nop
 10668                                  
 10669                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10670                                  ; We eat characters until a CR is seen.
 10671                                  
 10672                                  NOPLINE:
 10673 000006BF E80501                  	call	SKIPTOEOL
 10674 000006C2 E87B03                  	call	GETBATBYT	; eat trailing LF
 10675                                  	;test	word [Batch],0FFFFh
 10676 000006C5 F706[0502]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10677 000006CB 75A8                    	jnz	short TESTNOP	; no, go get another line
 10678                                  READBAT_RETN:				; Hit EOF			
 10679 000006CD C3                      	retn
 10680                                  
 10681                                  ; ---------------------------------------------------------------------------
 10682                                  
 10683                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10684                                  ; input, we are to consider two special cases:
 10685                                  ;
 10686                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10687                                  ;   %sym%	This is a symbol from the environment
 10688                                  
 10689                                  RDBAT:
 10690 000006CE E86F03                  	call	GETBATBYT
 10691 000006D1 41                      	inc	cx		; Inc the line length
 10692                                  
 10693                                  	; 05/02/2023
 10694                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10695 000006D2 E83522                  	call	testkanj
 10696 000006D5 740C                    	jz	short RDBAT1
 10697                                  	;cmp	cx,127
 10698 000006D7 83F97F                  	cmp	cx,COMBUFLEN-1
 10699 000006DA 7350                    	jnb	short TOOLONG
 10700 000006DC AA                      	stosb
 10701 000006DD E86003                  	call    GETBATBYT
 10702 000006E0 41                      	inc	cx
 10703 000006E1 EB0A                    	jmp	short SAVBATBYT
 10704                                  RDBAT1:
 10705 000006E3 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10706 000006E7 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10707                                  
 10708                                  ; See if we have a parameter character.
 10709                                  
 10710 000006E9 3C25                    	cmp	al,'%'		; Check for parameter
 10711 000006EB 7449                    	je	short NEEDPARM
 10712                                  
 10713                                  ; no parameter character. Store it as usual and see if we are done.
 10714                                  
 10715                                  SAVBATBYT:
 10716 000006ED AA                      	stosb			; End of line found?
 10717 000006EE 3C0D                    	cmp	al,0Dh
 10718 000006F0 75DC                    	jne	short RDBAT	; no, go for more
 10719                                  
 10720                                  ; We have read in an entire line. 
 10721                                  ; Decide whether we should echo the command line or not.
 10722                                  
 10723                                  FOUND_EOL:
 10724 000006F2 81EF[469C]              	sub	di,COMBUF+3
 10725 000006F6 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10726 000006F8 26A2[449C]              	mov	[es:COMBUF+1],al
 10727                                  				; Set length of line
 10728 000006FC E84103                  	call	GETBATBYT	; Eat linefeed
 10729 000006FF E8EE06                  	call	BATCLOSE
 10730 00000702 803E[5A02]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10731 00000707 7407                    	jz	short RESET
 10732 00000709 F606[5902]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10733 0000070E 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10734                                  RESET:
 10735 00000710 0E                      	push	cs
 10736 00000711 1F                      	pop	ds		; Go back to local segment
 10737 00000712 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10738                                  TRY_NEXTFLAG:
 10739 00000714 803E[7002]01            	cmp	byte [NullFlag],nullcommand ; 1
 10740                                  				;G was there a command last time?
 10741 00000719 7403                    	jz	short NO_CRLF_PRINT
 10742                                  				;G no - don't print crlf
 10743 0000071B E8FE23                  	call	CRLF2		;G Print out prompt
 10744                                  NO_CRLF_PRINT:
 10745 0000071E E8BD1B                  	call	PRINT_PROMPT
 10746 00000721 0E                      	push	cs		;G change data segment
 10747 00000722 1F                      	pop	ds
 10748 00000723 BA[459C]                	mov	dx,COMBUF+2	; get command line for echoing
 10749 00000726 E84C24                  	call	CRPRINT
 10750                                  	;call	CRLF2
 10751                                  	;retn
 10752                                  	; 06/02/2023
 10753 00000729 E9F023                  	jmp	CRLF2
 10754                                  
 10755                                  ; The line was too long. Eat remainder of input text up until the CR
 10756                                  
 10757                                  TOOLONG:
 10758 0000072C 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10759 0000072E 7403                    	jz	short LTLCONT	; Yes, continue
 10760 00000730 E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10761                                  LTLCONT:
 10762 00000733 AA                      	stosb			; Terminate the command
 10763 00000734 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10764                                  
 10765                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10766                                  
 10767                                  NEEDPARM:
 10768 00000736 E80703                  	call	GETBATBYT	; get next character
 10769 00000739 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10770 0000073B 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10771 0000073D 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10772 0000073F 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10773                                  
 10774                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10775                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10776                                  ; see if the <something> has a terminating % and then look up the contents
 10777                                  ; in the environment.
 10778                                  
 10779                                  PAROK:
 10780 00000741 2C30                    	sub	al,'0'
 10781 00000743 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10782 00000745 3C09                    	cmp	al,9
 10783 00000747 7735                    	ja	short NEEDENV
 10784                                  
 10785                                  ; We have found %<number>. This is taken from the parameters in the
 10786                                  ; allocated batch area.
 10787                                  
 10788 00000749 98                      	cbw
 10789 0000074A 89C3                    	mov	bx,ax		; move index into AX
 10790 0000074C D1E3                    	shl	bx,1		; convert word index into byte ptr
 10791 0000074E 06                      	push	es
 10792 0000074F 8E06[0502]              	mov	es,[Batch]
 10793                                  
 10794                                  ; The structure of the batch area is:
 10795                                  ;
 10796                                  ;   BYTE    type of segment
 10797                                  ;   DWORD   offset for next line
 10798                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10799                                  ;   ASCIZ   file name (with . and ..)
 10800                                  ;   BYTES   CR-terminated parameters
 10801                                  ;   BYTE    0 flag to indicate end of parameters
 10802                                  ;
 10803                                  ; Get pointer to BX'th argument
 10804                                  
 10805                                  	;;mov	si,[es:bx+0Bh]
 10806                                  	; 05/02/2023
 10807                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10808 00000753 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10809 00000757 07                      	pop	es
 10810                                  
 10811                                  ; Is there a parameter here?
 10812                                  
 10813 00000758 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10814 0000075B 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10815 0000075D E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10816                                  
 10817                                  ; Copy in the found parameter from batch segment
 10818                                  
 10819                                  YES_THERE_IS:
 10820 00000760 1E                      	push	ds
 10821 00000761 8E1E[0502]              	mov	ds,[Batch]
 10822 00000765 49                      	dec	cx		; Don't count '%' in line length
 10823                                  COPYPARM:
 10824 00000766 AC                      	lodsb			; From resident segment
 10825 00000767 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10826 00000769 740F                    	je	short ENDPARAM
 10827 0000076B 41                      	inc	cx		; Inc the line length
 10828 0000076C 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10829 00000770 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10830 00000772 AA                      	stosb
 10831 00000773 EBF1                    	jmp	short COPYPARM
 10832                                  
 10833                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10834                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10835                                  ; believing that we are at EOL. Clobber AL too.
 10836                                  
 10837                                  LINETOOL:
 10838 00000775 30C0                    	xor	al,al
 10839 00000777 1F                      	pop	ds
 10840 00000778 EBB2                    	jmp	short TOOLONG
 10841                                  
 10842                                  ; We have copied in an entire parameter. Go back for more
 10843                                  
 10844                                  ENDPARAM:
 10845 0000077A 1F                      	pop	ds
 10846 0000077B E950FF                  	jmp	RDBAT
 10847                                  
 10848                                  ; We have found % followed by something other than 0-9. We presume that there
 10849                                  ; will be a following % character. In between is an environment variable that
 10850                                  ; we will fetch and replace in the batch line with its value.
 10851                                  
 10852                                  NEEDENV:
 10853                                  	; MSDOS 6.0 COMMAND.COM
 10854                                  	; 05/02/2023 
 10855 0000077E 49                      	dec     cx 		;AN070; Don't count "%"
 10856                                  
 10857                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10858 0000077F 1E                      	push	ds
 10859 00000780 57                      	push	di
 10860                                  				; temp spot for name
 10861 00000781 BF[A19F]                	mov	di,ID
 10862 00000784 0430                    	add	al,'0'		; reconvert character
 10863 00000786 AA                      	stosb			; store it in appropriate place
 10864                                  
 10865                                  ; loop getting characters until the next % is found or until EOL
 10866                                  
 10867                                  GETENV1:
 10868 00000787 E8B602                  	call	GETBATBYT	; get the byte
 10869 0000078A AA                      	stosb			; store it
 10870 0000078B 3C0D                    	cmp	al,0Dh		; EOL?
 10871 0000078D 7514                    	jne	short GETENV15	; no, see if it the term char
 10872                                  
 10873                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10874                                  
 10875 0000078F 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10876 00000794 BE[A19F]                	mov	si,ID 		; point to buffer
 10877 00000797 5F                      	pop	di		; point to line buffer
 10878 00000798 0E                      	push	cs
 10879 00000799 1F                      	pop	ds
 10880 0000079A E89002                  	call	STRCPY
 10881                                  	; 05/02/2023
 10882 0000079D 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10883                                  	; 24/04/2023
 10884                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10885 0000079F 1F                      	pop	ds
 10886 000007A0 E94AFF                  	jmp	SAVBATBYT
 10887                                  GETENV15:
 10888 000007A3 3C25                    	cmp	al,'%'		; terminating %?
 10889 000007A5 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10890                                  
 10891                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10892                                  ; This was the source of bug #1.
 10893                                  ;	dec	cx		;AN070; Don't count "%"
 10894                                  
 10895 000007A7 B03D                    	mov	al,'='		; terminate  with =
 10896 000007A9 268845FF                	mov	[es:di-1],al
 10897                                  
 10898                                  ; ID now either has a =-terminated string which we are to find in the
 10899                                  ; environment or a non =-terminated string which will not be found in the
 10900                                  ; environment.
 10901                                  
 10902                                  GETENV2:
 10903 000007AD BE[A19F]                	mov	si,ID
 10904 000007B0 0E                      	push	cs
 10905 000007B1 1F                      	pop	ds		; DS:SI points to name
 10906 000007B2 51                      	push	cx
 10907 000007B3 E8AA20                  	call	find_name_in_environment
 10908 000007B6 59                      	pop	cx
 10909 000007B7 06                      	push	es
 10910 000007B8 1F                      	pop	ds
 10911 000007B9 0E                      	push	cs
 10912 000007BA 07                      	pop	es
 10913 000007BB 89FE                    	mov	si,di
 10914 000007BD 5F                      	pop	di		; get back pointer to command line
 10915                                  
 10916                                  ; If the parameter was not found, there is no need to perform any replacement.
 10917                                  ; We merely pretend that we've copied the parameter.
 10918                                  
 10919 000007BE 7203                    	jc	short GETENV6
 10920                                  
 10921                                  ; ES:DI points to command line being built
 10922                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10923                                  
 10924 000007C0 E86A02                  	call	STRCPY		; (let RdBat handle overflow)
 10925                                  	; 24/04/2022
 10926                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10927                                  GETENV6:
 10928 000007C3 1F                      	pop	ds
 10929 000007C4 E907FF                  	jmp	RDBAT		; go back to batch file
 10930                                  
 10931                                  ; =============== S U B	R O U T	I N E =======================================
 10932                                  
 10933                                  ;   SkipToEOL - read from batch file until end of line
 10934                                  
 10935                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10936                                  SKIPTOEOL:
 10937 000007C7 F706[0502]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10938                                  	;jnz	short SKIPTOEOL1  	
 10939                                  	;retn			; no batch file in effect
 10940                                  	
 10941 000007CD 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10942                                  SKIPTOEOL1:
 10943 000007CF E86E02                  	call	GETBATBYT
 10944 000007D2 3C0D                    	cmp	al,0Dh		; eol character?
 10945 000007D4 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10946                                  SKIPTOEOL2:
 10947 000007D6 C3                      	retn
 10948                                  
 10949                                  ; =============== S U B	R O U T	I N E =======================================
 10950                                  
 10951                                  ;Break	<Allocate and deallocate the transient portion>
 10952                                  
 10953                                  ; Free Transient. Modify ES,AX,flags
 10954                                  
 10955                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10956                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10957                                  FREE_TPA:
 10958 000007D7 06                      	push	es
 10959 000007D8 8E06[E49D]              	mov	es,[RESSEG]
 10960 000007DC 268E06[1A04]            	mov	es,[es:Res_Tpa]
 10961 000007E1 B449                    	mov	ah,49h
 10962                                  	;mov	ah,DEALLOC ; 49h
 10963 000007E3 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10964                                  			; ES = segment address of area to be freed
 10965 000007E5 07                      	pop	es
 10966 000007E6 C3                      	retn
 10967                                  
 10968                                  ; =============== S U B	R O U T	I N E =======================================
 10969                                  
 10970                                  ; Allocate transient. Modify AX,BX,DX,flags
 10971                                  
 10972                                  	; 06/02/2023
 10973                                  ALLOC_TPA:
 10974 000007E7 06                      	push	es
 10975 000007E8 8E06[E49D]              	mov	es,[RESSEG]
 10976 000007EC BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10977 000007EF B448                    	mov	ah,48h
 10978                                  	;mov	ah,ALLOC ; 48h
 10979 000007F1 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10980                                  			; BX = number of 16-byte paragraphs desired
 10981 000007F3 53                      	push	bx	  	; Save size of block
 10982 000007F4 B448                    	mov	ah,48h
 10983                                  	;mov	ah,ALLOC ; 48h
 10984 000007F6 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10985                                  			; BX = number of 16-byte paragraphs desired
 10986                                  
 10987                                  ; Attempt to align TPA on 64K boundary
 10988                                  
 10989 000007F8 5B                      	pop	bx		; Restore size of block
 10990 000007F9 26A3[1A04]              	mov	[es:Res_Tpa],ax
 10991                                  				; Save segment to beginning of block
 10992 000007FD A3[F49D]                	mov	[TRAN_TPA],ax
 10993                                  
 10994                                  ; Is the segment already aligned on a 64K boundary
 10995                                  
 10996 00000800 89C2                    	mov	dx,ax		; Save segment
 10997 00000802 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10998 00000805 7507                    	jnz	short CALC_TPA
 10999 00000807 89D0                    	mov	ax,dx
 11000 00000809 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 11001 0000080C 7523                    	jnz	short NOROUND
 11002                                  CALC_TPA:
 11003 0000080E 89D0                    	mov	ax,dx
 11004 00000810 2500F0                  	and	ax,0F000h
 11005 00000813 050010                  	add	ax,1000h	; Round up to next 64K boundary
 11006 00000816 7219                    	jc	short NOROUND	; Memory wrap if carry set
 11007                                  
 11008                                  ; Make sure that new boundary is within allocated range
 11009                                  
 11010 00000818 268B16[1A04]            	mov	dx,[es:Res_Tpa]
 11011 0000081D 01DA                    	add	dx,bx		; Compute maximum address
 11012 0000081F 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 11013 00000821 720E                    	jb	short NOROUND
 11014                                  
 11015                                  ; Make sure that we won't overwrite the transient
 11016                                  
 11017 00000823 8CCB                    	mov	bx,cs		; CS is beginning of transient
 11018 00000825 39C3                    	cmp	bx,ax
 11019 00000827 7208                    	jb	short NOROUND
 11020                                  
 11021                                  ; The area from the 64K boundary to the beginning of the transient must
 11022                                  ; be at least 64K.
 11023                                  
 11024 00000829 29C3                    	sub	bx,ax
 11025                                  	;cmp	bx,4096
 11026 0000082B 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 11027 0000082F 7304                    	jnb	short ROUNDDONE
 11028                                  NOROUND:
 11029 00000831 26A1[1A04]              	mov	ax,[es:Res_Tpa]
 11030                                  ROUNDDONE:
 11031 00000835 26A3[0C04]              	mov	[es:LTpa],ax	; Re-compute everything
 11032 00000839 A3[E69D]                	mov	[TPA],ax
 11033 0000083C 89C3                    	mov	bx,ax
 11034 0000083E 8CC8                    	mov	ax,cs
 11035 00000840 29D8                    	sub	ax,bx
 11036 00000842 53                      	push	bx
 11037 00000843 BB1000                  	mov	bx,16
 11038 00000846 F7E3                    	mul	bx
 11039 00000848 5B                      	pop	bx
 11040 00000849 09D2                    	or	dx,dx
 11041 0000084B 7403                    	jz	short SAVSIZ2
 11042 0000084D B8FFFF                  	mov	ax,-1
 11043                                  SAVSIZ2:
 11044                                  
 11045                                  ; AX is the number of bytes free in the buffer between the resident and the
 11046                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 11047                                  
 11048 00000850 3D0002                  	cmp	ax,512
 11049 00000853 7603                    	jbe	short GOTSIZE2
 11050                                  	;and	ax,~1FFh
 11051 00000855 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 11052                                  GOTSIZE2:
 11053 00000858 A3[059E]                	mov	[BYTCNT],ax
 11054 0000085B 07                      	pop	es
 11055 0000085C C3                      	retn
 11056                                  
 11057                                  ; =============== S U B	R O U T	I N E =======================================
 11058                                  
 11059                                  ;Break	<BatCom - enter a batch file>
 11060                                  
 11061                                  ; The exec search has determined that the user has requested a batch file for
 11062                                  ; execution. We parse the arguments, create the batch segment, and signal
 11063                                  ; batch processing.
 11064                                  
 11065                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11066                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 11067                                  
 11068                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11069                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0868h
 11070                                  BATCOM:	
 11071                                  
 11072                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 11073                                  
 11074                                  ; Batch parameters are read with ES set to segment of resident part
 11075                                  
 11076                                  	; MSDOS 6.0
 11077 0000085D 8E06[E49D]              	mov	es,[RESSEG]
 11078                                  	;ASSUME	ES:RESGROUP
 11079                                  	;cmp	byte [es:Call_Batch_Flag],1
 11080 00000861 26803E[6D02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11081                                  					;AN043; If in CALL,
 11082 00000867 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 11083                                  	;invoke	IOSET			; Set up any redirection
 11084 00000869 E85C28                  	call	IOSET
 11085                                  skip_ioset:				;AN043;
 11086 0000086C E868FF                  	call	FREE_TPA		; G
 11087                                  	;cmp	byte [es:Call_Batch_Flag],1
 11088 0000086F 26803E[6D02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11089 00000875 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 11090                                  
 11091                                  	; 12/02/2023
 11092                                  	; MSDOS 3.3
 11093                                  	;call	IOSET
 11094                                  	;mov	es,[RESSEG]
 11095                                  	;call	FREE_TPA
 11096                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 11097                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 11098                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 11099                                  
 11100                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11101                                  
 11102                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 11103                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 11104                                  ; Don't execute if in call
 11105                                  
 11106 00000877 E89E08                  	call	FOROFF
 11107                                  GETECHO:
 11108 0000087A E8382C                  	call	PipeOff
 11109 0000087D 26A0[5902]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 11110 00000881 2401                    	and	al,1			; Save current echo state
 11111                                  
 11112 00000883 50                      	push	ax
 11113 00000884 31C0                    	xor	ax,ax
 11114 00000886 26F706[0502]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 11115 0000088D 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 11116 0000088F 26A1[0502]              	mov	ax,[es:Batch] 		; Get current batch segment
 11117                                  	;cmp	byte [es:Call_Batch_Flag],1
 11118 00000893 26803E[6D02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11119 00000899 7408                    	jz	short LEAVEBAT
 11120                                  
 11121                                  ;  We are in a chained batch file, save batlast from previous batch segment
 11122                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11123                                  
 11124 0000089B 06                      	push	es
 11125 0000089C 8EC0                    	mov	es,ax		; Get current batch segment
 11126                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11127                                  				; Get previous batch segment
 11128                                  	; 12/02/2023
 11129                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11130 0000089E 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11131 000008A2 07                      	pop	es
 11132                                  LEAVEBAT:
 11133 000008A3 50                      	push	ax		; Keep segment until new one created
 11134                                  	;cmp	byte [es:Call_Batch_Flag],1
 11135 000008A4 26803E[6D02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11136 000008AA 7403                    	jz	short STARTBAT
 11137 000008AC E82201                  	call	BATCHOFF
 11138                                  
 11139                                  ; Find length of batch file
 11140                                  
 11141                                  STARTBAT:
 11142 000008AF 26C606[6D02]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11143 000008B5 BE[0C9D]                	mov	si,EXECPATH
 11144                                  
 11145                                  	; 12/02/2023
 11146                                  	; MSDOS 6.0
 11147 000008B8 B811B7                  	mov	ax,0B711h
 11148                                  	;mov	ax,AppendTruename
 11149                                  				;AN042; Get the real path where the batch file
 11150 000008BB CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11151 000008BD B44E                    	mov	ah,4Eh
 11152                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11153 000008BF 89F2                    	mov	dx,si		;AN042; Get the string
 11154 000008C1 B91300                  	mov	cx,13h
 11155                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11156 000008C4 CD21                    	int	21h		;AN042;
 11157                                  
 11158                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11159 000008C6 E8F028                  	call	dstrlen
 11160                                  ;
 11161                                  ; Allocate batch area:
 11162                                  ;   BYTE    type of segment
 11163                                  ;   WORD    segment of last batch file
 11164                                  ;   WORD    segment for FOR command
 11165                                  ;   BYTE    FOR flag state on entry to batch file
 11166                                  ;   DWORD   offset for next line
 11167                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11168                                  ;   ASCIZ   file name (with . and ..)
 11169                                  ;   BYTES   CR-terminated parameters
 11170                                  ;   BYTE    0 flag to indicate end of parameters
 11171                                  ;
 11172                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11173                                  ; later when we've squeezed out the extra
 11174                                  ;
 11175 000008C9 89CB                    	mov	bx,cx		; length of file name.
 11176                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11177                                  	; 12/02/2023
 11178                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11179                                  	; 25/04/2023
 11180 000008CB 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11181                                  					; structure + max len + round up
 11182 000008CF 51                      	push	cx
 11183 000008D0 B104                    	mov	cl,4
 11184 000008D2 D3EB                    	shr	bx,cl		; convert to paragraphs
 11185 000008D4 53                      	push	bx		; Save size of batch segment
 11186 000008D5 B448                    	mov	ah,48h
 11187                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11188 000008D7 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11189                                  				; BX = number of 16-byte paragraphs desired
 11190 000008D9 5B                      	pop	bx		; Get size of batch segment
 11191                                  
 11192                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11193                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11194                                  ; G This error will occur with nesting of batch files. We also need to
 11195                                  ; G make sure that we don't overlay the transient.
 11196                                  
 11197 000008DA 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11198                                  
 11199 000008DC 50                      	push	ax		;G save batch segment
 11200 000008DD 01D8                    	add	ax,bx		;G get end of batch segment
 11201 000008DF 83C020                  	add	ax,20h		;G add some tpa work area
 11202 000008E2 8CCB                    	mov	bx,cs		;G get the transient segment
 11203                                  
 11204                                  	; MSDOS 6.0
 11205                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11206                                  ; M006; batchseg is always above the transient. We need to change this code
 11207                                  ; M006; to only check for an overlap
 11208                                  
 11209                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11210                                  	; 12/02/2023
 11211                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11212                                  	;mov	dx,TRANSPACEEND		
 11213                                  	;add	dx,15		;round up para; M006
 11214 000008E4 BA86AA                  	mov	dx,TRANSPACEEND+15
 11215                                  
 11216 000008E7 D3EA                    	shr	dx,cl		;para size of transient; M006
 11217 000008E9 01DA                    	add	dx,bx		;dx = top of transient; M006
 11218                                  
 11219 000008EB 39D8                    	cmp	ax,bx		; M006
 11220 000008ED 7211                    	jb	short ENOUGH_MEM
 11221                                  				; Batchseg below transient
 11222                                  				; enough memory ; M006
 11223 000008EF 39D0                    	cmp	ax,dx		; M006
 11224 000008F1 770D                    	ja	short ENOUGH_MEM	
 11225                                  				; Batchseg above transient
 11226                                  				; enough memory ; M006
 11227                                  
 11228                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11229                                  
 11230 000008F3 58                      	pop	ax		; restore ax; M006
 11231                                  
 11232                                  	; 12/02/2023
 11233                                  	; MSDOS 3.3
 11234                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11235                                  ; M006;	pop	ax		;G get batch segment back
 11236                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11237                                  
 11238                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11239 000008F4 06                      	push	es		;G no we're hitting the transient
 11240 000008F5 8EC0                    	mov	es,ax
 11241 000008F7 B80049                  	mov	ax,4900h
 11242                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11243 000008FA CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11244                                  			; ES = segment address of area to be freed
 11245 000008FC 07                      	pop	es
 11246                                  MEM_ERROR:
 11247 000008FD E9BA00                  	jmp	NO_MEMORY	;G Set up for message and exit
 11248                                  
 11249                                  ENOUGH_MEM:
 11250                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11251                                  	; MSDOS 6.0
 11252 00000900 58                      	pop	ax		; restore ax; M006
 11253                                  
 11254                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11255 00000901 26A3[0502]              	mov	[es:Batch],ax
 11256 00000905 E8DFFE                  	call	ALLOC_TPA
 11257                                  
 11258                                  ; Initialize batch segment
 11259                                  
 11260 00000908 5A                      	pop	dx		; length of name
 11261 00000909 58                      	pop	ax		;G get saved batch segment back
 11262 0000090A 26FF06[6A02]            	inc	word [es:Nest]	;G increment # batch files in progress
 11263 0000090F 06                      	push	es
 11264 00000910 268E06[0502]            	mov	es,[es:Batch]
 11265                                  	;mov	byte [ES:0],0
 11266                                  				; signal batch file type
 11267 00000915 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11268                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11269                                  				;G save segment of last batch file
 11270                                  	;mov	[es:3],ax	; MSDOS 6.0
 11271 0000091B 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11272 0000091F 1E                      	push	ds
 11273 00000920 8E1E[E49D]              	mov	ds,[RESSEG]	;G set to resident data
 11274                                  
 11275 00000924 31C0                    	xor	ax,ax
 11276 00000926 8A1E[6702]              	mov	bl,[ForFlag]	;G get the current FOR state
 11277                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11278                                  				;G save it in the batch segment
 11279                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11280 0000092A 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11281 0000092F F6C3FF                  	test	bl,-1 ; 0FFh	;G are we in a FOR?
 11282 00000932 7408                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11283 00000934 A1[6802]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11284 00000937 C606[6702]00            	mov	byte [ForFlag],0 ;G reset forflag
 11285                                  FOR_NOT_ON:
 11286                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11287                                  				;G save FOR segment in batch segment
 11288                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11289 0000093C 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11290 00000940 31C0                    	xor	ax,ax
 11291 00000942 A3[6802]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11292 00000945 8A1E[5902]              	mov	bl,[EchoFlag]
 11293 00000949 1F                      	pop	ds
 11294                                  	;mov	[es:1],bl 
 11295                                  				 ;G save echo state of parent
 11296 0000094A 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11297                                  ;SR;
 11298                                  ; Initialize the new BatchEOF flag we have added to 0
 11299                                  
 11300                                  	; MSDOS 6.0
 11301                                  	;mov	byte [es:2],0
 11302 0000094F 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11303                                  
 11304                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11305 00000955 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11306                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11307 00000959 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11308                                  
 11309                                  ; Initialize pointers
 11310                                  
 11311 0000095D 48                      	dec	ax		; put -1 into AX
 11312                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11313                                  				; point to parm area
 11314                                  	;mov	di,0Ch	; MSDOS 6.0
 11315 0000095E BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11316 00000961 89FB                    	mov	bx,di
 11317 00000963 B90A00                  	mov	cx,10
 11318 00000966 F3AB                    	rep stosw		; Init to no parms
 11319                                  
 11320                                  ; Move in batch file name
 11321                                  
 11322 00000968 89D1                    	mov	cx,dx
 11323 0000096A F3A4                    	rep	movsb
 11324                                  
 11325                                  ; Now copy the command line into batch segment, parsing the arguments along
 11326                                  ; the way. Segment will look like this:
 11327                                  ;
 11328                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11329                                  ;
 11330                                  ; or, in the case of fewer arguments:
 11331                                  ;
 11332                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11333                                  
 11334 0000096C BE[459C]                	mov	si,COMBUF+2
 11335                                  	;mov	cx,10		; at most 10 arguments
 11336                                  	; 07/06/2023
 11337 0000096F B10A                    	mov	cl,10
 11338                                  EACHPARM:
 11339 00000971 E8B521                  	call	scanoff		; skip to argument
 11340                                  
 11341                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11342                                  
 11343 00000974 3C0D                    	cmp	al,0Dh		; end of road?
 11344 00000976 741D                    	jz	short HAVPARM	; yes, no more arguments
 11345                                  
 11346                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11347                                  
 11348 00000978 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11349                                  
 11350                                  ; Go into allocated piece and stick in new argument pointer.
 11351                                  
 11352 0000097A 26893F                  	mov	[es:bx],di	; store batch pointer
 11353 0000097D 83C302                  	add	bx,2		; advance arg counter
 11354                                  
 11355                                  ; Move the parameter into batch segment
 11356                                  
 11357                                  MOVPARM:
 11358 00000980 AC                      	lodsb			; get byte
 11359 00000981 E8AD21                  	call	DELIM		; if delimiter
 11360 00000984 7407                    	jz	short ENDPARM	; then done with parm
 11361 00000986 AA                      	stosb			; store byte
 11362 00000987 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11363 00000989 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11364 0000098B EBF3                    	jmp	short MOVPARM
 11365                                  
 11366                                  ; We have copied a parameter up until the first separator.
 11367                                  ; Terminate it with CR.
 11368                                  
 11369                                  ENDPARM:
 11370 0000098D B00D                    	mov	al,0Dh
 11371 0000098F AA                      	stosb
 11372 00000990 E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11373 00000992 49                      	dec	cx		; remember that we've seen one.	
 11374 00000993 EBDC                    	jmp	short EACHPARM
 11375                                  
 11376                                  ; We have parsed the entire line. Terminate the arg list
 11377                                  
 11378                                  HAVPARM:
 11379 00000995 30C0                    	xor	al,al		; Nul terminate the parms
 11380 00000997 AA                      	stosb
 11381                                  
 11382                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11383                                  ; into paragraphs and setblock to the appropriate size
 11384                                  
 11385 00000998 8D5D0F                  	lea	bx,[di+15]
 11386 0000099B B104                    	mov	cl,4
 11387 0000099D D3EB                    	shr	bx,cl
 11388 0000099F B44A                    	mov	ah,4Ah
 11389                                  	;mov	ah,SETBLOCK ; 4Ah
 11390 000009A1 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11391                                  			; ES = segment address of block	to change
 11392                                  			; BX = new size	in paragraphs
 11393 000009A3 07                      	pop	es
 11394 000009A4 06                      	push	es
 11395 000009A5 1F                      	pop	ds		; Simply batch FCB setup
 11396 000009A6 833E[6102]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11397 000009AB 7506                    	jne	short NOBATSING
 11398 000009AD C706[6102]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11399                                  
 11400                                  NOBATSING:
 11401                                  
 11402                                  ; Enter the batch file with the current echo state
 11403                                  
 11404 000009B3 58                      	pop	ax		; Get original echo state
 11405 000009B4 A2[5902]                	mov	[EchoFlag],al	; restore it
 11406 000009B7 E94AF7                  	jmp	TCOMMAND
 11407                                  
 11408                                  ; The following is executed if there isn't enough memory for batch segment
 11409                                  
 11410                                  NO_MEMORY:
 11411 000009BA 5A                      	pop	dx		; even up our stack 
 11412 000009BB 58                      	pop	ax
 11413 000009BC 58                      	pop	ax
 11414 000009BD E827FE                  	call	ALLOC_TPA	; reallocate memory
 11415                                  
 11416                                  	; 12/02/2023
 11417                                  	; MSDOS 3.3
 11418                                  	;mov	dx,INSFMEMMESPTR
 11419                                  	;jmp	CERROR
 11420                                  
 11421                                  	; MSDOS 6.0
 11422                                  	;mov	byte [msg_disp_class],1
 11423 000009C0 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 11424                                  				;AN000; set up extended error msg class
 11425                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11426 000009C5 BA[0392]                	mov	dx,extend_buf_ptr
 11427                                  	;			;AC000; get extended message pointer
 11428                                  	;mov	word [extend_buf_ptr],8
 11429 000009C8 C706[0392]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11430                                  				;AN000; get message number in control block
 11431 000009CE E9CC24                  	jmp	cerror		;g print error message and go...
 11432                                  
 11433                                  ; =============== S U B	R O U T	I N E =======================================
 11434                                  
 11435                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11436                                  BATCHOFF:
 11437 000009D1 50                      	push	ax
 11438 000009D2 06                      	push	es
 11439 000009D3 1E                      	push	ds
 11440 000009D4 53                      	push	bx
 11441                                  
 11442 000009D5 2E8E06[E49D]            	mov	es,[cs:RESSEG]
 11443 000009DA 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 11444 000009DF A1[0502]                	mov	ax,[Batch]	; Free the batch segment
 11445 000009E2 09C0                    	or	ax,ax
 11446 000009E4 7442                    	jz	short NOTFREE
 11447                                  
 11448 000009E6 06                      	push	es
 11449 000009E7 8EC0                    	mov	es,ax
 11450 000009E9 F606[5902]01            	test	byte [EchoFlag],1
 11451                                  				;G Is echo on?
 11452 000009EE 7505                    	jnz	short ECHO_LAST_LINE
 11453                                  				;G Yes - echo last line in file
 11454                                  	;mov	byte [SUPPRESS],0
 11455 000009F0 C606[5A02]00            	mov	byte [Suppress],NO_ECHO
 11456                                  				;G no - don't echo last line in file	
 11457                                  ECHO_LAST_LINE:
 11458                                  	;mov	bl,[es:1]
 11459 000009F5 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11460                                  				; G get echo state
 11461 000009FA 881E[5902]              	mov	[EchoFlag],bl
 11462                                  				; G  and restore it
 11463                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11464                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11465 000009FE 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11466                                  				;G Get FOR segment
 11467 00000A03 891E[6802]              	mov	[ForPtr],bx	;G  and restore it
 11468                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11469                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11470 00000A07 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11471                                  				;G Get FOR flag
 11472 00000A0C 881E[6702]              	mov	[ForFlag],bl
 11473                                  				;G  and restore it
 11474                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11475                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11476 00000A10 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11477                                  				;G  Get old batch segment
 11478                                  
 11479 00000A15 B449                    	mov	ah,49h
 11480                                  	;mov	ah,DEALLOC ; 49h
 11481 00000A17 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11482                                  			; ES = segment address of area to be freed
 11483 00000A19 07                      	pop	es
 11484 00000A1A 891E[6E02]              	mov	[Next_Batch],bx	;G reset batch segment	
 11485 00000A1E 26FF0E[6A02]            	dec	word [es:Nest]
 11486 00000A23 31C0                    	xor	ax,ax
 11487 00000A25 A3[0502]                	mov	[Batch],ax	; No batch in progress
 11488                                  NOTFREE:
 11489 00000A28 5B                      	pop	bx
 11490 00000A29 1F                      	pop	ds
 11491 00000A2A 07                      	pop	es
 11492 00000A2B 58                      	pop	ax
 11493 00000A2C C3                      	retn
 11494                                  
 11495                                  ; =============== S U B	R O U T	I N E =======================================
 11496                                  
 11497                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11498                                  
 11499                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11500                                  ;	Entry : DS:SI ==> source string
 11501                                  ;		ES:DI ==> destination string
 11502                                  ;		CX = current length of destination string
 11503                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11504                                  
 11505                                  	; 12/02/2023	
 11506                                  	; MSDOS 3.3
 11507                                  ;STRCPY:
 11508                                  	;push	ax
 11509                                  ;CCYCLE:
 11510                                  	;lodsb
 11511                                  	;stosb
 11512                                  	;or	al,al
 11513                                  	;jnz	short CCYCLE
 11514                                  	;pop	ax
 11515                                  	;retn
 11516                                  
 11517                                  ;Procedure StrCpy,NEAR
 11518                                  
 11519                                  	; 12/02/2023
 11520                                  	; MSDOS 6.0
 11521                                  STRCPY:
 11522 00000A2D 50                      	push	ax
 11523                                  ccycle:
 11524 00000A2E AC                      	lodsb
 11525 00000A2F 41                      	inc	cx
 11526                                  	;cmp	cx,128
 11527 00000A30 81F98000                	cmp	cx,COMBUFLEN
 11528                                  	;jb	short ccopy
 11529                                  	;stc			; set carry to signal error
 11530                                  	;jmp	short ccend
 11531                                  	; 12/02/2023
 11532 00000A34 F5                      	cmc
 11533 00000A35 7205                    	jc	short ccend
 11534                                  ccopy:
 11535 00000A37 AA                      	stosb
 11536 00000A38 08C0                    	or	al,al
 11537 00000A3A 75F2                    	jnz	short ccycle
 11538                                  ccend:
 11539 00000A3C 49                      	dec	cx		; discount extra byte
 11540 00000A3D 4F                      	dec	di		; back up pointer
 11541 00000A3E 58                      	pop	ax
 11542 00000A3F C3                      	retn			; return carry clear
 11543                                  
 11544                                  ;EndProc StrCpy
 11545                                  
 11546                                  ;============================================================================
 11547                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11548                                  ;============================================================================
 11549                                  ; 12/10/2018 - Retro DOS v3.0
 11550                                  
 11551                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11552                                  
 11553                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11554                                  
 11555                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11556                                  
 11557                                  ; =============== S U B	R O U T	I N E =======================================
 11558                                  
 11559                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11560                                  
 11561                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11562                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11563                                  ; AH, DX destroyed.
 11564                                  
 11565                                  GETBATBYT:
 11566 00000A40 53                      	push	bx
 11567 00000A41 51                      	push	cx
 11568 00000A42 1E                      	push	ds
 11569 00000A43 F606[4F02]FF            	test	byte [Batch_Abort],-1
 11570                                  	;jnz	short BATEOF
 11571                                  	; 14/02/2023
 11572 00000A48 7403                    	jz	short getbatbyt1
 11573 00000A4A E9D100                  	jmp	BATEOF
 11574                                  getbatbyt1:
 11575 00000A4D F706[0502]FFFF          	test	word [Batch],-1
 11576                                  	;jz	short BATEOF
 11577                                  	; 14/02/2023
 11578 00000A53 7503                    	jnz	short getbatbyt2
 11579 00000A55 E9C600                  	jmp	BATEOF
 11580                                  getbatbyt2:
 11581 00000A58 06                      	push	es
 11582 00000A59 8E06[0502]              	mov	es,[Batch]
 11583                                  
 11584                                  	; MSDOS 6.0
 11585                                  ;M020;
 11586                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11587                                  ;try to read from the batchfile again.
 11588                                  
 11589                                  	;cmp	byte [es:2],0
 11590 00000A5D 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11591                                  				;already reached EOF?	;M020
 11592 00000A63 7403                    	jz	short not_eof	;no, read batch file	;M020
 11593 00000A65 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11594                                  not_eof:						;M020
 11595                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11596                                  	;add	word [es:8],1	; MSDOS 6.0
 11597 00000A68 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11598                                  	;adc	word [es:10],0	; MSDOS 6.0
 11599 00000A6E 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11600 00000A74 07                      	pop	es
 11601                                  
 11602                                  ; See if we have bytes buffered...
 11603                                  
 11604 00000A75 8CC8                    	mov	ax,cs
 11605 00000A77 8ED8                    	mov	ds,ax
 11606 00000A79 8B1E[2FAA]              	mov	bx,[BATBUFPOS]
 11607 00000A7D 83FBFF                  	cmp	bx,-1
 11608 00000A80 7540                    	jnz	short UNBUF
 11609                                  
 11610                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11611                                  
 11612 00000A82 BA[31AA]                	mov	dx,BATBUF
 11613 00000A85 8B0E[A797]              	mov	cx,[BATBUFLEN] ; max to read.
 11614 00000A89 8B1E[5AA2]              	mov	bx,[BATHAND]
 11615                                  	; 14/02/2023
 11616 00000A8D B43F                    	mov	ah,3Fh
 11617                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11618 00000A8F CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11619                                  			; BX = file handle,CX = number	of bytes to read
 11620                                  			; DS:DX	-> buffer
 11621                                  	; MSDOS 6.0
 11622 00000A91 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11623                                  	;invoke	get_ext_error_number	;AN022; get the error
 11624 00000A93 E8B817                  	call	get_ext_error_number
 11625 00000A96 1E                      	push	ds			;AN022; save local segment
 11626 00000A97 8E1E[E49D]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11627                                  	;assume ds:resgroup		;AN022;
 11628 00000A9B 89C2                    	mov	dx,ax			;AN022; put error in DX
 11629                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11630 00000A9D E85CFB                  	call	output_batch_name
 11631 00000AA0 1F                      	pop	ds			;AN022;
 11632                                  	;assume	ds:trangroup		;AN022;
 11633                                  	;invoke	std_eprintf		;AN022; print out the error
 11634 00000AA1 E8914A                  	call	std_eprintf
 11635                                  	;mov	byte ptr combuf+2,end_of_line_in
 11636 00000AA4 C606[459C]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11637                                  	;				;AN022; terminate the batch line for parsing
 11638                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11639 00000AA9 C606[469C]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11640                                  	;				;AN022; terminate the batch line for output
 11641                                  ;M020;
 11642                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11643                                  ;error is never hit (and it shouldn't be)
 11644                                  
 11645 00000AAE 8E1E[E49D]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11646 00000AB2 EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11647                                  bat_read_ok:				;AN022;
 11648                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11649 00000AB4 89C1                    	mov	cx,ax
 11650                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11651                                  	; 14/02/2023
 11652 00000AB6 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11653 00000AB8 890E[51AA]              	mov	[BATBUFEND],cx
 11654 00000ABC 31DB                    	xor	bx,bx
 11655 00000ABE 891E[2FAA]              	mov	[BATBUFPOS],bx
 11656                                  
 11657                                  	; Buffered bytes!
 11658                                  UNBUF:
 11659 00000AC2 8A87[31AA]              	mov	al,[BATBUF+bx]		; get next byte
 11660 00000AC6 43                      	inc	bx
 11661 00000AC7 3B1E[51AA]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11662 00000ACB 7203                    	jb	short SETBUFPOS
 11663 00000ACD BBFFFF                  	mov	bx,-1
 11664                                  SETBUFPOS:
 11665 00000AD0 891E[2FAA]              	mov	[BATBUFPOS],bx
 11666 00000AD4 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11667 00000AD6 7575                    	jne	short GETBYTEDONE
 11668                                  
 11669                                  ;We get here only when we hit an EOF
 11670                                  	
 11671                                  	; MSDOS 6.0
 11672                                  BATEOFDS:
 11673                                  ;SR;
 11674                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11675                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11676                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11677                                  ;batch processing is turned off before the last line is processed and so 
 11678                                  ;this line would never be executed. 
 11679                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11680                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11681                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11682                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11683                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11684                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11685                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11686                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11687                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11688                                  ;another redundant CR-LF. There is no work-around I can think of.
 11689                                  ; 	I would love to restructure this entire routine and its caller to
 11690                                  ;make the flow really easy to understand but I guess this will have to wait.
 11691                                  ;
 11692 00000AD8 06                      	push	es
 11693 00000AD9 8E06[E49D]              	mov	es,[RESSEG]
 11694                                  ;SR;
 11695                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11696                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11697                                  ;
 11698 00000ADD 268E06[0502]            	mov	es,[es:Batch]
 11699                                  	;cmp	byte [es:2],0
 11700 00000AE2 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11701 00000AE8 7516                    	jnz	short crpresent
 11702                                  
 11703                                  	;inc	byte [es:2]
 11704 00000AEA 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11705                                  					;match the dec following
 11706 00000AEF 8B1E[51AA]              	mov	bx,[BATBUFEND]
 11707 00000AF3 80BF[30AA]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11708 00000AF8 7406                    	je	short crpresent		;yes, no need to fake it
 11709                                  
 11710                                  	;add	byte [es:2],3
 11711 00000AFA 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11712                                  					;BatchEOF == 4 to fake CR-LF
 11713                                  crpresent:
 11714                                  ;;	;pop	es
 11715                                  
 11716                                  	;ASSUME	DS:TranGroup
 11717                                  	; 14/02/2023
 11718 00000B00 8E1E[E49D]              	mov	ds,[RESSEG]
 11719                                  	;ASSUME	DS:ResGroup
 11720                                  ;SR;
 11721                                  ; The shift operation is done here to replace the decrement. This is because
 11722                                  ;we can jump to this label directly from above when bogus calls are made to
 11723                                  ;this routine even after batch processing is turned off. The shift ensures
 11724                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11725                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11726                                  ;calls.
 11727                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11728                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11729                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11730                                  ;turning batch processing off.
 11731                                  
 11732                                  At_EOF:					;new label added ;M020
 11733                                  	;shr	byte [es:2],1
 11734 00000B04 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11735                                  					;decrement the flag
 11736 00000B09 7412                    	jz	short turn_off		;zero,turn batch off
 11737                                  	;cmp	byte [es:2],1
 11738 00000B0B 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11739 00000B11 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11740                                  ;
 11741                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11742                                  ;
 11743 00000B13 B00D                    	mov	al,0Dh			;return fake CR.
 11744 00000B15 07                      	pop	es
 11745 00000B16 EB35                    	jmp	short GETBYTEDONE
 11746                                  ret_lf:
 11747 00000B18 B00A                    	mov	al,0Ah			;return fake LF
 11748 00000B1A 07                      	pop	es
 11749 00000B1B EB30                    	jmp	short GETBYTEDONE		
 11750                                  turn_off:
 11751 00000B1D 07                      	pop	es
 11752                                  ;BATEOF:
 11753                                  	; MSDOS 3.3
 11754                                  ;TURN_OFF:
 11755                                  	;mov	ds,[RESSEG]
 11756                                  
 11757                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11758                                  BATEOF:
 11759 00000B1E E8B0FE                  	call	BATCHOFF
 11760 00000B21 E8CC02                  	call	BATCLOSE
 11761                                  
 11762                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11763                                  
 11764                                  ;SR; BugBug
 11765                                  ; There is a good reason why this carriage return is being returned here. 
 11766                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11767                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11768                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11769                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11770                                  ;the batchfile already had a CR-LF. 
 11771                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11772                                  ;the end-of-line. This CR is to mark the end-of-file.
 11773                                  
 11774 00000B24 B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11775 00000B26 F606[4F02]FF            	test	byte [Batch_Abort],-1
 11776 00000B2B C606[4F02]00            	mov	byte [Batch_Abort],0
 11777 00000B30 7407                    	jz	short CONT_GET_BYT
 11778 00000B32 BF[459C]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11779 00000B35 31C9                    	xor	cx,cx			; zero line length
 11780 00000B37 EB14                    	jmp	short GETBYTEDONE
 11781                                  CONT_GET_BYT:
 11782 00000B39 833E[6102]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11783 00000B3E 750D                    	jne	short GETBYTEDONE
 11784 00000B40 833E[6A02]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11785 00000B45 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11786 00000B47 C706[6102]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11787                                  GETBYTEDONE:
 11788 00000B4D 1F                      	pop	ds
 11789 00000B4E 59                      	pop	cx
 11790 00000B4F 5B                      	pop	bx
 11791 00000B50 C3                      	retn
 11792                                  
 11793                                  ; ---------------------------------------------------------------------------
 11794                                  
 11795                                  ;break	<$If - conditional execution>
 11796                                  
 11797                                  	; 17/04/2023
 11798                                  ;IFERRORP:
 11799                                  ;	pop	ax
 11800                                  ;IFERROR:
 11801                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11802                                  ;FORERROR:
 11803                                  ;	mov	dx,SYNTMES_PTR
 11804                                  ;	jmp	cerror
 11805                                  
 11806                                  ; ---------------------------------------------------------------------------
 11807                                  
 11808                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11809                                  	;
 11810                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11811                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0B69h
 11812                                  _$IF:
 11813                                  	; MSDOS 6.0
 11814                                  ; Turn off any pipes in progress.
 11815 00000B51 1E                      	push	ds			;AN004; save local DS
 11816 00000B52 8E1E[E49D]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11817                                  	;assume	ds:resgroup		;AN004;
 11818 00000B56 803E[D402]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11819 00000B5B 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11820                                  	;invoke	PipeDel 		;AN004; turn off piping
 11821 00000B5D E8DA26                  	call	PIPEDEL	
 11822                                  IFNoPipe:				;AN004;
 11823 00000B60 1F                      	pop	ds			;AN004; get local DS back
 11824                                  	;assume	ds:trangroup		;AN004;
 11825                                  
 11826                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11827 00000B61 C606[F79D]00            	mov	byte [IFNOTFLAG],0
 11828 00000B66 C706[02A9]0000          	mov	word [IF_NOT_COUNT],0
 11829 00000B6C BE8100                  	mov	si,81h
 11830                                  IFREENT:
 11831 00000B6F E8B71F                  	call	scanoff
 11832 00000B72 3C0D                    	cmp	al,0Dh
 11833 00000B74 743C                    	je	short IFERROR
 11834 00000B76 89F5                    	mov	bp,si
 11835 00000B78 BF[F595]                	mov	di,IFTAB		; Prepare to search if table	
 11836                                  	;mov	ch,0
 11837                                  	; 17/04/2023
 11838 00000B7B 30ED                    	xor	ch,ch
 11839                                  IFINDCOM:
 11840 00000B7D 89EE                    	mov	si,bp
 11841 00000B7F 8A0D                    	mov	cl,[di]
 11842 00000B81 47                      	inc	di
 11843 00000B82 E33E                    	jcxz	IFSTRING
 11844 00000B84 EB02                    	jmp	short FIRSTCOMP
 11845                                  IFCOMP:
 11846 00000B86 7510                    	jnz	short IF_DIF
 11847                                  FIRSTCOMP:
 11848 00000B88 AC                      	lodsb
 11849 00000B89 268A25                  	mov	ah,[es:di]
 11850 00000B8C 47                      	inc	di
 11851 00000B8D 38E0                    	cmp	al,ah
 11852 00000B8F 7405                    	je	short IFLP
 11853 00000B91 80CC20                  	or	ah,20h			; Try lower case
 11854 00000B94 38E0                    	cmp	al,ah
 11855                                  IFLP:
 11856 00000B96 E2EE                    	loop	IFCOMP
 11857                                  IF_DIF:
 11858 00000B98 9F                      	lahf
 11859 00000B99 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11860 00000B9B 8B1D                    	mov	bx,[di]			; Get handler address
 11861 00000B9D 47                      	inc	di
 11862 00000B9E 47                      	inc	di
 11863 00000B9F 9E                      	sahf
 11864 00000BA0 75DB                    	jnz	short IFINDCOM
 11865 00000BA2 AC                      	lodsb
 11866 00000BA3 3C0D                    	cmp	al,0Dh
 11867                                  IFERRJ:
 11868 00000BA5 740B                    	jz	short IFERROR
 11869 00000BA7 E8871F                  	call	DELIM
 11870 00000BAA 75D1                    	jnz	short IFINDCOM
 11871 00000BAC E87A1F                  	call	scanoff
 11872 00000BAF FFE3                    	jmp	bx
 11873                                  
 11874                                  	; 17/04/2023
 11875                                  IFERRORP:
 11876 00000BB1 58                      	pop	ax
 11877                                  IFERROR:
 11878                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11879                                  FORERROR:
 11880 00000BB2 BA[9B92]                	mov	dx,SYNTMES_PTR
 11881 00000BB5 E9E522                  	jmp	cerror
 11882                                  
 11883                                  IFNOT:
 11884 00000BB8 F616[F79D]              	not	byte [IFNOTFLAG]
 11885 00000BBC FF06[02A9]              	inc	word [IF_NOT_COUNT]
 11886 00000BC0 EBAD                    	jmp	short IFREENT
 11887                                  
 11888                                  ; We are comparing two strings for equality. First, find the end of the
 11889                                  ; first string.
 11890                                  
 11891                                  IFSTRING:
 11892 00000BC2 56                      	push	si			; save away pointer for later compare
 11893 00000BC3 31C9                    	xor	cx,cx			; count of chars in first string
 11894                                  FIRST_STRING:
 11895 00000BC5 AC                      	lodsb				; get character
 11896 00000BC6 3C0D                    	cmp	al,0Dh			; end of line?
 11897 00000BC8 74E7                    	jz	short IFERRORP		; yes => error
 11898 00000BCA E8641F                  	call	DELIM			; is it a delimiter?
 11899 00000BCD 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11900 00000BCF 41                      	inc	cx			; remember 1 byte for the length
 11901 00000BD0 EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11902                                  EQUAL_CHECK:
 11903 00000BD2 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11904 00000BD4 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11905 00000BD6 3C0D                    	cmp	al,0Dh			; end of line?
 11906 00000BD8 74D7                    	je	short IFERRORP		; yes, syntax error
 11907 00000BDA AC                      	lodsb				; get next char
 11908 00000BDB EBF5                    	jmp	short EQUAL_CHECK
 11909                                  
 11910                                  ; The first = has been found. The next char had better be an = too.
 11911                                  
 11912                                  EQUAL_CHECK2:
 11913 00000BDD AC                      	lodsb				; get potential = char
 11914 00000BDE 3C3D                    	cmp	al,'='			; is it good?	
 11915                                  	;jnz	short IFERRPJ		; no, error
 11916                                  	; 17/04/2023
 11917 00000BE0 75CF                    	jne	short IFERRORP
 11918                                  
 11919                                  ; Find beginning of second string.
 11920                                  
 11921 00000BE2 E8441F                  	call	scanoff
 11922 00000BE5 3C0D                    	cmp	al,0Dh
 11923                                  	;jz	short IFERRPJ
 11924                                  	; 17/04/2023
 11925 00000BE7 74C8                    	je	short IFERRORP
 11926 00000BE9 5F                      	pop	di
 11927                                  
 11928                                  ; DS:SI points to second string
 11929                                  ; CX has number of chars in first string
 11930                                  ; ES:DI points to first string
 11931                                  
 11932 00000BEA F3A6                    	repe	cmpsb
 11933 00000BEC 7414                    	jz	short MATCH		; match found!
 11934                                  
 11935                                  ; No match. Let's find out what was wrong. The character that did not match
 11936                                  ; has been advanced over. Let's back up to it.
 11937                                  
 11938 00000BEE 4E                      	dec	si
 11939                                  
 11940                                  ; If it is EOL, then syntax error
 11941                                  
 11942 00000BEF 803C0D                  	cmp	byte [si],0Dh
 11943                                  	;jz	short IFERRJ
 11944                                  	; 17/04/2023
 11945 00000BF2 74BE                    	je	short IFERROR
 11946                                  
 11947                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11948                                  
 11949                                  SKIPSTRINGEND:
 11950 00000BF4 AC                      	lodsb
 11951                                  NOTMATCH:
 11952 00000BF5 3C0D                    	cmp	al,0Dh
 11953                                  IFERRORJ2:
 11954                                  	;jz	short IFERRJ
 11955                                  	; 17/04/2023
 11956 00000BF7 74B9                    	jz	short IFERROR
 11957 00000BF9 E8351F                  	call	DELIM
 11958 00000BFC 75F6                    	jnz	short SKIPSTRINGEND
 11959                                  
 11960                                  ; Signal that we did NOT have a match
 11961                                  
 11962 00000BFE B0FF                    	mov	al,-1	 ; 0FFh
 11963 00000C00 EB37                    	jmp	short IFRET
 11964                                  
 11965                                  	; 17/04/2023
 11966                                  ;IFERRPJ:
 11967                                  	;jmp	IFERRORP
 11968                                  
 11969                                  ; The compare succeeded. Was the second string longer than the first?
 11970                                  ; We do this by seeing if the next char is a delimiter.
 11971                                  
 11972                                  MATCH:
 11973 00000C02 AC                      	lodsb
 11974 00000C03 E82B1F                  	call	DELIM
 11975 00000C06 75ED                    	jnz	short NOTMATCH ; not same.
 11976 00000C08 30C0                    	xor	al,al
 11977 00000C0A EB2D                    	jmp	short IFRET
 11978                                  
 11979                                  ; ---------------------------------------------------------------------------
 11980                                  
 11981                                  IFEXISTS:
 11982                                  
 11983                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11984                                  
 11985                                  ;MOREDELIM:
 11986 00000C0C AC                      	lodsb
 11987 00000C0D E8211F                  	call	DELIM
 11988 00000C10 75FA                    	jnz	short IFEXISTS
 11989                                  	;jnz	short MOREDELIM
 11990                                  
 11991 00000C12 BA[1FA0]                	mov	dx,DIRBUF
 11992 00000C15 B8001A                  	mov	ax,1A00h
 11993                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11994 00000C18 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11995                                  			; DS:DX	-> disk	transfer buffer
 11996 00000C1A BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11997 00000C1D 031E[02A9]              	add	bx,[IF_NOT_COUNT]
 11998                                  	;mov	ax,ARG_ARGV
 11999                                  	;mov	ax,ARG+ARG_UNIT.argv
 12000 00000C21 B8[B6A2]                	mov	ax,ARG
 12001 00000C24 E8812A                  	call	argv_calc		; convert arg index to pointer
 12002 00000C27 8B17                    	mov	dx,[bx]
 12003                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12004                                  	;mov	cx,6
 12005 00000C29 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 12006 00000C2C B8004E                  	mov	ax,4E00h
 12007                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 12008 00000C2F CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12009                                  			; CX = search attributes
 12010                                  			; DS:DX	-> ASCIZ filespec
 12011                                  			; (drive,path, and wildcards allowed)
 12012 00000C31 7204                    	jc	short IF_EX_C ; carry is how to determine error
 12013 00000C33 30C0                    	xor	al,al
 12014 00000C35 EB02                    	jmp	short IFRET
 12015                                  
 12016                                  	;nop
 12017                                  IF_EX_C:
 12018 00000C37 B0FF                    	mov	al,-1	; 0FFh	; false 'n' fall through...
 12019                                  IFRET:
 12020 00000C39 F606[F79D]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 12021 00000C3E 7402                    	jz	short REALTEST
 12022 00000C40 F6D0                    	not	al
 12023                                  REALTEST:
 12024 00000C42 08C0                    	or	al,al
 12025 00000C44 7403                    	jz	short IFTRUE
 12026 00000C46 E9BBF4                  	jmp	TCOMMAND
 12027                                  
 12028                                  IFTRUE:
 12029 00000C49 E8DD1E                  	call	scanoff
 12030 00000C4C 89F1                    	mov	cx,si
 12031 00000C4E 81E98100                	sub	cx,81h
 12032 00000C52 280E8000                	sub	[80h],cl
 12033 00000C56 8A0E8000                	mov	cl,[80h]
 12034 00000C5A 880E[449C]              	mov	[COMBUF+1],cl
 12035 00000C5E BF[459C]                	mov	di,COMBUF+2
 12036 00000C61 FC                      	cld
 12037 00000C62 F3A4                    	rep	movsb
 12038 00000C64 B00D                    	mov	al,0Dh
 12039 00000C66 AA                      	stosb
 12040                                  
 12041                                  ; Signal that an IF was done. 
 12042                                  ; This prevents the redirections from getting lost.
 12043                                  
 12044 00000C67 1E                      	push	ds
 12045 00000C68 8E1E[E49D]              	mov	ds,[RESSEG]
 12046 00000C6C C606[6602]FF            	mov	byte [IfFlag],-1
 12047 00000C71 1F                      	pop	ds
 12048                                  
 12049                                  ; Go do the command
 12050                                  
 12051                                  	;jmp	DOCOM1 ; MSDOS 5.0 COMMAND.COM
 12052                                  	; 07/06/2023
 12053                                  	; Retro DOS v4.2 COMMAND.COM
 12054 00000C72 E97EF6                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 12055                                  
 12056                                  ; ---------------------------------------------------------------------------
 12057                                  
 12058                                  IFERRORJ3:
 12059 00000C75 EB80                    	jmp	IFERRORJ2
 12060                                  
 12061                                  IFERLEV:
 12062 00000C77 B70A                    	mov	bh,10
 12063 00000C79 30DB                    	xor	bl,bl
 12064                                  GETNUMLP:
 12065 00000C7B AC                      	lodsb
 12066 00000C7C 3C0D                    	cmp	al,0Dh
 12067 00000C7E 74F5                    	je	short IFERRORJ3
 12068 00000C80 E8AE1E                  	call	DELIM
 12069 00000C83 740C                    	jz	short GOTNUM
 12070 00000C85 2C30                    	sub	al,'0'
 12071 00000C87 86C3                    	xchg	al,bl
 12072 00000C89 F6E7                    	mul	bh
 12073 00000C8B 00D8                    	add	al,bl
 12074 00000C8D 86C3                    	xchg	al,bl
 12075 00000C8F EBEA                    	jmp	short GETNUMLP
 12076                                  GOTNUM:
 12077 00000C91 1E                      	push	ds
 12078 00000C92 8E1E[E49D]              	mov	ds,[RESSEG]
 12079 00000C96 8A26[5602]              	mov	ah,[RetCode]
 12080 00000C9A 1F                      	pop	ds
 12081 00000C9B 30C0                    	xor	al,al
 12082 00000C9D 38DC                    	cmp	ah,bl
 12083 00000C9F 7398                    	jnb	short IFRET
 12084 00000CA1 FEC8                    	dec	al
 12085 00000CA3 EB94                    	jmp	short IFRET
 12086                                  
 12087                                  ; ---------------------------------------------------------------------------
 12088                                  
 12089                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 12090                                  ; This is a NOP if no batch in progress.
 12091                                  
 12092                                  _SHIFT:
 12093 00000CA5 8E1E[E49D]              	mov	ds,[RESSEG]
 12094 00000CA9 A1[0502]                	mov	ax,[Batch]		; get batch pointer
 12095 00000CAC 09C0                    	or	ax,ax			; in batch mode?
 12096 00000CAE 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 12097                                  SHIFT_RETN:				; no, done.
 12098 00000CB0 C3                      	retn
 12099                                  SHIFT1:
 12100 00000CB1 8EC0                    	mov	es,ax
 12101 00000CB3 8ED8                    	mov	ds,ax
 12102                                  
 12103                                  ; Now move the batch args down by 1 word
 12104                                  
 12105                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 12106                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 12107 00000CB5 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 12108 00000CB8 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 12109 00000CBB B90900                  	mov	cx,9			; move 9 parameters
 12110 00000CBE F3A5                    	rep	movsw			; SHIFT down
 12111                                  
 12112                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 12113                                  ; We have copied it into the previous position.
 12114                                  
 12115 00000CC0 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 12116 00000CC3 74EB                    	je	short SHIFT_RETN ; No new parm
 12117                                  
 12118                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 12119                                  ; Assume, first, that there is no next argument.
 12120                                   
 12121 00000CC5 8B35                    	mov	si,[di]
 12122 00000CC7 C705FFFF                	mov	word [di],-1		; Assume no parm
 12123                                  
 12124                                  ; The parameters are CR separated. Scan for end of this parm.
 12125                                  
 12126                                  SKIPCRLP:
 12127 00000CCB AC                      	lodsb
 12128 00000CCC 3C0D                    	cmp	al,0Dh
 12129 00000CCE 75FB                    	jne	short SKIPCRLP
 12130                                  
 12131                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12132                                  ; are finished. There are no more parms and the pointer has been previously
 12133                                  ; initialized to indicate it.
 12134                                  
 12135 00000CD0 803C00                  	cmp	byte [si],0
 12136 00000CD3 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12137 00000CD5 8935                    	mov	[di],si			; Pointer to next parm as %9
 12138 00000CD7 C3                      	retn
 12139                                  
 12140                                  ; =============== S U B	R O U T	I N E =======================================
 12141                                  
 12142                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12143                                  ; returns char in AL, carry set -> eof
 12144                                  
 12145                                  SKIPDELIM:
 12146 00000CD8 F706[0502]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12147 00000CDE 740A                    	jz	short SKIPERR
 12148 00000CE0 E85DFD                  	call	GETBATBYT		; get a char
 12149 00000CE3 E84B1E                  	call	DELIM			; check for ignoreable chars
 12150 00000CE6 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12151 00000CE8 F8                      	clc
 12152 00000CE9 C3                      	retn
 12153                                  SKIPERR:
 12154 00000CEA F9                      	stc
 12155                                  GOTO_RETN:
 12156 00000CEB C3                      	retn
 12157                                  
 12158                                  ; ---------------------------------------------------------------------------
 12159                                  
 12160                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12161                                  ;  .com file. This routine strips the CALL off the command line, sets
 12162                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12163                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12164                                  ;  being CALLed.
 12165                                  
 12166                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12167                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12168                                  
 12169                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12170                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0D01h
 12171                                  _$CALL:
 12172                                  
 12173                                  ;  strip off CALL from command line
 12174                                  
 12175                                  	;ASSUME DS:trangroup,ES:trangroup
 12176                                  
 12177 00000CEC 56                      	push	si
 12178 00000CED 57                      	push	di
 12179 00000CEE 50                      	push	ax
 12180 00000CEF 51                      	push	cx
 12181 00000CF0 BE[459C]                	mov	si,COMBUF+2
 12182 00000CF3 E8331E                  	call	scanoff			;get to first non-delimeter
 12183                                  	;add	si,4
 12184 00000CF6 83C604                  	add	si,length_call		;point to char past CALL
 12185 00000CF9 BF[459C]                	mov	di,COMBUF+2
 12186                                  	;mov	cx,124		
 12187 00000CFC B97C00                  	mov	cx,COMBUFLEN-length_call 
 12188                                  					;get length of buffer
 12189 00000CFF F3A4                    	rep	movsb			;move it
 12190 00000D01 59                      	pop	cx
 12191 00000D02 58                      	pop	ax
 12192 00000D03 5F                      	pop	di
 12193 00000D04 5E                      	pop	si
 12194                                  
 12195                                  ;  set call flag to indicate call in progress
 12196                                  
 12197 00000D05 1E                      	push	ds
 12198 00000D06 8E1E[E49D]              	mov	ds,[RESSEG]
 12199 00000D0A C606[6C02]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12200 00000D0F C606[6D02]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12201                                  
 12202                                  ; Turn off any pipes in progress.
 12203                                  
 12204 00000D14 803E[D402]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12205 00000D19 7403                    	jz	short _NOPIPE
 12206 00000D1B E81C25                  	call	PIPEDEL
 12207                                  _NOPIPE:
 12208 00000D1E 1F                      	pop	ds
 12209 00000D1F C3                      	retn
 12210                                  
 12211                                  ; ---------------------------------------------------------------------------
 12212                                  
 12213                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12214                                  _GOTO:
 12215 00000D20 8E1E[E49D]              	mov	ds,[RESSEG]
 12216 00000D24 F706[0502]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12217 00000D2A 74BF                    	jz	short GOTO_RETN
 12218 00000D2C 31D2                    	xor	dx,dx
 12219 00000D2E 1E                      	push	ds
 12220 00000D2F 8E1E[0502]              	mov	ds,[Batch]
 12221                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12222 00000D33 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12223                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12224 00000D37 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12225                                  
 12226                                  	; MSDOS 6.0
 12227                                  ;M037
 12228                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12229                                  ;
 12230 00000D3B C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12231                                  					; clear eof indicator ;M037
 12232                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12233 00000D40 1F                      	pop	ds
 12234                                  GOTOOPEN:
 12235 00000D41 E870F8                  	call	PROMPTBAT
 12236                                  	;mov	di,5Dh
 12237 00000D44 BF5D00                  	mov	di,FCB+1		; Get the label
 12238 00000D47 B90B00                  	mov	cx,11
 12239 00000D4A B020                    	mov	al,' '
 12240 00000D4C F2AE                    	repne	scasb
 12241 00000D4E 7501                    	jnz	short NOINC
 12242 00000D50 41                      	inc	cx
 12243                                  NOINC:
 12244 00000D51 83E90B                  	sub	cx,11
 12245 00000D54 F7D9                    	neg	cx
 12246                                  	;mov	[cs:GOTOLEN],cx
 12247                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12248 00000D56 26890E[1FA0]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12249                                  
 12250                                  ; At beginning of file. Skip to first non-delimiter char
 12251                                  
 12252 00000D5B E87AFF                  	call	SKIPDELIM
 12253 00000D5E 721C                    	jb	short BADGOTO
 12254 00000D60 3C3A                    	cmp	al,':'
 12255 00000D62 7426                    	jz	short CHKLABEL
 12256                                  LABLKLP:				; Look for the label
 12257 00000D64 E8D9FC                  	call	GETBATBYT
 12258 00000D67 3C0A                    	cmp	al,0Ah
 12259 00000D69 7509                    	jne	short LABLKTST
 12260                                  
 12261                                  ; At beginning of line. Skip to first non-delimiter char
 12262                                  
 12263 00000D6B E86AFF                  	call	SKIPDELIM
 12264 00000D6E 720C                    	jb	short BADGOTO
 12265 00000D70 3C3A                    	cmp	al,':'
 12266 00000D72 7416                    	je	short CHKLABEL
 12267                                  LABLKTST:
 12268 00000D74 F706[0502]FFFF          	test	word [Batch],0FFFFh ; -1
 12269 00000D7A 75E8                    	jnz	short LABLKLP
 12270                                  BADGOTO:
 12271 00000D7C E87100                  	call	BATCLOSE
 12272                                  
 12273                                  	; MSDOS 6.0
 12274                                  ;SR;
 12275                                  ; At this point we are terminating without freeing up any nested batch 
 12276                                  ;segments i.e if the error occurred within a called batch file. This routine
 12277                                  ;will traverse the linked list of batch segments and free all of them.
 12278                                  ;
 12279 00000D7F E8BB00                  	call	free_batch		; free up nested batch segments
 12280                                  
 12281                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12282 00000D82 0E                      	push	cs
 12283 00000D83 1F                      	pop	ds
 12284 00000D84 BA[9892]                	mov	dx,BADLAB_PTR
 12285 00000D87 E91321                  	jmp	cerror
 12286                                  
 12287                                  ; Found the :.	Skip to first non-delimiter char
 12288                                  
 12289                                  CHKLABEL:
 12290 00000D8A E84BFF                  	call	SKIPDELIM
 12291 00000D8D 72ED                    	jb	short BADGOTO
 12292 00000D8F BF5D00                  	mov	di,FCB+1 ; 5Dh
 12293                                  	;mov	cx,[cs:GOTOLEN]
 12294                                  	; 14/02/2023
 12295 00000D92 268B0E[1FA0]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12296 00000D97 EB05                    	jmp	short GOTBYTE
 12297                                  
 12298                                  NEXTCHRLP:
 12299 00000D99 51                      	push	cx
 12300 00000D9A E8A3FC                  	call	GETBATBYT
 12301 00000D9D 59                      	pop	cx
 12302                                  GOTBYTE:
 12303                                  	; 18/03/2023
 12304                                  	; 14/02/2023
 12305                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12306 00000D9E E8691B                  	call	testkanj
 12307 00000DA1 7413                    	jz	short NOTKANJ1
 12308 00000DA3 263A05                  	cmp	al,[es:di]
 12309 00000DA6 75CC                    	jne	short LABLKTST
 12310 00000DA8 47                      	inc	di
 12311 00000DA9 49                      	dec	cx
 12312 00000DAA E3C8                    	jcxz	LABLKTST
 12313 00000DAC 51                      	push	cx
 12314 00000DAD E890FC                  	call	GETBATBYT
 12315 00000DB0 59                      	pop	cx
 12316 00000DB1 263A05                  	cmp	al,[es:di]
 12317 00000DB4 EB0C                    	jmp	short KNEXTLABCHR
 12318                                  NOTKANJ1:
 12319                                  	; 14/02/2023
 12320                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12321 00000DB6 0C20                    	or	al,20h
 12322 00000DB8 263A05                  	cmp	al,[es:di]
 12323                                  	;jne	short TRYUPPER
 12324                                  	;jmp	short NEXTLABCHR
 12325                                  	; 25/04/2023
 12326 00000DBB 7407                    	je	short NEXTLABCHR 
 12327                                  TRYUPPER:
 12328 00000DBD 2C20                    	sub	al,20h
 12329 00000DBF 263A05                  	cmp	al,[es:di]
 12330                                  KNEXTLABCHR:
 12331 00000DC2 75B0                    	jnz	short LABLKTST
 12332                                  NEXTLABCHR:
 12333 00000DC4 47                      	inc	di
 12334 00000DC5 E2D2                    	loop	NEXTCHRLP
 12335 00000DC7 E876FC                  	call	GETBATBYT
 12336                                  	; 14/02/2023
 12337 00000DCA 26833E[1FA0]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12338                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12339 00000DD0 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12340 00000DD2 3C20                    	cmp	al,' '
 12341 00000DD4 779E                    	ja	short LABLKTST
 12342                                  GOTOCONT:
 12343 00000DD6 3C0D                    	cmp	al,0Dh
 12344 00000DD8 7407                    	je	short SKIPLFEED
 12345                                  TONEXTBATLIN:
 12346 00000DDA E863FC                  	call	GETBATBYT
 12347 00000DDD 3C0D                    	cmp	al,0Dh
 12348 00000DDF 75F9                    	jne	short TONEXTBATLIN
 12349                                  SKIPLFEED:
 12350 00000DE1 E85CFC                  	call	GETBATBYT
 12351                                  
 12352                                  	; MSDOS 6.0
 12353                                  ;SR;
 12354                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12355                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12356                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12357                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12358                                  ;all other cases, EOF will be hit while trying to read the next line and
 12359                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12360                                  ;
 12361 00000DE4 06                      	push	es
 12362 00000DE5 8E06[0502]              	mov	es,[Batch]
 12363 00000DE9 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12364                                  					;invalidate fake CR-LF flag
 12365 00000DEF 07                      	pop	es
 12366                                  
 12367                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12368                                  	;call	BATCLOSE
 12369                                  	;retn
 12370                                  	; 14/02/2023
 12371                                  	;jmp	short BATCLOSE
 12372                                  
 12373                                  ; =============== S U B	R O U T	I N E =======================================
 12374                                  
 12375                                  BATCLOSE:
 12376 00000DF0 2E8B1E[5AA2]            	mov	bx,[cs:BATHAND]
 12377 00000DF5 83FB05                  	cmp	bx,5
 12378 00000DF8 7204                    	jb	short CLOSERETURN
 12379                                  	; 14/02/2023
 12380 00000DFA B43E                    	mov	ah,3Eh
 12381                                  	;mov	ah,CLOSE ; 3Eh
 12382 00000DFC CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12383                                  			; BX = file handle
 12384                                  CLOSERETURN:
 12385 00000DFE C606[4E02]00            	mov	byte [In_Batch],0 ; reset flag	
 12386 00000E03 C3                      	retn
 12387                                  
 12388                                  ; =============== S U B	R O U T	I N E =======================================
 12389                                  
 12390                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12391                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12392                                  
 12393                                  	; 14/02/2023
 12394                                  BATOPEN:
 12395 00000E04 1E                      	push	ds
 12396 00000E05 8E1E[0502]              	mov	ds,[Batch]
 12397                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12398                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12399 00000E09 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12400 00000E0C B8003D                  	mov	ax,3D00h
 12401                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12402 00000E0F CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12403                                  			; DS:DX	-> ASCIZ filename
 12404                                  			; AL = access mode
 12405                                  			; 0 - read
 12406 00000E11 721C                    	jb	short SETERRDL
 12407                                  	;mov	dx,[8]
 12408 00000E13 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12409                                  	;mov	cx,[10]
 12410 00000E17 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12411 00000E1B 1F                      	pop	ds
 12412                                  	;mov	[cs:BATHAND],ax
 12413 00000E1C 26A3[5AA2]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12414 00000E20 89C3                    	mov	bx,ax
 12415 00000E22 B80042                  	mov	ax,4200h
 12416                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12417 00000E25 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12418                                  			; AL = method: offset from beginning of	file
 12419                                  
 12420                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12421                                  					; nuke batch buffer position
 12422 00000E27 26C706[2FAA]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12423                                  BATOPEN_RETN:
 12424 00000E2E C3                      	retn
 12425                                  
 12426                                  SETERRDL:
 12427 00000E2F 89D3                    	mov	bx,dx
 12428                                  	; MSDOS 6.0
 12429                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12430                                  	; 14/02/2023
 12431 00000E31 E81A14                  	call	get_ext_error_number
 12432 00000E34 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12433                                  
 12434                                  	; MSDOS 3.3
 12435                                  	;mov	dx,INSERTDSKPTR
 12436                                  	;call	GET_EXT_ERR_NUMBER
 12437                                  
 12438                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12439 00000E36 8A07                    	mov	al,[bx]			; Get drive spec
 12440 00000E38 2C40                    	sub	al,'@'	; sub al,40h	; A = 1
 12441 00000E3A 1F                      	pop	ds
 12442 00000E3B F9                      	stc				; SUB mucked over carry
 12443 00000E3C C3                      	retn
 12444                                  
 12445                                  ; =============== S U B	R O U T	I N E =======================================
 12446                                  
 12447                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12448                                  ;the batch and FOR segments until all of them are freed. It also restores
 12449                                  ;the old state of the EchoFlag.
 12450                                  ;
 12451                                  ;	ENTRY:	ds = RESGROUP
 12452                                  ;
 12453                                  ;	EXIT: 	All batch & FOR segments freed.
 12454                                  ;		EchoFlag restored to old state before batch process.
 12455                                  ;
 12456                                  ;	REGISTERS AFFECTED: bx, cx
 12457                                  
 12458                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12459                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12460                                  
 12461                                  free_batch: ;proc near
 12462                                  	;assume	ds:RESGROUP,es:nothing
 12463                                  
 12464 00000E3D 06                      	push	es
 12465 00000E3E 8B1E[6E02]              	mov	bx,[Next_Batch]
 12466 00000E42 09DB                    	or	bx,bx
 12467 00000E44 7432                    	jz	short fb_ret
 12468                                  _ClearBatch:
 12469 00000E46 8EC3                    	mov	es,bx			; get batch segment
 12470                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12471 00000E48 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12472 00000E4D 83FB00                  	cmp	bx,0			; is a FOR in progress
 12473 00000E50 7408                    	je	short no_bat_for	; no - don't deallocate
 12474 00000E52 06                      	push	es			;
 12475 00000E53 8EC3                    	mov	es,bx			; yes - free it up...
 12476 00000E55 B449                    	mov	ah,49h
 12477                                  	;mov	ah,DEALLOC		;
 12478 00000E57 CD21                    	int	21h			;
 12479 00000E59 07                      	pop	es			; restore to batch segment
 12480                                  no_bat_for:
 12481                                  	;mov	cl,[es:1]
 12482 00000E5A 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12483                                  					; get old echo flag
 12484                                  	;mov	bx,[es:3]
 12485 00000E5F 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12486                                  					; get old batch segment
 12487 00000E64 B449                    	mov	ah,49h
 12488                                  	;mov	ah,DEALLOC		; free it up...
 12489 00000E66 CD21                    	int	21h
 12490                                  	; 14/02/2023
 12491                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12492 00000E68 FF0E[6A02]              	dec	word [Nest]		; is there another batch file?
 12493 00000E6C 75D8                    	jnz	short _ClearBatch	; keep going until no batch file
 12494                                  	
 12495 00000E6E 880E[5902]              	mov	[EchoFlag],cl		;restore echo status
 12496 00000E72 C706[0502]0000          	mov	word [Batch],0		;no batch process in progress
 12497                                  fb_ret:
 12498 00000E78 07                      	pop	es
 12499 00000E79 C3                      	ret
 12500                                  
 12501                                  ;free_batch endp
 12502                                  
 12503                                  ;============================================================================
 12504                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12505                                  ;============================================================================
 12506                                  ; 10/10/2018 - Retro DOS v3.0
 12507                                  
 12508                                  ; All batch proccessing has DS set to segment of resident portion
 12509                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12510                                  
 12511                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12512                                  
 12513                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12514                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12515                                  
 12516                                  ; ---------------------------------------------------------------------------
 12517                                  
 12518                                  	; 15/02/2023
 12519                                  FORTERM:
 12520                                  	; MSDOS 6.0
 12521 00000E7A 0E                      	push	cs			;AN037; Get local segment into
 12522 00000E7B 1F                      	pop	ds			;AN037;  DS, ES
 12523 00000E7C 0E                      	push	cs			;AN037;
 12524 00000E7D 07                      	pop	es			;AN037;
 12525                                  
 12526                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12527 00000E7E E89702                  	call	FOROFF
 12528                                  	;mov	ds,[cs:RESSEG]
 12529 00000E81 268E1E[E49D]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12530 00000E86 813E[6102]00FF          	cmp	word [SingleCom],0FF00h
 12531 00000E8C 750F                    	jne	short BAT_CRLF
 12532 00000E8E 833E[6A02]00            	cmp	word [Nest],0		;See if we have nested batch files
 12533 00000E93 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12534 00000E95 C706[6102]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12535 00000E9B EB12                    	jmp	short NOFORP2
 12536                                  BAT_CRLF:
 12537 00000E9D F606[5902]01            	test	byte [EchoFlag],1 	; Is echo on?
 12538 00000EA2 740B                    	jz	short NOFORP2		; no - exit
 12539 00000EA4 F706[0502]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12540                                  					; print CRLF if in batch
 12541 00000EAA 7403                    	jz	short NOFORP2
 12542 00000EAC E86D1C                  	call	CRLF2
 12543                                  NOFORP2:
 12544 00000EAF E952F2                  	jmp	TCOMMAND
 12545                                  
 12546                                  ; ---------------------------------------------------------------------------
 12547                                  
 12548                                  ;------
 12549                                  ;   For-loop processing. For loops are of the form:
 12550                                  ;	    for %<loop-variable> in (<list>) do <command>
 12551                                  ; where <command> may contain references of the form %<variable>, which are
 12552                                  ; later substituted with the items in <list>. The for-loop structure is
 12553                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12554                                  ; <command> once for each item in <list>. All of the information needed for
 12555                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12556                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12557                                  ; a complete copy of the original command-line structure as parsed by
 12558                                  ; 'parseline', loop control variables, and a dma buffer for the
 12559                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12560                                  ; processing has completed, this chunk of memory is returned to the system.
 12561                                  ;
 12562                                  ;   All of the previously defined variables, in 'datares', used for loop
 12563                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12564                                  ;
 12565                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12566                                  ; containing all of the other error messages.
 12567                                  ;
 12568                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12569                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12570                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12571                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12572                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12573                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12574                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12575                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12576                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12577                                  ; instead of
 12578                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12579                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12580                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12581                                  ; doesn't matter whether we put brackets around the location or not -- the
 12582                                  ; assembler is "smart" enough to know that we want an address instead of the
 12583                                  ; contents of that location.
 12584                                  ;
 12585                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12586                                  ; One method would be to have a link field in each for-structure pointing to
 12587                                  ; its parent.  Variable references that couldn't be resolved in the local
 12588                                  ; frame would cause a search of prior frames. For-structures would still be
 12589                                  ; allocated and released in exactly the same fashion. The only limit on the
 12590                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12591                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12592                                  ; maintained in the resident data area. This structure would be an array of
 12593                                  ; control-variable names and pointers to for-structure blocks. This would
 12594                                  ; greatly speed up the resolution of non-local variable references. However,
 12595                                  ; since space in the resident is precious, we would have to compromise on a
 12596                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12597                                  ; allocation and de-allocation would have to be modified slightly to take this
 12598                                  ; new structure into account.
 12599                                  ;
 12600                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12601                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12602                                  ; it may be easier to allocate it as part of 'for_segment'.
 12603                                  ;------
 12604                                  		; include fordata.asm
 12605                                  
 12606                                  ; Data structure definitions included by tfor.asm
 12607                                  
 12608                                  struc FOR_INFO
 12609 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12610 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12611 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12612 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12613 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12614 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12615 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12616 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12617                                    .size:
 12618                                  endstruc
 12619                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12620                                  _$FOR_EXIT:
 12621 00000EB2 EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12622                                  
 12623                                  ; ---------------------------------------------------------------------------
 12624                                  
 12625                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
 12626                                  FORPROC:
 12627 00000EB4 A1[6802]                	mov	ax,[ForPtr]
 12628 00000EB7 8ED8                    	mov	ds,ax
 12629 00000EB9 8EC0                    	mov	es,ax			; operate in for-info area
 12630                                  	;mov	dx,5CBh	; MSDOS 5.0
 12631 00000EBB BACB05                  	mov	dx,FOR_INFO.FORDMA ; 5CBh
 12632                                  					; 1348+1+2+2+2+128 = 1483 = 5CBh
 12633 00000EBE B8001A                  	mov	ax,1A00h
 12634                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12635 00000EC1 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12636                                  			; DS:DX	-> disk	transfer buffer
 12637                                  FOR_BEGIN:
 12638                                  	;cmp	word [545h],0
 12639 00000EC3 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0 ; [545h]
 12640 00000EC8 7404                    	jz	short FOR_BEGIN1
 12641                                  					; non-zero for_expand equals FALSE
 12642                                  	;inc	word [547h]
 12643 00000ECA FF064705                	inc	word [FOR_INFO.FOR_MINARG] ; [547h]
 12644                                  FOR_BEGIN1:
 12645 00000ECE 8B1E4705                	mov	bx,[FOR_INFO.FOR_MINARG] ; [547h]
 12646                                  					; current item in <list> to examine
 12647 00000ED2 3B1E4905                	cmp	bx,[FOR_INFO.FOR_MAXARG] ; [549h]
 12648 00000ED6 7FDA                    	jg	short _$FOR_EXIT	; exceeding maxarg means all done	
 12649                                  	;mov	ax,0
 12650 00000ED8 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12651 00000EDB E8CA27                  	call	argv_calc		; compute argv[x] address
 12652                                  	;mov	cx,[bx+3]
 12653 00000EDE 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12654 00000EE1 8B17                    	mov	dx,[bx]
 12655                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12656                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12657 00000EE3 F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12658 00000EE7 7514                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12659 00000EE9 8B37                    	mov	si,[bx]
 12660                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12661                                  
 12662                                  	;mov	al,[cs:LPAREN]
 12663                                  	; 15/02/2023
 12664                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12665 00000EEB B028                    	mov	al,'('	; mov al,lparen
 12666 00000EED 3844FF                  	cmp	[si-1],	al		; If the current token is the first
 12667 00000EF0 750B                    	jne	short FORSUB		;  one in the list and originally had
 12668 00000EF2 41                      	inc	cx			;  the opening paren as its first char,
 12669                                  					;  the argstartel ptr needs to be
 12670                                  					;  advanced passed it before the prefix
 12671                                  					;  length is computed.
 12672 00000EF3 B03A                    	mov	al,':'
 12673 00000EF5 384401                  	cmp	[si+1],	al		; If the token begins with "(d:",
 12674 00000EF8 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12675 00000EFA 83C102                  	add	cx,2			;  rest of the prefix as well.
 12676                                  FORSUB:
 12677 00000EFD 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12678                                  	;cmp	word [545h],0
 12679 00000EFF 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12680                                  					; are we still expanding a name?
 12681 00000F04 7416                    	jz	short FOR_FIND_NEXT
 12682                                  					; if so, get next matching filename
 12683                                  	;test	byte [bx+2],2
 12684 00000F06 F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12685 00000F0A 7505                    	jnz	short FOR_FIND_FIRST
 12686                                  					; should we expand THIS (new) arg?
 12687                                  	;mov	cx,[bx+5]	
 12688                                  					; else, just copy all of it directly	
 12689 00000F0C 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12690 00000F0F EB1D                    	jmp	short FOR_SMOOSH
 12691                                  
 12692                                  	;nop
 12693                                  	; 15/02/2023
 12694                                  FOR_FIND_FIRST:
 12695 00000F11 51                      	push	cx
 12696 00000F12 31C9                    	xor	cx,cx
 12697 00000F14 B8004E                  	mov	ax,4E00h
 12698                                  	;mov	ax,Find_First*256 ; 4E00h
 12699 00000F17 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12700                                  			; CX = search attributes
 12701                                  			; DS:DX	-> ASCIZ filespec
 12702                                  			; (drive,path, and wildcards allowed)
 12703 00000F19 59                      	pop	cx
 12704 00000F1A EB05                    	jmp	short FOR_RESULT
 12705                                  
 12706                                  	;nop
 12707                                  FOR_FIND_NEXT:
 12708 00000F1C B8004F                  	mov	ax,4F00h
 12709                                  	;mov	ax,Find_Next*256 ;4F00h
 12710 00000F1F CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12711                                  			; [DTA]	= data block from
 12712                                  			; last AH = 4Eh/4Fh call
 12713                                  FOR_RESULT:
 12714 00000F21 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12715 00000F24 7201                    	jc	short FOR_CHECK
 12716                                  	; 15/02/2023
 12717 00000F26 40                      	inc	ax ; ax = 0
 12718                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12719                                  FOR_CHECK:				; record success of findfirst/next
 12720 00000F27 A34505                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12721 00000F2A 09C0                    	or	ax,ax			; anything out there?
 12722 00000F2C 7595                    	jnz	short FOR_BEGIN		; if not, try next arg
 12723                                  FOR_SMOOSH:
 12724                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12725 00000F2E 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12726                                  	;mov	di,54Bh	; MSDOS 5.0
 12727 00000F30 BF4B05                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12728 00000F33 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12729                                  					
 12730 00000F35 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12731                                  					; if we're not expanding, we can
 12732 00000F3A 7509                    	jnz	short FOR_MAKE_COM 	; skip the following	
 12733                                  	; 15/02/2023
 12734                                  	;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.0 COMMAND.COM
 12735 00000F3C BEE905                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12736                                  FOR_MORE:
 12737                                  	;cmp	byte [si],0		; tack on matching filename
 12738                                  	;jz	short FOR_MAKE_COM
 12739                                  	;movsb
 12740                                  	;jnz	short FOR_MORE
 12741                                  	; 25/04/2023
 12742 00000F3F AC                      	lodsb
 12743 00000F40 AA                      	stosb
 12744 00000F41 08C0                    	or	al,al
 12745 00000F43 75FA                    	jnz	short FOR_MORE
 12746                                  FOR_MAKE_COM:
 12747                                  	; 25/04/2023
 12748                                  	;xor	al,al			; tack a null byte onto the end
 12749                                  	;stosb				; of the substitute string
 12750 00000F45 31C9                    	xor	cx,cx			; character count for command line
 12751 00000F47 F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12752 00000F49 31DB                    	xor	bx,bx			; argpointer
 12753 00000F4B BF[459C]                	mov	di,COMBUF+2
 12754                                  	; 15/02/2023
 12755                                  	;mov	bl,[544h]  ; MSDOS 5.0
 12756 00000F4E 8A1E4405                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12757                                  	;mov	dh,[64Bh]
 12758 00000F52 8A364B06                	mov	dh,[FOR_INFO.FOR_VAR] 
 12759                                  					; %<for-var> is replaced by [forbuf]
 12760 00000F56 0E                      	push	cs			; time to form the <command> string
 12761 00000F57 07                      	pop	es
 12762                                  	;assume ES:trangroup
 12763                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12764 00000F58 B80000                  	mov	ax,0			; translate offset to pointer
 12765 00000F5B E84A27                  	call	argv_calc
 12766                                  	;mov	si,[bx+9]
 12767 00000F5E 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr] 
 12768                                  					; mov ptr passed beginning space
 12769 00000F61 46                      	inc	si
 12770                                  FOR_MAKE_LOOP:
 12771 00000F62 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12772 00000F64 46                      	inc	si
 12773 00000F65 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12774 00000F67 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12775 00000F69 3834                    	cmp	[si],dh			; got the right <variable>?
 12776 00000F6B 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12777 00000F6D 46                      	inc	si			; skip over <for-variable>
 12778                                  
 12779 00000F6E 56                      	push	si
 12780                                  	; 15/02/2023
 12781                                  	;mov	si,54Bh	; MSDOS 5.0
 12782 00000F6F BE4B05                  	mov	si,FOR_INFO.FORBUF
 12783                                  					; substitute the <item> for <variable>
 12784                                  					; to make a final <command> to execute
 12785                                  SLOOP:					
 12786 00000F72 AC                      	lodsb				; grab all those <item> bytes, and
 12787 00000F73 AA                      	stosb				; add 'em to the <command> string,
 12788 00000F74 08C0                    	or	al,al			; until we run into a null
 12789 00000F76 E0FA                    	loopne	SLOOP
 12790 00000F78 4F                      	dec	di			; adjust length and <command> pointer
 12791 00000F79 41                      	inc	cx			; so we can overwrite the null
 12792 00000F7A 5E                      	pop	si
 12793 00000F7B EBE5                    	jmp	short FOR_MAKE_LOOP
 12794                                  					; got back for more <command> bytes
 12795                                  FOR_STOSB:
 12796 00000F7D AA                      	stosb				; take a byte from the <command> arg
 12797 00000F7E 49                      	dec	cx			; and put it into the <command> to be
 12798                                  					; executed (and note length, too)
 12799 00000F7F 3C0D                    	cmp	al,0Dh		
 12800 00000F81 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12801                                  FOR_MADE_COM:
 12802 00000F83 F6D1                    	not	cl
 12803                                  	;mov	[cs:COMBUF+1],cl
 12804                                  	;mov	ds,[cs:RESSEG]
 12805                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12806                                  	; MSDOS 5.0 COMMAND.COM
 12807 00000F85 26880E[449C]            	mov	[es:COMBUF+1],cl
 12808 00000F8A 268E1E[E49D]            	mov	ds,[es:RESSEG]				
 12809                                  	;assume DS:resgroup
 12810 00000F8F F606[5902]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12811 00000F94 742F                    	jz	short NOECHO3
 12812                                  	;cmp	byte [NullFlag],nullcommand
 12813 00000F96 803E[7002]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12814 00000F9B 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf	 	
 12815                                  
 12816 00000F9D E87C1B                  	call	CRLF2		  	;G Print out prompt
 12817                                  NO_CRLF_PR:
 12818 00000FA0 C606[7002]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12819 00000FA5 0E                      	push	cs
 12820 00000FA6 1F                      	pop	ds
 12821 00000FA7 57                      	push	di
 12822 00000FA8 E83313                  	call	PRINT_PROMPT	  	;G Prompt the user
 12823 00000FAB 5F                      	pop	di
 12824                                  
 12825 00000FAC 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12826 00000FB1 C706[06A1][459C]        	mov	word [string_ptr_2],COMBUF+2
 12827                                  	; 17/04/2023
 12828 00000FB7 BA[CA93]                	mov	dx,string_buf_ptr
 12829 00000FBA E88045                  	call	std_printf
 12830 00000FBD 26C645FF0D              	mov	byte [es:di-1],0Dh
 12831 00000FC2 E92BF3                  	jmp	DOCOM		  	; run silent, run deep...
 12832                                  NOECHO3:
 12833 00000FC5 C606[7002]00            	mov	byte [NullFlag],0
 12834 00000FCA 0E                      	push	cs
 12835 00000FCB 1F                      	pop	ds
 12836                                  	;jmp	DOCOM1
 12837                                  	; 07/06/2023
 12838                                  	; Retro DOS v4.2 COMMAND.COM
 12839 00000FCC E924F3                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 12840                                  
 12841                                  FORNESTERRJ:				; no multi-loop processing... yet!		
 12842 00000FCF E84601                  	call	FOROFF
 12843 00000FD2 E92901                  	jmp	FORNESTERR
 12844                                  
 12845                                  ; ---------------------------------------------------------------------------
 12846                                  
 12847                                  FORERRORJ:
 12848 00000FD5 E9DAFB                  	jmp	FORERROR
 12849                                  
 12850                                  ; ---------------------------------------------------------------------------
 12851                                  
 12852                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12853                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 12854                                  _$FOR:
 12855 00000FD8 8E06[E49D]              	mov	es,[RESSEG]
 12856 00000FDC 26803E[6702]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12857 00000FE2 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12858                                  
 12859                                  ; Turn off any pipes in progress.
 12860                                  
 12861 00000FE4 26803E[D402]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12862 00000FEA 7403                    	jz	short NO_PIPE
 12863 00000FEC E84B22                  	call	PIPEDEL
 12864                                  NO_PIPE:
 12865 00000FEF 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12866 00000FF1 E8F400                  	call	NEXTARG			; move to next argv[n]
 12867 00000FF4 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12868 00000FF6 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12869 00000FF8 75DB                    	jne	short FORERRORJ
 12870 00000FFA 89C5                    	mov	bp,ax			; save forloop variable
 12871 00000FFC AC                      	lodsb
 12872 00000FFD 08C0                    	or	al,al			; and MUST end immediately...
 12873 00000FFF 75D4                    	jnz	short FORERRORJ
 12874 00001001 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12875 00001004 72CF                    	jb	short FORERRORJ
 12876                                  	;and	ax,0DFDFh
 12877 00001006 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12878                                  	; 15/02/2023
 12879                                  	;cmp	ax,4E49h  	; MSDOS 5.0	
 12880                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12881                                  	;cmp	ax,in_word	; MSDOS 5.0
 12882 00001009 3D494E                  	cmp	ax,'IN'
 12883 0000100C 75C7                    	jnz	short FORERRORJ
 12884 0000100E AC                      	lodsb
 12885                                  
 12886                                  	; 15/02/2023
 12887                                  	; MSDOS 3.3
 12888                                  	;or	al,al			; it, too, must end right away
 12889                                  	;jz	short CHECKLPAREN
 12890                                  	;cmp	al,[LPAREN]
 12891                                  	;jnz	short FORERRORJ
 12892                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12893                                  	;add	word [bx],2
 12894                                  	;;add	word [bx+9],2
 12895                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12896                                  	;;sub	word [bx+5],2
 12897                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12898                                  	;mov	ax,[si-1]
 12899                                  	;jmp	short LPCHECK
 12900                                  
 12901                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12902                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12903                                  
 12904                                  	; MSDOS 6.0
 12905                                  ; Compaq bug fix -- exit from this loop on error
 12906                                  
 12907 0000100F 08C0                    	or	al,al
 12908 00001011 75C2                    	jne	short FORERRORJ		; jump on error
 12909                                  
 12910                                  ;	je	short CHECKLPAREN
 12911                                  ;
 12912                                  ; Not null. Perhaps there are no spaces between this and the (:
 12913                                  ;   FOR %i in(foo bar...
 12914                                  ; Check for the Lparen here
 12915                                  ;
 12916                                  ;;	cmp	al,lparen
 12917                                  ;;	jnz	short FORERRORJ	
 12918                                  ;
 12919                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12920                                  ; being there in the first place.
 12921                                  ;
 12922                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12923                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12924                                  ;;						; advance original string
 12925                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12926                                  ;
 12927                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12928                                  ; current value.
 12929                                  ;
 12930                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12931                                  ;;	jmp	short LPCHECK
 12932                                  ;
 12933                                  ; end of Compaq bug fix
 12934                                  
 12935                                  ; ---------------------------------------------------------------------------
 12936                                  
 12937                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12938                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12939                                  
 12940                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12941                                  CHECKLPAREN:
 12942 00001013 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12943 00001016 72BD                    	jc	short FORERRORJ
 12944                                  LPCHECK:
 12945                                  	; 15/02/2023
 12946                                  	; MSDOS 5.0 (% MSDOS 6.0)	
 12947                                  	;;cmp	al,[LPAREN]
 12948                                  	;cmp	al,lparen
 12949 00001018 3C28                    	cmp	al,'('
 12950 0000101A 75B9                    	jne	short FORERRORJ
 12951 0000101C 80FC00                  	cmp	ah,0
 12952 0000101F 7410                    	je	short FOR_PAREN_TOKEN
 12953                                  	;;cmp	ah,[RPAREN]		; special case:  null list	
 12954                                  	;cmp	ah,rparen
 12955 00001021 80FC29                  	cmp	ah,')'
 12956 00001024 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12957 00001026 E951FE                  	jmp	FORTERM
 12958                                  FOR_LIST_NOT_EMPTY:
 12959                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12960 00001029 FF07                    	inc	word [bx]		; Advance ptr past "("
 12961                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry	
 12962 0000102B FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12963 0000102E 46                      	inc	si			; Inc si so check for ")" works
 12964 0000102F EB0D                    	jmp	short FOR_LIST
 12965                                  
 12966                                  	;nop
 12967                                  FOR_PAREN_TOKEN:
 12968 00001031 E8B400                  	call	NEXTARG			; what have we in our <list>?
 12969 00001034 729F                    	jc	short FORERRORJ
 12970                                  	; 15/02/2023
 12971                                  	;;;cmp	ax,[RPAREN+1]	
 12972                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12973                                  	;cmp	ax,nullrparen
 12974 00001036 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12975 00001039 7503                    	jne	short FOR_LIST
 12976 0000103B E93CFE                  	jmp	FORTERM
 12977                                  
 12978                                  ;FORERORJJ:
 12979                                  	;jmp	FORERROR
 12980                                  
 12981                                  FOR_LIST:				; skip over rest of <list>
 12982 0000103E 89D1                    	mov	cx,dx			; first arg of <list>
 12983                                  
 12984                                  SKIP_LIST:
 12985                                  	;add	si,[bx+5]
 12986 00001040 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12987 00001043 83EE03                  	sub	si,3			; si = ptr to last char of token
 12988                                  	; 15/02/2023
 12989                                  	;;mov	al,[RPAREN]
 12990                                  	;mov	al,rparen
 12991 00001046 B029                    	mov	al,')'
 12992 00001048 3804                    	cmp	[si],al			; Is this the last element in <list>
 12993 0000104A 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12994 0000104C E89900                  	call	NEXTARG			; No, get next arg <list>
 12995                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12996                                  	;jmp	short SKIP_LIST
 12997                                  	; 15/02/2023
 12998 0000104F 73EF                    	jnc	short SKIP_LIST
 12999                                  
 13000                                  	; 15/02/2023
 13001                                  FORERORJJ:
 13002 00001051 E95EFB                  	jmp	FORERROR
 13003                                  
 13004                                  FOR_END_LIST:
 13005 00001054 89D7                    	mov	di,dx			; record position of last arg in <list>
 13006 00001056 C60400                  	mov	byte [si],0		; Zap the rparen
 13007                                  	; 15/02/2023
 13008                                  	;;;cmp	ax,[RPAREN+1]	
 13009                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 13010                                  	;cmp	ax,nullparen
 13011 00001059 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 13012 0000105C 7401                    	je	short FOR_DO		; Yes, continue
 13013 0000105E 47                      	inc	di			; No, inc position of last arg
 13014                                  FOR_DO:
 13015 0000105F E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 13016 00001062 72ED                    	jc	short FORERORJJ
 13017                                  	;and	ax,0DFDFh	
 13018 00001064 25DFDF                  	and	ax,~2020h		; uppercase the letters
 13019                                  	; 15/02/2023
 13020                                  	;;cmp	ax,[DO_WORD]
 13021                                  	;cmp	ax,do_word ; 4F44h
 13022 00001067 3D444F                  	cmp	ax,'DO'	 ; 4F44h	
 13023 0000106A 75E5                    	jne	short FORERORJJ
 13024 0000106C AC                      	lodsb
 13025 0000106D 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 13026 0000106F 75E0                    	jnz	short FORERORJJ
 13027                                  		
 13028 00001071 E87400                  	call	NEXTARG			; on to the beginning of <command>
 13029 00001074 72DB                    	jc	short FORERORJJ		; null <command> not legal
 13030                                  
 13031 00001076 50                      	push	ax
 13032 00001077 53                      	push	bx
 13033 00001078 51                      	push	cx
 13034 00001079 52                      	push	dx			; preserve registers against disaster
 13035 0000107A 57                      	push	di
 13036 0000107B 56                      	push	si
 13037 0000107C 55                      	push	bp
 13038 0000107D E857F7                  	call	FREE_TPA		; need to make free memory, first
 13039 00001080 E89500                  	call	FOROFF
 13040                                  	;mov	bx,264
 13041 00001083 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 13042 00001086 E84A29                  	call	SAVE_ARGS		; extra bytes needed for for-info
 13043 00001089 9C                      	pushf
 13044 0000108A 26A3[6802]              	mov	[es:ForPtr],ax
 13045 0000108E E856F7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 13046 00001091 9D                      	popf
 13047 00001092 5D                      	pop	bp
 13048 00001093 5E                      	pop	si
 13049 00001094 5F                      	pop	di
 13050 00001095 5A                      	pop	dx
 13051 00001096 59                      	pop	cx
 13052 00001097 5B                      	pop	bx
 13053 00001098 58                      	pop	ax
 13054 00001099 723C                    	jc	short FOR_ALLOC_ERR
 13055                                  
 13056 0000109B 06                      	push	es			; save resgroup seg...
 13057 0000109C 26FF36[6802]            	push	word [es:ForPtr]
 13058 000010A1 07                      	pop	es
 13059                                  	;assume es:for_segment	
 13060 000010A2 49                      	dec	cx			; forproc wants min pointing before
 13061 000010A3 4F                      	dec	di			; first arg, max right at last one
 13062                                  	; 15/02/2023
 13063                                  	;mov	[547h],cx
 13064 000010A4 26890E4705              	mov	[es:FOR_INFO.FOR_MINARG],cx
 13065                                  	;mov	[549h],di
 13066 000010A9 26893E4905              	mov	[es:FOR_INFO.FOR_MAXARG],di
 13067                                  	;mov	[544h],dl
 13068 000010AE 2688164405              	mov	[es:FOR_INFO.FOR_COM_START],dl
 13069                                  	;mov	word [545h],0FFFFh ; -1
 13070 000010B3 26C7064505FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 13071                                  					; non-zero means FALSE
 13072 000010BA 89E8                    	mov	ax,bp
 13073                                  	;mov	[64Bh],ah
 13074 000010BC 2688264B06              	mov	[es:FOR_INFO.FOR_VAR],ah
 13075 000010C1 07                      	pop	es
 13076                                  	;assume es:resgroup	
 13077 000010C2 26FE06[6702]            	inc	byte [es:ForFlag]
 13078 000010C7 26833E[6102]FF          	cmp	word [es:SingleCom],-1
 13079 000010CD 7507                    	jne	short FOR_RET
 13080 000010CF 26C706[6102]00FF        	mov	word [es:SingleCom],0FF00h
 13081                                  FOR_RET:
 13082 000010D6 C3                      	retn
 13083                                  
 13084                                  FOR_ALLOC_ERR:
 13085                                  	; 15/02/2023
 13086                                  	; MSDOS 3.3
 13087                                  	;mov	dx,INSFMEMMESPTR
 13088                                  	;jmp	CERROR
 13089                                  
 13090                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13091                                  	; MSDOS 6.0
 13092                                  	;mov	byte [msg_disp_class],1
 13093 000010D7 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class	
 13094                                  					;AN000; set up extended error msg class
 13095                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr     
 13096 000010DC BA[0392]                	mov	dx,extend_buf_ptr
 13097                                  					;AC000; get extended message pointer
 13098                                  	;mov	word [extend_buf_ptr],8
 13099 000010DF C706[0392]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13100                                  					;AN000; get message number in control block
 13101 000010E5 E9B51D                  	jmp	cerror
 13102                                  
 13103                                  
 13104                                  ; =============== S U B	R O U T	I N E =======================================
 13105                                  
 13106                                  NEXTARG:
 13107 000010E8 42                      	inc	dx			; next argv[n]
 13108                                  	;cmp	dx,[ARG_ARGVCNT]
 13109 000010E9 3B16[76A5]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13110                                  					; make sure we don't run off end
 13111 000010ED 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13112 000010EF 89D3                    	mov	bx,dx
 13113                                  	;mov	ax,ARG_ARGV
 13114                                  	;mov	ax,ARG+ARG_UNIT.argv
 13115 000010F1 B8[B6A2]                	mov	ax,ARG
 13116 000010F4 E8B125                  	call	argv_calc		; convert array index to pointer
 13117 000010F7 8B37                    	mov	si,[bx]			; load pointer to argstring
 13118                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13119 000010F9 AD                      	lodsw				; and load first two chars
 13120 000010FA F8                      	clc
 13121 000010FB C3                      	retn
 13122                                  NEXTARG_ERR:
 13123 000010FC F9                      	stc
 13124 000010FD C3                      	retn
 13125                                  
 13126                                  ; ---------------------------------------------------------------------------
 13127                                  
 13128                                  FORNESTERR:
 13129 000010FE 1E                      	push	ds
 13130 000010FF 8E1E[E49D]              	mov	ds,[RESSEG]
 13131                                  	;ASSUME DS:RESGROUP
 13132 00001103 BA[6193]                	mov	dx,FORNESTMES_PTR
 13133 00001106 813E[6102]00FF          	cmp	word [SingleCom],0FF00h
 13134 0000110C 7506                    	jne	short NOFORP3
 13135 0000110E C706[6102]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13136                                  NOFORP3:
 13137 00001114 1F                      	pop	ds
 13138 00001115 E9851D                  	jmp	cerror
 13139                                  
 13140                                  ; =============== S U B	R O U T	I N E =======================================
 13141                                  
 13142                                  ; General routine called to free the for segment. We also clear the forflag
 13143                                  ; too. Change no registers.
 13144                                  
 13145                                  FOROFF:
 13146 00001118 50                      	push	ax
 13147 00001119 06                      	push	es
 13148 0000111A 2E8E06[E49D]            	mov	es,[cs:RESSEG]
 13149 0000111F 26A1[6802]              	mov	ax,[es:ForPtr]
 13150 00001123 09C0                    	or	ax,ax
 13151 00001125 7408                    	jz	short FREEDONE
 13152 00001127 06                      	push	es
 13153 00001128 8EC0                    	mov	es,ax
 13154                                  	; 15/02/2023
 13155 0000112A B449                    	mov	ah,49h
 13156                                  	;mov	ah,DEALLOC ; 49h
 13157 0000112C CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13158                                  			; ES = segment address of area to be freed
 13159 0000112E 07                      	pop	es
 13160                                  FREEDONE:
 13161 0000112F 26C706[6802]0000        	mov	word [es:ForPtr],0
 13162 00001136 26C606[6702]00          	mov	byte [es:ForFlag],0
 13163 0000113C 07                      	pop	es
 13164 0000113D 58                      	pop	ax
 13165 0000113E C3                      	retn
 13166                                  
 13167                                  ;============================================================================
 13168                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13169                                  ;============================================================================
 13170                                  ; 09/10/2018 - Retro DOS v3.0
 13171                                  
 13172                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13173                                  
 13174                                  ; ---------------------------------------------------------------------------
 13175                                  
 13176                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13177                                  
 13178                                  %if 0
 13179                                  
 13180                                  ; The DIR command displays the contents of a directory.
 13181                                  ;
 13182                                  ; ****************************************************************
 13183                                  ; *
 13184                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13185                                  ; *
 13186                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13187                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13188                                  ; *		 If an error occurs issue and error message and
 13189                                  ; *		 transfer control to CERROR.
 13190                                  ; *
 13191                                  ; * INPUT:	 command line at offset 81H
 13192                                  ; *
 13193                                  ; * OUTPUT:	 none
 13194                                  ; *
 13195                                  ; ****************************************************************
 13196                                  
 13197                                  CATALOG:
 13198                                  	; MSDOS 3.3
 13199                                  
 13200                                  	;mov	ax,ARG_ARGV
 13201                                  	;mov	ax,ARG+ARG_UNIT.argv
 13202                                  	mov	ax,ARG
 13203                                  	mov	dx,0FFFFh
 13204                                  	xor	cx,cx
 13205                                  	xor	si,si
 13206                                  DIR1:
 13207                                  	;cmp	cx,[ARG_ARGVCNT]
 13208                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13209                                  	jnb	short DIR6 ; No more arguments
 13210                                  	mov	bx,cx
 13211                                  	call	ARGV_CALC
 13212                                  	;or	si,[bx+7]
 13213                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13214                                  	test	si,7FFCh  ; test si,~8003
 13215                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13216                                  	;test	byte [bx+2],1
 13217                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13218                                  	jz	short DIR3
 13219                                  	jmp	short DIR5
 13220                                  DIR2:
 13221                                  	mov	dx,BADPARMPTR
 13222                                  	jmp	CERROR
 13223                                  DIR3:
 13224                                  	or	cx,cx
 13225                                  	jnz	short DIR4	
 13226                                  	;cmp	word [bx+5],3
 13227                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13228                                  	jz	short DIR5
 13229                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13230                                  	add	word [bx],3
 13231                                  	;add	word [bx+9],3
 13232                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13233                                  	;add	word [bx+3],3
 13234                                  	add	word [bx+ARGV_ELE.argstartel],3
 13235                                  	;sub	word [bx+5],3
 13236                                  	sub	word [bx+ARGV_ELE.arglen],3
 13237                                  DIR4:
 13238                                  	cmp	dx,0FFFFh
 13239                                  	jnz	short DIR2
 13240                                  	mov	dx,bx
 13241                                  DIR5:
 13242                                  	inc	cx
 13243                                  	jmp	short DIR1
 13244                                  DIR6:
 13245                                  	mov	[COMSW],si
 13246                                  	push	dx
 13247                                  	xor	al,al
 13248                                  	cmp	dx,0FFFFh
 13249                                  	jz	short DIR7
 13250                                  	mov	bx,dx
 13251                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13252                                  	mov	di,[bx]
 13253                                  	cmp	byte [di+1],':'
 13254                                  	jnz	short DIR7
 13255                                  	mov	al,[di]
 13256                                  	or	al,20h		; Lowercase drive name	
 13257                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13258                                  DIR7:
 13259                                  	;mov	[5CH],al
 13260                                  	mov	[FCB],al
 13261                                  	call	OKVOLARG
 13262                                  	mov	al,'?'		; *.* is default file spec.
 13263                                  	;mov	di,5Dh
 13264                                  	mov	di,FCB+1
 13265                                  	mov	cx,11
 13266                                  	rep stosb
 13267                                  
 13268                                  ; Begin by processing any switches that may have been specified.
 13269                                  ; BITS will contain any information about switches that was
 13270                                  ; found when the command line was parsed.
 13271                                  
 13272                                  	mov	ax,[COMSW]	; Get switches from command
 13273                                  	mov	[_BITS],ax	; initialize switches
 13274                                  	mov	word [COMSW],0	; initialize flags
 13275                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13276                                  	;test	al,1
 13277                                  	test	al,SWITCHW	; /W ?
 13278                                  	;mov	al,1
 13279                                  	mov	al,NORMPERLIN
 13280                                  	jz	short DIR8
 13281                                  	;mov	al,5
 13282                                  	mov	al,WIDEPERLIN
 13283                                  DIR8:
 13284                                  	mov	[LINLEN],al	; Set number of entries per line
 13285                                  	mov	[LINCNT],al
 13286                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13287                                  	mov	dx,DIRBUF
 13288                                  	mov	ah,Set_DMA ; 1Ah
 13289                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13290                                  			; DS:DX	-> disk	transfer buffer
 13291                                  	;mov	dl,[5Ch]
 13292                                  	mov	dl,[FCB]
 13293                                  	call	SAVUDIR
 13294                                  	pop	bx
 13295                                  	cmp	bx,0FFFFh
 13296                                  	jz	short DIR9
 13297                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13298                                  	mov	dx,[bx]
 13299                                  
 13300                                  ; The user may have specified a device. Search for the path and see if the
 13301                                  ; attributes indicate a device.
 13302                                  
 13303                                  	mov	ah,Find_First ; 4Eh
 13304                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13305                                  			; CX = search attributes
 13306                                  			; DS:DX	-> ASCIZ filespec
 13307                                  			; (drive,path, and wildcards allowed)
 13308                                  	jc	short DIR10
 13309                                  			; Check device atrribute..
 13310                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13311                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13312                                  	; 14/10/2018
 13313                                  	;test	byte [DIRBUF+21],40h
 13314                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13315                                  	jz	short DIR10	; no, go do normal operation
 13316                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13317                                  DIR9:
 13318                                  	jmp	short DOHEADER
 13319                                  DIR10:
 13320                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13321                                  	mov	dx,[bx]
 13322                                  	mov	ah,CHDir ; 3Bh
 13323                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13324                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13325                                  	jnc	short DOHEADER
 13326                                  	;mov	si,[bx+3]
 13327                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13328                                  	cmp	dx,si
 13329                                  	jz	short DIR_NO_DRIVE
 13330                                  	xor	cl,cl
 13331                                  	xchg	cl,[si]
 13332                                  	mov	ah,CHDir ; 3Bh
 13333                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13334                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13335                                  	xchg	cl,[si]
 13336                                  	jnc	short DIR_NO_DRIVE
 13337                                  	mov	al,[si-1]
 13338                                  	call	PATHCHRCMP
 13339                                  	jnz	short DIR11
 13340                                  	mov	al,[si-2]
 13341                                  	call	PATHCHRCMP
 13342                                  	jz	short DIR12
 13343                                  	xchg	cl,[si-1]
 13344                                  	mov	ah,CHDir ; 3Bh
 13345                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13346                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13347                                  	xchg	cl,[si-1]
 13348                                  	jnc	short DIR_NO_DRIVE
 13349                                  DIR11:
 13350                                  	mov	ch,':'
 13351                                  	cmp	ch,[si-1]
 13352                                  	jnz	short DIR12
 13353                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13354                                  	mov	cx,[bx]
 13355                                  	xchg	cx,si
 13356                                  	sub	cx,si
 13357                                  	cmp	cx,2
 13358                                  	jz	short DIR_NO_DRIVE
 13359                                  DIR12:
 13360                                  	mov	dx,BADCDPTR
 13361                                  	;test	byte [bx+2],4
 13362                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13363                                  	jnz	short DIRERROR
 13364                                  DIRNF:
 13365                                  	mov	dx,FNOTFOUNDPTR
 13366                                  DIRERROR:
 13367                                  	jmp	CERROR
 13368                                  DIR_NO_DRIVE:
 13369                                  	cmp	word [si],'..'
 13370                                  	jnz	short DOREALPARSE
 13371                                  	cmp	byte [si+2],0
 13372                                  	jnz	short DOREALPARSE
 13373                                  	inc	word [COMSW]
 13374                                  	jmp	short DOHEADER
 13375                                  DOREALPARSE:
 13376                                  	mov	di,FCB ; 5Ch	
 13377                                  	;mov	ax,290Eh
 13378                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13379                                  	int	21h	; DOS -	PARSE FILENAME
 13380                                  			; DS:SI	-> string to parse
 13381                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13382                                  			; AL = bit mask	to control parsing
 13383                                  	cmp	byte [si],0
 13384                                  	jz	short DOHEADER
 13385                                  	dec	word [COMSW]
 13386                                  DOHEADER:
 13387                                  		
 13388                                  ; Display the header
 13389                                  
 13390                                  	push	bx
 13391                                  	call	BUILD_DIR_STRING
 13392                                  	mov	dx,DIRBUF
 13393                                  	mov	[VOL_DIR],dx
 13394                                  	mov	dx,DIRHEADPTR
 13395                                  	call	PRINTF_CRLF
 13396                                  	pop	bx
 13397                                  	cmp	bx,0FFFFh
 13398                                  	jz	short DOSEARCH
 13399                                  
 13400                                  ; If there were chars left after parse or device, then invalid file name
 13401                                  
 13402                                  	cmp	word [COMSW],0
 13403                                  	jz	short DOSEARCH	; nothing left; good parse
 13404                                  	jl	short DIRNFFIX	; not .. => error file not found
 13405                                  	call	RESTUDIR
 13406                                  	mov	dx,BADCDPTR
 13407                                  	jmp	CERROR		; was .. => error directory not found
 13408                                  DIRNFFIX:
 13409                                  	call	RESTUDIR
 13410                                  	jmp	short DIRNF
 13411                                  
 13412                                  ; We are assured that everything is correct. Let's go and search. Use
 13413                                  ; attributes that will include finding directories. Perform the first search
 13414                                  ; and reset our directory afterward.
 13415                                  
 13416                                  DOSEARCH:
 13417                                  	;mov	byte [55h],0FFh
 13418                                  	mov	byte [FCB-7],0FFh
 13419                                  	;mov	byte [5Bh],10h
 13420                                  	mov	byte [FCB-1],10h
 13421                                  
 13422                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13423                                  ; the directory information as an extended FCB. We must bias all fetches into
 13424                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13425                                  
 13426                                  	mov	ah,Dir_Search_First ; 11h
 13427                                  	mov	dx,FCB-7 ; 55h
 13428                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13429                                  			; DS:DX	-> FCB
 13430                                  
 13431                                  ; Restore the user's directory. We preserve, though, the return from the
 13432                                  ; previous system call for later checking.
 13433                                  
 13434                                  FOUND_FIRST_FILE:
 13435                                  	push	ax		; save return state
 13436                                  	call	RESTUDIR	; restore user's dir	
 13437                                  	pop	ax		; get return state back
 13438                                  
 13439                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13440                                  ; no more.
 13441                                  
 13442                                  DIRSTART:
 13443                                  	inc	al		; 0FFh = file not found
 13444                                  	jnz	short DISPLAY	; Either an error or we are finished
 13445                                  	jmp	CHKCNT
 13446                                  DISPLAY:
 13447                                  	inc	word [FILECNT]	; Keep track of how many we find
 13448                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13449                                  	;call	SHONAME
 13450                                  	call	DISPLAYNAME
 13451                                  	;test	byte [_BITS],1
 13452                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13453                                  	jz	short DIRTEST	; If so, no size, date, or time
 13454                                  	jmp	NEXENT
 13455                                  DIRTEST:
 13456                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13457                                  	; 14/10/2018
 13458                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13459                                  	;test	byte [DIRBUF+19],10h
 13460                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13461                                  	jz	short FILEENT
 13462                                  	mov	dx,DMESPTR
 13463                                  	call	STD_PRINTF
 13464                                  	jmp	short NOFSIZ
 13465                                  FILEENT:
 13466                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13467                                  	;mov	dx,[DIRBUF+36]
 13468                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13469                                  	mov	[FILESIZE_L],dx
 13470                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13471                                  	;mov	dx,[DIRBUF+38]
 13472                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13473                                  	mov	[FILESIZE_H],dx
 13474                                  	mov	dx,FSIZEMESPTR
 13475                                  	call	STD_PRINTF	; Print size of file
 13476                                  NOFSIZ:
 13477                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13478                                  	;mov	ax,[DIRBUF+32]
 13479                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13480                                  	or	ax,ax
 13481                                  	jz	short NEXENT	; Skip if no date
 13482                                  	mov	di,CHARBUF
 13483                                  	push	ax
 13484                                  	mov	ax,'  '
 13485                                  	stosw
 13486                                  	pop	ax
 13487                                  	mov	bx,ax
 13488                                  	and	ax,1Fh		; Get day
 13489                                  	mov	dl,al
 13490                                  	mov	ax,bx
 13491                                  	mov	cl,5
 13492                                  	shr	ax,cl		; Align month
 13493                                  	and	al,0Fh		; Get month
 13494                                  	mov	dh,al
 13495                                  	mov	cl,bh
 13496                                  	shr	cl,1		; Align year
 13497                                  	xor	ch,ch
 13498                                  	add	cx,80		; Relative 1980
 13499                                  	cmp	cl,100
 13500                                  	jb	short MILLENIUM
 13501                                  	sub	cl,100
 13502                                  MILLENIUM:
 13503                                  	call	DATE_CXDX
 13504                                  	;mov	cx,[DIRBUF_FTIME]
 13505                                  	;mov	cx,[DIRBUF+30]
 13506                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13507                                  	jcxz	PRBUF		; Time field present?
 13508                                  	mov	ax,2020h
 13509                                  	stosw
 13510                                  	shr	cx,1
 13511                                  	shr	cx,1
 13512                                  	shr	cx,1
 13513                                  	shr	cl,1
 13514                                  	shr	cl,1		; Hours in CH, minutes in CL
 13515                                  	mov	bl,[TIME_24]
 13516                                  	or	bl,80h		; Tell P_TIME called from DIR
 13517                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13518                                  PRBUF:
 13519                                  	xor	ax,ax
 13520                                  	stosb
 13521                                  	mov	dx,CHARBUF
 13522                                  	mov	[STRING_PTR_2],dx
 13523                                  	mov	dx,STRINGBUF2PTR
 13524                                  	call	STD_PRINTF
 13525                                  NEXENT:
 13526                                  	dec	byte [LINCNT]
 13527                                  	jnz	short SAMLIN
 13528                                  NEXLIN:
 13529                                  	mov	al,[LINLEN]
 13530                                  	mov	[LINCNT],al
 13531                                  	call	CRLF2
 13532                                  	dec	byte [LINPERPAG]
 13533                                  	jnz	short SCROLL
 13534                                  	;test	byte [_BITS],2
 13535                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13536                                  	jz	short SCROLL	; If not, just continue
 13537                                  	mov	byte [LINPERPAG],23
 13538                                  	call	PAUSE
 13539                                  	jmp	short SCROLL
 13540                                  SAMLIN:
 13541                                  	mov	dx,TABPTR	; Output a tab
 13542                                  	call	STD_PRINTF
 13543                                  SCROLL:
 13544                                  	mov	ah,Dir_Search_Next ; 12h
 13545                                  	;mov	dx,55h
 13546                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13547                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13548                                  			; DS:DX	-> FCB
 13549                                  			; Return: AL = status
 13550                                  	jmp	DIRSTART
 13551                                  CHKCNT:
 13552                                  	test	word [FILECNT],0FFFFh ; -1
 13553                                  	jnz	short TRAILER
 13554                                  	jmp	DIRNF
 13555                                  TRAILER:
 13556                                  	mov	al,[LINLEN]
 13557                                  	cmp	al,[LINCNT]
 13558                                  	jz	short MMESSAGE
 13559                                  	call	CRLF2
 13560                                  MMESSAGE:
 13561                                  	mov	dx,DIRMESPTR
 13562                                  	mov	si,[FILECNT]
 13563                                  	mov	[DIR_NUM],si
 13564                                  	call	STD_PRINTF
 13565                                  DTFREE:
 13566                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13567                                  	;mov	dl,[5Ch]
 13568                                  	mov	dl,[FCB]
 13569                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13570                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13571                                  	cmp	ax,-1
 13572                                  	jnz	short DTFREE1
 13573                                  DTRET:
 13574                                  	retn
 13575                                  DTFREE1:
 13576                                  	mul	cx
 13577                                  	mul	bx
 13578                                  	mov	[BYTES_FREE],ax
 13579                                  	mov	[BYTES_FREE+2],dx
 13580                                  	mov	dx,BYTEMESPTR
 13581                                  	jmp	STD_PRINTF
 13582                                  
 13583                                  ; =============== S U B	R O U T	I N E =======================================
 13584                                  
 13585                                  SHONAME:
 13586                                  DISPLAYNAME:
 13587                                  	; MSDOS 3.3
 13588                                  	mov	di,CHARBUF
 13589                                  	mov	cx,8
 13590                                  	rep	movsb
 13591                                  	mov	al,' '
 13592                                  	stosb
 13593                                  	mov	cx,3
 13594                                  	rep	movsb
 13595                                  	xor	ax,ax
 13596                                  	stosb
 13597                                  	push	dx
 13598                                  	mov	dx,CHARBUF
 13599                                  	mov	[STRING_PTR_2],dx
 13600                                  	mov	dx,STRINGBUF2PTR
 13601                                  	call	STD_PRINTF
 13602                                  	pop	dx
 13603                                  	retn
 13604                                  
 13605                                  %endif
 13606                                  
 13607                                  ;============================================================================
 13608                                  ; DIR.ASM, MSDOS 6.0, 1991
 13609                                  ;============================================================================
 13610                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13611                                  
 13612                                  	; MSDOS 6.0
 13613                                  %if 0
 13614                                  
 13615                                  ;***	DIR.ASM - DIR internal command
 13616                                  
 13617                                  comment	% =================================================================
 13618                                  
 13619                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13620                                  "PART4 COMMAND Transient routines".
 13621                                  
 13622                                  From residual documentation, I surmise that TCMD.ASM originally
 13623                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13624                                  VER.  The file seems to have been successively split:
 13625                                  
 13626                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13627                                  
 13628                                  TCMD1A.ASM contained only the DIR command.
 13629                                  
 13630                                  Usage:
 13631                                  ------
 13632                                  
 13633                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13634                                  
 13635                                  DIR /?
 13636                                  
 13637                                  
 13638                                  <filespec> may include any or none of:  drive; directory path;
 13639                                             wildcarded filename.  If drive or directory path are
 13640                                  	   omitted, the current defaults are used.  If the
 13641                                  	   file name or extension is omitted, wildcards are
 13642                                  	   assumed.
 13643                                  
 13644                                  /w	Wide listing format.  Files are displayed in compressed
 13645                                  	'name.ext' format.  Subdirectory files are enclosed in
 13646                                  	brackets, '[dirname]'.
 13647                                  
 13648                                  /p	Paged, or prompted listing.  A screenful is displayed
 13649                                  	at a time.  The name of the directory being listed appears
 13650                                  	at the top of each page.
 13651                                  
 13652                                  	Bugbug:  pages nead to be uniform length..?
 13653                                  
 13654                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13655                                  	listed in compressed 'name.ext' format, one per line,
 13656                                  	without additional information.  Good for making batch
 13657                                  	files or for piping.  When used with /s, complete
 13658                                  	pathnames are listed.
 13659                                  
 13660                                  /s	Descend subdirectory tree.  Performs command on current
 13661                                  	or specified directory, then for each subdirectory below
 13662                                  	that directory.  Directory header and footer is displayed
 13663                                  	for each directory where matching files are found, unless
 13664                                  	used with /b.  /b suppresses headers and footers.
 13665                                  
 13666                                  	Tree is explored depth first, alphabetically within the
 13667                                  	same level.
 13668                                  
 13669                                  	Bugbug:  hidden directories aren't searched.
 13670                                  
 13671                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13672                                  
 13673                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13674                                  	compressed volume.
 13675                                  
 13676                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13677                                  	extension).  A sort order may be specified after /o.  Any of
 13678                                  	the following characters may be used: nedsgc (name, extension,
 13679                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13680                                  	a '-' before any letter causes a downward sort on that field.
 13681                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13682                                  	then within each extension sort by date and time in reverse
 13683                                  	chronological order.
 13684                                  
 13685                                  /a	Attribute selection.  Without /a, hidden and system files
 13686                                  	are suppressed from the listing.  With /a alone, all files
 13687                                  	are listed.  An attribute list may follow /a, consisting of
 13688                                  	any of the following characters:  hsdar (hidden, system,
 13689                                  	directory, archive, read-only).  A '-' before any letter
 13690                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13691                                  	are marked read-only and are not directory files.  Note
 13692                                  	that hidden or system files may be included in the listing.
 13693                                  	They are suppressed without /a but are treated like any other
 13694                                  	attribute with /a.
 13695                                  
 13696                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13697                                  
 13698                                  /h has been removed.					;M008
 13699                                  
 13700                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13701                                  	DIR command line.  Any command line options may be specified
 13702                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13703                                  	A filespec may be specified in DIRCMD and will be used unless
 13704                                  	a filespec is specified on the command line.  Any switch
 13705                                  	specified in DIRCMD may be overridden on the command line.
 13706                                  	If the original DIR default action is desired for a particular
 13707                                  	switch, the switch letter may be preceded by a '-' on the
 13708                                  	command line.  E.g.,
 13709                                  
 13710                                  	  /-w	use long listing format
 13711                                  	  /-p	don't page the listing
 13712                                  	  /-b	don't use bare format
 13713                                  	  /-s	don't descend subdirectory tree
 13714                                  	  /-o	display files in disk order
 13715                                  	  /-a	suppress hidden and system files
 13716                                  
 13717                                  Notes:
 13718                                  ------
 13719                                  
 13720                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13721                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13722                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13723                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13724                                  a flag byte which is made zero when the entry is loaded, and made one
 13725                                  when the entry is used.
 13726                                  
 13727                                  Revision History
 13728                                  ================
 13729                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13730                                  				in the absence of ANSI.SYS
 13731                                  
 13732                                  M007	sa	8/1/90		Allow /p/b combination
 13733                                  
 13734                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13735                                  				to internally handle /? message.
 13736                                  
 13737                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13738                                  
 13739                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13740                                  				first FCB with the drive number when the drive
 13741                                  				letter in the command line is preceded by a
 13742                                  				switch.  Now dir manually loads the drive
 13743                                  				number after parsing.
 13744                                  
 13745                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13746                                  				from the ROM BIOS.
 13747                                  
 13748                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13749                                  				a subdirectory having len(pathname)>MAXPATH.
 13750                                  				Just skip over that subdirectory.
 13751                                  
 13752                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13753                                  				byte value, rather than collating table.
 13754                                  				This to match MS-DOS Shell's sort order.
 13755                                  
 13756                                  ========================================================================= %
 13757                                  
 13758                                  %endif
 13759                                  
 13760                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22)
 13761                                  ;ifdef DBLSPACE_HOOKS
 13762                                  NUM_DIR_SWS	equ	16	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13763                                  ;else
 13764                                  ; 16/02/2023 - Retro DOS v4.0 (v4.1) COMMAND.COM (MSDOS 5.0)
 13765                                  ;NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13766                                  ;endif
 13767                                  
 13768                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13769                                  ;
 13770                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13771                                  ;		(order is hard-coded; see OnOffSw)
 13772                                  ;		Inmem is set when entries are loaded in memory.
 13773                                  
 13774                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13775                                  ;mask.wide  equ 1
 13776                                  ;mask.pagd  equ 2
 13777                                  ;mask.subd  equ 4
 13778                                  ;mask.bare  equ 8
 13779                                  ;mask.lcase equ 16
 13780                                  ;mask.inmem equ 32
 13781                                  
 13782                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 13783                                  ;ifdef DBLSPACE_HOOKS
 13784                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1,cratio:1
 13785                                  ;else
 13786                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13787                                  ;endif
 13788                                  mask.cratio equ 1
 13789                                  mask.wide   equ 2
 13790                                  mask.pagd   equ 4
 13791                                  mask.subd   equ 8
 13792                                  mask.bare   equ 16
 13793                                  mask.lcase  equ 32
 13794                                  mask.inmem  equ 64
 13795                                  ;
 13796                                  mask.dev    equ 1
 13797                                  mask.baddir equ 2	
 13798                                  
 13799                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13800                                  
 13801                                  ; 05/06/2023
 13802                                  ;ifdef DBLSPACE_HOOKS
 13803                                  NUM_ORDER_LTRS	equ	6	; length of sort order letter list
 13804                                  CRATIO_ORDER	equ	6	; position of 'C' in ORDER_LTRS
 13805                                  ;else
 13806                                  ;NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13807                                  ;endif
 13808                                  
 13809                                  ;ResultBuffer	struc		; structure of parse result buffer
 13810                                  ;ValueType	db	?
 13811                                  ;ValueTag	db	?
 13812                                  ;SynPtr		dw	?
 13813                                  ;ValuePtr	dd	?
 13814                                  ;ResultBuffer	ends
 13815                                  
 13816                                  ;ErrorRec	record	baddir:1,dev:1
 13817                                  ;
 13818                                  ;		Error bits are:
 13819                                  ;		  Invalid directory format
 13820                                  ;		  File is device
 13821                                  
 13822                                  ;EntryStruc	struc			; our private directory entry structure
 13823                                  ;used		db	?		; =0 until entry used, then =1
 13824                                  ;filename	db	8 dup (?)	; filename
 13825                                  ;fileext	db	3 dup (?)	; extension
 13826                                  ;fileattr	db	?		; file attributes
 13827                                  ;filetime	dw	?		; file time
 13828                                  ;filedate	dw	?		; file date
 13829                                  ;filesize	dd	?		; file size
 13830                                  ; 05/06/2023
 13831                                  ;;ifdef DBLSPACE_HOOKS
 13832                                  ;compratio	db	?		; compression ratio
 13833                                  ;;endif
 13834                                  ;EntryStruc	ends
 13835                                  
 13836                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13837                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13838                                  ;	push	ax
 13839                                  ;	endm
 13840                                  
 13841                                  ;	public	Catalog		; our entry point
 13842                                  ;
 13843                                  ;	break	<DIR (Catalog) principal routines>
 13844                                  ;
 13845                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13846                                  ; ---------------------------------------------------------------------------
 13847                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13848                                  
 13849                                  ;----------------------------------------------------------------------------
 13850                                  ;----------------------------------------------------------------------------
 13851                                  
 13852                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13853                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13854                                  
 13855                                  ;***	Catalog - DIR command main routine
 13856                                  ;
 13857                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13858                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13859                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13860                                  ;		Tpa = TPA buffer seg addr
 13861                                  ;		BytCnt = # bytes in TPA buffer
 13862                                  ;
 13863                                  ;	EXIT	nothing
 13864                                  ;
 13865                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13866                                  ;
 13867                                  ;	ERROR EXITS
 13868                                  ;
 13869                                  ;	  Errors are handled by setting up error message pointers
 13870                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13871                                  ;	   the environment variable, however, are handled by printing
 13872                                  ;	   an error message and continuing.
 13873                                  ;
 13874                                  ;	EFFECTS
 13875                                  ;
 13876                                  ;	  Directory listing is displayed (on standard output).
 13877                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13878                                  ;	   restore APPEND state.
 13879                                  ;	  Working directory may be changed. The user's default
 13880                                  ;	   directory is saved and flagged for restoration by RestUDir
 13881                                  ;	   during COMMAND cycle.
 13882                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13883                                  ;
 13884                                  ;	NOTES
 13885                                  ;
 13886                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13887                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13888                                  
 13889                                  	; 16/02/2023
 13890                                  
 13891                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 13892                                  ;----------------------------------------------------------------------------
 13893                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:1167h
 13894                                  
 13895                                  CATALOG:
 13896                                  	; 07/06/2023
 13897                                  	; MSDOS 6.22 COMMAND COM feature only !
 13898 0000113F E82F0A                  	call    screen_f_set	; set display parameters for video/text mode
 13899                                  	;			; (different depending on scr width/columns)
 13900 00001142 E8CA00                  	call	SetDefaults
 13901 00001145 E8EE00                  	call	ParseEnvironment
 13902 00001148 E80601                  	call	ParseCmdLine
 13903 0000114B 7303                    	jnc	short catalog1	; no parse error
 13904                                  	;jmp	catErr		; error msg is set up
 13905                                  	; 07/06/2023
 13906                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMANBD.COM
 13907 0000114D E9B200                  	jmp	catExtErr2 
 13908                                  catalog1:
 13909 00001150 E82F01                  	call	SetOptions
 13910 00001153 E80501                  	call	SetCollatingTable
 13911                                  
 13912                                  ;	Drive # to operate on has already been placed in FCB by
 13913                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13914                                  
 13915                                  	;;;test	Bits,mask bare
 13916                                  	;;test 	word [_Bits],8
 13917                                  	;test	byte [_Bits],8
 13918                                  	; 07/06/2023
 13919 00001156 F606[71A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 13920 0000115B 750A                    	jnz	short catalog2	; don't display volume info for /b
 13921                                  	;invoke	OkVolArg	; find & display volume info
 13922 0000115D E86010                  	call	OkVolArg
 13923                                  	;sub	byte [LeftOnpage],2
 13924 00001160 832E[109E]02            	sub	word [LeftOnPage],2
 13925                                  				; record display lines used by volume info
 13926 00001165 EB15                    	jmp	short catCrunch
 13927                                  
 13928                                  ;	OkVolArg side effects:
 13929                                  ;	APPEND is disabled;
 13930                                  ;	DTA established at DirBuf;
 13931                                  ;	Filename fields in FCB are wildcarded.
 13932                                  
 13933                                  catalog2:
 13934                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13935                                  
 13936                                  	;invoke	DisAppend	; disable APPEND
 13937 00001167 E82310                  	call	DisAppend
 13938                                  
 13939                                  	;mov	dx,offset TRANGROUP:DirBuf
 13940 0000116A BA[1FA0]                	mov	dx,DIRBUF
 13941 0000116D B41A                    	mov	ah,1Ah
 13942                                  	;mov	ah,Set_DMA
 13943 0000116F CD21                    	int	21h		; set DTA
 13944                                  
 13945 00001171 BF5C00                  	mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13946 00001174 47                      	inc	di		; ES:DI = ptr to filename field of FCB
 13947 00001175 B03F                    	mov	al,'?'		; AL = wildcard character
 13948 00001177 B90B00                  	mov	cx,11
 13949 0000117A F3AA                    	rep	stosb		; wildcard filename field
 13950                                  
 13951                                  catCrunch:
 13952 0000117C E86A01                  	call	CrunchPath	; crunch pathname to get directory and filename
 13953 0000117F 724B                    	jc	short catRecErr	; handle recorded or extended error
 13954                                  
 13955                                  ;	User's directory has been saved, we've changed to specified directory.
 13956                                  ;	ComSw = error bits for later use
 13957                                  ;	FCB contains parsed filename
 13958                                  
 13959                                  	;cmp	byte [COMSW],0
 13960 00001181 833E[FB9D]00            	cmp	word [COMSW],0
 13961 00001186 7544                    	jne	short catRecErr	; handle recorded error
 13962                                  
 13963 00001188 E8B801                  	call	InstallCtrlC	; install control-C handler
 13964                                  
 13965                                  	; 07/06/2023
 13966                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 13967                                  	; MSDOS 6.0 (DBLSPACE/DRVSPACE)
 13968                                  
 13969                                   	;test	word [_Bits],1	; mask.cratio
 13970 0000118B F606[71A0]01            	test	byte [_Bits],mask.cratio ; compression ratio wanted?
 13971 00001190 740A                    	jz      short catalog4
 13972 00001192 E8380A                  	call    OpenCVF         ; yes, try to open CVF file
 13973 00001195 7305                    	jnc     short catalog4
 13974                                  
 13975                                  	;and	word [_Bits],0FFFEh ; not (mask cratio)
 13976 00001197 8026[71A0]FE            	and	byte [_Bits],~mask.cratio ; 0FEh
 13977                                  
 13978                                  catalog4:	; 07/06/2023
 13979 0000119C E89609                  	call	ZeroTotals	; zero grand totals
 13980 0000119F E88304                  	call	ListDir		; list main directory
 13981                                  	;jc	short catExtErr
 13982                                  	; 07/06/2023
 13983                                  	; MSDOS 6.22 COMMAND.COM
 13984 000011A2 724E                    	jc      short catExtErr1
 13985                                  
 13986                                  	;;;test	Bits,mask subd
 13987                                  	;;test	word [_Bits],4
 13988                                  	;test	byte [_Bits],4
 13989                                  	; 07/06/2023
 13990 000011A4 F606[71A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0 
 13991 000011A9 7405                    	jz	short catalog3	; subdirectories option not set
 13992 000011AB E8AD01                  	call	ListSubds	; list subdirectories
 13993                                  	;jc	short catExtErr
 13994                                  	; 07/06/2023
 13995                                  	; MSDOS 6.22 COMMAND.COM
 13996 000011AE 7242                    	jc      short catExtErr1
 13997                                  
 13998                                  catalog3:
 13999                                  ;	Check if any files were found.
 14000                                  
 14001                                  	;;;test	Bits,mask bare
 14002                                  	;;test	word [_Bits],8
 14003                                  	;test	byte [_Bits],8
 14004                                  	; 07/06/2023
 14005 000011B0 F606[71A0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0
 14006 000011B5 750A                    	jnz	short catRet	; don't bother for bare format
 14007                                  
 14008 000011B7 A1[189E]                	mov	ax,[FileCntTotal]
 14009 000011BA 09C0                    	or	ax,ax
 14010 000011BC 7421                    	jz	short catNoFiles ; no files found
 14011                                  
 14012 000011BE E8D202                  	call	DisplayTotals	; display trailing grand totals
 14013                                  	;jmp	short catRet	; all done
 14014                                  	; 25/04/2023
 14015                                  	; 07/06/2023
 14016                                  catRet:
 14017                                  	;retn	; MSDOS 5.0 COMMAND.COM
 14018                                  	
 14019                                  	; 07/06/2023
 14020                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14021                                  
 14022                                  	;test	word [_Bits],1	; mask.cratio
 14023 000011C1 F606[71A0]01            	test	byte [_Bits],mask.cratio
 14024 000011C6 7403                    	jz      short catRetn
 14025 000011C8 E81F0B                  	call    CloseCVF
 14026                                  catRetn:
 14027 000011CB C3                      	retn
 14028                                  
 14029                                  catRecErr:
 14030                                  
 14031                                  ;	ComSw may have error bit set. If not, do extended error.
 14032                                  
 14033                                  	;;;test	ComSw,mask dev
 14034                                  	;;test	word [COMSW],1
 14035                                  	;test	byte [COMSW],1
 14036 000011CC F606[FB9D]01            	test	byte [COMSW],mask.dev
 14037 000011D1 750C                    	jnz	short catNoFiles 
 14038                                  				; filename is device, respond 'file not found'
 14039                                  	;;test	ComSw,mask baddir
 14040                                  	;;test	word [COMSW],2
 14041                                  	;test	byte [COMSW],2
 14042 000011D3 F606[FB9D]02            	test	byte [COMSW],mask.baddir
 14043                                  	;jz	short catExtErr	; no ComSw error bits, must be extended error
 14044                                  	; 07/06/2023
 14045                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM 
 14046 000011D8 7418                    	jz	short catExtErr1
 14047                                  
 14048                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 14049                                  				; invalid directory
 14050 000011DA BA[3E93]                	mov	dx,badcd_ptr
 14051                                  	;jmp	short catErr
 14052                                  	; 07/06/2023
 14053                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14054 000011DD EB23                    	jmp	short catExtErr2	
 14055                                  
 14056                                  catNoFiles:
 14057                                  
 14058                                  ;	Display header and force 'file not found' message.
 14059                                  
 14060 000011DF E89B07                  	call	DisplayHeader
 14061 000011E2 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 14062 000011E5 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 14063 000011EA BA[0392]                	mov	dx,extend_buf_ptr
 14064 000011ED A3[0392]                	mov	[extend_buf_ptr],ax
 14065                                  	;jmp	short catErr
 14066                                  	; 07/06/2023
 14067                                  	; MSDOS 6.22 COMMAND.COM
 14068 000011F0 EB10                    	jmp	short catExtErr2
 14069                                  
 14070                                  catExtErr:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14071                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14072                                  catExtErr1:
 14073                                  
 14074                                  ;	DOS has returned an error status. Get the extended error#, and
 14075                                  ;	set up an error message, changing 'No more files' error 
 14076                                  ;	to 'File not found' error.
 14077                                  
 14078 000011F2 E84910                  	call	Set_Ext_Error_Msg
 14079 000011F5 833E[0392]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 14080                                  	;jne	short catalog4  ; catErr ; MSDOS 5.0 COMMAND.COM
 14081                                  	; 07/06/2023
 14082                                  	; MSDOS 6.22 COMMAND.COM
 14083 000011FA 7506                    	jne	short catExtErr2	
 14084                                  
 14085 000011FC C706[0392]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 14086                                  
 14087                                  ;catalog4:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14088                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14089                                  catExtErr2:
 14090                                  	;test	word [_Bits],1	; mask.cratio
 14091 00001202 F606[71A0]01            	test	byte [_Bits],mask.cratio
 14092                                  				; close Compressed Volume File if cratio
 14093 00001207 7403                    	jz      short catErr
 14094 00001209 E8DE0A                  	call    CloseCVF
 14095                                  
 14096                                  ;	Error exit. Error message information has been set up
 14097                                  ;	for Std_EPrintf.
 14098                                  
 14099                                  catErr:
 14100 0000120C E98E1C                  	jmp	cerror		; go to COMMAND error recycle point
 14101                                  
 14102                                  	; 25/04/2023
 14103                                  ;catRet:
 14104                                  	;retn
 14105                                  
 14106                                  ; ---------------------------------------------------------------------------
 14107                                  
 14108                                  ;***	SetDefaults - set default pathname, options
 14109                                  ;
 14110                                  ;	ENTRY	DS = TRANGROUP seg addr
 14111                                  ;
 14112                                  ;	EXIT	nothing
 14113                                  ;
 14114                                  ;	USED	AX,DI
 14115                                  ;
 14116                                  ;	EFFECTS
 14117                                  ;	  SrcBuf = '*',EOL - default pathname
 14118                                  ;	  PathPos = ptr to pathname
 14119                                  ;	  PathCnt = length of pathname
 14120                                  
 14121                                  	; 16/02/2023
 14122                                  SetDefaults:
 14123 0000120F BF[87A1]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 14124 00001212 893E[75A0]              	mov	[PathPos],di		; PathPos = ptr to pathname
 14125                                  	;mov	al,STAR
 14126 00001216 B02A                    	mov	al,'*'
 14127 00001218 AA                      	stosb
 14128                                  	;mov	al,END_OF_LINE_IN
 14129 00001219 B00D                    	mov	al,0Dh ; cr
 14130 0000121B AA                      	stosb				; SrcBuf = '*',0Dh
 14131 0000121C C706[73A0]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 14132                                  
 14133 00001222 31C0                    	xor	ax,ax			; AX = 0
 14134 00001224 A3[FB9D]                	mov	[COMSW],ax		; = no error
 14135 00001227 A3[71A0]                	mov	[_Bits],ax		; = options off
 14136 0000122A A2[24A1]                	mov	[DestBuf],al		; = no sort
 14137 0000122D C606[79A0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 14138 00001232 A2[7AA0]                	mov	[AttrSelect],al		; exclude hidden, system files
 14139                                  peRet:	; 25/04/2023
 14140 00001235 C3                      	retn
 14141                                  
 14142                                  ; ---------------------------------------------------------------------------
 14143                                  
 14144                                  ;***	ParseEnvironment - find and parse our environment variable
 14145                                  ;
 14146                                  ;	Find our environment variable and parse it. If a parse
 14147                                  ;	error occurs, issue an error message. The parse results
 14148                                  ;	up to the error will still have effect. Always leave
 14149                                  ;	the option variables in a useable state.
 14150                                  ;
 14151                                  ;	ENTRY	DS = TRANGROUP seg addr
 14152                                  ;
 14153                                  ;	EXIT	nothing
 14154                                  ;
 14155                                  ;	USED	AX,BX,CX,DX,SI,DI
 14156                                  ;
 14157                                  ;	EFFECTS
 14158                                  ;
 14159                                  ;	  Bits may contain new option settings.
 14160                                  ;	  DestBuf may contain new series of sort codes.
 14161                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14162                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14163                                  ;	  PathPos, PathCnt updated for new pathname.
 14164                                  ;
 14165                                  ;	  If a parse error occurred, an error message will be issued.
 14166                                  
 14167                                  	; 16/02/2023
 14168                                  ParseEnvironment:
 14169 00001236 E8A203                  	call	GetEnvValue		; get environment variable value
 14170 00001239 72FA                    	jc	short peRet		; name not found in environment
 14171                                  
 14172                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 14173                                  
 14174 0000123B E80F05                  	call	Parse_Line		; parse environment value
 14175 0000123E 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14176                                  	;cmp	ax,END_OF_LINE
 14177 00001241 74F2                    	je	short peRet		; successful completion
 14178                                  
 14179                                  ;	Some kind of parse error occurred.
 14180                                  ;	We're set up for a Std_EPrintf call.
 14181                                  
 14182 00001243 E8EF42                  	call	std_eprintf		; display the parse error
 14183                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 14184                                  					; restore default msg class
 14185 00001246 C606[0192]FF            	mov	byte [msg_disp_class],0FFh ; -1
 14186                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 14187 0000124B BA[4594]                	mov	dx,errparsenv_ptr
 14188                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 14189                                  	;call	Printf_Crlf
 14190                                  	; 25/04/2023
 14191                                  	;retn
 14192 0000124E E9DE42                  	jmp	Printf_Crlf
 14193                                  					;M008;Internal handling of /? removed
 14194                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14195                                  	; 25/04/2023
 14196                                  ;peRet:
 14197                                  	;retn
 14198                                  
 14199                                  ; ---------------------------------------------------------------------------
 14200                                  
 14201                                  ;***	ParseCmdLine - parse and record command line parameters
 14202                                  ;
 14203                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14204                                  ;		DS, ES, CS = TRANGROUP seg addr
 14205                                  ;
 14206                                  ;	EXIT	CY = set if parse error occurred
 14207                                  ;
 14208                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14209                                  ;		AX = system parser error code
 14210                                  ;		DX = ptr to message block
 14211                                  ;
 14212                                  ;	USED	AX,BX,CX,DX,SI,DI
 14213                                  ;
 14214                                  ;	EFFECTS
 14215                                  ;
 14216                                  ;	  Bits may contain new option settings.
 14217                                  ;	  DestBuf may contain new series of sort codes.
 14218                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14219                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14220                                  ;	  PathPos, PathCnt updated for new pathname.
 14221                                  ;
 14222                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14223                                  ;	  Msg_Disp_Class = parse error class
 14224                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14225                                  ;	  Message block (see DX) is set up for parse error message
 14226                                  
 14227                                  	; 16/02/2023
 14228                                  ParseCmdLine:
 14229 00001251 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14230 00001254 E8F604                  	call	Parse_Line		; parse cmd line tail
 14231 00001257 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14232                                  	;;cmp	ax,END_OF_LINE
 14233                                  	; 25/04/2023
 14234                                  	;je	short pcOk		; parse completed successfully
 14235                                  
 14236                                  ;	A parse error occurred. We're all set up for message output.
 14237                                  
 14238                                  	; 25/04/2023
 14239                                  	; cf = 1 (ax < 0FFFFh)
 14240                                  	;stc		   		; return failure
 14241                                  	;jmp	short pcRet
 14242                                  	; 25/04/2023
 14243                                  	;retn
 14244                                  pcOk:
 14245                                  	; 25/04/2023
 14246                                  	;cf = 0 (ax = 0FFFFh)
 14247                                  	;clc				; return success
 14248                                  pcRet:
 14249 0000125A C3                      	retn
 14250                                  
 14251                                  ; ---------------------------------------------------------------------------
 14252                                  
 14253                                  ;***	SetCollatingTable - set up character collating table for sorting
 14254                                  ;
 14255                                  ;	If country is other than USA, try to get a collating table
 14256                                  ;	for character sorting. For USA, use straight byte values.
 14257                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14258                                  ;	by straight byte values in the USA for better performance.
 14259                                  ;
 14260                                  ;	ENTRY	ES = TRANGROUP seg addr
 14261                                  ;
 14262                                  ;	EXIT	nothing
 14263                                  ;
 14264                                  ;	USED	AX,BX,CX,DX,DI
 14265                                  ;
 14266                                  ;	EFFECTS
 14267                                  ;
 14268                                  ;	  If collating table is set -
 14269                                  ;	    CountryPtrId = 6.
 14270                                  ;	    CountryPtr points to collating table.
 14271                                  ;
 14272                                  ;	  Otherwise -
 14273                                  ;	    CountryPtrId = 0.
 14274                                  
 14275                                  SetCollatingTable:
 14276                                  
 14277                                  ;	Begin modification M028
 14278                                  
 14279                                  	;mov	dx,offset TRANGROUP:InternatVars
 14280                                  	;			; DS:DX = ptr to international info buffer
 14281 0000125B BA[06AA]                	mov	dx,INTERNATVARS
 14282 0000125E B80038                  	mov	ax,3800h
 14283                                  	;mov	ax,INTERNATIONAL << 8
 14284                                  	;;mov	ax,INTERNATIONAL shl 8
 14285                                  				; AX = 'Get current country info'
 14286 00001261 CD21                    	int	21h		; call DOS
 14287 00001263 7217                    	jc	short scNoTable	; error - so don't collate
 14288                                  
 14289                                  ;	BX = country code
 14290                                  
 14291 00001265 83FB01                  	cmp	bx,1
 14292 00001268 7412                    	je	short scNoTable	; we're in USA, don't collate
 14293                                  
 14294                                  ;	End modification M028
 14295                                  
 14296                                  ;*	Country code is other than USA. Try to get a collating table.
 14297                                  
 14298 0000126A B80665                  	mov	ax,6506h
 14299                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14300                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14301                                  				; AH = 'Get Extended Country Info'
 14302                                  				; AL = 'Get Pointer to Collating Table'
 14303 0000126D BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14304 00001270 B90500                  	mov	cx,5		; CX = length of info buffer
 14305 00001273 89DA                    	mov	dx,bx		; DX = country ID = default
 14306                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14307 00001275 BF[26AA]                	mov	di,CountryPtrInfo
 14308                                  				; ES:DI = ptr to info buffer
 14309 00001278 CD21                    	int	21h		; call DOS
 14310 0000127A 7305                    	jnc	short scRet	; success
 14311                                  
 14312                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14313                                  
 14314                                  scNoTable:			;M028
 14315 0000127C C606[26AA]00            	mov	byte [CountryPtrId],0
 14316                                  scRet:
 14317 00001281 C3                      	retn
 14318                                  
 14319                                  ; ---------------------------------------------------------------------------
 14320                                  
 14321                                  ;***	SetOptions - check and set options
 14322                                  ;
 14323                                  ;	ENTRY	nothing
 14324                                  ;
 14325                                  ;	EXIT	nothing
 14326                                  ;
 14327                                  ;	USED	AX,BX,CX,DX
 14328                                  ;
 14329                                  ;	EFFECTS
 14330                                  ;
 14331                                  ;	  Bits may contain modified option settings.
 14332                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14333                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14334                                  ;	  PerLine is set according to /w presence.
 14335                                  
 14336                                  	; 16/02/2023
 14337                                  
 14338                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14339                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:12BEh
 14340                                  
 14341                                  SetOptions:
 14342                                  
 14343                                  ;	If bare listing requested, cancel wide listings.
 14344                                  
 14345                                  	;;;test	Bits,mask bare
 14346                                  	;;test	word [_Bits],8
 14347                                  	;test	byte [_Bits],8
 14348                                  	; 07/06/2023
 14349 00001282 F606[71A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 14350 00001287 7411                    	jz	short setopts1
 14351                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14352                                  	;;and	word [_Bits],0FFFEh
 14353                                  	;;and	byte [_Bits],0FEh
 14354                                  	; 07/06/2023
 14355 00001289 8026[71A0]FD            	and	byte [_Bits],~mask.wide ; 0FDh ; MSDOS 6.0
 14356                                  
 14357                                  ;setopts1:	; MSDOS 5.0 COMMAND.COM
 14358                                  	; 07/06/2023
 14359                                   	; MSDOS 6.22 COMMAND.COM
 14360                                  setopts0:
 14361                                  	;test	word [_Bits],12h  ; (mask bare) or (mask wide)
 14362 0000128E F606[71A0]12            	test	byte [_Bits],(mask.bare|mask.wide)
 14363 00001293 7405                    	jz      short setopts1
 14364                                  	;and 	word [_Bits],0FFFEh ; not mask cratio
 14365 00001295 8026[71A0]FE            	and	byte [_Bits],~mask.cratio
 14366                                  
 14367                                  setopts1:
 14368                                  ;	Set # lines per display page.
 14369                                  
 14370                                  ;M01  Obtain screen height from ROM BIOS data area
 14371                                  ;
 14372                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14373                                  
 14374 0000129A 1E                      	push	ds
 14375                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14376 0000129B B84000                  	mov	ax,40h
 14377 0000129E 8ED8                    	mov	ds,ax			;
 14378                                  	;Assume	DS:ROMBIOS_DATA
 14379                                  
 14380                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14381 000012A0 A08400                  	mov	al,[84h]
 14382 000012A3 1F                      	pop	ds			;
 14383                                  	;Assume	DS:Trangroup
 14384                                  
 14385 000012A4 08C0                    	or	al,al			; If zero specified
 14386 000012A6 7502                    	jnz	short setopts2		;
 14387                                  
 14388                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14389 000012A8 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14390                                  setopts2:
 14391 000012AA 30E4                    	xor	ah,ah
 14392                                  setopts3:
 14393 000012AC FEC0                    	inc	al			; height + 1 ;M018
 14394                                  
 14395 000012AE A3[7DA2]                	mov	[LinPerPag],ax		; set the rows now
 14396                                  
 14397                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14398                                  
 14399                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE 
 14400                                  					; IOCTL for handles
 14401 000012B1 B80C44                  	mov	ax,440Ch
 14402                                  	;mov	bx,STDOUT		; handle #
 14403 000012B4 BB0100                  	mov	bx,1
 14404                                  	;mov	ch,IOC_SC		; screen
 14405 000012B7 B503                    	mov	ch,3
 14406                                  	;mov	cl,get_generic		; get display info
 14407 000012B9 B17F                    	mov	cl,7Fh
 14408 000012BB BA[6DA2]                	mov	dx,Display_Ioctl	; info block
 14409 000012BE CD21                    	int	21h			; call DOS
 14410                                  
 14411 000012C0 A1[7DA2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14412 000012C3 A3[109E]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14413                                  
 14414                                  ;	Set # entries per line.
 14415                                  
 14416                                  	;mov	byte [PerLine],NORMPERLIN
 14417                                  					; # entries per line without /w
 14418 000012C6 C606[0D9E]01            	mov	byte [PerLine],1
 14419                                  	;;;test	Bits,mask wide
 14420                                  	;;test	word [_Bits],1
 14421                                  	;test	byte [_Bits],1
 14422                                  	; 07/06/2023
 14423 000012CB F606[71A0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0
 14424 000012D0 7405                    	jz	short setopts4
 14425                                  	;mov	byte [PerLine],WIDEPERLIN
 14426                                  					; # entries per line with /w
 14427 000012D2 C606[0D9E]05            	mov	byte [PerLine],5
 14428                                  setopts4:
 14429                                  				;M011;start;The following code checks if a drive
 14430                                  				;letter has been parsed into SrcBuf, and if
 14431                                  				;so, the correct drive number is loaded into
 14432                                  				;the first FCB, at offset 5C.
 14433                                  
 14434                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14435 000012D7 803E[88A1]3A            	cmp	byte [SrcBuf+1],':'
 14436 000012DC 750A                    	jne	short soRet
 14437                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14438 000012DE A0[87A1]                	mov	al,[SrcBuf]
 14439                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14440 000012E1 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14441 000012E3 2C40                    	sub	al,'@'	; 40h			; convert to 1-based number (1=A)
 14442 000012E5 A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14443                                  						;M011;end
 14444                                  soRet:
 14445 000012E8 C3                      	retn
 14446                                  
 14447                                  ; ---------------------------------------------------------------------------
 14448                                  
 14449                                  ;***	CrunchPath - analyze supplied or default pathname
 14450                                  ;
 14451                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14452                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14453                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14454                                  ;		 must have space for another char after the delimiter.
 14455                                  ;
 14456                                  ;	EXIT	CY = clear if no error
 14457                                  ;		We are changed to directory found in pathname
 14458                                  ;		Previous directory ready to be restored via RestUDir
 14459                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14460                                  ;
 14461                                  ;		If error occurred,
 14462                                  ;		CY = set
 14463                                  ;		ComSw = error bits (see ErrorRec)
 14464                                  ;		If ComSw not set,
 14465                                  ;		Ready for DOS Get Extended Error call
 14466                                  
 14467                                  	; 16/02/2023
 14468                                  CrunchPath:
 14469 000012E9 E80102                  	call	FileIsDevice
 14470 000012EC 7507                    	jne	short crpath1	; not a device, skip ahead
 14471                                  	;;;or	ComSw,mask dev	; signal file is device
 14472                                  	;;or	word [COMSW],1
 14473                                  	;or	byte [COMSW],1
 14474 000012EE 800E[FB9D]01            	or	byte [COMSW],mask.dev
 14475 000012F3 EB2F                    	jmp	short cpErr	; return error
 14476                                  crpath1:
 14477 000012F5 FF36[75A0]              	push	word [PathPos]	; save ptr to pathname
 14478 000012F9 C606[7DA0]FF            	mov	byte [DirFlag],-1
 14479                                  				; tell PathCrunch not to parse file into FCB
 14480 000012FE E8C418                  	call	PathCrunch	; change to directory in pathname
 14481 00001301 C606[7DA0]00            	mov	byte [DirFlag],0
 14482                                  				; reset our little flag
 14483 00001306 5E                      	pop	si		; SI = ptr to pathname
 14484 00001307 7208                    	jc	short cpNoDir	; didn't find directory path
 14485 00001309 741A                    	jz	short cpRet	; found directory path w/ no filename
 14486                                  				;  - leave wildcard default in FCB and return
 14487                                  
 14488                                  ;*	We found a directory, and there was a filename attached.
 14489                                  ;	DestTail = ptr to ASCIIZ filename
 14490                                  
 14491 0000130B 8B36[21A1]              	mov	si,[DestTail]	; SI = ptr to filename
 14492 0000130F EB28                    	jmp	short cpFile	; go parse the file into FCB
 14493                                  
 14494                                  ;*	PathCrunch failed to find a directory in the pathname.
 14495                                  ;
 14496                                  ;	Msg_Numb = error code
 14497                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14498                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14499                                  
 14500                                  cpNoDir:
 14501 00001311 A1[9AA2]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14502 00001314 09C0                    	or	ax,ax
 14503 00001316 750C                    	jnz	short cpErr	  ; error occurred - return it
 14504 00001318 803E[1FA1]00            	cmp	byte [DestIsDir],0
 14505 0000131D 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14506                                  crpath3:
 14507                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14508                                  	;;or	word [COMSW],2
 14509                                  	;or	byte [COMSW],2
 14510 0000131F 800E[FB9D]02            	or	byte [COMSW],mask.baddir
 14511                                  	;jmp	short cpErr	  ; return error
 14512                                  	; 16/02/2023
 14513                                  cpErr:
 14514 00001324 F9                      	stc			  ; return error
 14515                                  cpRet:
 14516 00001325 C3                      	retn
 14517                                  
 14518                                  cpMaybe:
 14519                                  ;	SI = ptr to pathname
 14520                                  
 14521                                  	;cmp	byte [si+1],COLON_CHAR
 14522 00001326 807C013A                	cmp	byte [si+1],':'
 14523 0000132A 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14524 0000132C AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14525                                  crpath2:
 14526 0000132D 813C2E2E                	cmp	word [si],".."
 14527 00001331 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14528 00001333 807C0200                	cmp	byte [si+2],0
 14529                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14530                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14531                                  	;;;or	word [COMSW],2
 14532                                  	;;or	byte [COMSW],2
 14533                                  	;or	byte [COMSW],mask.baddir
 14534                                  	;jmp	short cpErr	  ; return error
 14535                                  	; 16/02/2023
 14536 00001337 74E6                    	je	short crpath3
 14537                                  
 14538                                  ;	The preceding code was taken from the old DIR routine.
 14539                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14540                                  ;	occurring when we're at the root directory. Too bad it
 14541                                  ;	doesn't handle problems with "..\..", etc.
 14542                                  
 14543                                  ;	We're ready to parse a filename into the FCB.
 14544                                  ;	SI = ptr to ASCIIZ filename
 14545                                  
 14546                                  cpFile:	
 14547 00001339 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14548 0000133C B80E29                  	mov	ax,290Eh
 14549                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14550                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14551                                  				; wildcards already in FCB used as defaults
 14552 0000133F CD21                    	int	21h
 14553 00001341 F8                      	clc			; return success
 14554                                  	;jmp	short cpRet
 14555                                  	; 16/02/2023
 14556 00001342 C3                      	retn
 14557                                  
 14558                                  ;cpErr:
 14559                                  ;	stc			; return error
 14560                                  ;cpRet:
 14561                                  ;	retn
 14562                                  
 14563                                  ; ---------------------------------------------------------------------------
 14564                                  
 14565                                  ;***	InstallCtrlC - install our private control-C handler
 14566                                  ;
 14567                                  ;	Put our control-c handler in front of command.com's default
 14568                                  ;	handler, to make sure the user's default directory gets restored.
 14569                                  ;	This shouldn't be necessary, but, for now, there are situations
 14570                                  ;	where the TDATA segment is left in a modified state when a
 14571                                  ;	control-c occurs.  This means that the transient will be
 14572                                  ;	reloaded, and the user's directory cannot be restored.
 14573                                  ;
 14574                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14575                                  ;
 14576                                  ;	ENTRY	nothing
 14577                                  ;
 14578                                  ;	EXIT	nothing
 14579                                  ;
 14580                                  ;	USED	AX,BX,DX
 14581                                  ;
 14582                                  ;	EFFECTS
 14583                                  ;
 14584                                  ;	  CtrlCHandler address placed in int 23 vector.
 14585                                  ;
 14586                                  ;	NOTE
 14587                                  ;
 14588                                  ;	  Command.com's basic control-c handler will be restored
 14589                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14590                                  
 14591                                  	; 16/02/2023
 14592                                  InstallCtrlC:
 14593 00001343 06                      	push	es			; preserve ES
 14594 00001344 B82335                  	mov	ax,3523h
 14595                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14596                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14597 00001347 CD21                    	int	21h
 14598 00001349 891E[2BAA]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14599 0000134D 8C06[2DAA]              	mov	[OldCtrlCHandler+2],es	 
 14600 00001351 07                      	pop	es			; restore ES
 14601                                  
 14602 00001352 BA[401B]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14603 00001355 B82325                  	mov	ax,2523h
 14604                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14605                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14606 00001358 CD21                    	int	21h
 14607 0000135A C3                      	retn
 14608                                  
 14609                                  ; ---------------------------------------------------------------------------
 14610                                  
 14611                                  ;***	ListSubds - search and list files in subdirectories
 14612                                  ;
 14613                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14614                                  ;		FCB is still set up for file searches
 14615                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14616                                  ;
 14617                                  ;	EXIT	CY = clear if no error
 14618                                  ;		FileCnt = # files found & displayed
 14619                                  ;		FileSiz = total size of files found
 14620                                  ;
 14621                                  ;		If error,
 14622                                  ;		CY = set
 14623                                  ;		Ready for DOS Get Extended Error call
 14624                                  ;
 14625                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14626                                  ;
 14627                                  ;	EFFECTS
 14628                                  ;
 14629                                  ;	  FileCntTotal, FileSizTotal are updated.
 14630                                  ;	  Subdirectories may be listed on standard output device.
 14631                                  ;
 14632                                  ;	NOTES
 14633                                  ;
 14634                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14635                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14636                                  ;	   Each name is stored ASCIIZ.
 14637                                  
 14638                                  	; 16/02/2023
 14639                                  ListSubds:
 14640                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14641 0000135B E8D01E                  	call	SetRest1
 14642                                  
 14643 0000135E BB[E1A1]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14644                                  lsNode:
 14645 00001361 C60700                  	mov	byte [bx],0		; start with null child name
 14646                                  lsLoop:
 14647 00001364 E81002                  	call	FindNextChild		; search for next subdirectory
 14648 00001367 7235                    	jc	short lsErr		; search failed - examine error
 14649                                  
 14650 00001369 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14651 0000136B E8AA04                  	call	ChangeDir		; enter child directory
 14652                                  
 14653                                  					; M023;start
 14654 0000136E 7306                    	jnc	short lstsd1		; check for error
 14655                                  	;cmp	ax,3
 14656 00001370 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14657 00001373 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14658                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14659                                  	; 16/02/2023			; M023;end
 14660 00001375 C3                      	retn
 14661                                  lstsd1:	
 14662 00001376 53                      	push	bx
 14663 00001377 E8AB02                  	call	ListDir			; list the directory
 14664 0000137A 5B                      	pop	bx
 14665                                  
 14666                                  ;	Note we're ignoring errors returned here.
 14667                                  
 14668 0000137B 89DF                    	mov	di,bx			; DI = ptr to child's name
 14669 0000137D B90D00                  	mov	cx,13			; CX = max name length w/ null
 14670 00001380 30C0                    	xor	al,al			; AL = zero byte to look for
 14671 00001382 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14672 00001384 53                      	push	bx			; save ptr to child's name
 14673 00001385 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14674 00001387 E8D7FF                  	call	lsNode			; recurse from new node
 14675 0000138A 5B                      	pop	bx			; BX = ptr to child's name
 14676 0000138B 9C                      	pushf				; save error condition
 14677                                  	
 14678                                  	;;shove	0
 14679                                  	;mov	ax,0
 14680 0000138C 29C0                    	sub	ax,ax ; 0
 14681 0000138E 50                      	push	ax
 14682                                  	;shove	".."
 14683 0000138F B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14684 00001392 50                      	push	ax
 14685 00001393 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14686 00001395 E88004                  	call	ChangeDir		; return to parent directory
 14687 00001398 58                      	pop	ax			; restore stack
 14688 00001399 58                      	pop	ax
 14689                                  
 14690 0000139A 9D                      	popf				; restore error condition from child
 14691                                  	;jc	short lsRet		; return error
 14692                                  	;jmp	short lsLoop		; look for more children
 14693                                  	; 16/02/2023
 14694 0000139B 73C7                    	jnc	short lsLoop
 14695 0000139D C3                      	retn
 14696                                  lsErr:
 14697 0000139E E8AD0E                  	call	get_ext_error_number	; AX = extended error code
 14698                                  	;cmp	ax,2
 14699 000013A1 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14700 000013A4 7406                    	je	short lsRet		; file not found, we're ok
 14701                                  	;cmp	ax,18
 14702 000013A6 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14703 000013A9 7401                    	je	short lsRet		; no more files, we're ok
 14704 000013AB F9                      	stc				; return other errors
 14705                                  lsRet:	
 14706 000013AC C3                      	retn
 14707                                  
 14708                                  ; ---------------------------------------------------------------------------
 14709                                  
 14710                                  	;break	<DIR support routines>
 14711                                  
 14712                                  ;***	SUPPORT ROUTINES
 14713                                  
 14714                                  ; ----------------------
 14715                                  
 14716                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14717                                  ;
 14718                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14719                                  ;		BX = ptr to last child's name
 14720                                  ;		BP = ptr to temp child's name
 14721                                  ;
 14722                                  ;	EXIT	nothing
 14723                                  ;
 14724                                  ;	USED	AX,CX,SI,DI
 14725                                  ;
 14726                                  ;	EFFECTS
 14727                                  ;
 14728                                  ;	  Filename pointed to by BP may be changed.
 14729                                  ;
 14730                                  ;	NOTES
 14731                                  ;
 14732                                  ;	  Potential filename replaces temp filename if:
 14733                                  ;	   it's a subdirectory file;
 14734                                  ;	   it doesn't start with a '.';
 14735                                  ;	   it's alphanumerically greater than last child's name;
 14736                                  ;	   and it's alphanumerically less than temp name.
 14737                                  
 14738                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14739                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14740                                  CheckChild:
 14741                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14742 000013AD F606[34A0]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14743 000013B2 741D                    	jz	short ccRet	; not a subdirectory file- return
 14744                                  
 14745                                  	; 16/02/2023
 14746 000013B4 BE[3DA0]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14747 000013B7 803C2E                  	cmp	byte [si],'.'
 14748                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14749                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14750 000013BA 7415                    	je	short ccRet	; starts with a dot- return
 14751                                  
 14752                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14753                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14754 000013BC 89DF                    	mov	di,bx
 14755 000013BE E86E04                  	call	CmpAscz		; compare candidate to last child's name
 14756 000013C1 760E                    	jna	short ccRet	; it's not above it- return
 14757                                  
 14758                                  	; 07/06/2023
 14759                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14760                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14761                                  	; si = DIRBUF+FIND_BUF.PNAME
 14762 000013C3 89EF                    	mov	di,bp
 14763 000013C5 E86704                  	call	CmpAscz		; compare candidate to temp name
 14764 000013C8 7307                    	jnb	short ccRet	; it's not below it- return
 14765                                  
 14766                                  ;	New kid is alright. Copy to temp.
 14767                                  
 14768                                  	; 07/06/2023
 14769                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14770                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14771                                  	; si = DIRBUF+FIND_BUF.PNAME
 14772 000013CA 89EF                    	mov	di,bp
 14773 000013CC B90D00                  	mov	cx,13
 14774 000013CF F3A4                    	rep	movsb
 14775                                  ccRet:
 14776 000013D1 C3                      	retn
 14777                                  
 14778                                  ; ---------------------------------------------------------------------------
 14779                                  
 14780                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14781                                  ;
 14782                                  ;	Compare one directory entry against another according to
 14783                                  ;	the sort codes in DestBuf. One or more comparisons
 14784                                  ;	may be made of file name, extension, time/date, and
 14785                                  ;	size.  Comparisons may be made for upward or downward
 14786                                  ;	sort order.
 14787                                  ;
 14788                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14789                                  ;		ES:BP = ptr to entry to be compared against
 14790                                  ;		DestBuf contains sort codes (see DestBuf)
 14791                                  ;		DS = TRANGROUP seg addr
 14792                                  ;
 14793                                  ;	EXIT	BX = unchanged
 14794                                  ;		BP = unchanged
 14795                                  ;		Condition flags set for same, above, or below
 14796                                  ;		 comparing BX entry against BP entry.
 14797                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14798                                  ;
 14799                                  ;	USED:	AX,CX,DX,SI,DI
 14800                                  
 14801                                  	; 16/02/2023
 14802                                  CmpEntry:
 14803 000013D2 BE[24A1]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14804                                  ceLoop:
 14805 000013D5 31C0                    	xor	ax,ax		; AX = 0
 14806 000013D7 8A04                    	mov	al,[si]		; AL = sort code
 14807 000013D9 08C0                    	or	al,al
 14808 000013DB 741C                    	jz	short ceDone	; sort code is zero, we're done
 14809 000013DD 46                      	inc	si		; DS:SI = ptr to next sort code
 14810 000013DE 56                      	push	si		; save ptr to next sort code
 14811 000013DF FEC8                    	dec	al
 14812 000013E1 D0E0                    	shl	al,1
 14813                                  	;sal	al,1		; AX = index into cmp call table
 14814                                  				; CY set for downward sort order
 14815 000013E3 89C6                    	mov	si,ax		; SI = index into cmp call table
 14816 000013E5 2E8B84[FA13]            	mov	ax,[cs:si+FieldCmps]
 14817                                  				; AX = addr of compare routine
 14818 000013EA 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14819 000013EC FFD0                    	call	ax 		; do upwards sort
 14820 000013EE EB06                    	jmp	short ceNs
 14821                                  ceDn:
 14822 000013F0 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14823 000013F2 FFD0                    	call	ax		; do sort
 14824 000013F4 87DD                    	xchg	bx,bp		; swap ptrs back
 14825                                  ceNs:
 14826 000013F6 5E                      	pop	si		; SI = ptr to next sort code
 14827 000013F7 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14828                                  ceDone:
 14829                                  
 14830                                  ;	Get here either from unequal compare or sort code = 0.
 14831                                  ;	In the latter case, condition codes indicate equality,
 14832                                  ;	which is correct.
 14833                                  
 14834 000013F9 C3                      	retn
 14835                                  
 14836                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14837                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14838                                  
 14839                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 14840                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:144Eh)
 14841                                  
 14842                                  FieldCmps:		; call table of entry comparisons
 14843 000013FA [0614]                  	dw	CmpName
 14844 000013FC [1114]                  	dw	CmpExt
 14845 000013FE [4F14]                  	dw	CmpTime
 14846 00001400 [6B14]                  	dw	CmpSize
 14847 00001402 [7014]                  	dw	CmpType
 14848                                  	; 05/06/2023 - Retro DOS 4.2 COMMAND.COM
 14849 00001404 [7E14]                  	dw	CmpCratio
 14850                                  
 14851                                  ; ---------------------------------------------------------------------------
 14852                                  
 14853                                  ;***	CmpName - compare file name of two entries
 14854                                  ;***	CmpExt - compare extension of two entries
 14855                                  ;
 14856                                  ;	ENTRY	ES:BX = ptr to one entry
 14857                                  ;		ES:BP = ptr to another entry
 14858                                  ;
 14859                                  ;	EXIT	BX = unchanged
 14860                                  ;		BP = unchanged
 14861                                  ;		Condition flags set for same, above, or below
 14862                                  ;		comparing BX entry to BP entry.
 14863                                  ;
 14864                                  ;	USED:	AX,CX,DX,SI,DI
 14865                                  
 14866                                  	; 16/02/2023
 14867                                  CmpName:
 14868 00001406 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14869 00001408 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14870                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14871                                  	;add	si,1
 14872                                  	; 25/04/2023
 14873 0000140A 46                      	inc	si
 14874                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14875                                  	;add	di,1
 14876                                  	; 25/04/2023
 14877 0000140B 47                      	inc	di
 14878                                  	;mov	cx,size filename
 14879                                  				; CX = length of name
 14880 0000140C B90800                  	mov	cx,8
 14881 0000140F EB0C                    	jmp	short CmpStr
 14882                                  
 14883                                  CmpExt:
 14884                                  	; 07/06/2023
 14885                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14886                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14887                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14888                                  	;add	si,9
 14889                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14890                                  	;add	di,9
 14891                                  	;
 14892 00001411 BE0900                  	mov	si,9
 14893 00001414 89F7                    	mov	di,si ; mov di,9
 14894 00001416 01DE                    	add	si,bx
 14895 00001418 01EF                    	add	di,bp
 14896                                  	;
 14897                                  	;mov	cx,size fileext	; CX = length of extension field
 14898 0000141A B90300                  	mov	cx,3
 14899                                  
 14900                                  ;	Bugbug:	use symbol for subfunction code.
 14901                                  
 14902                                  CmpStr:	
 14903 0000141D 803E[26AA]06            	cmp	byte [CountryPtrId],6
 14904 00001422 7527                    	jne	short cnNoCollTable
 14905                                  				; no collating table available
 14906                                  
 14907                                  ;*	Compare strings using collating table.
 14908                                  ;
 14909                                  ;	ES:SI = ptr to 1st string
 14910                                  ;	ES:DI = ptr to 2nd string
 14911                                  ;	CX = length
 14912                                  
 14913 00001424 55                      	push	bp		; preserve BP
 14914 00001425 53                      	push	bx		; preserve BX
 14915 00001426 1E                      	push	ds		; preserve DS
 14916 00001427 C51E[27AA]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14917                                  	;assume	ds:NOTHING
 14918 0000142B 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14919 0000142D 43                      	inc	bx
 14920 0000142E 43                      	inc	bx		; DS:BX = ptr to collating values
 14921                                  				; DS:[BX]-2 = size of table
 14922 0000142F 31C0                    	xor	ax,ax		; AX = 0 for starters
 14923                                  
 14924                                  ;	Bugbug:	Investigate removing collating table length checks.
 14925                                  
 14926                                  cnNextChar:
 14927 00001431 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14928 00001434 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14929 00001435 39E8                    	cmp	ax,bp		; compare to collating table length
 14930 00001437 7301                    	jae	short cn1 	; char not in table
 14931 00001439 D7                      	xlat				
 14932                                  cn1:				; AL = AX = collating value
 14933 0000143A 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14934                                  	;lods	byte ptr es:[si]
 14935 0000143C 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14936                                  				; ES:SI = ptr to next char 1st string
 14937 0000143E 39E8                    	cmp	ax,bp		; compare to collating table length
 14938 00001440 7301                    	jae	short cn2	; char not in table
 14939 00001442 D7                      	xlat				
 14940                                  cn2:				; AL = AX = collating value
 14941 00001443 39D0                    	cmp	ax,dx		; compare collating values
 14942 00001445 E1EA                    	loope	cnNextChar	; until unequal or no more left
 14943                                  
 14944 00001447 1F                      	pop	ds		; restore DS
 14945                                  	;assume	ds:TRANGROUP
 14946 00001448 5B                      	pop	bx		; restore BX
 14947 00001449 5D                      	pop	bp		; restore BP
 14948 0000144A C3                      	retn
 14949                                  
 14950                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14951                                  ;	Don't we wish we could just do this all the time?  Sigh.
 14952                                  
 14953                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14954                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14955                                  cnNoCollTable:
 14956                                  	;repe	cmps byte ptr es:[si],[di]
 14957                                  				;db 0F3h,26h,0A6h,0C3h
 14958 0000144B F3                      	repe	; 0F3h
 14959 0000144C 26                      	es	; 26h
 14960 0000144D A6                      	cmpsb	; 0A6h
 14961 0000144E C3                      	retn	; 0C3h
 14962                                  
 14963                                  ; ---------------------------------------------------------------------------
 14964                                  
 14965                                  ;***	CmpTime - compare entries by date/time
 14966                                  ;
 14967                                  ;	ENTRY	ES:BX = ptr to one entry
 14968                                  ;		ES:BP = ptr to another entry
 14969                                  ;
 14970                                  ;	EXIT	BX = unchanged
 14971                                  ;		BP = unchanged
 14972                                  ;		Condition flags set for same, above, or below
 14973                                  ;		 comparing BX entry to BP entry.
 14974                                  ;
 14975                                  ;	USED:	CX,SI,DI
 14976                                  ;
 14977                                  ;	NOTE	Filetime and filedate fields in our private entry
 14978                                  ;		structure must be adjacent and in that order.
 14979                                  
 14980                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14981                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14982                                  CmpTime:
 14983 0000144F 89DE                    	mov	si,bx
 14984 00001451 89EF                    	mov	di,bp
 14985                                  	;add	si,filedate + size filedate - 1
 14986 00001453 83C610                  	add	si,16 ; 15+2-1
 14987                                  	;add	di,filedate + size filedate - 1
 14988 00001456 83C710                  	add	di,16 ; 15+2-1
 14989                                  	; 07/06/2023
 14990 00001459 BE1000                  	mov	si,16
 14991                                  CmpST2:		; 07/06/2023
 14992 0000145C 89F7                    	mov	di,si	; mov di,16
 14993 0000145E 01DE                    	add	si,bx
 14994 00001460 01EF                    	add	di,bp
 14995                                  
 14996                                  	;mov	cx,size filetime + size filedate
 14997 00001462 B90400                  	mov	cx,4 ; 2+2
 14998 00001465 FD                      	std
 14999                                  	;repe	cmps byte ptr es:[si],[di]
 15000                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 15001 00001466 F3                      	repe	; 0F3h
 15002 00001467 26                      	es	; 26h
 15003 00001468 A6                      	cmpsb	; 0A6h
 15004                                  	
 15005 00001469 FC                      	cld	; 0FCh
 15006 0000146A C3                      	retn	; 0C3h
 15007                                  
 15008                                  ; ---------------------------------------------------------------------------
 15009                                  
 15010                                  ;***	CmpSize - compare entries by size
 15011                                  ;
 15012                                  ;	ENTRY	ES:BX = ptr to one entry
 15013                                  ;		ES:BP = ptr to another entry
 15014                                  ;
 15015                                  ;	EXIT	BX = unchanged
 15016                                  ;		BP = unchanged
 15017                                  ;		Condition flags set for same, above, or below
 15018                                  ;		 comparing BX entry to BP entry.
 15019                                  ;
 15020                                  ;	USED:	CX,SI,DI
 15021                                  
 15022                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15023                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15024                                  CmpSize:
 15025                                  	;mov	si,bx
 15026                                  	;mov	di,bp
 15027                                  	;;add	si,filesize + size filesize - 1
 15028                                  	;add	si,20  ; 17+4-1
 15029                                  	;;add	di,filesize + size filesize - 1
 15030                                  	;add	di,20  ; 17+4-1
 15031                                  	; 07/06/2023
 15032 0000146B BE1400                  	mov	si,20
 15033                                  	;;;
 15034 0000146E EBEC                    	jmp	short CmpST2 ; 07/06/2023
 15035                                  	;;;
 15036                                  ;CmpST2:
 15037                                  ;	mov	di,si	; mov di,20
 15038                                  ;	add	si,bx
 15039                                  ;	add	di,bp
 15040                                  ;
 15041                                  ;	;mov	cx,size filesize
 15042                                  ;	mov	cx,4
 15043                                  ;	std
 15044                                  ;	;repe	cmps byte ptr es:[si],[di]
 15045                                  ;				;db 0F3h,26h,0A6h
 15046                                  ;	repe	; 0F3h
 15047                                  ;	es	; 26h
 15048                                  ;	cmpsb	; 0A6h
 15049                                  ;
 15050                                  ;	cld
 15051                                  ;	retn
 15052                                  
 15053                                  ; ---------------------------------------------------------------------------
 15054                                  
 15055                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 15056                                  ;
 15057                                  ;	ENTRY	ES:BX = ptr to one entry
 15058                                  ;		ES:BP = ptr to another entry
 15059                                  ;
 15060                                  ;	EXIT	BX = unchanged
 15061                                  ;		BP = unchanged
 15062                                  ;		Condition flags set for same, above, or below
 15063                                  ;		 comparing BX entry to BP entry.
 15064                                  ;
 15065                                  ;	USED:	AX
 15066                                  
 15067                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15068                                  CmpType:
 15069                                  	;mov	al,es:[bx].fileattr
 15070 00001470 268A470C                	mov	al,[es:bx+12]
 15071                                  	;mov	ah,es:[bp].fileattr
 15072 00001474 268A660C                	mov	ah,[es:bp+12]
 15073                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 15074                                  	;and	ax,1010h
 15075 00001478 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 15076 0000147B 38C4                    	cmp	ah,al
 15077 0000147D C3                      	retn
 15078                                  
 15079                                  ; ---------------------------------------------------------------------------
 15080                                  
 15081                                  ;***	CmpCratio - compare entries by compression ratio
 15082                                  ;
 15083                                  ;	ENTRY	ES:BX = ptr to one entry
 15084                                  ;		ES:BP = ptr to another entry
 15085                                  ;
 15086                                  ;	EXIT	BX = unchanged
 15087                                  ;		BP = unchanged
 15088                                  ;		Condition flags set for same, above, or below
 15089                                  ;		 comparing BX entry to BP entry.
 15090                                  ;
 15091                                  ;	USED:	AX
 15092                                  
 15093                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 15094                                  CmpCratio:
 15095                                  	;mov	al,es:[bx].compratio
 15096 0000147E 268A4715                	mov	al,[es:bx+21]	
 15097                                  	;cmp	al,es:[bp].compratio
 15098 00001482 263A4615                	cmp     al,[es:bp+21]
 15099 00001486 C3                      	retn
 15100                                  
 15101                                  ; ---------------------------------------------------------------------------
 15102                                  
 15103                                  ;***	DefaultAttr - set default attribute conditions
 15104                                  ;
 15105                                  ;	ENTRY	nothing
 15106                                  ;
 15107                                  ;	EXIT	CY clear
 15108                                  ;
 15109                                  ;	USED
 15110                                  ;
 15111                                  ;	EFFECTS
 15112                                  ;
 15113                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15114                                  
 15115                                  	; 16/02/2023
 15116                                  DefaultAttr:
 15117                                  	;mov	byte [AttrSpecified],6
 15118 00001487 C606[79A0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 15119                                  					; specify H and S
 15120 0000148C C606[7AA0]00            	mov	byte [AttrSelect],0	; H and S must be off
 15121 00001491 F8                      	clc				; return success
 15122                                  dtRet:	; 18/02/2023
 15123 00001492 C3                      	retn
 15124                                  
 15125                                  ; ---------------------------------------------------------------------------
 15126                                  
 15127                                  ;***	DisplayTotals - display grand total stats
 15128                                  ;
 15129                                  ;	If we searched subdirectories, display the total # files found
 15130                                  ;	 and total size of files found.
 15131                                  ;	Display disk space remaining.
 15132                                  ;
 15133                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 15134                                  ;		Bits contains setting of /s
 15135                                  ;		FCB contains drive #
 15136                                  ;
 15137                                  ;	EXIT	nothing
 15138                                  ;
 15139                                  ;	USES	AX,DX
 15140                                  ;		FileSiz
 15141                                  
 15142                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15143                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 15144                                  
 15145                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15146                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:14F1h
 15147                                  
 15148                                  DisplayTotals:
 15149                                  	;;;test	Bits,mask subd
 15150                                  	;;test	word [_Bits],4
 15151                                  	;test	byte [_Bits],4
 15152                                  	; 07/06/2023
 15153 00001493 F606[71A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 15154 00001498 7432                    	jz	short dtFree		; no subdirectories- do bytes free
 15155                                  
 15156 0000149A E87F16                  	call	CRLF2			; start on new line
 15157 0000149D E82304                  	call	UseLine
 15158                                  
 15159 000014A0 BA[4294]                	mov	dx,total_ptr
 15160 000014A3 E89740                  	call	std_printf		; "Total:",cr,lf
 15161 000014A6 E81A04                  	call	UseLine
 15162                                  	;;;
 15163                                  	; 07/06/2023
 15164                                  	; MSDOS 6.22 COMMAND.COM
 15165                                  	;test	word [_Bits],1		; mask.cratio
 15166 000014A9 F606[71A0]01            	test	byte [_Bits],mask.cratio
 15167 000014AE 740E                    	jz      short dtCntSize
 15168 000014B0 A1[249E]                	mov     ax,[ccluUsedTotal]
 15169 000014B3 A3[229E]                	mov     [ccluUsedDir],ax
 15170 000014B6 BE[2E9E]                	mov     si,csecUsedTotal
 15171 000014B9 BF[2A9E]                	mov     di,csecUsedDir
 15172 000014BC A5                      	movsw
 15173 000014BD A5                      	movsw
 15174                                  dtCntSize:    
 15175                                  	;;;
 15176 000014BE A1[189E]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 15177 000014C1 BE[1C9E]                	mov	si,FileSizTotal
 15178 000014C4 BF[149E]                	mov	di,FileSiz
 15179 000014C7 A5                      	movsw
 15180 000014C8 A5                      	movsw				; move total size to size variable
 15181 000014C9 E8FD05                  	call	DisplayCntSiz		; display file count & size &
 15182                                  dtFree: 				;   (maybe) compression ratio
 15183 000014CC B436                    	mov	ah,36h
 15184                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 15185 000014CE 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 15186 000014D2 CD21                    	int	21h			; call DOS
 15187 000014D4 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 15188 000014D7 74B9                    	jz	short dtRet		; can't get drive space - return
 15189 000014D9 F7E1                    	mul	cx
 15190 000014DB F7E3                    	mul	bx
 15191 000014DD A3[0FA1]                	mov	[Bytes_Free],ax
 15192 000014E0 8916[11A1]              	mov	[Bytes_Free+2],dx
 15193 000014E4 BA[5192]                	mov	dx,bytmes_ptr
 15194 000014E7 E85340                  	call	std_printf		; "nnn bytes free",cr,lf
 15195                                  	;call	UseLine
 15196                                  ;dtRet:
 15197                                  	;retn
 15198                                  	; 18/02/2023
 15199 000014EA E9D603                  	jmp	UseLine
 15200                                  
 15201                                  ; ---------------------------------------------------------------------------
 15202                                  
 15203                                  ;***	FileIsDevice - see if file looks like a device
 15204                                  ;
 15205                                  ;	ENTRY	PathPos = ptr to pathname
 15206                                  ;		PathCnt = length of pathname w/o terminating char
 15207                                  ;		DirBuf is DOS DTA
 15208                                  ;
 15209                                  ;	EXIT	ZR = set if file looks like a device
 15210                                  ;
 15211                                  ;	USED	AX,BX,CX,DX,DI
 15212                                  ;
 15213                                  ;	EFFECTS
 15214                                  ;
 15215                                  ;	  DTA buffer holds results of Find First function
 15216                                  ;
 15217                                  ;	NOTES
 15218                                  ;
 15219                                  ;	  We try to flag devices in two ways. First, we try
 15220                                  ;	  the DOS Find First function. It returns attribute bit 6
 15221                                  ;	  set on a successful find if it identifies a device name.
 15222                                  ;	  Unfortunately, it returns 'path not found' for a device
 15223                                  ;	  name terminated with colon, such as "CON:". So, we look
 15224                                  ;	  for any colon in the pathname after the 2nd character,
 15225                                  ;	  and flag the pathname as a device if we find one.
 15226                                  
 15227                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15228                                  FileIsDevice:
 15229 000014ED 8B16[75A0]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 15230                                  
 15231 000014F1 89D7                    	mov	di,dx
 15232 000014F3 033E[73A0]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 15233 000014F7 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 15234 000014F9 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 15235                                  
 15236 000014FB 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 15237 000014FD B44E                    	mov	ah,4Eh
 15238                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 15239 000014FF CD21                    	int	21h	 	 ; call DOS
 15240 00001501 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 15241 00001503 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 15242                                  
 15243                                  ;	Found a dir entry, see if Find First thinks it's a device.
 15244                                  
 15245                                  	;test	byte [DIRBUF+21],40h
 15246 00001505 F606[34A0]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 15247 0000150A 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 15248 0000150C 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 15249                                  	;jmp	short piRet
 15250                                  	; 25/04/2023
 15251                                  piRet:
 15252 0000150E C3                      	retn
 15253                                  
 15254                                  ;	Device attribute not returned by Find First function. But
 15255                                  ;	let's check for a colon anywhere in the pathname after the
 15256                                  ;	second byte.
 15257                                  ;
 15258                                  ;	DI = ptr to byte after pathname
 15259                                  
 15260                                  piCol:
 15261 0000150F 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15262 00001510 B03A                    	mov	al,':'
 15263                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15264 00001512 8B0E[73A0]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15265 00001516 49                      	dec	cx
 15266 00001517 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15267 00001518 09C9                    	or	cx,cx
 15268 0000151A 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15269 0000151C 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15270 0000151E FD                      	std			 ; scan downward
 15271 0000151F F2AE                    	repne	scasb
 15272 00001521 FC                      	cld			 ; restore default upward direction
 15273                                  
 15274                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15275                                  ;piRet:
 15276 00001522 C3                      	retn
 15277                                  
 15278                                  ;FileIsDevice endp
 15279                                  
 15280                                  ; ---------------------------------------------------------------------------
 15281                                  
 15282                                  ;***	FindFirst - find first directory entry to display
 15283                                  ;***	FindNext - find next directory entry to display
 15284                                  ;
 15285                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15286                                  ;		AttrSpecified, AttrSelect are set
 15287                                  ;
 15288                                  ;	EXIT	CY = clear if successful
 15289                                  ;		BX = offset in TPA buffer of directory entry found
 15290                                  ;
 15291                                  ;		If unsuccessful,
 15292                                  ;		CY = set
 15293                                  ;		AX = DOS error code
 15294                                  ;		DOS Get Extended Error call will get error code
 15295                                  ;
 15296                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15297                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15298                                  ;		but DOS Get Extended Error call WON'T return the correct
 15299                                  ;		error. That's ok, because we'll see the value in AX
 15300                                  ;		and recognize it as a non-error condition.
 15301                                  ;
 15302                                  ;	USED	AX,CX,DX,SI,DI
 15303                                  ;
 15304                                  ;	EFFECTS
 15305                                  ;
 15306                                  ;	  Entries in memory may be marked as output.
 15307                                  ;	  If not sorted, entry is loaded at TPA.
 15308                                  ;
 15309                                  ;	NOTES
 15310                                  ;
 15311                                  ;	  If we don't find a qualifying file, we return after the final
 15312                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15313                                  ;	   indicate an appropriate condition.
 15314                                  
 15315                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15316                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15317                                  
 15318                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15319                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1585h
 15320                                  	
 15321                                  FindFirst:
 15322                                  	;mov	ax,offset TRANGROUP:GetFirst
 15323 00001523 B8[FA15]                	mov	ax,GetFirst
 15324 00001526 EB03                    	jmp	short ffFindEntry
 15325                                  
 15326                                  	; 18/02/2023
 15327                                  FindNext:
 15328                                  	;mov	ax,offset TRANGROUP:GetNext
 15329 00001528 B8[0816]                	mov	ax,GetNext
 15330                                  
 15331                                  ;	AX = address of correct disk get routine to use.
 15332                                  
 15333                                  ffFindEntry:
 15334 0000152B 06                      	push	es			; save TRANGROUP seg addr
 15335                                  	;;;test	Bits,mask inmem
 15336                                  	;;test	word [_Bits],20h
 15337                                  	;test	byte [_Bits],20h
 15338                                  	; 07/06/2023
 15339 0000152C F606[71A0]40            	test	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0
 15340 00001531 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15341                                  
 15342                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15343                                  ;	There will always be one, or LoadEntries would've failed.
 15344                                  
 15345 00001533 E81A00                  	call	FindInMem		; find first entry in TPA
 15346 00001536 EB16                    	jmp	short ffRet		; return what TPA search returns
 15347                                  
 15348                                  ;	Get entry from disk.
 15349                                  
 15350                                  ffDisk:
 15351 00001538 FFD0                    	call	ax			; get entry from disk
 15352 0000153A 720E                    	jc	short ffGetErr		; get & return error
 15353 0000153C 8E06[E69D]              	mov	es,[TPA]		; ES = seg addr of TPA
 15354 00001540 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15355 00001542 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15356 00001544 E86001                  	call	LoadEntry		; load entry to TPA
 15357 00001547 F8                      	clc				; return success
 15358 00001548 EB04                    	jmp	short ffRet
 15359                                  
 15360                                  ffGetErr:
 15361 0000154A E8010D                  	call	 get_ext_error_number	; AX = DOS error code
 15362 0000154D F9                      	stc
 15363                                  ffRet:
 15364 0000154E 07                      	pop	es			; ES = TRANGROUP seg addr again
 15365 0000154F C3                      	retn
 15366                                  
 15367                                  ; ---------------------------------------------------------------------------
 15368                                  
 15369                                  ;***	FindInMem - find next directory entry in TPA buffer
 15370                                  ;
 15371                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15372                                  ;
 15373                                  ;	EXIT	BX = offset in TPA of entry found
 15374                                  ;
 15375                                  ;		If no more files,
 15376                                  ;		CY = set
 15377                                  ;		AX = DOS 'no more files' error code
 15378                                  ;
 15379                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15380                                  ;
 15381                                  ;	EFFECTS
 15382                                  ;
 15383                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15384                                  
 15385                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15386                                  FindInMem:
 15387 00001550 8E06[E69D]              	mov	es,[TPA]		; ES = TPA seg addr
 15388 00001554 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15389 00001556 FC                      	cld				; make sure default string direction is up
 15390                                  	
 15391 00001557 E86D00                  	call	FindOneInMem		; locate an entry
 15392 0000155A 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15393                                  
 15394                                  ;	BX = ptr to entry in TPA
 15395                                  
 15396                                  fiBest:
 15397 0000155C 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15398                                  fiNext:
 15399 0000155E E87300                  	call	FindNextInMem		; locate next entry
 15400 00001561 720C                    	jc	short fiFound		; no more, best entry so far wins
 15401                                  
 15402                                  ;	BX = ptr to next entry
 15403                                  
 15404 00001563 E86CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15405 00001566 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15406 00001568 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15407                                  
 15408                                  fiNoMore:
 15409                                  
 15410                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15411                                  
 15412                                  	;mov	ax,18
 15413 0000156A B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15414 0000156D F9                      	stc				; return error
 15415                                  	;jmp	short fiRet
 15416                                  	; 18/02/2023
 15417 0000156E C3                      	retn
 15418                                  
 15419                                  fiFound:
 15420 0000156F 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15421 00001571 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15422 00001575 F8                      	clc				; return success
 15423                                  fiRet:
 15424 00001576 C3                      	retn
 15425                                  
 15426                                  ; ---------------------------------------------------------------------------
 15427                                  
 15428                                  ;***	FindNextChild - find next subdirectory in current directory
 15429                                  ;
 15430                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15431                                  ;		DirBuf is established DTA
 15432                                  ;
 15433                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15434                                  ;
 15435                                  ;		If failure,
 15436                                  ;		CY = set
 15437                                  ;		DOS Get Extended Error call will get error
 15438                                  ;
 15439                                  ;	USED	AX,CX,DX,SI,DI,BP
 15440                                  ;
 15441                                  ;	EFFECTS
 15442                                  ;
 15443                                  ;	  DirBuf is used for find first/next calls.
 15444                                  ;
 15445                                  ;	NOTES
 15446                                  ;
 15447                                  ;	  We keep on checking files until DOS returns an error. If
 15448                                  ;	  the error is 'no more files' and the temp filename is not
 15449                                  ;	  the initial high tag, copy the temp to the child's name spot
 15450                                  ;	  and return success. Otherwise, send the error back to caller.
 15451                                  ;
 15452                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15453                                  
 15454                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15455                                  FindNextChild:
 15456 00001577 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15457                                  	;shove	00FFh			; temp filename = high tag
 15458 0000157A B8FF00                  	mov	ax,0FFh
 15459 0000157D 50                      	push	ax
 15460 0000157E 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15461                                  	;shove	"*"	
 15462 00001580 B02A                    	mov	al,'*'  ; ax = 002Ah
 15463 00001582 50                      	push	ax
 15464                                  	;;shove	".*" 
 15465                                  	;mov	ax,"*."
 15466                                  	;mov	ax,2E2Ah
 15467 00001583 B42E                    	mov	ah,'.'
 15468 00001585 50                      	push	ax
 15469 00001586 E88005                  	call	GetDriveLtr		; AX = "d:"
 15470 00001589 50                      	push	ax
 15471 0000158A 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15472                                  
 15473                                  ;	See that the stack is restored properly at the end of this proc.
 15474                                  
 15475                                  	;mov	cx,10h
 15476 0000158C B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15477 0000158F B44E                    	mov	ah,4Eh
 15478                                  	;mov	ah,Find_First
 15479 00001591 CD21                    	int	21h			; DOS- Find First matching file
 15480 00001593 722C                    	jc	short fcRet		; return error
 15481                                  
 15482 00001595 E815FE                  	call	CheckChild		; check child against last, temp
 15483                                  fcNext:	
 15484                                  	;mov	cx,10h
 15485 00001598 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15486 0000159B B44F                    	mov	ah,4Fh
 15487                                  	;mov	ah,Find_Next
 15488 0000159D CD21                    	int	21h			; DOS- Find Next matching file
 15489 0000159F 7205                    	jc	short fcErr		; examine error
 15490                                  
 15491 000015A1 E809FE                  	call	CheckChild		; check child against last, temp
 15492 000015A4 EBF2                    	jmp	short fcNext		; go find another child
 15493                                  
 15494                                  fcErr:
 15495 000015A6 E8A50C                  	call	get_ext_error_number	; AX = extended error code
 15496                                  	;cmp	ax,18
 15497 000015A9 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15498 000015AC 7512                    	jne	short fcNope		; some other error- return it
 15499                                  
 15500                                  ;	We ran out of files. See if we qualified at least one.
 15501                                  
 15502 000015AE 807E00FF                	cmp	byte [bp],0FFh
 15503 000015B2 740C                    	je	short fcNope		; temp filename is unused- no child
 15504                                  
 15505                                  ;	Move temp filename to child name position.
 15506                                  
 15507 000015B4 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15508 000015B6 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15509                                  fcMove:
 15510 000015B8 AC                      	lodsb				; AL = next byte of filename
 15511 000015B9 AA                      	stosb				; store byte
 15512 000015BA 08C0                    	or	al,al
 15513 000015BC 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15514 000015BE EBF8                    	jmp	short fcMove		; go move another byte
 15515                                  fcNope:
 15516 000015C0 F9                      	stc				; return error
 15517                                  fcRet:
 15518 000015C1 9F                      	lahf
 15519 000015C2 83C414                  	add	sp,20			; restore stack
 15520 000015C5 9E                      	sahf
 15521 000015C6 C3                      	retn
 15522                                  
 15523                                  ; ---------------------------------------------------------------------------
 15524                                  
 15525                                  ;***	FindOneInMem - find the first available entry in TPA
 15526                                  ;***	FindNextInMem - find the next available entry in TPA
 15527                                  ;
 15528                                  ;	ENTRY	ES = TPA seg addr
 15529                                  ;		BX = ptr to entry in TPA
 15530                                  ;
 15531                                  ;	EXIT	BX = ptr to entry found
 15532                                  ;		CY = set if no more entries available in TPA
 15533                                  ;
 15534                                  ;	USED	AL
 15535                                  
 15536                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15537                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15538                                  FindOneInMem:
 15539 000015C7 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15540 000015CA 3C01                    	cmp	al,1
 15541 000015CC 7406                    	je	short FindNextInMem	; entry has already been used
 15542 000015CE 3CFF                    	cmp	al,0FFh
 15543 000015D0 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15544                                  
 15545                                  ;	BX = ptr to entry that hasn't been output yet.
 15546                                  
 15547 000015D2 F8                      	clc				; return success
 15548 000015D3 C3                      	retn
 15549                                  
 15550                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15551                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:163Ah
 15552                                  FindNextInMem:
 15553                                  	; 07/06/2023
 15554                                  	;add	bx,21 ; MSDOS 5.0
 15555                                  	; 07/06/2023
 15556 000015D4 83C316                  	add	bx,22 ; MSDOS 6.0  ; size EntryStruc (22 = 21 + compratio)
 15557                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15558 000015D7 EBEE                    	jmp	short FindOneInMem	; go look at it
 15559                                  foNoMore:
 15560 000015D9 F9                      	stc				; ran out of entries, return failure
 15561 000015DA C3                      	retn
 15562                                  
 15563                                  ; ---------------------------------------------------------------------------
 15564                                  
 15565                                  ;***	GetEnvValue - get value of our environment variable
 15566                                  ;
 15567                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15568                                  ;
 15569                                  ;	EXIT	CY = set if environment variable not in environment
 15570                                  ;
 15571                                  ;		Otherwise:
 15572                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15573                                  ;
 15574                                  ;	USED	AX,BX,CX,DX,DI
 15575                                  ;		(We assume the (almost) worst, since we don't know about
 15576                                  ;		Find_Name_In_Environment.)
 15577                                  ;
 15578                                  ;	EFFECTS
 15579                                  ;
 15580                                  ;	  ScanBuf is loaded with value text
 15581                                  
 15582                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15583                                  GetEnvValue:
 15584 000015DB 06                      	push	es				; save ES
 15585                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15586 000015DC BE[CE94]                	mov	si,DirEnvVar	; "DIRCMD="
 15587                                  	;invoke	Find_Name_In_Environment
 15588 000015DF E87E12                  	call	find_name_in_environment
 15589 000015E2 7214                    	jc	short geRet			; name not found in environment
 15590                                  
 15591                                  ;	ES:DI = ptr to value of environment variable
 15592                                  ;	We're assuming DS, CS, and SS are unchanged.
 15593                                  
 15594 000015E4 1E                      	push	ds
 15595 000015E5 06                      	push	es
 15596 000015E6 1F                      	pop	ds
 15597 000015E7 07                      	pop	es
 15598                                  
 15599                                  	;assume	ds:nothing
 15600                                  
 15601                                  ;	DS = seg addr of environment variable value (in environment segment)
 15602                                  ;	ES = TRANGROUP seg addr
 15603                                  
 15604 000015E8 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15605                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15606 000015EA BF[E1A1]                	mov	di,ScanBuf
 15607                                  geLoop:
 15608                                  ;@@:	
 15609 000015ED AC                      	lodsb
 15610 000015EE 08C0                    	or	al,al
 15611 000015F0 AA                      	stosb
 15612                                  	;loopnz	@B		; move the string, including trailing null
 15613 000015F1 E0FA                    	loopnz	geLoop
 15614                                  
 15615 000015F3 06                      	push	es
 15616 000015F4 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15617                                  	;assume	ds:TRANGROUP
 15618                                  
 15619                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15620 000015F5 BE[E1A1]                	mov	si,ScanBuf
 15621                                  geRet:
 15622 000015F8 07                      	pop	es				; restore ES
 15623 000015F9 C3                      	retn
 15624                                  
 15625                                  ; ---------------------------------------------------------------------------
 15626                                  
 15627                                  ;***	GetFirst - get first directory entry from disk
 15628                                  ;
 15629                                  ;	ENTRY	DOS DTA established at DirBuf
 15630                                  ;		FCB contains drive # and filename
 15631                                  ;		Current directory (on selected drive) is the one to search
 15632                                  ;		AttrSpecified & AttrSelect masks set
 15633                                  ;
 15634                                  ;	EXIT	CY = clear if success
 15635                                  ;		DirBuf contains extended FCB for file found
 15636                                  ;
 15637                                  ;		If unsuccessful,
 15638                                  ;		CY = set
 15639                                  ;		Ready for DOS Get Extended Error call
 15640                                  ;
 15641                                  ;	USED	AX,DX
 15642                                  ;
 15643                                  ;	EFFECTS
 15644                                  ;
 15645                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15646                                  ;	  FCB-1 = attribute mask to find all files
 15647                                  ;	  These fields should remain unmodified for GetNext calls.
 15648                                  ;
 15649                                  ;***	GetNext - get next directory entry from disk
 15650                                  ;
 15651                                  ;	ENTRY	As for GetFirst, plus
 15652                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15653                                  ;
 15654                                  ;	EXIT	As for GetFirst
 15655                                  ;
 15656                                  ;	USED	AX,DX
 15657                                  
 15658                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15659                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15660                                  
 15661                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15662                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1660h
 15663                                  GetFirst:
 15664                                  	;mov	byte [55h],0FFh	; -1
 15665 000015FA C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15666                                  	;mov	byte [5Bh],16h
 15667 000015FF C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15668                                  					; find any file
 15669                                  	; 07/06/2023
 15670                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15671 00001604 B411                    	mov	ah,11h
 15672                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15673                                  	; 07/06/2023
 15674                                  	;int	21h			; call DOS
 15675                                  	;shl	al,1			; CY = set if error
 15676                                  	;jc	short gfRet		; return error
 15677                                  	;jmp	short gfFound		; go look at attr's
 15678                                  	; 07/06/2023
 15679 00001606 EB02                    	jmp	short GetFrstNxt
 15680                                  GetNext:
 15681                                  	; 07/06/2023
 15682                                  	;;mov	dx,55h
 15683                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15684 00001608 B412                    	mov	ah,12h
 15685                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15686                                  GetFrstNxt:
 15687                                  	; 07/06/2023
 15688 0000160A BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15689                                  	;
 15690 0000160D CD21                    	int	21h			; call DOS
 15691 0000160F D0E0                    	shl	al,1			; CY = set if error
 15692 00001611 7211                    	jc	short gfRet		; return error
 15693                                  
 15694                                  ;*	Found an entry. Check attributes.
 15695                                  gfFound:
 15696                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15697                                  	;mov	al,[DIRBUF+19]
 15698 00001613 A0[32A0]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15699 00001616 8A26[79A0]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15700 0000161A 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15701 0000161C 2226[7AA0]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15702 00001620 38E0                    	cmp	al,ah
 15703 00001622 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15704                                  gfRet:
 15705 00001624 C3                      	retn
 15706                                  
 15707                                  ; ---------------------------------------------------------------------------
 15708                                  
 15709                                  ;***	ListDir - search for and list files in the current directory
 15710                                  ;
 15711                                  ;	List header, files, and trailer for current directory on selected
 15712                                  ;	drive. Header & trailer are listed if at least one file is found.
 15713                                  ;	If no qualifying files are found, no display output occurs.
 15714                                  ;
 15715                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15716                                  ;		FCB contains selected drive # and filename spec
 15717                                  ;		Option bits, attribute masks, and sort codes set up
 15718                                  ;
 15719                                  ;	EXIT	CY = clear if no error
 15720                                  ;		FileCnt = # files found & displayed
 15721                                  ;
 15722                                  ;		If error,
 15723                                  ;		CY = set
 15724                                  ;		Ready for DOS Get Extended Error call
 15725                                  ;
 15726                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15727                                  ;		FileSiz
 15728                                  ;
 15729                                  ;	EFFECTS
 15730                                  ;
 15731                                  ;	  FileCntTotal, FileSizTotal are updated.
 15732                                  ;	  Files found are listed. A directory header and trailer are
 15733                                  ;	   displayed only if files are found.
 15734                                  
 15735                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15736                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15737                                  
 15738                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 15739                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1694h
 15740                                  ListDir:
 15741 00001625 31C0                    	xor	ax,ax
 15742 00001627 A3[129E]                	mov	[FileCnt],ax		; zero file count
 15743 0000162A A3[149E]                	mov	[FileSiz],ax		; zero file size accumulator
 15744 0000162D A3[169E]                	mov	[FileSiz+2],ax
 15745                                  
 15746                                  	; 08/06/2023
 15747                                  	; MSDOS 6.0
 15748                                  ;ifdef DBLSPACE_HOOKS
 15749 00001630 A3[229E]                	mov	[ccluUsedDir],ax 	; zero count clusters used
 15750 00001633 A3[2A9E]                	mov	[csecUsedDir],ax	; zero count compressed sectors used
 15751 00001636 A3[2C9E]                	mov	[csecUsedDir+2],ax
 15752                                  ;endif	
 15753 00001639 803E[24A1]00            	cmp	byte [DestBuf],0	; check for sort code
 15754 0000163E 740A                    	je	short ld1		; no sort
 15755 00001640 E83000                  	call	LoadEntries		; load entries for sorted listing
 15756 00001643 7305                    	jnc	short ld1		; no error - continue
 15757 00001645 E8060C                  	call	get_ext_error_number	; AX = DOS error code
 15758                                  	; 19/02/2023
 15759                                  	;stc
 15760 00001648 EB12                    	jmp	short ldErr		; return error
 15761                                  ld1:
 15762 0000164A E8D6FE                  	call	FindFirst		; find first file
 15763 0000164D 720D                    	jc	short ldErr		; not found, return error
 15764                                  
 15765                                  ;	BX = offset in TPA buffer of entry found
 15766                                  
 15767 0000164F E82B03                  	call	DisplayHeader		; if at least one file, display header
 15768                                  ldNext:
 15769 00001652 E8F902                  	call	DisplayFile		; display the file entry
 15770                                  ;ldNext:
 15771 00001655 E8D0FE                  	call	FindNext		; find another file
 15772 00001658 7202                    	jc	short ldErr		; not found
 15773                                  	;call	DisplayFile		; display entry
 15774                                  	;jmp	short ldNext		; go find another one
 15775                                  	; 19/02/2023
 15776 0000165A EBF6                    	jmp	short ldNext
 15777                                  ldErr:
 15778                                  	;cmp	ax,2
 15779 0000165C 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15780 0000165F 7407                    	je	short ldDone		; file not found, we're done
 15781                                  	;cmp	ax,18
 15782 00001661 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15783 00001664 7402                    	je	short ldDone		; no more files, we're done
 15784 00001666 F9                      	stc
 15785                                  	;jmp	short ldRet
 15786                                  	; 19/02/2023
 15787 00001667 C3                      	retn
 15788                                  ldDone:
 15789 00001668 833E[129E]00            	cmp	word [FileCnt],0
 15790                                  	;je	short ld2		; no files found, just return
 15791                                  	; 25/04/2023
 15792 0000166D 7403                    	jz	short ldRet
 15793 0000166F E84704                  	call	DisplayTrailer		; display trailing info
 15794                                  	; 08/06/2023
 15795                                  	; cf=0
 15796                                  ;ld2:	
 15797                                  	;clc				; return success
 15798                                  ldRet:
 15799 00001672 C3                      	retn
 15800                                  
 15801                                  ; ---------------------------------------------------------------------------
 15802                                  
 15803                                  ;***	LoadEntries - attempt to load entries from current directory
 15804                                  ;
 15805                                  ;	Load all qualifying directory entries from the current directory
 15806                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15807                                  ;	other than 'no more files', return to caller with carry flag set.
 15808                                  ;	If we run out of buffer space, display a message that we haven't
 15809                                  ;	enough memory to sort this directory, but return without error.
 15810                                  ;	Other routines know whether or not entries have been loaded by
 15811                                  ;	the 'inmem' flag bit, which we set here.
 15812                                  ;
 15813                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15814                                  ;	this allows sorting over 3000 entries in a directory.
 15815                                  ;
 15816                                  ;	ENTRY	Tpa = buffer seg addr
 15817                                  ;		BytCnt = buffer length, in bytes
 15818                                  ;		Current directory (on selected drive) is the one to load
 15819                                  ;		FCB contains drive # and filespec
 15820                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15821                                  ;
 15822                                  ;	EXIT	CY = set if error
 15823                                  ;		If error, DOS Get Extended Error will get error info
 15824                                  ;
 15825                                  ;	USED	AX,CX,DX,SI,DI
 15826                                  ;
 15827                                  ;	EFFECTS
 15828                                  ;
 15829                                  ;	  Inmem bit of Bits = set if load succeeded.
 15830                                  ;	  Tpa buffer contains directory entries.
 15831                                  ;	  Byte after last entry = 0FFh.
 15832                                  
 15833                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15834                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 15835                                  LoadEntries:
 15836 00001673 06                      	push	es			; save TRANGROUP seg addr
 15837 00001674 8E06[E69D]              	mov	es,[TPA]		; ES = TPA seg addr
 15838 00001678 31FF                    	xor	di,di			; ES:DI = destination ptr
 15839                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15840                                  	; MSDOS 5.0
 15841                                  	;;and	word [_Bits],0FFDFh
 15842                                  	;and	byte [_Bits],0DFh	; not 20h
 15843                                  	; 08/06/2023
 15844                                  	;and	byte [_Bits],0BFh	; ~20h ; MSDOS 6.0
 15845 0000167A 8026[71A0]BF            	and	byte [_Bits],~mask.inmem ; 0BFh ; MSDOS 6.0
 15846                                  
 15847 0000167F E878FF                  	call	GetFirst		; look for first file
 15848 00001682 7221                    	jc	short leRet		; return any error
 15849 00001684 E82000                  	call	LoadEntry		; load entry into TPA
 15850                                  leNext:
 15851 00001687 E87EFF                  	call	GetNext			; get another file
 15852 0000168A 720F                    	jc	short leLoaded		; assume any error is no more files
 15853 0000168C A1[059E]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15854 0000168F 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15855                                  	; 08/06/2023
 15856                                  	;;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15857                                  	;cmp	ax,23 ; 21+2 ; MSDOS 5.0
 15858 00001691 83F818                  	cmp	ax,24 ; 22+2 ; MSDOS 6.0
 15859 00001694 720E                    	jb	short leOk		; not enough memory left, give up
 15860 00001696 E80E00                  	call	LoadEntry		; load entry into TPA
 15861 00001699 EBEC                    	jmp	short leNext		; go get another file
 15862                                  
 15863                                  leLoaded:
 15864 0000169B 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15865                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15866                                  	; MSDOS 5.0
 15867                                  	;;or	word [_Bits],20h
 15868                                  	;or	byte [_Bits],20h
 15869                                  	; 08/06/2023
 15870                                  	;or	byte [_Bits],40h	; MSDOS 6.0
 15871 0000169F 800E[71A0]40            	or	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0 
 15872                                  	; 25/04/2023
 15873                                  	; cf = 0
 15874                                  leOk:
 15875 000016A4 F8                      	clc				; return no error
 15876                                  leRet:
 15877 000016A5 07                      	pop	es			; ES = TRANGROUP seg addr again
 15878 000016A6 C3                      	retn
 15879                                  
 15880                                  ; ---------------------------------------------------------------------------
 15881                                  
 15882                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15883                                  ;
 15884                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15885                                  ;		DirBuf contains extended FCB of entry to load
 15886                                  ;
 15887                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15888                                  ;
 15889                                  ;	USED	AX,CX,SI
 15890                                  ;
 15891                                  ;	NOTES
 15892                                  ;
 15893                                  ;	  I could've used symbolic offsets and sizes of fields from
 15894                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15895                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15896                                  ;	   as well as our private directory entry structure.
 15897                                  ;
 15898                                  ;	  We force a zero size for subdirectory files. A zero size is
 15899                                  ;	   ordinarily returned for subdirectories, but with Novell
 15900                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15901                                  
 15902                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15903                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15904                                  	
 15905                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15906                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:171Ch
 15907                                  LoadEntry:
 15908                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15909 000016A7 BE[27A0]                	mov	si,DIRBUF+8
 15910 000016AA 30C0                    	xor	al,al				; AL = 0
 15911 000016AC AA                      	stosb					; 'used' byte = false
 15912 000016AD B90B00                  	mov	cx,11
 15913 000016B0 F3A4                    	rep	movsb				; transfer filename & extension
 15914 000016B2 AC                      	lodsb					; AL = attrib byte
 15915 000016B3 AA                      	stosb					; store attrib byte
 15916                                  	;add	si,10 ; 22-11-1
 15917                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15918 000016B4 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15919 000016B7 A5                      	movsw					; transfer time
 15920 000016B8 A5                      	movsw					; transfer date
 15921                                  
 15922                                  ; 08/06/2023
 15923                                  ; MSDOS 5.0
 15924                                  %if 0
 15925                                  	inc	si				; skip alloc unit
 15926                                  	inc	si
 15927                                  	;and	al,10h
 15928                                  	and	al,ATTR_DIRECTORY
 15929                                  	jnz	short leSetDirSize		; force zero size for subdir
 15930                                  	movsw
 15931                                  	movsw					; transfer size
 15932                                  	retn
 15933                                  leSetDirSize:
 15934                                  	xor	ax,ax ; 0
 15935                                  	stosw
 15936                                  	stosw					; store zero size
 15937                                  	retn
 15938                                  %endif
 15939                                  
 15940                                  ; 08/06/2023
 15941                                  ; MSDOS 6.0
 15942                                  %if 1
 15943                                  ;ifdef DBLSPACE_HOOKS
 15944 000016B9 88C1                    	mov	cl,al				; attrib to cl
 15945 000016BB AD                      	lodsw					; allocation unit (cluster
 15946                                  	;and	cl,10h
 15947 000016BC 80E110                  	and	cl,ATTR_DIRECTORY
 15948 000016BF 751E                    	jnz	short leSetDirSize		; force zero size for subdir
 15949 000016C1 A5                      	movsw
 15950 000016C2 A5                      	movsw					; transfer size
 15951                                  	
 15952                                  	;;test	word [_Bits],1
 15953                                  	;test	word [_Bits],mask.cratio	; compression ratio report?
 15954 000016C3 F606[71A0]01            	test	byte [_Bits],mask.cratio
 15955 000016C8 7504                    	jnz	short leCalcRatio		; yup
 15956                                  
 15957 000016CA 31C0                    	xor	ax,ax
 15958 000016CC AA                      	stosb					; dummy compression ratio
 15959 000016CD C3                      	retn
 15960                                  leCalcRatio:
 15961 000016CE E83306                  	call	CalcCompRatio			; takes cluster in AX
 15962 000016D1 09C0                    	or	ax,ax				;   returns ratio in AX
 15963 000016D3 740E                    	jz	short leNoRatio			; 0 means couldn't calculate
 15964 000016D5 FECC                    	dec	ah				; pack 1.0 - 16.0 comp ratio
 15965 000016D7 B104                    	mov	cl,4				;   into 2 nibbles.  Store
 15966 000016D9 D2E4                    	shl	ah,cl				;   1-16 as 0-15 in hi nibble,
 15967 000016DB 08E0                    	or	al,ah				;   tenths (0-9) in low nibble
 15968 000016DD AA                      	stosb
 15969 000016DE C3                      	retn
 15970                                  leSetDirSize:
 15971 000016DF 31C0                    	xor	ax,ax ; 0
 15972 000016E1 AB                      	stosw
 15973 000016E2 AB                      	stosw					; store zero size
 15974                                  leNoRatio:
 15975 000016E3 FEC8                    	dec	al				; al = FFh = special invalid
 15976 000016E5 AA                      	stosb					; compression ratio
 15977 000016E6 C3                      	retn
 15978                                  ;endif
 15979                                  %endif
 15980                                  
 15981                                  ; ---------------------------------------------------------------------------
 15982                                  
 15983                                  ;***	NoOrder - turn sorting off
 15984                                  ;
 15985                                  ;	ENTRY	nothing
 15986                                  ;
 15987                                  ;	EXIT	CY clear
 15988                                  ;
 15989                                  ;	USED	AX
 15990                                  ;
 15991                                  ;	EFFECTS
 15992                                  ;
 15993                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15994                                  
 15995                                  	; 19/02/2023
 15996                                  NoOrder:
 15997 000016E7 C606[24A1]00            	mov	byte [DestBuf],0
 15998                                  				; no sort
 15999 000016EC F8                      	clc			; no error
 16000 000016ED C3                      	retn
 16001                                  
 16002                                  ; ---------------------------------------------------------------------------
 16003                                  
 16004                                  ;***	OnOffSw - record occurence of on/off option switch
 16005                                  ;
 16006                                  ;	ENTRY	DI = index into word list of switches
 16007                                  ;
 16008                                  ;	EXIT	CY clear
 16009                                  ;
 16010                                  ;	USED	AX,CX
 16011                                  ;
 16012                                  ;	EFFECTS
 16013                                  ;
 16014                                  ;	  Bits modified to indicate option state.
 16015                                  
 16016                                  	; 19/02/2023
 16017                                  OnOffSw:
 16018 000016EE 89F9                    	mov	cx,di		; CX = index into word list of options
 16019 000016F0 D1E9                    	shr	cx,1
 16020 000016F2 D1E9                    	shr	cx,1		; CX = bit position of option
 16021 000016F4 B80100                  	mov	ax,1		
 16022 000016F7 D3E0                    	shl	ax,cl		; AX = bit mask of option
 16023 000016F9 F7C70200                	test	di,2		; check if it is a negated option
 16024 000016FD 7405                    	jz	short oo1	; it's negated
 16025                                  	;or	Bits,ax		; turn option on
 16026 000016FF 0906[71A0]              	or	[_Bits],ax
 16027                                  	;jmp	short ooRet
 16028                                  	; 19/02/2023
 16029                                  	;cf=0
 16030 00001703 C3                      	retn
 16031                                  oo1:	
 16032 00001704 F7D0                    	not	ax		; AX = complemented bit mask of option
 16033                                  	;and	Bits,ax		; turn option off
 16034 00001706 2106[71A0]              	and	[_Bits],ax
 16035                                  ooRet:
 16036                                  	; 19/02/2023
 16037                                  	;cf=0
 16038                                  	;clc			; always return success
 16039 0000170A C3                      	retn
 16040                                  
 16041                                  ; ---------------------------------------------------------------------------
 16042                                  
 16043                                  ;***	ParseAttr - parse and record /A option
 16044                                  ;
 16045                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 16046                                  ;
 16047                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 16048                                  ;
 16049                                  ;		For parse error, we set up for Std_EPrintf call:
 16050                                  ;		AX = parse error code, like system parser
 16051                                  ;		DX = ptr to message block
 16052                                  ;
 16053                                  ;	USED	AX,CX,DX,DI
 16054                                  ;
 16055                                  ;	EFFECTS
 16056                                  ;
 16057                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 16058                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 16059                                  ;
 16060                                  ;	  For parse error, we set up for Std_EPrintf call:
 16061                                  ;	  Msg_Disp_Class = parse error message class
 16062                                  ;	  Message block (see DX) is set up for parse error message
 16063                                  
 16064                                  	; 19/02/2023
 16065                                  ParseAttr:
 16066 0000170B 56                      	push	si			; save SI
 16067 0000170C C606[79A0]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 16068                                  
 16069                                  ;	Each /A invocation starts by assuming all files are to be listed.
 16070                                  
 16071                                  	;;mov	si,word ptr [bx].ValuePtr
 16072                                  					; SI = ptr to string after /A
 16073                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16074 00001711 8B7704                  	mov	si,[bx+4]
 16075                                  paLoop:	
 16076 00001714 BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 16077 00001717 AC                      	lodsb				; AL = next char in string
 16078 00001718 08C0                    	or	al,al
 16079                                  	;jz	short paOk		; it's terminating null, we're done
 16080                                  	; 19/02/2023
 16081 0000171A 742F                    	jz	short paRet ; cf=0
 16082 0000171C 3C2D                    	cmp	al,'-'
 16083 0000171E 7502                    	jne	short pa1		; not '-', go look for letter
 16084 00001720 4A                      	dec	dx			; DX = 0 (for negated attribute)
 16085 00001721 AC                      	lodsb				; AL = next char
 16086                                  pa1:	
 16087                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 16088                                  					; DI = ptr to attrib letter list
 16089 00001722 BF[9A97]                	mov	di,AttrLtrs ; "RHSvDA"
 16090                                  	;mov	cx,6
 16091 00001725 B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 16092 00001728 F2AE                    	repne	scasb			; look for our letter in the list
 16093 0000172A 751B                    	jne	short paErr		; not found, return error
 16094                                  
 16095 0000172C F7D1                    	not	cx
 16096                                  	;add	cx,6
 16097 0000172E 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 16098                                  
 16099                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 16100                                  ;	starting from bit 0.
 16101                                  
 16102                                  ;	Record this attribute bit in AttrSpecified.
 16103                                  
 16104 00001731 B001                    	mov	al,1
 16105 00001733 D2E0                    	shl	al,cl			; AL = mask for our bit
 16106 00001735 0806[79A0]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 16107                                  
 16108                                  ;	Record the selected state for this attribute in AttrSelect.
 16109                                  ;	DX = 0 or 1, the selected state for this attribute.
 16110                                  
 16111 00001739 F6D0                    	not	al			; AL = mask for all other bits
 16112 0000173B 2006[7AA0]              	and	[AttrSelect],al		; clear our bit
 16113 0000173F D2E2                    	shl	dl,cl			; DL = our bit state in position
 16114 00001741 0816[7AA0]              	or	[AttrSelect],dl		; set selected attr state
 16115 00001745 EBCD                    	jmp	short paLoop		; go look at next char
 16116                                  
 16117                                  ;	The attribute letter string is invalid.
 16118                                  
 16119                                  paErr:	
 16120 00001747 E8D003                  	call	SetupParamError		; set message up for Std_EPrintf
 16121 0000174A F9                      	stc		   		; return error
 16122                                  	; 19/02/2023
 16123                                  	;jmp	short paRet
 16124                                  ;paOk:
 16125                                  	;clc				; return success		
 16126                                  paRet:	
 16127 0000174B 5E                      	pop	si			; restore SI
 16128 0000174C C3                      	retn
 16129                                  
 16130                                  ; ---------------------------------------------------------------------------
 16131                                  
 16132                                  ;***	ParseLine - parse a line of text
 16133                                  ;
 16134                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 16135                                  ;	error occurs.
 16136                                  ;
 16137                                  ;	ENTRY	DS:SI = ptr to text
 16138                                  ;		CS, DS, ES = TRANGROUP seg addr
 16139                                  ;
 16140                                  ;	EXIT	AX = last return code from system parser
 16141                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 16142                                  ;
 16143                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16144                                  ;		DX = ptr to message block
 16145                                  ;
 16146                                  ;	USED	BX,CX,DX,SI,DI
 16147                                  ;
 16148                                  ;	EFFECTS
 16149                                  ;
 16150                                  ;	  Bits may contain new option settings.
 16151                                  ;	  DestBuf may contain new series of sort codes.
 16152                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16153                                  ;	  SrcBuf may contain a new default pathname/filespec.
 16154                                  ;	  PathPos, PathCnt updated for new pathname.
 16155                                  ;
 16156                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16157                                  ;	  Msg_Disp_Class = parse error class
 16158                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16159                                  ;	  Message block (see DX) is set up for parse error message
 16160                                  
 16161                                  	; 19/02/2023
 16162                                  Parse_Line:
 16163                                  	; 04/05/2023
 16164 0000174D BF[6898]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 16165 00001750 31C9                    	xor	cx,cx			; CX = # positionals found
 16166                                  plPars:
 16167 00001752 E8AF0F                  	call	Parse_With_Msg		; call parser
 16168 00001755 83F8FF                  	cmp	ax,-1
 16169                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 16170 00001758 7411                    	je	short plRet		; EOL encountered, return
 16171 0000175A 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 16172 0000175D 750C                    	jne	short plRet		; parse error occurred, return
 16173                                  
 16174                                  ;	Parse call succeeded. We have a filespec or a switch.
 16175                                  ;	DX = ptr to result buffer
 16176                                  
 16177 0000175F 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 16178 00001761 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 16179 00001764 7406                    	je	short plFil		; we have a filespec
 16180                                  
 16181 00001766 E87500                  	call	ParseSwitch		; else we have a switch
 16182                                  	;jc	short plRet		; error parsing switch, return
 16183                                  	;jmp	short plPars		; parse more
 16184                                  	; 19/02/2023
 16185 00001769 73E7                    	jnc	short plPars
 16186                                  plRet:
 16187 0000176B C3                      	retn	
 16188                                  plFil:	
 16189 0000176C E8D200                  	call	CopyPathname		; copy pathname into our buffer
 16190 0000176F EBE1                    	jmp	short plPars		; parse more
 16191                                  ;plRet:
 16192                                  ;	retn
 16193                                  
 16194                                  ; ---------------------------------------------------------------------------
 16195                                  
 16196                                  ;***	ParseOrder - parse and record /O option
 16197                                  ;
 16198                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 16199                                  ;
 16200                                  ;	EXIT	CY = set if error occurs parsing order
 16201                                  ;
 16202                                  ;		For parse error, we set up for Std_EPrintf call:
 16203                                  ;		AX = parse error code, like system parser
 16204                                  ;		DX = ptr to message block
 16205                                  ;
 16206                                  ;	USED	AX,CX,DX,DI
 16207                                  ;
 16208                                  ;	EFFECTS
 16209                                  ;
 16210                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 16211                                  ;
 16212                                  ;	  For parse error, we set up for Std_EPrintf call:
 16213                                  ;	  Msg_Disp_Class = parse error message class
 16214                                  ;	  Message block (see DX) is set up for parse error message
 16215                                  
 16216                                  	; 19/02/2023 - Retro DOS v4.0 COMMAND.COM
 16217                                  	;
 16218                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16219                                  	; MSDOS 6.22 COMMAND.COM
 16220                                  ParseOrder:
 16221 00001771 56                      	push	si			; save SI
 16222 00001772 53                      	push	bx			; save ptr to result buffer
 16223                                  
 16224                                  	;;mov	si,word ptr [bx].ValuePtr
 16225                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16226 00001773 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 16227                                  	;mov	bx,offset TRANGROUP:DestBuf
 16228                                  	; 08/06/2023
 16229 00001776 BB[24A1]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 16230 00001779 8A04                    	mov	al,[si]			; AL = 1st char of order string
 16231 0000177B 08C0                    	or	al,al
 16232 0000177D 750E                    	jnz	short poLtr		; not NUL, go parse letters
 16233                                  
 16234                                  ;	We have /O alone. Set standard sort order.
 16235                                  ;	Note hardwired dependency on character order in OrderLtrs.
 16236                                  
 16237 0000177F C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 16238 00001782 43                      	inc	bx
 16239 00001783 C60701                  	mov	byte [bx],1		; then by name
 16240 00001786 43                      	inc	bx
 16241 00001787 C60702                  	mov	byte [bx],2		; then by extension
 16242 0000178A 43                      	inc	bx
 16243 0000178B EB2F                    	jmp	short poOk		; return success
 16244                                  
 16245                                  ;	We have /O<something>. Parse sort order letters.
 16246                                  
 16247                                  poLtr:	
 16248 0000178D 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 16249 0000178F AC                      	lodsb				; AL = next sort order letter
 16250 00001790 08C0                    	or	al,al
 16251 00001792 7428                    	jz	short poOk		; NUL found, return success
 16252                                  
 16253 00001794 3C2D                    	cmp	al,'-'
 16254 00001796 7503                    	jne	short po1		; not '-', go look for letter
 16255 00001798 B280                    	mov	dl,80h			; DL = downward sort mask
 16256 0000179A AC                      	lodsb				; AL = next char
 16257                                  po1:
 16258                                  	;mov	di,offset TRANGROUP:OrderLtrs
 16259                                  	; 08/06/2023
 16260 0000179B BF[A097]                	mov	di,OrderLtrs ;"NEDSGC"	; DI = ptr to list of letters
 16261                                  	; (NUM_ORDER_LTRS = 6 for MSDOS 6.22 COMMAND.COM)
 16262                                  	; ((N,E,D,S,G for MSDOS 5.0 and N,E,D,S,G,C for MSDOS 6.22)) 
 16263                                  	;mov	cx,6 ; 08/06/2023
 16264 0000179E B90600                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 16265 000017A1 F2AE                    	repne	scasb			; look for our letter in the list
 16266 000017A3 7510                    	jne	short poErr		; not found, return error
 16267                                  
 16268 000017A5 F7D9                    	neg	cx
 16269                                  	;add	cx,6 ; 08/06/2023
 16270 000017A7 83C106                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 16271                                  
 16272 000017AA 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 16273 000017AC 880F                    	mov	[bx],cl			; store sort order code in buffer
 16274 000017AE 43                      	inc	bx			; BX = ptr to next spot in buffer
 16275                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 16276 000017AF 81FB[7BA1]              	cmp	bx,EndDestBuf
 16277                                  	;jae	short poErr		; too many letters
 16278                                  	;
 16279                                  	;jmp	short poLtr		; go look at next char
 16280                                  	; 19/02/2023
 16281 000017B3 72D8                    	jb	short poLtr
 16282                                  
 16283                                  ;	The sort order string is invalid.  
 16284                                  
 16285                                  poErr:
 16286 000017B5 5B                      	pop	bx			; BX = ptr to result buffer
 16287 000017B6 E86103                  	call	SetupParamError		; set message up for Std_EPrintf
 16288 000017B9 F9                      	stc				; return failure
 16289 000017BA EB04                    	jmp	short poRet
 16290                                  poOk:	
 16291 000017BC C60700                  	mov	byte [bx],0		; mark end of sort code list
 16292 000017BF 5B                      	pop	bx			; BX = ptr to result buffer
 16293                                  	; 19/02/2023
 16294                                  	;cf=0
 16295                                  	;clc				; return success
 16296                                  poRet:
 16297 000017C0 5E                      	pop	si			; restore SI
 16298 000017C1 C3                      	retn
 16299                                  
 16300                                  ; ---------------------------------------------------------------------------
 16301                                  ; MSDOS 6.0
 16302                                  	; 08/06/2023
 16303                                  
 16304                                  ;ifdef DBLSPACE_HOOKS
 16305                                  
 16306                                  ;***	ParseRatio - parse and record /C[H] option
 16307                                  ;
 16308                                  ;	ENTRY	BX = ptr to system parser result buffer for /C occurence
 16309                                  ;		DI = index into word list of switches
 16310                                  ;
 16311                                  ;	EXIT	CY = set if error occurs parsing order
 16312                                  ;
 16313                                  ;		For parse error, we set up for Std_EPrintf call:
 16314                                  ;		AX = parse error code, like system parser
 16315                                  ;		DX = ptr to message block
 16316                                  ;
 16317                                  ;	USED	AX,CX,DX,DI
 16318                                  ;
 16319                                  ;	EFFECTS
 16320                                  ;
 16321                                  ;	  Bits modified to indicate option state.
 16322                                  ;	  fUseHostSize is set to zero for /C, non-zero for /CH.
 16323                                  ;
 16324                                  ;	  For parse error, we set up for Std_EPrintf call:
 16325                                  ;	  Msg_Disp_Class = parse error message class
 16326                                  ;	  Message block (see DX) is set up for parse error message
 16327                                  
 16328                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16329                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:184Ch
 16330                                  
 16331                                  ParseRatio:	;proc
 16332 000017C2 E829FF                  	call	OnOffSw			; turn on option bit
 16333 000017C5 56                      	push	si			; save SI
 16334                                  	;;mov	si,word ptr [bx].ValuePtr
 16335                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16336 000017C6 8B7704                  	mov	si,[bx+4]		; SI = ptr to possible H option
 16337 000017C9 8A04                    	mov	al,[si] 		; AL = null or 'H'
 16338 000017CB 08C0                    	or	al,al
 16339 000017CD 740A                    	jz	short prDone		; if null, no H option to check
 16340 000017CF 3C48                    	cmp	al,'H' 			; only H is allowed, make sure that's
 16341 000017D1 7406                    	je	short prDone		;   what it is
 16342 000017D3 E84403                  	call	SetupParamError		; set message up for Std_EPrintf
 16343 000017D6 F9                      	stc				; return failure
 16344 000017D7 EB03                    	jmp	short prRet
 16345                                  prDone:
 16346 000017D9 A2[859E]                	mov	[fUseHostSize],al	; set Host cluster size flag
 16347                                  	; 08/06/2023
 16348                                  	;clc
 16349                                  	;;cf = 0
 16350                                  prRet:	
 16351 000017DC 5E                      	pop	si
 16352 000017DD C3                      	retn
 16353                                  
 16354                                  ;ParseRatio	;endp
 16355                                  ;endif
 16356                                  
 16357                                  ; ---------------------------------------------------------------------------
 16358                                  
 16359                                  ;***	ParseSwitch - parse a switch
 16360                                  ;
 16361                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16362                                  ;		     a switch
 16363                                  ;
 16364                                  ;	EXIT	CY = set if parse error occurred
 16365                                  ;
 16366                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16367                                  ;		AX = parse error code, like system parser
 16368                                  ;		DX = ptr to message block
 16369                                  ;
 16370                                  ;	USED	AX,BX,DX
 16371                                  ;
 16372                                  ;	EFFECTS
 16373                                  ;
 16374                                  ;	  Bits may contain new option settings.
 16375                                  ;	  DestBuf may contain new series of sort codes.
 16376                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16377                                  ;
 16378                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16379                                  ;	  Msg_Disp_Class = parse error class
 16380                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16381                                  ;	  Message block (see DX) is set up for parse error message
 16382                                  
 16383                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16384                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 16385                                  
 16386                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16387                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1869h
 16388                                  ParseSwitch:
 16389 000017DE 51                      	push	cx			; save CX
 16390 000017DF 57                      	push	di			; save DI
 16391                                  
 16392                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 16393                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 16394 000017E0 8B4702                  	mov	ax,[bx+2]
 16395                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16396 000017E3 BF[BF98]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16397                                  	; 08/06/2023
 16398                                  	; (NUM_DIR_SWS = 16 for MSDOS 6.0)
 16399                                  	;mov	cx,16
 16400 000017E6 B91000                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16401 000017E9 FC                      	cld				; scan direction = upward
 16402 000017EA F2AF                    	repne	scasw			; locate synonym ptr in list
 16403                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16404 000017EC 81EF[C198]              	sub	di,Dir_Sw_Ptrs+2
 16405                                  
 16406                                  ;	DI = index into word list of synonym ptrs
 16407                                  
 16408 000017F0 2EFF95[F817]            	call	word [cs:di+SwHandler]	; use same index into call table
 16409                                  
 16410 000017F5 5F                      	pop	di			; restore DI
 16411 000017F6 59                      	pop	cx			; restore CX
 16412                                  
 16413 000017F7 C3                      	retn
 16414                                  
 16415                                  ; ---------------------------------------------------------------------------
 16416                                  
 16417                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16418                                  ;	Simple on/off switches must occur first in both lists, and must be
 16419                                  ;	  in order of option bits in Bits, starting with bit 0.
 16420                                  
 16421                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16422                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16423                                  
 16424                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16425                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1883h
 16426                                  SwHandler:
 16427                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 16428                                  		; ifdef DBLSPACE_HOOKS
 16429 000017F8 [EE16]                  	dw	OnOffSw 	; /-C
 16430 000017FA [C217]                  	dw	ParseRatio	; /C[H]
 16431                                  	;	; endif	
 16432 000017FC [EE16]                  	dw	OnOffSw		; /-W
 16433 000017FE [EE16]                  	dw	OnOffSw		; /W
 16434 00001800 [EE16]                  	dw	OnOffSw		; /-P
 16435 00001802 [EE16]                  	dw	OnOffSw		; /P
 16436 00001804 [EE16]                  	dw	OnOffSw		; /-S
 16437 00001806 [EE16]                  	dw	OnOffSw		; /S
 16438 00001808 [EE16]                  	dw	OnOffSw		; /-B
 16439 0000180A [EE16]                  	dw	OnOffSw		; /B
 16440 0000180C [EE16]                  	dw	OnOffSw		; /-L	;M010
 16441 0000180E [EE16]                  	dw	OnOffSw		; /L	;M010
 16442 00001810 [E716]                  	dw	NoOrder		; /-O
 16443 00001812 [7117]                  	dw	ParseOrder	; /O
 16444 00001814 [8714]                  	dw	DefaultAttr	; /-A
 16445 00001816 [0B17]                  	dw	ParseAttr	; /A
 16446                                  
 16447                                  ; ---------------------------------------------------------------------------
 16448                                  
 16449                                  	;break	<DIR utility routines>
 16450                                  
 16451                                  ;***	UTILITY ROUTINES
 16452                                  ; ---------------------- 
 16453                                  
 16454                                  ; ---------------------------------------------------------------------------
 16455                                  
 16456                                  ;***	ChangeDir - change directory on target drive
 16457                                  ;
 16458                                  ;	ENTRY	FCB contains drive #
 16459                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16460                                  ;
 16461                                  ;	EXIT	Changed current directory on drive
 16462                                  ;
 16463                                  ;		If error,
 16464                                  ;		CY = set
 16465                                  ;		DOS Get Extended Error call will get error
 16466                                  ;
 16467                                  ;	USED	AX,DX,SI,DI
 16468                                  ;
 16469                                  ;	EFFECTS
 16470                                  ;
 16471                                  ;	  DirBuf is used to build "d:string".
 16472                                  
 16473                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16474                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16475                                  
 16476                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16477                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:18A3h
 16478                                  ChangeDir:
 16479                                  	;mov	di,offset TRANGROUP:DirBuf
 16480 00001818 BF[1FA0]                	mov	di,DIRBUF
 16481 0000181B E8EB02                  	call	GetDriveLtr	; AX = "d:"
 16482 0000181E AB                      	stosw			; put drive specifier in buffer
 16483 0000181F 89D6                    	mov	si,dx		; SI = ptr to argument string
 16484                                  cdLoop:
 16485 00001821 AC                      	lodsb
 16486 00001822 AA                      	stosb			; move byte to buffer
 16487 00001823 08C0                    	or	al,al
 16488 00001825 75FA                    	jne	short cdLoop	; continue until null transferred
 16489                                  
 16490                                  	;mov	dx,offset TRANGROUP:DirBuf
 16491 00001827 BA[1FA0]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16492                                  	;mov	ah,CHDir
 16493 0000182A B43B                    	mov	ah,3Bh
 16494 0000182C CD21                    	int	21h		; change directory
 16495 0000182E C3                      	retn			; return what CHDIR returns
 16496                                  
 16497                                  ; ---------------------------------------------------------------------------
 16498                                  
 16499                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16500                                  ;
 16501                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16502                                  ;		ES:DI = ptr to another ASCIIZ string
 16503                                  ;
 16504                                  ;	EXIT	flags set after REPE CMPSB
 16505                                  ;
 16506                                  ;	USED	AL,CX,SI,DI
 16507                                  ;
 16508                                  ;	NOTES
 16509                                  ;
 16510                                  ;	Maximum run of comparison is length of DS:SI string.
 16511                                  ;	This ensures that two identical strings followed by
 16512                                  ;	random characters will compare correctly.
 16513                                  
 16514                                  	; 19/02/2023
 16515                                  CmpAscz:
 16516                                  	; 07/06/2023
 16517 0000182F 56                      	push	si ; *
 16518                                  	;
 16519 00001830 57                      	push	di
 16520                                  
 16521 00001831 89F7                    	mov	di,si
 16522 00001833 30C0                    	xor	al,al
 16523 00001835 B9FFFF                  	mov	cx,0FFFFh
 16524 00001838 F2AE                    	repne	scasb
 16525 0000183A F7D1                    	not	cx
 16526                                  
 16527 0000183C 5F                      	pop	di
 16528 0000183D F3A6                    	repe	cmpsb
 16529                                  
 16530                                  	; 07/06/2023
 16531 0000183F 5E                      	pop	si ; *
 16532                                  	;
 16533 00001840 C3                      	retn
 16534                                  
 16535                                  ; ---------------------------------------------------------------------------
 16536                                  
 16537                                  ;***	CopyPathname - copy pathname to our buffer
 16538                                  ;
 16539                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16540                                  ;		     a filespec
 16541                                  ;
 16542                                  ;	EXIT	nothing
 16543                                  ;
 16544                                  ;	USED	AX
 16545                                  ;
 16546                                  ;	EFFECTS
 16547                                  ;
 16548                                  ;	  SrcBuf may contain a new pathname/filespec.
 16549                                  ;	  PathPos, PathCnt updated for new pathname.
 16550                                  
 16551                                  	; 19/02/2023
 16552                                  CopyPathname:
 16553 00001841 56                      	push	si
 16554                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16555                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16556 00001842 C57704                  	lds	si,[bx+4]
 16557                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16558 00001845 E8AA19                  	call	Move_To_SrcBuf
 16559 00001848 5E                      	pop	si
 16560 00001849 C3                      	retn
 16561                                  
 16562                                  ; ---------------------------------------------------------------------------
 16563                                  
 16564                                  ;***	CountFile - update counters with current file
 16565                                  ;
 16566                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16567                                  ;
 16568                                  ;	EXIT	nothing
 16569                                  ;
 16570                                  ;	USED	AX,DX
 16571                                  ;
 16572                                  ;	EFFECTS
 16573                                  ;
 16574                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16575                                  
 16576                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16577                                  CountFile:
 16578 0000184A 06                      	push	es			; save TRANGROUP seg addr
 16579 0000184B 8E06[E69D]              	mov	es,[TPA]		; ES = TPA seg addr
 16580                                  
 16581 0000184F FF06[129E]              	inc	word [FileCnt]		; # files this directory
 16582 00001853 FF06[189E]              	inc	word [FileCntTotal]	; # files total
 16583 00001857 7504                    	jnz	short cntf1
 16584 00001859 FF06[1A9E]              	inc	word [FileCntTotal+2]
 16585                                  cntf1:
 16586                                  	;mov	ax,word ptr es:[bx].filesize
 16587                                  					; AX = low word of file size
 16588                                  	;mov	dx,word ptr es:[bx].filesize+2
 16589                                  					; DX = high word of file size
 16590 0000185D 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16591 00001861 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16592 00001865 0106[149E]              	add	[FileSiz],ax
 16593 00001869 1116[169E]              	adc	[FileSiz+2],dx		; size of this directory
 16594 0000186D 0106[1C9E]              	add	[FileSizTotal],ax
 16595 00001871 1116[1E9E]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16596                                  
 16597 00001875 07                      	pop	es			; ES = TRANGROUP seg addr again
 16598                                  dbRet:	; 19/02/2023
 16599 00001876 C3                      	retn
 16600                                  
 16601                                  ; ---------------------------------------------------------------------------
 16602                                  
 16603                                  ;***	DisplayBare - display filename in bare format
 16604                                  ;
 16605                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16606                                  ;
 16607                                  ;	EXIT	DX = # char's displayed, including dot
 16608                                  ;
 16609                                  ;	USED	AX,CX,SI,DI
 16610                                  ;
 16611                                  ;	EFFECTS
 16612                                  ;
 16613                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16614                                  ;	  If /s is on, complete pathname is displayed.
 16615                                  ;
 16616                                  ;	NOTE
 16617                                  ;
 16618                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16619                                  
 16620                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16621                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16622                                  
 16623                                  
 16624                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16625                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1900h
 16626                                  
 16627                                  DisplayBare:
 16628                                  ;	Suppress . and .. files from bare listing.
 16629                                  
 16630 00001877 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16631 00001879 8E1E[E69D]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16632                                  	;assume	ds:NOTHING
 16633                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16634 0000187D 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16635 00001881 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16636                                  	;assume	ds:TRANGROUP
 16637 00001883 74F1                    	je	short dbRet		; it's . or .. - don't display
 16638                                  
 16639                                  	;;;test	Bits,mask subd
 16640                                  	;;test	word [_Bits],4
 16641                                  	;test	byte [_Bits],4
 16642                                  	; 08/06/2023
 16643 00001885 F606[71A0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 16644 0000188A 7431                    	jz	short dbNameExt		; not /s - display filename only
 16645                                  
 16646                                  	;invoke	Build_Dir_String
 16647 0000188C E8080B                  	call	build_dir_string
 16648                                  	;mov	di,offset TRANGROUP:BwdBuf
 16649 0000188F BF[1FA0]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16650                                     
 16651                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16652                                  	;;test	word [_Bits],10h
 16653                                  	;test	byte [_Bits],10h
 16654                                  	; 08/06/2023
 16655 00001892 F606[71A0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 16656                                  	;jz	@F			;M010;lowercase not needed
 16657 00001897 7405                    	jz	short dbare1
 16658 00001899 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16659 0000189B E8C202                  	call	LowercaseString		;M010;path string is in BwdBuf
 16660                                  dbare1:
 16661                                  ;@@:	
 16662                                  	;xor	al,al			; AL = 0
 16663                                  	; 19/02/2023
 16664 0000189E 31C0                    	xor	ax,ax
 16665 000018A0 B9FFFF                  	mov	cx,0FFFFh
 16666 000018A3 FC                      	cld
 16667 000018A4 F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16668 000018A6 4F                      	dec	di			; ES:DI = ptr to null byte
 16669                                  
 16670 000018A7 26807DFF5C              	cmp	byte [es:di-1],'\'
 16671                                  	;je	@F
 16672 000018AC 7403                    	je	short dbare2		; already terminated w/ '\'
 16673                                  
 16674                                  	;mov	ax,'\'			; AX = '\',0
 16675 000018AE B05C                    	mov	al,'\'
 16676 000018B0 AB                      	stosw				; add to dir string
 16677                                  ;@@:
 16678                                  dbare2:
 16679                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16680 000018B1 C706[06A1][1FA0]        	mov	word [string_ptr_2],BWDBUF
 16681                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16682 000018B7 BA[CA93]                	mov	dx,string_buf_ptr
 16683                                  	;invoke	Std_Printf		; display device & directory path
 16684 000018BA E8803C                  	call	std_printf
 16685                                  dbNameExt:
 16686 000018BD E82D00                  	call	DisplayDotForm		; display name.ext
 16687                                  	;invoke	CrLf2			; display cr/lf
 16688 000018C0 E85912                  	call	CRLF2
 16689                                  	; 19/02/2023
 16690                                  	;call	UseLine			;M007;Allow /p with /b
 16691                                  ;dbRet:
 16692                                  	;retn
 16693                                  
 16694                                  	; 19/02/2023
 16695                                  	;jmp	short UseLine
 16696                                  
 16697                                  ; ---------------------------------------------------------------------------
 16698                                  
 16699                                  ;***	UseLine - use a display line, start a new page if none left
 16700                                  ;
 16701                                  ;	ENTRY	nothing
 16702                                  ;
 16703                                  ;	EXIT	nothing
 16704                                  ;
 16705                                  ;	USED	flags
 16706                                  
 16707                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16708                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16709                                  UseLine:
 16710 000018C3 FF0E[109E]              	dec	word [LeftOnPage]
 16711 000018C7 833E[109E]02            	cmp	word [LeftOnPage],2
 16712 000018CC 771E                    	ja	short ulRet
 16713                                  	; 19/02/2023
 16714                                  	;call	EndPage
 16715                                  ;ulRet:
 16716                                  	;retn
 16717                                  
 16718                                  	; 19/02/2023
 16719                                  	;jmp	short EndPage
 16720                                  
 16721                                  ; ---------------------------------------------------------------------------
 16722                                  
 16723                                  ;***	EndPage - end the current display page
 16724                                  ;
 16725                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16726                                  ;		Current directory (on selected drive) is the one being listed
 16727                                  ;		Bits contains /p setting
 16728                                  ;
 16729                                  ;	EXIT	LeftOnPage = # lines left for next page
 16730                                  ;
 16731                                  ;	USED	AX,DX
 16732                                  ;
 16733                                  ;	EFFECTS
 16734                                  ;
 16735                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16736                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16737                                  
 16738                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16739                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16740                                  
 16741                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16742                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1BADh
 16743                                  EndPage:
 16744                                  	;;;test	Bits,mask pagd
 16745                                  	;;test	word [_Bits],2
 16746                                  	;test	byte [_Bits],2
 16747                                  	; 08/06/2023
 16748 000018CE F606[71A0]04            	test	byte [_Bits],mask.pagd ; 4 ; MSDOS 6.0
 16749 000018D3 7410                    	jz	short epNew		; paged display isn't enabled
 16750                                  
 16751 000018D5 53                      	push	bx			; save BX
 16752 000018D6 51                      	push	cx			; save CX
 16753                                  
 16754                                  	;invoke	Pause			; "Press any key to continue..."
 16755 000018D7 E83706                  	call	PAUSE
 16756                                  
 16757                                  	;invoke	Build_Dir_String
 16758 000018DA E8BA0A                  	call	build_dir_string
 16759                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16760 000018DD BA[4E94]                	mov	dx,dircont_ptr
 16761                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16762 000018E0 E84C3C                  	call	Printf_Crlf
 16763                                  
 16764 000018E3 59                      	pop	cx			; restore CX
 16765 000018E4 5B                      	pop	bx			; restore BX
 16766                                  epNew:	
 16767 000018E5 A1[7DA2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16768 000018E8 48                      	dec	ax			; AX = # lines till next EndPage
 16769 000018E9 A3[109E]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16770                                  ulRet:	
 16771                                  	; 19/02/2023
 16772 000018EC C3                      	retn
 16773                                  
 16774                                  ; ---------------------------------------------------------------------------
 16775                                  
 16776                                  ;***	DisplayDotForm - display filename in compressed dot format
 16777                                  ;
 16778                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16779                                  ;	if the filename has a nonblank extension.
 16780                                  ;
 16781                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16782                                  ;
 16783                                  ;	EXIT	DX = # char's displayed, including dot
 16784                                  ;
 16785                                  ;	USED	AX,CX,SI,DI
 16786                                  ;
 16787                                  ;	EFFECTS
 16788                                  ;
 16789                                  ;	  Filename is displayed in name.ext format.
 16790                                  ;
 16791                                  ;	NOTE
 16792                                  ;
 16793                                  ;	  We allow for bogus filenames that have blanks embedded
 16794                                  ;	  in the name or extension.
 16795                                  
 16796                                  ;	Bugbug:	might be a good performance gain if we buffered
 16797                                  ;	up the output and used DOS function 9.
 16798                                  
 16799                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16800                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16801                                  
 16802                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16803                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1953h
 16804                                  DisplayDotForm:
 16805 000018ED 1E                      	push	ds			; save TRANGROUP seg addr
 16806 000018EE 06                      	push	es			; save ES
 16807 000018EF 2EA1[E69D]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16808 000018F3 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16809                                  	;assume	ds:nothing
 16810 000018F5 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16811                                  
 16812                                  	; 08/06/2023
 16813                                  	;mov	di,bx			; ES:DI = ptr to entry
 16814                                  	;;;add	di,filename + size filename - 1
 16815                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16816                                  	;;mov	cx,size filename	; CX = length of name field
 16817                                  	;mov	cx,8
 16818                                  	; 08/06/2023
 16819 000018F7 B90800                  	mov	cx,8
 16820 000018FA 89CF                    	mov	di,cx
 16821 000018FC 01DF                    	add	di,bx	
 16822                                  
 16823 000018FE B020                    	mov	al,' '
 16824 00001900 FD                      	std				; scan down
 16825 00001901 F3AE                    	repe	scasb			; scan for nonblank
 16826                                  
 16827                                  ;	Assume file name has at least one character.
 16828                                  
 16829 00001903 41                      	inc	cx			; CX = # chars in name
 16830 00001904 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16831                                  
 16832 00001906 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16833                                  	;;add	si,filename		; DS:SI = ptr to name
 16834                                  	;add	si,1 
 16835                                  	;		; add si,EntryStruc.filename
 16836                                  	; 25/04/2023
 16837 00001908 46                      	inc	si
 16838                                  NextNameChar:
 16839 00001909 FC                      	cld
 16840 0000190A AC                      	lodsb				; AL = next char
 16841                                  
 16842                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16843                                  	;;test	word [ss:_Bits],10h
 16844                                  	;test	byte [ss:_Bits],10h
 16845                                  	; 08/06/2023
 16846 0000190B 36F606[71A0]20          	test	byte [ss:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 16847                                  	;jz	short @F		;M010;lowercase not required
 16848 00001911 7403                    	jz	short ddf1
 16849 00001913 E83F02                  	call	LowerCase		;M010;filename char is in AL
 16850                                  ddf1:
 16851                                  ;@@:	
 16852                                  	;invoke	Print_Char		; display it
 16853 00001916 E82F0A                  	call	PRINT_CHAR
 16854 00001919 E2EE                    	loop	NextNameChar
 16855                                  
 16856                                  ;	Now do extension.
 16857                                  
 16858 0000191B 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16859                                  	;add	di,fileext + size fileext - 1
 16860 0000191D 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16861                                  	;mov	cx,size fileext		; CX = length of ext field
 16862 00001920 B90300                  	mov	cx,3
 16863 00001923 B020                    	mov	al,' '
 16864 00001925 FD                      	std				; scan down
 16865 00001926 F3AE                    	repe	scasb			; scan for nonblank
 16866 00001928 7420                    	je	short ddDone		; no nonblank chars in ext
 16867                                  
 16868 0000192A 41                      	inc	cx			; CX = # chars in ext
 16869 0000192B 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16870 0000192D 42                      	inc	dx			;      including dot
 16871                                  
 16872 0000192E B02E                    	mov	al,'.'
 16873 00001930 E8150A                  	call	PRINT_CHAR
 16874 00001933 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16875                                  	;add	si,fileext		; DS:SI = ptr to ext
 16876 00001935 83C609                  	add	si,9
 16877                                  
 16878                                  NextExtChar:
 16879 00001938 FC                      	cld
 16880 00001939 AC                      	lodsb				; AL = next char
 16881                                  
 16882                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16883                                  	;;test	word [cs:_Bits],10h
 16884                                  	;test	byte [cs:_Bits],10h
 16885                                  	; 08/06/2023
 16886 0000193A 2EF606[71A0]20          	test	byte [cs:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 16887                                  	;jz	short @F		;M010;lowercase not required
 16888 00001940 7403                    	jz	short ddf2
 16889 00001942 E81002                  	call	LowerCase		;M010;fileext char is in AL
 16890                                  ;@@:	
 16891                                  ddf2:
 16892                                  	;invoke	Print_Char		; display it
 16893 00001945 E8000A                  	call	PRINT_CHAR
 16894 00001948 E2EE                    	loop	NextExtChar
 16895                                  ddDone:
 16896 0000194A 07                      	pop	es			; restore ES
 16897 0000194B 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16898                                  	;assume	ds:TRANGROUP
 16899 0000194C FC                      	cld				; leave direction flag = up
 16900 0000194D C3                      	retn
 16901                                  
 16902                                  ; ---------------------------------------------------------------------------
 16903                                  
 16904                                  ;***	DisplayFile - display file entry, update counters
 16905                                  ;
 16906                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16907                                  ;		Bits contains /w, /p settings
 16908                                  ;
 16909                                  ;	EXIT	nothing
 16910                                  ;
 16911                                  ;	USED	AX,CX,DX,SI,DI,BP
 16912                                  ;
 16913                                  ;	EFFECTS
 16914                                  ;
 16915                                  ;	  Entry is displayed.  
 16916                                  ;	  If not /b,
 16917                                  ;	    Cursor is left at end of entry on screen.
 16918                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16919                                  ;	  If /b,
 16920                                  ;	    Cursor is left at beginning of next line.
 16921                                  ;	    Cnt's and Siz's aren't updated.
 16922                                  
 16923                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16924                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16925                                  	
 16926                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16927                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:19B9h
 16928                                  
 16929                                  DisplayFile:
 16930                                  	;;;test	Bits,mask bare
 16931                                  	;;test	word [_Bits],8
 16932                                  	;test	byte [_Bits],8
 16933                                  	; 08/06/2023
 16934 0000194E F606[71A0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0 
 16935 00001953 7405                    	jz	short dfNorm		; not /b - do normal display
 16936                                  
 16937 00001955 E81FFF                  	call	DisplayBare		; display file in bare format
 16938 00001958 EB22                    	jmp	short dfRet
 16939                                  dfNorm:	
 16940 0000195A E88200                  	call	DisplayNext		; pos'n cursor for next entry
 16941                                  	;;;test	Bits,mask wide
 16942                                  	;;test	word [_Bits],1
 16943                                  	;test	byte [_Bits],1
 16944                                  	; 08/06/2023
 16945 0000195D F606[71A0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0 
 16946 00001962 7405                    	jz	short dfFull		; full format
 16947 00001964 E87401                  	call	DisplayWide		; wide format
 16948 00001967 EB10                    	jmp	short dfCnt
 16949                                  dfFull:	
 16950 00001969 E83E00                  	call	DisplayName		; display filename & extension
 16951 0000196C E89700                  	call	DisplayTheRest		; display size, date, time
 16952                                  	
 16953                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 16954                                  	; MSDOS 6.0
 16955                                  ;ifdef DBLSPACE_HOOKS
 16956                                  	;;test	Bits,mask cratio
 16957                                  	;test	word [_Bits],1		
 16958 0000196F F606[71A0]01            	test	byte [_Bits],mask.cratio 
 16959                                  					; display compression ratio
 16960 00001974 7403                    	jz	short dfCnt
 16961 00001976 E81A01                  	call	DisplayCompRatio
 16962                                  ;endif
 16963                                  
 16964                                  dfCnt:
 16965 00001979 E8CEFE                  	call	CountFile		; update file counters
 16966                                  dfRet:
 16967                                  dhRet:	; 19/02/2023
 16968 0000197C C3                      	retn
 16969                                  
 16970                                  ; ---------------------------------------------------------------------------
 16971                                  
 16972                                  ;***	DisplayHeader - display directory header of working directory
 16973                                  ;
 16974                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16975                                  ;		LeftOnPage = # lines left on display page
 16976                                  ;
 16977                                  ;	EXIT	nothing
 16978                                  ;
 16979                                  ;	ERROR EXIT
 16980                                  ;
 16981                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16982                                  ;	   specification" if there's a problem obtaining the current 
 16983                                  ;	   directory pathname.
 16984                                  ;
 16985                                  ;	USED	AX,DX,SI,DI
 16986                                  ;
 16987                                  ;	EFFECTS
 16988                                  ;
 16989                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16990                                  ;	   we are using for the DTA) contains the directory string.
 16991                                  ;	  LeftOnPage is adjusted.
 16992                                  
 16993                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16994                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16995                                  
 16996                                  DisplayHeader:
 16997                                  	;;;test	Bits,mask bare
 16998                                  	;;test	word [_Bits],8
 16999                                  	;test	byte [_Bits],8
 17000                                  	; 08/06/2023
 17001 0000197D F606[71A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17002 00001982 75F8                    	jnz	short dhRet		; /b - don't display header
 17003                                  
 17004                                  	;;;test	Bits,mask subd
 17005                                  	;;test	word [_Bits],4
 17006                                  	;test	byte [_Bits],4
 17007                                  	; 08/06/2023
 17008 00001984 F606[71A0]08            	test	byte [_Bits],mask.subd ; 8  ;MSDOS 6.0
 17009 00001989 7408                    	jz	short dhNorm		; not /s
 17010                                  
 17011                                  ;	For subdirectory listings, put a blank line before the header.
 17012                                  
 17013                                  	;invoke	Crlf2			; start with a blank line
 17014 0000198B E88E11                  	call	CRLF2
 17015 0000198E E832FF                  	call	UseLine
 17016 00001991 EB05                    	jmp	short dhCom
 17017                                  dhNorm:
 17018 00001993 B020                    	mov	al,' ' ; 20h
 17019                                  	;mov	al,BLANK		; if not /s, precede by a blank
 17020 00001995 E8B009                  	call	PRINT_CHAR		; print a leading blank
 17021                                  dhCom:
 17022 00001998 E8FC09                  	call	build_dir_string
 17023 0000199B BA[4A93]                	mov	dx,dirhead_ptr
 17024 0000199E E89C3B                  	call	std_printf		; print header & cr/lf
 17025 000019A1 E81FFF                  	call	UseLine
 17026 000019A4 E87511                  	call	CRLF2			; another cr/lf
 17027                                  	;call	UseLine
 17028                                  ;dhRet:
 17029                                  	;retn
 17030                                  
 17031                                  	; 19/02/2023
 17032 000019A7 E919FF                  	jmp	UseLine
 17033                                  
 17034                                  ; ---------------------------------------------------------------------------
 17035                                  
 17036                                  ;***	DisplayName - display file name & extension
 17037                                  ;
 17038                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17039                                  ;
 17040                                  ;	EXIT	nothing
 17041                                  ;
 17042                                  ;	USED	AX,CX,DX,SI,DI
 17043                                  ;
 17044                                  ;	EFFECTS
 17045                                  ;
 17046                                  ;	  Filename & extension are displayed in spread format.
 17047                                  ;	  Cursor is left at end of extension.
 17048                                  
 17049                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17050                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17051                                  
 17052                                  DisplayName:
 17053 000019AA 1E                      	push	ds			; save TRANGROUP seg addr
 17054 000019AB 8E1E[E69D]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17055                                  	;assume	ds:nothing
 17056 000019AF 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17057                                  	;;add	si,filename		; DS:SI = ptr to filename
 17058                                  	;add	si,1  ; EntryStruc.filename
 17059                                  	; 08/06/2023
 17060 000019B1 46                      	inc	si
 17061 000019B2 BF[509F]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 17062                                  
 17063 000019B5 B90800                  	mov	cx,8
 17064 000019B8 FC                      	cld
 17065 000019B9 F3A4                    	rep	movsb			; move filename to CharBuf
 17066 000019BB B020                    	mov	al,' '
 17067 000019BD AA                      	stosb				; add a blank
 17068                                  	;mov	cx,3
 17069                                  	; 08/06/2023
 17070 000019BE B103                    	mov	cl,3
 17071 000019C0 F3A4                    	rep	movsb			; add extension
 17072 000019C2 30C0                    	xor	al,al
 17073 000019C4 AA                      	stosb				; add a NULL
 17074                                  
 17075 000019C5 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17076                                  	;assume	ds:TRANGROUP
 17077                                  
 17078                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 17079                                  	;;test	word [_Bits],10h
 17080                                  	;test	byte [_Bits],10h
 17081                                  	; 08/06/2023
 17082 000019C6 F606[71A0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17083 000019CB 7406                    	jz	short dn1		;M010;lowercase not required
 17084 000019CD BE[509F]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 17085 000019D0 E88D01                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 17086                                  dn1:	
 17087 000019D3 C706[06A1][509F]        	mov	word [string_ptr_2],CHARBUF
 17088 000019D9 BA[CA93]                	mov	dx,string_buf_ptr
 17089                                  	;call	std_printf		; print filename & extension
 17090                                  	;retn
 17091                                  	; 19/02/2023
 17092 000019DC E95E3B                  	jmp	std_printf
 17093                                  
 17094                                  ; ---------------------------------------------------------------------------
 17095                                  
 17096                                  ;***	DisplayNext - move display cursor to next entry position
 17097                                  ;
 17098                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 17099                                  ;		LeftOnPage = # lines can still be printed for this page
 17100                                  ;		FileCnt = # files in this dir displayed before this one
 17101                                  ;		Bits contains /w setting
 17102                                  ;
 17103                                  ;	EXIT	nothing
 17104                                  ;
 17105                                  ;	USED	AX,DX
 17106                                  ;
 17107                                  ;	EFFECTS
 17108                                  ;
 17109                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 17110                                  ;	   displayed.
 17111                                  ;	  LeftOnPage may be updated.
 17112                                  
 17113                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17114                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17115                                  	
 17116                                  DisplayNext:
 17117 000019DF 833E[129E]00            	cmp	word [FileCnt],0
 17118 000019E4 7415                    	je	short dn1st		; 1st file in directory
 17119 000019E6 803E[0C9E]00            	cmp	byte [LeftOnLine],0
 17120 000019EB 7E08                    	jng	short dnEol	; jle	; no more room on this line
 17121                                  
 17122                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 17123                                  ;	we still have room for more on this line.
 17124                                  ;	Tab to next position.
 17125                                  
 17126 000019ED BA[D993]                	mov	dx,tab_ptr
 17127 000019F0 E84A3B                  	call	std_printf
 17128 000019F3 EB0C                    	jmp	short dnDone
 17129                                  dnEol:	
 17130                                  ;	Start this entry on a new line.
 17131                                  
 17132 000019F5 E82411                  	call	CRLF2		; start on new line
 17133 000019F8 E8C8FE                  	call	UseLine
 17134                                  dn1st:
 17135 000019FB A0[0D9E]                	mov	al,[PerLine]
 17136 000019FE A2[0C9E]                	mov	[LeftOnLine],al	; reset # entries left on line
 17137                                  
 17138                                  dnDone:
 17139 00001A01 FE0E[0C9E]              	dec	byte [LeftOnLine]
 17140                                  				; reflect the entry about to be displayed
 17141 00001A05 C3                      	retn
 17142                                  
 17143                                  ; ---------------------------------------------------------------------------
 17144                                  
 17145                                  ;***	DisplayTheRest - display file size/dir, date, time
 17146                                  ;
 17147                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17148                                  ;		Display cursor is at end of file extension
 17149                                  ;
 17150                                  ;	EXIT	nothing
 17151                                  ;
 17152                                  ;	USED	AX,CX,DX,SI,DI,BP
 17153                                  ;
 17154                                  ;	EFFECTS
 17155                                  ;
 17156                                  ;	  File size, date, & time are displayed.
 17157                                  
 17158                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17159                                  
 17160                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17161                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1A7Ch
 17162                                  DisplayTheRest	:
 17163 00001A06 06                      	push	es			; save TRANGROUP seg addr
 17164 00001A07 8E06[E69D]              	mov	es,[TPA]		; ES = TPA seg addr
 17165 00001A0B 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 17166                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 17167                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 17168 00001A0D 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 17169 00001A12 7415                    	jz	short drNonDir		; not a directory file
 17170                                  
 17171                                  ;	For a directory file, display <DIR> instead of size.
 17172                                  
 17173 00001A14 BA[DC93]                	mov	dx,dmes_ptr
 17174 00001A17 E8233B                  	call	std_printf
 17175                                  	; 08/06/2023
 17176                                  	;jmp	short drCom
 17177                                  
 17178                                  	; 08/06/2023
 17179                                  	; MSDOS 6.22 COMMAND.COM (disassembled source code)
 17180 00001A1A F606[C693]40            	test    byte [screen_f_1],40h	; 80 columns ?
 17181 00001A1F 7406                    	jz      short dr_0      	; no
 17182 00001A21 BA[DF93]                	mov     dx,space_4_ptr		; 4 space chars
 17183 00001A24 E8163B                  	call    std_printf
 17184                                  dr_0:
 17185 00001A27 EB16                    	jmp	short drCom		; skip to common fields
 17186                                  
 17187                                  drNonDir:
 17188                                  ;	For a non-directory file, display file size.
 17189                                  
 17190                                  	;;mov	dx,word ptr es:[bp].filesize
 17191                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 17192 00001A29 268B5611                	mov	dx,[es:bp+17]
 17193 00001A2D 8916[02A1]              	mov	[File_Size_Low],dx
 17194                                  	;;mov	dx,word ptr es:[bp].filesize+2
 17195                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 17196 00001A31 268B5613                	mov	dx,[es:bp+19]
 17197 00001A35 8916[04A1]              	mov	[File_Size_High],dx
 17198 00001A39 BA[BC93]                	mov	dx,disp_file_size_ptr
 17199 00001A3C E8FE3A                  	call	std_printf
 17200                                  drCom:
 17201                                  ;	For all files, display date & time.
 17202                                  
 17203                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 17204                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 17205 00001A3F 268B460F                	mov	ax,[es:bp+15]
 17206 00001A43 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 17207 00001A45 7448                    	jz	short drDone		; no date, skip date/time display
 17208 00001A47 89C3                    	mov	bx,ax			; BX = date word
 17209 00001A49 83E01F                  	and	ax,1Fh			; AX = day of month
 17210 00001A4C 88C2                    	mov	dl,al			; DL = day of month
 17211 00001A4E 89D8                    	mov	ax,bx			; AX = date word
 17212 00001A50 B105                    	mov	cl,5
 17213 00001A52 D3E8                    	shr	ax,cl			; shift day out
 17214 00001A54 240F                    	and	al,0Fh			; AL = month
 17215 00001A56 88C6                    	mov	dh,al			; DH = month
 17216 00001A58 88F9                    	mov	cl,bh
 17217 00001A5A D0E9                    	shr	cl,1			; CL = year - 1980
 17218 00001A5C 30ED                    	xor	ch,ch			; CX = year - 1980
 17219 00001A5E 83C150                  	add	cx,80			; CX = 2-digit year
 17220 00001A61 80F964                  	cmp	cl,100
 17221 00001A64 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 17222 00001A66 80E964                  	sub	cl,100			; adjust for 21st century
 17223                                  dr_1:	
 17224 00001A69 86F2                    	xchg	dh,dl			; DX = month/day
 17225 00001A6B 890E[1D94]              	mov	[DirDat_Yr],cx		; move year to msg block
 17226 00001A6F 8916[1F94]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 17227                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 17228                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 17229 00001A73 268B4E0D                	mov	cx,[es:bp+13]
 17230 00001A77 E310                    	jcxz	drPrint			; no time field - go print
 17231 00001A79 D1E9                    	shr	cx,1
 17232 00001A7B D1E9                    	shr	cx,1
 17233 00001A7D D1E9                    	shr	cx,1			; CH = hours
 17234 00001A7F D0E9                    	shr	cl,1
 17235 00001A81 D0E9                    	shr	cl,1			; CL = minutes
 17236 00001A83 86E9                    	xchg	ch,cl			; CX = hr/min
 17237 00001A85 890E[2894]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 17238                                  drPrint:
 17239 00001A89 BA[1894]                	mov	dx,dirdattim_ptr
 17240 00001A8C E8AE3A                  	call	std_printf		; print date & time
 17241                                  drDone:
 17242 00001A8F 07                      	pop	es			; ES = TRANGROUP seg addr again	
 17243 00001A90 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 17244                                  ;dtrRet:
 17245                                  	; 19/02/2023
 17246 00001A92 C3                      	retn
 17247                                  
 17248                                  ; ---------------------------------------------------------------------------
 17249                                  ; MSDOS 6.0
 17250                                  
 17251                                  ;ifdef DBLSPACE_HOOKS
 17252                                  
 17253                                  ;***	DisplayCompRatio - display compression ratio
 17254                                  ;
 17255                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17256                                  ;
 17257                                  ;	EXIT	nothing
 17258                                  ;
 17259                                  ;	USED	AX,CX,DX
 17260                                  ;
 17261                                  ;	EFFECTS
 17262                                  ;
 17263                                  ;	  File compression ratio is displayed.
 17264                                  
 17265                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17266                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1B09h
 17267                                  
 17268                                  DisplayCompRatio:	;proc
 17269 00001A93 06                      	push	es			; save TRANGROUP seg addr
 17270 00001A94 8E06[E69D]              	mov	es,[TPA]		; ES = TPA seg addr
 17271                                  	;;mov	al,es:[bx].compratio
 17272                                  	;mov	al,[es:bx+EntryStruc.compratio]
 17273 00001A98 268A4715                	mov	al,[es:bx+15h]
 17274 00001A9C 3CFF                    	cmp	al,0FFh			; invalid/no compression ratio?
 17275 00001A9E 7417                    	je	short dcrRet
 17276                                  
 17277 00001AA0 88C4                    	mov	ah,al			; unpack compression ratio
 17278 00001AA2 B104                    	mov	cl,4
 17279 00001AA4 D2EC                    	shr	ah,cl			; isolate whole number portion
 17280 00001AA6 FEC4                    	inc	ah			; 0-15 = 1-16
 17281 00001AA8 240F                    	and	al,0Fh 			; isolate tenths
 17282                                  
 17283 00001AAA 8826[0DA1]              	mov	[Dir_CRatio_1],ah
 17284 00001AAE A2[0EA1]                	mov	[Dir_CRatio_2],al
 17285                                  	;mov	dx,offset TRANGROUP:DirCompRatio_Ptr
 17286                                  	;invoke	Std_Printf
 17287 00001AB1 BA[8894]                	mov	dx,DirCompRatio_Ptr
 17288 00001AB4 E8863A                  	call	std_printf	
 17289                                  dcrRet:
 17290 00001AB7 07                      	pop	es
 17291                                  dtrRet:		; 08/06/2023
 17292 00001AB8 C3                      	retn
 17293                                  
 17294                                  ;DisplayCompRatio	;endp
 17295                                  
 17296                                  ;endif
 17297                                  
 17298                                  ; ---------------------------------------------------------------------------
 17299                                  
 17300                                  ;***	DisplayTrailer - display trailing lines for directory listing
 17301                                  ;
 17302                                  ;	ENTRY	LeftOnPage = # lines left on display page
 17303                                  ;		FileCnt = # files listed
 17304                                  ;		FileSiz = total size of files listed
 17305                                  ;
 17306                                  ;	EXIT	nothing
 17307                                  ;
 17308                                  ;	USED
 17309                                  ;
 17310                                  ;	EFFECTS
 17311                                  ;
 17312                                  ;	  Trailing info lines are displayed
 17313                                  
 17314                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17315                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17316                                  
 17317                                  DisplayTrailer:
 17318                                  	;;;test	Bits,mask bare
 17319                                  	;;test	word [_Bits],8
 17320                                  	;test	byte [_Bits],8
 17321                                  	; 08/06/2023
 17322 00001AB9 F606[71A0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17323 00001ABE 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 17324                                  
 17325 00001AC0 E85910                  	call	CRLF2			; start on new line
 17326 00001AC3 E8FDFD                  	call	UseLine
 17327 00001AC6 A1[129E]                	mov	ax,[FileCnt]		; AX = # files found
 17328                                  
 17329                                  ;	DisplayTotals uses this entry point.
 17330                                  ;
 17331                                  DisplayCntSiz:
 17332                                  ;	AX = # files
 17333                                  ;	FileSiz = dword total size of files
 17334                                  
 17335 00001AC9 A3[0BA1]                	mov	[Dir_Num],ax		; load # files
 17336 00001ACC BA[4392]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 17337 00001ACF E86B3A                  	call	std_printf		; "nnn File(s)"
 17338                                  
 17339 00001AD2 BA[3494]                	mov	dx,bytes_ptr
 17340 00001AD5 E8653A                  	call	std_printf		; "nnn bytes",cr,lf
 17341                                  	; 19/02/2023
 17342                                  	;call	UseLine
 17343                                  ;dtrRet:
 17344                                  	;retn
 17345                                  
 17346                                  	; 19/02/2023
 17347 00001AD8 E9E8FD                  	jmp	UseLine
 17348                                  
 17349                                  ; ---------------------------------------------------------------------------
 17350                                  
 17351                                  ;***	DisplayWide - display filename in wide format
 17352                                  ;
 17353                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17354                                  ;
 17355                                  ;	EXIT	nothing
 17356                                  ;
 17357                                  ;	USED	AX,CX,DX,SI,DI
 17358                                  ;
 17359                                  ;	EFFECTS
 17360                                  ;
 17361                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 17362                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 17363                                  
 17364                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17365                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 17366                                  
 17367                                  DisplayWide:
 17368 00001ADB 1E                      	push	ds			; save TRANGROUP seg addr
 17369 00001ADC 8E1E[E69D]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17370                                  	;assume	ds:nothing
 17371                                  
 17372                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17373                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17374 00001AE0 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 17375 00001AE4 7405                    	jz	short dw1		; not a subdirectory file
 17376 00001AE6 B05B                    	mov	al,'['
 17377 00001AE8 E85D08                  	call	PRINT_CHAR		; prefix subdirectory
 17378                                  dw1:	
 17379 00001AEB E8FFFD                  	call	DisplayDotForm		; display name.ext
 17380                                  
 17381                                  ;	DX = # chars displayed in name.ext
 17382                                  
 17383                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17384                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17385 00001AEE F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 17386 00001AF2 7405                    	jz	short dw2		; not a subdirectory file
 17387 00001AF4 B05D                    	mov	al,']'
 17388 00001AF6 E84F08                  	call	PRINT_CHAR		; postfix subdirectory
 17389                                  dw2:
 17390                                  ;	Pad field with blanks.
 17391                                  
 17392                                  	;mov	cx,size filename + size fileext + 1
 17393 00001AF9 B90C00                  	mov	cx,12 ; 8+3+1
 17394                                  					; CX = field size
 17395 00001AFC 29D1                    	sub	cx,dx			; CX = # pad char's
 17396 00001AFE E307                    	jcxz	dwDone
 17397 00001B00 B020                    	mov	al,' '
 17398                                  dw3:	
 17399 00001B02 E84308                  	call	PRINT_CHAR
 17400 00001B05 E2FB                    	loop	dw3
 17401                                  dwDone:	
 17402 00001B07 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17403                                  	;assume	ds:TRANGROUP
 17404 00001B08 C3                      	retn
 17405                                  
 17406                                  ; ---------------------------------------------------------------------------
 17407                                  
 17408                                  ;***	GetDriveLtr - get target drive letter
 17409                                  ;
 17410                                  ;	ENTRY	FCB contains drive #
 17411                                  ;
 17412                                  ;	EXIT	AX = "d:"
 17413                                  ;
 17414                                  ;	USED	nothing
 17415                                  
 17416                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17417                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 17418                                  GetDriveLtr:
 17419 00001B09 A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 17420 00001B0C 08C0                    	or	al,al
 17421 00001B0E 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 17422 00001B10 A0[F89D]                	mov	al,[CURDRV]	; AL = current drive #
 17423 00001B13 FEC0                    	inc	al		; AL = 1-based drive #
 17424                                  gdl1:	
 17425 00001B15 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 17426 00001B17 B43A                    	mov	ah,':'		; AX = "d:"
 17427 00001B19 C3                      	retn
 17428                                  
 17429                                  ; ---------------------------------------------------------------------------
 17430                                  
 17431                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 17432                                  ;
 17433                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 17434                                  ;	for system parser calls. Set up a message substitution block,
 17435                                  ;	etc. for invalid value strings. I copied the procedure from
 17436                                  ;	Setup_Parse_Error_Msg.
 17437                                  ;
 17438                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 17439                                  ;		
 17440                                  ;
 17441                                  ;	EXIT	AX = system parser error return code for bad param format
 17442                                  ;		DX = ptr to message description block for Std_EPrintf
 17443                                  ;
 17444                                  ;	USED	SI
 17445                                  ;
 17446                                  ;	EFFECTS
 17447                                  ;
 17448                                  ;	  Msg_Disp_Class = parse error message class
 17449                                  ;	  Message block (see DX) is set up for parse error message
 17450                                  
 17451                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17452                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 17453                                  SetupParamError:
 17454 00001B1A B80900                  	mov	ax,9			; parse error #
 17455 00001B1D C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class
 17456                                  	;mov	byte [msg_disp_class],2
 17457 00001B22 A3[0392]                	mov	[extend_buf_ptr],ax
 17458                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 17459 00001B25 8B7704                  	mov	si,[bx+4]
 17460 00001B28 8936[06A1]              	mov	[string_ptr_2],si
 17461 00001B2C C606[0592]01            	mov	byte [extend_buf_sub],one_subst
 17462                                  	;mov	byte [extend_buf_sub],1
 17463 00001B31 BA[0392]                	mov	dx,extend_buf_ptr
 17464 00001B34 C3                      	retn
 17465                                  
 17466                                  ; ---------------------------------------------------------------------------
 17467                                  
 17468                                  ;***	ZeroTotals - zero grand total file count, size
 17469                                  ;
 17470                                  ;	ENTRY	nothing
 17471                                  ;
 17472                                  ;	EXIT	nothing
 17473                                  ;
 17474                                  ;	USED	AX
 17475                                  ;
 17476                                  ;	EFFECTS
 17477                                  ;
 17478                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 17479                                  ;
 17480                                  ;	NOTES
 17481                                  ;
 17482                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 17483                                  
 17484                                  ; 05/06/2023
 17485                                  ;ifdef DBLSPACE_HOOKS
 17486                                  ;csecSIZE EQU size csecUsed + size csecUsedDir + size csecUsedTotal
 17487                                  ;ccluSIZE EQU size ccluUsed + size ccluUsedDir + size ccluUsedTotal
 17488                                  ;endif
 17489                                  
 17490                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17491                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h
 17492                                  
 17493                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17494                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C08h	
 17495                                  ZeroTotals:
 17496 00001B35 BF[189E]                	mov	di,FileCntTotal
 17497                                  
 17498                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17499                                  	;;mov	cx,size FileCntTotal+size FileSizTotal
 17500                                  	;mov	cx,8
 17501                                  	;ifdef DBLSPACE_HOOKS
 17502                                  	;mov	cx,size FileCntTotal+size FileSizTotal+csecSIZE+ccluSIZE
 17503                                  	;endif
 17504 00001B38 B91A00                  	mov	cx,26
 17505                                  
 17506 00001B3B 30C0                    	xor	al,al
 17507 00001B3D F3AA                    	rep	stosb
 17508 00001B3F C3                      	retn	
 17509                                  
 17510                                  ; ---------------------------------------------------------------------------
 17511                                  
 17512                                  ;***	CtrlCHandler - our own control-c handler
 17513                                  ;
 17514                                  ;	Make sure user's default directory gets restored. See notes
 17515                                  ;	at InstallCtrlCHandler.
 17516                                  ;
 17517                                  ;	ENTRY	control-c
 17518                                  ;
 17519                                  ;	EXIT	to OldCtrlCHandler
 17520                                  ;
 17521                                  ;	USED	DS,flags
 17522                                  ;
 17523                                  ;	EFFECTS
 17524                                  ;
 17525                                  ;	  Restore user's default directory.
 17526                                  ;
 17527                                  ;	NOTES
 17528                                  ;
 17529                                  ;	  This handler is only installed after calling PathCrunch,
 17530                                  ;	  which sets UserDir1, so the restoration will work.
 17531                                  ;
 17532                                  ;	  The original control-c vector will be restored, whether
 17533                                  ;	  or not this one is invoked, in the HeadFix routine.
 17534                                  
 17535                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17536                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17537                                  
 17538                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17539                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C13h ; *
 17540                                  
 17541                                  CtrlCHandler:	;proc far
 17542                                  
 17543                                  ;SR;
 17544                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17545                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17546                                  ;
 17547 00001B40 1E                      	push	ds
 17548 00001B41 0E                      	push	cs
 17549 00001B42 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17550 00001B43 50                      	push	ax
 17551 00001B44 53                      	push	bx ; *
 17552 00001B45 52                      	push	dx
 17553 00001B46 E8A101                  	call	CloseCVF ; * 		; close CVF file if open
 17554 00001B49 E88D0E                  	call	RestUDir		; restore user's default directory
 17555 00001B4C 5A                      	pop	dx
 17556 00001B4D 5B                      	pop	bx ; *
 17557 00001B4E 58                      	pop	ax
 17558 00001B4F 1F                      	pop	ds
 17559 00001B50 2EFF2E[2BAA]            	jmp	far [cs:OldCtrlCHandler]
 17560                                  					; go to previous int 23 handler
 17561                                  
 17562                                  ; ---------------------------------------------------------------------------
 17563                                  
 17564                                  ;M010;start
 17565                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17566                                  ;
 17567                                  ;	ENTRY	AL = character to be displayed
 17568                                  ;
 17569                                  ;	EXIT	AL is lowercase
 17570                                  ;
 17571                                  ;	USED	nothing
 17572                                  
 17573                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17574                                  LowerCase:
 17575 00001B55 3C41                    	cmp	al,'A'		; ensure AL is in range 'A'-'Z'
 17576 00001B57 7206                    	jb	short lcRet
 17577 00001B59 3C5A                    	cmp	al,'Z'
 17578 00001B5B 7702                    	ja	short lcRet
 17579                                  
 17580 00001B5D 0C20                    	or	al,20h		; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17581                                  lcRet:
 17582 00001B5F C3                      	retn
 17583                                  
 17584                                  ; ---------------------------------------------------------------------------
 17585                                  
 17586                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17587                                  ;
 17588                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17589                                  ;		ES = DS
 17590                                  ;
 17591                                  ;	EXIT	nothing
 17592                                  ;	
 17593                                  ;	USED	AL,SI
 17594                                  
 17595                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17596                                  LowercaseString:
 17597 00001B60 57                      	push	di			; save di
 17598 00001B61 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17599 00001B63 FC                      	cld
 17600                                  NextChar: 
 17601 00001B64 AC                      	lodsb				; get character from string into al
 17602 00001B65 08C0                    	or	al,al			; are we at end of string?
 17603 00001B67 7406                    	jz	short EndOfString
 17604                                  
 17605 00001B69 E8E9FF                  	call	LowerCase		; convert character to lowercase
 17606 00001B6C AA                      	stosb				; store character back into buffer
 17607 00001B6D EBF5                    	jmp	short NextChar		; repeat until end of string
 17608                                  
 17609                                  EndOfString:
 17610 00001B6F 5F                      	pop	di			; restore di
 17611 00001B70 C3                      	retn
 17612                                  
 17613                                  ;M010;end
 17614                                  
 17615                                  
 17616                                  ; 08/06/2023
 17617                                  ; ---------------------------------------------------------------------------
 17618                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 17619                                  ; -----------------------------------------
 17620                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 17621                                  ; ---------------------------------------------------------------------------
 17622                                  
 17623                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17624                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C44h
 17625                                  screen_f_set:
 17626                                  	; set dir display parameters depending on screen width (# of columns)
 17627 00001B71 1E                      	push	ds
 17628 00001B72 B84000                  	mov	ax,40h
 17629 00001B75 8ED8                    	mov	ds,ax
 17630 00001B77 833E4A0028              	cmp	word [4Ah],40	; Check ROMBIOS DATA colums per row
 17631                                  				; value (80 or 40)
 17632 00001B7C 1F                      	pop	ds
 17633 00001B7D 7527                    	jnz	short columns_80 ; 80 columns per line (video mode 3)
 17634 00001B7F 8026[C693]BF            	and	byte [screen_f_1],0BFh ; ~40h
 17635 00001B84 C706[C793]0A0A          	mov	word [screen_f_2],0A0Ah ; 10 bytes (file size field)
 17636 00001B8A 8026[4D92]BF            	and	byte [screen_f_3],0BFh
 17637 00001B8F 8026[3E94]BF            	and	byte [screen_f_4],0BFh
 17638 00001B94 C706[3F94]0A0A          	mov	word [screen_f_5],0A0Ah ; 10 bytes (file size field)
 17639 00001B9A 8026[5B92]BF            	and	byte [screen_f_6],0BFh
 17640 00001B9F C706[5C92]1C1C          	mov	word [screen_f_7],1C1Ch ; 28 bytes (free bytes field)
 17641                                  	;jmp	short screen_f_set_retn
 17642 00001BA5 C3                      	retn
 17643                                  columns_80:
 17644 00001BA6 800E[C693]40            	or	byte [screen_f_1],40h
 17645 00001BAB C706[C793]0E0E          	mov	word [screen_f_2],0E0Eh ; 14 bytes (file size field)
 17646 00001BB1 800E[4D92]40            	or	byte [screen_f_3],40h
 17647 00001BB6 800E[3E94]40            	or	byte [screen_f_4],40h
 17648 00001BBB C706[3F94]0E0E          	mov	word [screen_f_5],0E0Eh ; 14 bytes (file size field)
 17649 00001BC1 800E[5B92]40            	or	byte [screen_f_6],40h
 17650 00001BC6 C706[5C92]2020          	mov	word [screen_f_7],2020h ; 32 bytes (free bytes field)
 17651                                  screen_f_set_retn:
 17652 00001BCC C3                      	retn
 17653                                  
 17654                                  ;============================================================================
 17655                                  ; CRATIO.ASM, MSDOS 6.0, 1992
 17656                                  ;============================================================================
 17657                                  ; 08/06/2023 - Retro DOS v4.2
 17658                                  
 17659                                  ; The code to calculate compression ratios requires access to the drive's
 17660                                  ; (DOS) FAT and MagicDrv FAT regions.  Two buffers are used (one for each
 17661                                  ; FAT type).  pbufDOSFAT and pbufMDFAT contain the offset to the buffers,
 17662                                  ; segFATBuf contains the segment (both buffers are in the same segment).
 17663                                  ; The buffers are of variable size: cFATEntries contains the size of the
 17664                                  ; buffers in terms of the number of FAT entries they can contain.
 17665                                  
 17666                                  ; ---------------------------------------------------------------------------
 17667                                  
 17668                                  ;***	OpenCVF - open Compressed Volume File for compression ratio report
 17669                                  ;
 17670                                  ;	ENTRY
 17671                                  ;		FCB setup with drive for DIR
 17672                                  ;
 17673                                  ;	EXIT	If successful, CY clear, CVF file open, fhCVF has file handle,
 17674                                  ;		szCVF has \0 terminated CVF file name, MDBPB loaded.
 17675                                  ;
 17676                                  ;		If unsuccessful, CY set
 17677                                  ;
 17678                                  ;	USED	AX, BX, CX, DX, SI, DI
 17679                                  
 17680                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17681                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1CA1h
 17682                                  OpenCVF:
 17683 00001BCD B8FFFF                  	mov	ax,-1
 17684 00001BD0 A3[329E]                	mov	[fhCVF],ax		;indicate CVF not open
 17685 00001BD3 A3[889E]                	mov	[entInBuf],ax		;  and no FAT entries in buffers
 17686                                  
 17687 00001BD6 8A165C00                	mov	dl,[FCB] ; mov dl,5Ch	;target drive of DIR cmd
 17688 00001BDA 08D2                    	or	dl,dl			;default drive?
 17689 00001BDC 7404                    	jz	short ocvf_default
 17690 00001BDE FECA                    	dec	dl			;no, from 1=A to 0=A
 17691 00001BE0 EB04                    	jmp	short ocvf_swap_info
 17692                                  
 17693                                  ocvf_default:
 17694 00001BE2 8A16[F89D]              	mov	dl,[CURDRV]		;0=A, 1=B, ...
 17695                                  
 17696                                  ocvf_swap_info:
 17697 00001BE6 B8114A                  	mov	ax,4A11h ; multMagicDrv	;magicdrv Int 2Fh multiplex ID
 17698 00001BE9 BB0100                  	mov	bx,1	 ; MD_DRIVE_MAP	;get drive swap info
 17699 00001BEC CD2F                    	int	2fh
 17700                                  
 17701 00001BEE 09C0                    	or	ax,ax			;0 if okay
 17702 00001BF0 7573                    	jnz	short ocvf_error
 17703                                  
 17704 00001BF2 F6C380                  	test	bl,80h 			;80h set if compressed volume
 17705 00001BF5 746E                    	jz	short ocvf_error
 17706                                  
 17707 00001BF7 80E37F                  	and	bl,7Fh 			;bl = host drive, bh = seq #
 17708                                  
 17709                                  	; The CVF may have been mounted from a swapped host drive, in which
 17710                                  	; case the host drive returned in BL is the original host (now
 17711                                  	; swapped with a CVF).	Make a second drive swap info call on the
 17712                                  	; returned host to see if it must be accessed by a different drive
 17713                                  	; letter.
 17714                                  
 17715 00001BFA 53                      	push	bx
 17716 00001BFB 52                      	push	dx			;save dl, orig drive letter
 17717                                  
 17718 00001BFC B8114A                  	mov	ax,4A11h ; mov ax,multMagicDrv
 17719 00001BFF 88DA                    	mov	dl,bl
 17720 00001C01 BB0100                  	mov	bx,1	 ; mov bx,MD_DRIVE_MAP
 17721 00001C04 CD2F                    	int	2fh
 17722                                  
 17723 00001C06 5A                      	pop	dx
 17724 00001C07 59                      	pop	cx			;bx from 1st drive swap info call
 17725                                  
 17726 00001C08 09C0                    	or	ax,ax			;0 if okay
 17727 00001C0A 7559                    	jnz	short ocvf_error
 17728                                  
 17729 00001C0C 80E37F                  	and	bl,7Fh
 17730 00001C0F 87D9                    	xchg	bx,cx			;bx = 1st, cx = 2nd swap results
 17731                                  
 17732 00001C11 38CA                    	cmp	dl,cl			;2nd swap info call return orig drive?
 17733 00001C13 7402                    	je	short ocvf_got_host	;yes, 1st swap info call returned host
 17734                                  
 17735 00001C15 88CB                    	mov	bl,cl			;no, use swapped host, orig seq #
 17736                                  ocvf_got_host:
 17737                                  	; Build the filename of the Compressed Volume File
 17738                                  
 17739                                  	;mov	di,offset TRANGROUP:szCVF
 17740                                  					;CVF name buffer
 17741 00001C17 BF[349E]                	mov	di,szCVF
 17742                                  
 17743 00001C1A 88D8                    	mov	al,bl
 17744 00001C1C 0441                    	add	al,'A'
 17745 00001C1E B43A                    	mov	ah,':'
 17746 00001C20 FC                      	cld
 17747 00001C21 AB                      	stosw				; drive:
 17748                                  
 17749                                  	;mov	si,offset TRANGROUP:sCVFRoot
 17750                                  					; \name.
 17751 00001C22 BE[2899]                	mov	si,sCVFRoot	; "\DBLSPACE"
 17752                                  	;mov	cx,cbCVFRoot
 17753 00001C25 B90A00                  	mov	cx,10
 17754 00001C28 F3A4                    	rep	movsb
 17755                                  
 17756 00001C2A 83C703                  	add	di,3			; point past extension
 17757 00001C2D 30C0                    	xor	al,al
 17758 00001C2F FD                      	std
 17759 00001C30 AA                      	stosb				; null terminate
 17760                                  
 17761 00001C31 88F8                    	mov	al,bh			; seq #
 17762 00001C33 B30A                    	mov	bl,10
 17763                                  	;mov	cx,3			; 3 digit ext/seq #
 17764 00001C35 B103                    	mov	cl,3
 17765                                  ;@@:
 17766 00001C37 30E4                    ocvf_1:	xor	ah,ah			; convert seq # to ascii
 17767 00001C39 F6F3                    	div	bl			;   and store as CVF extension
 17768 00001C3B 80C430                  	add	ah,'0'
 17769 00001C3E 86E0                    	xchg	ah,al
 17770 00001C40 AA                      	stosb
 17771 00001C41 88E0                    	mov	al,ah
 17772                                  	;loop	@b
 17773 00001C43 E2F2                    	loop	ocvf_1
 17774                                  
 17775 00001C45 FC                      	cld
 17776                                  
 17777                                  	; Now open the Compressed Volume File
 17778                                  
 17779                                  	; 08/06/2023
 17780                                  	; MSDOS 6.22 COMMAND.COM code only !
 17781                                  	;;;
 17782 00001C46 BF[349E]                	mov	di,szCVF ; *
 17783 00001C49 C745045256              	mov	word [di+4],5652h ; 'RV' (DRVSPACE)
 17784 00001C4E B8003D                  	mov	ax,3D00h
 17785                                  	;mov	dx,szCVF
 17786 00001C51 89FA                    	mov	dx,di ; *
 17787 00001C53 CD21                    	int	21h     ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
 17788                                  			; DS:DX -> ASCIZ filename
 17789                                  			; AL = access mode
 17790                                  			; 0 - read
 17791 00001C55 7310                    	jnb     short ocvf_2
 17792 00001C57 C74504424C              	mov	word [di+4],4C42h ; 'BL' (DBLSPACE)
 17793                                  	;;;
 17794                                  
 17795                                  	;mov	ax,(OPEN shl 8) or 00h 	;compatibility mode/read access
 17796 00001C5C B8003D                  	mov	ax,3D00h
 17797                                  	;;mov	dx,offset TRANGROUP:szCVF
 17798                                  	;mov	dx,szCVF
 17799 00001C5F 89FA                    	mov	dx,di ; *
 17800 00001C61 CD21                    	int	21h
 17801                                  	;jc	short ocvf_error
 17802                                  	; 18/06/2023
 17803 00001C63 7302                    	jnc	short ocvf_2
 17804                                  ocvf_error:	; 18/06/2023
 17805 00001C65 F9                      	stc				;indicate failure
 17806 00001C66 C3                      	retn
 17807                                  ocvf_2:
 17808 00001C67 A3[329E]                	mov	[fhCVF],ax		; success, save CVF file handle
 17809                                  
 17810                                  	; Read the extended MagicDrv BPB
 17811                                  
 17812 00001C6A 89C3                    	mov	bx,ax
 17813                                  	;mov	ah,READ
 17814 00001C6C B43F                    	mov	ah,3Fh
 17815                                  	;mov	cx,size MD_BPB
 17816 00001C6E B94000                  	mov	cx,64
 17817                                  	;mov	dx,offset TRANGROUP:MDBPB
 17818 00001C71 BA[449E]                	mov	dx,MDBPB
 17819 00001C74 CD21                    	int	21h
 17820 00001C76 7204                    	jc	short ocvf_error1
 17821                                  
 17822 00001C78 39C8                    	cmp	ax,cx			; get it all?
 17823 00001C7A 7405                    	je	short ocvf_pick_cluster_size
 17824                                  					; yes...
 17825                                  ocvf_error1:
 17826 00001C7C E86B00                  	call	CloseCVF
 17827                                  	; 18/06/2023
 17828                                  ;ocvf_error:
 17829 00001C7F F9                      	stc				;indicate failure
 17830                                  	;jmp	short ocvf_ret
 17831 00001C80 C3                      	retn
 17832                                  
 17833                                  	; Determine the cluster size to use for ratio calculation
 17834                                  
 17835                                  ocvf_pick_cluster_size:
 17836 00001C81 803E[859E]00            	cmp	byte [fUseHostSize],0 	; user want Host drive cluster size?
 17837 00001C86 7411                    	je	short ovcf_use_CVF_size	; no, use CVF cluster size
 17838                                  
 17839                                  	;mov	ah,Get_Drive_Data	; get the host drive cluster size
 17840 00001C88 B41C                    	mov	ah,1Ch
 17841 00001C8A 8A16[349E]              	mov	dl,[szCVF]
 17842                                  	;sub	dl,40h	
 17843 00001C8E 80EA40                  	sub	dl,'A'-1		; 1 = A, 2 = B, ...
 17844 00001C91 1E                      	push	ds
 17845 00001C92 CD21                    	int	21h
 17846 00001C94 1F                      	pop	ds
 17847                                  
 17848 00001C95 3CFF                    	cmp	al,0FFh			; host drive cluster size in AL if okay,
 17849 00001C97 7503                    	jne	short ovcf_set_size	;   failed = 0FFh
 17850                                  
 17851                                  ovcf_use_CVF_size:
 17852                                  	;mov	al,[MDBPB.dos_bpb.csecPerClu]
 17853 00001C99 A0[519E]                	mov	al,[MDBPB+0Dh]		; using CVF cluster size
 17854                                  
 17855                                  ovcf_set_size:
 17856 00001C9C A2[849E]                	mov	[csecPerCluster],al
 17857                                  
 17858                                  	; Lastly, setup the FAT buffers
 17859                                  ocvf_set_buf:
 17860 00001C9F A1[059E]                	mov	ax,[BYTCNT]		; if >= 32k TPA space available,
 17861 00001CA2 A3[079E]                	mov	[savBytCnt],ax		;   setup larger FAT buffers
 17862 00001CA5 3D0080                  	cmp	ax,32*1024  ; 8000h
 17863 00001CA8 7318                    	jae	short ocvf_big_buf
 17864                                  
 17865                                  	; small TPA, use small resident buffers
 17866                                  
 17867                                  	;mov	word ptr [cFATEntries],cRES_FAT_ENTRIES
 17868 00001CAA C706[869E]2000          	mov	word [cFATEntries],32 ; cRES_FAT_ENTRIES
 17869 00001CB0 8C1E[8A9E]              	mov	[segFATBuf],ds
 17870                                  	;mov	word ptr [pbufDOSFAT],offset TRANGROUP:bufDOSFAT
 17871                                  	;mov	word ptr [pbufMDFAT],offset TRANGROUP:bufMDFAT
 17872 00001CB4 C706[8C9E][909E]        	mov	word [pbufDOSFAT],bufDOSFAT
 17873 00001CBA C706[8E9E][D09E]        	mov	word [pbufMDFAT],bufMDFAT
 17874                                  	;jmp	short ocvf_success
 17875                                  	; 08/06/2023
 17876                                  	; cf = 1
 17877 00001CC0 F8                      	clc
 17878 00001CC1 C3                      	retn
 17879                                  
 17880                                  ocvf_big_buf:
 17881                                  	;mov	bx,cBIG_FAT_ENTRIES
 17882 00001CC2 BB0001                  	mov	bx,256
 17883 00001CC5 891E[869E]              	mov	[cFATEntries],bx
 17884                                  
 17885 00001CC9 D1E3                    	shl	bx,1			; 6 bytes per entry (2 for DOS FAT, 4 MD FAT)
 17886 00001CCB 89D9                    	mov	cx,bx			; entries * 2
 17887 00001CCD D1E3                    	shl	bx,1
 17888 00001CCF 01CB                    	add	bx,cx			; bx = # entries * 6
 17889                                  
 17890 00001CD1 29D8                    	sub	ax,bx			; reduce TPA size by size of FAT buffers
 17891 00001CD3 2500FE                  	and	ax,0FE00h		; init code rounds BytCnt down to multiple of
 17892 00001CD6 A3[059E]                	mov	[BYTCNT],ax		;   512 bytes -- a no-op with some buf sizes.
 17893                                  
 17894 00001CD9 8B1E[E69D]              	mov	bx,[TPA]		; buffers in the TPA
 17895 00001CDD 891E[8A9E]              	mov	[segFATBuf],bx
 17896 00001CE1 A3[8C9E]                	mov	[pbufDOSFAT],ax		; DOS FAT buffer offset
 17897 00001CE4 01C8                    	add	ax,cx			;   + DOS FAT buffer size
 17898 00001CE6 A3[8E9E]                	mov	[pbufMDFAT],ax 		;   = MD FAT buffer offset
 17899                                  	; 08/06/2023
 17900                                  	; cf = 0
 17901                                  ;ocvf_success:
 17902                                  	;clc				;indicate success
 17903                                  ocvf_ret:
 17904 00001CE9 C3                      	retn
 17905                                  
 17906                                  ; ---------------------------------------------------------------------------
 17907                                  
 17908                                  ;***	CloseCVF - close Compressed Volume File
 17909                                  ;
 17910                                  ;	ENTRY	fhCVF has file handle
 17911                                  ;
 17912                                  ;	EXIT
 17913                                  ;
 17914                                  ;	USED	AX, BX, CX, DX
 17915                                  
 17916                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 17917                                  CloseCVF:
 17918 00001CEA 8B1E[329E]              	mov	bx,[fhCVF]		; -1 unless file is open
 17919 00001CEE 83FBFF                  	cmp	bx,-1 ; 0FFFFh
 17920 00001CF1 7410                    	je	short ccvf_ret
 17921                                  
 17922                                  	;mov	ah,CLOSE
 17923 00001CF3 B43E                    	mov	ah,3Eh
 17924 00001CF5 CD21                    	int	21h
 17925                                  
 17926 00001CF7 C706[329E]FFFF          	mov	word [fhCVF],-1 ; 0FFFFh ; don't try to close again
 17927                                  
 17928 00001CFD A1[079E]                	mov	ax,[savBytCnt]		; 'deallocate' DOS & MD FAT buffers
 17929 00001D00 A3[059E]                	mov	[BYTCNT],ax		;   by restoring old TPA byte count
 17930                                  ccvf_ret:
 17931 00001D03 C3                      	retn
 17932                                  
 17933                                  ; ---------------------------------------------------------------------------
 17934                                  
 17935                                  ;***	CalcCompRatio - calculate file compression ratio
 17936                                  ;
 17937                                  ;	ENTRY	AX = starting cluster of file to get compression ratio of
 17938                                  ;
 17939                                  ;	EXIT	AX = compression ratio.  Example: a ratio of 2.7 to 1.0
 17940                                  ;		     will return AH = 02h & AL = 07h
 17941                                  ;		ccluUsed set to # DOS clusters used by file
 17942                                  ;		csecUsed set to # compressed sectors used by file
 17943                                  ;		ccluUsedDir, ccluUsedTotal, csecUsedDir, csecUsedTotal updated
 17944                                  ;	USED	none
 17945                                  
 17946                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 17947                                  CalcCompRatio:
 17948 00001D04 53                      	push	bx
 17949 00001D05 51                      	push	cx
 17950 00001D06 52                      	push	dx
 17951 00001D07 06                      	push	es
 17952 00001D08 8E06[8A9E]              	mov	es,[segFATBuf]		; es is pointer to FAT buffers
 17953                                  	;assume	es:nothing
 17954                                  
 17955 00001D0C 31DB                    	xor	bx,bx			; zero count of sectors & clusters used
 17956 00001D0E 891E[209E]              	mov	[ccluUsed],bx
 17957 00001D12 891E[269E]              	mov	[csecUsed],bx
 17958 00001D16 891E[289E]              	mov	[csecUsed+2],bx
 17959                                  ccr_next:
 17960 00001D1A 83F802                  	cmp	ax,2			; sanity check the DOS FAT value
 17961 00001D1D 7250                    	jb	short ccr_screwy
 17962                                  
 17963 00001D1F 83F8F0                  	cmp	ax,0FFF0h		; end of file?
 17964 00001D22 7352                    	jae	short ccr_eof
 17965                                  
 17966 00001D24 E84701                  	call	CheckFATBuffers 	; make sure buffers contain target
 17967 00001D27 7246                    	jc	short ccr_screwy	;   FAT entries
 17968                                  
 17969 00001D29 E82901                  	call	GetMDFATEntry		; returns corresponding entry in BX:CX
 17970 00001D2C 7241                    	jc	short ccr_screwy
 17971                                  
 17972 00001D2E D1E3                    	shl	bx,1			; used bit to CY
 17973 00001D30 733D                    	jnc	short ccr_screwy	; better be used!
 17974                                  
 17975 00001D32 88FD                    	mov	ch,bh			; save uncompressed count
 17976                                  
 17977 00001D34 D1E3                    	shl	bx,1			; get count into position
 17978 00001D36 81E3000F                	and	bx,0F00h		; bh = count of compressed sectors used
 17979 00001D3A 86FB                    	xchg	bh,bl			; bx = count
 17980 00001D3C 43                      	inc	bx			; 0 - 15 means 1 - 16 used
 17981                                  
 17982 00001D3D 011E[269E]              	add	[csecUsed],bx
 17983 00001D41 8316[289E]00            	adc	word [csecUsed+2],0
 17984                                  
 17985 00001D46 89C2                    	mov	dx,ax			; save cluster # in dx
 17986                                  
 17987 00001D48 88E8                    	mov	al,ch			; uncompressed count to al
 17988 00001D4A B103                    	mov	cl,3
 17989 00001D4C D2E8                    	shr	al,cl			; get uncompressed count into position
 17990 00001D4E 83E00F                  	and	ax,000Fh		; ax = uncompressed count (0 - 15)
 17991 00001D51 4B                      	dec	bx			; bx = compressed count (0 - 15)
 17992 00001D52 39D8                    	cmp	ax,bx			; if the compressed cnt > uncompressed
 17993                                  	;jae	@f			;   fudge a little and use the larger
 17994 00001D54 7302                    	jae	short ccr_1 ; jnb
 17995 00001D56 89D8                    	mov	ax,bx
 17996                                  ;@@:	
 17997                                  ccr_1:
 17998 00001D58 8A0E[849E]              	mov	cl,[csecPerCluster]	; round up to the number of clusters
 17999 00001D5C 30ED                    	xor	ch,ch			;   required for uncompressed
 18000 00001D5E 01C8                    	add	ax,cx			;   sectors
 18001 00001D60 F6F1                    	div	cl
 18002 00001D62 30E4                    	xor	ah,ah
 18003 00001D64 0106[209E]              	add	[ccluUsed],ax
 18004                                  
 18005 00001D68 89D0                    	mov	ax,dx			; restore cluster #
 18006 00001D6A E8A900                  	call	GetDOSFATEntry		; retuns next DOS FAT entry in AX
 18007                                  	;jc	short ccr_screwy
 18008                                  	;jmp	short ccr_next
 18009                                  	; 08/06/2023
 18010 00001D6D 73AB                    	jnc	short ccr_next
 18011                                  ccr_screwy:
 18012 00001D6F 31C0                    	xor	ax,ax			; something screwy happened, set
 18013                                  					;   ratio to 0.0 and exit
 18014                                  ccr_ret:
 18015 00001D71 07                      	pop	es
 18016 00001D72 5A                      	pop	dx
 18017 00001D73 59                      	pop	cx
 18018 00001D74 5B                      	pop	bx
 18019 00001D75 C3                      	retn
 18020                                  
 18021                                  	; Reached the end-of-file, now calculate the ratio as the
 18022                                  	; number of DOS sectors used / number of compressed sectors used.
 18023                                  
 18024                                  ccr_eof:
 18025 00001D76 A1[209E]                	mov	ax,[ccluUsed]
 18026 00001D79 0106[229E]              	add	[ccluUsedDir],ax	; update cluster used totals
 18027 00001D7D 0106[249E]              	add	[ccluUsedTotal],ax
 18028                                  
 18029 00001D81 8B0E[289E]              	mov	cx,[csecUsed+2]
 18030 00001D85 8B1E[269E]              	mov	bx,[csecUsed]		; cx:bx = # compressed sectors used
 18031                                  
 18032 00001D89 011E[2A9E]              	add	[csecUsedDir],bx	; update sector used totals
 18033 00001D8D 110E[2C9E]              	adc	[csecUsedDir+2],cx
 18034 00001D91 011E[2E9E]              	add	[csecUsedTotal],bx
 18035 00001D95 110E[309E]              	adc	[csecUsedTotal+2],cx
 18036                                  
 18037 00001D99 E80200                  	call	ComputeRatio		; ax=clusters used, cx:bx=sectors used
 18038                                  
 18039 00001D9C EBD3                    	jmp	short ccr_ret
 18040                                  
 18041                                  	; 08/06/2023
 18042                                  ;ccr_screwy:
 18043                                  ;	xor	ax,ax			; something screwy happened, set
 18044                                  ;					;   ratio to 0.0 and exit
 18045                                  ;ccr_ret:
 18046                                  ;	pop	es
 18047                                  ;	pop	dx
 18048                                  ;	pop	cx
 18049                                  ;	pop	bx
 18050                                  ;	retn
 18051                                  
 18052                                  ; ---------------------------------------------------------------------------
 18053                                  
 18054                                  ;***	ComputeRatio - calculate ratio of compressed sectors used to
 18055                                  ;		       (would be) DOS sectors used
 18056                                  ;
 18057                                  ;	Entry
 18058                                  ;		AX = DOS clusters used, cx:bx = compressed sectors used
 18059                                  ;	Exit
 18060                                  ;		ah = whole portion, al = tenths
 18061                                  ;
 18062                                  ;	Used	BX, CX, DX
 18063                                  
 18064                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18065                                  ComputeRatio:
 18066 00001D9E 56                      	push	si
 18067 00001D9F 57                      	push	di
 18068                                  
 18069 00001DA0 89DE                    	mov	si,bx
 18070 00001DA2 89CF                    	mov	di,cx			; save cx:bx in di:si
 18071                                  
 18072 00001DA4 8A1E[849E]              	mov	bl,[csecPerCluster]
 18073 00001DA8 30FF                    	xor	bh,bh
 18074 00001DAA F7E3                    	mul	bx			; dx:ax = # DOS sectors used
 18075 00001DAC 89F3                    	mov	bx,si			; restore bx
 18076                                  
 18077 00001DAE E83800                  	call	Div32			; dx:ax = quotient, cx:bx = remainder
 18078                                  
 18079 00001DB1 50                      	push	ax			; save quotient
 18080                                  
 18081 00001DB2 89D8                    	mov	ax,bx			; if no remainder, tenths will be 0
 18082 00001DB4 09C8                    	or	ax,cx			;   which is in AX so skip following
 18083 00001DB6 7423                    	jz	short cr_got_tenths	;   (happens frequently)
 18084                                  
 18085                                  	; Multiply the reminder by 10, add half the divisor so result is
 18086                                  	; rounded up, and divide again to get tenths digit
 18087                                  
 18088 00001DB8 89C8                    	mov	ax,cx
 18089 00001DBA 31D2                    	xor	dx,dx
 18090 00001DBC 89D9                    	mov	cx,bx
 18091 00001DBE BB0A00                  	mov	bx,10
 18092 00001DC1 F7E3                    	mul	bx
 18093 00001DC3 91                      	xchg	ax,cx
 18094 00001DC4 F7E3                    	mul	bx
 18095 00001DC6 01CA                    	add	dx,cx			; dx:ax = remainder * 10
 18096                                  
 18097 00001DC8 89F9                    	mov	cx,di
 18098 00001DCA 89F3                    	mov	bx,si
 18099 00001DCC D1E9                    	shr	cx,1
 18100 00001DCE D1DB                    	rcr	bx,1			; cx:bx = 1/2 divisor
 18101 00001DD0 01D8                    	add	ax,bx
 18102 00001DD2 11CA                    	adc	dx,cx			; dx:ax = remainder * 10 + 1/2 divisor
 18103                                  
 18104 00001DD4 89F9                    	mov	cx,di
 18105 00001DD6 89F3                    	mov	bx,si
 18106                                  
 18107 00001DD8 E80E00                  	call	Div32
 18108                                  
 18109                                  cr_got_tenths:
 18110 00001DDB 5B                      	pop	bx			; original quotient
 18111 00001DDC 88DC                    	mov	ah,bl
 18112                                  
 18113 00001DDE 3C0A                    	cmp	al,10			; if the tenths rounded up to the
 18114 00001DE0 7204                    	jb	short cr_exit 		;   next whole number, adjust the
 18115                                  					;   whole number part and 0 the
 18116 00001DE2 FEC4                    	inc	ah			;   tenths  (i.e. round 1.97 to 2.0)
 18117 00001DE4 30C0                    	xor	al,al
 18118                                  cr_exit:
 18119 00001DE6 5F                      	pop	di
 18120 00001DE7 5E                      	pop	si
 18121                                  
 18122 00001DE8 C3                      	retn
 18123                                  
 18124                                  ; --------------------------------------------------------------------------- 
 18125                                  
 18126                                  ;***	Div32 - 32 bit divide for computing ratios
 18127                                  ;
 18128                                  ;	Entry	DX:AX = dividend, CX:BX = divisor
 18129                                  ;
 18130                                  ;	Exit	DX:AX = quotient, CX:BX = reminder
 18131                                  
 18132                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18133                                  Div32:
 18134 00001DE9 E322                    	jcxz	d32_16bit		; differently if 16bit divisor
 18135                                  
 18136 00001DEB 56                      	push	si
 18137 00001DEC 57                      	push	di
 18138                                  
 18139                                  	; Brute force divide by subtraction. This is okay because worse case
 18140                                  	; the dividend will only be 16 times greater, and typically about 2
 18141                                  	; times
 18142                                  
 18143 00001DED 31F6                    	xor	si,si
 18144 00001DEF 89F7                    	mov	di,si			; di:si is quotient
 18145                                  ;@@:
 18146                                  div32_1:
 18147 00001DF1 29D8                    	sub	ax,bx			; subtract divisor
 18148 00001DF3 19CA                    	sbb	dx,cx
 18149 00001DF5 7208                    	jc	short d32_too_far
 18150                                  
 18151 00001DF7 83C601                  	add	si, 1			; accumulate quotient
 18152 00001DFA 83D700                  	adc	di, 0
 18153                                  	;jmp	short @b
 18154 00001DFD EBF2                    	jmp	short div32_1
 18155                                  
 18156                                  d32_too_far:
 18157 00001DFF 01D8                    	add	ax,bx			; fix the last subtraction
 18158 00001E01 11CA                    	adc	dx,cx
 18159                                  
 18160 00001E03 89F9                    	mov	cx,di
 18161 00001E05 89F3                    	mov	bx,si			; dx:ax = remainder, cx:bx = quoient
 18162                                  
 18163 00001E07 93                      	xchg	ax,bx
 18164 00001E08 87D1                    	xchg	dx,cx			; dx:ax = quoient, cx:bx = remainder
 18165                                  
 18166 00001E0A 5F                      	pop	di
 18167 00001E0B 5E                      	pop	si
 18168                                  
 18169 00001E0C C3                      	retn
 18170                                  
 18171                                  d32_16bit:
 18172 00001E0D F7F3                    	div	bx			; divide dx:ax by bx
 18173                                  
 18174 00001E0F 89D3                    	mov	bx,dx			; remainder to cx:bx
 18175 00001E11 31D2                    	xor	dx,dx			; quotient to dx:ax
 18176 00001E13 89D1                    	mov	cx,dx
 18177 00001E15 C3                      	retn
 18178                                  
 18179                                  ; --------------------------------------------------------------------------- 
 18180                                  
 18181                                  ;***	GetDOSFATEntry - returns next cluster in file's FAT chain
 18182                                  ;
 18183                                  ;	Entry	AX = current cluster number
 18184                                  ;		ES = segment of FAT buffer
 18185                                  ;		Entry should be in FAT buffer
 18186                                  ;
 18187                                  ;	Exit	AX = next cluster number
 18188                                  ;		CY set if error
 18189                                  ;
 18190                                  ;	Uses	BX
 18191                                  
 18192                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18193                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1EF2h
 18194                                  GetDOSFATEntry:
 18195 00001E16 2B06[889E]              	sub	ax,[entInBuf]		; calc entry # in buffer
 18196 00001E1A 7212                    	jc	short gdf_ret 		; CY already set for error
 18197                                  
 18198 00001E1C 89C3                    	mov	bx,ax
 18199                                  
 18200                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18201 00001E1E 803E[819E]00            	cmp	byte [MDBPB+3Dh],0
 18202 00001E23 750A                    	jnz	short gdf_12		; go do 12
 18203                                  
 18204 00001E25 D1E3                    	shl	bx,1			; offset = entry * 2
 18205 00001E27 031E[8C9E]              	add	bx,[pbufDOSFAT]
 18206 00001E2B 268B07                  	mov	ax,[es:bx]
 18207                                  	; 08/06/2023
 18208                                  	; cf = 0
 18209                                  ;gdf_success:
 18210                                  	;clc				; success
 18211                                  gdf_ret:
 18212 00001E2E C3                      	retn
 18213                                  
 18214                                  gdf_12:
 18215 00001E2F D1EB                    	shr	bx,1
 18216 00001E31 01C3                    	add	bx,ax			; offset to entry = entry * 1.5
 18217 00001E33 031E[8C9E]              	add	bx,[pbufDOSFAT]
 18218                                  
 18219                                  ;	ES:BX points to the word containing the desired 12 bit FAT entry.
 18220                                  ;	For odd entries, the upper 12 bits are valid, for even entries
 18221                                  ;	the low 12 bits are valid.  odd: OOOx  even: xEEE
 18222                                  
 18223 00001E37 A801                    	test	al,1			; is current entry odd?
 18224                                  
 18225 00001E39 268B07                  	mov	ax,[es:bx]		; word with FAT entry
 18226 00001E3C 7505                    	jnz	short gdf_odd
 18227                                  
 18228 00001E3E 25FF0F                  	and	ax,0FFFh		; keep low 12 bits for even
 18229 00001E41 EB08                    	jmp	short gdf_testEOF
 18230                                  
 18231                                  gdf_odd:
 18232 00001E43 89CB                    	mov	bx,cx			; (save cx in bx)
 18233 00001E45 B104                    	mov	cl,4
 18234 00001E47 D3E8                    	shr	ax,cl			; upper 12 bits for odd
 18235 00001E49 89D9                    	mov	cx,bx			; (restore cx)
 18236                                  
 18237                                  gdf_testEOF:
 18238 00001E4B 3DF00F                  	cmp	ax,0FF0h		; valid entry?
 18239                                  	;jb	short gdf_success
 18240 00001E4E F5                      	cmc	; cf = 1 <--> cf = 0
 18241 00001E4F 73DD                    	jnc	short gdf_ret	
 18242                                  
 18243 00001E51 80CCF0                  	or	ah,0F0h			; caller expects 16 bit special values
 18244                                  	;jmp	short gdf_success
 18245                                  	; cf = 0
 18246 00001E54 C3                      	retn
 18247                                  
 18248                                  ; --------------------------------------------------------------------------- 
 18249                                  
 18250                                  ;***	GetMDFATEntry - returns requested MD FAT entry
 18251                                  ;
 18252                                  ;	Entry	AX = current DOS cluster number
 18253                                  ;		ES = segment of FAT buffer
 18254                                  ;		Entry should be in FAT buffer
 18255                                  ;
 18256                                  ;	Exit	BX:CX = corresponding MD FAT entry
 18257                                  ;		CY set if error
 18258                                  ;
 18259                                  ;	Uses	None
 18260                                  
 18261                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18262                                  GetMDFATEntry:
 18263 00001E55 89C3                    	mov	bx,ax
 18264 00001E57 2B1E[889E]              	sub	bx,[entInBuf]		; calc entry # in buffer
 18265 00001E5B 7210                    	jc	short gmf_ret 		; CY already set for error return
 18266                                  
 18267 00001E5D D1E3                    	shl	bx,1
 18268 00001E5F D1E3                    	shl	bx,1			; * 4 bytes per MDFAT entry
 18269                                  
 18270 00001E61 031E[8E9E]              	add	bx,[pbufMDFAT]
 18271 00001E65 268B0F                  	mov	cx,[es:bx]
 18272 00001E68 268B5F02                	mov	bx,[es:bx+2]
 18273                                  
 18274 00001E6C F8                      	clc
 18275                                  gmf_ret:
 18276 00001E6D C3                      	retn
 18277                                  
 18278                                  ; --------------------------------------------------------------------------- 
 18279                                  
 18280                                  ;***	CheckFATBuffers - check that target FAT entry is in FAT buffers.  If
 18281                                  ;			  not, fill the buffers starting with the requested
 18282                                  ;			  entry.
 18283                                  ;
 18284                                  ;	ENTRY	AX = FAT entry #
 18285                                  ;		ES = segment of FAT buffers
 18286                                  ;
 18287                                  ;	EXIT	FAT buffers contain target entry, or CY set if error
 18288                                  ;		entInBuf updated
 18289                                  ;
 18290                                  ;	USED	BX
 18291                                  
 18292                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18293                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1F4Bh
 18294                                  
 18295                                  CheckFATBuffers:
 18296 00001E6E 89C3                    	mov	bx,ax
 18297 00001E70 2B1E[889E]              	sub	bx,[entInBuf]
 18298 00001E74 7208                    	jb	short cfb_load_fat
 18299                                  
 18300 00001E76 2B1E[869E]              	sub	bx,[cFATEntries]
 18301 00001E7A 7302                    	jae	short cfb_load_fat ; jnb
 18302                                  
 18303 00001E7C F8                      	clc
 18304 00001E7D C3                      	retn
 18305                                  
 18306                                  	; Desired entry isn't in the FAT buffers, reload the buffers to
 18307                                  	; include it
 18308                                  
 18309                                  cfb_load_fat:
 18310 00001E7E 50                      	push	ax
 18311 00001E7F 51                      	push	cx
 18312 00001E80 52                      	push	dx
 18313                                  
 18314                                  	; Start with the DOS FAT buffer
 18315                                  
 18316 00001E81 31C9                    	xor	cx,cx			; zero high offset to FAT file position
 18317                                  
 18318                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18319 00001E83 803E[819E]00            	cmp	byte [MDBPB+3Dh],0
 18320 00001E88 7509                    	jnz	short cfb_12		; go do 12
 18321                                  
 18322 00001E8A A3[889E]                	mov	[entInBuf],ax		; this entry is first
 18323                                  
 18324 00001E8D D1E0                    	shl	ax,1			; 2 bytes per cluster #
 18325 00001E8F D1D1                    	rcl	cx,1			; cx:ax = offset to FAT entry
 18326                                  
 18327 00001E91 EB0B                    	jmp	short cfb_common
 18328                                  
 18329                                  cfb_12:
 18330                                  	;and	al,not 1 ; 0FEh		; start with even # entry
 18331 00001E93 24FE                    	and	al,~1
 18332 00001E95 A3[889E]                	mov	[entInBuf],ax
 18333                                  
 18334 00001E98 89C3                    	mov	bx,ax
 18335 00001E9A D1EB                    	shr	bx,1
 18336 00001E9C 01D8                    	add	ax,bx			; ax = offset to FAT entry
 18337                                  					;      (entry # * 1.5)
 18338                                  cfb_common:
 18339 00001E9E 89C3                    	mov	bx,ax			; cx:bx = offset to FAT entry
 18340                                  
 18341                                  	;mov	ax,[MDBPB.csecMDReserved] ; # magicDrv reserved sectors
 18342 00001EA0 A1[6B9E]                	mov	ax,[MDBPB+27h]
 18343                                  	;add	ax,[MDBPB.dos_bpb.csecReserved]
 18344 00001EA3 0306[529E]              	add	ax,[MDBPB+0Eh]
 18345                                  
 18346                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18347 00001EA7 F726[4F9E]              	mul	word [MDBPB+0Bh]	; DX:AX = DOS FAT file origin
 18348 00001EAB 01D8                    	add	ax,bx
 18349 00001EAD 11CA                    	adc	dx,cx			; DX:AX = file offset to read from
 18350                                  
 18351 00001EAF 8B0E[869E]              	mov	cx,[cFATEntries]	; size to read
 18352 00001EB3 D1E1                    	shl	cx,1
 18353 00001EB5 8B1E[8C9E]              	mov	bx,[pbufDOSFAT]		; es:bx = location to read
 18354                                  
 18355 00001EB9 E83500                  	call	ReadCVFile
 18356 00001EBC 722F                    	jc	short cfb_error
 18357                                  
 18358                                  	; Now read the corresponding MagicDrv FAT entries
 18359                                  
 18360                                  	;mov	ax,[MDBPB.secMDFATStart]
 18361 00001EBE A1[689E]                	mov	ax,[MDBPB+24h]
 18362 00001EC1 40                      	inc	ax
 18363                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18364 00001EC2 F726[4F9E]              	mul	word [MDBPB+0Bh]	; DX:AX = MDFAT file offset
 18365                                  
 18366 00001EC6 8B1E[889E]              	mov	bx,[entInBuf]
 18367 00001ECA 31C9                    	xor	cx,cx			; CX:BX = 32 bit cluster #
 18368                                  	;add	bx,[MDBPB.cluFirstData]
 18369 00001ECC 031E[719E]              	add	bx,[MDBPB+2Dh]
 18370 00001ED0 11C9                    	adc	cx,cx			; CX:BX = MDFAT entry #
 18371                                  
 18372 00001ED2 D1E3                    	shl	bx,1
 18373 00001ED4 D1D1                    	rcl	cx,1
 18374 00001ED6 D1E3                    	shl	bx,1
 18375 00001ED8 D1D1                    	rcl	cx,1			; * 4 bytes per MDFAT entry
 18376                                  
 18377 00001EDA 01D8                    	add	ax,bx
 18378 00001EDC 11CA                    	adc	dx,cx			; DX:AX = file offset of MDFAT entry
 18379                                  
 18380 00001EDE 8B0E[869E]              	mov	cx,[cFATEntries]
 18381 00001EE2 D1E1                    	shl	cx,1
 18382 00001EE4 D1E1                    	shl	cx,1			; size to read
 18383 00001EE6 8B1E[8E9E]              	mov	bx,[pbufMDFAT]		; es:bx = location to read into
 18384                                  
 18385 00001EEA E80400                  	call	ReadCVFile
 18386                                  	;jnc	short cfb_ret ; cf = 0 ; 08/06/2023
 18387                                  	; 08/06/2023
 18388                                  	; cf = 1
 18389                                  cfb_error:
 18390                                  	;stc
 18391                                  cfb_ret:
 18392 00001EED 5A                      	pop	dx
 18393 00001EEE 59                      	pop	cx
 18394 00001EEF 58                      	pop	ax
 18395 00001EF0 C3                      	retn
 18396                                  
 18397                                  ; --------------------------------------------------------------------------- 
 18398                                  
 18399                                  ;***	ReadCVFile - read from the Compressed Volume File
 18400                                  ;
 18401                                  ;	Entry	DX:AX file offset, ES:BX buffer location, CX length in bytes
 18402                                  ;
 18403                                  ;	Exit	CY set if error, else data read
 18404                                  ;
 18405                                  ;	Uses	AX, BX, CX, DX
 18406                                  
 18407                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18408                                  ReadCVFile:
 18409 00001EF1 53                      	push	bx			; save buffer loc
 18410 00001EF2 51                      	push	cx			; save read length
 18411                                  
 18412 00001EF3 89D1                    	mov	cx,dx
 18413 00001EF5 89C2                    	mov	dx,ax			; cx:dx = file offset of fat entry
 18414                                  	;mov	ax,(LSEEK shl 8) or 0
 18415 00001EF7 B80042                  	mov	ax,4200h
 18416 00001EFA 8B1E[329E]              	mov	bx,[fhCVF]
 18417 00001EFE CD21                    	int	21h
 18418 00001F00 720E                    	jc	short rcf_ret 		; CY set for error return
 18419                                  
 18420                                  	;mov	ah,READ
 18421 00001F02 B43F                    	mov	ah,3Fh
 18422 00001F04 59                      	pop	cx			; read length
 18423 00001F05 5A                      	pop	dx			; buffer loc offset
 18424 00001F06 1E                      	push	ds
 18425 00001F07 06                      	push	es
 18426 00001F08 1F                      	pop	ds			; buffer loc segment
 18427 00001F09 CD21                    	int	21h
 18428 00001F0B 1F                      	pop	ds
 18429 00001F0C 7202                    	jc	short rcf_ret 		; CY set for error return
 18430                                  
 18431 00001F0E 39C8                    	cmp	ax,cx			; read it all?
 18432                                  	;je	short rcf_ret 		; yes, CY clear
 18433                                  	; 08/06/2023	
 18434                                  	; ax < cx
 18435                                  	;stc				; end-of-file?
 18436                                  rcf_ret:
 18437 00001F10 C3                      	retn
 18438                                  
 18439                                  ;============================================================================
 18440                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 18441                                  ;============================================================================
 18442                                  ; 09/10/2018 - Retro DOS v3.0
 18443                                  
 18444                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 18445                                  
 18446                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18447                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 18448                                  
 18449                                  ; =============== S U B	R O U T	I N E =======================================
 18450                                  
 18451                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18452                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1FF4h
 18453                                  PAUSE:
 18454 00001F11 BA[9592]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 18455 00001F14 E82636                  	call	std_printf
 18456 00001F17 E80DE7                  	call	GETKEYSTROKE
 18457                                  	;call	CRLF2
 18458                                  	;retn
 18459                                  	; 19/02/2023
 18460 00001F1A E9FF0B                  	jmp	CRLF2
 18461                                  
 18462                                  ; ---------------------------------------------------------------------------
 18463                                  
 18464                                  ;****************************************************************
 18465                                  ;*
 18466                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 18467                                  ;*
 18468                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 18469                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 18470                                  ;*		up an error message and transfer control to CERROR.
 18471                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 18472                                  ;*		entered or SLASHP_ERASE if /P entered.
 18473                                  ;*
 18474                                  ;* INPUT:	command line at offset 81H
 18475                                  ;*
 18476                                  ;* OUTPUT:	if no error:
 18477                                  ;*		FCB at 5ch set up with filename(s) entered
 18478                                  ;*		Current directory set to entered directory
 18479                                  ;*
 18480                                  ;****************************************************************
 18481                                  
 18482                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18483                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 18484                                  
 18485                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18486                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2001h
 18487                                  ERASE:
 18488                                  	; MSDOS 6.0
 18489                                  
 18490                                  	;assume	ds:trangroup,es:trangroup
 18491                                  
 18492 00001F1D BE8100                  	mov	si,81h		;AC000; get command line
 18493 00001F20 C706[FB9D]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 18494 00001F26 BF[5D98]                	mov	di,PARSE_ERASE
 18495                                  				;AN000; Get address of PARSE_ERASE
 18496 00001F29 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18497                                  erase_scan:
 18498 00001F2B 31D2                    	xor	dx,dx		;AN000;
 18499 00001F2D E8D407                  	call	Parse_With_Msg	;AC018; call parser
 18500                                  	
 18501                                  	;cmp	ax,-1  ; 0FFFFh
 18502                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 18503                                  	;je	short good_line	;AN000; yes - done parsing
 18504                                  	;;cmp	ax,0
 18505                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 18506                                  	;and	ax,ax		;AC000; did we have an error?
 18507                                  	;jnz	short errj2	;AC000; yes exit
 18508                                  	; 10/06/2023
 18509 00001F30 40                      	inc	ax  ; cmp ax,-1
 18510 00001F31 743C                    	jz	short good_line ; 0FFFFh -> 0
 18511 00001F33 48                      	dec	ax  ; cmp ax,0	
 18512 00001F34 7566                    	jnz	short errj2  ; 1 -> 0
 18513                                  	; ax = 0
 18514                                  
 18515 00001F36 813E[59AA][D097]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 18516                                  				;AN000; was /P entered?
 18517 00001F3C 741C                    	je	short set_erase_prompt
 18518                                  				;AN000; yes - go set prompt
 18519                                  ;
 18520                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 18521                                  ;
 18522 00001F3E 56                      	push	si		;AC000; save position in line
 18523 00001F3F C536[5BAA]              	lds	si,[PARSE1_ADDR]
 18524                                  				;AC000; get address of filespec
 18525                                  	;cmp	byte [si+1],colon_char
 18526 00001F43 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 18527 00001F47 750B                    	jne	short erase_drive_ok
 18528                                  				;AC000; no - continue
 18529                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 18530 00001F49 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 18531 00001F4D 7505                    	jne	short erase_drive_ok
 18532                                  				;AC000; no - continue
 18533 00001F4F B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 18534                                  				;AN022; get message number in control block
 18535 00001F52 EB3D                    	jmp	short extend_setup
 18536                                  				;AC000; exit
 18537                                  erase_drive_ok:
 18538 00001F54 E89B12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18539 00001F57 5E                      	pop	si		;AC000; get position back
 18540 00001F58 EBD1                    	jmp	short erase_scan
 18541                                  				;AN000; continue parsing
 18542                                  set_erase_prompt:
 18543 00001F5A 833E[FB9D]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 18544 00001F5F 7408                    	jz	short ok_to_set_erase_prompt
 18545                                  				;AN018; no go set switch
 18546                                  	;mov	ax,1
 18547 00001F61 B80100                  	mov	ax,MoreArgs_Ptr 
 18548                                  				;AN018; set up too many arguments
 18549 00001F64 E8AC07                  	call	setup_parse_error_msg
 18550                                  				;AN018; set up an error message
 18551 00001F67 EB33                    	jmp	short errj2	;AN018; exit
 18552                                  
 18553                                  ok_to_set_erase_prompt: 	;AN018;
 18554 00001F69 FF06[FB9D]              	inc	word [COMSW]	;AN000; indicate /p specified
 18555 00001F6D EBBC                    	jmp	short erase_scan
 18556                                  				;AN000; continue parsing
 18557                                  good_line:			;G  We know line is good
 18558 00001F6F E8530C                  	call	PathCrunch
 18559 00001F72 730D                    	jnc	short checkdr
 18560 00001F74 A1[9AA2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18561                                  	;cmp	ax,0		;AN022; was message flag set?
 18562 00001F77 09C0                    	or	ax,ax
 18563 00001F79 7516                    	jnz	short extend_setup
 18564                                  				;AN022; yes - print out message
 18565                                  	;cmp	byte [DestIsDir],0
 18566 00001F7B 3806[1FA1]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 18567 00001F7F 750D                    	jnz	short badpath_err
 18568                                  				;AC022; see if they should have
 18569                                  checkdr:
 18570 00001F81 833E[FB9D]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 18571 00001F86 7403                    	jz	short notest2j	;AN000; no - go to notest2
 18572 00001F88 E90B1B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 18573                                  notest2j:
 18574 00001F8B E9A31A                  	jmp	notest2
 18575                                  
 18576                                  badpath_err:			;AN022; "Path not found" message
 18577 00001F8E B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 18578                                  				;AN022; set up error number
 18579                                  extend_setup:			;AN022;
 18580                                  	;mov	byte [msg_disp_class],1
 18581 00001F91 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 18582                                  				;AN022; set up extended error msg class
 18583 00001F96 BA[0392]                	mov	dx,extend_buf_ptr
 18584                                  				;AC022; get extended message pointer
 18585 00001F99 A3[0392]                	mov	[extend_buf_ptr],ax
 18586                                  				;AN022; get message number in control block
 18587                                  errj2:				;AC022; exit jump
 18588 00001F9C E9FE0E                  	jmp	cerror		;AN022;
 18589                                  
 18590                                  ; ---------------------------------------------------------------------------
 18591                                  
 18592                                  ; ****************************************************************
 18593                                  ; *
 18594                                  ; * ROUTINE:	 CRENAME - rename file(s)
 18595                                  ; *
 18596                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 18597                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 18598                                  ; *		 Make sure the second filespec only contains a
 18599                                  ; *		 filename. If both openands are valid, attempt
 18600                                  ; *		 to rename the file.
 18601                                  ; *
 18602                                  ; * INPUT:	 command line at offset 81H
 18603                                  ; *
 18604                                  ; * OUTPUT:	 none
 18605                                  ; *
 18606                                  ; ****************************************************************
 18607                                  
 18608                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18609                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18610                                  CRENAME:
 18611                                  	; MSDOS 6.0
 18612                                  	;assume	ds:trangroup,es:trangroup
 18613                                  
 18614 00001F9F BE8100                  	mov	si,81h		;AC000; Point to command line
 18615 00001FA2 BF[DF98]                	mov	di,PARSE_RENAME
 18616                                  				;AN000; Get address of PARSE_RENAME
 18617 00001FA5 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18618 00001FA7 31D2                    	xor	dx,dx		;AN000;
 18619 00001FA9 E85807                  	call	Parse_With_Msg	;AC018; call parser
 18620                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 18621 00001FAC 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18622                                  ;	jz	short crename_no_parse_error
 18623                                  				;AC000; no - continue
 18624 00001FAE 752C                    	jnz	short crename_parse_error
 18625                                  				;AC000; Yes, fail. (need long jump)
 18626                                  ;
 18627                                  ;  Get first file name returned from parse into our buffer
 18628                                  ;
 18629                                  crename_no_parse_error:
 18630 00001FB0 56                      	push	si		;AN000; save position in line
 18631 00001FB1 C536[5BAA]              	lds	si,[PARSE1_ADDR]
 18632                                  				;AN000; get address of filespec
 18633 00001FB5 E83A12                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 18634 00001FB8 5E                      	pop	si		;AN000; restore position in line
 18635                                  
 18636 00001FB9 31D2                    	xor	dx,dx		;AN000; clear dx
 18637 00001FBB E84607                  	call	Parse_With_Msg	;AC018; call parser
 18638                                  	;cmp	ax,RESULT_NO_ERROR
 18639 00001FBE 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 18640 00001FC0 751A                    	jnz	short crename_parse_error
 18641                                  				;AN000; Yes, fail.
 18642                                  ;
 18643                                  ;  Check the second file name for drive letter colon
 18644                                  ;
 18645 00001FC2 56                      	push	si		;AN000; save position in line
 18646 00001FC3 C536[5BAA]              	lds	si,[PARSE1_ADDR]
 18647                                  				;AC000; get address of path
 18648                                  	;mov	al,':'		;AC000;
 18649                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 18650 00001FC7 807C013A                	cmp	byte [si+1],':'
 18651 00001FCB 7511                    	jnz	short ren_no_drive
 18652                                  				;AN000; Yes, error
 18653                                  	;mov	byte [msg_disp_class],2
 18654 00001FCD C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class
 18655                                  				;AN000; set up parse error msg class
 18656 00001FD2 BA[0392]                	mov	dx,extend_buf_ptr
 18657                                  				;AC000; get extended message pointer
 18658                                  	;mov	word [extend_buf_ptr],0Ah
 18659 00001FD5 C706[0392]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 18660                                  				;AN000; get "Invalid parameter" message number
 18661 00001FDB 5E                      	pop	si		;AN000;
 18662                                  crename_parse_error:		;AC022;
 18663 00001FDC EB64                    	jmp	short errj	;AC000;
 18664                                  
 18665                                  ;  Get second file name returned from parse into the fCB. Save
 18666                                  ;  character after file name so we can later check to make sure it
 18667                                  ;  isn't a path character.
 18668                                  
 18669                                  ren_no_drive:
 18670 00001FDE BF6C00                  	mov	di,FCB+10h ; 6Ch
 18671                                  				;AC000; set up to parse second file name
 18672                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 18673 00001FE1 B80129                  	mov	ax,2901h
 18674 00001FE4 CD21                    	int	21h		;AC000; do the function
 18675 00001FE6 AC                      	lodsb			;AC000; Load char after filename
 18676 00001FE7 A2[17A1]                	mov	[One_Char_Val],al
 18677                                  				;AN000; save char after filename
 18678 00001FEA 5E                      	pop	si		;AN000; get line position back
 18679                                  ;
 18680                                  ; We have source and target. See if any args beyond.
 18681                                  ;
 18682 00001FEB BF[DF98]                	mov	di,PARSE_RENAME
 18683                                  				;AC000; get address of parse_rename
 18684 00001FEE E8FD06                  	call	parse_check_eol ;AC000; are we at end of line?
 18685 00001FF1 75E9                    	jnz	short crename_parse_error
 18686                                  				;AN000; no, fail.
 18687 00001FF3 E8CF0B                  	call	PathCrunch
 18688 00001FF6 BA[1492]                	mov	dx,BADCPMES_PTR
 18689 00001FF9 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 18690 00001FFB 730F                    	jnc	short notest3
 18691 00001FFD A1[9AA2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18692                                  	;cmp	ax,0		;AN022; was message flag set?
 18693 00002000 21C0                    	and	ax,ax ; 0 ?
 18694 00002002 758D                    	jnz	short extend_setup
 18695                                  				;AN022; yes - print out message
 18696                                  	;cmp	byte [DestIsDir],0
 18697 00002004 3806[1FA1]              	cmp	[DestIsDir],al	; No CHDIRs worked
 18698 00002008 7402                    	jz	short notest3 	; see if they should have
 18699 0000200A EB82                    	Jmp	badpath_err	;AC022; set up error
 18700                                  notest3:
 18701 0000200C A0[17A1]                	mov	al,[One_Char_Val]
 18702                                  				;AN000; move char into AX
 18703 0000200F BA[3292]                	mov	dx,INORNOT_PTR 
 18704                                  				; Load invalid fname error ptr
 18705 00002012 E8A20B                  	call	pathchrcmp	; Is the char in al a path sep?
 18706 00002015 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 18707                                  				;  filename only.
 18708                                  	;mov	ah,FCB_Rename
 18709 00002017 B417                    	mov	ah,17h
 18710 00002019 BA5C00                  	mov	dx,FCB ; 5Ch
 18711 0000201C CD21                    	int	21h
 18712 0000201E 3CFF                    	cmp	al,0FFh		; Did an error occur??
 18713 00002020 7506                    	jne	short renameok
 18714                                  
 18715 00002022 E82902                  	call	get_ext_error_number
 18716                                  				;AN022; get extended error
 18717 00002025 50                      	push	ax		;AC022; Save results
 18718 00002026 B0FF                    	mov	al,0FFh		; Restore original error state
 18719                                  renameok:
 18720 00002028 50                      	push	ax
 18721 00002029 E8AD09                  	call	RestUDir
 18722 0000202C 58                      	pop	ax
 18723 0000202D FEC0                    	inc	al
 18724                                  	;;retnz
 18725                                  	;jz	short rn1
 18726                                  	;retn	
 18727 0000202F 7514                    	jnz	short ret56
 18728                                  rn1:
 18729 00002031 58                      	pop	ax		;AC022; get the error number back
 18730 00002032 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 18731                                  				;AN022; error file not found?
 18732 00002035 7408                    	je	short use_renerr
 18733                                  				;AN022; yes - use generic error message
 18734 00002037 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 18735                                  				;AN022; error file not found?
 18736 0000203A 7403                    	je	short use_renerr
 18737                                  				;AN022; yes - use generic error message
 18738 0000203C E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 18739                                  
 18740                                  use_renerr:
 18741 0000203F BA[1192]                	mov	dx,RENERR_PTR	;AC022;
 18742                                  errj:
 18743 00002042 E9580E                  	jmp	cerror
 18744                                  ret56:
 18745                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 18746 00002045 C3                      	retn
 18747                                  
 18748                                  ; ---------------------------------------------------------------------------
 18749                                  
 18750                                  ;****************************************************************
 18751                                  ;*
 18752                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 18753                                  ;*		standard output device
 18754                                  ;*
 18755                                  ;* SYNTAX:	TYPE filespec
 18756                                  ;*
 18757                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 18758                                  ;*		1Ah and display the contents to STDOUT.
 18759                                  ;*
 18760                                  ;* INPUT:	command line at offset 81H
 18761                                  ;*
 18762                                  ;* OUTPUT:	none
 18763                                  ;*
 18764                                  ;****************************************************************
 18765                                  
 18766                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18767                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18768                                  TYPEFIL:
 18769                                  	; MSDOS 6.0	
 18770                                  	;assume	ds:trangroup,es:trangroup
 18771                                  
 18772 00002046 BE8100                  	mov	si,81h
 18773 00002049 BF[4B98]                	mov	di,PARSE_MRDIR
 18774                                  				;AN000; Get address of PARSE_MRDIR
 18775 0000204C 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18776 0000204E 31D2                    	xor	dx,dx		;AN000;
 18777 00002050 E8B106                  	call	Parse_With_Msg	;AC018; call parser
 18778                                  	;cmp	ax,RESULT_NO_ERROR
 18779 00002053 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18780 00002055 751E                    	jnz	short typefil_parse_error
 18781                                  				;AN000; yes - issue error message
 18782                                  
 18783 00002057 56                      	push	si		;AC000; save position in line
 18784 00002058 C536[5BAA]              	lds	si,[PARSE1_ADDR]
 18785                                  				;AC000; get address of filespec
 18786 0000205C E89311                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18787 0000205F 5E                      	pop	si		;AC000; get position back
 18788 00002060 BF[4B98]                	mov	di,PARSE_MRDIR
 18789                                  				;AC000; get address of parse_mrdir
 18790 00002063 E88806                  	call	parse_check_eol ;AC000; are we at end of line?
 18791                                  	;jz	short gottarg 	;AC000; yes - continue
 18792                                  	; 20/02/2023
 18793                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 18794                                  	;jmp	cerror
 18795 00002066 750D                    	jnz	short typefil_parse_error
 18796                                  gottarg:
 18797 00002068 E8CC0F                  	call	SETPATH
 18798 0000206B F606[23A1]02            	test	byte [DestInfo],00000010b ; 2
 18799                                  				; Does the filespec contain wildcards
 18800 00002070 7406                    	jz	short nowilds 	; No, continue processing
 18801 00002072 BA[3292]                	mov	dx,INORNOT_PTR	; Yes, report error
 18802                                  	; 20/02/2023
 18803                                  typefil_parse_error:
 18804 00002075 E9250E                  	jmp	cerror
 18805                                  nowilds:
 18806                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 18807 00002078 B8006C                  	mov	ax,6C00h
 18808                                  	;mov	bx,read_open_mode ; 0
 18809                                  				;AN000; get open mode for TYPE
 18810 0000207B 31C9                    	xor	cx,cx		;AN000; no special files
 18811 0000207D 89CB                    	mov	bx,cx ; 20/02/2023
 18812 0000207F BA0101                  	mov	dx,101h
 18813                                  	;mov	dx,read_open_flag ; 101h
 18814                                  				;AN000; set up open flags
 18815 00002082 BE[87A1]                	mov	si,SrcBuf	;AN030; get file name
 18816 00002085 CD21                    	int	21h
 18817 00002087 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 18818                                  
 18819                                  typerr: 			;AN022;
 18820 00002089 0E                      	push	cs		;AN022; make sure we have local segment
 18821 0000208A 1F                      	pop	ds		;AN022;
 18822 0000208B E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 18823 0000208E C706[06A1][87A1]        	mov	word [string_ptr_2],SrcBuf 
 18824                                  				;AC022; get address of failed string
 18825                                  	;mov	byte [extend_buf_sub],1
 18826 00002094 C606[0592]01            	mov	byte [extend_buf_sub],one_subst
 18827                                  				;AC022; put number of subst in control block
 18828 00002099 E9010E                  	jmp	cerror		;AC022; exit
 18829                                  
 18830                                  typecont:
 18831 0000209C 89C3                    	mov	bx,ax		;AC000; get Handle
 18832                                  ;M043
 18833                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 18834                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 18835                                  ;indicate it is a device.
 18836                                  ;
 18837                                  	;mov	ax,(IOCTL shl 8) or 0
 18838 0000209E B80044                  	mov	ax,4400h
 18839 000020A1 CD21                    	int	21h
 18840                                  
 18841 000020A3 F6C280                  	test	dl,80h		;is it a device?
 18842 000020A6 7408                    	jz	short not_device
 18843                                  				;no, a file
 18844                                  
 18845 000020A8 C706[55AA]FFFF          	mov	word [TypeFilSiz+2],-1 ; 0FFFFh
 18846                                  				;indicate it is a device
 18847 000020AE EB17                    	jmp	short dotype
 18848                                  not_device:
 18849                                  ;SR;
 18850                                  ; Find the filesize by seeking to the end and then reset file pointer to
 18851                                  ;start of file
 18852                                  
 18853                                  	;mov	ax,(LSEEK shl 8) or 2
 18854 000020B0 B80242                  	mov	ax,4202h
 18855 000020B3 31D2                    	xor	dx,dx
 18856 000020B5 89D1                    	mov	cx,dx		;seek  to end of file
 18857 000020B7 CD21                    	int	21h
 18858                                  
 18859 000020B9 A3[53AA]                	mov	[TypeFilSiz],ax
 18860 000020BC 8916[55AA]              	mov	[TypeFilSiz+2],dx ;store filesize
 18861                                  	;mov	ax,(LSEEK shl 8) or 0
 18862 000020C0 B80042                  	mov	ax,4200h
 18863 000020C3 31D2                    	xor	dx,dx
 18864 000020C5 CD21                    	int	21h	        ;reset file pointer to start
 18865                                  dotype:				;M043
 18866 000020C7 C606[04A9]00            	mov	byte [zflag],0 	; Reset ^Z flag
 18867 000020CC 8E1E[E69D]              	mov	ds,[TPA]
 18868 000020D0 31D2                    	xor	dx,dx
 18869                                  	;ASSUME	DS:NOTHING
 18870                                  typelp:
 18871 000020D2 2E803E[04A9]00          	cmp	byte [cs:zflag],0
 18872                                  				;AC050; Is the ^Z flag set?
 18873                                  	;retnz			; Yes, return
 18874                                  	; 17/04/2023
 18875 000020D8 7401                    	jz	short tf1
 18876 000020DA C3                      	retn
 18877                                  tf1:
 18878 000020DB 2E8B0E[059E]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 18879                                  
 18880                                  ;Update the filesize left to read
 18881                                  
 18882 000020E0 2E833E[55AA]FF          	cmp	word [cs:TypeFilSiz+2],-1
 18883                                  				;is it a device? M043
 18884 000020E6 7431                    	je	short typ_read	;yes, just read from it; M043
 18885                                  
 18886 000020E8 2E833E[55AA]00          	cmp	word [cs:TypeFilSiz+2],0
 18887                                  				;more than 64K left?
 18888 000020EE 740D                    	jz	short lt64k	;no, do word subtraction
 18889 000020F0 2E290E[53AA]            	sub	[cs:TypeFilSiz],cx
 18890 000020F5 2E831E[55AA]00          	sbb	word [cs:TypeFilSiz+2],0
 18891                                  				;update filesize
 18892 000020FB EB1C                          	jmp	short typ_read	;do the read
 18893                                  lt64k:
 18894 000020FD 2E3B0E[53AA]            	cmp	cx,[cs:TypeFilSiz]
 18895                                  				;readsize <= buffer?
 18896 00002102 7610                    	jbe	short gtbuf	; yes, just update readsize
 18897                                  
 18898                                  ;Buffer size is larger than bytes to read
 18899                                  
 18900 00002104 2E8B0E[53AA]            	mov	cx,[cs:TypeFilSiz]
 18901 00002109 E361                    	jcxz	typelp_ret
 18902 0000210B 2EC706[53AA]0000        	mov	word [cs:TypeFilSiz],0
 18903 00002112 EB05                    	jmp	short typ_read
 18904                                  gtbuf:
 18905 00002114 2E290E[53AA]            	sub	[cs:TypeFilSiz],cx
 18906                                  				;update filesize remaining
 18907                                  typ_read:
 18908                                  	;mov	ah,read
 18909 00002119 B43F                    	mov	ah,3Fh
 18910 0000211B CD21                    	int	21h		
 18911 0000211D 7303                    	jnc	short tf2	;M043
 18912 0000211F E967FF                  	jmp	typerr		;M043
 18913                                  tf2:				;M043
 18914                                  ;M043;	jc	typerr		;AN022; Exit if error
 18915                                  
 18916 00002122 89C1                    	mov	cx,ax
 18917 00002124 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 18918 00002126 1E                      	push	ds
 18919 00002127 07                      	pop	es		; Check to see if a ^Z was read.
 18920                                  	;assume es:nothing
 18921 00002128 31FF                    	xor	di,di
 18922 0000212A 50                      	push	ax
 18923 0000212B B01A                    	mov	al,1Ah
 18924 0000212D F2AE                    	repnz	scasb
 18925 0000212F 58                      	pop	ax
 18926 00002130 91                      	xchg	ax,cx
 18927                                  	;cmp	ax,0
 18928 00002131 21C0                    	and	ax,ax
 18929 00002133 7506                    	jnz	short foundz	; Yes, handle it
 18930 00002135 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 18931 00002139 750A                    	jnz	short typecont2	; No ^Z, continue
 18932                                  foundz:
 18933 0000213B 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 18934 0000213D 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 18935 0000213E 0E                      	push	cs		;  will be typed.
 18936 0000213F 07                      	pop	es
 18937                                  	;assume es:trangroup
 18938 00002140 26F616[04A9]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 18939                                  typecont2:			;  will quit after this write.
 18940 00002145 53                      	push	bx
 18941 00002146 BB0100                  	mov	bx,1
 18942                                  	;mov	ah,Write
 18943 00002149 B440                    	mov	ah,40h
 18944 0000214B CD21                    	int	21h
 18945 0000214D 5B                      	pop	bx
 18946 0000214E 720C                    	jc	short Error_outputj
 18947 00002150 39C8                    	cmp	ax,cx
 18948 00002152 7503                    	jnz	short tf3	;M043
 18949 00002154 E97BFF                  	jmp	typelp		;M043
 18950                                  tf3:				;M043
 18951                                  ;M043;	jz	short typelp
 18952 00002157 49                      	dec	cx
 18953 00002158 39C8                    	cmp	ax,cx
 18954                                  	;;retz			; One less byte OK (^Z)
 18955                                  	;jnz	short Error_outputj
 18956                                  ;tf4:
 18957                                  	;retn
 18958 0000215A 7410                    	jz	short typelp_ret ; 20/02/2023
 18959                                  
 18960                                  Error_outputj:
 18961 0000215C BB0100                  	mov	bx,1
 18962                                  	;mov	ax,IOCTL SHL 8
 18963 0000215F B80044                  	mov	ax,4400h
 18964 00002162 CD21                    	int	21h
 18965 00002164 F6C280                  	test	dl,80h
 18966                                  	;test	dl,devid_ISDEV
 18967                                  	;;retnz			; If device, no error message
 18968                                  	;jnz	short tf4
 18969 00002167 7503                    	jnz	short typelp_ret
 18970 00002169 E9310A                  	jmp	error_output
 18971                                  typelp_ret:
 18972 0000216C C3                      	retn
 18973                                  
 18974                                  ; ---------------------------------------------------------------------------
 18975                                  
 18976                                  ; VOLUME command displays the volume ID on the specified drive
 18977                                  
 18978                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18979                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18980                                  	; 10/06/2023
 18981                                  VOLUME:
 18982                                  	; MSDOS 6.0
 18983 0000216D BE8100                  	mov	si,81h
 18984 00002170 BF[3998]                	mov	di,PARSE_VOL
 18985                                  				;AN000; Get address of PARSE_VOL
 18986 00002173 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18987 00002175 31D2                    	xor	dx,dx		;AN000;
 18988 00002177 E88A05                  	call	Parse_With_Msg	;AC018; call parser
 18989                                  
 18990                                  	;cmp	ax,-1 ; 0FFFFh
 18991                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 18992                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 18993                                  	;;cmp	ax,RESULT_NO_ERROR
 18994                                  	;;cmp	ax,0		;AC000; did we have an error?
 18995                                  	;or	ax,ax ; 0?
 18996                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 18997                                  	; 10/06/2023
 18998 0000217A 40                      	inc	ax  ; cmp ax,-1
 18999 0000217B 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 19000 0000217D 48                      	dec	ax  ; cmp ax,0
 19001 0000217E 750A                    	jnz	short badvolarg ; 1 -> 0
 19002                                  	; ax = 0
 19003                                  
 19004                                  ; We have parsed off the drive. See if there are any more chars left
 19005                                  
 19006 00002180 BF[3998]                	mov	di,PARSE_VOL
 19007                                  				;AC000; get address of parse_vol
 19008 00002183 31D2                    	xor	dx,dx		;AC000;
 19009 00002185 E86605                  	call	parse_check_eol ;AC000; call parser
 19010 00002188 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 19011                                  
 19012                                  ; The line was not interpretable. Report an error.
 19013                                  
 19014                                  badvolarg:
 19015 0000218A E9100D                  	jmp	cerror
 19016                                  
 19017                                  ; ---------------------------------------------------------------------------
 19018                                  
 19019                                  ;***	DisAppend - disable APPEND
 19020                                  ;
 19021                                  ;	ENTRY	nothing
 19022                                  ;
 19023                                  ;	EXIT	nothing
 19024                                  ;
 19025                                  ;	USED	AX,BX
 19026                                  ;
 19027                                  ;	EFFECTS
 19028                                  ;
 19029                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 19030                                  ;	  after the command finishes, by the HeadFix routine.
 19031                                  ;
 19032                                  ;	NOTE
 19033                                  ;
 19034                                  ;	  This routine must not be called more than once during a single
 19035                                  ;	  command cycle. The second call would permanently disable APPEND.
 19036                                  
 19037                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19038                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 19039                                  	
 19040                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19041                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2289h
 19042                                  
 19043                                  	; MSDOS 6.0
 19044                                  DisAppend:
 19045 0000218D 1E                      	push	ds			; save DS
 19046 0000218E 06                      	push	es			; save ES
 19047 0000218F 57                      	push	di
 19048                                  
 19049                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 19050 00002190 B800B7                  	mov	ax,0B700h
 19051 00002193 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19052 00002195 08C0                    	or	al,al
 19053 00002197 7423                    	jz	short daRet		; APPEND not installed, return
 19054                                  
 19055                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 19056 00002199 B802B7                  	mov	ax,0B702h
 19057 0000219C CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19058 0000219E 83F8FF                  	cmp	ax,0FFFFh
 19059 000021A1 7519                    	jne	short daRet		; it's not a local version, return
 19060                                  
 19061                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 19062 000021A3 B806B7                  	mov	ax,0B706h
 19063 000021A6 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19064                                  
 19065 000021A8 8E1E[E49D]              	mov	ds,[RESSEG]		; DS = resident seg addr
 19066                                  
 19067 000021AC 891E[7E02]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 19068 000021B0 C606[8002]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 19069                                  
 19070 000021B5 31DB                    	xor	bx,bx			; BX = APPEND state = off
 19071                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 19072 000021B7 B807B7                  	mov	ax,0B707h
 19073 000021BA CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19074                                  daRet:	
 19075 000021BC 5F                      	pop	di
 19076 000021BD 07                      	pop	es			; restore ES
 19077 000021BE 1F                      	pop	ds			; restore DS
 19078                                  
 19079 000021BF C3                      	retn
 19080                                  
 19081                                  ; ---------------------------------------------------------------------------
 19082                                  
 19083                                  ; Find the Volume ID on the disk.
 19084                                  
 19085                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19086                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19087                                  	
 19088                                  	; MSDOS 6.0
 19089                                  OkVolArg:
 19090 000021C0 E8CAFF                  	call	DisAppend		; disable APPEND
 19091 000021C3 E85609                  	call	CRLF2
 19092                                  	;mov	al,blank			
 19093 000021C6 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19094 000021C8 E87D01                  	call	PRINT_CHAR		;AN051;  before volume message
 19095 000021CB 1E                      	push	ds
 19096 000021CC 07                      	pop	es
 19097                                  
 19098                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 19099                                  ; of volume_id ONLY.
 19100                                  
 19101 000021CD BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 19102 000021D0 B0FF                    	mov	al,-1 ; 0FFh		; Tag to indicate Extention
 19103 000021D2 AA                      	stosb
 19104 000021D3 31C0                    	xor	ax,ax			; Zero padding to volume label
 19105 000021D5 AB                      	stosw
 19106 000021D6 AB                      	stosw
 19107 000021D7 AA                      	stosb
 19108 000021D8 B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 19109 000021DA AA                      	stosb
 19110 000021DB 47                      	inc	di			; Skip drive byte; it is already set
 19111 000021DC B90B00                  	mov	cx,11			; fill in remainder of file
 19112 000021DF B03F                    	mov	al,'?'
 19113 000021E1 F3AA                    	rep	stosb
 19114                                  
 19115                                  ; Set up transfer address (destination of search first information)
 19116                                  
 19117 000021E3 BA[1FA0]                	mov	dx,DIRBUF
 19118                                  	;mov	ah,Set_DMA
 19119 000021E6 B41A                    	mov	ah,1Ah
 19120 000021E8 CD21                    	int	21h
 19121                                  
 19122                                  ; Do the search
 19123                                  
 19124 000021EA BA5500                  	mov	dx,FCB-7 ; 55h
 19125                                  	;mov	ah,Dir_Search_First
 19126 000021ED B411                    	mov	ah,11h
 19127 000021EF CD21                    	int	21h
 19128                                  
 19129                                  ;********************************
 19130                                  ; Print volume ID info
 19131                                  
 19132 000021F1 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 19133 000021F2 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 19134 000021F5 0440                    	add	al,'@'  ; add al,40h
 19135 000021F7 3C40                    	cmp	al,'@'
 19136 000021F9 7505                    	jne	short drvok
 19137 000021FB A0[F89D]                	mov	al,[CURDRV]
 19138                                  	;add	al,capital_A
 19139 000021FE 0441                    	add	al,'A'
 19140                                  drvok:
 19141 00002200 A2[19A1]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 19142 00002203 58                      	pop	ax			;AC000; get return code back
 19143 00002204 08C0                    	or	al,al			;AC000; volume label found?
 19144 00002206 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 19145 00002208 BA[FE92]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 19146 0000220B EB13                    	jmp	short print_serial	;AC000; go print it
 19147                                  
 19148                                  Get_vol_name:
 19149 0000220D BF[509F]                	mov	di,CHARBUF
 19150 00002210 89FA                    	mov	dx,di
 19151 00002212 BE[27A0]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 19152 00002215 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 19153 00002218 F3A4                    	rep	movsb			;AN000;  3/3/KK
 19154                                  
 19155 0000221A 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 19156 0000221C AA                      	stosb
 19157 0000221D BA[0C93]                	mov	dx,VolMes_Ptr		;AC000; set up message
 19158                                  
 19159                                  print_serial:
 19160                                  
 19161                                  ; Attempt to get the volume serial number from the disk. If an error
 19162                                  ; occurs, do not print volume serial number.
 19163                                  
 19164 00002220 52                      	push	dx			;AN000; save message offset
 19165                                  	;mov	ax,(GetSetMediaID SHL 8)
 19166 00002221 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 19167 00002224 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 19168 00002228 BA[7FA2]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 19169 0000222B CD21                    	int	21h			;AN000; do the call
 19170                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 19171                                  			; AL = 00h get serial number / 01h set serial number
 19172                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 19173                                  			; DS:DX -> disk info
 19174 0000222D 5A                      	pop	dx			;AN000; get message offset back
 19175 0000222E 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 19176 00002230 E80A33                  	call	std_printf		;AC000; go print volume message
 19177                                  	;mov	al,blank				
 19178 00002233 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19179 00002235 E81001                  	call	PRINT_CHAR		;AN051;  before volume message
 19180 00002238 BA[2593]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 19181                                  printvol_end:
 19182 0000223B E9FF32                  	jmp	std_printf		;AC000; go print and exit
 19183                                  
 19184                                  ; ---------------------------------------------------------------------------
 19185                                  
 19186                                  ;****************************************************************
 19187                                  ;*
 19188                                  ;* ROUTINE:	Set_ext_error_msg
 19189                                  ;*
 19190                                  ;* FUNCTION:	Sets up extended error message for printing
 19191                                  ;*
 19192                                  ;* INPUT:	return from INT 21
 19193                                  ;*
 19194                                  ;* OUTPUT:	extended error message set up in extended error
 19195                                  ;*		buffer.
 19196                                  ;*
 19197                                  ;****************************************************************
 19198                                  	
 19199                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19200                                  
 19201                                  	; MSDOS 6.0
 19202                                  Set_Ext_Error_Msg:			;AN000;
 19203 0000223E E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 19204 00002241 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 19205                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 19206 00002246 BA[0392]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 19207 00002249 A3[0392]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 19208 0000224C F9                      	stc				;AN000; make sure carry is set
 19209 0000224D C3                      	retn				;AN000; return
 19210                                  
 19211                                  ; ---------------------------------------------------------------------------
 19212                                  
 19213                                  ;****************************************************************
 19214                                  ;*
 19215                                  ;* ROUTINE:	Get_ext_error_number
 19216                                  ;*
 19217                                  ;* FUNCTION:	Does get extended error function call
 19218                                  ;*
 19219                                  ;* INPUT:	return from INT 21
 19220                                  ;*
 19221                                  ;* OUTPUT:	AX - extended error number
 19222                                  ;*
 19223                                  ;****************************************************************
 19224                                  
 19225                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19226                                  
 19227                                  	; MSDOS 6.0
 19228                                  get_ext_error_number:			;AN022;
 19229                                  
 19230                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 19231                                  					;AN022; save registers
 19232 0000224E 53                      	push	bx
 19233 0000224F 51                      	push	cx
 19234 00002250 52                      	push	dx
 19235 00002251 56                      	push	si
 19236 00002252 57                      	push	di
 19237 00002253 55                      	push	bp
 19238 00002254 06                      	push	es
 19239 00002255 1E                      	push	ds
 19240                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 19241 00002256 B459                    	mov	ah,59h
 19242 00002258 31DB                    	xor	bx,bx			;AN022; clear BX
 19243 0000225A CD21                    	int	21h			;AN022;
 19244                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 19245                                  			; BX = version code (0000h for DOS 3.x)
 19246                                  
 19247                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 19248                                  					;AN022; restore registers
 19249 0000225C 1F                      	pop	ds
 19250 0000225D 07                      	pop	es
 19251 0000225E 5D                      	pop	bp
 19252 0000225F 5F                      	pop	di
 19253 00002260 5E                      	pop	si
 19254 00002261 5A                      	pop	dx
 19255 00002262 59                      	pop	cx
 19256 00002263 5B                      	pop	bx
 19257                                  
 19258 00002264 C3                      	retn				;AN022; return
 19259                                  
 19260                                  ;============================================================================
 19261                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 19262                                  ;============================================================================
 19263                                  ; 08/10/2018 - Retro DOS v3.0
 19264                                  
 19265                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 19266                                  
 19267                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19268                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 19269                                  
 19270                                  ; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19271                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 2361h
 19272                                  
 19273                                  ; ---------------------------------------------------------------------------
 19274                                  
 19275                                  ; MSDOS 6.0
 19276                                  ;***	Version - display DOS version
 19277                                  ;
 19278                                  ;	SYNTAX	ver [/debug]
 19279                                  ;
 19280                                  ;		/debug - display additional DOS configuration info
 19281                                  ;
 19282                                  ;	ENTRY	command-line tail is in PSP
 19283                                  ;
 19284                                  ;	EXIT	if successful, nothing
 19285                                  ;		if parse fails,
 19286                                  ;		  parse error message is set up (for Std_EPrintf)
 19287                                  ;		    AX = system parser error code
 19288                                  ;		    DX = ptr to message block
 19289                                  ;		  we jump to CError
 19290                                  ;
 19291                                  ;	EFFECTS
 19292                                  ;	  If parse fails, a parse error message is displayed.
 19293                                  ;	  Otherwise, version message is displayed.
 19294                                  ;	  If /debug is specified, additional DOS info is displayed.
 19295                                  
 19296                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19297                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19298                                  VERSION:
 19299                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 19300                                  
 19301                                  ;	Parse command line for /debug switch.
 19302                                  
 19303 00002265 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 19304 00002268 BF[FC98]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 19305 0000226B 31C9                    	xor	cx,cx			; CX = # positional param's found
 19306 0000226D E89404                  	call	Parse_With_Msg
 19307                                  
 19308 00002270 B301                    	mov	bl,1			; BL = flag = /debug present
 19309                                  	;cmp	ax,RESULT_NO_ERROR
 19310                                  	;cmp	ax,0
 19311                                  	;je	short verPrintVer	; something parsed - must be /debug
 19312 00002272 09C0                    	or	ax,ax
 19313 00002274 740A                    	jz	short verPrintVer 
 19314 00002276 FECB                    	dec	bl			; BL = flag = no /debug present
 19315                                  	;cmp	ax,END_OF_LINE ; -1
 19316 00002278 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 19317 0000227B 7403                    	je	short verPrintVer	; reached end of line - ok
 19318                                  
 19319                                  ;	The parse failed. Error message has been set up.
 19320                                  
 19321 0000227D E91D0C                  	jmp	cerror
 19322                                  
 19323                                  verPrintVer:
 19324 00002280 53                      	push	bx			; save /debug flag
 19325 00002281 E89808                  	call	CRLF2
 19326 00002284 E83F00                  	call	PRINT_VERSION
 19327 00002287 E89208                  	call	CRLF2
 19328 0000228A 5B                      	pop	bx   			; BL = /debug flag
 19329 0000228B 08DB                    	or	bl,bl
 19330 0000228D 7434                    	jz	short verDone		; /debug is false - we're done
 19331                                  
 19332                                  ;*	For /debug, display DOS internal revision and DOS location
 19333                                  ;	(low memory, HMA, or ROM).
 19334                                  
 19335                                  ;	Bugbug:	use symbols for bitmasks below.
 19336                                  
 19337                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 19338 0000228F B80633                  	mov	ax,3306h
 19339 00002292 CD21                    	int	21h
 19340                                  		; DOS - 5+ Get TRUE Version Number
 19341                                  		; (BL major, BH minor, DL revision, DH flags)
 19342 00002294 88D0                    	mov	al,dl			;revision number in dl; M013
 19343 00002296 88F7                    	mov	bh,dh			;flags in dh now; M013
 19344                                  ;M032	and	al,7			; AL = DOS internal revision
 19345 00002298 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 19346                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 19347 0000229A 7602                    	jbe	short ver1
 19348 0000229C B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 19349                                  ;@@:
 19350                                  ver1:
 19351 0000229E 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 19352 000022A0 A2[17A1]                	mov	[One_Char_Val],al
 19353 000022A3 BA[5C94]                	mov	dx,dosrev_ptr
 19354 000022A6 E89432                  	call	std_printf		; print DOS internal revision
 19355                                  
 19356 000022A9 B104                    	mov	cl,4
 19357 000022AB D2EF                    	shr	bh,cl			; CY = DOS in ROM
 19358 000022AD 7209                    	jc	short verRom
 19359 000022AF D0EF                    	shr	bh,1			; CY = DOS in HMA
 19360 000022B1 720A                    	jc	short verHma
 19361                                  
 19362                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 19363                                  
 19364                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 19365 000022B3 BA[7094]                	mov	dx,DosLow_Ptr
 19366 000022B6 EB08                    	jmp	short verPrintLoc
 19367                                  verRom: 
 19368                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 19369 000022B8 BA[6A94]                	mov	dx,DosRom_Ptr
 19370 000022BB EB03                    	jmp	short verPrintLoc
 19371                                  verHma: 
 19372                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 19373 000022BD BA[6D94]                	mov	dx,DosHma_Ptr
 19374                                  verPrintLoc:
 19375 000022C0 E87A32                  	call	std_printf
 19376                                  verDone:
 19377 000022C3 E95608                  	jmp	CRLF2
 19378                                  
 19379                                  ; 21/02/2023
 19380                                  ;	; MSDOS 3.3
 19381                                  ;VERSION:
 19382                                  ;	call	CRLF2
 19383                                  ;	call	PRINT_VERSION
 19384                                  ;	jmp	CRLF2
 19385                                  
 19386                                  ; =============== S U B	R O U T	I N E =======================================
 19387                                  
 19388                                  	; 21/02/2023 - Retro DOS v4.0
 19389                                  PRINT_VERSION:
 19390                                  	;mov	ah,GET_VERSION ; 30h
 19391 000022C6 B430                    	mov	ah,30h
 19392 000022C8 CD21                    	int	21h	; DOS -	GET DOS	VERSION
 19393                                  			; Return: AL = major version number (00h for DOS 1.x)
 19394 000022CA 50                      	push	ax
 19395 000022CB 30E4                    	xor	ah,ah
 19396 000022CD A3[13A1]                	mov	[Major_Ver_Num],ax
 19397 000022D0 58                      	pop	ax
 19398 000022D1 86E0                    	xchg	ah,al
 19399 000022D3 30E4                    	xor	ah,ah
 19400 000022D5 A3[15A1]                	mov	[Minor_Ver_Num],ax
 19401 000022D8 BA[E592]                	mov	dx,VerMes_Ptr
 19402 000022DB E95F32                  	jmp	std_printf
 19403                                  
 19404                                  ; =============== S U B	R O U T	I N E =======================================
 19405                                  
 19406                                  	; 21/02/2023 - Retro DOS v4.0
 19407                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19408                                  PRINT_PROMPT:
 19409 000022DE 1E                      	push	ds
 19410 000022DF 0E                      	push	cs
 19411 000022E0 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 19412 000022E1 06                      	push	es
 19413 000022E2 E87805                  	call	find_prompt	; Look for prompt string
 19414 000022E5 7206                    	jc	short PP0	; Can't find one	
 19415 000022E7 26803D00                	cmp	byte [es:di],0
 19416 000022EB 7524                    	jnz	short PP1
 19417                                  PP0:				; Use default prompt
 19418 000022ED E86700                  	call	PRINT_DRIVE
 19419 000022F0 B03E                    	mov	al,'>'
 19420                                  	;mov	al,SYM
 19421 000022F2 E85300                  	call	PRINT_CHAR
 19422 000022F5 EB36                    	jmp	short PP5
 19423                                  ;PP1:
 19424                                  ;	mov	al,[es:di]	; Get a char
 19425                                  ;	inc	di
 19426                                  ;	or	al,al
 19427                                  ;	jz	short PP5	; Nul terminated
 19428                                  ;	; 21/02/2023
 19429                                  ;	cmp	al,'$' ; 24h
 19430                                  ;	;cmp	al,[DOLLAR]	; Meta character
 19431                                  ;	jz	short PP2	; Nope
 19432                                  ;	call	PRINT_CHAR
 19433                                  ;	jmp	short PP1
 19434                                  PP2:
 19435 000022F7 268A05                  	mov	al,[es:di]
 19436 000022FA 47                      	inc	di
 19437                                  	;mov	bx,CLSSTRING+2	; "[2J"
 19438 000022FB BB[CA95]                	mov	bx,PROMPT_TABLE-3
 19439 000022FE 08C0                    	or	al,al
 19440 00002300 742B                    	jz	short PP5
 19441                                  PP3:
 19442 00002302 83C303                  	add	bx,3
 19443                                  	; 21/02/2023
 19444 00002305 E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 19445                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 19446 00002308 3A07                    	cmp	al,[bx]
 19447 0000230A 7416                    	jz	short PP4
 19448 0000230C 803F00                  	cmp	byte [bx],0
 19449 0000230F 75F1                    	jnz	short PP3
 19450                                  	;jmp	short PP1
 19451                                  	; 21/02/2023
 19452                                  PP1:
 19453 00002311 268A05                  	mov	al,[es:di]	; Get a char
 19454 00002314 47                      	inc	di
 19455 00002315 08C0                    	or	al,al
 19456 00002317 7414                    	jz	short PP5	; Nul terminated
 19457                                  	; 21/02/2023
 19458 00002319 3C24                    	cmp	al,'$' ; 24h
 19459                                  	;cmp	al,[DOLLAR]	; Meta character
 19460 0000231B 74DA                    	jz	short PP2	; Nope
 19461 0000231D E82800                  	call	PRINT_CHAR
 19462 00002320 EBEF                    	jmp	short PP1
 19463                                  PP4:
 19464 00002322 06                      	push	es
 19465 00002323 57                      	push	di
 19466 00002324 0E                      	push	cs
 19467 00002325 07                      	pop	es
 19468 00002326 FF5701                  	call	word [bx+1]
 19469 00002329 5F                      	pop	di
 19470 0000232A 07                      	pop	es
 19471 0000232B EBE4                    	jmp	short PP1
 19472                                  PP5:
 19473 0000232D 07                      	pop	es		; Restore segments
 19474 0000232E 1F                      	pop	ds
 19475 0000232F C3                      	retn
 19476                                  
 19477                                  ; ---------------------------------------------------------------------------
 19478                                  
 19479                                  PRINT_BACK:
 19480                                  	; 21/02/2023
 19481 00002330 BA[E293]                	mov	dx,dback_ptr
 19482 00002333 E90732                  	jmp	std_printf
 19483                                  
 19484                                  ; ---------------------------------------------------------------------------
 19485                                  
 19486                                  PRINT_EQ:
 19487 00002336 B03D                    	mov	al,'='
 19488 00002338 EB0E                    	jmp	short PRINT_CHAR
 19489                                  
 19490                                  ; ---------------------------------------------------------------------------
 19491                                  
 19492                                  PRINT_ESC:
 19493 0000233A B01B                    	mov	al,1Bh
 19494 0000233C EB0A                    	jmp	short PRINT_CHAR
 19495                                  
 19496                                  ; ---------------------------------------------------------------------------
 19497                                  
 19498                                  	; 21/02/2023
 19499                                  PRINT_G:
 19500                                  	;mov	al,[RABRACKET]
 19501 0000233E B03E                    	mov	al,'>' ; 3Eh
 19502 00002340 EB06                    	jmp	short PRINT_CHAR
 19503                                  
 19504                                  ; ---------------------------------------------------------------------------
 19505                                  
 19506                                  	; 21/02/2023
 19507                                  PRINT_L:
 19508                                  	;mov	al,[LABRACKET]
 19509 00002342 B03C                    	mov	al,'<' ; 3Ch
 19510 00002344 EB02                    	jmp	short PRINT_CHAR
 19511                                  
 19512                                  ; ---------------------------------------------------------------------------
 19513                                  
 19514                                  	; 21/02/2023
 19515                                  Print_B:
 19516                                  	;mov	al,[VBAR]
 19517 00002346 B07C                    	mov	al,'|' ; 7Ch
 19518                                  
 19519                                  ; =============== S U B	R O U T	I N E =======================================
 19520                                  
 19521                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19522                                  PRINT_CHAR:
 19523                                  	; MSDOS 6.0
 19524                                  
 19525                                  ;	Bugbug:	Why bother with ds,es here?
 19526                                  		
 19527 00002348 06                      	push	es
 19528 00002349 1E                      	push	ds
 19529 0000234A 07                      	pop	es
 19530 0000234B 57                      	push	di
 19531 0000234C 52                      	push	dx
 19532 0000234D 88C2                    	mov	dl,al		;AC000; Get char into al
 19533                                  	;mov	ah,STD_CON_OUTPUT
 19534                                  				;AC000; print the char to stdout
 19535 0000234F B402                    	mov	ah,2
 19536 00002351 CD21                    	int	21h		;AC000;
 19537 00002353 5A                      	pop	dx
 19538 00002354 5F                      	pop	di
 19539 00002355 07                      	pop	es
 19540 00002356 C3                      	retn
 19541                                  
 19542                                  ; ---------------------------------------------------------------------------
 19543                                  
 19544                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19545                                  PRINT_DRIVE:
 19546                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 19547 00002357 B419                    	mov	ah,19h
 19548 00002359 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 19549 0000235B 0441                    	add	al,'A'
 19550                                  	;add	al,[CAPITAL_A]
 19551                                  	;call	PRINT_CHAR
 19552                                  	;retn
 19553                                  	; 21/02/2023
 19554 0000235D EBE9                    	jmp	short PRINT_CHAR
 19555                                  
 19556                                  ; ---------------------------------------------------------------------------
 19557                                  
 19558                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19559                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 19560                                  
 19561                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19562                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2460h
 19563                                  
 19564                                  build_dir_for_prompt:
 19565 0000235F 30D2                    	xor	dl,dl
 19566 00002361 BE[1FA0]                	mov	si,BWDBUF
 19567 00002364 89F7                    	mov	di,si
 19568 00002366 A0[F89D]                	mov	al,[CURDRV]
 19569 00002369 0441                    	add	al,'A'
 19570 0000236B B43A                    	mov	ah,':'
 19571 0000236D AB                      	stosw
 19572 0000236E A0[E99D]                	mov	al,[DIRCHAR]
 19573 00002371 AA                      	stosb
 19574 00002372 87F7                    	xchg	si,di
 19575 00002374 893E[06A1]              	mov	[string_ptr_2],di
 19576                                  	;mov	ah,CURRENT_DIR ; 47h
 19577 00002378 B447                    	mov	ah,47h
 19578 0000237A CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19579                                  			; DL = drive (0=default,1=A,etc.)
 19580                                  			; DS:SI	points to 64-byte buffer area
 19581                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19582 0000237C BA[CA93]                	mov	dx,string_buf_ptr
 19583 0000237F 7303                    	jnc	short doprint
 19584                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 19585 00002381 BA[9292]                	mov	dx,BADCURDRV
 19586                                  doprint:
 19587                                  	;call	std_printf
 19588                                  	;retn
 19589 00002384 E9B631                  	jmp	std_printf
 19590                                  
 19591                                  ; =============== S U B	R O U T	I N E =======================================
 19592                                  
 19593                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19594                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 19595                                  
 19596                                  build_dir_for_chdir:
 19597 00002387 E80D00                  	call	build_dir_string
 19598 0000238A BA[1FA0]                	mov	dx,DIRBUF
 19599 0000238D 8916[06A1]              	mov	[string_ptr_2],dx
 19600                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 19601                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19602 00002391 BA[CA93]                	mov	dx,string_buf_ptr
 19603                                  	;call	std_printf
 19604                                  	;retn
 19605                                  	; 21/02/2023
 19606                                  	;jmp	short doprint
 19607 00002394 E9A631                  	jmp	std_printf
 19608                                  
 19609                                  
 19610                                  ; =============== S U B	R O U T	I N E =======================================
 19611                                  
 19612                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19613                                  build_dir_string:
 19614 00002397 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 19615 0000239B 88D0                    	mov	al,dl
 19616 0000239D 0440                    	add	al,'@'	; 40h
 19617 0000239F 3C40                    	cmp	al,'@'
 19618 000023A1 7506                    	jne	short gotdrive
 19619 000023A3 0206[F89D]              	add	al,[CURDRV]
 19620 000023A7 FEC0                    	inc	al
 19621                                  gotdrive:
 19622 000023A9 50                      	push	ax
 19623 000023AA BE[22A0]                	mov	si,BWDBUF+3
 19624                                  	;mov	ah,CURRENT_DIR ; 47h
 19625 000023AD B447                    	mov	ah,47h
 19626 000023AF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19627                                  			; DL = drive (0=default,1=A,etc.)
 19628                                  			; DS:SI	points to 64-byte buffer area
 19629 000023B1 7305                    	jnc	short dpbisok
 19630 000023B3 0E                      	push	cs
 19631 000023B4 1F                      	pop	ds
 19632 000023B5 E9ED09                  	jmp	DRVBAD
 19633                                  dpbisok:
 19634 000023B8 BF[1FA0]                	mov	di,BWDBUF
 19635 000023BB 89FA                    	mov	dx,di
 19636 000023BD 58                      	pop	ax
 19637 000023BE B43A                    	mov	ah,':'
 19638 000023C0 AB                      	stosw
 19639 000023C1 A0[E99D]                	mov	al,[DIRCHAR]
 19640 000023C4 AA                      	stosb
 19641 000023C5 C3                      	retn
 19642                                  
 19643                                  ; ---------------------------------------------------------------------------
 19644                                  
 19645                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19646                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 19647                                  
 19648                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19649                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:24C9h
 19650                                  PATH:
 19651                                  	; MSDOS 6.0
 19652 000023C6 30C0                    	xor	al,al			;AN049; Set up holding buffer
 19653 000023C8 BF[129B]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 19654 000023CB AA                      	stosb				;AN049; Initialize PATH to null
 19655 000023CC 4F                      	dec	di			;AN049; point to the start of buffer
 19656 000023CD E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 19657 000023D0 7460                    	jz	short disppath		; Print the current path
 19658                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 19659 000023D2 3C3B                    	cmp	al,';' ; 3Bh
 19660 000023D4 7503                    	jne	short pathslp 		;AC049;
 19661 000023D6 46                      	inc	si			;AN049; point past semicolon
 19662 000023D7 EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 19663                                  pathslp:					; Get the user specified path
 19664 000023D9 AC                      	lodsb				; Get a character
 19665 000023DA 3C0D                    	cmp	al,0Dh
 19666                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 19667 000023DC 7434                    	je	short path_eol		;AC049; yes - end of command
 19668 000023DE E82905                  	call	testkanj		;See if DBCS
 19669 000023E1 7405                    	jz	short notkanj2		;No - continue
 19670 000023E3 AA                      	stosb				;AC049; Yes - store the first byte
 19671 000023E4 AC                      	lodsb				;skip second byte of DBCS
 19672                                  path_hold:				;AN049;
 19673 000023E5 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 19674 000023E6 EBF1                    	jmp	short pathslp		;continue parsing
 19675                                  notkanj2:
 19676 000023E8 E84905                  	call	UPCONV			;upper case the character
 19677                                  
 19678 000023EB 3C3B                    	cmp	al,';' ; 3Bh
 19679                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 19680 000023ED 74F6                    	je	short path_hold		;AC049; go store it
 19681 000023EF E83F07                  	call	DELIM			;delimiter?
 19682 000023F2 75F1                    	jnz	short path_hold		;AC049; no - go store character
 19683                                  scan_white:				;AN049; make sure were at EOL
 19684 000023F4 AC                      	lodsb				;AN049; get a character
 19685 000023F5 3C0D                    	cmp	al,0Dh
 19686                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 19687 000023F7 7419                    	je	short path_eol		;AN049; yes - go set path
 19688 000023F9 3C20                    	cmp	al,' ' ; 20h
 19689                                  	;cmp	al,blank		;AN049; whitespace?
 19690 000023FB 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 19691                                  	;cmp	al,9
 19692 000023FD 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 19693 000023FF 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 19694                                  
 19695 00002401 BA[0392]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 19696                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 19697 00002404 C706[0392]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 19698                                  	;mov	byte [msg_disp_class],2		
 19699                                  					;AN049; set up parse error msg class
 19700 0000240A C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class
 19701 0000240F E98B0A                  	jmp	cerror			;AN049;
 19702                                  path_eol:				;AN049; Parsing was clean
 19703 00002412 30C0                    	xor	al,al			;AN049; null terminate the PATH
 19704 00002414 AA                      	stosb				;AN049;    buffer
 19705 00002415 E84004                  	call	find_path		;AN049; Find PATH in environment
 19706 00002418 E81404                  	call	delete_path		;AC049; Delete any offending name
 19707 0000241B E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 19708 0000241E E89A04                  	call	move_name		;AC049; move in PATH=
 19709 00002421 BE[129B]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 19710                                  store_path:				;AN049; Store the PATH in the environment
 19711 00002424 AC                      	lodsb				;AN049; Get a character
 19712                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 19713 00002425 20C0                    	and	al,al ; al=0 ?
 19714 00002427 7405                    	jz	short got_paths		;AN049; yes - exit
 19715 00002429 E82A05                  	call	store_char		;AN049; no - store character
 19716 0000242C EBF6                    	jmp	short store_path	;AN049; continue
 19717                                  got_paths:				;AN049; we're finished
 19718 0000242E 31C0                    	xor	ax,ax			;	null terminate the PATH in
 19719 00002430 AB                      	stosw				;    	the environment
 19720 00002431 C3                      	retn
 19721                                  disppath:
 19722 00002432 E82304                  	call	find_path		;AN049;
 19723 00002435 E80300                  	call	print_path
 19724                                  	;call	CRLF2
 19725                                  	;retn
 19726                                  	; 21/02/2023
 19727 00002438 E9E106                  	jmp	CRLF2
 19728                                  
 19729                                  ; =============== S U B	R O U T	I N E =======================================
 19730                                  
 19731                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19732                                  print_path:
 19733 0000243B 26803D00                	cmp	byte [es:di],0
 19734 0000243F 750A                    	jnz	short path1
 19735                                  path0:
 19736 00002441 BA[5893]                	mov	dx,NULLPATH_PTR
 19737 00002444 0E                      	push	cs
 19738 00002445 07                      	pop	es
 19739 00002446 0E                      	push	cs
 19740 00002447 1F                      	pop	ds
 19741 00002448 E9F230                  	jmp	std_printf
 19742                                  path1:
 19743 0000244B 06                      	push	es
 19744 0000244C 1F                      	pop	ds
 19745 0000244D 83EF05                  	sub	di,5
 19746 00002450 89FE                    	mov	si,di
 19747 00002452 E8AD04                  	call	SCASB2		; Look for null
 19748                                  	;cmp	cx,0FFh ; 255
 19749                                  	; 21/02/2023
 19750                                  	;ch = 0
 19751 00002455 80F9FF                  	cmp	cl,255
 19752 00002458 74E7                    	je	short path0
 19753 0000245A 0E                      	push	cs
 19754 0000245B 07                      	pop	es
 19755 0000245C BF[82A0]                	mov	di,Arg_Buf
 19756                                  	;mov	dx,100h ; 256
 19757                                  	;sub	dx,cx
 19758                                  	;xchg	dx,cx
 19759                                  	; 21/02/2023
 19760 0000245F F6D9                    	neg	cl ; 256-cl
 19761 00002461 F3A4                    	rep	movsb
 19762 00002463 BA[A093]                	mov	dx,arg_buf_ptr
 19763 00002466 0E                      	push	cs
 19764 00002467 1F                      	pop	ds
 19765 00002468 E9D230                  	jmp	std_printf
 19766                                  
 19767                                  ; ---------------------------------------------------------------------------
 19768                                  
 19769                                  ; ****************************************************************
 19770                                  ; *
 19771                                  ; * ROUTINE:	 CLS
 19772                                  ; *
 19773                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 19774                                  ; *		 installed, send a control string to clear the
 19775                                  ; *		 screen.
 19776                                  ; *
 19777                                  ; * INPUT:	 command line at offset 81H
 19778                                  ; *
 19779                                  ; * OUTPUT:	 none
 19780                                  ; *
 19781                                  ; ****************************************************************
 19782                                  
 19783                                  	; MSDOS 6.0
 19784                                  
 19785                                  ANSI_installed	equ 0FFh
 19786                                  
 19787                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19788                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19789                                  CLS:
 19790                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 19791                                  	;mov	ah,1Ah
 19792                                  	;mov	al,0			;AN000;
 19793 0000246B B8001A                  	mov	ax,1A00h
 19794 0000246E CD2F                    	int	2Fh			;AN000;
 19795                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 19796                                  		; Return: AL = FFh if installed
 19797 00002470 3CFF                    	cmp	al,ANSI_installed	;AN000;
 19798 00002472 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 19799                                  
 19800                                  check_lines:
 19801                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 19802 00002474 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 19803                                  	;mov	bx,stdout		;AN000; lines for stdout
 19804 00002477 BB0100                  	mov	bx,1   ; handle
 19805                                  	;;mov	ch,ioc_sc		;AN000; type is display
 19806                                  	;mov	ch,3   ; CON device	
 19807                                  	;;mov	cl,get_generic		;AN000; get information
 19808                                  	;mov	cl,7Fh ; minor function, get display info
 19809                                  	; 25/04/2023
 19810 0000247A B97F03                  	mov	cx,037Fh
 19811 0000247D BA[6DA2]                	mov	dx,Display_Ioctl	;AN000;
 19812 00002480 CD21                    	int	21h			;AN000;
 19813 00002482 720A                    	jc	short no_variable	;AN000; function had error, use default
 19814                                  		; 21/02/2023
 19815                                  		; ds:dx = parameter block
 19816                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 19817                                  		; offset 00h  byte  level (0 for DOS 4.0)
 19818                                  		;   	 01h  byte  reserved
 19819                                  		;   	 02h  word  length of following data
 19820                                  		;   	 04h  word  control flags
 19821                                  		;	       bit 0 set for blink, clear for intensity
 19822                                  		;	       bits 1 to 15 reserved
 19823                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 19824                                  		;   	 07h  byte  reserved
 19825                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 19826                                  		;   	 0Ah  word  pixel columns
 19827                                  		;   	 0Ch  word  pixel rows
 19828                                  		;   	 0Eh  word  character columns
 19829                                  		;   	 10h  word  character rows
 19830                                  	
 19831                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 19832                                  	;				;AN000; get number of rows returned
 19833                                  	;mov	dh,al			;AN000; set number of rows
 19834                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 19835                                  	;				;AN000; get number of columns returned
 19836                                  	;mov	dl,al			;AN000; set number of columns
 19837                                  	; 21/02/2023
 19838 00002484 8A16[7BA2]              	mov	dl,[display_width]
 19839 00002488 8A36[7DA2]              	mov	dh,[LinPerPag]
 19840 0000248C EB3B                    	jmp	short regcls		;AN000; go do cls
 19841                                  
 19842                                  no_variable:
 19843                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 19844                                  	;mov	bx,1
 19845                                  	; bx = 1
 19846                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 19847 0000248E B80044                  	mov	ax,4400h
 19848 00002491 CD21                    	int	21h			;AC000;
 19849 00002493 F6C280                  	test	dl,80h
 19850                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 19851 00002496 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 19852 00002498 F6C210                  	test	dl,10h
 19853                                  	;test	dl,devid_SPECIAL	;AC000;
 19854 0000249B 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 19855                                  
 19856                                  ansicls:
 19857 0000249D E85200                  	call	ansi_cls		;AN000; clear the screen
 19858 000024A0 EB2C                    	jmp	short cls_ret		;AN000; exit
 19859                                  
 19860                                  ; Get video mode
 19861                                  
 19862                                  cls_normal:				;AC000;
 19863                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 19864 000024A2 B40F                    	mov	ah,0Fh
 19865                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 19866 000024A4 CD10                    	int	10h
 19867 000024A6 3C03                    	cmp	al,3
 19868                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 19869 000024A8 760A                    	jbe	short DoAlpha
 19870 000024AA 3C07                    	cmp	al,7
 19871                                  	;cmp	al,video_bw		;AC000; see if black & white card
 19872 000024AC 7406                    	je	short DoAlpha
 19873                                  
 19874                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 19875                                  ; be just as bogus and set the mode that we just got. This will blank the
 19876                                  ; screen too.
 19877                                  
 19878                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 19879 000024AE B400                    	mov	ah,0
 19880                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 19881 000024B0 CD10                    	int	10h
 19882 000024B2 EB1A                    	jmp	short cls_ret		;AC000; exit
 19883                                  
 19884                                  DoAlpha:
 19885                                  
 19886                                  ; Get video mode and number of columns to scroll
 19887                                  
 19888                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 19889                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 19890                                  ;M01   area
 19891                                  ;M01   Commented out code here is the original
 19892                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 19893                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 19894                                  ;M01	mov	dl,ah
 19895                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 19896                                  
 19897                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 19898                                  
 19899 000024B4 1E                      	push	ds
 19900                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 19901 000024B5 B84000                  	mov	ax,40h
 19902 000024B8 8ED8                    	mov	ds,ax			;  *			M01
 19903                                  
 19904                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 19905 000024BA 8A164A00                	mov	dl,[4Ah]
 19906                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 19907 000024BE 8A368400                	mov	dh,[84h]
 19908 000024C2 1F                      	pop	ds			;			M01
 19909                                  
 19910 000024C3 08F6                    	or	dh,dh			; Q:ZERO		M01
 19911 000024C5 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 19912                                  
 19913                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 19914                                  	; 25/04/2023
 19915 000024C7 B619                    	mov	dh,25
 19916                                  regcls:
 19917 000024C9 FEC6                    	inc	dh			; height+1		M018
 19918 000024CB E80100                  	call	reg_cls 		; go clear the screen
 19919                                  cls_ret:
 19920 000024CE C3                      	retn				; exit
 19921                                  
 19922                                  ; ---------------------------------------------------------------------------
 19923                                  
 19924                                  ; MSDOS 6.0
 19925                                  
 19926                                  ; ****************************************************************
 19927                                  ; *
 19928                                  ; * ROUTINE:	 REG_CLS
 19929                                  ; *
 19930                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 19931                                  ; *
 19932                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 19933                                  ; *		 DH = NUMBER OF ROWS
 19934                                  ; *
 19935                                  ; * OUTPUT:	 none
 19936                                  ; *
 19937                                  ; ****************************************************************
 19938                                  
 19939                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19940                                  reg_cls:
 19941                                  ; Set overscan to black.
 19942                                  
 19943 000024CF FECE                    	dec	dh			; decrement rows and columns
 19944 000024D1 FECA                    	dec	dl			;  to zero base
 19945 000024D3 52                      	push	dx			; save rows,columns
 19946                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 19947 000024D4 B40B                    	mov	ah,0Bh
 19948 000024D6 31DB                    	xor	bx,bx
 19949                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19950 000024D8 CD10                    	int	10h
 19951 000024DA 5A                      	pop	dx			;  restore rows,colums
 19952                                  
 19953 000024DB 31C0                    	xor	ax,ax			; zero out ax
 19954 000024DD 89C1                    	mov	cx,ax			;  and cx
 19955                                  
 19956                                  ; Scroll active page
 19957                                  
 19958                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 19959 000024DF B406                    	mov	ah,6
 19960                                  	;mov	bh,video_attribute	; attribute for blank line
 19961 000024E1 B707                    	mov	bh,7
 19962 000024E3 30DB                    	xor	bl,bl			; set BL to 0
 19963                                  	;int	video_io_int		; do int 10h - BIOS video IO
 19964 000024E5 CD10                    	int	10h
 19965                                  
 19966                                  ; Seek to cursor to 0,0
 19967                                  
 19968                                  ;M022 following two lines added
 19969                                  	;mov	ah,get_video_state	; get current video page in BH
 19970 000024E7 B40F                    	mov	ah,0Fh
 19971                                  	;int	video_io_int
 19972 000024E9 CD10                    	int	10h
 19973                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 19974 000024EB B402                    	mov	ah,2
 19975 000024ED 31D2                    	xor	dx,dx			; row and column 0
 19976                                  ;M022	mov	bh,0
 19977                                  	;int	video_io_int		; do into 10h - BIOS video IO
 19978 000024EF CD10                    	int	10h
 19979                                  
 19980 000024F1 C3                      	retn
 19981                                  
 19982                                  ; ---------------------------------------------------------------------------
 19983                                  
 19984                                  ; MSDOS 6.0
 19985                                  
 19986                                  ; ****************************************************************
 19987                                  ; *
 19988                                  ; * ROUTINE:	 ANSI_CLS
 19989                                  ; *
 19990                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 19991                                  ; *		 to STDOUT.
 19992                                  ; *
 19993                                  ; * INPUT:	 none
 19994                                  ; *
 19995                                  ; * OUTPUT:	 none
 19996                                  ; *
 19997                                  ; ****************************************************************
 19998                                  
 19999                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20000                                  ansi_cls:			;AC000;
 20001 000024F2 BE[C895]                	mov	si,CLSSTRING
 20002                                  			; db 4,1Bh,'[2J'
 20003 000024F5 AC                      	lodsb
 20004 000024F6 88C1                    	mov	cl,al	; al = 4
 20005 000024F8 30ED                    	xor	ch,ch
 20006                                  	;mov	ah,Raw_CON_IO
 20007 000024FA B406                    	mov	ah,6
 20008                                  clrloop:
 20009 000024FC AC                      	lodsb
 20010 000024FD 88C2                    	mov	dl,al
 20011 000024FF CD21                    	int	21h
 20012                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 20013 00002501 E2F9                    	loop	clrloop
 20014 00002503 C3                      	retn
 20015                                  
 20016                                  ;============================================================================
 20017                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 20018                                  ;============================================================================
 20019                                  ; 08/10/2018 - Retro DOS v3.0
 20020                                  
 20021                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 20022                                  
 20023                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 20024                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 20025                                  
 20026                                  ; ---------------------------------------------------------------------------
 20027                                  
 20028                                  ; ****************************************************************
 20029                                  ; *
 20030                                  ; * ROUTINE:	 CTTY - Change console
 20031                                  ; *
 20032                                  ; * SYNTAX:	 CTTY device
 20033                                  ; *
 20034                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 20035                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 20036                                  ; *		 STDERR. This routine returns to LODCOM1.
 20037                                  ; *
 20038                                  ; * INPUT:	 command line at offset 81H
 20039                                  ; *
 20040                                  ; * OUTPUT:	 none
 20041                                  ; *
 20042                                  ; ****************************************************************
 20043                                  
 20044                                  	; 21/02/2023 - Retro DOS v4.0
 20045                                  	; 08/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 20046                                  	; 10/06/2023
 20047                                  CTTY:
 20048                                  	; MSDOS 6.0
 20049 00002504 1E                      	push	ds			;AN000; Get local ES
 20050 00002505 07                      	pop	es			;AN000;
 20051 00002506 BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 20052 00002509 BF[EA98]                	mov	di,PARSE_CTTY
 20053                                  					;AC000; Get address of PARSE_CTTY
 20054 0000250C 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 20055 0000250E 31D2                    	xor	dx,dx			;AC000;
 20056 00002510 E85925                  	call	cmd_parse		;AC000; call parser
 20057                                  
 20058                                  	;cmp	ax,-1 ; 0FFFFh
 20059                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20060                                  	;je	short ctty_error	;AN000; yes - error
 20061                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 20062                                  	;and	ax,ax ; ax > 0 ?
 20063                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 20064                                  	; 10/06/2023
 20065 00002513 40                      	inc	ax  ; cmp ax,-1
 20066 00002514 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 20067 00002516 48                      	dec	ax  ; cmp ax,0
 20068 00002517 7531                    	jnz	short ctty_error  ; 1 -> 0
 20069                                  	; ax = 0
 20070                                  
 20071 00002519 56                      	push	si			;AN000; save position in line
 20072 0000251A C536[5BAA]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20073 0000251E BF[87A1]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 20074                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 20075 00002521 AC                      	lodsb				;AN000; get a char from buffer
 20076 00002522 AA                      	stosb				;AN000; store in srcbuf
 20077                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 20078 00002523 08C0                    	or	al,al ; al = 0 ?
 20079 00002525 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 20080                                  					;AN000; no - keep moving
 20081 00002527 5E                      	pop	si			;AN000; get line position back
 20082 00002528 BF[EA98]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 20083 0000252B E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 20084                                  	;jz	short nocolon 		;AN000; yes - continue
 20085                                  	; 21/02/2023
 20086 0000252E 751A                    	jnz	short ctty_error
 20087                                  ;ctty_error:
 20088                                  	;jmp	short isbaddev		;AC000; yes - exit
 20089                                  
 20090                                  	; 21/02/2023
 20091                                  	; MSDOS 3.3
 20092                                  	;call	SETPATH
 20093                                  	;dec	si
 20094                                  	;dec	si
 20095                                  	;cmp	byte [si],':'
 20096                                  	;jnz	short NOCOLON
 20097                                  	;mov	byte [si],0
 20098                                  nocolon:
 20099                                  	; 21/02/2023
 20100                                  	; MSDOS 6.0
 20101 00002530 BA[87A1]                	mov	dx,SrcBuf
 20102                                  ;NOCOLON:
 20103                                  	; MSDOS 3.3 & MSDOS 6.0
 20104                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 20105                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 20106 00002533 B8023D                  	mov	ax,3D02h ; 21/02/2023
 20107 00002536 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 20108                                  			; DS:DX	-> ASCIZ filename
 20109                                  			; AL = access mode
 20110                                  			; 2 - read & write
 20111 00002538 7210                    	jc	short isbaddev
 20112 0000253A 89C3                    	mov	bx,ax
 20113                                  	;mov	ax,IOCTL*256 ; 4400h
 20114 0000253C B80044                  	mov	ax,4400h
 20115 0000253F CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 20116                                  			; BX = file or device handle
 20117 00002541 F6C280                  	test	dl,80h
 20118 00002544 750C                    	jnz	short devisok
 20119                                  closedev:
 20120                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 20121 00002546 B43E                    	mov	ah,3Eh
 20122 00002548 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20123                                  			; BX = file handle
 20124                                  ctty_error:
 20125                                  isbaddev:
 20126 0000254A BA[5E93]                	mov	dx,BADDEV_PTR
 20127 0000254D E8ED2F                  	call	std_printf
 20128 00002550 EB40                    	jmp	short resret
 20129                                  
 20130                                  	;nop
 20131                                  devisok:
 20132                                  	; 21/02/2023
 20133                                  	; MSDOS 6.0
 20134 00002552 52                      	push	dx		;AN007; save device info
 20135                                  	; 08/06/2023
 20136 00002553 A1[E593]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 20137                                  	;mov	dh,util_msg_class
 20138 00002556 B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 20139 00002558 53                      	push	bx		;AN021; save handle
 20140 00002559 E8C630                  	call	TSYSGETMSG	;AN021; get the address of the message
 20141 0000255C 89F2                    	mov	dx,si		;AN021; get address into dx
 20142                                  	;mov	ax,(Write shl 8)
 20143 0000255E B80040                  	mov	ax,4000h	;AN007; write to device
 20144 00002561 B90200                  	mov	cx,2		;AN007; write two bytes
 20145 00002564 CD21                    	int	21h		;AN007;
 20146 00002566 5B                      	pop	bx		;AN021; get back handle
 20147 00002567 5A                      	pop	dx		;AN007; get back device info
 20148 00002568 72DC                    	jc	short closedev	;AN007; if error, quit
 20149                                  
 20150                                  	; MSDOS 3.3 & MSDOS 6.0
 20151 0000256A 30F6                    	xor	dh,dh
 20152 0000256C 80CA03                  	or	dl,3
 20153                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 20154                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 20155 0000256F B80144                  	mov	ax,4401h
 20156 00002572 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 20157                                  			; BX = device handle,DH = 0
 20158                                  			; DL = device information to set 
 20159                                  			;	(bits 0-7 from	function 0)
 20160 00002574 53                      	push	bx
 20161 00002575 B90300                  	mov	cx,3
 20162 00002578 31DB                    	xor	bx,bx
 20163                                  iclloop:			; Close basic handles
 20164                                  	;mov	ah,CLOSE ; 3Eh
 20165 0000257A B43E                    	mov	ah,3Eh
 20166 0000257C CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20167                                  			; BX = file handle
 20168 0000257E 43                      	inc	bx
 20169 0000257F E2F9                    	loop	iclloop
 20170 00002581 5B                      	pop	bx		; Get handle
 20171                                  	;mov	ah,XDUP ; 45h
 20172 00002582 B445                    	mov	ah,45h
 20173 00002584 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20174                                  			; BX = file handle to duplicate
 20175                                  	;mov	ah,XDUP ; 45h
 20176 00002586 B445                    	mov	ah,45h
 20177 00002588 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20178                                  			; BX = file handle to duplicate
 20179                                  	;mov	ah,XDUP ; 45h
 20180 0000258A B445                    	mov	ah,45h
 20181 0000258C CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20182                                  			; BX = file handle to duplicate
 20183                                  	;mov	ah,CLOSE ; 3Eh
 20184 0000258E B43E                    	mov	ah,3Eh
 20185 00002590 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20186                                  			; BX = file handle
 20187                                  resret:
 20188 00002592 8E1E[E49D]              	mov	ds,[RESSEG]
 20189 00002596 1E                      	push	ds
 20190                                  	;mov	ax,[18h]
 20191 00002597 A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 20192 0000259A A3[5B02]                	mov	[Io_Save],ax
 20193                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 20194                                  	;;mov	ax,LODCOM1
 20195                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 20196                                  	;mov	ax,175h ; MSDOS 6.0
 20197 0000259D B8[7400]                	mov	ax,TrnLodCom1_Trap
 20198 000025A0 50                      	push	ax
 20199                                  
 20200 000025A1 CB                      	retf		; Far return
 20201                                  
 20202                                  ; ---------------------------------------------------------------------------
 20203                                  
 20204                                  ;****************************************************************
 20205                                  ;*
 20206                                  ;* ROUTINE:	CHCP - Change code page internal command
 20207                                  ;*		(added DOS 3.30 07/21/86)
 20208                                  ;*
 20209                                  ;* SYNTAX:	CHCP [xxx]
 20210                                  ;*		where xxx is a valid code page
 20211                                  ;*
 20212                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 20213                                  ;*		6402H to set the code page to xxxx. If no parameters
 20214                                  ;*		are specified, CHCP will use INT 21H function 6401H
 20215                                  ;*		to get global code page and display it to the user.
 20216                                  ;*
 20217                                  ;* INPUT:	command line at offset 81H
 20218                                  ;*
 20219                                  ;* OUTPUT:	none
 20220                                  ;*
 20221                                  ;****************************************************************
 20222                                  
 20223                                  NLSFUNC_installed equ  0FFh
 20224                                  set_global_cp	  equ  2
 20225                                  get_global_cp	  equ  1
 20226                                  
 20227                                  	; 21/02/2023 - Retro DOS v4.0
 20228                                  	; 09/06/2023 - Retro DOS v4.2 COMMAND.COM
 20229                                  	; 10/06/2023
 20230                                  CHCP:
 20231                                  	; MSDOS 6.0
 20232 000025A2 1E                      	push	ds		;AN000; Get local ES
 20233 000025A3 07                      	pop	es		;AN000;
 20234 000025A4 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 20235 000025A7 BF[F697]                	mov	di,PARSE_CHCP
 20236                                  				;AN000; Get address of PARSE_CHCP
 20237 000025AA 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 20238 000025AC 31D2                    	xor	dx,dx		;AC000;
 20239 000025AE E85301                  	call    Parse_With_Msg	;AC018; call parser
 20240                                  
 20241                                  	;cmp	ax,-1
 20242                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 20243                                  	;;jne	short setcp	;AC000; no go get number & set code page
 20244                                  	;je	short getcp	;AC000; yes - no parm - get code page
 20245                                  ;setcp:
 20246                                  	;;cmp	ax,0
 20247                                  	;;cmp	ax,RESULT_NO_ERROR
 20248                                  	;			;AN000; did we have an error?
 20249                                  	;;jne	short cp_error	;AC018; yes - go issue message
 20250                                  	;and	ax,ax ; ax > 0 ?
 20251                                  	;jnz	short cp_error	
 20252                                  	; 10/06/2023
 20253 000025B1 40                      	inc	ax  ; cmp ax,-1	
 20254 000025B2 745C                    	jz	short getcp ; 0FFFFh -> 0
 20255 000025B4 48                      	dec	ax  ; cmp ax,0
 20256 000025B5 7556                    	jnz	short cp_error ; 1 -> 0
 20257                                  	; ax = 0
 20258                                  
 20259                                  	;;push	cx		;AN000; save positional count
 20260                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 20261                                  	;;mov	cx,[bx]		;AN000;  into cx
 20262                                  	;;mov	[system_cpage],cx
 20263                                  	;			;AN000; save user input number
 20264                                  	;;pop	cx		;AC000; restore positional count
 20265                                  	;; 21/02/2023
 20266                                  	;mov	di,[bx]
 20267                                  	;mov	[system_cpage],di
 20268                                  	; 09/06/2023	
 20269 000025B7 8B1E[5BAA]              	mov	bx,[PARSE1_ADDR]
 20270 000025BB 891E[80A0]              	mov	[system_cpage],bx
 20271                                  	;
 20272 000025BF BF[F697]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 20273 000025C2 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 20274 000025C5 7546                    	jnz	short cp_error	;AC000; no - exit
 20275                                  okset:
 20276                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 20277                                  	;mov	ah,14h
 20278                                  	;mov	al,0		;AN000;
 20279 000025C7 B80014                  	mov	ax,1400h
 20280 000025CA CD2F                    	int	2Fh		;AN000;
 20281                                  	;cmp	al,0FFh
 20282 000025CC 3CFF                    	cmp	al,NLSFUNC_installed
 20283                                  				;AN000;
 20284 000025CE 7405                    	je	short got_NLS 	;AN000; Yes - continue
 20285 000025D0 BA[8C92]                	mov	dx,NLSFUNC_PTR
 20286                                  				;AN000; no - set up error message
 20287 000025D3 EB38                    	jmp	short cp_error	;AN000; error exit
 20288                                  
 20289                                  	; 21/02/2023
 20290                                  got_NLS:
 20291                                  	; MSDOS 6.0
 20292 000025D5 8B1E[80A0]              	mov	bx,[system_cpage]
 20293                                  				;AN000; get user input code page
 20294                                  ;SET_CP_TBL_NUM:
 20295                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 20296                                  	;
 20297                                  	; MSDOS 3.3 & MSDOS 6.0
 20298                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 20299                                  	;mov	ah,66h
 20300                                  	;;mov	al,set_global_cp 
 20301                                  	;mov	al,2		;minor - set
 20302                                  	; 26/04/2023
 20303 000025D9 B80266                  	mov	ax,6602h
 20304 000025DC CD21                    	int	21h
 20305                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 20306                                  		; BX = active code page
 20307                                  		; DX = system code page (active page at boot time)
 20308                                  
 20309 000025DE 733F                    	jnc	short chcp_return
 20310                                  				;no error - exit
 20311                                  
 20312 000025E0 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 20313 000025E3 7515                    	jnz	short chcp_other_error
 20314                                  
 20315                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 20316 000025E5 B459                    	mov	ah,59h
 20317 000025E7 31DB                    	xor	bx,bx
 20318 000025E9 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20319                                  			; BX = version code (0000h for DOS 3.x)
 20320                                  
 20321 000025EB 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 20322 000025EE 7505                    	jne	short no_countrysys ; 26/04/2023
 20323                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 20324 000025F0 BA[8F92]                	mov	dx,INV_CODE_PAGE
 20325                                  	;jmp	cerror
 20326 000025F3 EB18                    	jmp	short cp_error
 20327                                  
 20328                                  	; 21/02/2023
 20329                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 20330                                  no_countrysys:
 20331                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 20332                                  ;					;AN000; set up extended error msg class
 20333                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 20334                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 20335                                  					;AN000; get message number in control block
 20336 000025F5 BA[7994]                	mov	dx,NoCntry_Ptr
 20337 000025F8 EB13                    	jmp	short cp_error
 20338                                  
 20339                                  chcp_other_error:		; end of p716
 20340                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 20341 000025FA B459                    	mov	ah,59h
 20342 000025FC 31DB                    	xor	bx,bx
 20343 000025FE CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20344                                  			; BX = version code (0000h for DOS 3.x)
 20345 00002600 83F841                  	cmp	ax,65		;was it access denied?
 20346 00002603 7505                    	jne	short none_set	;no - assume all failed
 20347 00002605 BA[7092]                	mov	dx,cp_not_all_ptr
 20348                                  				;set up message
 20349                                  	;jmp	cerror		;AC000; error exit
 20350 00002608 EB03                    	jmp     short cp_error
 20351                                  none_set:
 20352 0000260A BA[6292]                	mov	dx,cp_not_set_ptr
 20353                                  				;set up message
 20354                                  cp_error:
 20355 0000260D E98D08                  	jmp	cerror		;exit
 20356                                  getcp:
 20357                                  	;;mov	ah,GETSETCDPG ; 66h
 20358                                  	;mov	ah,66h		;get/set global code page function	
 20359                                  	;;mov	al,get_global_cp ; 1
 20360                                  	;mov	al,1		;minor - get
 20361                                  	; 26/04/2023
 20362 00002610 B80166                  	mov	ax,6601h
 20363 00002613 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 20364 00002615 891E[80A0]              	mov	[system_cpage],bx
 20365                                  				;get active cp for output
 20366 00002619 BA[7E92]                	mov	dx,cp_active_ptr
 20367 0000261C E81E2F                  	call	std_printf	;print it out
 20368                                  chcp_return:
 20369 0000261F C3                      	retn
 20370                                  
 20371                                  ; ---------------------------------------------------------------------------
 20372                                  
 20373                                  ; ****************************************************************
 20374                                  ; *
 20375                                  ; * ROUTINE:	 TRUENAME
 20376                                  ; *
 20377                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 20378                                  ; *		 Parses the command line. If a path is found, set
 20379                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 20380                                  ; *		 set SRCXNAME to the drive letter. If no path
 20381                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 20382                                  ; *		 current directory. Use the NAME TRANSLATE system
 20383                                  ; *		 call to get the real name and  then display the 
 20384                                  ; *		 real name. If an error occurs issue an error
 20385                                  ; *		 message and transfer control to  CERROR.
 20386                                  ; *
 20387                                  ; * INPUT:	 command line at offset 81H
 20388                                  ; *
 20389                                  ; * OUTPUT:	 none
 20390                                  ; *
 20391                                  ; ****************************************************************
 20392                                  
 20393                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20394                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 20395                                  
 20396                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20397                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2741h
 20398                                  
 20399                                  TRUENAME:				;AN000; TRUENAME entry point
 20400 00002620 1E                      	push	ds			;AN000; Get local ES
 20401 00002621 07                      	pop	es			;AN000;
 20402 00002622 BE8100                  	mov	si,81h			;AN000; Get command line
 20403 00002625 BF[5498]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 20404 00002628 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 20405 0000262A 31D2                    	xor	dx,dx			;AN000;
 20406 0000262C E8D500                  	call	Parse_With_Msg		;AC018; call parser
 20407                                  
 20408 0000262F BF[129B]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 20409                                  	;cmp	ax,0FFFFh
 20410                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20411                                  	;je	short tn_eol		;AN000; yes - go process
 20412                                  	;; 22/02/2023
 20413                                  	;;cmp	ax,0
 20414                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 20415                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 20416                                  	;and	ax,ax ; ax = 0 ?
 20417                                  	;jnz	short tn_parse_error ; no, parse error	
 20418                                  	; 10/06/2023
 20419 00002632 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 20420 00002633 7433                    	jz	short tn_eol ; ah = 0 ; *
 20421 00002635 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 20422 00002636 752D                    	jnz	short tn_parse_error
 20423                                  	
 20424                                  	;cmp	byte [PARSE1_TYPE],6
 20425 00002638 803E[57AA]06            	cmp	byte [PARSE1_TYPE],result_drive
 20426                                  					;AN000; was a drive entered?
 20427                                  	;je	short tn_drive		;AN000; yes - go process
 20428                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 20429                                  	; 23/02/2023
 20430 0000263D 7512                    	jne	short tn_filespec
 20431                                  
 20432                                  ;tn_eol: 
 20433                                  ;	;mov	ah,0			;AN000; no parameters on line
 20434                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20435                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 20436                                  ;	mov	al,'.'
 20437                                  ;	stosw				;AN000; store in srcxname
 20438                                  ;	jmp	short tn_doit		;AN000; go do command
 20439                                  
 20440                                  tn_drive:				;AN000; a drive was entered
 20441 0000263F 56                      	push	si			;AN000; save position in line
 20442 00002640 BE[5BAA]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 20443 00002643 AC                      	lodsb				;AN000; get the drive number
 20444 00002644 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 20445 00002646 AA                      	stosb				;AN000; store it in srcxname
 20446                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 20447 00002647 B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 20448 0000264A AB                      	stosw				;AN000;  store in srcxname
 20449                                  	;mov	al,0
 20450 0000264B B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 20451 0000264D AA                      	stosb				;AN000;
 20452 0000264E 5E                      	pop	si			;AN000; get line position back
 20453 0000264F EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 20454                                  
 20455                                  tn_filespec:				;AN000; a filespec was entered
 20456 00002651 56                      	push	si			;AN000; save position in line
 20457 00002652 C536[5BAA]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20458                                  
 20459                                  tn_move_filename:			;AN000; put filespec in srcxname
 20460 00002656 AC                      	lodsb				;AN000; get a char from buffer
 20461 00002657 AA                      	stosb				;AN000; store in srcxname
 20462                                  	;;cmp	al,0
 20463                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 20464 00002658 08C0                    	or	al,al ; al = 0 ?
 20465 0000265A 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 20466 0000265C 5E                      	pop	si			;AN000; get line position back
 20467                                  
 20468                                  tn_check_eol:				;AN000; make sure no extra parms
 20469 0000265D BF[5498]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 20470 00002660 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 20471 00002663 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 20472                                  tn_parse_error: 			;AN000; A parse error occurred
 20473 00002665 E93508                  	jmp	cerror			;AN000; Go to error routine
 20474                                  
 20475                                  tn_eol: 
 20476                                  	;23/02/2023
 20477                                  	;;mov	ah,0			;AN000; no parameters on line
 20478                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20479                                  	;;mov	al,dot_chr		;AN000;   for current dir
 20480                                  	;mov	al,'.'
 20481                                  	; 10/06/2023
 20482                                  	;mov	ax,002Eh
 20483                                  	; ah = 0 ; *
 20484 00002668 B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 20485                                  	;	
 20486 0000266A AB                      	stosw				;AN000; store in srcxname
 20487                                  	; 23/02/2023
 20488                                  	;jmp	short tn_doit		;AN000; go do command
 20489                                  
 20490                                  tn_doit:				;AN000;
 20491 0000266B BE[129B]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 20492 0000266E BF[439C]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 20493 00002671 B460                    	mov	ah,xNameTrans		;AN000; do name translate call
 20494                                  	;mov	ah,60h
 20495 00002673 CD21                    	int	21h			;AN000;
 20496 00002675 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 20497                                  
 20498 00002677 E8C4FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 20499 0000267A C706[06A1][129B]        	mov	word [string_ptr_2],SRCXNAME
 20500                                  					;AN000; get address of failed string
 20501                                  	;mov	byte [extend_buf_sub],1
 20502 00002680 C606[0592]01            	mov	byte [extend_buf_sub],one_subst
 20503                                  					;AN000; put number of subst in control block
 20504 00002685 E91508                  	jmp	cerror			;AN000; Go to error routine
 20505                                  
 20506                                  tn_print_xname: 			;AN000;
 20507 00002688 C706[06A1][439C]        	mov	word [string_ptr_2],COMBUF
 20508                                  					;AN000; Set up address of combuf
 20509 0000268E BA[CA93]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 20510 00002691 E88804                  	call	CRLF2			;AN000; print a crlf
 20511                                  	;call	Printf_Crlf		;AN000; print it out
 20512                                  	;retn				;AN000;
 20513                                  	; 23/02/2023
 20514 00002694 E9982E                  	jmp	Printf_Crlf
 20515                                  
 20516                                  ; ---------------------------------------------------------------------------
 20517                                  
 20518                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20519                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 20520                                  
 20521                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20522                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:27C3h
 20523                                  _$EXIT:
 20524                                  	; MSDOS 6.0
 20525 00002697 1E                      	push	ds			;AN000; save data segment
 20526 00002698 8E1E[E49D]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 20527                                  	;assume	ds:resgroup		;AN000;
 20528                                  
 20529 0000269C 803E[5E02]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 20530 000026A1 740A                    	jz	short free_com		;AN045; no - free everything
 20531                                  
 20532                                  ;	We're a permanent command.
 20533                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 20534                                  
 20535 000026A3 833E[6102]FF            	cmp	word [SingleCom],-1	;M034
 20536 000026A8 7412                    	je	short no_reset		;M034 ; exit singlecom
 20537 000026AA E957DA                  	jmp	TCOMMAND		;permanent command, recycle
 20538                                  
 20539                                  free_com:
 20540                                  	;mov	ax,(multdos shl 8 or message_2f)
 20541 000026AD B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 20542                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 20543 000026B0 B205                    	mov	dl,5
 20544 000026B2 8B3E[7602]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 20545 000026B6 8E06[7802]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 20546 000026BA CD2F                    	int	2Fh			;AN000; go set it
 20547                                  no_reset:				;AN045;
 20548 000026BC 1F                      	pop	ds			;AN000; restore local data segment
 20549                                  	;assume	ds:trangroup		;AN000;
 20550                                  ;M040
 20551                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 20552                                  ;this, restores user dir if flag is set and resets the flag.
 20553                                  
 20554                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 20555 000026BD E80C03                  	call	RestUDir1
 20556 000026C0 8E06[E49D]              	mov	es,[RESSEG]
 20557                                  	;assume	es:resgroup
 20558                                  
 20559 000026C4 26A1[FA01]              	mov	ax,[es:Parent]
 20560                                  	;mov	[es:16h],ax
 20561                                  	;mov	[es:PDB_Parent_PID],ax
 20562 000026C8 26A31600                	mov	[es:PDB.PARENT_PID],ax
 20563 000026CC 26A1[FC01]              	mov	ax,[es:OldTerm]
 20564                                  	;mov	[es:0Ah],ax
 20565                                  	;mov	[es:PDB_Exit],ax
 20566 000026D0 26A30A00                	mov	[es:PDB.EXIT],ax
 20567 000026D4 26A1[FE01]              	mov	ax,[es:OldTerm+2]
 20568                                  	;mov	[es:0Ch],ax
 20569                                  	;mov	[es:PDB_Exit+2],ax
 20570 000026D8 26A30C00                	mov	[es:PDB.EXIT+2],ax
 20571                                  
 20572 000026DC 06                      	push	es
 20573 000026DD 8E06[F49D]              	mov	es,[TRAN_TPA]
 20574                                  	;mov	ah,DEALLOC
 20575 000026E1 B449                    	mov	ah,49h
 20576 000026E3 CD21                    	int	21h			; Now running in "free" space
 20577 000026E5 07                      	pop	es
 20578                                  
 20579                                  	;mov	ah,Exit
 20580 000026E6 B44C                    	mov	ah,4Ch
 20581                                  	;mov	al,byte ptr RetCode
 20582 000026E8 26A0[5602]              	mov	al,[es:RetCode]
 20583 000026EC CD21                    	int	21h
 20584                                  
 20585                                  ; ---------------------------------------------------------------------------
 20586                                  
 20587                                  ; MSDOS 6.0
 20588                                  ; ****************************************************************
 20589                                  ; *
 20590                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 20591                                  ; *
 20592                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 20593                                  ; *		 If not end of line, set up to print parse
 20594                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 20595                                  ; *		 EXPECTED!
 20596                                  ; *
 20597                                  ; * INPUT:	 DS:SI	  last output from parser
 20598                                  ; *		 ES:DI	  points to parse block
 20599                                  ; *		 CX	  last output from parser
 20600                                  ; *
 20601                                  ; * OUTPUT:	 AX	  parser return code
 20602                                  ; *
 20603                                  ; *		 if end of line found
 20604                                  ; *		     zero flag set
 20605                                  ; *		 else
 20606                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20607                                  ; *
 20608                                  ; ****************************************************************
 20609                                  
 20610                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20611                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 20612                                  
 20613                                  parse_check_eol:
 20614 000026EE 31D2                    	xor	dx,dx			;AN000;
 20615 000026F0 8936[7EA0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20616 000026F4 E87523                  	call	cmd_parse		;AN000; call parser
 20617 000026F7 3CFF                    	cmp	al,-1 ; 0FFh
 20618                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 20619 000026F9 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 20620                                  	;cmp	ax,0
 20621                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 20622 000026FB 21C0                    	and	ax,ax ; ax = 0 ?
 20623 000026FD 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 20624 000026FF 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 20625                                  ok_to_setup_pmsg:
 20626 00002700 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 20627                                  parse_good_eol:
 20628                                  parse_msg_good:	; 23/02/2023
 20629 00002703 C3                      	retn				;AN000;
 20630                                  
 20631                                  ; ---------------------------------------------------------------------------
 20632                                  
 20633                                  ; MSDOS 6.0
 20634                                  ; ****************************************************************
 20635                                  ; *
 20636                                  ; * ROUTINE:	 PARSE_WITH_MSG
 20637                                  ; *
 20638                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 20639                                  ; *		 message is set up.
 20640                                  ; *
 20641                                  ; * INPUT:	 DS:SI	  last output from parser
 20642                                  ; *		 ES:DI	  points to parse block
 20643                                  ; *		 CX	  last output from parser
 20644                                  ; *
 20645                                  ; * OUTPUT:	 AX	  parser return code
 20646                                  ; *
 20647                                  ; *		 if no error
 20648                                  ; *		     outputs from parser
 20649                                  ; *		 else
 20650                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20651                                  ; *		     error message set up for STD_PRINTF
 20652                                  ; *
 20653                                  ; ****************************************************************
 20654                                  
 20655                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20656                                  Parse_With_Msg:
 20657 00002704 8936[7EA0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20658 00002708 E86123                  	call	cmd_parse		;AN018; call parser
 20659 0000270B 3CFF                    	cmp	al,-1 ; 0FFh
 20660                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 20661 0000270D 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 20662                                  	;cmp	ax,0
 20663                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 20664 0000270F 09C0                    	or	ax,ax ; ax = 0 ?
 20665 00002711 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 20666                                  	; 23/02/2023
 20667                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 20668                                  ;parse_msg_good:
 20669                                  	;retn				;AN018;
 20670                                  	; 23/02/2023
 20671                                  	;jmp	short setup_parse_error_msg	
 20672                                  
 20673                                  ; ---------------------------------------------------------------------------
 20674                                  
 20675                                  ; MSDOS 6.0
 20676                                  ; ****************************************************************
 20677                                  ; *
 20678                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 20679                                  ; *
 20680                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 20681                                  ; *		 message is set up.
 20682                                  ; *
 20683                                  ; * INPUT:	 AX	     Parse error number
 20684                                  ; *		 SI	     Set to past last parameter
 20685                                  ; *		 Parse_last  Set to start of last parameter
 20686                                  ; *
 20687                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 20688                                  ; *		 error message set up for STD_PRINTF
 20689                                  ; *
 20690                                  ; ****************************************************************
 20691                                  
 20692                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20693                                  setup_parse_error_msg:
 20694 00002713 C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class
 20695                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 20696 00002718 BA[0392]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 20697 0000271B C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 20698                                  					;AC018; terminate the parameter string
 20699 0000271E A3[0392]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 20700 00002721 83F802                  	cmp	ax,2
 20701                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 20702 00002724 740D                    	je	short setup_parse_msg_ret
 20703                                  					;AN018;    no subst
 20704 00002726 8B36[7EA0]              	mov	si,[parse_last] 	;AC018; get start of parameter
 20705 0000272A 8936[06A1]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 20706 0000272E C606[0592]01            	mov	byte [extend_buf_sub],one_subst
 20707                                  					;AC018; put number of subst in control block
 20708                                  	;mov	byte [extend_buf_sub],1
 20709                                  setup_parse_msg_ret:
 20710 00002733 46                      	inc	si			;AN018; make sure zero flag not set
 20711 00002734 C3                      	retn				;AC018;
 20712                                  
 20713                                  ;============================================================================
 20714                                  ; TENV.ASM, MSDOS 6.0, 1991
 20715                                  ;============================================================================
 20716                                  ; 08/10/2018 - Retro DOS v3.0
 20717                                  
 20718                                  ; TITLE	Part6 COMMAND Transient routines.
 20719                                  
 20720                                  ;	Environment utilities and misc. routines
 20721                                  
 20722                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 20723                                  
 20724                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 20725                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 20726                                  
 20727                                  ; ---------------------------------------------------------------------------
 20728                                  
 20729                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20730                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20731                                  ADD_PROMPT:
 20732 00002735 E8FC00                  	call	delete_prompt	; Delete any existing prompt
 20733 00002738 E8AD01                  	call	scan_double_null
 20734                                  
 20735                                  ADD_PROMPT2:
 20736 0000273B 56                      	push	si
 20737 0000273C E89B01                  	call	GETARG
 20738 0000273F 5E                      	pop	si
 20739 00002740 7501                    	jnz	short ADD_PROMPT3
 20740                                  ADD_PROMPT_RETN:
 20741 00002742 C3                      	retn
 20742                                  ADD_PROMPT3:			; Pre scan for arguments
 20743 00002743 E87501                  	call	move_name	; Move in name
 20744 00002746 E89101                  	call	GETARG
 20745 00002749 56                      	push	si
 20746 0000274A EB53                    	jmp	short ADD_NAME
 20747                                  
 20748                                  ;break	The SET command
 20749                                  
 20750                                  ; Input: DS:SI points to a CR terminated string
 20751                                  ; Output: carry flag is set if no room
 20752                                  ;	  otherwise name is added to environment
 20753                                  
 20754                                  DISP_ENVJ:
 20755 0000274C E9BC00                  	jmp	DISP_ENV
 20756                                  
 20757                                  ADD_NAME_TO_ENVIRONMENT:
 20758 0000274F E88801                  	call	GETARG
 20759 00002752 74F8                    	jz	short DISP_ENVJ
 20760                                  
 20761                                  ; check if line contains exactly one equals sign
 20762                                  
 20763 00002754 31DB                    	xor	bx,bx		; = count is 0
 20764 00002756 56                      	push	si		; Save pointer to beginning of line
 20765                                  EQLP:
 20766 00002757 AC                      	lodsb			; Get a char
 20767 00002758 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 20768 0000275A 740F                    	je	short QUEQ	
 20769 0000275C 3C3D                    	cmp	al,'='		; Look for = sign	
 20770 0000275E 75F7                    	jne	short EQLP	; not there, get next char
 20771 00002760 FEC3                    	inc	bl		; Otherwise increment EQ count
 20772 00002762 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 20773 00002765 75F0                    	jne	short EQLP
 20774 00002767 FEC7                    	inc	bh		; Set BH=1 means no parameters
 20775 00002769 EBEC                    	jmp	short EQLP	; And look for more
 20776                                  QUEQ:
 20777 0000276B 5E                      	pop	si		; Restore beginning of line
 20778 0000276C FECB                    	dec	bl		; Zero flag means only one EQ
 20779 0000276E 7406                    	jz	short ONEQ	; Good line
 20780 00002770 BA[9B92]                	mov	dx,SYNTMES_PTR
 20781 00002773 E92707                  	jmp	cerror
 20782                                  ONEQ:
 20783 00002776 53                      	push	bx
 20784 00002777 E8BD00                  	call	delete_name_in_environment
 20785 0000277A 5B                      	pop	bx
 20786 0000277B FECF                    	dec	bh
 20787 0000277D 74C3                    	jz	short ADD_PROMPT_RETN
 20788 0000277F E86601                  	call	scan_double_null
 20789 00002782 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 20790 00002784 E83401                  	call	move_name
 20791 00002787 56                      	push	si
 20792 00002788 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 20793                                  				;  env var name
 20794                                  		
 20795                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 20796                                  ; necessary in the resident for re-reading the transient. Let's look for
 20797                                  ; COMSPEC=
 20798                                  
 20799 0000278A C606[A697]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 20800 0000278F BE[C694]                	mov	si,COMSPECSTR ; "COMSPEC="
 20801 00002792 B90400                  	mov	cx,4
 20802 00002795 F3A7                    	repe	cmpsw
 20803 00002797 7504                    	jnz	short NOT_COMSPEC
 20804                                  				; Zero set => exact match
 20805 00002799 FE06[A697]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 20806                                  	;mov	byte [COMSPEC_FLAG],1
 20807                                  NOT_COMSPEC:
 20808 0000279D 89DF                    	mov	di,bx		; Load ptr to end of env var name
 20809                                  ADD_NAME:
 20810 0000279F 5E                      	pop	si		; Add the value of the new env var
 20811 000027A0 56                      	push	si		;  to the environment.
 20812                                  ADD_NAME1:
 20813 000027A1 AC                      	lodsb
 20814 000027A2 3C0D                    	cmp	al,13 ; 0Dh
 20815 000027A4 7405                    	je	short ADD_NAME_RET
 20816 000027A6 E8AD01                  	call	store_char
 20817 000027A9 EBF6                    	jmp	short ADD_NAME1
 20818                                  ADD_NAME_RET:
 20819 000027AB 5E                      	pop	si
 20820 000027AC 803E[A697]00            	cmp	byte [comspec_flag],0
 20821                                  				; If the new env var is comspec,	
 20822                                  ADD_NAME_JZ_RET:
 20823 000027B1 748F                    	jz	short ADD_PROMPT_RETN 
 20824                                  				;  copy the value into the
 20825                                  				;  comspec var in the resident
 20826                                  
 20827                                  ; We have changed the COMSPEC variable. We need to update the resident
 20828                                  ; pieces necessary to reread in the info. First, skip all delimiters
 20829                                  
 20830 000027B3 E87303                  	call	scanoff
 20831 000027B6 8E06[E49D]              	mov	es,[RESSEG]	;  comspec var in the resident
 20832                                  
 20833                                  ; Make sure that the printer knows where the beginning of the string is
 20834                                  
 20835 000027BA BF[0702]                	mov	di,ComSpec
 20836 000027BD 89FB                    	mov	bx,di
 20837                                  
 20838                                  ; Generate drive letter for display
 20839                                  
 20840 000027BF 31C0                    	xor	ax,ax		;g assume no drive first
 20841 000027C1 26A2[5002]              	mov	[es:ComDrv],al
 20842                                  	; 23/02/2023
 20843                                  	; MSDOS 6.0 (& 5.0)
 20844 000027C5 50                      	push	ax		;AN000; 3/3/KK
 20845 000027C6 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 20846 000027C8 E83F01                  	call	testkanj	;AN000; 3/3/KK	
 20847 000027CB 58                      	pop	ax		;AN000; 3/3/KK
 20848 000027CC 7518                    	jnz	short _GOTDRIVE
 20849                                  	;
 20850 000027CE 807C013A                	cmp	byte [si+1],':'	; drive specified?
 20851 000027D2 7512                    	jne	short _GOTDRIVE
 20852 000027D4 8A04                    	mov	al,[si]		; get his specified drive
 20853                                  	; 23/02/2023
 20854 000027D6 E85B01                  	call	UPCONV
 20855                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 20856 000027D9 2C41                    	sub	al,'A'		; convert to 0-based
 20857 000027DB 83C702                  	add	di,2
 20858 000027DE FEC0                    	inc	al		; convert to 1-based number
 20859 000027E0 26A2[5002]              	mov	[es:ComDrv],al
 20860                                  
 20861                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 20862                                  ; done here..
 20863                                  	;add	al,40h
 20864 000027E4 0440                    	add	al,'A'-1
 20865                                  _GOTDRIVE:
 20866                                  	; 23/02/2023
 20867                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 20868                                  	;mov	[es:PUTBACKSUBSTPTR],di
 20869                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 20870 000027E6 26893E[E601]            	mov	[es:PutBackComSpec],di
 20871                                  				;g point to beginning of name after drive
 20872                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 20873                                  	;mov	[es:PUTBACKDRV],al
 20874                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 20875 000027EB 26A2[EB01]              	mov	[es:PutBackDrv],al
 20876                                  
 20877                                  ; Copy chars until delim      	
 20878                                  
 20879 000027EF 89DF                    	mov	di,bx
 20880                                  COPY_COMSPEC:
 20881 000027F1 AC                      	lodsb
 20882 000027F2 E83C03                  	call	DELIM
 20883 000027F5 7407                    	jz	short COPYDONE
 20884 000027F7 3C0D                    	cmp	al,13 ; 0Dh
 20885 000027F9 7403                    	je	short COPYDONE
 20886 000027FB AA                      	stosb
 20887 000027FC EBF3                    	jmp	short COPY_COMSPEC
 20888                                  COPYDONE:
 20889 000027FE 30C0                    	xor	al,al		; Null terminate the string and quit
 20890 00002800 AA                      	stosb
 20891                                  	;mov	byte [comspec_flag],0
 20892 00002801 A2[A697]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 20893 00002804 4F                      	dec	di
 20894 00002805 26893E[4702]            	mov	[es:ComSpec_End],di
 20895 0000280A C3                      	retn
 20896                                  
 20897                                  DISP_ENV:
 20898 0000280B 8E1E[E49D]              	mov	ds,[RESSEG]
 20899 0000280F 8E1E[FA03]              	mov	ds,[EnvirSeg]
 20900                                  	; assume ds:nothing
 20901 00002813 31F6                    	xor	si,si
 20902                                  PENVLP:
 20903 00002815 803C00                  	cmp	byte [si],0
 20904 00002818 7497                    	jz	short ADD_NAME_JZ_RET
 20905 0000281A BF[82A0]                	mov	di,Arg_Buf
 20906                                  PENVLP2:
 20907 0000281D AC                      	lodsb
 20908 0000281E AA                      	stosb
 20909 0000281F 08C0                    	or	al,al
 20910 00002821 75FA                    	jnz	short PENVLP2
 20911 00002823 BA[A093]                	mov	dx,arg_buf_ptr
 20912 00002826 1E                      	push	ds
 20913 00002827 06                      	push	es
 20914 00002828 1F                      	pop	ds
 20915                                  	; assume ds:nothing
 20916 00002829 E8032D                  	call	Printf_Crlf
 20917 0000282C 1F                      	pop	ds
 20918 0000282D EBE6                    	jmp	short PENVLP
 20919                                  
 20920                                  ; =============== S U B	R O U T	I N E =======================================
 20921                                  
 20922                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20923                                  delete_path:
 20924 0000282F BE[BA94]                	mov	si,PATH_TEXT ; "PATH="
 20925 00002832 EB03                    	jmp	short delete_name_in_environment
 20926                                  
 20927                                  ; =============== S U B	R O U T	I N E =======================================
 20928                                  
 20929                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20930                                  delete_prompt:
 20931 00002834 BE[BF94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20932                                  
 20933                                  ; ---------------------------------------------------------------------------
 20934                                  
 20935                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20936                                  delete_name_in_environment:
 20937                                  
 20938                                  ; Input: DS:SI points to a "=" terminated string
 20939                                  ; Output: carry flag is set if name not found
 20940                                  ;	  otherwise name is deleted
 20941                                  
 20942 00002837 56                      	push	si
 20943 00002838 1E                      	push	ds
 20944 00002839 E82C00                  	call	FIND		; ES:DI points to name
 20945 0000283C 7217                    	jc	short del1
 20946 0000283E 89FE                    	mov	si,di		; Save it
 20947 00002840 E8BF00                  	call	SCASB2		; Scan for the nul
 20948 00002843 87F7                    	xchg	si,di
 20949                                  ;SR;
 20950                                  ; If we have only one env string, then the double null is lost when the last
 20951                                  ;string is deleted and we have an invalid empty environment with only a 
 20952                                  ;single null. To avoid this, we will look for the double null case and then
 20953                                  ;move an extra null char.
 20954                                  ; Bugbug: The only possible problem is that the last pathstring 
 20955                                  ;will be followed by a triple null. Is this really a problem?
 20956                                  
 20957                                  	; MSDOS 6.0
 20958 00002845 26803C00                	cmp	byte [es:si],0	;null char?
 20959 00002849 7501                    	jnz	short not_dnull	;no, we are at a double null
 20960 0000284B 4E                      	dec	si		;point at the double null
 20961                                  not_dnull:
 20962                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20963 0000284C E86901                  	call	GETENVSIZ
 20964 0000284F 29F1                    	sub	cx,si
 20965 00002851 06                      	push	es
 20966 00002852 1F                      	pop	ds		; ES:DI points to name
 20967                                  				; DS:SI points to next name
 20968 00002853 F3A4                    	rep	movsb
 20969                                  del1:
 20970 00002855 1F                      	pop	ds
 20971 00002856 5E                      	pop	si
 20972                                  find_retn:
 20973 00002857 C3                      	retn
 20974                                  
 20975                                  ; =============== S U B	R O U T	I N E =======================================
 20976                                  
 20977                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20978                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 20979                                  find_path:
 20980 00002858 BE[BA94]                	mov	si,PATH_TEXT ; "PATH="
 20981 0000285B EB03                    	jmp	short find_name_in_environment
 20982                                  
 20983                                  ; =============== S U B	R O U T	I N E =======================================
 20984                                  
 20985                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20986                                  find_prompt:
 20987 0000285D BE[BF94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 20988                                  
 20989                                  ; ---------------------------------------------------------------------------
 20990                                  
 20991                                  find_name_in_environment:
 20992                                  
 20993                                  ; Input: DS:SI points to a "=" terminated string
 20994                                  ; Output: ES:DI points to the arguments in the environment
 20995                                  ;	  zero is set if name not found
 20996                                  ;	  carry flag is set if name not valid format
 20997                                  
 20998 00002860 E80500                  	call	FIND		; Find the name
 20999 00002863 72F2                    	jc	short find_retn	; Carry means not found	
 21000 00002865 E99600                  	jmp	SCASB1		; Scan for = sign
 21001                                  
 21002                                  ; ---------------------------------------------------------------------------
 21003                                  	;nop
 21004                                  
 21005                                  ; =============== S U B	R O U T	I N E =======================================
 21006                                  
 21007                                  ; On return of FIND1, ES:DI points to beginning of name
 21008                                  
 21009                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21010                                  FIND:
 21011 00002868 FC                      	cld
 21012 00002869 E84100                  	call	COUNT0		; CX = Length of name
 21013 0000286C 8E06[E49D]              	mov	es,[RESSEG]
 21014                                  	;assume es:RESGROUP
 21015 00002870 268E06[FA03]            	mov	es,[es:EnvirSeg]
 21016                                  	;assume es:NOTHING
 21017 00002875 31FF                    	xor	di,di
 21018                                  find1:	
 21019 00002877 51                      	push	cx
 21020 00002878 56                      	push	si
 21021 00002879 57                      	push	di
 21022                                  find11:
 21023 0000287A AC                      	lodsb
 21024                                  	; 23/02/2023 
 21025                                  	; MSDOS 6.0 (& 5.0)
 21026 0000287B E88C00                  	call	testkanj	
 21027 0000287E 740F                    	jz	short notkanj3
 21028 00002880 4E                      	dec	si
 21029 00002881 AD                      	lodsw
 21030 00002882 47                      	inc	di
 21031 00002883 47                      	inc	di
 21032 00002884 263B45FE                	cmp	ax,[es:di-2]
 21033 00002888 7511                    	jne	short find12
 21034 0000288A 49                      	dec	cx
 21035 0000288B E2ED                    	loop	find11
 21036 0000288D EB0C                    	jmp	short find12
 21037                                  notkanj3:
 21038 0000288F E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 21039                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21040 00002892 47                      	inc	di
 21041 00002893 263A45FF                	cmp	al,[es:di-1]
 21042 00002897 7502                    	jne	short find12
 21043 00002899 E2DF                    	loop	find11
 21044                                  find12:
 21045 0000289B 5F                      	pop	di
 21046 0000289C 5E                      	pop	si
 21047 0000289D 59                      	pop	cx
 21048 0000289E 74B7                    	jz	short find_retn
 21049 000028A0 51                      	push	cx
 21050 000028A1 E85E00                  	call	SCASB2		; Scan for a nul
 21051 000028A4 59                      	pop	cx
 21052 000028A5 26803D00                	cmp	byte [es:di],0
 21053 000028A9 75CC                    	jnz	short find1
 21054 000028AB F9                      	stc			; Indicate not found
 21055 000028AC C3                      	retn
 21056                                  
 21057                                  ; =============== S U B	R O U T	I N E =======================================
 21058                                  
 21059                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21060                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 21061                                  COUNT0:
 21062 000028AD 1E                      	push	ds
 21063 000028AE 07                      	pop	es
 21064                                  	;assume es:nothing
 21065 000028AF 89F7                    	mov	di,si
 21066                                  ;COUNT1:
 21067 000028B1 57                      	push	di		; Count number of chars until "="
 21068 000028B2 E84900                  	call	SCASB1
 21069                                  	; 23/02/2023
 21070                                  ;	jmp	short COUNTX
 21071                                  ;COUNT2:
 21072                                  ;	push	di		; Count number of chars until nul
 21073                                  ;	call	SCASB2
 21074                                  ;COUNTX:
 21075 000028B5 59                      	pop	cx
 21076 000028B6 29CF                    	sub	di,cx
 21077 000028B8 87F9                    	xchg	di,cx
 21078                                  move_name_retn:
 21079 000028BA C3                      	retn
 21080                                  
 21081                                  ; =============== S U B	R O U T	I N E =======================================
 21082                                  
 21083                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21084                                  move_name:
 21085 000028BB 803C0D                  	cmp	byte [si],13 ; 0Dh
 21086 000028BE 74FA                    	je	short move_name_retn
 21087 000028C0 AC                      	lodsb
 21088                                  	; 23/02/2023 
 21089                                  	; MSDOS 6.0 (& 5.0)
 21090 000028C1 E84600                  	call	testkanj		
 21091 000028C4 7409                    	jz	short notkanj1
 21092 000028C6 E88D00                  	call	store_char
 21093 000028C9 AC                      	lodsb
 21094 000028CA E88900                  	call	store_char
 21095 000028CD EBEC                    	jmp	short move_name
 21096                                  notkanj1: 
 21097 000028CF E86200                  	call	UPCONV
 21098                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 21099 000028D2 E88100                  	call	store_char
 21100 000028D5 3C3D                    	cmp	al,'='
 21101 000028D7 75E2                    	jne	short move_name
 21102                                  getarg_retn:
 21103 000028D9 C3                      	retn
 21104                                  
 21105                                  ; =============== S U B	R O U T	I N E =======================================
 21106                                  
 21107                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21108                                  GETARG:
 21109 000028DA BE8000                  	mov	si,80h
 21110 000028DD AC                      	lodsb
 21111 000028DE 08C0                    	or	al,al
 21112 000028E0 74F7                    	jz	short getarg_retn
 21113 000028E2 E84402                  	call	scanoff
 21114 000028E5 3C0D                    	cmp	al,13 ; 0Dh
 21115                                  sdn_retn:
 21116 000028E7 C3                      	retn
 21117                                  
 21118                                  ; =============== S U B	R O U T	I N E =======================================
 21119                                  
 21120                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 21121                                  ; there is NO double NULL, merely a string that is empty.
 21122                                  
 21123                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21124                                  scan_double_null:
 21125 000028E8 8E06[E49D]              	mov	es,[RESSEG]
 21126 000028EC 268E06[FA03]            	mov	es,[es:EnvirSeg]
 21127 000028F1 31FF                    	xor	di,di
 21128                                  
 21129                                  ; Top cycle-point. If the string here is empty, then we are done
 21130                                  
 21131                                  sdn1:
 21132 000028F3 26803D00                	cmp	byte [es:di],0	; nul string?
 21133 000028F7 74EE                    	jz	short sdn_retn	; yep, all done
 21134 000028F9 E80600                  	call	SCASB2
 21135 000028FC EBF5                    	jmp	short sdn1
 21136                                  
 21137                                  ; =============== S U B	R O U T	I N E =======================================
 21138                                  
 21139                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21140                                  SCASB1:
 21141 000028FE B03D                    	mov	al,'='		; Scan for an =
 21142 00002900 EB02                    	jmp	short SCASBX
 21143                                  
 21144                                  ; =============== S U B	R O U T	I N E =======================================
 21145                                  
 21146                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21147                                  SCASB2:
 21148 00002902 30C0                    	xor	al,al		; Scan for a nul
 21149                                  
 21150                                  ; ---------------------------------------------------------------------------
 21151                                  
 21152                                  	; 23/02/2023
 21153                                  SCASBX:
 21154 00002904 B90001                  	mov	cx,256
 21155 00002907 F2AE                    	repne	scasb
 21156 00002909 C3                      	retn
 21157                                  
 21158                                  ; =============== S U B	R O U T	I N E =======================================
 21159                                  
 21160                                  ; MSDOS 6.0
 21161                                  
 21162                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 21163                                  
 21164                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21165                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 21166                                  testkanj:
 21167 0000290A 1E                      	push	ds			;AN000;  3/3/KK
 21168 0000290B 56                      	push	si			;AN000;  3/3/KK
 21169 0000290C 50                      	push	ax			;AN000;  3/3/KK
 21170 0000290D 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 21171 00002912 C536[7A02]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 21172                                  ktlop:					;AN000;  3/3/KK
 21173 00002916 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 21174 00002919 740E                    	je	short notlead 		;AN000;  3/3/KK
 21175 0000291B 58                      	pop	ax			;AN000;  3/3/KK
 21176 0000291C 50                      	push	ax			;AN000;  3/3/KK
 21177 0000291D 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21178 0000291F 7208                    	jb	short notlead 		;AN000;  3/3/KK
 21179 00002921 46                      	inc	si			;AN000;  3/3/KK
 21180 00002922 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21181 00002924 7607                    	jbe	short islead		;AN000;  3/3/KK
 21182 00002926 46                      	inc	si			;AN000;  3/3/KK
 21183 00002927 EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 21184                                  notlead:				;AN000;  3/3/KK
 21185 00002929 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 21186 0000292B EB03                    	jmp	short ktret		;AN000;  3/3/KK
 21187                                  islead: 				;AN000;  3/3/KK
 21188 0000292D 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 21189 0000292F 40                      	inc	ax			;AN000;  3/3/KK
 21190                                  ktret:					;AN000;  3/3/KK
 21191 00002930 58                      	pop	ax			;AN000;  3/3/KK
 21192 00002931 5E                      	pop	si			;AN000;  3/3/KK
 21193 00002932 1F                      	pop	ds			;AN000;  3/3/KK
 21194 00002933 C3                      	retn				;AN000;  3/3/KK
 21195                                  
 21196                                  ; =============== S U B	R O U T	I N E =======================================
 21197                                  
 21198                                  ; MSDOS 6.0
 21199                                  
 21200                                  ; ****************************************************************
 21201                                  ; *
 21202                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 21203                                  ; *
 21204                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 21205                                  ; *		 the character in AL from the file upper case table
 21206                                  ; *		 in DOS if character if above  ascii 128, else
 21207                                  ; *		 subtracts 20H if between "a" and "z".
 21208                                  ; *
 21209                                  ; * INPUT:	 AL	      char to be upper cased
 21210                                  ; *		 FUCASE_ADDR  set to the file upper case table
 21211                                  ; *
 21212                                  ; * OUTPUT:	 AL	      upper cased character
 21213                                  ; *
 21214                                  ; ****************************************************************
 21215                                  
 21216                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21217                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 21218                                  
 21219                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21220                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2A6Eh
 21221                                  UPCONV:
 21222 00002934 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 21223 00002936 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 21224 00002938 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 21225 0000293A 1E                      	push	ds			;AN000;
 21226 0000293B 53                      	push	bx			;AN000;
 21227 0000293C 8E1E[E49D]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 21228                                  	;lds	bx,dword ptr FUCase_Addr+1
 21229 00002940 C51E[7202]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 21230 00002944 83C302                  	add	bx,2			;AN000;  skip over first word
 21231                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 21232 00002947 D7                      	xlat
 21233 00002948 5B                      	pop	bx			;AN000;
 21234 00002949 1F                      	pop	ds			;AN000;
 21235                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 21236                                  	; 10/06/2023
 21237                                  upconv_end:
 21238                                  	; 24/02/2023
 21239 0000294A C3                      	retn
 21240                                  oth_fucase:				;AN000;
 21241 0000294B 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 21242 0000294D 72FB                    	jb	short upconv_end	;AC000;    subtract 20h to get
 21243 0000294F 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 21244 00002951 77F7                    	ja	short upconv_end	;AC000;
 21245 00002953 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 21246                                  ;upconv_end:	; 10/06/2023		;AN000;
 21247 00002955 C3                      	retn
 21248                                  
 21249                                  ; ---------------------------------------------------------------------------
 21250                                  
 21251                                  ; MSDOS 3.3
 21252                                  
 21253                                  	; 24/02/2023
 21254                                  ;UPCONV_MAPCALL:
 21255                                  	;			; If between "a" and "z"
 21256                                  	;cmp	al,[small_a]
 21257                                  	;jb	short UPCONV_END
 21258                                  	;cmp	al,[small_z]
 21259                                  	;ja	short UPCONV_END
 21260                                  	;sub	al,20h		; Change lower-case to upper
 21261                                  ;UPCONV_END:
 21262                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 21263                                  	;			  ; 	  for (current) country
 21264                                  	;retn
 21265                                  
 21266                                  ; =============== S U B	R O U T	I N E =======================================
 21267                                  
 21268                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 21269                                  
 21270                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21271                                  store_char:
 21272 00002956 51                      	push	cx
 21273 00002957 53                      	push	bx
 21274                                  
 21275                                  	; 24/02/2023
 21276                                  	;;16/10/2018
 21277                                  	; MSDOS 6.0
 21278 00002958 06                      	push	es		;AN056;*
 21279 00002959 1E                      	push	ds		;AN056; Save local DS
 21280 0000295A 8E1E[E49D]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 21281 0000295E 8E06[FA03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 21282 00002962 1F                      	pop	ds		;AN056; Get local segment back
 21283                                  
 21284                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21285 00002963 E85200                  	call	GETENVSIZ
 21286 00002966 89CB                    	mov	bx,cx		; Save room for double nul	
 21287 00002968 83EB02                  	sub	bx,2
 21288 0000296B 39DF                    	cmp	di,bx
 21289 0000296D 723F                    	jb	short store1
 21290 0000296F 50                      	push	ax
 21291 00002970 51                      	push	cx
 21292 00002971 53                      	push	bx		; Save Size of environment
 21293 00002972 E862DE                  	call	FREE_TPA
 21294 00002975 5B                      	pop	bx
 21295 00002976 83C302                  	add	bx,2		; Recover true environment size
 21296                                  
 21297 00002979 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 21298 0000297D 7203                    	jb	short envsiz_ok
 21299                                  bad_env_size:			;AN056;
 21300 0000297F F9                      	stc
 21301 00002980 EB16                    	jmp	short envnoset
 21302                                  	;nop
 21303                                  envsiz_ok:
 21304 00002982 B104                    	mov	cl,4
 21305 00002984 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 21306 00002986 43                      	inc	bx
 21307                                  	; 24/02/2023
 21308                                  	; MSDOS 6.0
 21309 00002987 8CC1                    	mov	cx,es		;AN056; Get environment segment
 21310 00002989 01D9                    	add	cx,bx		;AN056; Add in size of environment
 21311 0000298B 83C120                  	add	cx,20h		;AN056; Add in some TPA
 21312 0000298E 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 21313 00002990 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 21314 00002992 73EB                    	jnb	short bad_env_size
 21315                                  				;AN056; Yes - don't do it!!!
 21316                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21317 00002994 B44A                    	mov	ah,4Ah
 21318                                  	;mov	ah,SETBLOCK ; 4Ah
 21319 00002996 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 21320                                  			; ES = segment address of block	to change
 21321                                  			; BX = new size	in paragraphs
 21322                                  envnoset:
 21323 00002998 9C                      	pushf
 21324 00002999 06                      	push	es
 21325 0000299A 8E06[E49D]              	mov	es,[RESSEG]
 21326 0000299E E846DE                  	call	ALLOC_TPA
 21327 000029A1 07                      	pop	es
 21328 000029A2 9D                      	popf
 21329 000029A3 59                      	pop	cx
 21330 000029A4 58                      	pop	ax
 21331                                  	; 10/06/2023
 21332 000029A5 7307                    	jnc	short store1
 21333                                  	; 24/02/2023
 21334 000029A7 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 21335                                  	;jnc	short store1
 21336 000029A8 BA[1A92]                	mov	dx,ENVERR_PTR
 21337 000029AB E9EF04                  	jmp	cerror
 21338                                  store1:	
 21339 000029AE AA                      	stosb
 21340 000029AF 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 21341                                  	; 24/02/2023
 21342 000029B4 07                      	pop	es ; MSDOS 6.0	;AN056;*
 21343 000029B5 5B                      	pop	bx
 21344 000029B6 59                      	pop	cx
 21345 000029B7 C3                      	retn
 21346                                  
 21347                                  ; =============== S U B	R O U T	I N E =======================================
 21348                                  
 21349                                  	; 24/02/2023
 21350                                  GETENVSIZ:
 21351                                  
 21352                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 21353                                  ;ES has environment segment
 21354                                  ;Size returned in CX, all other registers preserved
 21355                                  
 21356 000029B8 06                      	push	es
 21357 000029B9 50                      	push	ax
 21358 000029BA 8CC0                    	mov	ax,es
 21359 000029BC 48                      	dec	ax		;Point at arena	
 21360 000029BD 8EC0                    	mov	es,ax
 21361                                  	;mov	ax,[es:3]
 21362 000029BF 26A10300                	mov	ax,[es:ARENA.size]
 21363 000029C3 B104                    	mov	cl,4
 21364 000029C5 D3E0                    	shl	ax,cl		;Convert to bytes
 21365 000029C7 89C1                    	mov	cx,ax
 21366 000029C9 58                      	pop	ax
 21367 000029CA 07                      	pop	es
 21368                                  getenvsiz_retn:
 21369 000029CB C3                      	retn
 21370                                  
 21371                                  ; =============== S U B	R O U T	I N E =======================================
 21372                                  
 21373                                  	; 24/02/2023
 21374                                  RestUDir1:
 21375 000029CC 1E                      	push	ds
 21376 000029CD 8E1E[E49D]              	mov	ds,[RESSEG]
 21377 000029D1 803E[5D02]00            	cmp	byte [RestDir],0
 21378 000029D6 1F                      	pop	ds
 21379 000029D7 74F2                    	jz	short getenvsiz_retn
 21380                                  
 21381                                  ; =============== S U B	R O U T	I N E =======================================
 21382                                  
 21383                                  	; 24/02/2023
 21384                                  RestUDir:
 21385 000029D9 BA[C69C]                	mov	dx,USERDIR1
 21386 000029DC B43B                    	mov	ah,3Bh
 21387                                  	;mov	ah,CHDir ; 3Bh
 21388 000029DE CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21389                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21390 000029E0 30C0                    	xor	al,al
 21391                                  	;call	SETREST
 21392                                  	;retn
 21393                                  	; 24/02/2023
 21394 000029E2 E94B08                  	jmp	SETREST	
 21395                                  
 21396                                  ;============================================================================
 21397                                  ; TENV2.ASM, MSDOS 6.0, 1991
 21398                                  ;============================================================================
 21399                                  ; 07/10/2018 - Retro DOS v3.0
 21400                                  
 21401                                  ; TITLE	Part6 COMMAND Transient routines.
 21402                                  
 21403                                  ;	Environment utilities and misc. routines
 21404                                  
 21405                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 21406                                  
 21407                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21408                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 21409                                  
 21410                                  ; ---------------------------------------------------------------------------
 21411                                  
 21412                                  ; ****************************************************************
 21413                                  ; *
 21414                                  ; * ROUTINE:	 $CHDIR
 21415                                  ; *
 21416                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 21417                                  ; *		 line. If path is found, CHDIR to path. If a drive
 21418                                  ; *		 letter is found, get and display the current dir
 21419                                  ; *		 of the specified drive. If nothing is found, get
 21420                                  ; *		 and display the current dir of the default drive.
 21421                                  ; *
 21422                                  ; * INPUT:	 command line at offset 81H
 21423                                  ; *
 21424                                  ; * OUTPUT:	 none
 21425                                  ; *
 21426                                  ; ****************************************************************
 21427                                  
 21428                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21429                                  
 21430                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21431                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B21h
 21432                                  _$CHDIR:
 21433                                  	; MSDOS 6.0
 21434 000029E5 BE8100                  	mov	si,81h
 21435 000029E8 BF[5498]                	mov	di,PARSE_CHDIR
 21436                                  				;AN000; Get address of PARSE_CHDIR
 21437 000029EB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21438 000029ED 31D2                    	xor	dx,dx		;AN000;
 21439 000029EF E812FD                  	call	Parse_With_Msg	;AC018; call parser
 21440                                  	
 21441                                  	;cmp	ax,-1
 21442                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 21443                                  	;je	short bwdj	; No args
 21444                                  	;;cmp	ax,0
 21445                                  	;;cmp	ax,RESULT_NO_ERROR
 21446                                  	;			;AC000; did we have an error?
 21447                                  	;or	ax,ax ; ax = 0 ?
 21448                                  	;jnz	short ChDirErr	;AC018; yes - exit
 21449                                  	
 21450                                  	; 10/06/2023
 21451 000029F2 40                      	inc	ax	; cmp ax,-1
 21452 000029F3 7414                    	jz	short bwdj ; 0FFFFh -> 0
 21453 000029F5 48                      	dec	ax	; cmp ax,0
 21454 000029F6 756D                    	jnz	short ChDirErr ; 1 -> 0
 21455                                  	; ax = 0
 21456                                  
 21457                                  	;cmp	byte [PARSE1_TYPE],6
 21458 000029F8 803E[57AA]06            	cmp	byte [PARSE1_TYPE],result_drive
 21459                                  				;AC000; was a drive entered?
 21460 000029FD 7511                    	jne	short REALCD	; no
 21461                                  
 21462                                  ; D: was found. See if there is anything more.
 21463                                  
 21464 000029FF BF[5498]                	mov	di,PARSE_CHDIR
 21465                                  				;AC000; get address of parse_chdir
 21466 00002A02 31D2                    	xor	dx,dx		;AC000;
 21467 00002A04 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 21468 00002A07 755C                    	jnz	short ChDirErr	;AC000;
 21469                                  bwdj:
 21470 00002A09 E87BF9                  	call	build_dir_for_chdir
 21471                                  				; Drive only specified
 21472 00002A0C E80D01                  	call	CRLF2
 21473                                  chdir_retn:
 21474 00002A0F C3                      	retn
 21475                                  
 21476                                  	; 24/02/2023
 21477                                  	; MSDOS 3.3
 21478                                  	;mov	ax,[COMSW]
 21479                                  	;or	ax,[ALLSWITCH]
 21480                                  	;mov	dx,BADPARMPTR
 21481                                  	;jnz	short CHDIR_ERR
 21482                                  	;mov	si,81h
 21483                                  	;call	SCANOFF
 21484                                  	;cmp	al,0Dh		; are we at end of line?
 21485                                  	;je	short BWDJ	; No args
 21486                                  	;inc	si
 21487                                  	;lodsb
 21488                                  	;cmp	al,':'
 21489                                  	;jne	short REALCD
 21490                                  	;push	si
 21491                                  	;call	SCANOFF
 21492                                  	;pop	si
 21493                                  	;cmp	al,0Dh		; was a drive entered?
 21494                                  	;jne	short REALCD	; no
 21495                                  ;BWDJ:
 21496                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 21497                                  	;call	CRLF2
 21498                                  ;CHDIR_RETN:
 21499                                  	;retn
 21500                                  
 21501                                  	; 24/02/2023
 21502                                  	; MSDOS 6.0
 21503                                  REALCD:
 21504 00002A10 56                      	push	si		;AN000; save position in line
 21505 00002A11 C536[5BAA]              	lds	si,[PARSE1_ADDR]
 21506                                  				;AN000; get address of filespec
 21507 00002A15 E8DA07                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 21508 00002A18 5E                      	pop	si		;AN000; restore position in line
 21509 00002A19 BF[5498]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 21510 00002A1C 31D2                    	xor	dx,dx		;AC000;
 21511 00002A1E E8CDFC                  	call	parse_check_eol ;AC000; call parser
 21512 00002A21 7542                    	jnz	short ChDirErr	;AC000;
 21513                                  	
 21514 00002A23 E81106                  	call	SETPATH
 21515 00002A26 F606[23A1]02            	test	byte [DestInfo],2
 21516 00002A2B 7518                    	jnz	short BadChDir
 21517                                  
 21518                                  	; 26/04/2023
 21519 00002A2D B43B                    	mov	ah,3Bh
 21520                                  	;mov	ah,CHDir
 21521 00002A2F CD21                    	int	21h
 21522 00002A31 73DC                    	jnc	short chdir_retn
 21523                                  	
 21524 00002A33 E818F8                  	call	get_ext_error_number
 21525                                  				;AN022; get the extended error
 21526 00002A36 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21527                                  				;AN022; see if path not found
 21528 00002A39 740A                    	je	short BadChDir	;AN022; yes - issue old message
 21529                                  ;SR;
 21530                                  ; We want to issue "Invalid Directory" message even if the path is valid
 21531                                  ;but is not a directory. The extended error returns "Access denied" which
 21532                                  ;is kind of confusing. Issue the old message if access denied error is 
 21533                                  ;returned
 21534                                  
 21535 00002A3B 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21536 00002A3E 7405                    	je	short BadChDir
 21537                                  	
 21538 00002A40 E89E00                  	call	set_ext_error_subst ;AN022;
 21539 00002A43 EB20                    	jmp	short ChDirErr	;AN022;
 21540                                  
 21541                                  BadChDir:
 21542 00002A45 BA[3E93]                	mov	dx,badcd_ptr
 21543                                  ;ChDirErr:
 21544                                  ;	call	std_eprintf
 21545                                  ;mkdir_retn:
 21546                                  	;retn
 21547                                  	; 24/02/2023
 21548 00002A48 EB1B                    	jmp	short ChDirErr	;AN022;
 21549                                  
 21550                                  	; 24/02/2023
 21551                                  	; MSDOS 3.3
 21552                                  ;REALCD:
 21553                                  	;call	SETPATH
 21554                                  	;test	byte [DESTINFO],2
 21555                                  	;jnz	short BADCHDIR
 21556                                  	;mov	ah,CHDir ; 3Bh
 21557                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21558                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 21559                                  	;jnc	short CHDIR_RETN
 21560                                  ;BADCHDIR:
 21561                                  	;mov	dx,BADCDPTR
 21562                                  ;CHDIR_ERR:
 21563                                  	;call	STD_EPRINTF
 21564                                  ;MKDIR_RETN:
 21565                                  	;retn
 21566                                  
 21567                                  ; =============== S U B	R O U T	I N E =======================================
 21568                                  
 21569                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21570                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 21571                                  
 21572                                  	; 11/06/2023 - Retro DOS v4.2
 21573                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B8Ch
 21574                                  _$MKDIR:
 21575                                  	; MSDOS 6.0
 21576 00002A4A E86300                  	call	SETRMMK
 21577 00002A4D 7216                    	jc	short MkDirErr
 21578                                  
 21579 00002A4F B439                    	mov	ah,39h
 21580                                  	;mov	ah,MKDIR
 21581 00002A51 CD21                    	int	21h
 21582 00002A53 7313                    	jnc	short mkdir_retn
 21583                                  
 21584 00002A55 E8F6F7                  	call	get_ext_error_number	
 21585                                  				;AN022; get the extended error
 21586 00002A58 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21587                                  				;AN022; see if path not found
 21588 00002A5B 742A                    	je	short MD_other_err
 21589                                  				;AN022; yes - issue old message
 21590 00002A5D 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21591                                  				;AN022; access denied?
 21592 00002A60 7407                    	je	short badmderr	;AN022; yes - see if file exists
 21593                                  	
 21594 00002A62 E87C00                  	call	set_ext_error_subst
 21595                                  				;AN022;
 21596                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 21597                                  	; 24/02/2023
 21598                                  ChDirErr:
 21599                                  MkDirErr:
 21600                                  RmDirErr:
 21601 00002A65 E8CD2A                  	call	std_eprintf
 21602                                  mkdir_retn:
 21603                                  rmdir_retn:
 21604 00002A68 C3                      	retn
 21605                                  	
 21606                                  badmderr:
 21607 00002A69 BA[129B]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 21608 00002A6C B41A                    	mov	ah,1Ah
 21609                                  	;mov	ah,Set_DMA	;AN006;
 21610 00002A6E CD21                    	int	21h		;AN006;
 21611                                  	
 21612 00002A70 B44E                    	mov	ah,4Eh
 21613                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 21614                                  	;mov	cx,10h
 21615 00002A72 B91000                  	mov	cx,ATTR_DIRECTORY
 21616                                  				;AN006;   search for directory
 21617 00002A75 CD21                    	int	21h		;AN006;
 21618 00002A77 720E                    	jc	short MD_other_err
 21619                                  				;AN006; doesn't exist - must be something else
 21620                                  	;;mov	dl,SRCXNAME.find_buf_attr
 21621                                  				;AN006; we found a file/dir
 21622                                  	;mov	dl,[SRCXNAME+21] 
 21623 00002A79 8A16[279B]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 21624 00002A7D F6C210                  	test	dl,ATTR_DIRECTORY
 21625                                  				;AN006; was it a directory?
 21626 00002A80 7405                    	jz	short MD_other_err
 21627                                  				;AN006; no - must have been a file
 21628 00002A82 BA[3194]                	mov	dx,MD_EXISTS_PTR
 21629                                  				;AN006; set up already exists error
 21630 00002A85 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 21631                                  MD_other_err:			;AN006;
 21632 00002A87 BA[4193]                	mov	dx,badmkd_ptr
 21633                                  ;MkDirErr:
 21634                                  	;call	std_eprintf
 21635                                  	;retn
 21636                                  	; 24/02/2023
 21637 00002A8A EBD9                    	jmp	short MkDirErr
 21638                                  
 21639                                  	; 24/02/2023
 21640                                  	; MSDOS 3.3
 21641                                  	;call	SETRMMK
 21642                                  	;jb	short MKDIRERR
 21643                                  	;mov	ah,MKDIR ; 39h
 21644                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 21645                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 21646                                  	;jnc	short MKDIR_RETN
 21647                                  	;mov	dx,BADMKDPTR
 21648                                  	;call	GET_EXT_ERR_NUMBER
 21649                                  ;MKDIRERR:
 21650                                  	;call	STD_EPRINTF
 21651                                  	;retn
 21652                                  
 21653                                  ; =============== S U B	R O U T	I N E =======================================
 21654                                  
 21655                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21656                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 21657                                  	; 11/06/2023 - Retro DOS v4.2
 21658                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2C00h
 21659                                  _$RMDIR:
 21660 00002A8C E82100                  	call	SETRMMK
 21661 00002A8F 72D4                    	jb	short RmDirErr
 21662 00002A91 7518                    	jnz	short badrderr
 21663                                  
 21664 00002A93 B43A                    	mov	ah,3Ah
 21665                                  	;mov	ah,RMDIR ; 3Ah
 21666 00002A95 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 21667                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 21668 00002A97 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 21669                                  
 21670                                  	; 24/02/2023
 21671                                  	; MSDOS 6.0
 21672 00002A99 E8B2F7                  	call	get_ext_error_number
 21673                                  				;AN022; get the extended error
 21674 00002A9C 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21675                                  				;AN022; see if path not found
 21676 00002A9F 740A                    	je	short badrderr	;AN022; yes - issue old message
 21677 00002AA1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21678                                  				;AN022; access denied?
 21679 00002AA4 7405                    	je	short badrderr	;AN022; yes - issue old message
 21680                                  
 21681 00002AA6 E83800                  	call	set_ext_error_subst
 21682                                  				;AN022;
 21683 00002AA9 EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 21684                                  
 21685                                  	; MSDOS 6.0
 21686                                  badrderr:
 21687                                  	; 24/02/2023
 21688 00002AAB BA[4493]                	mov	dx,badrmd_ptr
 21689 00002AAE EBB5                    	jmp	short RmDirErr
 21690                                  ;RmDirErr:
 21691                                  	;call	std_eprintf
 21692                                  ;;rmdir_retn
 21693                                  	;retn
 21694                                  
 21695                                  	; 24/02/2023
 21696                                  	; MSDOS 3.3
 21697                                  	;mov	dx,BADRMDPTR
 21698                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 21699                                  ;RMDIRERR:
 21700                                  	;call	STD_EPRINTF
 21701                                  ;RMDIR_RETN:
 21702                                  	;retn
 21703                                  
 21704                                  ; =============== S U B	R O U T	I N E =======================================
 21705                                  
 21706                                  ; 	<Common MkDir/RmDir set up code>
 21707                                  ;****************************************************************
 21708                                  ;*
 21709                                  ;* ROUTINE:	SETRMMK
 21710                                  ;*
 21711                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 21712                                  ;*		commands. Parses the command line for a required
 21713                                  ;*		filespec.
 21714                                  ;*
 21715                                  ;* INPUT:	command line at offset 81H
 21716                                  ;*
 21717                                  ;* OUTPUT:	carry clear
 21718                                  ;*		    DS:DX points to ASCIIZ argument
 21719                                  ;*		carry set
 21720                                  ;*		    DS:DX has error message pointer
 21721                                  ;*
 21722                                  ;****************************************************************
 21723                                  
 21724                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21725                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 21726                                  	; 11/06/2023 - Retro DOS v4.2
 21727                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2BCEh
 21728                                  SETRMMK:
 21729                                  	; MSDOS 6.0
 21730 00002AB0 BE8100                  	mov	si,81h
 21731 00002AB3 BF[4B98]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 21732 00002AB6 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21733 00002AB8 31D2                    	xor	dx,dx		;AN000;
 21734                                  	;invoke	Parse_With_Msg	;AC000; call parser
 21735 00002ABA E847FC                  	call	Parse_With_Msg
 21736                                  	;cmp	ax,0
 21737                                  	;cmp	ax,RESULT_NO_ERROR
 21738 00002ABD 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 21739 00002ABF 7519                    	jnz	short noargerr	;AC000; yes - exit
 21740                                  
 21741 00002AC1 BF[129B]                	mov	di,SRCXNAME
 21742                                  				;AN000; get address of srcxname
 21743 00002AC4 57                      	push	di		;AN000; save address
 21744 00002AC5 56                      	push	si		;AN000; save position in line
 21745 00002AC6 C536[5BAA]              	lds	si,[PARSE1_ADDR]
 21746                                  				;AN000; get address of path
 21747                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 21748 00002ACA AC                      	lodsb			;get a char from buffer
 21749 00002ACB AA                      	stosb			;AN000; store in srcxname
 21750                                  	;cmp	al,0
 21751                                  	;cmp	al,END_OF_LINE_OUT
 21752 00002ACC 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 21753 00002ACE 75FA                    	jnz	short mrdir_move_filename
 21754                                  				;AC000; no - keep moving
 21755 00002AD0 5E                      	pop	si		;AN000; get line position back
 21756                                  
 21757                                  ; we have scanned an argument.	See if any args beyond.
 21758                                  
 21759 00002AD1 BF[4B98]                	mov	di,PARSE_MRDIR
 21760 00002AD4 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 21761 00002AD7 5A                      	pop	dx		;AC000; get address of SRCXNAME
 21762                                  	;retz			;yes - return no error
 21763 00002AD8 7406                    	jz	short setrmmk_retn
 21764                                  noargerr:
 21765 00002ADA BA[0392]                	mov	dx,extend_buf_ptr
 21766                                  				;AC000; get extended message pointer
 21767 00002ADD 31C0                    	xor	ax,ax
 21768 00002ADF F9                      	stc
 21769                                  setrmmk_retn:
 21770 00002AE0 C3                      	retn
 21771                                  
 21772                                  	; 24/02/2023
 21773                                  	; MSDOS 3.3
 21774                                  ;SETRMMK:
 21775                                  	;mov	si,81h
 21776                                  	;call	SCANOFF
 21777                                  	;cmp	al,0Dh
 21778                                  	;je	short NOARGERR
 21779                                  	;mov	dx,si
 21780                                  ;SETRMMK1:
 21781                                  	;lodsb
 21782                                  	;call	DELIM
 21783                                  	;jz	short SETRMMK3
 21784                                  	;cmp	al,0Dh
 21785                                  	;jne	short SETRMMK1
 21786                                  	;mov	byte [si-1],0
 21787                                  ;SETRMMK2:
 21788                                  	;retn
 21789                                  ;SETRMMK3:
 21790                                  	;mov	byte [si-1],0
 21791                                  	;push	si
 21792                                  	;call	SCANOFF
 21793                                  	;pop	si
 21794                                  	;cmp	al,0Dh
 21795                                  	;je	short SETRMMK2
 21796                                  ;NOARGERR:
 21797                                  	;mov	dx,BADARGSPTR
 21798                                  	;xor	ax,ax
 21799                                  	;stc
 21800                                  ;SETRMMK_RETN:
 21801                                  	;retn
 21802                                  
 21803                                  ; =============== S U B	R O U T	I N E =======================================
 21804                                  
 21805                                  ; MSDOS 6.0
 21806                                  
 21807                                  ;****************************************************************
 21808                                  ;*
 21809                                  ;* ROUTINE:	Set_ext_error_subst
 21810                                  ;*
 21811                                  ;* FUNCTION:	Sets up substitution for extended error
 21812                                  ;*
 21813                                  ;* INPUT:	AX - extended error number
 21814                                  ;*		DX - offset of string
 21815                                  ;*
 21816                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 21817                                  ;*
 21818                                  ;****************************************************************
 21819                                  
 21820                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21821                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 21822                                  set_ext_error_subst:
 21823                                  	;mov	byte [msg_disp_class],1
 21824 00002AE1 C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 21825                                  					;AN022; set up extended error msg class
 21826 00002AE6 8916[06A1]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 21827                                  	;mov	byte [extend_buf_sub],1
 21828 00002AEA C606[0592]01            	mov	byte [extend_buf_sub],one_subst 
 21829                                  	;AN022; put number of subst in control block
 21830 00002AEF BA[0392]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 21831 00002AF2 A3[0392]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 21832                                  savudir_err_retn: ; 24/02/2023
 21833 00002AF5 C3                      	retn				;AN022; return
 21834                                  
 21835                                  ; =============== S U B	R O U T	I N E =======================================
 21836                                  
 21837                                  ; <SavUDir - preserve the users current directory on a particular drive>
 21838                                  
 21839                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 21840                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 21841                                  ;   buffer
 21842                                  ;
 21843                                  ;   Inputs:	DL has 1-based drive number
 21844                                  ;		ES:DI has destination buffer (SavUDir1 only)
 21845                                  ;   Outputs:	Carry Clear
 21846                                  ;		    DS = TranGroup
 21847                                  ;		Carry Set
 21848                                  ;		    AX has error code
 21849                                  ;   Registers Modified: AX, SI
 21850                                  
 21851                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21852                                  SAVUDIR:
 21853 00002AF6 BF[C69C]                	mov	di,USERDIR1
 21854                                  ; --------------
 21855                                  SAVUDIR1:
 21856 00002AF9 88D0                    	mov	al,dl
 21857 00002AFB 0440                    	add	al,'@' ; 40h
 21858 00002AFD 3C40                    	cmp	al,'@' ; 40h
 21859 00002AFF 7506                    	jne	short GOTUDRV
 21860 00002B01 0206[F89D]              	add	al,[CURDRV]
 21861 00002B05 FEC0                    	inc	al		; A = 1
 21862                                  GOTUDRV:
 21863 00002B07 AA                      	stosb
 21864 00002B08 8A26[E99D]              	mov	ah,[DIRCHAR]
 21865 00002B0C B03A                    	mov	al,':' ; 3Ah
 21866 00002B0E AB                      	stosw
 21867 00002B0F 06                      	push	es
 21868 00002B10 1F                      	pop	ds
 21869 00002B11 89FE                    	mov	si,di
 21870 00002B13 B447                    	mov	ah,47h ; 24/02/2023
 21871                                  	;mov	ah,CURRENT_DIR	; 47h
 21872 00002B15 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 21873                                  			; DL = drive (0=default,1=A,etc.)
 21874                                  			; DS:SI	points to 64-byte buffer area
 21875 00002B17 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 21876 00002B19 0E                      	push	cs
 21877 00002B1A 1F                      	pop	ds
 21878 00002B1B C3                      	retn
 21879                                  
 21880                                  ; =============== S U B	R O U T	I N E =======================================
 21881                                  
 21882                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21883                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 21884                                  CRLF2:
 21885 00002B1C 52                      	push	dx
 21886 00002B1D BA[E593]                	mov	dx,acrlf_ptr
 21887 00002B20 1E                      	push	ds
 21888 00002B21 0E                      	push	cs
 21889 00002B22 1F                      	pop	ds
 21890 00002B23 E8172A                  	call	std_printf
 21891 00002B26 1F                      	pop	ds
 21892 00002B27 5A                      	pop	dx
 21893 00002B28 C3                      	retn
 21894                                  
 21895                                  ; =============== S U B	R O U T	I N E =======================================
 21896                                  
 21897                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 21898                                  ; may NOT be TRANGROUP
 21899                                  
 21900                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21901                                  scanoff:
 21902 00002B29 AC                      	lodsb
 21903 00002B2A E80400                  	call	DELIM
 21904 00002B2D 74FA                    	jz	short scanoff
 21905 00002B2F 4E                      	dec	si		; Point to first non-delimiter
 21906                                  scanoff_retn:
 21907 00002B30 C3                      	retn
 21908                                  
 21909                                  ; =============== S U B	R O U T	I N E =======================================
 21910                                  
 21911                                  ; Input:    AL is character to classify
 21912                                  ; Output:   Z set if delimiter
 21913                                  ;	    NZ set otherwise
 21914                                  ; Registers modified: none
 21915                                  
 21916                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21917                                  DELIM:
 21918 00002B31 3C20                    	cmp	al,' '	 ;20h
 21919 00002B33 74FB                    	je	short scanoff_retn
 21920 00002B35 3C3D                    	cmp	al,'='  ; 3Dh
 21921 00002B37 74F7                    	je	short scanoff_retn
 21922 00002B39 3C2C                    	cmp	al,','	; 2Ch
 21923 00002B3B 74F3                    	je	short scanoff_retn
 21924 00002B3D 3C3B                    	cmp	al,';'	 ;3Bh
 21925 00002B3F 74EF                    	je	short scanoff_retn
 21926 00002B41 3C09                    	cmp	al,9		; Check for TAB character
 21927 00002B43 74EB                    	je	short scanoff_retn
 21928 00002B45 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 21929 00002B47 C3                      	retn
 21930                                  
 21931                                  
 21932                                  ; =============== S U B	R O U T	I N E =======================================
 21933                                  
 21934                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21935                                  FCB_TO_ASCZ:			
 21936                                  	; Convert DS:SI to ASCIZ ES:DI
 21937 00002B48 B90800                  	mov	cx,8
 21938                                  MAINNAME:
 21939 00002B4B AC                      	lodsb
 21940 00002B4C 3C20                    	cmp	al,' ' ; 20h
 21941 00002B4E 7401                    	jz	short SKIPSPC
 21942 00002B50 AA                      	stosb
 21943                                  SKIPSPC:
 21944 00002B51 E2F8                    	loop	MAINNAME
 21945 00002B53 AC                      	lodsb
 21946 00002B54 3C20                    	cmp	al,' '
 21947 00002B56 740F                    	je	short GOTNAME
 21948 00002B58 88C4                    	mov	ah,al
 21949                                  	; 24/02/2023
 21950 00002B5A B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 21951                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 21952                                  	;stosb
 21953                                  	;xchg	al,ah
 21954                                  	;stosb
 21955                                  	; 24/02/2023
 21956 00002B5C AB                      	stosw
 21957 00002B5D B102                    	mov	cl,2
 21958                                  EXTNAME:
 21959 00002B5F AC                      	lodsb
 21960 00002B60 3C20                    	cmp	al,' '
 21961 00002B62 7403                    	je	short GOTNAME
 21962 00002B64 AA                      	stosb
 21963 00002B65 E2F8                    	loop	EXTNAME
 21964                                  GOTNAME:
 21965 00002B67 30C0                    	xor	al,al
 21966 00002B69 AA                      	stosb
 21967                                  STRCOMP_RETN:
 21968 00002B6A C3                      	retn
 21969                                  
 21970                                  ; =============== S U B	R O U T	I N E =======================================
 21971                                  
 21972                                  ; Compare ASCIZ DS:SI with ES:DI.
 21973                                  ; SI,DI destroyed.
 21974                                  
 21975                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21976                                  STRCOMP:	
 21977 00002B6B A6                      	cmpsb
 21978 00002B6C 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 21979 00002B6E 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 21980                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 21981                                  	;jmp	short STRCOMP	; Equal so far, keep going
 21982                                  	; 24/02/2023
 21983 00002B72 75F7                    	jnz	short STRCOMP
 21984 00002B74 C3                      	retn
 21985                                  
 21986                                  ; =============== S U B	R O U T	I N E =======================================
 21987                                  
 21988                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21989                                  CRPRINT:
 21990 00002B75 50                      	push	ax
 21991                                  	;mov	al,13	; 0Dh
 21992 00002B76 B00D                    	mov	al,0Dh
 21993 00002B78 51                      	push	cx
 21994 00002B79 57                      	push	di
 21995 00002B7A 89D7                    	mov	di,dx
 21996 00002B7C B9FFFF                  	mov	cx,65535 ; 0FFFFh
 21997 00002B7F 06                      	push	es
 21998 00002B80 1E                      	push	ds
 21999 00002B81 07                      	pop	es
 22000 00002B82 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 22001 00002B84 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 22002 00002B88 07                      	pop	es
 22003 00002B89 8916[06A1]              	mov	[string_ptr_2],dx
 22004                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 22005 00002B8D BA[CA93]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 22006 00002B90 E8AA29                  	call	std_printf
 22007                                  	;mov	byte [di-1],13
 22008 00002B93 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 22009 00002B97 7204                    	jb	short error_output
 22010 00002B99 5F                      	pop	di
 22011 00002B9A 59                      	pop	cx
 22012 00002B9B 58                      	pop	ax
 22013 00002B9C C3                      	retn
 22014                                  
 22015                                  ; ---------------------------------------------------------------------------
 22016                                  
 22017                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22018                                  error_output:
 22019 00002B9D 0E                      	push	cs
 22020 00002B9E 1F                      	pop	ds
 22021 00002B9F 8E06[E49D]              	mov	es,[RESSEG]
 22022 00002BA3 BA[1792]                	mov	dx,NOSPACE_PTR
 22023 00002BA6 26803E[D302]00          	cmp	byte [es:PipeFlag],0
 22024 00002BAC 7406                    	jz	short go_to_error
 22025 00002BAE E80409                  	call	PipeOff
 22026 00002BB1 BA[6493]                	mov	dx,PIPEEMES_PTR
 22027                                  go_to_error:
 22028 00002BB4 E9E602                  	jmp	cerror
 22029                                  
 22030                                  ; =============== S U B	R O U T	I N E =======================================
 22031                                  
 22032                                  ;---- Mod for path invocation ----
 22033                                  
 22034                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22035                                  pathchrcmp:
 22036                                  	; 18/03/2023	
 22037                                  	;push	ax
 22038                                  	;mov	ah,'/' ; 2Fh
 22039                                  	;cmp	[SWITCHAR],ah
 22040 00002BB7 803E[E89D]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 22041 00002BBC 7404                    	je	short noslasht
 22042 00002BBE 3C2F                    	cmp	al,'/'
 22043 00002BC0 7402                    	je	short pccont
 22044                                  noslasht:
 22045 00002BC2 3C5C                    	cmp	al,'\' ; 5Ch
 22046                                  pccont:	
 22047                                  	;pop	ax
 22048 00002BC4 C3                      	retn
 22049                                  
 22050                                  ; =============== S U B	R O U T	I N E =======================================
 22051                                  
 22052                                  ; PATHCRUNCH -
 22053                                  ;
 22054                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 22055                                  ;       PathPos = ptr to string with pathname in it
 22056                                  ;       PathCnt = length of string
 22057                                  ;
 22058                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 22059                                  ;       PathCnt = length left in string
 22060                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 22061                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 22062                                  ;       If path crunched successfully,
 22063                                  ;         CY = clear
 22064                                  ;         Current directory is changed to directory in pathname
 22065                                  ;         UserDir1 contains previous directory for use by RestUDir
 22066                                  ;         RestDir = nonzero to flag later restoration of user's dir
 22067                                  ;         DestTail = ptr to beginning of filename
 22068                                  ;         If filename found in pathname,
 22069                                  ;           ZR = clear
 22070                                  ;           FCB filename fields contain filename
 22071                                  ;         If filename not found (pure directory path),
 22072                                  ;           ZR = set
 22073                                  ;           FCB filename fields are wildcarded with ?'s
 22074                                  ;       If pathcrunch failed (no ChDir's worked),
 22075                                  ;         CY = set
 22076                                  ;         Msg_Numb = extended error code
 22077                                  ;
 22078                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 22079                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 22080                                  ;       with the filename wildcarded.
 22081                                  
 22082                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22083                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 22084                                  
 22085                                  	; 11/06/2023 - Retro DOS v4.2
 22086                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2D11h
 22087                                  PathCrunch:
 22088                                  	; MSDOS 6.0
 22089 00002BC5 C706[9AA2]0000          	mov     word [Msg_Numb],0
 22090                                  				;AN022; Set up message flag
 22091                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22092                                  	;mov	dl,[5Ch]
 22093 00002BCB 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 22094 00002BCF E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 22095                                  	; MSDOS 6.0
 22096 00002BD2 7233                     	jc	short pcrunch_cderrj
 22097                                  				;AN022; if error on current dir - report
 22098 00002BD4 E86004                  	call	SETPATH		; scan past switches, whitespace
 22099                                  
 22100                                  ;       DX = ptr to pathname, NULL-terminated
 22101                                  ;       PathPos = ptr to byte after NULL at end of pathname
 22102                                  
 22103                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22104 00002BD7 F606[23A1]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 22105 00002BDC 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 22106                                  
 22107                                  	;mov	ah,CHDir ; 3Bh
 22108 00002BDE B43B                    	mov	ah,3Bh
 22109 00002BE0 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22110                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22111                                  	; MSDOS 6.0
 22112 00002BE2 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 22113                                  	
 22114 00002BE4 E867F6                  	call	get_ext_error_number    ;AN022; get the extended error
 22115 00002BE7 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 22116 00002BEA 741E                    	je	short trypeel		;AC022;    keep trying
 22117 00002BEC 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 22118 00002BEF 7419                    	je	short trypeel		;AC022;    keep trying
 22119 00002BF1 A3[9AA2]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 22120 00002BF4 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 22121                                  
 22122                                  	; MSDOS 3.3
 22123                                  	;jc	short trypeel
 22124                                  chdir_worked:
 22125                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22126 00002BF7 E83406                  	call	SetRest1	; set 'Restore Directory' flag true
 22127 00002BFA B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 22128 00002BFC BF5D00                  	mov	di,5Dh  ; FCB+1
 22129 00002BFF B90B00                  	mov	cx,11
 22130 00002C02 F3AA                    	rep	stosb
 22131 00002C04 30C0                    	xor	al,al		; return carry clear, zero set
 22132 00002C06 C3                      	retn
 22133                                  
 22134                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 22135 00002C07 E98100                  	jmp	pcrunch_cderr	;AN022;
 22136                                  
 22137                                  trypeel:
 22138 00002C0A 8B36[75A0]              	mov	si,[PathPos]
 22139 00002C0E 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 22140 00002C0F 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 22141                                  	; 25/02/2023
 22142                                  	; MSDOS 5.0 (& 6.0)
 22143 00002C12 803E[B5A2]00            	cmp	byte [KPARSE],0
 22144 00002C17 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 22145                                  	
 22146 00002C19 E89BFF                  	call	pathchrcmp
 22147 00002C1C 7475                    	jz	short peelfail	; Trailing '/'
 22148                                  delstrt:
 22149 00002C1E 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 22150 00002C20 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 22151 00002C22 52                      	push	dx		; save ptr to pathname
 22152                                  delloop:
 22153 00002C23 39CE                    	cmp	si,cx
 22154                                  	;jz	short BADRET
 22155                                  	; 25/02/2023
 22156 00002C25 7413                    	je	short gotdele	; no char's left, we have what we have
 22157 00002C27 AC                      	lodsb			; AL = next char of pathname
 22158 00002C28 E8DFFC                  	call	testkanj
 22159 00002C2B 7403                    	jz	short notkanj8	; not Kanji, move along
 22160 00002C2D 46                      	inc	si
 22161 00002C2E EBF3                    	jmp	short delloop	
 22162                                  
 22163                                  	; 25/02/2023
 22164                                  	; MSDOS 3.3
 22165                                  	;mov	al,[si]
 22166                                  	;call	PATHCHRCMP
 22167                                  	;jz	short TRYCD
 22168                                  	;dec	si
 22169                                  	;jmp	short delloop
 22170                                  
 22171                                  notkanj8:
 22172 00002C30 E884FF                  	call	pathchrcmp
 22173 00002C33 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 22174 00002C35 89F2                    	mov	dx,si
 22175 00002C37 4A                      	dec	dx		; DX = ptr to last delimiter found	
 22176 00002C38 EBE9                    	jmp	short delloop	; go look for more
 22177                                  
 22178                                  	; 25/02/2023
 22179                                  	; MSDOS 5.0 (& 6.0)
 22180                                  gotdele:
 22181 00002C3A 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 22182 00002C3C 5A                      	pop	dx		; DX = ptr to pathname
 22183 00002C3D 39D6                    	cmp	si,dx
 22184 00002C3F 7454                    	je	short badret	; didn't find path delim
 22185 00002C41 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 22186 00002C43 89D6                    	mov	si,dx		; SI = ptr to pathname
 22187                                  delloop2:			; Set value of KPARSE
 22188 00002C45 39CE                    	cmp	si,cx
 22189 00002C47 7412                    	je	short trycd	; roll up till SI meets CX
 22190 00002C49 C606[B5A2]00            	mov	byte [KPARSE],0
 22191 00002C4E AC                      	lodsb
 22192 00002C4F E8B8FC                  	call	testkanj
 22193 00002C52 74F1                    	jz	short delloop2
 22194 00002C54 46                      	inc	si
 22195 00002C55 FE06[B5A2]              	inc	byte [KPARSE]
 22196 00002C59 EBEA                    	jmp	short delloop2
 22197                                  
 22198                                  trycd:
 22199 00002C5B 50                      	push	ax
 22200                                  	; 25/02/2023
 22201 00002C5C B02E                    	mov	al,'.'
 22202                                  	;mov	al,[DOT_CHR]	; AL = '.'
 22203                                  	; MSDOS 6.0
 22204 00002C5E 384401                  	cmp	[si+1],al	; check for '.' after path delim
 22205                                  				;M019; allow continuation if '. ' or 
 22206                                  				;M019; '..' is not found.
 22207 00002C61 7509                    	jne	short trycd1	;M019; '.' not found
 22208 00002C63 384402                  	cmp	[si+2],al	;M019; check for '..'
 22209 00002C66 7404                    	je	short trycd1	;M019; found '..'
 22210 00002C68 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 22211                                  trycd1:	
 22212 00002C6C 58                      	pop     ax
 22213 00002C6D 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 22214                                  
 22215                                  	; 25/02/2023
 22216                                  	; MSDOS 3.3
 22217                                  	;cmp	[si+1],	al	; check for '.' after path delim
 22218                                  	;pop	ax
 22219                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 22220                                  
 22221                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22222 00002C6F 8A44FF                  	mov	al,[si-1]
 22223 00002C72 3C3A                    	cmp	al,':' 		; Special case d:\file
 22224 00002C74 741F                    	je	short badret
 22225                                  	; 25/02/2023
 22226                                  	; MSDOS 6.0
 22227 00002C76 803E[B5A2]00            	cmp	byte [KPARSE],0
 22228 00002C7B 7505                    	jnz	short notdoublesl
 22229 00002C7D E837FF                  	call	pathchrcmp
 22230                                  	;jnz	short notdoublesl
 22231                                  				; Last char is 2nd KANJI byte, might be '\'
 22232                                  	; 25/02/2023
 22233 00002C80 7411                    	jz	short peelfail 
 22234                                  ;peelfail:
 22235                                  	;stc
 22236                                  	;retn
 22237                                  
 22238                                  notdoublesl:
 22239 00002C82 C60400                  	mov	byte [si],0
 22240                                  	;mov	ah,CHDir ; 3Bh
 22241 00002C85 B43B                    	mov	ah,3Bh
 22242 00002C87 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22243                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22244 00002C89 7320                    	jnc	short cdsucc
 22245                                  
 22246                                  	; 25/02/2023
 22247                                  	; MSDOS 6.0
 22248                                  pcrunch_cderr:
 22249 00002C8B E8C0F5                  	call	get_ext_error_number
 22250                                  				;AN022; get the extended error
 22251 00002C8E A3[9AA2]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 22252 00002C91 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 22253                                  peelfail: ; 25/02/2023
 22254 00002C93 F9                      	stc			;AN022; set up carry flag
 22255                                  pcrunch_retn:
 22256 00002C94 C3                      	retn
 22257                                  
 22258                                  badret:
 22259                                  	; MSDOS 3.3 & MSDOS 6.0
 22260 00002C95 8A04                    	mov	al,[si]
 22261 00002C97 E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 22262 00002C9A F9                      	stc
 22263 00002C9B 75F7                    	jnz	short pcrunch_retn
 22264 00002C9D 30DB                    	xor	bl,bl
 22265 00002C9F 865C01                  	xchg	bl,[si+1]
 22266                                  	;mov	ah,CHDir ; 3Bh
 22267 00002CA2 B43B                    	mov	ah,3Bh
 22268 00002CA4 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22269                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22270                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 22271                                  	; 25/02/2023
 22272 00002CA6 72E3                    	jc	short pcrunch_cderr
 22273                                  				;AN022; go to error exit 
 22274 00002CA8 885C01                  	mov	[si+1],bl
 22275                                  cdsucc:
 22276 00002CAB E88005                  	call	SetRest1
 22277 00002CAE 46                      	inc	si		; Reset zero
 22278 00002CAF 8936[21A1]              	mov	[DestTail],si
 22279                                  	; 25/02/2023
 22280                                  	; MSDOS 6.0
 22281 00002CB3 9C                      	pushf			;AN015; save flags
 22282 00002CB4 803E[7DA0]FF            	cmp	byte [DirFlag],-1
 22283                                  				;AN015; don't do parse if in DIR
 22284 00002CB9 7408                    	je	short pcrunch_end
 22285                                  				;AN015;
 22286                                  	; MSDOS 3.3 & MSDOS 6.0
 22287 00002CBB BF5C00                  	mov	di,FCB  ; 5Ch
 22288                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 22289 00002CBE B80229                  	mov	ax,2902h	
 22290 00002CC1 CD21                    	int	21h		; Parse with default drive
 22291                                  			; DOS -	PARSE FILENAME
 22292                                  			; DS:SI	-> string to parse
 22293                                  			; ES:DI	-> buffer to fill with unopened	FCB
 22294                                  			; AL = bit mask	to control parsing
 22295                                  	; MSDOS 3.3
 22296                                  	;retn
 22297                                  
 22298                                  pcrunch_end:
 22299 00002CC3 9D                      	popf			;AN015; get flags back
 22300 00002CC4 C3                      	retn
 22301                                  
 22302                                  ;============================================================================
 22303                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 22304                                  ;============================================================================
 22305                                  ; 05/10/2018 - Retro DOS v3.0
 22306                                  
 22307                                  ;TITLE	Part7 COMMAND Transient Routines
 22308                                  
 22309                                  ;	More misc routines
 22310                                  
 22311                                  ;---------------------------
 22312                                  ; We can get rid of this switch processing code if we can take
 22313                                  ; care of the remaining two calls to switch, later in the file.
 22314                                  ; However, I have not checked whether or not any other files use
 22315                                  ; switch -- after all, it IS public!
 22316                                  ;---------------------------
 22317                                  
 22318                                  ; 14/06/2023
 22319                                  SWCOUNT	EQU 8	; MSDOS 6.22		; Length of switch_list
 22320                                  ; 28/03/2023
 22321                                  ;SWCOUNT  EQU  6  ; MSDOS 6.0 (& MSDOS 5.0)
 22322                                  ;;SWCOUNT EQU  5  ; MSDOS 3.3	
 22323                                  
 22324                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 22325                                  
 22326                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22327                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 22328                                  
 22329                                  ; ---------------------------------------------------------------------------
 22330                                  
 22331                                  	; 25/02/2023
 22332                                  RETSW:
 22333 00002CC5 93                      	xchg	ax,bx		; Put switches in AX
 22334 00002CC6 C3                      	retn
 22335                                  
 22336                                  ; =============== S U B	R O U T	I N E =======================================
 22337                                  
 22338                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22339                                  	; 11/06/2023 - Retro DOS 4.2 COMMAND.COM
 22340                                  SWITCH:
 22341 00002CC7 31DB                    	xor	bx,bx		; Initialize - no switches set
 22342                                  SWLOOP:
 22343 00002CC9 E85DFE                  	call	scanoff		; Skip any delimiters
 22344 00002CCC 3A06[E89D]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 22345 00002CD0 75F3                    	jnz	short RETSW	; No -- we're finished
 22346 00002CD2 81CB0080                	or	bx,8000h
 22347                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 22348 00002CD6 46                      	inc	si		; Skip over the switch character
 22349 00002CD7 E84FFE                  	call	scanoff
 22350 00002CDA 3C0D                    	cmp	al,0Dh
 22351 00002CDC 74E7                    	je	short RETSW	; Oops
 22352 00002CDE 46                      	inc	si
 22353                                  
 22354                                  	; Convert lower case input to upper case
 22355                                  
 22356 00002CDF E852FC                  	call	UPCONV
 22357                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 22358                                  
 22359 00002CE2 BF[9297]                	mov	di,switch_list	; "-Y?VBAPW" (for MSDOS 6.22) ; 11/06/2023
 22360                                  				; "?VBAPW" (for MSDOS 6.0)
 22361                                  				; ("VBAPW" (for MSDOS 3.3))
 22362                                  	; 11/06/2023
 22363                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2E33h
 22364 00002CE5 B90800                  	mov	cx,8  ; MSDOS 6.22	   	
 22365                                  	;mov	cx,6  ; MSDOS 6.0 (& MSDOS 5.0)
 22366                                  	;;mov	cx,5  ; MSDOS 3.3
 22367                                  	;;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 22368                                  		
 22369                                  	;nop
 22370                                  		
 22371 00002CE8 F2AE                    	repne	scasb		; Look for matching switch
 22372 00002CEA 7507                    	jnz	short BADSW
 22373 00002CEC B80100                  	mov	ax,1
 22374 00002CEF D3E0                    	shl	ax,cl		; Set a bit for the switch
 22375 00002CF1 09C3                    	or	bx,ax
 22376                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 22377 00002CF3 EBD4                    	jmp	short SWLOOP
 22378                                  ;BADSW:
 22379                                  	;jmp	short SWLOOP
 22380                                  ;DRVBAD:
 22381                                  ;	mov	dx,baddrv_ptr
 22382                                  ;	jmp	cerror
 22383                                  EXTERNALJ:
 22384 00002CF5 E90501                  	jmp	EXTERNAL
 22385                                  FNDCOM:				; search the internal command table
 22386 00002CF8 08C0                    	or	al,al		; Get real length of first arg
 22387 00002CFA 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 22388                                  				;  to be external.
 22389                                  ; barryf code starts here
 22390                                  
 22391 00002CFC E82703                  	call	test_append	; see if APPEND installed
 22392 00002CFF 7429                    	jz	short CONTCOM	; not loaded
 22393                                  
 22394                                  APPEND_INTERNAL:
 22395 00002D01 8A0E[A09F]              	mov	cl,[IDLEN]
 22396 00002D05 B500                    	mov	ch,0
 22397 00002D07 890E[75A0]              	mov	[PathPos],cx
 22398                                  	
 22399                                  	; 25/02/2023	
 22400                                  	; MSDOS 6.0
 22401 00002D0B FE06[9CA2]              	inc 	byte [append_exec]
 22402                                  				;AN041; set APPEND to ON
 22403 00002D0F E8B603                  	call	IOSET		; re-direct the o'l io
 22404                                  
 22405 00002D12 BE[A09F]                	mov	si,IDLEN	; address command name, DS already set	
 22406 00002D15 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 22407                                  		
 22408                                  	; MSDOS 6.0
 22409 00002D18 BF[2755]                	mov	di,append_parse
 22410                                  				;AN010; Get the entry point for PARSE for APPEND
 22411                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22412 00002D1B B801AE                  	mov	ax,0AE01h
 22413 00002D1E CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 22414                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 22415                                  			; DX = FFFFh, DS:SI -> buffer
 22416                                  			; Return: buffer at DS:SI filled with a	length byte
 22417                                  			; followed by the uppercase internal command
 22418                                  			; to execute (if length not 0)
 22419                                  	; 25/02/2023
 22420                                  	; INT 2Fh
 22421                                  	; 	AX = AE01h
 22422                                  	; entry:
 22423                                  	; 	DX = magic value FFFFh
 22424                                  	; 	CH = 00h
 22425                                  	; 	CL = length of command name
 22426                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22427                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22428                                  	; return:
 22429                                  	;	DS:SI buffer updated
 22430                                  	;	if length byte is nonzero, the following bytes contain
 22431                                  	;	the uppercase internal command to execute and the command line
 22432                                  	; 	buffer contains the command's parameters
 22433                                  	;	(the first DS:[SI] bytes are ignored)
 22434                                  	;
 22435                                  	; Format of COMMAND.COM command line buffer:
 22436                                  	;	Offset  Size    Description
 22437                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22438                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22439                                  	;	N BYTEs command line text, terminated by 0Dh
 22440                                  	;
 22441                                  	; Format of command name buffer:
 22442                                  	;	Offset  Size    Description
 22443                                  	;	00h     BYTE    length of command name
 22444                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22445                                  
 22446 00002D20 803E[A09F]00            	cmp	byte [IDLEN],0 ; execute requested
 22447 00002D25 7503                    	jne	short CONTCOM
 22448 00002D27 E9A300                  	jmp	CMD_DONE
 22449                                  
 22450                                  	;nop
 22451                                  CONTCOM:			; continue with internal scan
 22452 00002D2A BF[1196]                	mov	di,COMTAB
 22453 00002D2D 31C9                    	xor	cx,cx
 22454                                  FINDCOM:
 22455 00002D2F BE[A19F]                	mov	si,ID		; pointer to command argument
 22456 00002D32 8A0D                    	mov	cl,[di]		; load length of internal command
 22457 00002D34 47                      	inc	di		; advance past length
 22458 00002D35 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 22459 00002D37 3A0E[A09F]              	cmp	cl,[IDLEN]	; that of the command argument
 22460 00002D3B 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 22461 00002D3D 890E[75A0]              	mov	[PathPos],cx	; store length of command
 22462 00002D41 F3A6                    	repe	cmpsb
 22463                                  ABCD:					
 22464 00002D43 9F                      	lahf			; save the good ol' flags
 22465 00002D44 01CF                    	add	di,cx		; skip over remaining internal, if any
 22466 00002D46 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 22467 00002D48 A2[F69D]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 22468 00002D4B 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 22469 00002D4C 8B1D                    	mov	bx,[di]		; load internal command address
 22470 00002D4E 47                      	inc	di		; skip over the puppy
 22471 00002D4F 47                      	inc	di
 22472                                  		
 22473                                  	; MSDOS 6.0
 22474 00002D50 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 22475 00002D52 47                      	inc	di
 22476 00002D53 47                      	inc	di
 22477 00002D54 9E                      	sahf			; remember those flags?
 22478 00002D55 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 22479                                  
 22480                                  ; All messages get redirected.
 22481                                  
 22482 00002D57 803E[9CA2]00            	cmp     byte [append_exec],0
 22483                                  				;AN041; APPEND just executed?
 22484 00002D5C 7503                    	jnz 	short DONT_SET_IO
 22485                                  				;AN041; Yes - this junk is already set
 22486 00002D5E E86703                  	call	IOSET		; re-direct the ol' i/o
 22487                                  
 22488                                  DONT_SET_IO:			;AN041;
 22489                                  
 22490                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 22491                                  ; respond to /? only if it is the only command-line argument.
 22492                                  
 22493 00002D61 A1[FB9D]                	mov	ax,[COMSW]	; AX = switches after command
 22494 00002D64 0B06[019E]              	or	ax,[AllSwitch]	; AX = all switches
 22495                                  	;and	ax,SwitchQues	
 22496 00002D68 83E020                  	and	ax,20h
 22497 00002D6B 7426                    	jz	short DRIVE_CHECK
 22498                                  				; /? not in command line
 22499 00002D6D F606[F69D]04            	test	byte [CHKDRV],4	
 22500                                  	;test	byte [CHKDRV],fLimitHelp
 22501 00002D72 7407                    	jz	short DO_HELP	; /? allowed in combination
 22502                                  
 22503                                  ; Make sure /? is the only argument on the command line.
 22504                                  
 22505 00002D74 833E[76A5]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 22506 00002D79 7518                    	jne	short DRIVE_CHECK
 22507                                  				; /? not only arg - ignore
 22508                                  
 22509                                  ; Note: this is all the check we need, even against things like /??.
 22510                                  ; Our argv parser breaks /?? into two args, /? and ?.
 22511                                  
 22512                                  DO_HELP:
 22513                                  ; DX = ptr to word list of msg #s, terminated by zero word
 22514                                  
 22515 00002D7B 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 22516                                      	;mov	ax,no_subst	; AL = no subst's code
 22517 00002D7D B80000                  	mov	ax,0
 22518 00002D80 50                      	push	ax		; build subst block on stack
 22519                                  
 22520                                  NEXT_HELP_MSG:
 22521 00002D81 AD                      	lodsw			; AX = help msg # or zero
 22522 00002D82 09C0                    	or	ax,ax
 22523 00002D84 7409                    	jz	short HELP_DONE
 22524 00002D86 50                      	push	ax		; SS:SP = ptr to subst block
 22525                                  				; (msg # and no_subst byte)
 22526                                  ;; We assume DS = SS.
 22527                                  	
 22528 00002D87 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 22529 00002D89 E8B127                  	call	std_printf	; display help message	
 22530 00002D8C 58                      	pop	ax		; remove msg # from stack
 22531 00002D8D EBF2                    	jmp	short NEXT_HELP_MSG
 22532                                  
 22533                                  HELP_DONE:
 22534 00002D8F 58                      	pop	ax		; clean up stack
 22535 00002D90 E971D3                  	jmp	TCOMMAND	
 22536                                  
 22537                                  	; 25/02/2023
 22538                                  	; MSDOS 3.3
 22539                                  	;sahf			; remember those flags?
 22540                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 22541                                  	;call	IOSET		; re-direct the ol' i/o
 22542                                  
 22543                                  DRIVE_CHECK:
 22544 00002D93 F606[F69D]01            	test	byte [CHKDRV],1
 22545                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 22546                                  				; did we wanna check those drives?
 22547 00002D98 7411                    	jz	short NOCHECK
 22548 00002D9A A0[F99D]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 22549 00002D9D 0A06[FA9D]              	or	al,[PARM2]	; us whether those drives were OK
 22550 00002DA1 3CFF                    	cmp	al,-1
 22551 00002DA3 7506                    	jne	short NOCHECK
 22552                                  	;jmp	DRVBAD
 22553                                  	; 25/02/2023
 22554                                  DRVBAD:
 22555 00002DA5 BA[5F92]                	mov	dx,baddrv_ptr
 22556 00002DA8 E9F200                  	jmp	cerror
 22557                                  
 22558                                  ; The user may have omitted the space between the command and its arguments.
 22559                                  ; We need to copy the remainder of the user's command line into the buffer.
 22560                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 22561                                  ; into the command line at 80.
 22562                                  
 22563                                  NOCHECK:
 22564 00002DAB E85B02                  	call	cmd_copy
 22565                                  SWITCHECK:
 22566                                  	;test	byte [CHKDRV],2
 22567 00002DAE F606[F69D]02            	test	byte [CHKDRV],fSwitchAllowed 
 22568                                  				; Does the command take switches
 22569 00002DB3 7516                    	jnz	short REALWORK	; Yes, process the command
 22570 00002DB5 E82F00                  	call	noswit		; No, check to see if any switches
 22571 00002DB8 7511                    	jnz	short REALWORK	; None, process the command
 22572                                  
 22573                                  	; MSDOS 6.0
 22574                                  	;mov	byte [msg_disp_class],2
 22575 00002DBA C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class
 22576                                  				;AN000; set up parse error msg class
 22577 00002DBF BA[0392]                	mov	dx,extend_buf_ptr	
 22578                                  				;AC000; get extended message pointer
 22579                                  	;mov	word [extend_buf_ptr],3
 22580 00002DC2 C706[0392]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 22581                                  				;AN000; get "Invalid switch" message number
 22582 00002DC8 E9D200                  	jmp	cerror		; Print error and chill out...
 22583                                  
 22584                                  	; 25/02/2023
 22585                                  	; MSDOS 3.3
 22586                                  	;mov	dx,BADPARMPTR
 22587                                  	;jmp	CERROR
 22588                                  
 22589                                  REALWORK:
 22590 00002DCB FFD3                    	call	bx		; do some real work, at last
 22591                                  
 22592                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 22593                                  ; otherwise, go get another command.
 22594                                  
 22595                                  CMD_DONE:
 22596 00002DCD 0E                      	push	cs		; g  restore data segment
 22597 00002DCE 1F                      	pop	ds		; g
 22598 00002DCF 1E                      	push	ds
 22599 00002DD0 8E1E[E49D]              	mov	ds,[RESSEG]	; g  save data segment
 22600                                  	;cmp	byte [Call_Flag],1
 22601                                  				; G  Is a call in progress?
 22602 00002DD4 803E[6C02]01            	cmp	byte [Call_Flag],call_in_progress
 22603 00002DD9 C606[6C02]00            	mov	byte [Call_Flag],0
 22604                                  				; G  Either way, reset flag
 22605 00002DDE 1F                      	pop	ds		; g  get data segment back
 22606 00002DDF 7403                    	jz	short INCALL	; G
 22607 00002DE1 E920D3                  	jmp	TCOMMAND	; chill out...
 22608                                  INCALL:
 22609                                  	;jmp	DOCOM1
 22610                                  	; 11/06/2023
 22611                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 22612 00002DE4 E90CD5                  	jmp	DOCOM0
 22613                                  
 22614                                  ; =============== S U B	R O U T	I N E =======================================
 22615                                  
 22616                                  	; 25/02/2023
 22617                                  noswit:
 22618 00002DE7 57                      	push	di		; Save di
 22619 00002DE8 BF8100                  	mov	di,81h		; di = ptr to command args
 22620 00002DEB BE8000                  	mov	si,80h		; Get address of length of command args
 22621 00002DEE AC                      	lodsb			; Load length
 22622 00002DEF 88C1                    	mov	cl,al		; Move length to cl
 22623 00002DF1 30ED                    	xor	ch,ch		; Zero ch
 22624 00002DF3 2EA0[E89D]              	mov	al,[cs:SWITCHAR] ; al = switch character
 22625                                  	;cmp	al,0		; Turn off ZF
 22626                                  	; 25/02/2023
 22627 00002DF7 20C0                    	and	al,al
 22628 00002DF9 F2AE                    	repne	scasb		; Scan for a switch character and return
 22629 00002DFB 5F                      	pop	di		;  with ZF set if one was found
 22630 00002DFC C3                      	retn
 22631                                  
 22632                                  ; ---------------------------------------------------------------------------
 22633                                  
 22634                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22635                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 22636                                  
 22637                                  EXTERNAL:
 22638 00002DFD E82602                  	call	test_append	; check to see if append installed
 22639 00002E00 7403                    	jz	short NOT_BARRYF
 22640                                  				; no - truly external command
 22641 00002E02 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 22642                                  
 22643                                  NOT_BARRYF:
 22644 00002E05 2EC606[F79D]00          	mov	byte [cs:FILTYP],0
 22645 00002E0B 2E8A16[049E]            	mov	dl,[cs:SPECDRV]
 22646 00002E10 2E8816[A09F]            	mov	[cs:IDLEN],dl
 22647 00002E15 2EC606[1AA1]00          	mov	byte [cs:ROM_CALL],0
 22648 00002E1B 52                      	push	dx
 22649 00002E1C BA[A09F]                	mov	dx,IDLEN
 22650 00002E1F E8ABD6                  	call	ROM_SCAN
 22651 00002E22 5A                      	pop	dx
 22652                                  	;jnc	short POSTSAVE
 22653 00002E23 7305                    	jnc	short DO_SCAN
 22654 00002E25 2EFE06[1AA1]            	inc	byte [cs:ROM_CALL]
 22655                                  	;jmp	short POSTSAVE
 22656                                  
 22657                                  	;nop
 22658                                  DO_SCAN:
 22659                                  POSTSAVE:
 22660 00002E2A BF[0C9D]                	mov	di,EXECPATH
 22661 00002E2D C60500                  	mov	byte [di],0	; Initialize to current directory
 22662                                  	
 22663 00002E30 2E803E[1AA1]00          	cmp	byte [cs:ROM_CALL],0
 22664                                  	;jz	short RESEARCH
 22665                                  	; 25/02/2023
 22666                                  	;jmp	short NEOEXECUTE
 22667 00002E36 750F                    	jnz	short NEOEXECUTE	
 22668                                  
 22669                                  	;nop
 22670                                  RESEARCH:
 22671 00002E38 E88508                  	call	path_search	; find the mother (result in execpath)
 22672 00002E3B 09C0                    	or	ax,ax		; did we find anything?
 22673                                  	;jz	short BADCOMJ45	; null means no (sob)
 22674                                  	; 25/02/2023
 22675 00002E3D 7459                    	jz	short BADCOM
 22676 00002E3F 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 22677                                  				; fuckin' sixteen-bit machine ought
 22678                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 22679                                  				; DISPLACEMENT!!
 22680                                  	;;jmp	short NEOEXECUTE
 22681                                  	;jmp	short EXECUTE	
 22682                                  	; 25/02/2023
 22683 00002E42 7D03                    	jnl	short EXECUTE ; jge
 22684                                  
 22685                                  	; 02H is .bat
 22686                                  
 22687                                  	;nop
 22688                                  BATCOMJ:
 22689 00002E44 E916DA                  	jmp	BATCOM
 22690                                  
 22691                                  	; 25/02/2023
 22692                                  ;BADCOMJ45:
 22693                                  	;jmp	short BADCOM
 22694                                  
 22695                                  	;nop
 22696                                  EXECUTE:
 22697                                  NEOEXECUTE:
 22698 00002E47 E87E02                  	call	IOSET
 22699                                  
 22700                                  ; MSDOS 6.0
 22701                                  ;M051
 22702                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 22703                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 22704                                  ;After a close, this would still leave one open active resulting in sharing
 22705                                  ;errors on subsequent opens of the redirected file.
 22706                                  
 22707                                  LH_EXECUTE:			;M051	
 22708 00002E4A 8E06[F49D]              	mov	es,[TRAN_TPA]
 22709                                  	;mov	ah,DEALLOC ; 49h
 22710 00002E4E B449                    	mov	ah,49h
 22711 00002E50 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 22712                                  			; ES = segment address of area to be freed
 22713                                  				; Now running in "free" space
 22714 00002E52 8E06[E49D]              	mov	es,[RESSEG]
 22715 00002E56 26FE06[5502]            	inc	byte [es:ExtCom] ; Indicate external command
 22716 00002E5B 26C606[5D02]00          	mov	byte [es:RestDir],0 
 22717                                  				; Since USERDIR1 is in transient, insure
 22718                                  				; this flag value for re-entry to COMMAND
 22719                                  	; MSDOS 6.0
 22720 00002E61 BE[0C9D]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 22721 00002E64 BF[2004]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 22722                                  	;mov	cx,LENMSGORPATHBUF
 22723 00002E67 B95000                  	mov	cx,80
 22724 00002E6A FC                      	cld
 22725 00002E6B F3A4                    	rep	movsb		; copy program pathname to resident
 22726                                  
 22727                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22728 00002E6D BF5C00                  	mov	di,FCB ; 5Ch
 22729 00002E70 89FE                    	mov	si,di
 22730                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 22731 00002E72 B152                    	mov	cl,82 ; 25/02/2023
 22732 00002E74 F3A5                    	rep	movsw		; Transfer parameters to resident header
 22733                                  	
 22734                                  	; 25/02/2023
 22735                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 22736                                  	; MSDOS 6.0 (& 5.0)
 22737                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 22738 00002E76 BA[2004]                	mov	dx,SafePathBuffer
 22739 00002E79 06                      	push	es
 22740 00002E7A 1F                      	pop	ds
 22741                                  
 22742                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 22743 00002E7B BB[FA03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 22744                                  	;mov	ax,EXEC*256 ; 4B00h
 22745 00002E7E B8004B                  	mov	ax,4B00h
 22746                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 22747 00002E81 2EF606[1AA1]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 22748 00002E87 7403                    	jz	short OK_EXEC
 22749 00002E89 E9BAD6                  	jmp	ROM_EXEC
 22750                                  
 22751                                  OK_EXEC:
 22752                                  
 22753                                  ; we are now running in free space. Anything we do from here on may get
 22754                                  ; trashed. Move the stack (also in free space) to allocated space because
 22755                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 22756                                  
 22757 00002E8C 8CC1                    	mov	cx,es
 22758 00002E8E 8ED1                    	mov	ss,cx
 22759 00002E90 BC[F404]                	mov	sp,RStack
 22760                                  	; MSDOS 3.3
 22761                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 22762                                  	; 25/02/2023
 22763                                  	; MSDOS 6.0
 22764 00002E93 2EFF2E[EA9D]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 22765                                  
 22766                                  ; ---------------------------------------------------------------------------
 22767                                  
 22768                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22769                                  BADCOM:
 22770 00002E98 0E                      	push	cs
 22771 00002E99 1F                      	pop	ds
 22772 00002E9A BA[2692]                	mov	dx,BADNAM_PTR
 22773                                  cerror:		
 22774 00002E9D E89526                  	call	std_eprintf
 22775 00002EA0 E961D2                  	jmp	TCOMMAND
 22776                                  
 22777                                  ; =============== S U B	R O U T	I N E =======================================
 22778                                  
 22779                                  ; Prescan converts the input buffer into a canonicalized form.
 22780                                  ; All redirections and pipes are removed.
 22781                                  
 22782                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22783                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 22784                                  
 22785                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 22786                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2FFBh
 22787                                  
 22788                                  PRESCAN:
 22789 00002EA3 31C9                    	xor	cx,cx
 22790 00002EA5 8E06[E49D]              	mov	es,[RESSEG]
 22791 00002EA9 BE[459C]                	mov	si,COMBUF+2
 22792 00002EAC 89F7                    	mov	di,si
 22793                                  COUNTQUOTES:
 22794 00002EAE AC                      	lodsb			; get a byte
 22795 00002EAF 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 22796 00002EB1 7504                    	jne	short COUNTEND	; no, try for end of road
 22797 00002EB3 FEC5                    	inc	ch		; bump count
 22798 00002EB5 EBF7                    	jmp	short COUNTQUOTES
 22799                                  				; go get next char
 22800                                  COUNTEND:
 22801 00002EB7 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 22802 00002EB9 75F3                    	jne	short COUNTQUOTES
 22803                                  				; no, go back for next char
 22804                                  	; 26/02/2023
 22805                                  	; MSDOS 5.0 (& 6.0)
 22806 00002EBB 51                      	push	cx		; save count
 22807 00002EBC 89FE                    	mov	si,di		; restore pointer to begining
 22808                                  KanjiScan:
 22809 00002EBE AC                      	lodsb			; get a byte
 22810 00002EBF E848FA                  	call	testkanj	; is it a leadin byte
 22811 00002EC2 740F                    	jz	short KanjiQuote
 22812                                  				; no, check for quotes
 22813 00002EC4 88C4                    	mov	ah,al		; save leadin
 22814 00002EC6 AC                      	lodsb			; get trailing byte
 22815 00002EC7 3D2020                  	cmp	ax,2020h
 22816                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 22817 00002ECA 75F2                    	jne	short KanjiScan	; no, go get next
 22818 00002ECC C744FE2020              	mov	word [si-2],2020h
 22819                                  				; replace with spaces
 22820 00002ED1 EBEB                    	jmp	short KanjiScan	; go get next char
 22821                                  	
 22822                                  KanjiQuote:
 22823 00002ED3 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 22824 00002ED5 750D                    	jne	short KanjiEnd	; no, check for end
 22825 00002ED7 FECD                    	dec	ch		; drop count
 22826 00002ED9 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 22827                                  KanjiQuoteLoop:
 22828 00002EDB AC                      	lodsb			; get next byte
 22829 00002EDC 3C22                    	cmp	al,22h	; '"'	; is it another quote
 22830 00002EDE 75FB                    	jne	short KanjiQuoteLoop
 22831                                  				; no, get another
 22832 00002EE0 FECD                    	dec	ch		; yes, drop count
 22833 00002EE2 EBDA                    	jmp	short KanjiScan	; go get next char
 22834                                  KanjiEnd:
 22835 00002EE4 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 22836 00002EE6 75D6                    	jne	short KanjiScan	; go back to beginning
 22837 00002EE8 59                      	pop	cx		; get back original count
 22838                                  	; 26/04/2023
 22839 00002EE9 89FE                    	mov	si,di		; restore pointer to beginning
 22840                                  	
 22841                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22842                                  PRESCANLP:
 22843 00002EEB AC                      	lodsb
 22844                                  	; 26/02/2023
 22845 00002EEC E81BFA                  	call	testkanj
 22846 00002EEF 740C                    	jz	short NOTKANJ6
 22847                                  	; MSDOS 6.0
 22848 00002EF1 8805                    	mov	[di],al
 22849 00002EF3 47                      	inc	di		; fake STOSB into DS
 22850 00002EF4 AC                      	lodsb			; grab second byte
 22851 00002EF5 8805                    	mov	[di],al		; fake stosb into DS
 22852 00002EF7 FEC1                    	inc	cl
 22853 00002EF9 FEC1                    	inc	cl
 22854 00002EFB EBEE                    	jmp	short PRESCANLP
 22855                                  
 22856                                  NOTKANJ6:
 22857                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22858 00002EFD 3C22                    	cmp	al,'"'	; 22h	; " character
 22859 00002EFF 7510                    	jne	short TRYGREATER
 22860 00002F01 FECD                    	dec	ch
 22861 00002F03 740C                    	jz	short TRYGREATER
 22862                                  QLOOP:
 22863 00002F05 8805                    	mov	[di],al
 22864 00002F07 47                      	inc	di
 22865 00002F08 FEC1                    	inc	cl
 22866 00002F0A AC                      	lodsb
 22867 00002F0B 3C22                    	cmp	al,'"'		; " character
 22868 00002F0D 75F6                    	jne	short QLOOP
 22869 00002F0F FECD                    	dec	ch
 22870                                  TRYGREATER:
 22871 00002F11 3C3E                    	cmp	al,'>' ; 3Eh
 22872                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 22873                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 22874 00002F13 7557                    	jne	short NOOUT
 22875                                  
 22876                                  ; We have found a ">" char. We need to see if there is another ">"
 22877                                  ; following it.
 22878                                  
 22879 00002F15 3804                    	cmp	[si],al
 22880 00002F17 7506                    	jne	short NOAPPND
 22881 00002F19 AC                      	lodsb
 22882 00002F1A 26FE06[8102]            	inc	byte [es:Re_Out_App] ; Flag >>
 22883                                  NOAPPND:
 22884                                  ; Now we attempt to find the file name. First, scan off all whitespace
 22885                                  
 22886 00002F1F E807FC                  	call	scanoff
 22887                                  
 22888                                  	; 26/02/2023
 22889                                  	; MSDOS 6.0
 22890 00002F22 3C3C                    	cmp	al,'<' ; 3Ch
 22891                                  	;cmp	al,labracket	;AN040; was there no filename?
 22892 00002F24 7404                    	je	short REOUT_ERRSET
 22893                                  				;AN040; yes - set up error
 22894                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22895 00002F26 3C0D                    	cmp	al,0Dh
 22896 00002F28 750D                    	jnz	short GOTREOFIL
 22897                                  
 22898                                  ; There was no file present. Set us up at end-of-line.
 22899                                  
 22900                                  REOUT_ERRSET:			;AN040; set up for an error
 22901 00002F2A C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 22902 00002F2D 26C706[8202]0900        	mov	word [es:Re_OutStr],9
 22903                                  				; Cause an error later
 22904 00002F34 E9A900                  	jmp	PRESCANEND
 22905                                  
 22906                                  GOTREOFIL:
 22907 00002F37 57                      	push	di
 22908                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 22909 00002F38 BF[8202]                	mov	di,Re_OutStr
 22910 00002F3B 89FB                    	mov	bx,di
 22911 00002F3D 06                      	push	es
 22912                                  
 22913                                  	; 26/02/2023
 22914                                  	; MSDOS 6.0
 22915                                  SETREOUTSTR:			; Get the output redirection name
 22916                                  				; MSKK06 07/14/89
 22917 00002F3E 51                      	push	cx		; save cx
 22918 00002F3F B94D00                  	mov	cx,64+13	; CX = max string length
 22919                                  SETREOUTSTR_LOOP:
 22920 00002F42 AC                      	lodsb
 22921 00002F43 3C0D                    	cmp	al,0Dh
 22922 00002F45 741A                    	je	short GOTRESTR_J
 22923 00002F47 E8E7FB                  	call	DELIM
 22924 00002F4A 7415                    	jz	short GOTRESTR_J
 22925 00002F4C 3A06[E89D]              	cmp	al,[SWITCHAR]
 22926 00002F50 740F                    	je	short GOTRESTR_J
 22927 00002F52 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 22928 00002F54 7413                    	je	short PIPEERRSYNJ5_J
 22929                                  				;AN033; Yes - get out quick - or system crashes
 22930 00002F56 3C3C                    	cmp	al,'<' ; 3Ch
 22931                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 22932 00002F58 7404                    	je	short ABRACKET_TERM
 22933                                  				;AN002; yes - end of string
 22934 00002F5A 3C3E                    	cmp	al,'>' ; 3Eh
 22935                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 22936 00002F5C 7506                    	jne	short NO_ABRACKET
 22937                                  				;AN002; no - not end of string
 22938                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 22939 00002F5E 4E                      	dec	si		;AN002; back up over symbol
 22940 00002F5F B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 22941                                  GOTRESTR_J:
 22942 00002F61 59                      	pop	cx		; MSKK06 07/14/89
 22943 00002F62 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 22944                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 22945 00002F64 AA                      	stosb			; store it into resgroup
 22946 00002F65 E2DB                    	loop	SETREOUTSTR_LOOP
 22947                                  				; MSKK06 07/14/89
 22948 00002F67 EBF8                    	jmp	short GOTRESTR_J
 22949                                  PIPEERRSYNJ5_J:
 22950 00002F69 59                      	pop	cx		; recover CX
 22951 00002F6A EB4B                    	jmp	short PIPEERRSYNJ5
 22952                                  
 22953                                  	; 26/02/2023
 22954                                  ;	; MSDOS 3.3
 22955                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 22956                                  ;	lodsb
 22957                                  ;	cmp	al,0Dh
 22958                                  ;	jz	short GOTRESTR
 22959                                  ;	call	DELIM
 22960                                  ;	jz	short GOTRESTR
 22961                                  ;	cmp	al,[SWITCHAR]
 22962                                  ;	je	short GOTRESTR
 22963                                  ;	cmp	al,'"'
 22964                                  ;	jne	short NO_ABRACKET
 22965                                  ;	dec	ch
 22966                                  ;NO_ABRACKET:
 22967                                  ;	stosb
 22968                                  ;	jmp	short SETREOUTSTR_LOOP
 22969                                  
 22970                                  NOOUT:
 22971                                  	; 26/02/2023
 22972                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22973 00002F6C 3C3C                    	cmp	al, '<' ; 3Ch
 22974                                  	;cmp	al,labracket	; MSDOS 6.0
 22975                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 22976 00002F6E 7523                    	jne	short CHKPIPE
 22977 00002F70 89F3                    	mov	bx,si		; Save loc of "<"
 22978 00002F72 E8B4FB                  	call	scanoff
 22979                                  	; MSDOS 6.0
 22980 00002F75 3C3E                    	cmp	al,'>' ; 3Eh
 22981                                  	;cmp	al,rabracket	;AN040; was there no filename?
 22982 00002F77 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 22983                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22984 00002F79 3C0D                    	cmp	al,0Dh
 22985 00002F7B 750B                    	jne	short GOTREIFIL
 22986                                  REIN_ERRSET:			;AN040; set up for error
 22987 00002F7D C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 22988 00002F80 C706[8F9D]0900          	mov	word [RE_INSTR],9 
 22989                                  				; Cause an error later
 22990 00002F86 EB58                    	jmp	short PRESCANEND
 22991                                  GOTREIFIL:
 22992 00002F88 57                      	push	di
 22993 00002F89 BF[8F9D]                	mov	di,RE_INSTR
 22994 00002F8C 89FB                    	mov	bx,di
 22995 00002F8E 06                      	push	es
 22996 00002F8F 0E                      	push	cs
 22997 00002F90 07                      	pop	es		; store in TRANGROUP
 22998                                  	; 26/04/2023
 22999                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 23000 00002F91 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 23001                                  				; Get the input redirection name
 23002                                  CHKPIPE:
 23003 00002F93 88C4                    	mov	ah,al
 23004                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23005 00002F95 80FC7C                  	cmp	ah,'|' ; 7Ch
 23006                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 23007                                  	;je	short ISPIPE3
 23008                                  	;; MSDOS 6.0
 23009                                  	;cmp	ah,'|' ; 7Ch
 23010                                  	;;cmp	al,vbar ; 7Ch
 23011                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 23012 00002F98 7539                    	jne	short CONTPRESCAN
 23013                                  ISPIPE3:
 23014                                  ; Only push the echo flag if we are entering the pipe for the first time.
 23015                                  
 23016 00002F9A 26803E[D302]00          	cmp	byte [es:PipeFlag],0
 23017 00002FA0 7505                    	jne	short NOECHOPUSH
 23018 00002FA2 26D026[5902]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 23019                                  NOECHOPUSH:
 23020 00002FA7 26FE06[D302]            	inc	byte [es:PipeFlag]
 23021 00002FAC E87AFB                  	call	scanoff
 23022 00002FAF 3C0D                    	cmp	al,0Dh
 23023 00002FB1 7404                    	je	short PIPEERRSYNJ5
 23024                                  	; 26/02/2023
 23025 00002FB3 3C7C                    	cmp	al,'|' ; 7Ch
 23026                                  	;cmp	al,ALTPIPECHR ; 7Ch
 23027                                  	;je	short PIPEERRSYNJ5
 23028                                  	;; MSDOS 6.0
 23029                                  	;cmp	al,'|' ; 7Ch
 23030                                  	;;cmp	al,vbar ; 7Ch
 23031                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 23032 00002FB5 751C                    	jne	short CONTPRESCAN
 23033                                  
 23034                                  PIPEERRSYNJ5:
 23035 00002FB7 06                      	push	es
 23036 00002FB8 1F                      	pop	ds
 23037 00002FB9 E99E02                  	jmp	PIPEERRSYN
 23038                                  
 23039                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 23040                                  ; than just a : in the redir string.
 23041                                  
 23042                                  GOTRESTR:
 23043 00002FBC 86E0                    	xchg	ah,al
 23044 00002FBE B03A                    	mov	al,':' ; 3Ah
 23045 00002FC0 29FB                    	sub	bx,di		; compute negative of number of chars
 23046 00002FC2 83FBFF                  	cmp	bx,-1		; is there just a :?
 23047 00002FC5 7407                    	je	short NOTRAILCOL ; yep, don't change
 23048 00002FC7 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 23049 00002FCB 7501                    	jne	short NOTRAILCOL
 23050 00002FCD 4F                      	dec	di		; Back up over trailing ':'
 23051                                  NOTRAILCOL:
 23052 00002FCE 30C0                    	xor	al,al
 23053 00002FD0 AA                      	stosb			; NUL terminate the string
 23054 00002FD1 07                      	pop	es
 23055 00002FD2 5F                      	pop	di		; Remember the start
 23056                                  CONTPRESCAN:
 23057 00002FD3 8825                    	mov	[di],ah		; "delete" the redirection string
 23058 00002FD5 47                      	inc	di
 23059 00002FD6 80FC0D                  	cmp	ah,0Dh
 23060 00002FD9 7405                    	je	short PRESCANEND
 23061 00002FDB FEC1                    	inc	cl
 23062 00002FDD E90BFF                  	jmp	PRESCANLP
 23063                                  PRESCANEND:
 23064 00002FE0 26803E[D302]00          	cmp	byte [es:PipeFlag],0
 23065 00002FE6 7414                    	jz	short ISNOPIPE
 23066                                  
 23067                                  	; 11/06/2023
 23068                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:314Ah
 23069                                  	;mov	di,48Ah		; PipeStr ; RESGROUP:EndInit+160
 23070                                  	;mov	[es:488h],di	; [es:PipePtr],di
 23071                                  				; (RESGROUP:EndInit+158)
 23072                                  	; 26/02/2023
 23073                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 23074                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 23075                                  	;;			; (EndInit+160]
 23076                                  	;mov	di,offset RESGROUP:PIPESTR
 23077 00002FE8 BF[7503]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 23078                                  
 23079                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 23080                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 23081 00002FEB 26893E[7303]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 23082                                  	
 23083 00002FF0 BE[459C]                	mov	si,COMBUF+2
 23084 00002FF3 E833FB                  	call	scanoff
 23085                                  PIPESETLP:			; Transfer the pipe into the resident
 23086 00002FF6 AC                      	lodsb			; pipe buffer
 23087 00002FF7 AA                      	stosb
 23088 00002FF8 3C0D                    	cmp	al,0Dh
 23089 00002FFA 75FA                    	jnz	short PIPESETLP
 23090                                  ISNOPIPE:
 23091 00002FFC 880E[449C]              	mov	[COMBUF+1],cl
 23092 00003000 26803E[D302]00          	cmp	byte [es:PipeFlag],0
 23093 00003006 0E                      	push	cs
 23094 00003007 07                      	pop	es
 23095 00003008 C3                      	retn
 23096                                  
 23097                                  ; =============== S U B	R O U T	I N E =======================================
 23098                                  
 23099                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23100                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 23101                                  cmd_copy:
 23102 00003009 BE[459C]                	mov	si,COMBUF+2
 23103 0000300C E81AFB                  	call	scanoff		; advance past separators...
 23104 0000300F 0336[75A0]              	add	si,[PathPos]
 23105 00003013 BF8100                  	mov	di,81h
 23106 00003016 31C9                    	xor	cx,cx
 23107                                  cmdcopy:
 23108 00003018 AC                      	lodsb
 23109 00003019 AA                      	stosb
 23110 0000301A 3C0D                    	cmp	al,0Dh
 23111 0000301C 7403                    	je	short copy_done
 23112 0000301E 41                      	inc	cx
 23113 0000301F EBF7                    	jmp	short cmdcopy
 23114                                  copy_done:
 23115 00003021 880E8000                	mov	[80h],cl
 23116 00003025 C3                      	retn
 23117                                  
 23118                                  ; =============== S U B	R O U T	I N E =======================================
 23119                                  
 23120                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23121                                  test_append:
 23122 00003026 BB[439C]                	mov	bx,COMBUF	; barry can address
 23123 00003029 BE[A09F]                	mov	si,IDLEN	; address command name, DS already set 	
 23124 0000302C BAFFFF                  	mov	dx,-1
 23125 0000302F B800AE                  	mov	ax,0AE00h
 23126 00003032 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 23127                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 23128                                  			; DX = FFFFh,[BX -> command line
 23129                                  			; Return: AL = FFh if this command is a TSR extension 
 23130                                  			;		   to COMMAND.COM
 23131                                  			; AL = 00h if the command should be executed as	usual
 23132                                  	;cmp	al,0
 23133 00003034 08C0                    	or	al,al ; 25/02/2023
 23134 00003036 C3                      	retn
 23135                                  
 23136                                  	; 25/02/2023
 23137                                  	; INT 2Fh
 23138                                  	; 	AX = AE00h
 23139                                  	; entry:
 23140                                  	; 	DX = magic value FFFFh
 23141                                  	; 	CH = FFh
 23142                                  	; 	CL = length of command line tail
 23143                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 23144                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 23145                                  	; return:
 23146                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 23147                                  	;	AL = 00h if the command should be executed as usual
 23148                                  	;
 23149                                  	; Format of COMMAND.COM command line buffer:
 23150                                  	;	Offset  Size    Description
 23151                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 23152                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 23153                                  	;	N BYTEs command line text, terminated by 0Dh
 23154                                  	;
 23155                                  	; Format of command name buffer:
 23156                                  	;	Offset  Size    Description
 23157                                  	;	00h     BYTE    length of command name
 23158                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 23159                                  
 23160                                  ;============================================================================
 23161                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 23162                                  ;============================================================================
 23163                                  ; 05/10/2018 - Retro DOS v3.0
 23164                                  
 23165                                  ;	More misc routines
 23166                                  
 23167                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 23168                                  
 23169                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23170                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 23171                                  
 23172                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23173                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3199h
 23174                                  
 23175                                  ; =============== S U B	R O U T	I N E =======================================
 23176                                  
 23177                                  SETPATH:
 23178                                  
 23179                                  ; ENTRY PathPos = ptr to string
 23180                                  ;       PathCnt = length of string
 23181                                  ;
 23182                                  ; EXIT  PathPos = ptr to string after pathname
 23183                                  ;       PathCnt = length of rest of string
 23184                                  ;       DX = ptr to pathname in string, made ASCIIZ
 23185                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 23186                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 23187                                  ;
 23188                                  ;       A null character is dropped at the end of the pathname. If the
 23189                                  ;       character in that spot previously was CR, it is copied into the
 23190                                  ;       following byte. So there must be at least two two character 
 23191                                  ;       positions in the buffer following the pathname.
 23192                                  
 23193                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23194                                  	
 23195                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23196                                  	; MSDOS 6.0
 23197                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 23198                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 23199                                  
 23200                                  	; 26/02/2023
 23201                                  	; MSDOS 3.3
 23202                                  	;mov	si,80h
 23203                                  	;lodsb
 23204                                  	;xor	ah,ah
 23205                                  	;mov	[PATCNT],ax
 23206                                  	;mov	[PATHPOS],si
 23207                                  GETPATH:
 23208                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23209 00003037 C606[23A1]00            	mov	byte [DestInfo],0
 23210 0000303C C606[1FA1]00            	mov	byte [DestIsDir],0
 23211 00003041 8B36[75A0]              	mov	si,[PathPos]	; SI = ptr to string
 23212 00003045 8B0E[73A0]              	mov	cx,[PathCnt]	; CX = string length
 23213 00003049 89F2                    	mov	dx,si		; DX = ptr to string
 23214 0000304B E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 23215 0000304D 51                      	push	cx		; save string length
 23216 0000304E 56                      	push	si		; save ptr to string
 23217 0000304F E875FC                  	call	SWITCH
 23218                                  
 23219                                  ;       After Switch, SI has been scanned past any switches, and
 23220                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 23221                                  
 23222 00003052 A3[77A0]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 23223 00003055 5B                      	pop	bx		; BX = ptr to original string
 23224 00003056 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 23225 00003058 59                      	pop	cx		; CX = string length
 23226 00003059 01D9                    	add	cx,bx		; CX = string length from current SI
 23227 0000305B 89F2                    	mov	dx,si		; DX = ptr to current string
 23228                                  SKIPPATH:
 23229                                  	; 26/02/2023
 23230                                  	; MSDOS 6.0
 23231 0000305D C606[B5A2]00            	mov	byte [KPARSE],0
 23232                                  SKIPPATH2:
 23233 00003062 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 23234 00003064 49                      	dec	cx		; CX = length left after next char
 23235 00003065 AC                      	lodsb			; AL = next char of string
 23236                                  				; SI = ptr to char after this one
 23237                                  	; 26/02/2023
 23238 00003066 E8A1F8                  	call	testkanj
 23239 00003069 7408                    	jz	short TESTPPSEP
 23240 0000306B 49                      	dec	cx
 23241 0000306C 46                      	inc	si
 23242 0000306D FE06[B5A2]              	inc	byte [KPARSE]
 23243 00003071 EBEF                    	jmp	short SKIPPATH2
 23244                                  TESTPPSEP:
 23245 00003073 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 23246 00003076 7504                    	jnz	short TESTPMETA	; it's not a path delim
 23247 00003078 FE06[1FA1]              	inc	byte [DestIsDir]
 23248                                  				; DestIsDir = 1, signalling path char
 23249                                  TESTPMETA:
 23250 0000307C 3C3F                    	cmp	al,'?'
 23251 0000307E 7505                    	jne	short TESTPSTAR	; char is not '?'
 23252 00003080 800E[23A1]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23253                                  TESTPSTAR:
 23254 00003085 3C2A                    	cmp	al,'*'
 23255                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 23256 00003087 7505                    	jne	short TESTPDELIM ; char is not '*'
 23257 00003089 800E[23A1]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23258                                  TESTPDELIM:
 23259 0000308E E8A0FA                  	call	DELIM		; compare AL to all delimiters
 23260 00003091 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 23261 00003093 3A06[E89D]              	cmp	al,[SWITCHAR]
 23262 00003097 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 23263                                  PATHDONEDEC:
 23264 00003099 4E                      	dec	si		; SI = ptr to char after pathname
 23265                                  PATHDONE:
 23266 0000309A 30C0                    	xor	al,al		; AL = NULL
 23267 0000309C 8604                    	xchg	al,[si]		; place NULL after pathname
 23268 0000309E 46                      	inc	si		; SI = ptr to byte after NULL
 23269 0000309F 3C0D                    	cmp	al,0Dh		; were we at end of line?
 23270 000030A1 7502                    	jne	short NOPSTORE	; not EOL, finish up
 23271 000030A3 8804                    	mov	[si],al		; save EOL after NULL
 23272                                  NOPSTORE:
 23273 000030A5 8936[75A0]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 23274 000030A9 890E[73A0]              	mov	[PathCnt],cx	; PathCnt = length of string left
 23275                                  SETPATH_RETN:
 23276 000030AD C3                      	retn
 23277                                  
 23278                                  ; ---------------------------------------------------------------------------
 23279                                  
 23280                                  PGETARG:
 23281 000030AE BE8000                  	mov	si,80h
 23282 000030B1 AC                      	lodsb
 23283 000030B2 08C0                    	or	al,al
 23284 000030B4 74F7                    	jz	short SETPATH_RETN
 23285 000030B6 E80300                  	call	PSCANOFF
 23286 000030B9 3C0D                    	cmp	al,0Dh
 23287 000030BB C3                      	retn
 23288                                  
 23289                                  ; ---------------------------------------------------------------------------
 23290                                  
 23291                                  PSCANOFF:
 23292 000030BC AC                      	lodsb
 23293 000030BD E871FA                  	call	DELIM
 23294 000030C0 7504                    	jnz	short PSCANOFFD
 23295 000030C2 3C3B                    	cmp	al,';' ; 3Bh
 23296 000030C4 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 23297                                  PSCANOFFD:
 23298 000030C6 4E                      	dec	si		; Point to first non-delimiter
 23299 000030C7 C3                      	retn
 23300                                  
 23301                                  ; =============== S U B	R O U T	I N E =======================================
 23302                                  
 23303                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23304                                  IOSET:
 23305                                  	; ALL REGISTERS PRESERVED
 23306 000030C8 1E                      	push	ds
 23307 000030C9 52                      	push	dx
 23308 000030CA 50                      	push	ax
 23309 000030CB 53                      	push	bx
 23310 000030CC 51                      	push	cx
 23311 000030CD 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 23312 000030D2 803E[D302]00            	cmp	byte [PipeFlag],0
 23313 000030D7 750D                    	jne	short NOREDIR
 23314 000030D9 F606[6602]FF            	test	byte [IfFlag],0FFh
 23315 000030DE 7506                    	jnz	short NOREDIR
 23316 000030E0 E88E00                  	call	TESTDOREIN
 23317 000030E3 E80600                  	call	TESTDOREOUT
 23318                                  NOREDIR:
 23319 000030E6 59                      	pop	cx
 23320 000030E7 5B                      	pop	bx
 23321 000030E8 58                      	pop	ax
 23322 000030E9 5A                      	pop	dx
 23323 000030EA 1F                      	pop	ds
 23324 000030EB C3                      	retn
 23325                                  
 23326                                  ; =============== S U B	R O U T	I N E =======================================
 23327                                  
 23328                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23329                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 23330                                  TESTDOREOUT:
 23331 000030EC 803E[8202]00            	cmp	byte [Re_OutStr],0
 23332                                  	;je	short NOREOUT  ; MSDOS 3.3
 23333                                  	; 26/02/2023
 23334 000030F1 7502                    	jne	short REOUTEXISTS
 23335 000030F3 EB7B                    	jmp	NOREOUT 
 23336                                  REOUTEXISTS:
 23337 000030F5 803E[8102]00            	cmp	byte [Re_Out_App],0
 23338 000030FA 745D                    	je	short REOUTCRT
 23339                                  
 23340 000030FC BA[8202]                	mov	dx,Re_OutStr
 23341                                  
 23342                                  	; 26/02/2023
 23343                                  	; MSDOS 6.0
 23344                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 23345 000030FF B8023D                  	mov	ax,3D02h
 23346                                  	; MSDOS 3.3
 23347                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 23348                                  	
 23349                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23350 00003102 50                      	push	ax
 23351 00003103 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23352                                  			; DS:DX	-> ASCIZ filename
 23353                                  			; AL = access mode
 23354                                  			; 1 - write
 23355 00003105 5B                      	pop	bx
 23356 00003106 724B                    	jc	short OpenWriteError
 23357                                  
 23358                                  	; 26/02/2023
 23359                                  	; MSDOS 6.0
 23360 00003108 89C3                    	mov	bx,ax
 23361                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 23362 0000310A B80044                  	mov	ax,4400h
 23363 0000310D CD21                    	int	21h			;AN035;
 23364                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 23365                                  			; BX = file or device handle
 23366 0000310F F6C280                  	test	dl,80h
 23367                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 23368 00003112 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 23369                                  	
 23370                                  	;mov	ax,(LSEEK SHL 8) OR 2
 23371 00003114 B80242                  	mov	ax,4202h
 23372 00003117 B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 23373 0000311A 89CA                    	mov	dx,cx			;AC011;
 23374 0000311C CD21                    	int	21h
 23375                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23376                                  			; AL = method: offset from end of file
 23377 0000311E 0E                      	push	cs			;AN011; Get transient seg to DS
 23378 0000311F 1F                      	pop	ds			;AN011;
 23379                                  	
 23380                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 23381 00003120 B8003F                  	mov	ax,3F00h
 23382 00003123 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 23383 00003126 BA[17A1]                	mov	dx,One_Char_Val		;AN011;
 23384 00003129 CD21                    	int	21h			;AN011;
 23385                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 23386                                  			; BX = file handle, CX = number of bytes to read
 23387                                  			; DS:DX -> buffer
 23388 0000312B 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 23389 0000312D 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 23390 0000312F 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 23391                                  	
 23392 00003131 803E[17A1]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 23393 00003136 8E1E[E49D]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 23394 0000313A 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 23395                                  	
 23396                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 23397 0000313C B80142                  	mov	ax,4201h
 23398 0000313F B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 23399                                  setreout_p:	; 26/02/2023
 23400 00003142 89CA                    	mov	dx,cx			;AN011;
 23401 00003144 CD21                    	int	21h			;AN011;
 23402 00003146 EB20                    	jmp	short SET_REOUT
 23403                                  reout_0_length: 			;AN017; We have a 0 length file
 23404                                  	; ds = cs ; 26/02/2023
 23405                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 23406                                  					;AN017; Get resident segment back
 23407                                  	; 26/02/2023
 23408 00003148 8E1E[E49D]              	mov	ds,[RESSEG]
 23409                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 23410 0000314C B80042                  	mov	ax,4200h
 23411 0000314F 31C9                    	xor	cx,cx			;AN017; Offset is 0
 23412                                  	;mov	dx,cx			;AN017;
 23413                                  	;int	21h			;AN017;
 23414                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 23415                                  	; 26/02/2023
 23416 00003151 EBEF                    	jmp	short setreout_p
 23417                                  
 23418                                  	; 26/02/2023
 23419                                  	; MSDOS 3.3
 23420                                  	;xor	dx,dx
 23421                                  	;xor	cx,cx
 23422                                  	;mov	bx,ax
 23423                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 23424                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23425                                  	;		; AL = method: offset from end of file
 23426                                  	;jmp	short SET_REOUT
 23427                                  		
 23428                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23429                                  OpenWriteError:	
 23430                                  	;cmp	ax,5
 23431 00003153 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 23432 00003156 F9                      	stc
 23433                                  	;;je	short REDIRERR ; MSDOS 3.3
 23434                                  	; 26/02/2023
 23435                                  	;jnz	short REOUTCRT
 23436                                  	;jmp	REDIRERR
 23437 00003157 743B                    	je	short REDIRERR
 23438                                  
 23439                                  REOUTCRT:	
 23440 00003159 BA[8202]                	mov	dx,Re_OutStr
 23441 0000315C 31C9                    	xor	cx,cx
 23442                                  	;mov	ah,CREAT ; 3Ch
 23443 0000315E B43C                    	mov	ah,3Ch
 23444 00003160 50                      	push	ax
 23445 00003161 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23446                                  			; CX = attributes for file
 23447                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23448 00003163 5B                      	pop	bx
 23449                                  	;jc	short REDIRERR ; MSDOS 3.3
 23450                                  	; 26/02/2023
 23451                                  	;jnc	short NOREDIRERR
 23452                                  	;jmp	REDIRERR
 23453 00003164 722E                    	jc	short REDIRERR
 23454                                  	
 23455                                  NOREDIRERR:
 23456 00003166 89C3                    	mov	bx,ax
 23457                                  SET_REOUT:
 23458                                  
 23459                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 23460                                  ; spot. We invalidate the new JFN we got.
 23461                                  
 23462 00003168 B0FF                    	mov	al,0FFh
 23463                                  	;xchg	al,[bx+18h]
 23464 0000316A 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23465 0000316D A21900                  	mov	[PDB.JFN_TABLE+1],al
 23466                                  NOREOUT:
 23467                                  IOSET_RETN:	; 17/04/2023
 23468 00003170 C3                      	retn
 23469                                  
 23470                                  ; =============== S U B	R O U T	I N E =======================================
 23471                                  
 23472                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23473                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23474                                  TESTDOREIN:
 23475 00003171 2E803E[8F9D]00          	cmp	byte [cs:RE_INSTR],0
 23476 00003177 74F7                    	jz	short IOSET_RETN
 23477 00003179 1E                      	push	ds
 23478 0000317A 0E                      	push	cs
 23479 0000317B 1F                      	pop	ds
 23480 0000317C BA[8F9D]                	mov	dx,RE_INSTR
 23481                                  	;mov	ax,OPEN*256 ; 3D00h
 23482 0000317F B8003D                  	mov	ax,3D00h
 23483 00003182 89C3                    	mov	bx,ax
 23484 00003184 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23485                                  			; DS:DX	-> ASCIZ filename
 23486                                  			; AL = access mode
 23487                                  			; 0 - read
 23488 00003186 1F                      	pop	ds
 23489                                  
 23490 00003187 720B                    	jc	short REDIRERR
 23491                                  
 23492 00003189 89C3                    	mov	bx,ax
 23493 0000318B B0FF                    	mov	al,0FFh
 23494                                  
 23495                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 23496                                  ; spot. We invalidate the new JFN we got.
 23497                                  
 23498                                  	;xchg	al,[bx+18h]
 23499 0000318D 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23500 00003190 A21800                  	mov	[PDB.JFN_TABLE],al
 23501 00003193 C3                      	retn
 23502                                  
 23503                                  ; ---------------------------------------------------------------------------
 23504                                  
 23505                                  ; We had some kind of error on the redirection. Figure out what the
 23506                                  ; appropriate message should be; BX has the system call that failed
 23507                                  
 23508                                  REDIRERR:
 23509 00003194 0E                      	push	cs
 23510 00003195 1F                      	pop	ds
 23511 00003196 E82E00                  	call	TriageError  ; MSDOS 6.0
 23512                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23513                                  
 23514                                  ; At this point, we have recognized the network-generated access denied error.
 23515                                  ; The correct message is in DX
 23516                                  
 23517 00003199 83F841                  	cmp	ax,65
 23518 0000319C 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 23519 0000319E 80FF3D                  	cmp	bh,OPEN ; 3Dh
 23520 000031A1 7406                    	je	short OpenError
 23521 000031A3 BA[1D92]                	mov	dx,FULLDIR_PTR
 23522                                  _CERRORJ:
 23523 000031A6 E9F4FC                  	jmp	cerror
 23524                                  
 23525                                  OpenError:
 23526                                  ; The system call was an OPEN. Report either file not found or path not found.
 23527                                  
 23528                                  	; 26/02/2023
 23529                                  	; MSDOS 6.0
 23530                                  	;mov	byte [cs:msg_disp_class],1
 23531 000031A9 2EC606[0192]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 23532                                  				;AN000; set up extended error msg class
 23533 000031AF BA[0392]                	mov	dx,extend_buf_ptr
 23534                                  				;AC000; get extended message pointer
 23535 000031B2 2EA3[0392]              	mov	[cs:extend_buf_ptr],ax
 23536                                  				;AN000; get message number in control block
 23537 000031B6 E9E4FC                  	jmp	cerror
 23538                                  
 23539                                  	; 26/02/2023
 23540                                  	; MSDOS 3.3
 23541                                  	;mov	dx,FNOTFOUNDPTR
 23542                                  	;;cmp	ax,2
 23543                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 23544                                  	;je	short _CERRORJ
 23545                                  	;mov	dx,ACCDENPTR
 23546                                  	;;cmp	ax,5 ; Access denied error
 23547                                  	;cmp	ax,ERROR_ACCESS_DENIED
 23548                                  	;je	short _CERRORJ
 23549                                  	;	; ERROR_PATH_NOT_FOUND
 23550                                  	;mov	dx,PNOTFOUNDPTR
 23551                                  	;jmp	CERROR
 23552                                  
 23553                                  ; =============== S U B	R O U T	I N E =======================================
 23554                                  
 23555                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 23556                                  ; registers
 23557                                  
 23558                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23559                                  dstrlen:
 23560 000031B9 50                      	push	ax
 23561 000031BA 31C9                    	xor	cx,cx
 23562 000031BC FC                      	cld
 23563                                  dloop:
 23564 000031BD AC                      	lodsb
 23565 000031BE 41                      	inc	cx
 23566 000031BF 08C0                    	or	al,al
 23567 000031C1 75FA                    	jnz	short dloop
 23568 000031C3 29CE                    	sub	si,cx
 23569 000031C5 58                      	pop	ax
 23570                                  TRIAGEERR_RETN:
 23571 000031C6 C3                      	retn
 23572                                  
 23573                                  ; =============== S U B	R O U T	I N E =======================================
 23574                                  
 23575                                  ;Break	<Extended error support>
 23576                                  
 23577                                  TriageError:  ; MSDOS 6.0
 23578                                  
 23579                                  ; TriageError will examine the return from a carry-set system call and
 23580                                  ; return the correct error if applicable.
 23581                                  ;
 23582                                  ;   Inputs:	outputs from a carry-settable system call
 23583                                  ;		No system calls may be done in the interrim
 23584                                  ;   Outputs:	If carry was set on input
 23585                                  ;		   carry set on output
 23586                                  ;		   DX contains trangroup offset to printf message
 23587                                  ;		else
 23588                                  ;		   No registers changed
 23589                                  
 23590                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 23591                                  
 23592                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23593                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 23594                                  
 23595                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23596                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 333Ch
 23597                                  
 23598                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 23599 000031C7 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 23600 000031C9 9C                      	pushf
 23601 000031CA 53                      	push	bx
 23602 000031CB 51                      	push	cx
 23603 000031CC 56                      	push	si
 23604 000031CD 57                      	push	di
 23605 000031CE 55                      	push	bp
 23606 000031CF 06                      	push	es
 23607 000031D0 1E                      	push	ds
 23608 000031D1 50                      	push	ax
 23609 000031D2 52                      	push	dx
 23610 000031D3 B459                    	mov	ah,59h
 23611                                  	;mov	ah,GETEXTENDEDERROR
 23612 000031D5 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 23613                                  			; BX = version code (0000h for DOS 3.x)
 23614 000031D7 59                      	pop	cx
 23615 000031D8 5B                      	pop	bx		; restore original AX
 23616 000031D9 BA[2992]                	mov	dx,ACCDEN_PTR
 23617 000031DC 83F841                  	cmp	ax,65		; network access denied?
 23618 000031DF 7404                    	je	short NoMove	; Yes, return it.
 23619 000031E1 89D8                    	mov	ax,bx
 23620 000031E3 89CA                    	mov	dx,cx
 23621                                  NoMove:
 23622 000031E5 1F                      	pop	ds
 23623 000031E6 07                      	pop	es
 23624 000031E7 5D                      	pop	bp
 23625 000031E8 5F                      	pop	di
 23626 000031E9 5E                      	pop	si
 23627 000031EA 59                      	pop	cx
 23628 000031EB 5B                      	pop	bx
 23629 000031EC 9D                      	popf
 23630 000031ED C3                      	retn
 23631                                  
 23632                                  ; =============== S U B	R O U T	I N E =======================================
 23633                                  
 23634                                  	; Far call from resident portion/segment of COMMAND.COM
 23635                                  
 23636                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 23637                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 23638                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3363h
 23639                                  
 23640                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23641                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23642                                  Triage_Init:
 23643 000031EE E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 23644                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23645 000031F1 CB                      	retf
 23646                                  
 23647                                  ; =============== S U B	R O U T	I N E =======================================
 23648                                  
 23649                                  ; MSDOS 6.0
 23650                                  
 23651                                  ; ****************************************************************
 23652                                  ; *
 23653                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 23654                                  ; *
 23655                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 23656                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 23657                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 23658                                  ; *
 23659                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 23660                                  ; *		 ES    points to TRANGROUP
 23661                                  ; *
 23662                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 23663                                  ; *		 PATHCNT set to length of string
 23664                                  ; *		 PATHPOS set to start of SRCBUF
 23665                                  ; *		 CX,AX	 changed
 23666                                  ; *
 23667                                  ; ****************************************************************
 23668                                  
 23669                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23670                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23671                                  Move_To_SrcBuf:
 23672 000031F2 56                      	push	si			;AN000;  save si,di
 23673 000031F3 57                      	push	di			;AN000;
 23674 000031F4 51                      	push	cx			;AN000;
 23675 000031F5 BF[87A1]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 23676 000031F8 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 23677 000031FA 89C8                    	mov	ax,cx			;AN000; clear ax
 23678 000031FC 57                      	push	di			;AN000; save start of srcbuf
 23679 000031FD AC                      	lodsb				;AN000; get a character from DS:SI
 23680                                  mts_get_chars:				;AN000;
 23681                                  	;cmp	al,0			;AN000; was it a null char?
 23682 000031FE 20C0                    	and 	al,al ; al = 0 ?
 23683 00003200 7405                    	jz	short mts_end_string	;AN000; yes - exit
 23684 00003202 AA                      	stosb				;AN000; no - store it in srcbuf
 23685 00003203 41                      	inc	cx			;AN000; increment length count
 23686 00003204 AC                      	lodsb				;AN000; get a character from DS:SI
 23687 00003205 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 23688                                  mts_end_string: 			;AN000; we've reached the end of line
 23689                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 23690 00003207 B00D                    	mov	al,0Dh
 23691 00003209 AA                      	stosb				;AN000;
 23692 0000320A 5F                      	pop	di			;AN000; restore start of srcbuf
 23693 0000320B 0E                      	push	cs			;AN000; set DS to local segment
 23694 0000320C 1F                      	pop	ds			;AN000;
 23695 0000320D 890E[73A0]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 23696 00003211 893E[75A0]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 23697 00003215 59                      	pop	cx			;AN000; restore cx,di,si
 23698 00003216 5F                      	pop	di			;AN000;
 23699 00003217 5E                      	pop	si			;AN000;
 23700 00003218 C3                      	retn				;AN000; exit
 23701                                  
 23702                                  ;============================================================================
 23703                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 23704                                  ;============================================================================
 23705                                  ; 03/10/2018 - Retro DOS v3.0
 23706                                  
 23707                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 23708                                  
 23709                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23710                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 23711                                  
 23712                                  ; =============== S U B	R O U T	I N E =======================================
 23713                                  
 23714                                  	; 26/02/2023
 23715                                  SINGLETEST:
 23716 00003219 1E                      	push	ds
 23717 0000321A 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 23718 0000321F 833E[6102]00            	cmp	word [SingleCom],0
 23719 00003224 7406                    	jz	short TESTDONE
 23720 00003226 813E[6102]FFEF          	cmp	word [SingleCom],0EFFFh
 23721                                  TESTDONE:
 23722 0000322C 1F                      	pop	ds
 23723 0000322D C3                      	retn
 23724                                  
 23725                                  ; =============== S U B	R O U T	I N E =======================================
 23726                                  
 23727                                  	; 26/02/2023
 23728                                  SetRest1:
 23729 0000322E B001                    	mov	al,1
 23730                                  
 23731                                  ; ---------------------------------------------------------------------------
 23732                                  
 23733                                  SETREST:
 23734 00003230 1E                      	push	ds
 23735 00003231 8E1E[E49D]              	mov	ds,[RESSEG]
 23736 00003235 A2[5D02]                	mov	[RestDir],al
 23737 00003238 1F                      	pop	ds
 23738 00003239 C3                      	retn
 23739                                  
 23740                                  ; =============== S U B	R O U T	I N E =======================================
 23741                                  
 23742                                  ; Note that we need to handle the same thing that RestDir handles: the
 23743                                  ; requirement that we try only once to restore the user's environment after
 23744                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 23745                                  ; disappear, we just give up.
 23746                                  
 23747                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23748                                  	;
 23749                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23750                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33AFh 
 23751                                  PIPEDEL:
 23752 0000323A 1E                      	push	ds
 23753 0000323B 52                      	push	dx
 23754 0000323C 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 23755                                  	;mov	dx,3EAh	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33B1h
 23756                                  	;;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 23757                                  			; Pipe1 = offset RESGROUP:EndInit
 23758 00003241 BA[D502]                	mov	dx,Pipe1	; Clean up in case ^C
 23759                                  	;mov	ah,Unlink ; 41h 
 23760 00003244 B441                    	mov	ah,41h
 23761 00003246 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23762                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 23763                                  			;		(no wildcards allowed)
 23764                                  
 23765                                  	;mov	dx,439h	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33BDh
 23766                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 23767                                  			; Pipe2 = offset RESGROUP:EndInit+79
 23768 00003248 BA[2403]                	mov	dx,Pipe2
 23769                                  	;mov	ah,Unlink ; 41h
 23770 0000324B B441                    	mov	ah,41h
 23771 0000324D CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23772                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 23773                                  			;		(no wildcards allowed)
 23774 0000324F 5A                      	pop	dx
 23775 00003250 E86202                  	call	PipeOff
 23776 00003253 C606[D402]00            	mov	byte [PipeFiles],0
 23777 00003258 1F                      	pop	ds
 23778 00003259 C3                      	retn
 23779                                  
 23780                                  ; ---------------------------------------------------------------------------
 23781                                  
 23782                                  	; 26/02/2023
 23783                                  PIPEERRSYN:
 23784 0000325A BA[9B92]                	mov	dx,SYNTMES_PTR
 23785 0000325D E8DAFF                  	call	PIPEDEL
 23786 00003260 0E                      	push	cs
 23787 00003261 1F                      	pop	ds
 23788 00003262 E938FC                  	jmp	cerror
 23789                                  
 23790                                  ; ---------------------------------------------------------------------------
 23791                                  
 23792                                  	; 26/02/2023
 23793                                  PIPERR:
 23794 00003265 9C                      	pushf
 23795 00003266 E85EFF                  	call    TriageError
 23796                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 23797 00003269 50                      	push	ax		; Save results from TriageError
 23798 0000326A 52                      	push	dx
 23799 0000326B BA[6493]                	mov	dx,PIPEEMES_PTR
 23800 0000326E E8C9FF                  	call	PIPEDEL
 23801 00003271 0E                      	push	cs
 23802 00003272 1F                      	pop	ds
 23803 00003273 E8BF22                  	call	std_eprintf
 23804 00003276 5A                      	pop	dx		; Restore results from TriageError
 23805 00003277 58                      	pop	ax
 23806 00003278 9D                      	popf
 23807 00003279 83F841                  	cmp	ax,65
 23808 0000327C 7503                    	jne	short TCOMMANDJ
 23809 0000327E E91CFC                  	jmp	cerror
 23810                                  
 23811                                  TCOMMANDJ:
 23812 00003281 E980CE                  	jmp	TCOMMAND
 23813                                  
 23814                                  ; ---------------------------------------------------------------------------
 23815                                  
 23816                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23817                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23818                                  PIPEPROCSTRT:
 23819 00003284 8E1E[E49D]              	mov	ds,[RESSEG]
 23820 00003288 FE06[D402]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 23821                                  
 23822                                  	; MSDOS 6.0
 23823 0000328C 06                      	push	es
 23824 0000328D 57                      	push	di
 23825 0000328E 1E                      	push	ds
 23826 0000328F 56                      	push	si
 23827                                  	
 23828 00003290 1E                      	push	ds
 23829 00003291 06                      	push	es
 23830 00003292 1F                      	pop	ds			;ds = TRANGROUP
 23831 00003293 BE[1A99]                	mov	si,TempVarName		;ds:si = "TEMP="
 23832                                  
 23833                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 23834                                  ;so the routine is not really general
 23835                                  
 23836 00003296 E8C7F5                  	call	find_name_in_environment
 23837                                  					;es:di points at path
 23838 00003299 1F                      	pop	ds			;ds = DATARES again
 23839 0000329A 721F                    	jc	short no_temp_path
 23840                                  	
 23841 0000329C 1E                      	push	ds
 23842 0000329D 06                      	push	es
 23843 0000329E 1F                      	pop	ds
 23844 0000329F 07                      	pop	es			;swap ds and es
 23845 000032A0 89FE                    	mov	si,di			;ds:si points at path
 23846                                  	
 23847 000032A2 E8AA02                  	call	skip_white		;skip white space chars
 23848                                  
 23849                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 23850                                  
 23851 000032A5 E8B302                  	call	copy_pipe_path		;copy the pipe path
 23852                                  	
 23853                                  ;Check if the TEMP path is valid
 23854                                  
 23855 000032A8 06                      	push	es
 23856 000032A9 1F                      	pop	ds			;ds = DATARES
 23857                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 23858                                  	;;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 23859                                  	;mov	dx,3EAh	; MSDOS 6.22 - offset EndInit
 23860 000032AA BA[D502]                	mov	dx,Pipe1
 23861                                  	;mov	ax,(CHMOD shl 8) or 0
 23862 000032AD B80043                  	mov	ax,4300h
 23863 000032B0 CD21                    	int	21h
 23864 000032B2 7207                    	jc	short no_temp_path
 23865                                  	
 23866 000032B4 F7C11000                	test	cx,10h			;is it a directory?
 23867 000032B8 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 23868                                  	
 23869 000032BA F9                      	stc				;no, indicate fail
 23870                                  no_temp_path:
 23871 000032BB 5E                      	pop	si
 23872 000032BC 1F                      	pop	ds
 23873 000032BD 5F                      	pop	di
 23874 000032BE 07                      	pop	es
 23875 000032BF 730B                    	jnc	short crt_temp		;path found, create tempfiles
 23876                                  
 23877                                  	; 27/02/2023
 23878                                  	; MSDOS 3.3
 23879                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 23880                                  	;				; Get current drive
 23881                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 23882                                  	;add	al,[cs:CAPITAL_A]
 23883                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 23884                                  	;mov	bx,PIPE1
 23885                                  	;mov	[bx],al
 23886                                  	;xor	ah,ah			; nul terminate path names
 23887                                  	;mov	byte [PIPE1+3],ah
 23888                                  	;mov	byte [PIPE2+3],ah
 23889                                  
 23890                                  	; MSDOS 6.0
 23891                                  ;SR;
 23892                                  ; We want to create temp files in the current directory rather than in the 
 23893                                  ;root of the drive. This is because the number of files that can be present
 23894                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 23895                                  
 23896                                  	;mov	ah,'.'
 23897                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 23898                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 23899                                  	;xor	ah,ah
 23900                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 23901                                  	;mov	[Pipe2+1],ah		;create files in current dir
 23902                                  	; 27/02/2023
 23903 000032C1 B92E00                  	mov	cx,002Eh
 23904 000032C4 890E[D502]              	mov	[Pipe1],cx
 23905 000032C8 890E[2403]              	mov	[Pipe2],cx
 23906                                  crt_temp:
 23907                                  	; MSDOS 6.0
 23908                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 23909                                  	;;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 23910                                  	;mov	dx,3EAh ; MSDOS 6.22 COMMAND.COM	
 23911 000032CC BA[D502]                	mov	dx,Pipe1
 23912                                  	; MSDOS 3.3
 23913                                  	;mov	dx,bx
 23914                                  	
 23915                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23916 000032CF 31C9                    	xor	cx,cx
 23917                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23918 000032D1 B45A                    	mov	ah,5Ah
 23919 000032D3 CD21                    	int	21h
 23920                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23921                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23922                                  		; receive generated filename
 23923                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23924 000032D5 728E                    	jc	short PIPERR	; Couldn't create
 23925                                  
 23926 000032D7 89C3                    	mov	bx,ax
 23927                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23928 000032D9 B43E                    	mov	ah,3Eh
 23929 000032DB CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23930                                  			; BX = file handle
 23931                                  	;;;mov	dx,PIPE2
 23932                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 23933                                  	;mov	dx,439h ; MSDOS 6.22 COMMAND.COM
 23934 000032DD BA[2403]                	mov	dx,Pipe2
 23935                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 23936 000032E0 B45A                    	mov	ah,5Ah
 23937 000032E2 CD21                    	int	21h
 23938                                  		; DOS -	3+ - CREATE UNIQUE FILE
 23939                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 23940                                  		; receive generated filename
 23941                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 23942                                  	; 17/04/2023
 23943                                  	;jc	short PIPERR
 23944                                  	; 27/02/2023
 23945 000032E4 7303                    	jnc	short pps1
 23946 000032E6 E97CFF                  	jmp	PIPERR
 23947                                  pps1:
 23948 000032E9 89C3                    	mov	bx,ax
 23949 000032EB B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 23950 000032ED CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 23951                                  				; BX = file handle
 23952                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 23953 000032EF E87FFE                  	call	TESTDOREIN
 23954                                  	;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 23955 000032F2 8B36[7303]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23956 000032F6 833E[6102]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 23957 000032FB 7506                    	jne	short NOSINGP
 23958 000032FD C706[6102]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 23959                                  NOSINGP:
 23960 00003303 EB29                    	jmp	short FIRSTPIPE
 23961                                  
 23962                                  ; ---------------------------------------------------------------------------
 23963                                  
 23964                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23965                                  	; 11/06/2026 - Retro DOS v4.2 COMMAND.COM
 23966                                  PIPEPROC:
 23967 00003305 8026[5902]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 23968                                  	;;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 23969 0000330A 8B36[7303]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 23970 0000330E AC                      	lodsb
 23971                                  	; 27/02/2023
 23972 0000330F 3C7C                    	cmp	al,'|'		
 23973                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 23974                                  	;je	short ISPIPE1	; Yes
 23975                                  	;cmp	al,'|'
 23976                                  	;;cmp	al,[cs:VBAR]
 23977 00003311 7403                    	je	short ISPIPE1
 23978 00003313 E98400                  	jmp	PIPEEND		; Pipe done
 23979                                  ISPIPE1:
 23980 00003316 8B16[F603]              	mov	dx,[InPipePtr]	; Get the input file name
 23981                                  	;mov	ax,OPEN*256 ; 3D00h
 23982 0000331A B8003D                  	mov	ax,3D00h
 23983 0000331D CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23984                                  			; DS:DX	-> ASCIZ filename
 23985                                  			; AL = access mode
 23986                                  			; 0 - read
 23987                                  PIPEERRJ:
 23988 0000331F 7303                    	jnc	short NO_PIPEERR
 23989 00003321 E941FF                  	jmp	PIPERR		; Lost the pipe file
 23990                                  NO_PIPEERR:
 23991 00003324 89C3                    	mov	bx,ax
 23992 00003326 B0FF                    	mov	al,0FFh
 23993                                  	;xchg	al,[bx+18h]
 23994 00003328 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23995 0000332B A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 23996                                  FIRSTPIPE:
 23997 0000332E BF[459C]                	mov	di,COMBUF+2
 23998 00003331 31C9                    	xor	cx,cx
 23999 00003333 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 24000 00003336 7503                    	jne	short PIPEOK1
 24001                                  PIPEERRSYNJ:
 24002 00003338 E91FFF                  	jmp	PIPEERRSYN
 24003                                  PIPEOK1:
 24004                                  	;;;mov	al,[cs:VBAR]
 24005                                  	; 27/02/2023
 24006                                  	;;mov	al,vbar
 24007                                  	;mov	al,'|'
 24008                                  	;cmp	[si],al		; '||'
 24009                                  	;je	short PIPEERRSYNJ
 24010 0000333B 803C7C                  	cmp	byte [si],'|'
 24011                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 24012 0000333E 74F8                    	je	short PIPEERRSYNJ
 24013                                  PIPECOMLP:
 24014 00003340 AC                      	lodsb
 24015 00003341 AA                      	stosb
 24016                                  	; 27/02/2023
 24017 00003342 E8C5F5                  	call	testkanj
 24018 00003345 7405                    	jz	short NOTKANJ5
 24019 00003347 A4                      	movsb
 24020                                  ;  Added following 2 commands to the fix pipe bug.
 24021 00003348 41                      	inc	cx		;AN000;  3/3/KK
 24022 00003349 41                      	inc	cx		;AN000;  3/3/KK
 24023 0000334A EBF4                    	jmp	short PIPECOMLP
 24024                                  NOTKANJ5:
 24025 0000334C 3C0D                    	cmp	al,0Dh
 24026 0000334E 7438                    	je	short LASTPIPE
 24027 00003350 41                      	inc	cx
 24028                                  	; 27/02/2023
 24029 00003351 3C7C                    	cmp	al,'|'
 24030                                  	;cmp	al,ALTPIPECHR
 24031                                  	;je	short ISPIPE2
 24032                                  	;;cmp	al,[cs:VBAR]
 24033                                  	;cmp	al,vbar
 24034 00003353 75EB                    	jne	short PIPECOMLP
 24035                                  ISPIPE2:
 24036 00003355 26C645FF0D              	mov	byte [es:di-1],0Dh
 24037 0000335A 49                      	dec	cx
 24038                                  	;mov	[cs:COMBUF+1],cl
 24039                                  	; 27/02/2023
 24040 0000335B 26880E[449C]            	mov	[es:COMBUF+1],cl
 24041 00003360 4E                      	dec	si
 24042                                  	;;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24043                                  	; 11/06/2023 - MSDOS 6.22 COMMAND.COM
 24044                                  	;mov	[488h],si ; [PipePtr] = [EndInit+158]
 24045 00003361 8936[7303]              	mov	[PipePtr],si		; On to next pipe element
 24046                                  			; mov [EndInit+158],si
 24047 00003365 8B16[F803]              	mov	dx,[OutPipePtr]
 24048 00003369 51                      	push	cx
 24049 0000336A 31C9                    	xor	cx,cx
 24050                                  	;mov	ax,CREAT*256 ; 3C00h
 24051 0000336C B8003C                  	mov	ax,3C00h
 24052 0000336F CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 24053                                  			; CX = attributes for file
 24054                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 24055 00003371 59                      	pop	cx
 24056 00003372 72AB                    	jc	short PIPEERRJ		; Lost the file
 24057 00003374 89C3                    	mov	bx,ax
 24058 00003376 B0FF                    	mov	al,0FFh
 24059                                  	;xchg	al,[bx+18h]
 24060 00003378 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 24061 0000337B A21900                  	mov	[PDB.JFN_TABLE+1],al
 24062 0000337E 8716[F603]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 24063 00003382 8916[F803]              	mov	[OutPipePtr],dx
 24064 00003386 EB0D                    	jmp	short PIPECOM
 24065                                  LASTPIPE:
 24066                                  	;mov	[cs:COMBUF+1],cl 
 24067                                  	; 27/02/2023
 24068 00003388 26880E[449C]            	mov	[es:COMBUF+1],cl
 24069 0000338D 4E                      	dec	si
 24070                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24071                                  	;mov	[488h],si ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24072 0000338E 8936[7303]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 24073                                  		; mov [EndInit+158],si
 24074 00003392 E857FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 24075                                  PIPECOM:
 24076 00003395 0E                      	push	cs
 24077 00003396 1F                      	pop	ds
 24078 00003397 E980CF                  	jmp	NOPIPEPROC	; Process the pipe element
 24079                                  PIPEEND:
 24080 0000339A E89DFE                  	call	PIPEDEL
 24081 0000339D 813E[6102]00F0          	cmp	word [SingleCom],0F000h
 24082 000033A3 7506                    	jnz	short NOSINGP2
 24083 000033A5 C706[6102]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 24084                                  NOSINGP2:
 24085 000033AB E956CD                  	jmp	TCOMMAND
 24086                                  
 24087                                  ; =============== S U B	R O U T	I N E =======================================
 24088                                  
 24089                                  ; Date and time are set during initialization and use
 24090                                  ; this routines since they need to do a long return
 24091                                  
 24092                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24093                                  DATINIT:
 24094 000033AE 2E8C1E[E49D]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 24095 000033B3 06                      	push	es
 24096 000033B4 1E                      	push	ds		; Going to use the previous stack
 24097 000033B5 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 24098 000033B7 8EC0                    	mov	es,ax
 24099 000033B9 8ED8                    	mov	ds,ax
 24100 000033BB E85E22                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 24101 000033BE BA[06AA]                	mov	dx,INTERNATVARS
 24102 000033C1 B80038                  	mov	ax,3800h
 24103                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 24104 000033C4 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 24105                                  			; get current-country info
 24106                                  			; DS:DX	-> buffer for returned info
 24107                                  	; 20/10/2018
 24108 000033C6 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 24109 000033CC C606[439C]80            	mov	byte [COMBUF],128 ; Init COMBUF
 24110 000033D1 C706[449C]010D          	mov	word [COMBUF+1],0D01h
 24111 000033D7 E80600                  	call	DATE
 24112 000033DA E86200                  	call	CTIME
 24113 000033DD 1F                      	pop	ds
 24114 000033DE 07                      	pop	es
 24115 000033DF CB                      	retf	; far return
 24116                                  
 24117                                  ; =============== S U B	R O U T	I N E =======================================
 24118                                  
 24119                                  ; MSDOS 6.0
 24120                                  
 24121                                  ; ****************************************************************
 24122                                  ; *
 24123                                  ; * ROUTINE:	 DATE - Set system date
 24124                                  ; *
 24125                                  ; * FUNCTION:	 If a date is specified, set the system date,
 24126                                  ; *		 otherwise display the current system date and
 24127                                  ; *		 prompt the user for a new date.  If an invalid
 24128                                  ; *		 date is specified, issue an error message and
 24129                                  ; *		 prompt for a new date.  If the user enters
 24130                                  ; *		 nothing when prompted for a date, terminate.
 24131                                  ; *
 24132                                  ; * INPUT:	 command line at offset 81H
 24133                                  ; *
 24134                                  ; * OUTPUT:	 none
 24135                                  ; *
 24136                                  ; ****************************************************************
 24137                                  
 24138                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24139                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 24140                                  
 24141                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24142                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:356Eh
 24143                                  DATE:
 24144 000033E0 BE8100                  	mov	si,81h			; Accepting argument for date inline
 24145 000033E3 BF[1598]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24146 000033E6 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24147 000033E8 31D2                    	xor	dx,dx			;AN000;
 24148 000033EA E87F16                  	call	cmd_parse		;AC000; call parser
 24149                                  
 24150                                  	; 27/02/2023
 24151                                  	;cmp	ax,-1
 24152                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24153                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 24154                                  	;;cmp	ax,0
 24155                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24156                                  	;;jne	short DATERR		;AN000; yes - go issue message
 24157                                  	; 26/04/2023
 24158                                  	;or	ax,ax ; ax = 0 ?
 24159                                  	;jnz	short DATERR
 24160                                  	;;jmp	short COMDAT		;AC000; we have a date
 24161                                  	; 11/06/2023
 24162 000033ED 40                      	inc	ax  ; cmp ax,-1
 24163 000033EE 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 24164 000033F0 48                      	dec	ax  ; cmp ax,0
 24165 000033F1 7541                    	jnz	short DATERR ; 1 -> 0
 24166                                  	; ax = 0
 24167                                  
 24168                                  	; 27/02/2023
 24169                                  COMDAT:
 24170 000033F3 8B0E[63AA]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 24171 000033F7 8A36[65AA]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 24172 000033FB 8A16[66AA]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 24173 000033FF 51                      	push	cx			;AC000; save date
 24174 00003400 52                      	push	dx			;AC000;
 24175 00003401 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 24176 00003404 31D2                    	xor	dx,dx			;AN029;
 24177 00003406 E86316                  	call	cmd_parse		;AN029; call parser
 24178 00003409 3CFF                    	cmp	al,0FFh ; -1
 24179                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24180 0000340B 5A                      	pop	dx			;AC000; retrieve date
 24181 0000340C 59                      	pop	cx			;AC000;
 24182 0000340D 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 24183                                  	; 26/04/2023
 24184                                  	;mov	ah,SET_DATE		;yes - set date
 24185 0000340F B42B                    	mov	ah,2Bh
 24186 00003411 CD21                    	int	21h
 24187                                  			; DOS - SET CURRENT DATE
 24188                                  			; DL = day, DH = month, CX = year
 24189                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 24190 00003413 08C0                    	or	al,al
 24191 00003415 751D                    	jnz	short DATERR
 24192                                  date_end:
 24193 00003417 C3                      	retn
 24194                                  
 24195                                  PRMTDAT:
 24196                                  	; Print "Current date is
 24197 00003418 E82908                  	call	GetDate 		;AN000; get date for output
 24198                                  
 24199 0000341B 86F2                    	xchg	dh,dl			;AN000; switch month & day
 24200 0000341D 890E[B192]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 24201 00003421 8916[B392]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 24202 00003425 BA[A192]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 24203 00003428 E81221                  	call	std_printf
 24204                                  
 24205                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 24206                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 24207                                  
 24208                                  GET_NEW_DATE:				;AN000;
 24209 0000342B E8BC00                  	call	GETDAT			;AC000; prompt user for date
 24210                                  	
 24211                                  	; 11/06/2023
 24212                                  	;cmp	ax,0FFFFh ; -1
 24213                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24214                                  	;je	short date_end		;AC000; yes - exit
 24215                                  	; 26/04/2023
 24216                                  	;;cmp	ax,0
 24217                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24218                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 24219                                  	;; 27/02/2023
 24220                                  	;;jz	short COMDAT
 24221                                  	; 26/04/2023
 24222                                  	;and	ax,ax ; 0 ?
 24223                                  	;jz	short COMDAT
 24224                                  
 24225                                  	; 11/06/2023
 24226 0000342E 40                      	inc	ax  ; cmp ax,-1
 24227 0000342F 74E6                    	jz	short date_end ; 0FFFFh -> 0
 24228 00003431 48                      	dec	ax  ; cmp ax,0
 24229 00003432 74BF                    	jz	short COMDAT ; 1 -> 0
 24230                                  	; ax > 0
 24231                                  
 24232                                  ;COMDAT:
 24233                                  ;	....
 24234                                  DATERR:
 24235 00003434 E8E5F6                  	call	CRLF2			;AN028; print out a blank line
 24236 00003437 BA[9E92]                	mov	dx,BADDAT_PTR
 24237 0000343A E80021                  	call	std_printf
 24238 0000343D EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 24239                                  
 24240                                  ; =============== S U B	R O U T	I N E =======================================
 24241                                  
 24242                                  ; MSDOS 6.0
 24243                                  
 24244                                  ; TIME gets and sets the time
 24245                                  
 24246                                  ; ****************************************************************
 24247                                  ; *
 24248                                  ; * ROUTINE:	 TIME - Set system time
 24249                                  ; *
 24250                                  ; * FUNCTION:	 If a time is specified, set the system time,
 24251                                  ; *		 otherwise display the current system time and
 24252                                  ; *		 prompt the user for a new time.  If an invalid
 24253                                  ; *		 time is specified, issue an error message and
 24254                                  ; *		 prompt for a new time.  If the user enters
 24255                                  ; *		 nothing when prompted for a time, terminate.
 24256                                  ; *
 24257                                  ; * INPUT:	 command line at offset 81H
 24258                                  ; *
 24259                                  ; * OUTPUT:	 none
 24260                                  ; *
 24261                                  ; ****************************************************************
 24262                                  
 24263                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24264                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 24265                                  
 24266                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24267                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:35D7h
 24268                                  CTIME:
 24269 0000343F BE8100                  	mov	si,81h			; Accepting argument for time inline
 24270 00003442 BF[2798]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 24271 00003445 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24272 00003447 31D2                    	xor	dx,dx			;AN000;
 24273 00003449 E82016                  	call	cmd_parse		;AC000; call parser
 24274                                  	
 24275                                  	; 27/02/2023
 24276                                  	;cmp	ax,-1
 24277                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24278                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 24279                                  	;;cmp	ax,0
 24280                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24281                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24282                                  	;and	ax,ax ; ax = 0 ?
 24283                                  	;jnz	short TIMERR
 24284                                  	;;jmp	short COMTIM		;AC000; we have a time
 24285                                  	; 11/06/2023
 24286 0000344C 40                      	inc	ax  ; cmp ax,-1
 24287 0000344D 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 24288 0000344F 48                      	dec	ax  ; cmp ax,0
 24289 00003450 7548                    	jnz	short TIMERR ; 1 -> 0
 24290                                  	; ax = 0
 24291                                  	
 24292                                  	; 27/02/2023
 24293                                  COMTIM:
 24294 00003452 8A2E[6BAA]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 24295 00003456 8A0E[6CAA]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 24296 0000345A 8A36[6DAA]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 24297 0000345E 8A16[6EAA]              	mov	dl,[TIME_FRACTION]	;AC000;
 24298 00003462 51                      	push	cx			;AC000; save time
 24299 00003463 52                      	push	dx			;AC000;
 24300 00003464 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 24301 00003467 31D2                    	xor	dx,dx			;AN029;
 24302 00003469 E80016                  	call	cmd_parse		;AN029; call parser
 24303 0000346C 3CFF                    	cmp	al, -1
 24304                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24305 0000346E 5A                      	pop	dx			;AC000; retieve time
 24306 0000346F 59                      	pop	cx			;AC000;
 24307 00003470 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 24308                                  SAVTIM:
 24309                                  	;mov	ah,SET_TIME
 24310 00003472 B42D                    	mov	ah,2Dh
 24311 00003474 CD21                    	int	21h
 24312 00003476 08C0                    	or	al,al
 24313 00003478 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 24314                                  time_end:
 24315 0000347A C3                      	retn
 24316                                  
 24317                                  PRMTTIM:
 24318                                  	;Printf "Current time is ... "
 24319                                  
 24320                                  	;mov	ah,Get_Time		;AC000; get the current time
 24321 0000347B B42C                    	mov	ah,2Ch
 24322 0000347D CD21                    	int	21h			;AC000;   Get time in CX:DX
 24323 0000347F 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24324 00003481 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24325 00003483 890E[D392]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24326 00003487 8916[D592]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24327 0000348B BA[CE92]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 24328 0000348E E8AC20                  	call	std_printf
 24329                                  
 24330                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 24331                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 24332                                  
 24333                                  GET_NEW_TIME:
 24334 00003491 E8AE00                  	call	GETTIM			;AC000;
 24335                                  	
 24336                                  	; 11/06/2023
 24337                                  	;cmp	ax,-1
 24338                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24339                                  	;je	short time_end		;AC000;
 24340                                  	;;cmp	ax,0
 24341                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24342                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24343                                  	;or	ax,ax  ; ax = 0 ?
 24344                                  	;;jnz	short TIMERR
 24345                                  	; 27/02/2023
 24346                                  	;jz	short COMTIM
 24347                                  
 24348                                  	; 11/06/2023
 24349 00003494 40                      	inc	ax  ; cmp ax,-1
 24350 00003495 74E3                    	jz	short time_end ; 0FFFFh -> 0
 24351 00003497 48                      	dec	ax  ; cmp ax,0
 24352 00003498 74B8                    	jz	short COMTIM ; 1 -> 0
 24353                                  	; ax > 0
 24354                                  
 24355                                  ;COMTIM:
 24356                                  ;	....
 24357                                  TIMERR:
 24358 0000349A E87FF6                  	call	CRLF2			;AN028; print out a blank line
 24359 0000349D BA[CB92]                	mov	dx,BadTim_Ptr
 24360 000034A0 E89A20                  	call	std_printf		; Print error message
 24361 000034A3 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 24362                                  
 24363                                  ; =============== S U B	R O U T	I N E =======================================
 24364                                  
 24365                                  ; MSDOS 6.0
 24366                                  
 24367                                  ; Set the special flag in the INIT flag to the value in CX.
 24368                                  
 24369                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24370                                  SetInitFlag:
 24371 000034A5 8E1E[E49D]              	mov	ds,[RESSEG]
 24372                                  
 24373 000034A9 8026[D202]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 24374                                  	;and	byte [InitFlag],0FDh
 24375 000034AE 080E[D202]              	or	byte [InitFlag],cl
 24376 000034B2 0E                      	push	cs
 24377 000034B3 1F                      	pop	ds
 24378 000034B4 C3                      	retn
 24379                                  
 24380                                  ; =============== S U B	R O U T	I N E =======================================
 24381                                  
 24382                                  ; MSDOS 6.0
 24383                                  
 24384                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24385                                  PipeOff:
 24386 000034B5 1E                      	push	ds
 24387 000034B6 50                      	push	ax
 24388 000034B7 2E8E1E[E49D]            	mov	ds,[cs:RESSEG]
 24389 000034BC 30C0                    	xor	al,al
 24390 000034BE 8606[D302]              	xchg	[PipeFlag],al
 24391 000034C2 08C0                    	or	al,al
 24392 000034C4 7404                    	jz	short PipeOffDone
 24393 000034C6 D02E[5902]              	shr	byte [EchoFlag],1
 24394                                  PipeOffDone:
 24395 000034CA 58                      	pop	ax
 24396 000034CB 1F                      	pop	ds
 24397 000034CC C3                      	retn
 24398                                  
 24399                                  ; =============== S U B	R O U T	I N E =======================================
 24400                                  
 24401                                  ; MSDOS 6.0
 24402                                  
 24403                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24404                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24405                                  PRINT_TIME:
 24406                                  	;mov	ah,Get_Time
 24407 000034CD B42C                    	mov	ah,2Ch
 24408 000034CF CD21                    	int	21h			; Get time in CX:DX
 24409                                  
 24410 000034D1 06                      	push	es
 24411 000034D2 0E                      	push	cs
 24412 000034D3 07                      	pop	es
 24413 000034D4 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24414 000034D6 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24415 000034D8 2E890E[0F94]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24416 000034DD 2E8916[1194]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24417 000034E2 BA[0A94]                	mov	dx,promtim_ptr		;AC000; set up message for output
 24418 000034E5 E85520                  	call	std_printf
 24419                                  
 24420                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 24421                                  					;AC000; reset hour, minutes, seconds, and hundredths
 24422                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 24423                                  					;AC000;  pointers in control block
 24424 000034E8 07                      	pop	es
 24425 000034E9 C3                      	retn
 24426                                  
 24427                                  ; =============== S U B	R O U T	I N E =======================================
 24428                                  
 24429                                  ; MSDOS 6.0
 24430                                  
 24431                                  ; ****************************************************************
 24432                                  ; *
 24433                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 24434                                  ; *
 24435                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 24436                                  ; *		 INFORMATION and issues the "Enter new date"
 24437                                  ; *		 message with the proper date format. COMBUF
 24438                                  ; *		 is reset to get a date from the command line.
 24439                                  ; *		 The PARSE_DATE blocks are then reset and the
 24440                                  ; *		 PARSE function call is issued.
 24441                                  ; *
 24442                                  ; * INPUT:	 NONE
 24443                                  ; *
 24444                                  ; * OUTPUT:	 COMBUF
 24445                                  ; *		 PARSER RETURN CODES
 24446                                  ; *
 24447                                  ; ****************************************************************
 24448                                  
 24449                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24450                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 24451                                  
 24452                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24453                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:368Ch
 24454                                  GETDAT:
 24455                                  	;mov	ax,(International SHL 8)
 24456 000034EA B80038                  	mov	ax,3800h
 24457                                  					; Determine what format the date
 24458 000034ED BA5C00                  	mov	dx,5Ch			;  should be entered in and
 24459 000034F0 CD21                    	int	21h			;  print a message describing it
 24460                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 24461                                  			; get current-country info
 24462                                  			; DS:DX -> buffer for returned info
 24463 000034F2 89D6                    	mov	si,dx
 24464 000034F4 AD                      	lodsw
 24465 000034F5 2E8B16[E893]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 24466 000034FA 48                      	dec	ax
 24467 000034FB 780C                    	js	short printformat
 24468 000034FD 2E8B16[EB93]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 24469 00003502 7405                    	jz	short printformat
 24470 00003504 2E8B16[EE93]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 24471                                  printformat:
 24472 00003509 89D0                    	mov	ax,dx			;AN000; get message number of format
 24473                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 24474 0000350B B6FF                    	mov	dh,-1 ; 0FFh
 24475 0000350D E81221                  	call	TSYSGETMSG		;AN000; get the address of the message
 24476 00003510 2E8936[C292]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 24477 00003515 BA[BD92]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 24478 00003518 E82220                  	call	std_printf
 24479                                  	;mov	word [cs:NewDat_Format],no_subst
 24480                                  					;AN000; reset subst block
 24481 0000351B 2EC706[C292]0000        	mov	word [cs:NewDat_Format],0
 24482                                  
 24483                                  	; 28/02/2023
 24484 00003522 BF[1598]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24485                                  ; 28/02/2023
 24486                                  gettim_p:	
 24487                                  	;mov	ah,Std_Con_String_Input
 24488 00003525 B40A                    	mov	ah,0Ah
 24489 00003527 BA[439C]                	mov	dx,COMBUF
 24490 0000352A B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24491 0000352D E875FF                  	call	SetInitFlag		;  prompting for date.
 24492 00003530 CD21                    	int	21h			; Get input line
 24493 00003532 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 24494 00003534 E86EFF                  	call	SetInitFlag		;  prompting for date.
 24495 00003537 E8E2F5                  	call	CRLF2
 24496                                  	; 28/02/2023
 24497                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24498                                  ;gettim_p: ; 28/02/2023
 24499 0000353A BE[459C]                	mov	si,COMBUF+2
 24500                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 24501 0000353D 31D2                    	xor	dx,dx			;AN000;
 24502                                  	;call	cmd_parse		;AC000; call parser
 24503                                  	;retn
 24504                                  	; 28/02/2023
 24505 0000353F E92A15                  	jmp	cmd_parse
 24506                                  
 24507                                  ; =============== S U B	R O U T	I N E =======================================
 24508                                  
 24509                                  ; MSDOS 6.0
 24510                                  
 24511                                  ; ****************************************************************
 24512                                  ; *
 24513                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 24514                                  ; *
 24515                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 24516                                  ; *		 INFORMATION and issues the "Enter new time"
 24517                                  ; *		 message. COMBUF is reset to get a time from the
 24518                                  ; *		 command line. The PARSE_TIME blocks are then
 24519                                  ; *		 reset and the PARSE function call is issued.
 24520                                  ; *
 24521                                  ; * INPUT:	 NONE
 24522                                  ; *
 24523                                  ; * OUTPUT:	 COMBUF
 24524                                  ; *		 PARSER RETURN CODES
 24525                                  ; *
 24526                                  ; ****************************************************************
 24527                                  
 24528                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24529                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 24530                                  
 24531                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24532                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:36E7h
 24533                                  GETTIM:
 24534 00003542 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 24535 00003544 BA[DC92]                	mov	dx,NewTim_Ptr
 24536 00003547 E8F31F                  	call	std_printf
 24537                                  
 24538                                  	; 28/02/2023
 24539 0000354A BF[2798]                	mov	di,PARSE_TIME
 24540 0000354D EBD6                    	jmp	short gettim_p
 24541                                  
 24542                                  ; 28/02/2023
 24543                                  ;	;mov	ah,Std_Con_String_Input
 24544                                  ;	mov	ah,0Ah
 24545                                  ;	mov	dx,COMBUF
 24546                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24547                                  ;	call	SetInitFlag		;  prompting for time.
 24548                                  ;	int	21h			; Get input line
 24549                                  ;	; 28/02/2023
 24550                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 24551                                  ;	call	SetInitFlag		;  prompting for time.
 24552                                  ;	call	CRLF2
 24553                                  ;	; 28/02/2023
 24554                                  ;	;mov	si,COMBUF+2
 24555                                  ;	; 28/02/2023
 24556                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 24557                                  ;	; 28/02/2023
 24558                                  ;	jmp	short gettim_p	
 24559                                  ;	; 28/02/2023
 24560                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 24561                                  ;	;xor	dx,dx			;AN000;
 24562                                  ;	;call	cmd_parse		;AC000; call parser
 24563                                  ;	;retn
 24564                                  
 24565                                  
 24566                                  ; =============== S U B	R O U T	I N E =======================================
 24567                                  
 24568                                  ; MSDOS 6.0
 24569                                  
 24570                                  ;Skip_white: Skips over the whitespace chars that could be present after
 24571                                  ;the '=' sign in the environment variable before the actual path.
 24572                                  ;
 24573                                  ;	ENTRY:	ds:si = arguments of the environment variable
 24574                                  ;
 24575                                  ;	EXIT:	ds:si = start of the path
 24576                                  ;
 24577                                  ;	REGISTERS AFFECTED: ax
 24578                                  
 24579                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24580                                  skip_white:
 24581 0000354F FC                      	cld
 24582                                  skw_lp:
 24583 00003550 AC                      	lodsb
 24584 00003551 3C20                    	cmp	al,' '			;blank char?
 24585 00003553 74FB                    	jz	short skw_lp		;yes, skip it
 24586 00003555 3C09                    	cmp	al,9			;tab char?
 24587 00003557 74F7                    	jz	short skw_lp		;yes, skip it
 24588 00003559 4E                      	dec	si			;point at first non-white
 24589 0000355A C3                      	retn
 24590                                  
 24591                                  ; =============== S U B	R O U T	I N E =======================================
 24592                                  
 24593                                  ; MSDOS 6.0
 24594                                  
 24595                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 24596                                  ;variable into the path buffers Pipe1 & Pipe2.
 24597                                  ;
 24598                                  ;	ENTRY:	ds:si = path to be copied
 24599                                  ;		es = RESGROUP
 24600                                  ;
 24601                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 24602                                  ;
 24603                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 24604                                  
 24605                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24606                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 24607                                  
 24608                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24609                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:371Eh
 24610                                  copy_pipe_path:
 24611 0000355B B9FFFF                  	mov	cx,0FFFFh ; 65535
 24612 0000355E 30C0                    	xor	al,al
 24613                                  
 24614 00003560 89F7                    	mov	di,si
 24615 00003562 06                      	push	es			;save es
 24616 00003563 1E                      	push	ds
 24617 00003564 07                      	pop	es			;es:di = path to be copied
 24618                                  	
 24619 00003565 FC                      	cld
 24620 00003566 57                      	push	di
 24621 00003567 F2AE                    	repnz	scasb			;look for the null char
 24622 00003569 5F                      	pop	di
 24623                                  
 24624 0000356A 07                      	pop	es			;es = RESGROUP again
 24625                                  
 24626 0000356B F7D1                    	not	cx			;length including the null
 24627                                  
 24628                                  	;;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 24629                                  	;;mov	di,3EAh ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24630                                  	;mov	di,offset DATARES:Pipe1
 24631 0000356D BF[D502]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 24632 00003570 57                      	push	di
 24633 00003571 51                      	push	cx			
 24634 00003572 F3A4                    	rep	movsb			;copy path into Pipe1
 24635 00003574 59                      	pop	cx
 24636 00003575 5F                      	pop	di
 24637                                  
 24638 00003576 1E                      	push	ds
 24639 00003577 06                      	push	es
 24640 00003578 1F                      	pop	ds			;ds:si = Pipe1
 24641 00003579 89FE                    	mov	si,di
 24642                                  	;;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 24643                                  	;;mov	di,439h ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24644                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 24645 0000357B BF[2403]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 24646 0000357E F3A4                    	rep	movsb			;copy path into Pipe2
 24647 00003580 1F                      	pop	ds
 24648 00003581 C3                      	retn
 24649                                  
 24650                                  ;============================================================================
 24651                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24652                                  ;============================================================================
 24653                                  ; 03/10/2018 - Retro DOS v3.0
 24654                                  
 24655                                  ;----------------------------------------------------------------------------
 24656                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24657                                  ; argv[argvcnt] array. The most important difference between this array and
 24658                                  ; the tradition UNIX format is the extra cparse information included with
 24659                                  ; each argument element.
 24660                                  ;---------------
 24661                                  ; ENTRY:
 24662                                  ;	BL	     special delimiter for cparse -- not implemented)
 24663                                  ;---------------
 24664                                  ; EXIT:
 24665                                  ;	CF	    set if error
 24666                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24667                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24668                                  ;	argvcnt     argument count
 24669                                  ;---------------
 24670                                  ; NOTE(S):
 24671                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24672                                  ;	*   Parseflags record contains cparse flags, as follows:
 24673                                  ;		sw_flag 	--	was this arg a switch?
 24674                                  ;		wildcard	--	whether or not it contained a * or ?
 24675                                  ;		path_sep	--	maybe it was a pathname
 24676                                  ;		unused		--	for future expansion
 24677                                  ;		special_delim	--	was there an initial special delimiter?
 24678                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24679                                  ;	*   Relationship between input, cparse output, and comtail can be
 24680                                  ;	    found in the following chart. Despite the claim of the cparse
 24681                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24682                                  ;	    tokens", such is not the case (see column two, row two).
 24683                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24684                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24685                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24686                                  ;	    documentation error.
 24687                                  ;	*   cparse also returns a switch code in BP for each switch it
 24688                                  ;	    recognizes on the command line.
 24689                                  ;	*   arglen for each token does NOT include the terminating null.
 24690                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24691                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24692                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24693                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24694                                  ;	    line parsing may result in slightly different behavior than
 24695                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24696                                  ;
 24697                                  ;	    Input		    Cparse		Command Line (80H)
 24698                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24699                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24700                                  ;	foo.bat 		foo.bat 		foo.bat
 24701                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24702                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24703                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24704                                  
 24705                                  ; =============== S U B	R O U T	I N E =======================================
 24706                                  
 24707                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24708                                  
 24709                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24710                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24711                                  
 24712                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24713                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24714                                  
 24715                                  PARSELINE:
 24716 00003582 50                      	push	ax			; most of these are clobbered
 24717 00003583 53                      	push	bx			; by cparse...
 24718 00003584 51                      	push	cx
 24719 00003585 52                      	push	dx
 24720 00003586 57                      	push	di
 24721 00003587 56                      	push	si
 24722 00003588 9C                      	pushf
 24723 00003589 C606[0AA1]00            	mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24724 0000358E C706[7CA8]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24725 00003594 31C0                    	xor	ax,ax
 24726                                  	;mov	cx,1348
 24727 00003596 B94405                  	mov	cx,ARG_UNIT.SIZE
 24728 00003599 BF[B6A2]                	mov	di,ARG
 24729 0000359C F3AA                    	rep	stosb
 24730                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24731 0000359E C706[FAA7][7AA5]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24732                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24733 000035A4 C706[78A5]0000          	mov	word [ARG+ARG_UNIT.argswinfo],0
 24734                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24735 000035AA C706[76A5]0000          	mov	word [ARG+ARG_UNIT.argvcnt],0
 24736 000035B0 BE[459C]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24737                                  
 24738                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24739                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24740                                  ; otherwise. This is done so that commands can get arg pointers into their
 24741                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24742                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24743                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24744                                  ; the command to be repeated or the transient part of command has been
 24745                                  ; reloaded.
 24746                                  
 24747 000035B3 1E                      	push	ds
 24748 000035B4 8E1E[E49D]              	mov	ds,[RESSEG]
 24749 000035B8 803E[6702]00            	cmp	byte [ForFlag],0
 24750 000035BD 1F                      	pop	ds
 24751 000035BE 7510                    	jnz	short PCONT
 24752                                  	;mov	di,ARG_ARGFORCOMBUF
 24753 000035C0 BF[7AA7]                	mov	di,ARG+ARG_UNIT.argforcombuf 
 24754 000035C3 30ED                    	xor	ch,ch
 24755 000035C5 8A0E[449C]              	mov	cl,[COMBUF+1]
 24756 000035C9 FEC1                    	inc	cl
 24757 000035CB F3A4                    	rep	movsb
 24758                                  	;mov	si,ARG_ARGFORCOMBUF
 24759 000035CD BE[7AA7]                	mov	si,ARG+ARG_UNIT.argforcombuf 
 24760                                  PCONT:
 24761 000035D0 BF[FCA7]                	mov	di,TPBUF	; destination is temporary token buffer	
 24762 000035D3 B320                    	mov	bl,' '		; no special delimiter, for now
 24763                                  PARSELOOP:
 24764 000035D5 8936[7EA8]              	mov	[COMPTR],si	; save ptr into original command buffer
 24765 000035D9 31ED                    	xor	bp,bp		; switch information put here by cparse
 24766 000035DB C606[98A2]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24767 000035E0 E846F5                  	call	scanoff		; skip leading blanks...
 24768 000035E3 E8C112                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24769 000035E6 730B                    	jnb	short MORE_PRSE
 24770 000035E8 09ED                    	or	bp,bp		; Check for trailing switch character
 24771 000035EA 7403                    	jz	short PARSEDONE
 24772 000035EC E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24773                                  				;   typical cause of this is that a
 24774                                  				;   switch char IMMEDIATELY preceeds
 24775                                  				;   the CR. We have an argument, but it
 24776                                  				;   is sort of an error.
 24777                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24778                                  	; 01/03/2023
 24779                                  PARSEDONE:
 24780 000035EF 9D                      	popf
 24781 000035F0 F8                      	clc
 24782 000035F1 EB0C                    	jmp	short PARSE_EXIT
 24783                                  
 24784                                  MORE_PRSE:
 24785 000035F3 C606[0AA1]02            	mov	byte [cpyflag],2
 24786                                  				; tell CPARSE that 1st token is done
 24787 000035F8 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24788 000035FB 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24789                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24790                                  	; 01/03/2023
 24791                                  ;PARSEDONE:
 24792                                  	;popf
 24793                                  	;clc
 24794                                  	;jmp	short PARSE_EXIT
 24795                                  
 24796                                  PARSE_ERROR:			; error entry (er, exit) point
 24797 000035FD 9D                      	popf
 24798 000035FE F9                      	stc
 24799                                  PARSE_EXIT:			; depend on not changing CF
 24800 000035FF 5E                      	pop	si
 24801 00003600 5F                      	pop	di
 24802 00003601 5A                      	pop	dx
 24803 00003602 59                      	pop	cx
 24804 00003603 5B                      	pop	bx
 24805 00003604 58                      	pop	ax
 24806 00003605 C3                      	retn
 24807                                  
 24808                                  ; =============== S U B	R O U T	I N E =======================================
 24809                                  
 24810                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24811                                  ;
 24812                                  ; ENTRY:
 24813                                  ;   BH			argflags
 24814                                  ;   CX			character count in argstring
 24815                                  ;   DI			pointer to argstring
 24816                                  ;   comptr		ptr to starting loc of current token in original command
 24817                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24818                                  ; EXIT:
 24819                                  ;   argbufptr		points to next free section of argbuffer
 24820                                  ;   arg.argbuf		contains null-terminated argument strings
 24821                                  ;   arg.argvcnt 	argument count
 24822                                  ;   arg.argv[]		array of flags and pointers
 24823                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24824                                  ;   CF			set if error
 24825                                  ;   AL			carry set:  error code; otherwise, zero
 24826                                  
 24827                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24828                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24829                                  newarg:
 24830 00003606 53                      	push	bx
 24831 00003607 51                      	push	cx
 24832 00003608 52                      	push	dx
 24833 00003609 57                      	push	di
 24834 0000360A 56                      	push	si
 24835 0000360B 9C                      	pushf
 24836 0000360C E86600                  	call	arg_switch		; if it's a switch, record switch info
 24837                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24838                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24839                                  
 24840                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24841 0000360F 833E[76A5]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24842 00003614 7D4F                    	jge	short to_many_args	; exceeded array limits
 24843 00003616 88FE                    	mov	dh,bh			
 24844                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24845 00003618 8B1E[76A5]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24846                                  	;inc	word [ARG_ARGVCNT]
 24847 0000361C FF06[76A5]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24848                                  	;mov	ax,ARG_ARGV
 24849 00003620 B8[B6A2]                	mov	ax,ARG+ARG_UNIT.argv
 24850 00003623 E88200                  	call	argv_calc		; convert offset to pointer
 24851                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24852                                  	;mov	word [bx+7],0
 24853 00003626 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24854                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24855                                  	;mov	[bx+5],cx
 24856 0000362B 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24857                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24858                                  	;mov	[bx+2],dh
 24859 0000362E 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24860 00003631 8B36[FAA7]              	mov	si,[ARGBUF_PTR]
 24861                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24862                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24863 00003635 8937                    	mov	[bx],si			
 24864 00003637 0336[5CA2]              	add	si,[STARTEL]		; save startel from new location
 24865 0000363B 29FE                    	sub	si,di			; form pointer into argbuf
 24866                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24867                                  	;mov	[bx+3],si
 24868 0000363D 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24869 00003640 8B36[7EA8]              	mov	si,[COMPTR]
 24870                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24871                                  	;mov	[bx+9],si
 24872 00003644 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24873 00003647 89FE                    	mov	si,di			; now save argstring in argbuffer
 24874 00003649 8B3E[FAA7]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24875 0000364D 01CF                    	add	di,cx			; sure we're not about to run off
 24876                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24877                                  	;cmp	di,ARG_ARGBUF+255
 24878 0000364F 81FF[79A6]              	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24879 00003653 7D15                    	jge	short buf_oflow		; the end of the buffer (plus null byte)	
 24880 00003655 29CF                    	sub	di,cx
 24881 00003657 FC                      	cld
 24882 00003658 F3A4                    	rep	movsb
 24883 0000365A B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24884 0000365C AA                      	stosb
 24885 0000365D 893E[FAA7]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24886                                  newarg_done:
 24887 00003661 9D                      	popf
 24888 00003662 F8                      	clc
 24889 00003663 EB0A                    	jmp	short newarg_exit
 24890                                  to_many_args:
 24891 00003665 B80100                  	mov	ax,1
 24892 00003668 EB03                    	jmp	short newarg_error
 24893                                  buf_oflow:
 24894 0000366A B80200                  	mov	ax,2
 24895                                  newarg_error:
 24896 0000366D 9D                      	popf
 24897 0000366E F9                      	stc
 24898                                  newarg_exit:
 24899 0000366F 5E                      	pop	si
 24900 00003670 5F                      	pop	di
 24901 00003671 5A                      	pop	dx
 24902 00003672 59                      	pop	cx
 24903 00003673 5B                      	pop	bx
 24904 00003674 C3                      	retn
 24905                                  
 24906                                  ; =============== S U B	R O U T	I N E =======================================
 24907                                  
 24908                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24909                                  ; event that it is, and we can recognize
 24910                                  ;
 24911                                  ; ENTRY:
 24912                                  ;   As in <newarg>.
 24913                                  ; EXIT:
 24914                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24915                                  ; NOTE(S):
 24916                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24917                                  ;	on the order of definition in the <switch_list> variable and the
 24918                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24919                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24920                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24921                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24922                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24923                                  ;   *	An ugly routine.
 24924                                  
 24925                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24926                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24927                                  arg_switch:
 24928 00003675 50                      	push	ax
 24929 00003676 53                      	push	bx
 24930 00003677 51                      	push	cx
 24931 00003678 57                      	push	di
 24932 00003679 9C                      	pushf
 24933 0000367A F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24934 0000367D 741C                    	jz	short arg_no_switch0
 24935 0000367F 833E[7CA8]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24936 00003684 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24937 00003686 8B1E[7CA8]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24938                                  	;mov	ax,offset TRANGROUP:arg.argv
 24939                                  	;mov	ax,ARG_ARGV
 24940 0000368A B8[B6A2]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24941 0000368D E81800                  	call	argv_calc
 24942                                  	;or	[BX].argsw_word,BP
 24943                                  	;or	[bx+7],bp
 24944 00003690 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24945                                  	;or	arg.argswinfo,BP
 24946                                  	;or	[ARG_ARGSWINFO],bp
 24947 00003693 092E[78A5]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24948                                  arg_yes_switch:
 24949 00003697 9D                      	popf
 24950 00003698 F9                      	stc
 24951 00003699 EB08                    	jmp	short arg_switch_exit
 24952                                  
 24953                                  arg_no_switch0:
 24954                                  	;mov	ax,[ARG_ARGVCNT]
 24955 0000369B A1[76A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24956 0000369E A3[7CA8]                	mov	[LASTARG],ax
 24957                                  arg_no_switch1:
 24958 000036A1 9D                      	popf
 24959 000036A2 F8                      	clc
 24960                                  arg_switch_exit:
 24961 000036A3 5F                      	pop	di
 24962 000036A4 59                      	pop	cx
 24963 000036A5 5B                      	pop	bx
 24964 000036A6 58                      	pop	ax
 24965 000036A7 C3                      	retn
 24966                                  
 24967                                  ; =============== S U B	R O U T	I N E =======================================
 24968                                  
 24969                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24970                                  ; the supplied array.  Method used for computing the address is:
 24971                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24972                                  ; ENTRY:
 24973                                  ;   AX	    --	    base of array
 24974                                  ;   BX	    --	    array index
 24975                                  ; EXIT:
 24976                                  ;   BX	    --	    byte offset
 24977                                  
 24978                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24979                                  argv_calc:
 24980 000036A8 50                      	push	ax		; Save base
 24981 000036A9 88D8                    	mov	al,bl		; al = array index
 24982                                  	;mov	bl,11
 24983 000036AB B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24984 000036AD F6E3                    	mul	bl		; ax = base offset
 24985 000036AF 5B                      	pop	bx		; Get base
 24986 000036B0 01D8                    	add	ax,bx		; Add in base offset
 24987 000036B2 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24988 000036B3 C3                      	retn
 24989                                  
 24990                                  ; ---------------------------------------------------------------------------
 24991                                  	
 24992                                  	;db 0Ah dup(0)
 24993                                  	;times 10 db 0
 24994                                  
 24995 000036B4 90<rep Ch>              align 16
 24996                                  
 24997                                  ;============================================================================
 24998                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24999                                  ;============================================================================
 25000                                  ; 03/10/2018 - Retro DOS v3.0
 25001                                  
 25002                                  ;----------------------------------------------------------------------------
 25003                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 25004                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 25005                                  ;    given a pathname, attempts to find a corresponding executable or batch
 25006                                  ;    file on disk. Directories specified in the user's search path will be
 25007                                  ;    searched for a matching file, if a match is not found in the current
 25008                                  ;    directory and if the pathname is actually only an MSDOS filename.
 25009                                  ;    <Path_Search> assumes that the parsed command name can be found in
 25010                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 25011                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 25012                                  ;    information could be placed in argv[0], or <Path_Search> could be
 25013                                  ;    (easily) modified to make no assumptions about where its input is found.
 25014                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 25015                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 25016                                  ;    allocated memory. This is handy for for-loop processing, and anything
 25017                                  ;    else that wants to save the whole shebang and then process other command
 25018                                  ;    lines.
 25019                                  ;
 25020                                  ; Alan L, OS/MSDOS				    August 15, 1983
 25021                                  ;
 25022                                  ; ENTRY:
 25023                                  ;   <Path_Search>:	    argv[0].
 25024                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 25025                                  ; EXIT:
 25026                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 25027                                  ;   <Save_Args>:	    success flag, segment address of new memory
 25028                                  ; NOTE(S):
 25029                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 25030                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 25031                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 25032                                  ;	does not function as specified; see <Parseline> for more details.
 25033                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 25034                                  ;	need to know about. This extra information is stored in a switch_flag
 25035                                  ;	word with each command-line argument; the switches themselves will not
 25036                                  ;	appear in the resulting arg structure.
 25037                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 25038                                  ;----------------------------------------------------------------------------
 25039                                  
 25040                                  ; =============== S U B	R O U T	I N E =======================================
 25041                                  
 25042                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 25043                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 25044                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 25045                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 25046                                  ; have a match, either in the current working directory if we were handed
 25047                                  ; a filename, or in the specified directory, given a pathname. If this call
 25048                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 25049                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 25050                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 25051                                  ; either the first invocation of search or on one of the succeeding calls
 25052                                  ; sets up the appropriate information for copying the successful pathname
 25053                                  ; prefix (if any) into the result buffer, followed by the successful filename
 25054                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 25055                                  ;
 25056                                  ; ENTRY:
 25057                                  ;   argv[0]		--	command name and associated information
 25058                                  ; EXIT:
 25059                                  ;   AX			--	non-zero indicates type of file found
 25060                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 25061                                  ; NOTE(S):
 25062                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 25063                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 25064                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 25065                                  ;	if search returns an .exe or .bat.
 25066                                  ;   5)	Clobbers dma address.
 25067                                  
 25068                                  PBUFLEN 	EQU	128		; length of EXECPATH
 25069                                  PATH_SEP_CHAR	EQU	';'
 25070                                  
 25071                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 25072                                  
 25073                                  	;special_delim equ 128
 25074                                  	;path_sep equ 4
 25075                                  	;wildcard equ 2
 25076                                  	;sw_flag  equ 1
 25077                                  
 25078                                  ;----------------------------------------------------------------------------
 25079                                  
 25080                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 25081                                  
 25082                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25083                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 25084                                  
 25085                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25086                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 387Bh
 25087                                  
 25088                                  path_search:
 25089 000036C0 53                      	push	bx
 25090 000036C1 51                      	push	cx
 25091 000036C2 52                      	push	dx		; could use a "stack 'em" instruction
 25092 000036C3 56                      	push	si
 25093 000036C4 57                      	push	di
 25094 000036C5 55                      	push	bp
 25095 000036C6 9C                      	pushf
 25096                                  
 25097                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 25098                                  	;test	byte [ARGV0_ARG_FLAGS],3
 25099 000036C7 F606[B8A2]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 25100 000036CC 7403                    	jz	short path_search_ok
 25101                                  path_failure_jmp:
 25102 000036CE E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 25103                                  
 25104                                  path_search_ok:
 25105 000036D1 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 25106 000036D4 BA[80A8]                	mov	dx,FBUF		; clobber old dma value with
 25107 000036D7 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 25108 000036DA CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 25109                                  			; DS:DX	-> disk	transfer buffer
 25110 000036DC 06                      	push	es
 25111 000036DD E878F1                  	call	find_path	; get a handle (ES:DI) on user path
 25112 000036E0 8C06[ABA8]              	mov	[pathinfo+0],es	; and squirrel it away
 25113 000036E4 893E[ADA8]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 25114 000036E8 893E[AFA8]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 25115 000036EC 07                      	pop	es
 25116                                  	
 25117 000036ED BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 25118 000036F0 BE[0C9D]                	mov	si,EXECPATH
 25119 000036F3 E88002                  	call	STRIP
 25120 000036F6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 25121                                  		
 25122 000036F8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 25123 000036FA C706[00A9][5F92]        	mov	word [search_error],baddrv_ptr
 25124 00003700 E89F01                  	call	PSEARCH		; must do at least one search
 25125 00003703 09C0                    	or	ax,ax		; find anything?
 25126 00003705 7469                    	jz	short path_noinit
 25127                                  				; failure ... search farther	
 25128 00003707 89C5                    	mov	bp,ax		; success... save filetype code	
 25129 00003709 BF[0C9D]                	mov	di,EXECPATH
 25130                                  	;mov	si,ds:arg.argv[0].argpointer
 25131                                  	;mov	si,[ARG_ARGV]
 25132 0000370C 8B36[B6A2]              	mov	si,[ARG+ARGV_ELE.argpointer]
 25133                                  	;mov	cx,ds:arg.argv[0].argstartel
 25134                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 25135 00003710 8B0E[B9A2]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 25136 00003714 29F1                    	sub	cx,si		; compute prefix bytes to copy
 25137                                  
 25138                                  ; We have the number of bytes in the prefix (up to the final component).
 25139                                  ; We need to form the complete pathname including leading drive and current
 25140                                  ; directory.
 25141                                  ;
 25142                                  ; Is there a drive letter present?
 25143                                  
 25144 00003716 B43A                    	mov	ah,':'
 25145 00003718 83F902                  	cmp	cx,2		; room for drive letter?
 25146 0000371B 7205                    	jb	short adddrive	; no, stick it in
 25147 0000371D 386401                  	cmp	[si+1],	ah	; colon present?
 25148 00003720 7408                    	je	short movedrive	; yes, just move it
 25149                                  adddrive:
 25150 00003722 A0[F89D]                	mov	al,[CURDRV]	; get current drive
 25151 00003725 0441                    	add	al,'A'		; convert to uppercase letter
 25152 00003727 AB                      	stosw			; store d:
 25153 00003728 EB05                    	jmp	short checkpath
 25154                                  
 25155                                  movedrive:
 25156 0000372A AD                      	lodsw			; move d:
 25157 0000372B AB                      	stosw
 25158 0000372C 83E902                  	sub	cx,2		; 2 bytes less to move
 25159                                  checkpath:
 25160 0000372F 0C20                    	or	al,20h
 25161 00003731 88C2                    	mov	dl,al		
 25162                                  	;sub	dl,60h
 25163 00003733 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 25164                                  
 25165                                  ; Stick in beginning path char
 25166                                  
 25167 00003736 A0[B1A8]                	mov	al,[psep_char]
 25168 00003739 AA                      	stosb
 25169                                  
 25170                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 25171                                  ; Otherwise, get current dir for DL.
 25172                                  
 25173 0000373A 83F901                  	cmp	cx,1		; is there room for path char?
 25174 0000373D 720A                    	jb	short addpath	; no, go add path
 25175 0000373F AC                      	lodsb
 25176 00003740 49                      	dec	cx
 25177 00003741 3A06[B1A8]              	cmp	al,[psep_char]	; is there a path separator?
 25178 00003745 741C                    	je	short movepath	; yes, go move remainder of path
 25179 00003747 41                      	inc	cx
 25180 00003748 4E                      	dec	si		; undo the lodsb
 25181                                  addpath:
 25182 00003749 56                      	push	si
 25183 0000374A 89FE                    	mov	si,di		; remainder of buffer
 25184 0000374C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25185 0000374F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25186                                  			; DL = drive (0=default,1=A,etc.)
 25187                                  			; DS:SI	points to 64-byte buffer area
 25188                                  
 25189                                  ; The previous current dir will succeed a previous find_first already worked.
 25190                                  ;
 25191                                  ; Find end of string.
 25192                                  
 25193 00003751 89F7                    	mov	di,si
 25194 00003753 5E                      	pop	si
 25195 00003754 A0[B1A8]                	mov	al,[psep_char]
 25196 00003757 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 25197 0000375A 7407                    	jz	short movepath	; yes, no need for path char
 25198                                  scanend:
 25199                                  	;cmp	byte [di],0	; end of string?
 25200                                  	;jz	short foundend
 25201                                  	;inc	di
 25202                                  	;jmp	short scanend
 25203                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 25204 0000375C 47                      	inc	di
 25205 0000375D 803D00                  	cmp	byte [di],0
 25206 00003760 75FA                    	jnz	short scanend
 25207                                  
 25208                                  ; Stick in a trailing path char.
 25209                                  
 25210                                  foundend:
 25211 00003762 AA                      	stosb
 25212                                  
 25213                                  ; Move remaining part of path. Skip leading path char if present.
 25214                                  
 25215                                  movepath:
 25216 00003763 3804                    	cmp	[si],al		; first char a path char?
 25217 00003765 7502                    	jne	short copypath
 25218                                  	; 26/04/2023
 25219 00003767 46                      	inc	si		; move past leading char
 25220 00003768 49                      	dec	cx		; drop from count
 25221                                  copypath:
 25222 00003769 E302                    	jcxz	_copydone	; no chars to move!	
 25223 0000376B F3A4                    	rep	movsb
 25224                                  _copydone:
 25225 0000376D E9A100                  	jmp	path_success
 25226                                  				; run off and form complete pathname
 25227                                  path_noinit:
 25228                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 25229                                  	;test	byte [ARGV0_ARG_FLAGS],4
 25230 00003770 F606[B8A2]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 25231 00003775 751B                    	jnz	short path_failure
 25232                                  				; complete pathname specified ==> fail
 25233                                  	;mov	bh,';'
 25234 00003777 B73B                    	mov	bh,PATH_SEP_CHAR
 25235                                  				; semicolon terminates pathstring
 25236                                  	;mov	dx,ds:arg.argv[0].argstartel
 25237                                  				; this is where the last element starts
 25238                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 25239 00003779 8B16[B9A2]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 25240                                  	;sub	dx,ds:arg.argv[0].argpointer
 25241                                  				; form pointer into EXECPATH,
 25242                                  	;sub	dx,[ARG_ARGV]
 25243 0000377D 2B16[B6A2]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 25244 00003781 81C2[0C9D]              	add	dx,EXECPATH	; skipping over drive spec, if any
 25245                                  path_loop:
 25246 00003785 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 25247 00003788 89C5                    	mov	bp,ax		; save filetype code
 25248 0000378A 9F                      	lahf			; save flags, just in case
 25249 0000378B 09ED                    	or	bp,bp		; did path_crunch find anything?		
 25250 0000378D 7508                    	jnz	short path_found 
 25251 0000378F 9E                      	sahf			; see? needed those flags, after all!
 25252 00003790 73F3                    	jnc	short path_loop	; is there anything left to the path?
 25253                                  path_failure:
 25254 00003792 31C0                    	xor	ax,ax
 25255 00003794 E98700                  	jmp	path_exit
 25256                                  
 25257                                  path_found:				; pathinfo[] points to winner
 25258 00003797 BF[0C9D]                	mov	di,EXECPATH
 25259                                  	;mov	cx,pathinfo[4] 
 25260 0000379A 8B0E[AFA8]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 25261                                  	;mov	si,pathinfo[2]
 25262 0000379E 8B36[ADA8]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 25263                                  
 25264                                  ;	BAS Nov 20/84
 25265                                  ;   Look at the pathname and expand . and .. if they are the first element
 25266                                  ;   in the pathname (after the drive letter)
 25267                                  
 25268 000037A2 06                      	push	es
 25269                                  	;push	pathinfo[0]
 25270 000037A3 FF36[ABA8]              	push	word [pathinfo+0]
 25271 000037A7 07                      	pop	es
 25272                                  ;SR;
 25273                                  ; Oops! Gets fooled if path= \;..
 25274                                  ; We should also check if a drive letter is really present
 25275                                  ;
 25276 000037A8 26807C022E              	cmp	byte [es:si+2],'.'
 25277                                  				; Look for Current dir at start of path
 25278 000037AD 7534                    	jne	short path_cpy
 25279                                  
 25280                                  	; 18/03/2023
 25281                                  	; MSDOS 6.0
 25282 000037AF 26807C013A              	cmp	byte [es:si+1],':'
 25283                                  				; does path have drive letter?
 25284 000037B4 752D                    	jne	short path_cpy	; no, copy the path string
 25285                                  
 25286 000037B6 51                      	push	cx		; Save pointer to end of string
 25287                                  	;mov	al,[es:si]
 25288                                  	;mov	[di],al		; Copy drive letter, :, and root char
 25289                                  	;mov	al,[es:si+1]	; to EXECPATH
 25290                                  	;mov	[di+1],al
 25291                                  	; 05/05/2023
 25292 000037B7 268B04                  	mov	ax,[es:si]
 25293 000037BA 8905                    	mov	[di],ax
 25294 000037BC A0[B1A8]                	mov	al,[psep_char]
 25295 000037BF 884502                  	mov	[di+2],	al
 25296 000037C2 56                      	push	si		; Save pointer to begining of string
 25297 000037C3 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25298 000037C6 80CA20                  	or	dl,20h
 25299                                  	;sub	dl,60h
 25300 000037C9 80EA60                  	sub	dl,'a'-1
 25301 000037CC 89FE                    	mov	si,di		; pointer to EXECPATH
 25302 000037CE 83C603                  	add	si,3		; Don't wipe out drive and root info
 25303 000037D1 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25304 000037D4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25305                                  			; DL = drive (0=default,1=A,etc.)
 25306                                  			; DS:SI	points to 64-byte buffer area
 25307 000037D6 E8E0F9                  	call	dstrlen		; Determine length of present info
 25308 000037D9 01CE                    	add	si,cx		; Don't copy over drive and root info
 25309 000037DB 4E                      	dec	si
 25310 000037DC 89F7                    	mov	di,si		; Point to end of target string
 25311 000037DE 5E                      	pop	si		; Restore pointer to begining of string
 25312 000037DF 83C603                  	add	si,3		; Point past drive letter, :, .
 25313 000037E2 59                      	pop	cx		; Restore pointer to end of string
 25314                                  path_cpy:
 25315 000037E3 07                      	pop	es
 25316 000037E4 29F1                    	sub	cx,si		; yields character count
 25317 000037E6 1E                      	push	ds		; time to switch segments
 25318 000037E7 FF36[ABA8]              	push	word [pathinfo+0]
 25319                                  				; string lives in this segment
 25320 000037EB 1F                      	pop	ds
 25321 000037EC FC                      	cld
 25322                                  
 25323                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25324                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25325                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25326                                  kloop:
 25327 000037ED AC                      	lodsb			;AN000;  3/3/KK
 25328 000037EE AA                      	stosb			;AN000;  3/3/KK
 25329 000037EF E818F1                  	call	testkanj	;AN000;  3/3/KK
 25330 000037F2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25331 000037F4 49                      	dec	cx		;AN000;  3/3/KK
 25332 000037F5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25333 000037F7 A4                      	movsb			;AN000;  3/3/KK
 25334 000037F8 49                      	dec	cx		;AN000;  3/3/KK
 25335 000037F9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25336 000037FC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25337                                  popdone:			;AN000;  3/3/KK
 25338 000037FE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25339 000037FF A0[B1A8]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25340 00003802 EB0C                    	jmp	short path_store
 25341                                  				;AN000;  3/3/KK
 25342                                  _notkanj1:
 25343                                  	; 26/04/2023
 25344 00003804 E2E7                    	loop	kloop
 25345 00003806 1F                      	pop	ds		; return to our segment
 25346 00003807 4F                      	dec	di		; overwrite terminator
 25347 00003808 A0[B1A8]                	mov	al,[psep_char]	; with a pathname separator
 25348 0000380B 3A45FF                  	cmp	al,[di-1]
 25349 0000380E 7401                    	je	short path_success
 25350                                  path_store:
 25351 00003810 AA                      	stosb
 25352                                  path_success:
 25353 00003811 BE[B3A8]                	mov	si,search_best_buf
 25354 00003814 31C9                    	xor	cx,cx
 25355                                  path_succ_loop:
 25356 00003816 AC                      	lodsb			; append winning filename to path
 25357 00003817 AA                      	stosb			; (including terminating null)	
 25358 00003818 08C0                    	or	al,al
 25359 0000381A 75FA                    	jnz	short path_succ_loop
 25360 0000381C 89E8                    	mov	ax,bp		; retrieve filetype code
 25361                                  path_exit:
 25362 0000381E 9D                      	popf
 25363 0000381F 5D                      	pop	bp
 25364 00003820 5F                      	pop	di
 25365 00003821 5E                      	pop	si		; chill out...
 25366 00003822 5A                      	pop	dx
 25367 00003823 59                      	pop	cx
 25368 00003824 5B                      	pop	bx
 25369 00003825 C3                      	retn
 25370                                  
 25371                                  ; =============== S U B	R O U T	I N E =======================================
 25372                                  
 25373                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25374                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25375                                  ;
 25376                                  ; ENTRY:
 25377                                  ; EXIT:
 25378                                  ; NOTE(S):
 25379                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25380                                  
 25381                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25382                                  STORE_PCHAR:
 25383 00003826 50                      	push	ax
 25384 00003827 B02F                    	mov	al,'/'		; is the pathname-element separator
 25385 00003829 E88BF3                  	call	pathchrcmp	; a regular slash?
 25386 0000382C 7402                    	jz	short STORE_SLASH
 25387                                  				; if yes, remember slash
 25388 0000382E B05C                    	mov	al,'\'
 25389                                  	; 18/03/2023
 25390                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25391                                  	;pop	ax
 25392                                  	;retn
 25393                                  STORE_SLASH:
 25394 00003830 A2[B1A8]                	mov	[psep_char],al
 25395 00003833 58                      	pop	ax
 25396 00003834 C3                      	retn
 25397                                  
 25398                                  ; =============== S U B	R O U T	I N E =======================================
 25399                                  
 25400                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25401                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25402                                  ; additional separator to use for breaking up the path-string. Null is the
 25403                                  ; default. Once the user-string has been formed, search is invoked to see
 25404                                  ; what's out there.
 25405                                  ;
 25406                                  ; ENTRY:
 25407                                  ;   BH			--	additional terminator character
 25408                                  ;   SI			--	pointer into pathstring to be dissected
 25409                                  ;   DX			--	pointer to stripped filename
 25410                                  ; EXIT:
 25411                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25412                                  ;   SI			--	moves along pathstring from call to call
 25413                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25414                                  ;   [tpbuf]		--	clobbered
 25415                                  ; NOTE(S):
 25416                                  ;   *	Implicit in this code is the ability to specify when to search
 25417                                  ;	the current directory (if at all) through the PATH defined by
 25418                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25419                                  ;	current directory before the bin and etc directories of drive c).
 25420                                  
 25421                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25422                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25423                                  
 25424                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25425                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:39FEh
 25426                                  	
 25427                                  path_crunch:
 25428 00003835 53                      	push	bx
 25429 00003836 51                      	push	cx
 25430 00003837 52                      	push	dx
 25431 00003838 57                      	push	di
 25432 00003839 56                      	push	si
 25433                                  	;pushf	; ** ; 18/03/2023
 25434 0000383A E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25435 0000383D BF[FCA7]                	mov	di,TPBUF	; destination of concatenated string
 25436 00003840 8B36[AFA8]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25437 00003844 8936[ADA8]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25438 00003848 1E                      	push	ds		; save old segment pointer
 25439 00003849 FF36[ABA8]              	push	word [pathinfo+0]
 25440                                  				; replace with pointer to userpath's
 25441 0000384D 1F                      	pop	ds		; segment
 25442                                  	; 26/04/2023
 25443 0000384E 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK	
 25444                                  path_cr_copy:
 25445 00003850 AC                      	lodsb			; get a pathname byte
 25446 00003851 08C0                    	or	al,al		; check for terminator(s)
 25447 00003853 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25448 00003855 38F8                    	cmp	al,bh
 25449 00003857 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25450                                  	;
 25451                                  	; 18/03/2023
 25452                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25453 00003859 E8AEF0                  	call	testkanj	;AN000; 3/3/KK
 25454 0000385C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25455 0000385E AA                      	stosb			;AN000; 3/3/KK
 25456 0000385F A4                      	movsb			;AN000; 3/3/KK
 25457 00003860 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK	
 25458 00003862 EBEC                    	jmp	short path_cr_copy
 25459                                  _notkanj2:
 25460 00003864 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25461                                  	;
 25462 00003866 AA                      	stosb
 25463 00003867 EBE7                    	jmp	short path_cr_copy
 25464                                  
 25465                                  path_seg:
 25466 00003869 1F                      	pop	ds		; restore old data segment
 25467 0000386A 8936[AFA8]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25468 0000386E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25469                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25470 00003870 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25471 00003872 81FF[FCA7]              	cmp	di,TPBUF	; was there really anything in pathstr?		
 25472 00003876 7421                    	je	short path_cr_leave
 25473                                  				; if nothing was copied, pathstr empty
 25474                                  path_cr_look:
 25475 00003878 A0[B1A8]                	mov	al,[psep_char]	; form complete pathname
 25476                                  	;
 25477                                  	; 18/03/2023
 25478                                  	; MSDOS 6.0
 25479 0000387B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25480 0000387D 7505                    	jnz	short path_cr_store
 25481                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25482                                  	;
 25483 0000387F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25484 00003882 7401                    	je	short path_cr_l1
 25485                                  path_cr_store:
 25486 00003884 AA                      	stosb
 25487                                  path_cr_l1:
 25488 00003885 89D6                    	mov	si,dx
 25489                                  path_cr_l2:
 25490 00003887 AC                      	lodsb			; tack the stripped filename onto
 25491 00003888 AA                      	stosb			; the end of the path, up to and
 25492 00003889 08C0                    	or	al,al		; including the terminating null
 25493 0000388B 75FA                    	jnz	short path_cr_l2
 25494 0000388D BA[FCA7]                	mov	dx,TPBUF	; and look for an appropriate file...	
 25495 00003890 C706[00A9][5B93]        	mov	word [search_error],BADPMES_PTR
 25496                                  	;invoke search
 25497 00003896 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25498                                  
 25499                                  	; 18/03/2023
 25500                                  ;path_cr_leave:
 25501                                  	;or	bl,bl		; did we finish off the pathstring?
 25502                                  	;jz	short path_cr_empty
 25503                                  	;			; null in BL means all gone...
 25504                                  	;popf	; **		; otherwise, plenty left
 25505                                  	;clc
 25506                                  	;jmp	short path_cr_exit
 25507                                  ;path_cr_empty:
 25508                                  	;popf	; **
 25509                                  	;stc
 25510                                  ;path_cr_exit:
 25511                                  
 25512                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25513                                  path_cr_leave:
 25514                                  	;popf ; ** ; 18/03/2023
 25515 00003899 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25516                                  	
 25517                                  path_cr_exit:
 25518 0000389C 5E                      	pop	si
 25519 0000389D 5F                      	pop	di
 25520 0000389E 5A                      	pop	dx
 25521 0000389F 59                      	pop	cx
 25522 000038A0 5B                      	pop	bx
 25523 000038A1 C3                      	retn
 25524                                  
 25525                                  ;============================================================================
 25526                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25527                                  ;============================================================================
 25528                                  ; 02/10/2018 - Retro DOS v3.0
 25529                                  
 25530                                  ;----------------------------------------------------------------------------
 25531                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25532                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25533                                  ; lowest priority). Where conflicts arise, the extension with
 25534                                  ; the highest priority is favored.
 25535                                  ; ENTRY:
 25536                                  ;   DX		--	pointer to null-terminated pathname
 25537                                  ;   fbuf	--	dma buffer for findfirst/next
 25538                                  ; EXIT:
 25539                                  ;   AX		--	8)  file found with .com extension
 25540                                  ;			4)  file found with .exe extension
 25541                                  ;			2)  file found with .bat extension
 25542                                  ;			0)  no such file to be found
 25543                                  ;   (if AX is non-zero:)
 25544                                  ;   [search_best]	identical to AX
 25545                                  ;   [search_best_buf]	null-terminated filename
 25546                                  ; NOTES:
 25547                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25548                                  ;---------------
 25549                                  ; CONSTANTS:
 25550                                  ;---------------
 25551                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25552                                  SEARCH_COM		EQU	8
 25553                                  SEARCH_EXE		EQU	4
 25554                                  SEARCH_BAT		EQU	2
 25555                                  FNAME_LEN		EQU	8
 25556                                  FNAME_MAX_LEN		EQU	13
 25557                                  DOT			EQU	'.'
 25558                                  WILDCHAR		EQU	'?'
 25559                                  
 25560                                  
 25561                                  ; =============== S U B	R O U T	I N E =======================================
 25562                                  
 25563                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25564                                  
 25565                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25566                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25567                                  
 25568                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25569                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3A73h
 25570                                  PSEARCH:
 25571 000038A2 51                      	push	cx
 25572 000038A3 52                      	push	dx
 25573 000038A4 57                      	push	di
 25574 000038A5 56                      	push	si
 25575                                  	;pushf	; ** ; 18/03/2023
 25576 000038A6 52                      	push	dx		; check drivespec (save pname ptr)
 25577 000038A7 89D7                    	mov	di,dx		; working copy of pathname
 25578 000038A9 BE[C0A8]                	mov	si,search_curdir_buf
 25579 000038AC 31D2                    	xor	dx,dx		; zero means current drive
 25580 000038AE 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25581 000038B2 7508                    	jne	short SEARCH_DIR_CHECK
 25582 000038B4 8A15                    	mov	dl,[di]		; get the drive byte
 25583 000038B6 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25584 000038B9 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25585                                  SEARCH_DIR_CHECK:
 25586 000038BC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25587 000038BF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25588                                  			; DL = drive (0=default,1=A,etc.)
 25589                                  			; DS:SI	points to 64-byte buffer area
 25590 000038C1 5A                      	pop	dx		; directory? If we can't we'll		
 25591 000038C2 724C                    	jc	short SEARCH_INVALID_DRIVE
 25592                                  				; assume it's a bad drive...
 25593 000038C4 B91300                  	mov	cx,search_attr	; 13h
 25594                                  				; filetypes to search for
 25595 000038C7 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25596 000038CA CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25597                                  			; CX = search attributes
 25598                                  			; DS:DX	-> ASCIZ filespec
 25599                                  			; (drive,path, and wildcards allowed)
 25600 000038CC 7249                    	jc	short SEARCH_NO_FILE
 25601 000038CE C606[B2A8]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25602 000038D3 C606[B3A8]00            	mov	byte [search_best_buf],ANULL
 25603                                  				; 0 ; nothing's been found, yet
 25604                                  SEARCH_LOOP:
 25605 000038D8 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25606 000038DB 3A06[B2A8]              	cmp	al,[search_best]
 25607                                  				; better than what we've found so far?
 25608 000038DF 7E13                    	jle	short SEARCH_NEXT
 25609                                  				; no, look for another	
 25610 000038E1 A2[B2A8]                	mov	[search_best],al
 25611                                  				; found something... save its code	
 25612                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25613                                  	;mov	si,FBUF_PNAME
 25614 000038E4 BE[9EA8]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25615 000038E7 BF[B3A8]                	mov	di,search_best_buf
 25616 000038EA B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25617 000038ED FC                      	cld
 25618 000038EE F3A4                    	rep	movsb		; save complete pathname representation
 25619 000038F0 3C08                    	cmp	al,SEARCH_COM	; 8
 25620                                  				; have we found the best of all?	
 25621 000038F2 740A                    	je	short SEARCH_DONE
 25622                                  SEARCH_NEXT:			; keep on looking
 25623 000038F4 B91300                  	mov	cx,search_attr ; 13h
 25624 000038F7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25625 000038FA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25626                                  			; [DTA]	= data block from
 25627                                  			; last AH = 4Eh/4Fh call
 25628 000038FC 73DA                    	jnc	short SEARCH_LOOP
 25629                                  SEARCH_DONE:			; it's all over with...
 25630 000038FE A0[B2A8]                	mov	al,[search_best]
 25631                                  				; pick best to return with
 25632                                  	; 18/03/2023
 25633                                  	; MSDOS 6.0
 25634 00003901 803E[6CA2]01            	cmp	byte [ext_entered],1
 25635                                  				;AN005; Did user request a specific ext?
 25636 00003906 7411                    	je	short SEARCH_EXIT
 25637                                  				;AN005; no - exit
 25638 00003908 A0[6CA2]                	mov	al,[ext_entered]
 25639                                  				;AN005; yes - get the real file type back
 25640 0000390B A2[B2A8]                	mov	[search_best],al
 25641                                  				;AN005; save the real file type
 25642                                  	;
 25643 0000390E EB09                    	jmp	short SEARCH_EXIT
 25644                                  
 25645                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25646 00003910 8B16[00A9]              	mov	dx,[search_error]
 25647                                  				; appropriate error message
 25648 00003914 E8261C                  	call	std_printf	; and pretend no file found
 25649                                  
 25650                                  SEARCH_NO_FILE:			; couldn't find a match
 25651                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25652                                  	; 18/03/2023
 25653 00003917 31C0                    	xor	ax,ax
 25654                                  SEARCH_EXIT:
 25655                                  	;popf	; ** ; 18/03/2023
 25656 00003919 5E                      	pop	si
 25657 0000391A 5F                      	pop	di
 25658 0000391B 5A                      	pop	dx
 25659 0000391C 59                      	pop	cx
 25660 0000391D C3                      	retn
 25661                                  
 25662                                  ; =============== S U B	R O U T	I N E =======================================
 25663                                  
 25664                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25665                                  ;
 25666                                  ; ENTRY:
 25667                                  ;   fbuf    --	dma buffer containing filename
 25668                                  ; EXIT:
 25669                                  ;   AX	    --	file code, as given in search header
 25670                                  ; NOTE(S):
 25671                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25672                                  
 25673                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25674                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25675                                  SEARCH_FTYPE:
 25676 0000391E 57                      	push	di
 25677 0000391F 56                      	push	si
 25678                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25679                                  	; 18/02/2023
 25680 00003920 31C0                    	xor	ax,ax ; ax = 0		
 25681                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25682                                  	;mov	di,FBUF_PNAME
 25683 00003922 BF[9EA8]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25684 00003925 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25685 00003928 FC                      	cld
 25686 00003929 F2AE                    	repnz	scasb		; search for the terminating null
 25687 0000392B 7535                    	jnz	short FTYPE_EXIT
 25688                                  				; weird... no null byte at end
 25689 0000392D 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25690                                  
 25691                                  	; Compare .COM
 25692                                  
 25693 00003930 BE[8697]                	mov	si,comext ; ".COM"
 25694 00003933 89F8                    	mov	ax,di
 25695 00003935 A7                      	cmpsw
 25696 00003936 7508                    	jnz	short FTYPE_EXE
 25697 00003938 A7                      	cmpsw
 25698 00003939 7505                    	jnz	short FTYPE_EXE
 25699                                  	;mov	ax,8
 25700 0000393B B80800                  	mov	ax,SEARCH_COM	; success!
 25701 0000393E EB22                    	jmp	short FTYPE_EXIT
 25702                                  
 25703                                  	; Compare .EXE
 25704                                  FTYPE_EXE:			; still looking... now for '.exe'
 25705 00003940 89C7                    	mov	di,ax
 25706 00003942 BE[8A97]                	mov	si,exeext ; ".EXE"
 25707 00003945 A7                      	cmpsw
 25708 00003946 7508                    	jnz	short FTYPE_BAT
 25709 00003948 A7                      	cmpsw
 25710 00003949 7505                    	jnz	short FTYPE_BAT
 25711                                  	;mov	ax,4
 25712 0000394B B80400                  	mov	ax,SEARCH_EXE	; success!
 25713 0000394E EB12                    	jmp	short FTYPE_EXIT
 25714                                  
 25715                                  	; Compare .BAT
 25716                                  FTYPE_BAT:			; still looking... now for '.bat'
 25717 00003950 89C7                    	mov	di,ax
 25718 00003952 BE[8E97]                	mov	si,batext ; ".BAT"
 25719 00003955 A7                      	cmpsw
 25720 00003956 7508                    	jnz	short FTYPE_FAIL
 25721 00003958 A7                      	cmpsw
 25722 00003959 7505                    	jnz	short FTYPE_FAIL
 25723                                  	;mov	ax,2
 25724 0000395B B80200                  	mov	ax,SEARCH_BAT	; success!
 25725 0000395E EB02                    	jmp	short FTYPE_EXIT
 25726                                  
 25727                                  FTYPE_FAIL:			; file doesn't match what we need
 25728                                  	;mov	ax,ANULL ; 0
 25729                                  	; 18/03/2023
 25730 00003960 29C0                    	sub	ax,ax  ; ax = 0
 25731                                  FTYPE_EXIT:
 25732                                  	; 18/03/2023
 25733                                  	; MSDOS 6.0
 25734 00003962 803E[6CA2]01            	cmp	byte [ext_entered],1
 25735                                  				;AN005; was an extension entered?
 25736 00003967 740A                    	jz	short FTYPE_DONE
 25737                                  				;AN005; no - exit
 25738                                  	;cmp	ax,ANULL	;AN005; was any match found
 25739 00003969 21C0                    	and	ax,ax  ; ax = 0 ?
 25740 0000396B 7406                    	jz	short FTYPE_DONE
 25741                                  				;AN005; no - exit
 25742 0000396D A2[6CA2]                	mov	[ext_entered],al
 25743                                  				;AN005; save the match type found
 25744 00003970 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25745                                  FTYPE_DONE:
 25746 00003973 5E                      	pop	si
 25747 00003974 5F                      	pop	di
 25748 00003975 C3                      	retn
 25749                                  
 25750                                  ; =============== S U B	R O U T	I N E =======================================
 25751                                  
 25752                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25753                                  ; replacing any extension with wildcards.
 25754                                  ;
 25755                                  ; ENTRY:
 25756                                  ;	BX	--	maximum length of destination buffer
 25757                                  ;	DS:SI	--	address of destination buffer
 25758                                  ;	argv[0] --	command name to be stripped
 25759                                  ; EXIT:
 25760                                  ;	CF	--	set if failure, clear if successful
 25761                                  ; NOTE(S):
 25762                                  
 25763                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25764                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25765                                  STRIP:
 25766 00003976 50                      	push	ax
 25767 00003977 53                      	push	bx
 25768 00003978 51                      	push	cx
 25769 00003979 52                      	push	dx
 25770 0000397A 57                      	push	di
 25771 0000397B 56                      	push	si
 25772                                  	;pushf	; ** ; 18/03/2023
 25773                                  		
 25774                                  	; 05/05/2023
 25775                                  	; MSDOS 6.0
 25776 0000397C C606[6CA2]01            	mov	byte [ext_entered],1
 25777                                  				;AN005; assume no extension on file name
 25778                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25779                                  	;mov	dx,[ARG_ARGV]
 25780                                  	;mov	dx,ds:arg.argv[0].argpointer
 25781                                  				; save pointer to beginning of argstring
 25782                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25783 00003981 8B16[B6A2]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25784                                  	;mov	di,ds:arg.argv[0].argstartel
 25785                                  				; beginning of last pathname element
 25786                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25787 00003985 8B3E[B9A2]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25788 00003989 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25789 0000398C 743D                    	je	short STRIP_ERROR
 25790 0000398E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25791                                  	;add	cx,ds:arg.argv[0].arglen
 25792                                  	;add	cx,[ARGV0_ARGLEN]
 25793 00003990 030E[BBA2]              	add	cx,[ARG+ARGV_ELE.arglen]
 25794 00003994 29F9                    	sub	cx,di		; and then find length of last element
 25795 00003996 41                      	inc	cx		; include null as well
 25796 00003997 B02E                    	mov	al,'.'
 25797                                  	;mov	al,DOT		; let's find the filetype extension
 25798 00003999 FC                      	cld
 25799 0000399A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25800                                  
 25801                                  	; 18/03/2023
 25802                                  	; MSDOS 6.0
 25803 0000399C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25804 0000399E B000                    	mov	al,0 ; 18/03/2023
 25805                                  	;mov	byte [ext_entered],0
 25806 000039A0 A2[6CA2]                	mov	[ext_entered],al
 25807                                  				;AN005; we found an extension
 25808                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25809                                  	;mov	al,0
 25810 000039A3 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25811                                  PROCESS_EXT:
 25812                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25813 000039A5 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25814 000039A7 29D1                    	sub	cx,dx		; number of bytes to be copied
 25815 000039A9 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25816 000039AC 39D9                    	cmp	cx,bx
 25817 000039AE 7F1B                    	jg	short STRIP_ERROR
 25818                                  				; if not, we must have a bad pathname
 25819 000039B0 89F7                    	mov	di,si		; destination buffer
 25820 000039B2 89D6                    	mov	si,dx		; source is beginning of pathname
 25821 000039B4 FC                      	cld
 25822 000039B5 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25823                                  
 25824                                  	; 18/03/2023
 25825                                  	; MSDOS 6.0
 25826 000039B7 803E[6CA2]01            	cmp	byte [ext_entered],1
 25827                                  				;AN005; if an extension was entered
 25828 000039BC 750A                    	jne	short SKIP_WILDS ; cf = 1 ; 12/06/2023
 25829                                  				;AN005;    don't set up wildcard ext.
 25830                                  
 25831                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25832 000039BE 4F                      	dec	di		; overwrite null or dot
 25833 000039BF AA                      	stosb			; with a dot
 25834 000039C0 B03F                    	mov	al,'?'
 25835                                  	;mov	al,WILDCHAR	; now add wildcards
 25836 000039C2 AA                      	stosb
 25837 000039C3 AA                      	stosb
 25838 000039C4 AA                      	stosb
 25839 000039C5 B000                    	mov	al,0
 25840                                  	;mov	al,ANULL	; and a terminating null	
 25841 000039C7 AA                      	stosb
 25842                                  SKIP_WILDS:
 25843                                  	;popf	; ** ; 18/03/2023
 25844 000039C8 F8                      	clc
 25845 000039C9 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25846                                  
 25847                                  STRIP_ERROR:
 25848                                  	;popf	; ** ; 18/03/2023
 25849 000039CB F9                      	stc
 25850                                  STRIP_EXIT:
 25851 000039CC 5E                      	pop	si
 25852 000039CD 5F                      	pop	di
 25853 000039CE 5A                      	pop	dx
 25854 000039CF 59                      	pop	cx
 25855 000039D0 5B                      	pop	bx
 25856 000039D1 58                      	pop	ax
 25857 000039D2 C3                      	retn
 25858                                  
 25859                                  ; =============== S U B	R O U T	I N E =======================================
 25860                                  
 25861                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25862                                  ;
 25863                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25864                                  ; beginning of this area. The caller indicates how much extra space is
 25865                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25866                                  ; an offset into that area, indicating where the caller may preserve its own
 25867                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25868                                  ; ENTRY:
 25869                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25870                                  ; EXIT:
 25871                                  ;   AX	    --	segment of new area.
 25872                                  ;   CF	    --	set if unable to save a copy.
 25873                                  ; NOTE(S):
 25874                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25875                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25876                                  ;	paragraphs.
 25877                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25878                                  ;	as the caller of Save_Args requests.
 25879                                  ;   3)	AX is undefined if CF indicates an error.
 25880                                  
 25881                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25882                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25883                                  SAVE_ARGS:
 25884 000039D3 53                      	push	bx
 25885 000039D4 51                      	push	cx
 25886 000039D5 52                      	push	dx
 25887 000039D6 57                      	push	di
 25888 000039D7 56                      	push	si
 25889 000039D8 55                      	push	bp
 25890                                  	; 01/05/2023
 25891                                  	; 26/04/2023
 25892                                  	;pushf ; **
 25893                                  	;add	bx,1363		; space for arg structure, round up
 25894 000039D9 81C35305                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25895 000039DD B104                    	mov	cl,4		; to paragraph size and convert
 25896 000039DF D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25897 000039E1 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25898 000039E4 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25899                                  			; BX = number of 16-byte paragraphs desired
 25900 000039E6 7242                    	jc	short SAVE_ERROR ; ***
 25901 000039E8 89C5                    	mov	bp,ax		; save segment id
 25902 000039EA 06                      	push	es		; save TRANGROUP address
 25903 000039EB 8EC0                    	mov	es,ax		; switch to new memory segment
 25904                                  	; assume es:nothing
 25905                                  	;mov	cx,1348		; get back structure size
 25906 000039ED B94405                  	mov	cx,ARG_UNIT.SIZE
 25907 000039F0 31FF                    	xor	di,di		; destination is new memory area
 25908                                  	;mov	si,ARG_ARGV
 25909 000039F2 BE[B6A2]                	mov	si,ARG		; source is arg structure
 25910 000039F5 F3A4                    	rep	movsb		; move that sucker!
 25911                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25912                                  	;mov	cx,[ARG_ARGVCNT]
 25913 000039F7 8B0E[76A5]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25914 000039FB 31C0                    	xor	ax,ax		; base address for argv_calc
 25915                                  
 25916                                  ;	Bugbug:	What did they mean by this?
 25917                                  ;	Note that the replacement line produces exactly the same code.
 25918                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25919                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25920                                  
 25921                                  	;mov	si,ARG_ARGV
 25922 000039FD BE[B6A2]                	mov	si,ARG	
 25923                                  SAVE_PTR_LOOP:
 25924 00003A00 49                      	dec	cx		; exhausted all args?
 25925 00003A01 7C24                    	jl	short SAVE_DONE
 25926 00003A03 89CB                    	mov	bx,cx		; get arg index and
 25927 00003A05 E8A0FC                  	call	argv_calc	; convert to a pointer
 25928                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25929                                  	;mov	dx,[ARG_ARGV+bx]
 25930 00003A08 8B97[B6A2]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25931 00003A0C 29F2                    	sub	dx,si		; adjust argpointer
 25932                                  	;mov	es:argv[BX].argpointer,dx
 25933                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25934 00003A0E 268917                  	mov	[es:bx],dx
 25935                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25936                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25937 00003A11 8B97[B9A2]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25938 00003A15 29F2                    	sub	dx,si		; and adjust argstartel
 25939                                  	;mov	es:argv[bx].argstartel,dx
 25940                                  	;mov	[es:bx+3],dx
 25941 00003A17 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25942                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25943                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25944 00003A1B 8B97[BFA2]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25945 00003A1F 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25946                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25947                                  	;mov	[es:bx+9],dx
 25948 00003A21 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25949 00003A25 EBD9                    	jmp	short SAVE_PTR_LOOP
 25950                                  SAVE_DONE:
 25951 00003A27 07                      	pop	es		; back we go to TRANGROUP
 25952                                  	; assume es:nothing
 25953 00003A28 89E8                    	mov	ax,bp		; restore segment id
 25954                                  	; 26/04/2023
 25955                                  	; cf = 0 ; *
 25956                                  	;jmp	short SAVE_OK
 25957                                  
 25958                                  	; 26/04/2023
 25959                                  ;SAVE_ERROR:
 25960                                  ;	; 26/04/2023
 25961                                  ;	;popf ; **
 25962                                  ;	stc
 25963                                  ;	jmp	short SAVE_EXIT
 25964                                  
 25965                                  SAVE_OK:
 25966                                  	; 26/04/2023
 25967                                  	;popf ; **
 25968                                  	; 26/04/2023
 25969                                  	; cf = 0 ; *
 25970                                  	;clc
 25971                                  SAVE_EXIT:
 25972                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25973 00003A2A 5D                      	pop	bp
 25974 00003A2B 5E                      	pop	si
 25975 00003A2C 5F                      	pop	di
 25976 00003A2D 5A                      	pop	dx
 25977 00003A2E 59                      	pop	cx
 25978 00003A2F 5B                      	pop	bx
 25979                                  answ_no:	; 26/04/2023
 25980 00003A30 C3                      	retn
 25981                                  
 25982                                  ;============================================================================
 25983                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25984                                  ;============================================================================
 25985                                  ; 02/10/2018 - Retro DOS v3.0
 25986                                  
 25987                                  ; Title	COMMAND Language midifiable Code Transient
 25988                                  
 25989                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25990                                  
 25991                                  ; =============== S U B	R O U T	I N E =======================================
 25992                                  
 25993                                  ; ****************************************************************
 25994                                  ; *
 25995                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25996                                  ; *
 25997                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25998                                  ; *		 user for Y/N if necessary. If an error occurs,
 25999                                  ; *		 set up an error message and go to CERROR.
 26000                                  ; *
 26001                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 26002                                  ; *		 Current directory set to entered directory
 26003                                  ; *
 26004                                  ; * OUTPUT:	 none
 26005                                  ; *
 26006                                  ; ****************************************************************
 26007                                  ;
 26008                                  ; ARE YOU SURE prompt when deleting *.*
 26009                                  
 26010                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26011                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26012                                  notest2:
 26013 00003A31 B90B00                  	mov	cx,11
 26014 00003A34 BE5D00                  	mov	si,FCB+1 ; 5Dh
 26015                                  ambspec:
 26016 00003A37 AC                      	lodsb
 26017 00003A38 3C3F                    	cmp	al,'?'
 26018 00003A3A 7502                    	jne	short allfil
 26019 00003A3C E2F9                    	loop	ambspec
 26020                                  allfil:
 26021                                  	; 19/03/2023
 26022                                  	;cmp	cx,0
 26023 00003A3E 09C9                    	or	cx,cx
 26024 00003A40 752E                    	jnz	short noprmpt
 26025                                  askagn:	
 26026 00003A42 BA[E292]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 26027 00003A45 E8F51A                  	call	std_printf
 26028 00003A48 BE8000                  	mov	si,80h
 26029 00003A4B 89F2                    	mov	dx,si
 26030 00003A4D C7047800                	mov	word [si],120	; zero length
 26031                                  	;mov	ax,0C0Ah
 26032 00003A51 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 26033 00003A54 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 26034                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 26035 00003A56 AD                      	lodsw
 26036 00003A57 08E4                    	or	ah,ah
 26037 00003A59 74E7                    	jz	short askagn
 26038 00003A5B E8CBF0                  	call	scanoff
 26039                                  	; 19/03/2023
 26040                                  	; MSDOS 6.0
 26041 00003A5E E80C02                  	call	char_in_xlat	; Convert to upper case
 26042                                  	;retc			; return if function not supported
 26043                                  	; 19/03/2023
 26044                                  	;jnc	short check_yn
 26045                                  ;answ_no:
 26046                                  	;retn
 26047 00003A61 72CD                    	jc	short answ_no
 26048                                  
 26049                                  	; 19/03/2023
 26050                                  	; AL = 0 if it was (country depended) NO character
 26051                                  	; AL = 1 if it was (country depenced) YES character
 26052                                  
 26053                                  	; MSDOS 3.3
 26054                                  	;call	UPCONV
 26055                                  
 26056                                  	; 19/03/2023	
 26057                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26058                                  	;cmp	al,[CAPITAL_N]
 26059                                  	;jne	short CHECK_Y
 26060                                  	;retn
 26061                                  ;CHECK_Y:
 26062                                  	;cmp	al,[CAPITAL_Y]
 26063                                  	;pushf
 26064                                  	;call	CRLF2
 26065                                  	;popf
 26066                                  	;jne	short ASKAGN
 26067                                  
 26068                                  check_yn:
 26069                                  	; 19/03/2023
 26070                                  	;cmp	al,0	; NO character
 26071 00003A63 08C0                    	or	al,al
 26072 00003A65 74C9                    	jz	short answ_no
 26073                                  	;cmp	al,1	 ;YES character
 26074 00003A67 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 26075 00003A69 9C                      	pushf
 26076 00003A6A E8AFF0                  	call	CRLF2
 26077 00003A6D 9D                      	popf
 26078 00003A6E 75D2                    	jnz	short askagn
 26079                                  noprmpt:
 26080 00003A70 B413                    	mov	ah,FCB_Delete ; 13h
 26081 00003A72 BA5C00                  	mov	dx,FCB ; 5Ch
 26082 00003A75 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 26083                                  			; DS:DX	-> FCB with filename field filled with
 26084                                  			; template for deletion ('?' wildcard allowed,but not '*')
 26085                                  			; Return: AL = 00h file	found,FFh file	not found
 26086 00003A77 FEC0                    	inc	al
 26087 00003A79 7403                    	jz	short eraerr
 26088                                  	; 26/04/2023
 26089                                  	;call	RestUDir
 26090                                  ;answ_no:
 26091                                  	;retn
 26092 00003A7B E95BEF                  	jmp	RestUDir ; 26/04/2023
 26093                                  
 26094                                  	; 19/03/2023
 26095                                  	; MSDOS 6.0
 26096                                  eraerr:
 26097                                  	;invoke	set_ext_error_msg
 26098                                  				;AN022; set up the extended error
 26099 00003A7E E8BDE7                  	call	Set_Ext_Error_Msg
 26100 00003A81 52                      	push	dx		;AN022; save message
 26101                                  	;invoke	RESTUDIR
 26102 00003A82 E854EF                  	call	RestUDir
 26103 00003A85 5A                      	pop	dx		;AN022; restore message
 26104                                  	
 26105 00003A86 833E[0392]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 26106                                  				;AN022; convert no more files to
 26107 00003A8B 7506                    	jne	short cerrorj2	;AN022;  file not found
 26108 00003A8D C706[0392]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 26109                                  				;AN000; get message number in control block
 26110                                  cerrorj2:
 26111 00003A93 E907F4                  	jmp	cerror
 26112                                  	
 26113                                  	; 19/03/2023
 26114                                  	; MSDOS 3.3
 26115                                  ;ERAERR:	
 26116                                  	;mov	ah,Set_DMA ; 1Ah
 26117                                  	;mov	dx,FCB ; 5Ch
 26118                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 26119                                  	;			; DS:DX	-> disk	transfer buffer
 26120                                  	;mov	ah,Dir_Search_First ; 11h
 26121                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 26122                                  	;			; DS:DX	-> FCB
 26123                                  	;push	ax
 26124                                  	;call	RESTUDIR
 26125                                  	;pop	ax
 26126                                  	;mov	dx,FNOTFOUNDPTR
 26127                                  	;inc	al
 26128                                  	;jz	short CERRORJ
 26129                                  	;mov	dx,ACCDENPTR
 26130                                  	;jmp	CERROR
 26131                                  
 26132                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26133                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 26134                                  
 26135                                  ; ****************************************************************
 26136                                  ; *
 26137                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 26138                                  ; *
 26139                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 26140                                  ; *		 user for Y/N where necessary. If an error occurs
 26141                                  ; *		 set up and error message and transfer control
 26142                                  ; *		 to CERROR.
 26143                                  ; *
 26144                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 26145                                  ; *		 Current directory set to entered directory
 26146                                  ; *
 26147                                  ; * OUTPUT:	 none
 26148                                  ; *
 26149                                  ; ****************************************************************
 26150                                  
 26151                                  	; 19/03/2023
 26152                                  slashp_erase:				;AN000; entry point
 26153                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 26154 00003A96 E8FEE8                  	call	build_dir_string
 26155                                  
 26156 00003A99 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 26157                                  	;mov	dx,offset trangroup:destdir
 26158 00003A9B BA[DC9F]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26159 00003A9E CD21                    	int	21h			;AN000;
 26160                                  
 26161                                  	;mov	ah,11h
 26162 00003AA0 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 26163 00003AA2 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 26164 00003AA5 CD21                    	int	21h			;AN000;
 26165 00003AA7 FEC0                    	inc	al			;AN000; did an error occur
 26166                                  	;jz	short eraerr		;AN022; go to error exit
 26167                                  	; 26/04/2023
 26168 00003AA9 7502                    	jnz	short delete_prompt_loop
 26169                                  
 26170                                  	; 26/04/2023
 26171                                  stop_del:
 26172 00003AAB EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 26173                                  
 26174                                  delete_prompt_loop:			;AN000;
 26175                                  	;mov	si,offset trangroup:destdir+1
 26176 00003AAD BE[DD9F]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 26177                                  	;mov	di,offset trangroup:dest
 26178 00003AB0 BF[AC9F]                	mov	di,DEST			;AN000; set up dest as target
 26179 00003AB3 A0[E99D]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 26180 00003AB6 AA                      	stosb				;AN000;   of DEST
 26181                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 26182 00003AB7 E88EF0                  	call	FCB_TO_ASCZ
 26183                                  
 26184                                  slashp_askagn:				;AN000;
 26185 00003ABA E85FF0                  	call	CRLF2			;AN000; print out carriage return, line feed
 26186                                  	;mov	dx,offset trangroup:bwdbuf
 26187 00003ABD BA[1FA0]                	mov	dx,BWDBUF		;AN000; print out current directory string
 26188 00003AC0 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 26189 00003AC2 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 26190                                  					;AN000; see if only D:\,0
 26191 00003AC6 7504                    	jnz	short not_del_root	;AN000; no continue
 26192 00003AC8 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 26193                                  					;AN000; yes, get rid of \ ;
 26194                                  not_del_root:				;AN000;
 26195 00003ACC 8916[06A1]              	mov	[string_ptr_2],dx 	;AN000;
 26196                                  	;mov	dx,offset trangroup:string_buf_ptr
 26197 00003AD0 BA[CA93]                	mov	dx,string_buf_ptr	;AN000;
 26198                                  	;invoke	std_printf		;AN000;
 26199 00003AD3 E8671A                  	call	std_printf
 26200                                  	;mov	dx,offset trangroup:dest
 26201 00003AD6 BA[AC9F]                	mov	dx,DEST			;AN000; print out file name string
 26202 00003AD9 8916[06A1]              	mov	[string_ptr_2],dx 	;AN000;
 26203                                  	;mov	dx,offset trangroup:string_buf_ptr
 26204 00003ADD BA[CA93]                	mov	dx,string_buf_ptr	;AN000;
 26205                                  	;invoke	std_printf		;AN000;
 26206 00003AE0 E85A1A                  	call	std_printf
 26207                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 26208 00003AE3 BA[DF92]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 26209                                  	;invoke	std_printf		;AN000;
 26210 00003AE6 E8541A                  	call	std_printf
 26211                                  
 26212                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 26213                                  ;;M029	mov	dx,si			;AN000;
 26214                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 26215                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 26216                                  ;;M029	int	21h			;AN000; get input from the user
 26217                                  ;;M029	lodsw				;AN000;
 26218                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 26219                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 26220                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 26221                                  
 26222                                  ;	Get a single character input.
 26223                                  
 26224                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 26225                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 26226 00003AE9 B8010C                  	mov	ax,0C01h
 26227 00003AEC CD21                    	int	21h			;M029
 26228                                  
 26229 00003AEE E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 26230                                  	;retc				;AN000; return if function not supported
 26231                                  	; 19/03/2023
 26232 00003AF1 7301                    	jnc	short slashp_check_yn
 26233                                  slashp_ans_no:
 26234 00003AF3 C3                      	retn
 26235                                  
 26236                                  slashp_check_yn:
 26237                                  	; 19/03/2023
 26238                                  	; AL = 0 if it was (country depended) NO character
 26239                                  	; AL = 1 if it was (country depenced) YES character
 26240                                  
 26241                                  	;cmp	al,capital_n		;AN000; was it no?
 26242                                  	;cmp	al,0
 26243 00003AF4 20C0                    	and	al,al ; 0
 26244 00003AF6 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 26245                                  	;cmp	al,capital_y		;AN000; was it yes?
 26246                                  	;cmp	al,1
 26247 00003AF8 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 26248                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 26249                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 26250                                  	; 19/03/2023
 26251 00003AFA 75BE                    	jnz	short slashp_askagn
 26252                                  
 26253                                  delete_this_file:			;AN000;
 26254 00003AFC B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 26255                                  	;mov	dx,offset trangroup:destdir
 26256 00003AFE BA[DC9F]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26257 00003B01 CD21                    	int	21h			;AN000;
 26258 00003B03 FEC0                    	inc	al			;AN000; did an error occur?
 26259 00003B05 7511                    	jnz	short next_del_file	;AN000; no - get next file
 26260                                  ;
 26261                                  ;M041; Begin changes
 26262                                  ; We got an error deleting the file. If this is access denied, we can go on
 26263                                  ;to the next file after printing an error message.
 26264                                  ;
 26265                                  	;invoke	Get_ext_error_number	;see what error we got
 26266 00003B07 E844E7                  	call	get_ext_error_number
 26267 00003B0A 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 26268                                  					;is it access denied?
 26269 00003B0D 759C                    	jne	short stop_del		;no, some other error
 26270                                  	;invoke	CrLf2			;print a CR-LF
 26271 00003B0F E80AF0                  	call	CRLF2
 26272                                  	;invoke set_ext_error_msg	;error message
 26273 00003B12 E829E7                  	call	Set_Ext_Error_Msg
 26274                                  	;invoke	std_eprintf		;"Access denied"
 26275 00003B15 E81D1A                  	call	std_eprintf
 26276                                  	; 26/04/2023
 26277                                  	;jmp	short next_del_file	;try next file
 26278                                  	; 26/04/2023
 26279                                  ;stop_del:
 26280                                  ;;
 26281                                  ;;M041; End changes
 26282                                  ;;
 26283                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 26284                                  
 26285                                  next_del_file:				;AN000;
 26286                                  ;
 26287                                  ; M050 - begin
 26288                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 26289                                  ;       with /protect+ and /light+ makes it intercept all
 26290                                  ;       deletes. This hook does not save and restore the DTA correctly.
 26291                                  ;       They save the DWORD in a WORD by mistake! They save both the
 26292                                  ;       segment and the offset in the SAME variable (WORD)!!!
 26293                                  ;
 26294 00003B18 B41A                    	mov	ah,Set_DMA ; 1Ah
 26295                                  	;mov	dx,offset trangroup:destdir
 26296 00003B1A BA[DC9F]                	mov	dx,DESTDIR
 26297 00003B1D CD21                    	int	21h
 26298                                  ;
 26299                                  ; M050 - end
 26300                                  
 26301 00003B1F B412                    	mov	ah,Dir_Search_Next ; 12h
 26302                                  					;AN000; search for another file
 26303 00003B21 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26304 00003B24 CD21                    	int	21h			;AN000;
 26305 00003B26 FEC0                    	inc	al			;AN000; was a file found?
 26306                                  	;jz	short slash_p_exit	;AN000; no - exit
 26307                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26308                                  	; 26/04/2023
 26309 00003B28 7583                    	jnz	short delete_prompt_loop
 26310                                  
 26311                                  slash_p_exit:
 26312                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26313 00003B2A E821E7                  	call	get_ext_error_number
 26314 00003B2D 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26315 00003B30 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26316 00003B32 E95CE4                  	jmp	extend_setup		;AN022; go issue error message
 26317                                  
 26318                                  good_erase_exit:
 26319                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26320 00003B35 E8A1EE                  	call	RestUDir
 26321                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26322                                  	;retn				;AN000; exit
 26323                                  	; 19/03/2023
 26324 00003B38 E9E1EF                  	jmp	CRLF2
 26325                                  
 26326                                  ; =============== S U B	R O U T	I N E =======================================
 26327                                  
 26328                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26329                                  
 26330                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26331                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26332                                  _ECHO:
 26333 00003B3B E89900                  	call	ON_OFF
 26334 00003B3E 7212                    	jb	short DOEMES
 26335 00003B40 8E1E[E49D]              	mov	ds,[RESSEG]
 26336 00003B44 7506                    	jnz	short ECH_OFF
 26337 00003B46 800E[5902]01            	or	byte [EchoFlag],1
 26338 00003B4B C3                      	retn
 26339                                  
 26340                                  ECH_OFF:
 26341 00003B4C 8026[5902]FE            	and	byte [EchoFlag],0FEh
 26342 00003B51 C3                      	retn
 26343                                  
 26344                                  	; 19/03/2023
 26345                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26346                                  ;CERRORJ:
 26347                                  	;jmp	cerror
 26348                                  
 26349                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26350                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26351                                  
 26352                                  DOEMES:
 26353                                  	; 19/03/2023
 26354                                  	; MSDOS 6.0
 26355                                  	;cmp	cl,0		;AC000; was anything on the line?
 26356 00003B52 20C9                    	and	cl,cl
 26357 00003B54 7409                    	jz	short PECHO	; just display current state.
 26358 00003B56 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26359 00003B59 E819F0                  	call	CRPRINT
 26360 00003B5C E9BDEF                  	jmp	CRLF2
 26361                                  
 26362                                  	; 19/03/2023
 26363                                  	; MSDOS 3.3
 26364                                  	;call	MOVE_TO_FIRST_ARG
 26365                                  	;jz	short PECHO
 26366                                  	;mov	dx,82h
 26367                                  	;call	CRPRINT
 26368                                  	;jmp	CRLF2
 26369                                  
 26370                                  PECHO:
 26371                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26372 00003B5F 8E1E[E49D]              	mov	ds,[RESSEG]
 26373 00003B63 8A1E[5902]              	mov	bl,[EchoFlag]
 26374 00003B67 0E                      	push	cs
 26375 00003B68 1F                      	pop	ds
 26376 00003B69 80E301                  	and	bl,1
 26377 00003B6C BA[8693]                	mov	dx,EchoMes_Ptr
 26378 00003B6F EB24                    	jmp	short PYN
 26379                                  
 26380                                  ; ---------------------------------------------------------------------------
 26381                                  
 26382                                  	; 19/03/2023
 26383                                  	; MSDOS 3.3
 26384                                  CERRORJ:
 26385 00003B71 E929F3                  	jmp	cerror
 26386                                  
 26387                                  ; =============== S U B	R O U T	I N E =======================================
 26388                                  
 26389                                  	; 19/03/2023
 26390                                  	; MSDOS 3.3
 26391                                  ;MOVE_TO_FIRST_ARG:
 26392                                  	;mov	si,81h
 26393                                  	;call	SCANOFF
 26394                                  	;cmp	al,0Dh
 26395                                  	;retn
 26396                                  
 26397                                  ; =============== S U B	R O U T	I N E =======================================
 26398                                  
 26399                                  CNTRLC:
 26400 00003B74 E86000                  	call	ON_OFF
 26401 00003B77 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26402 00003B7A 720C                    	jc	short PCNTRLC
 26403 00003B7C 7505                    	jnz	short CNTRLC_OFF
 26404 00003B7E B201                    	mov	dl,1
 26405 00003B80 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26406                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26407                                  			; DL = 00h for OFF or 01h for ON
 26408 00003B82 C3                      	retn
 26409                                  
 26410                                  ; ---------------------------------------------------------------------------
 26411                                  
 26412                                  CNTRLC_OFF:
 26413 00003B83 30D2                    	xor	dl,dl
 26414 00003B85 CD21                    	int	21h		; Turn off ^C check
 26415 00003B87 C3                      	retn
 26416                                  
 26417                                  ; ---------------------------------------------------------------------------
 26418                                  
 26419                                  PCNTRLC:
 26420                                  	; 19/03/2023
 26421                                  	; MSDOS 6.0
 26422                                  	;cmp	cl,0		;AC000; rest of line blank?
 26423 00003B88 08C9                    	or	cl,cl
 26424 00003B8A 75E5                    	jnz	short CERRORJ 	; no, oops!
 26425                                  
 26426                                  	; 19/03/2023
 26427                                  	; MSDOS 3.3
 26428                                  	;call	MOVE_TO_FIRST_ARG
 26429                                  	;jnz	short CERRORJ
 26430                                  ;pccont:
 26431                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26432 00003B8C 30C0                    	xor	al,al
 26433 00003B8E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26434 00003B90 88D3                    	mov	bl,dl
 26435 00003B92 BA[6A93]                	mov	dx,CtrlcMes_Ptr
 26436                                  
 26437                                  ; ---------------------------------------------------------------------------
 26438                                  
 26439                                  PYN:	; write "ON" or "OFF" state 
 26440                                  
 26441                                  	; 26/04/2023
 26442                                  	; 19/03/2023
 26443                                  	; MSDOS 3.3
 26444                                  	;call	STD_PRINTF
 26445                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26446                                  	;or	bl,bl
 26447                                  	;jnz	short PRINTVAL
 26448                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26449                                  	
 26450                                  	; 26/04/2023
 26451                                  	; 19/03/2023
 26452                                  	; MSDOS 6.0
 26453 00003B95 BE[9793]                	mov	si,ONMES_PTR
 26454 00003B98 08DB                    	or	bl,bl
 26455 00003B9A 7503                    	jnz	short PRINTVAL
 26456 00003B9C BE[9493]                	mov	si,OFFMES_PTR
 26457                                  PRINTVAL:
 26458                                  	; 19/03/2023
 26459                                  	; MSDOS 3.3
 26460                                  	;jmp	STD_PRINTF
 26461                                  
 26462                                  	; 19/03/2023
 26463                                  	; MSDOS 6.0
 26464 00003B9F 52                      	push	dx		;AN000; save offset of message block
 26465 00003BA0 89D3                    	mov	bx,dx		;AN000; save offset value
 26466 00003BA2 AD                      	lodsw			;AN000; get message number of on or off
 26467 00003BA3 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26468                                  				;AN000; this is a utility message
 26469 00003BA5 E87A1A                  	call	TSYSGETMSG	;AN000; get the address of the message
 26470                                  	;add	bx,5
 26471 00003BA8 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26472                                  	
 26473 00003BAB 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26474 00003BAD 5A                      	pop	dx		;AN000; get message back
 26475 00003BAE E88C19                  	call	std_printf	;AC000; go print message
 26476 00003BB1 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26477 00003BB5 C3                      	retn			;AN000; exit
 26478                                  
 26479                                  ; =============== S U B	R O U T	I N E =======================================
 26480                                  
 26481                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26482                                  VERIFY:
 26483 00003BB6 E81E00                  	call	ON_OFF
 26484 00003BB9 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26485 00003BBC 720A                    	jc	short PVERIFY
 26486 00003BBE 7503                    	jnz	short VER_OFF
 26487 00003BC0 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26488                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26489 00003BC2 C3                      	retn
 26490                                  
 26491                                  ; ---------------------------------------------------------------------------
 26492                                  
 26493                                  VER_OFF:
 26494 00003BC3 FEC8                    	dec	al
 26495 00003BC5 CD21                    	int	21h		; Turn off verify after write
 26496 00003BC7 C3                      	retn
 26497                                  
 26498                                  ; ---------------------------------------------------------------------------
 26499                                  
 26500                                  PVERIFY:
 26501                                  	; 19/03/2023
 26502                                  	; MSDOS 6.0
 26503                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26504 00003BC8 20C9                    	and	cl,cl
 26505 00003BCA 75A5                    	jnz	short CERRORJ 	; nope...
 26506                                  
 26507                                  	 ;19/03/2023
 26508                                  	; MSDOS 3.3
 26509                                  	;call	MOVE_TO_FIRST_ARG
 26510                                  	;jnz	short CERRORJ
 26511                                  
 26512 00003BCC B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26513 00003BCE CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26514                                  				; Return: AL = 00h if flag OFF
 26515                                  				; AL = 01h if flag ON
 26516 00003BD0 88C3                    	mov	bl,al
 26517 00003BD2 BA[7893]                	mov	dx,VeriMes_Ptr
 26518 00003BD5 EBBE                    	jmp	short PYN
 26519                                  
 26520                                  ; =============== S U B	R O U T	I N E =======================================
 26521                                  
 26522                                  ; ****************************************************************
 26523                                  ; *
 26524                                  ; * ROUTINE:	 ON_OFF
 26525                                  ; *
 26526                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26527                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26528                                  ; *		 routines.
 26529                                  ; *
 26530                                  ; * INPUT:	 command line at offset 81H
 26531                                  ; *		 PARSE_BREAK control block
 26532                                  ; *
 26533                                  ; * OUTPUT:	 If carry is clear
 26534                                  ; *		    If ON is found
 26535                                  ; *		       Zero flag set
 26536                                  ; *		    If OFF is found
 26537                                  ; *		       Zero flag clear
 26538                                  ; *		 If carry set
 26539                                  ; *		    If nothing on command line
 26540                                  ; *		       CL set to zero
 26541                                  ; *		    If error
 26542                                  ; *		       CL contains error value from parse
 26543                                  ; *
 26544                                  ; ****************************************************************
 26545                                  
 26546                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26547                                  ON_OFF:
 26548 00003BD7 BE8100                  	mov	si,81h
 26549                                  
 26550                                  	; 19/03/2023
 26551                                  	; MSDOS 3.3
 26552                                  	;call	SCANOFF		; scan off leading blanks & equal
 26553                                  	;cmp	al,0Dh		; are we at end of line?
 26554                                  	;je	short BAD_ONF	; yes, return error
 26555                                  	;lodsw
 26556                                  	;or	ax,2020h	; convert to lowercase
 26557                                  	;cmp	ax,6E6Fh ;'on'
 26558                                  	;je	short ON_CHECK
 26559                                  	;cmp	ax,666Fh ;'of'
 26560                                  	;jne	short BAD_ONF
 26561                                  	;lodsb
 26562                                  	;or	al,20h		; convert to lowercase		
 26563                                  	;cmp	al,66h	 ; 'f'
 26564                                  	;jne	short BAD_ONF	
 26565                                  	;or	al,66h ; or al,'f'
 26566                                  	;jmp	short OFF_CHECK
 26567                                  ;ON_CHECK:
 26568                                  	;xor	al,al
 26569                                  ;OFF_CHECK:
 26570                                  	;lahf
 26571                                  	;mov	bx,ax
 26572                                  	;call	SCANOFF		; scan off leading blanks & equal
 26573                                  	;cmp	al,0Dh		; are we at end of line?	
 26574                                  	;jne	short BAD_ONF	; no, return error
 26575                                  	;mov	ax,bx
 26576                                  	;sahf
 26577                                  	;clc
 26578                                  	;retn
 26579                                  
 26580                                  	; 19/03/2023
 26581                                  	; MSDOS 6.0
 26582                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26583 00003BDA AC                      	lodsb			;AN032; get a char
 26584                                  	;cmp	al,blank	;AN032; if whitespace
 26585 00003BDB 3C20                    	cmp	al,20h
 26586 00003BDD 74FB                    	je	short scan_on_off
 26587                                  				;AN032;    keep scanning
 26588 00003BDF 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26589                                  	;cmp	al,09h
 26590 00003BE1 74F7                    	je	short scan_on_off
 26591                                  				;AN032;    keep scanning
 26592                                  	;cmp	al,equal_chr	;AN032; if equal char
 26593 00003BE3 3C3D                    	cmp	al,'=' ; 3Dh
 26594 00003BE5 7401                    	je	short parse_on_off
 26595                                  				;AN032;    start parsing
 26596 00003BE7 4E                      	dec	si		;AN032; if none of above - back up
 26597                                  
 26598                                  parse_on_off:			;AN032;    and start parsing
 26599 00003BE8 BF[D397]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26600 00003BEB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26601 00003BED 31D2                    	xor	dx,dx		;AN000;
 26602 00003BEF E87A0E                  	call	cmd_parse	;AC000; call parser
 26603                                  	;cmp	ax,-1 ; 0FFFFh
 26604 00003BF2 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26605 00003BF5 742E                    	je	short BADONF	;AC000; yes, return error
 26606                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26607                                  	;cmp	ax,0
 26608 00003BF7 21C0                    	and	ax,ax ; ax = 0 ?
 26609 00003BF9 7404                    	jz	short on_off_there
 26610                                  				;AN000; no - continue
 26611 00003BFB 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26612 00003BFD EB26                    	jmp	short BADONF	;AN000; return error
 26613                                  
 26614                                  on_off_there:
 26615 00003BFF 803E[58AA]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26616                                  				;AN014; was a valid positional present?
 26617 00003C04 7505                    	jnz	short good_on_off
 26618                                  				;AN014; yes - continue
 26619 00003C06 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26620                                  	;mov	cx,10 ; 0Ah
 26621 00003C09 EB1A                    	jmp	short BADONF	;AN014; return error
 26622                                  
 26623                                  good_on_off:			;AN014;
 26624 00003C0B 31C0                    	xor	ax,ax		;AC000; set up return code for
 26625 00003C0D 0A06[58AA]              	or	al,[PARSE1_CODE]
 26626                                  				;AC000;    ON or OFF in AX
 26627 00003C11 9C                      	pushf			;AN000; save flags
 26628 00003C12 BF[D397]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26629 00003C15 31D2                    	xor	dx,dx		;AN000;
 26630 00003C17 E8520E                  	call	cmd_parse	;AN000; call parser
 26631 00003C1A 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26632                                  	;cmp	ax,-1 ; 0FFFFh
 26633 00003C1D 7503                    	jne	short BADONF_flags
 26634                                  				;AN000; NO, return error
 26635 00003C1F 9D                      	popf			;AN000; restore flags
 26636 00003C20 F8                      	clc			;AC000; no error
 26637                                  	;jmp	short on_off_end
 26638                                  				;AN000; return to caller
 26639                                  	; 26/04/2023
 26640 00003C21 C3                      	retn
 26641                                  
 26642                                  BADONF_flags:
 26643 00003C22 89C1                    	mov	cx,ax
 26644 00003C24 9D                      	popf
 26645                                  
 26646                                  ; ---------------------------------------------------------------------------
 26647                                  
 26648                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26649                                  ; and return the error
 26650                                  
 26651                                  BADONF:
 26652 00003C25 BA[4793]                	mov	dx,bad_on_off_ptr
 26653 00003C28 F9                      	stc
 26654                                  on_off_end:
 26655 00003C29 C3                      	retn
 26656                                  
 26657                                  ;============================================================================
 26658                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26659                                  ;============================================================================
 26660                                  ; 02/10/2018 - Retro DOS v3.0
 26661                                  
 26662                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26663                                  
 26664                                  ; =============== S U B	R O U T	I N E =======================================
 26665                                  
 26666                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26667                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26668                                  	
 26669                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26670                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3E20h
 26671                                  PRINT_DATE:
 26672                                  	; 20/03/2023
 26673                                  	; MSDOS 3.3
 26674                                  	;push	es
 26675                                  	;push	di
 26676                                  	;push	cs
 26677                                  	;pop	es
 26678                                  	;mov	di,ARG_BUF
 26679                                  	;mov	ah,Get_Date ; 2Ah
 26680                                  	;int	21h	; DOS -	GET CURRENT DATE
 26681                                  	;		; Return: DL = day,DH = month,	CX = year
 26682                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26683                                  	;cbw
 26684                                  	;call	GETDATE
 26685                                  	;call	P_DATE
 26686                                  	;xor	al,al
 26687                                  	;stosb
 26688                                  	;mov	dx,ARG_BUF_PTR
 26689                                  	;call	STD_PRINTF
 26690                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26691                                  	;pop	es ; !!??!! 
 26692                                  	;pop	di
 26693                                  	;retn
 26694                                  
 26695                                  	; 20/03/2023
 26696                                  	; MSDOS 6.0
 26697 00003C2A 06                      	push	es
 26698 00003C2B 57                      	push	di
 26699 00003C2C 0E                      	push	cs
 26700 00003C2D 07                      	pop	es
 26701 00003C2E E81300                  	call	GetDate 		; get date
 26702 00003C31 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26703 00003C33 890E[0194]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26704 00003C37 8916[0394]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26705 00003C3B BA[F193]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26706 00003C3E E8FC18                  	call	std_printf
 26707                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26708                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26709 00003C41 5F                      	pop	di			;AC000; restore di,es
 26710 00003C42 07                      	pop	es			;AC000;
 26711 00003C43 C3                      	retn
 26712                                  
 26713                                  ; ---------------------------------------------------------------------------
 26714                                  
 26715                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26716                                  
 26717                                  ;GETDATE:
 26718                                  	; 21/03/2023
 26719                                  	; MSDOS 3.3
 26720                                  	;mov	si,ax
 26721                                  	;shl	si,1
 26722                                  	;add	si,ax
 26723                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26724                                  	;mov	bx,cx
 26725                                  	;mov	cx,3
 26726                                  	;rep	movsb
 26727                                  	;mov	al,' '
 26728                                  	;stosb
 26729                                  	;retn
 26730                                  
 26731                                  	; 21/03/2023
 26732                                  	; MSDOS 6.0
 26733                                  
 26734                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26735                                  ; for output. Date will be returned in CX,DX.
 26736                                  
 26737                                  GetDate:
 26738 00003C44 BF[82A0]                	mov	di,Arg_Buf		;AC000; target for day of week
 26739 00003C47 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26740 00003C49 CD21                    	int	21h			;AC000; Get date in CX:DX
 26741 00003C4B 98                      	cbw				;AC000;
 26742 00003C4C 51                      	push	cx			;AN000; save date returned in
 26743 00003C4D 52                      	push	dx			;AN000;  CX:DX
 26744 00003C4E 89C6                    	mov	si,ax
 26745 00003C50 D1E6                    	shl	si,1
 26746 00003C52 01C6                    	add	si,ax			; SI=AX*3
 26747 00003C54 89F1                    	mov	cx,si			;AN000; save si
 26748 00003C56 A1[BA92]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26749 00003C59 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26750 00003C5B 57                      	push	di			;AN000; save argument buffer
 26751 00003C5C E8C319                  	call	TSYSGETMSG		;AN000; get the address of the message
 26752 00003C5F 5F                      	pop	di			;AN000; retrieve argument buffer
 26753 00003C60 01CE                    	add	si,cx			;AC000; get day of week
 26754 00003C62 B90300                  	mov	cx,3
 26755 00003C65 F3A4                      	rep	movsb
 26756 00003C67 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26757 00003C69 AA                      	stosb
 26758 00003C6A 5A                      	pop	dx			;AN000; get back date
 26759 00003C6B 59                      	pop	cx			;AN000;
 26760 00003C6C C3                      	retn
 26761                                  
 26762                                  ; =============== S U B	R O U T	I N E =======================================
 26763                                  
 26764                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26765                                  
 26766                                  	; MSDOS 6.0
 26767                                  
 26768                                  ; This routine determines whether the character in AL is a
 26769                                  ; Yes or No character. On return, if AL=0, the character is
 26770                                  ; No, if AL=1, the character is Yes.
 26771                                  
 26772                                  ;	assume	ds:trangroup
 26773                                  
 26774                                  char_in_xlat:	; proc	near
 26775                                  	; 21/03/2023
 26776 00003C6D 88C2                    	mov	dl,al			;AC000; get character into DX
 26777 00003C6F 30F6                    	xor	dh,dh			;AC000;
 26778                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26779 00003C71 B82365                  	mov	ax,6523h
 26780 00003C74 CD21                    	int	21h			;AC000;
 26781 00003C76 C3                      	retn
 26782                                  
 26783                                  ;char_in_xlat	endp
 26784                                  
 26785                                  ;============================================================================
 26786                                  ; TENV.ASM, MSDOS 6.0, 1991
 26787                                  ;============================================================================
 26788                                  ; 02/10/2018 - Retro DOS v3.0
 26789                                  
 26790                                  ;	Environment utilities and misc. routines
 26791                                  
 26792                                  ; MSDOS 6.0
 26793                                  ; ****************************************************************
 26794                                  ; *
 26795                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26796                                  ; *
 26797                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26798                                  ; *		 the character in AL from the file upper case table
 26799                                  ; *		 in DOS if character if above  ascii 128, else
 26800                                  ; *		 subtracts 20H if between "a" and "z".
 26801                                  ; *
 26802                                  ; * INPUT:	 AL	      char to be upper cased
 26803                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26804                                  ; *
 26805                                  ; * OUTPUT:	 AL	      upper cased character
 26806                                  ; *
 26807                                  ; ****************************************************************
 26808                                  ;
 26809                                  ;assume	ds:trangroup				;AN000;
 26810                                  ;
 26811                                  ;upconv	proc	near				;AN000;
 26812                                  ;
 26813                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26814                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26815                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26816                                  ;	push	ds				;AN000;
 26817                                  ;	push	bx				;AN000;
 26818                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26819                                  ;assume	ds:resgroup				;AN000;
 26820                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26821                                  ;	add	bx,2				;AN000;  skip over first word
 26822                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26823                                  ;	pop	bx				;AN000;
 26824                                  ;	pop	ds				;AN000;
 26825                                  ;assume	ds:trangroup				;AN000;
 26826                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26827                                  ;
 26828                                  ;oth_fucase:					;AN000;
 26829                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26830                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26831                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26832                                  ;	ja	upconv_end			;AC000;
 26833                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26834                                  ;
 26835                                  ;upconv_end:					;AN000;
 26836                                  ;	ret
 26837                                  ;
 26838                                  ;upconv	endp					;AN000;
 26839                                  
 26840                                  ;============================================================================
 26841                                  ; COPY.ASM, MSDOS 6.0, 1991
 26842                                  ;============================================================================
 26843                                  ; 01/10/2018 - Retro DOS v3.0
 26844                                  
 26845                                  ;	title	COMMAND COPY routines.
 26846                                  
 26847                                  ;/*
 26848                                  ; *                      Microsoft Confidential
 26849                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26850                                  ; *                      All Rights Reserved.
 26851                                  ; */
 26852                                  
 26853                                  ;***	COPY.ASM
 26854                                  
 26855                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26856                                  
 26857                                  
 26858                                  ;***	MODIFICATION HISTORY
 26859                                  
 26860                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26861                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26862                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26863                                  ;	     to tokens which begin with path characters so that PARSELINE
 26864                                  ;	     will work correctly.
 26865                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26866                                  ;	     individual tokens. That distinction is no longer needed for
 26867                                  ;	     FOR loop processing.
 26868                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26869                                  ;	     1 when Cparse is called from COPY.
 26870                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26871                                  ;	     mod. It now is conditional on flag like previous mod.
 26872                                  ;11/21/83 NP  Added printf
 26873                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26874                                  ;	     be added to a token.
 26875                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26876                                  ;	     NOTE: DestHand is the destination handle. There are two
 26877                                  ;	     special values: -1 meaning destination was never opened and
 26878                                  ;	     0 which means that the destination has been openned and
 26879                                  ;	     closed.
 26880                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26881                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26882                                  ;	     lost on large and multiple file (wildcard) copies.
 26883                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26884                                  ;	     destination are not equal.
 26885                                  ;
 26886                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26887                                  ;	     first source file AND we run out of disk space before
 26888                                  ;	     completing the concatenation, restore the first source
 26889                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26890                                  ;
 26891                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26892                                  ;		instead of compatibility mode. This gives lesser sharing
 26893                                  ;		violations when files are opened for read on a copy.
 26894                                  
 26895                                  ; ---------------------------------------------------------------------------
 26896                                  ;***	COPY CODE
 26897                                  ; ---------------------------------------------------------------------------
 26898                                  
 26899                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26900                                  
 26901                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26902                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26903                                  
 26904                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26905                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3E6Dh
 26906                                  
 26907                                  COPY:
 26908                                  	; 	Initialize internal variables.
 26909                                  
 26910 00003C77 31C0                    	xor	ax,ax		; AX = 0
 26911 00003C79 A3[08A1]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26912 00003C7C A3[38A2]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26913 00003C7F A3[84A1]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26914 00003C82 A2[039E]                	mov	[CFLAG],al	; 'destination file created' = false
 26915 00003C85 A3[099E]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26916 00003C88 A3[FF9D]                	mov	[DestSwitch],ax	; destination switches = none
 26917 00003C8B A3[5CA2]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26918 00003C8E A3[21A1]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26919 00003C91 A2[049E]                	mov	[DestClosed],al	; 'destination file closed' = false
 26920 00003C94 A2[20A1]                	mov	[DestSiz],al	; length of destination pathname = 0
 26921 00003C97 A2[83A1]                	mov	[SrcSiz],al	; length of source pathname = 0
 26922 00003C9A A2[23A1]                	mov	[DestInfo],al	; destination pathname flags = none
 26923 00003C9D A2[86A1]                	mov	[SrcInfo],al	; source pathname flags = none
 26924 00003CA0 A2[3AA2]                	mov	[INEXACT],al	; 'inexact copy' = false
 26925 00003CA3 A2[1FA1]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26926 00003CA6 A2[82A1]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26927 00003CA9 A2[C69C]                	mov	[USERDIR1],al	; saved working directory = null
 26928 00003CAC A2[3BA2]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26929 00003CAF A2[F79D]                	mov	[RDEOF],al	; 'read end of file' = false
 26930 00003CB2 A3[DEA1]                	mov	[SRCHAND],ax	; source handle = 0
 26931 00003CB5 A3[43A2]                	mov	[CPDATE],ax	; copy date = 0
 26932 00003CB8 A3[45A2]                	mov	[CPTIME],ax	; copy time = 0
 26933 00003CBB A2[E0A1]                	mov	[SRCISDEV],al	; 'source is device' = false
 26934                                  	; 23/03/2023
 26935                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26936 00003CBE A2[4BA2]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26937 00003CC1 A3[47A2]                	mov	[OFilePtr_Lo],ax
 26938 00003CC4 A3[49A2]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26939 00003CC7 A2[3FA2]                	mov	[TERMREAD],al	; 'terminate read' = false
 26940 00003CCA A2[7BA0]                	mov	[comma],al	; '"+,," found' = false
 26941 00003CCD A2[7CA0]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26942 00003CD0 A2[99A2]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26943 00003CD3 A3[019E]                	mov	[AllSwitch],ax	; all switches = none
 26944 00003CD6 A2[FA9D]                	mov	[ArgC],al	; source/dest argument count = 0
 26945 00003CD9 A2[41A2]                	mov	[PLUS],al	; '"+" in command line' = false
 26946 00003CDC A2[3CA2]                	mov	[BINARY],al	; 'binary copy' = false
 26947 00003CDF A2[40A2]                	mov	[ASCII],al	; 'ascii copy' = false
 26948 00003CE2 A3[129E]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26949 00003CE5 A3[3DA2]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26950 00003CE8 A2[F99D]                	mov	[Concat],al	; 'concatenating' = false
 26951 00003CEB A2[7FA1]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26952 00003CEE A3[80A1]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 26953                                  	
 26954                                  	; 12/06/2023
 26955                                  	; MSDOS 6.22 COMMAND.COM
 26956                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 26957 00003CF1 A2[58A2]                	mov     [cox_dest_file], al ; MSDOS 6.22
 26958 00003CF4 A2[59A2]                	mov     [cox_src_file], al  ; MSDOS 6.22
 26959                                  
 26960                                  	;	Initialize buffers with double-nulls.
 26961                                  
 26962 00003CF7 A3[E1A1]                	mov	[ScanBuf],ax
 26963 00003CFA A3[24A1]                	mov	[DestBuf],ax
 26964 00003CFD A3[87A1]                	mov	[SrcBuf],ax
 26965 00003D00 A3[65A0]                	mov	[SDIRBUF],ax
 26966 00003D03 A3[1FA0]                	mov	[DIRBUF],ax
 26967 00003D06 A3[DC9F]                	mov	[DestFcb],ax
 26968                                  
 26969 00003D09 A2[42A2]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26970                                  		
 26971 00003D0C 48                      	dec	ax ; -1		; AX = 0FFFFh
 26972 00003D0D A3[7BA1]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26973 00003D10 A2[0B9E]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26974 00003D13 A2[7EA1]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26975 00003D16 A2[1FA1]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26976                                  
 26977                                  	; 12/06/2023
 26978                                  	; Retro DOS v4.2 COMMAND.COM
 26979                                  	; MSDOS 6.22 COMMAND.COM code only !
 26980                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 26981                                  	;
 26982 00003D19 E8F306                  	call	init_copycmd_option ; MSDOS 6.22 
 26983                                  		
 26984 00003D1C BE8100                  	mov	si,81h		; SI = ptr to command line
 26985                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26986                                  	; 23/03/2023
 26987 00003D1F B32B                    	mov	bl,'+'
 26988 00003D21 FE06[98A2]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26989 00003D25 C606[0AA1]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26990                                  
 26991                                  	;*	Scan the command line for destination information.
 26992                                  
 26993                                  DESTSCAN:
 26994 00003D2A 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26995 00003D2C BF[E1A1]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26996                                  	; 23/03/2023
 26997 00003D2F 8936[7EA0]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26998 00003D33 E8710B                  	call	cparse			; parse next object
 26999 00003D36 9C                      	pushf	; (*)			; save CParse flags
 27000 00003D37 FE06[42A2]              	inc	byte [objcnt]		; count object
 27001 00003D3B F6C780                  	test	bh,80h
 27002 00003D3E 7405                    	jz	short NOCOPY		; no "+" delimiter
 27003 00003D40 C606[41A2]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 27004                                  NOCOPY:
 27005 00003D45 F6C701                  	test	bh,1
 27006 00003D48 747D                    	jz	short TESTP2		; not a switch
 27007                                  
 27008                                  	;	Found a switch.
 27009                                  
 27010                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 27011                                  	;
 27012                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27013                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F43h
 27014                                  CHK_CP_SWITCH:
 27015                                  	; MSDOS 6.0
 27016 00003D4A F7C51000                	test	bp,10h
 27017                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 27018 00003D4E 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27019                                  	;test	word [AllSwitch],10h
 27020 00003D50 F606[019E]10            	test	byte [AllSwitch],10h
 27021                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 27022 00003D55 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27023                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 27024                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 27025 00003D57 81CD0040                	or	bp,4000h
 27026                                  NOT_SLASHV:
 27027                                  	; ****************************************
 27028                                  	; 12/06/2023
 27029                                  	; Retro DOS v4.2 COMMAND.COM
 27030                                  	; MSDOS 6.22 COMMAND.COM code only !
 27031                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27032                                  	; ****************************************
 27033                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F55h
 27034                                  	;
 27035 00003D5B F7C54000                	test    bp,40h			; negative Y (-Y) switch flag
 27036 00003D5F 7417                    	jz	short CHK_SLASHY0
 27037                                  	;
 27038                                  	;test	word [AllSwitch],40h
 27039 00003D61 F606[019E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27040 00003D66 7507                    	jnz	short NOT_SLASHY1	; N flag
 27041                                  	;test	word [AllSwitch],80h
 27042 00003D68 F606[019E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27043 00003D6D 7404                    	jz	short NOT_SLASHY2
 27044                                  NOT_SLASHY1:
 27045 00003D6F 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27046                                  NOT_SLASHY2:				; Set up bad switch
 27047 00003D73 C606[57A2]00            	mov	byte [cox_y_override],0	; cox_y setting will be used
 27048                                  CHK_SLASHY0:
 27049 00003D78 F7C58000                	test    bp,80h
 27050 00003D7C 742B                    	jz      short CHK_SLASHY4	; not a /Y switch
 27051                                  	;
 27052 00003D7E 8A04                    	mov	al,[si]
 27053 00003D80 3C79                    	cmp	al,'y'
 27054 00003D82 740A                    	je	short CHK_SLASHY1
 27055 00003D84 3C59                    	cmp	al,'Y'
 27056 00003D86 7406                    	je	short CHK_SLASHY1
 27057 00003D88 81CD0040                	or	bp,4000h		; FBadSwitch
 27058                                  	;				; Set up bad switch
 27059 00003D8C EB1B                    	jmp	short CHK_SLASHY4
 27060                                  CHK_SLASHY1:
 27061 00003D8E C60420                  	mov	byte [si],20h ; ' '
 27062 00003D91 46                      	inc	si
 27063                                  	;test	word [AllSwitch],40h
 27064 00003D92 F606[019E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27065 00003D97 7507                    	jnz	short CHK_SLASHY2	; N flag
 27066                                  	;test	word [AllSwitch],80h
 27067 00003D99 F606[019E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27068 00003D9E 7404                    	jz	short CHK_SLASHY3
 27069                                  CHK_SLASHY2:
 27070 00003DA0 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27071                                  	;				; Set up bad switch
 27072                                  CHK_SLASHY3:
 27073 00003DA4 C606[57A2]01            	mov	byte [cox_y_override],1
 27074                                  CHK_SLASHY4:
 27075                                  	; ****************************************
 27076                                  	; 12/06/2023
 27077                                  ;NOT_SLASHV:
 27078                                  	;or	[DestSwitch],bp		; assume destination
 27079                                  	;or	[AllSwitch],bp		; keep tabs on all switches
 27080                                  
 27081                                  	; 12/06/2023
 27082                                  	; Retro DOS v4.2 COMMAND.COM
 27083                                  	; MSDOS 6.22 COMMAND.COM -TRANGROUP:3FA7h
 27084 00003DA9 092E[FF9D]              	or	[DestSwitch],bp		; set [DestSwitch] SwitchY flag to 1
 27085 00003DAD 092E[019E]              	or	[AllSwitch],bp		; set [AllSwitch] SwitchY flag to 1
 27086                                  	;test	bp,~SwitchCopy		; Bad switch?
 27087 00003DB1 F7C5237F                	test	bp,7F23h ; MSDOS 6.22	; ~SwitchCopy ; not SwitchCopy
 27088 00003DB5 740A                    	jz	short NOT_BAD_SWITCH	; Switches are okay
 27089                                  
 27090                                  	; 12/06/2023
 27091                                  	; 23/03/2023
 27092                                  	; MSDOS 6.0
 27093                                  	;;test	bp,not SwitchCopy	;AN018; Bad switch?
 27094                                  	;test	bp,7FE3h ; test bp,~SwitchCopy
 27095                                  	;jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 27096                                  	
 27097 00003DB7 9D                      	popf	; (*)			;AN018; fix up stack
 27098 00003DB8 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 27099 00003DBB E855E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 27100 00003DBE E9DCF0                  	jmp	cerror			;AC018; exit
 27101                                  NOT_BAD_SWITCH:
 27102 00003DC1 9D                      	popf				; restore CParse flags
 27103 00003DC2 7235                    	jc	short CHECKDONE		; found CR
 27104 00003DC4 E963FF                  	jmp	DESTSCAN		; continue scanning for destination
 27105                                  TESTP2:
 27106 00003DC7 9D                      	popf	; (*)			; restore CParse flags
 27107 00003DC8 722F                    	jc	short CHECKDONE		; found CR
 27108 00003DCA F6C780                  	test	bh,80h
 27109 00003DCD 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 27110 00003DCF FE06[FA9D]              	inc	byte [ArgC]		; count independent pathname args
 27111                                  GOTPLUS:
 27112 00003DD3 56                      	push	si			; save cmd line ptr
 27113 00003DD4 A1[5CA2]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 27114 00003DD7 BE[E1A1]                	mov	si,ScanBuf		; SI = ptr to path string
 27115 00003DDA 29F0                    	sub	ax,si			; AX = offset of last element
 27116 00003DDC BF[24A1]                	mov	di,DestBuf		; DI = ptr to destination buf
 27117 00003DDF 01F8                    	add	ax,di			; AX = ptr to last element in
 27118                                  					;  destination path buffer
 27119 00003DE1 A3[21A1]                	mov	[DestTail],ax		; save ptr to last element
 27120 00003DE4 880E[20A1]              	mov	[DestSiz],cl		; save path string length
 27121 00003DE8 41                      	inc	cx			; CX = mov length (incl null)
 27122 00003DE9 F3A4                    	rep	movsb			; DestBuf = possible destination path
 27123 00003DEB 883E[23A1]              	mov	[DestInfo],bh		; save CParse info flags
 27124 00003DEF C706[FF9D]0000          	mov	word [DestSwitch],0	; clear destination switches
 27125 00003DF5 5E                      	pop	si			; SI = ptr into cmd line again
 27126 00003DF6 E931FF                  	jmp	DESTSCAN		;AC018; continue scanning for dest
 27127                                  
 27128                                  CHECKDONE:
 27129                                  	;	We reached the CR. The destination scan is finished.
 27130                                  
 27131                                  	;	Disallow "copy file1+" as file overwriting itself.
 27132                                  	;
 27133                                  	;	(Note that "copy file1+file2+" will be accepted, and
 27134                                  	;	equivalent to "copy file1+file2".)
 27135                                  
 27136                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 27137                                  	;	through this check, since the switch would count
 27138                                  	;	as another object in ObjCnt.
 27139                                  
 27140 00003DF9 803E[41A2]01            	cmp	byte [PLUS],1		; "+" with
 27141 00003DFE 7514                    	jnz	short CDCONT
 27142 00003E00 803E[FA9D]01            	cmp	byte [ArgC],1		; one arg,
 27143 00003E05 750D                    	jnz	short CDCONT
 27144 00003E07 803E[42A2]02            	cmp	byte [objcnt],2		; two objects..
 27145 00003E0C 7506                    	jnz	short CDCONT
 27146 00003E0E BA[2C92]                	mov	dx,OVERWR_PTR
 27147 00003E11 E9AE07                  	jmp	COPYERR			; is file overwrite
 27148                                  
 27149                                  CDCONT:
 27150 00003E14 A0[41A2]                	mov	al,[PLUS]		; AL = '"+" occurred'
 27151 00003E17 A2[F99D]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 27152 00003E1A D0E0                    	shl	al,1
 27153 00003E1C D0E0                    	shl	al,1
 27154 00003E1E A2[3AA2]                	mov	[INEXACT],al		; therefore making an inexact copy
 27155                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 27156 00003E21 A0[FA9D]                	mov	al,[ArgC]		; AL = # independent arguments
 27157                                  
 27158                                  	; 23/03/2023
 27159                                  	; MSDOS 3.3		
 27160                                  	;or	al,al
 27161                                  	;jz	short CERROR4J
 27162                                  	; MSDOS 6.0
 27163 00003E24 08C0                    	or	al,al
 27164 00003E26 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 27165                                  		
 27166 00003E28 BA[0392]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27167 00003E2B C706[0392]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 27168                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 27169 00003E31 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 27170                                  
 27171                                  	; more than 0 args; check if too many
 27172                                  TRY_TOO_MANY:
 27173 00003E33 3C02                    	cmp	al,2
 27174 00003E35 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 27175                                  
 27176                                  	; 23/03/2023
 27177                                  	; MSDOS 6.0
 27178 00003E37 BA[0392]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27179 00003E3A C706[0392]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 27180                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 27181                                  CERROR_PARSEJ:
 27182 00003E40 C606[0192]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 27183                                  					; parse error message	
 27184                                  CERROR4J:
 27185 00003E45 E955F0                  	jmp	cerror
 27186                                  
 27187                                  ACOUNTOK:
 27188 00003E48 BD[1FA1]                	mov	bp,DestVars		; BP = base of dest variables
 27189                                  
 27190 00003E4B 3C01                    	cmp	al,1
 27191 00003E4D 7520                    	jnz	short GOT2ARGS
 27192                                  
 27193                                  	;	Only one independent pathname argument on command line.
 27194                                  	;	Set destination to d:*.*, where d: is current drive.
 27195                                  
 27196                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 27197                                  	;	The two files would be appended as d:file1, rather than x:file1.
 27198                                  
 27199 00003E4F A0[F89D]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 27200                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 27201                                  	; 23/03/2023
 27202 00003E52 0441                    	add	al,'A'
 27203 00003E54 B43A                    	mov	ah,':'			; AX = "d:"
 27204                                  	;mov	byte [bp+1],2
 27205 00003E56 C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 27206                                  
 27207 00003E5A BF[24A1]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 27208 00003E5D AB                      	stosw				; store "d:"
 27209                                  		
 27210 00003E5E C706[FF9D]0000          	mov	word [DestSwitch],0	; clear destination switches
 27211                                  	;mov	byte [bp+4],2		
 27212 00003E64 C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27213                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27214                                  	;mov	byte [bp+0],0		
 27215 00003E68 C6460000                	mov	byte [bp],0
 27216 00003E6C E8090A                  	call	SETSTARS		; add wildcards
 27217                                  GOT2ARGS:
 27218                                  	;	If destination pathname is "d:", add full wildcard filename
 27219                                  
 27220                                  	;cmp	byte [bp+1],2
 27221 00003E6F 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 27222 00003E73 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 27223 00003E75 B03A                    	mov	al,':'  ; 3Ah
 27224 00003E77 3806[25A1]              	cmp	byte [DestBuf+1],al
 27225 00003E7B 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 27226                                  	;or	byte [bp+4],2
 27227 00003E7D 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27228 00003E81 BF[26A1]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 27229                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27230                                  	;mov	byte [bp+0],0		
 27231 00003E84 C6460000                	mov	byte [bp],0
 27232 00003E88 E8ED09                  	call	SETSTARS		; add wildcards
 27233                                  NOTSHORTDEST:
 27234                                  	;	If destination pathname ends with "\", try to make
 27235                                  	;	sure it's "d:\".
 27236                                  
 27237                                  	;mov	di,[bp+2]
 27238 00003E8B 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 27239 00003E8E 803D00                  	cmp	byte [di],0
 27240 00003E91 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 27241                                  
 27242 00003E93 BA[3E93]                	mov	dx,badcd_ptr
 27243 00003E96 B03A                    	mov	al,':'
 27244 00003E98 3845FE                  	cmp	[di-2],al
 27245 00003E9B 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 27246                                  	;mov	byte [bp+0],2
 27247                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 27248 00003E9D C6460002                	mov	byte [bp],2
 27249                                  	;or	byte [bp+4],6
 27250 00003EA1 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 27251                                  					  ;  path character
 27252 00003EA5 E8D009                  	call	SETSTARS		; add wildcards
 27253                                  CHKSWTCHES:
 27254                                  	;	We have enough information about the destination for now.
 27255                                  
 27256                                  	;	Turn on verify if requested. Save the current verify flag.
 27257                                  
 27258                                  	; 23/03/2023
 27259                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 27260                                  	;mov	dx,BADPARMPTR
 27261                                  	
 27262 00003EA8 A1[019E]                	mov	ax,[AllSwitch]		; AX = all switch flags
 27263                                  
 27264                                  	; 23/03/2023
 27265                                  	; MSDOS 3.3
 27266                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27267                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27268                                  	;jnz	short CERROR4J
 27269                                  	
 27270                                  	; 23/03/2023
 27271                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27272                                  	;test	ax,SwitchV ; 10h
 27273                                  	; 18/04/2023
 27274                                  	;test	ax,10h
 27275 00003EAB A810                    	test	al,10h  ; test al,SwitchV
 27276 00003EAD 7414                    	jz	short NOVERIF		; no /v, no verify
 27277                                  
 27278 00003EAF B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27279 00003EB1 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27280                                  				; Return: AL = 00h if flag OFF
 27281                                  				; AL = 01h if flag ON
 27282 00003EB3 1E                      	push	ds
 27283 00003EB4 8E1E[E49D]              	mov	ds,[RESSEG]
 27284 00003EB8 30E4                    	xor	ah,ah
 27285 00003EBA A3[6302]                	mov	[VerVal],ax		; save current verify flag
 27286 00003EBD 1F                      	pop	ds
 27287 00003EBE B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27288 00003EC1 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27289                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27290                                  NOVERIF:
 27291                                  	;*	Scan for first source.
 27292                                  
 27293 00003EC3 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27294 00003EC5 BE8100                  	mov	si,81h			; SI = ptr into command line
 27295                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27296                                  	; 23/03/2023
 27297 00003EC8 B32B                    	mov	bl,'+' ; 2Bh
 27298                                  SCANFSRC:
 27299 00003ECA BF[E1A1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27300 00003ECD E8D709                  	call	cparse			; parse first source pathname
 27301 00003ED0 F6C701                  	test	bh,1			; switch?
 27302 00003ED3 75F5                    	jnz	short SCANFSRC		; yes, try again
 27303 00003ED5 092E[FF9D]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27304                                  
 27305                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27306                                  
 27307                                  	; 23/03/2023
 27308 00003ED9 F7C50800                	test	bp,8
 27309                                  	;test	bp,SWITCHB
 27310 00003EDD 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27311 00003EDF 803E[F99D]00            	cmp	byte [Concat],0
 27312 00003EE4 7405                    	jz	short NOSETCASC		; we're not concatenating
 27313 00003EE6 C606[40A2]04            	mov	byte [ASCII],4
 27314                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27315                                  NOSETCASC:
 27316 00003EEB E82604                  	call	SOURCE_SET		; set source variables
 27317 00003EEE E84400                  	call	FRSTSRC			; set up first source copy
 27318 00003EF1 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27319                                  
 27320                                  ; ---------------------------------------------------------------------------
 27321                                  
 27322                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27323                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27324                                  ENDCOPY:
 27325                                  	;*	End of the road. Close destination, display # files
 27326                                  	;	copied (meaning # destinations), and go back to main
 27327                                  	;	transient COMMAND code.
 27328                                  
 27329 00003EF4 E83203                  	call	CLOSEDEST
 27330                                  ENDCOPY2:
 27331 00003EF7 BA[3592]                	mov	dx,copied_ptr
 27332 00003EFA 8B36[129E]              	mov	si,[FileCnt]
 27333 00003EFE 8936[08A1]              	mov	[Copy_num],si
 27334 00003F02 E83816                  	call	std_printf
 27335 00003F05 E9FCC1                  	jmp	TCOMMAND		; stack could be messed up
 27336                                  
 27337                                  ; ---------------------------------------------------------------------------
 27338                                  
 27339                                  SRCNONEXIST:
 27340                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27341                                  	;	Otherwise, say 'file not found' and quit.
 27342                                  
 27343 00003F08 803E[F99D]00            	cmp	byte [Concat],0
 27344 00003F0D 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27345                                  
 27346                                  	; 24/03/2023
 27347                                  	; MSDOS 3.3
 27348                                  	;mov	dx,SRCBUF
 27349                                  	;mov	[STRING_PTR_1],dx
 27350                                  	;mov	dx,STRINGBUF1PTR
 27351                                  	;call	STD_PRINTF
 27352                                  	;mov	dx,FNOTFOUNDPTR
 27353                                  	;jmp	COPYERR
 27354                                  
 27355                                  	; 24/*03/2023
 27356                                  	; MSDOS 6.0
 27357                                  	;	Set up error message.
 27358 00003F0F C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27359                                  				  	; extended error msg
 27360 00003F14 BA[0392]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27361 00003F17 C706[0392]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27362                                  					; 'file not found' msg#
 27363 00003F1D C706[06A1][87A1]        	mov	word [string_ptr_2],SrcBuf
 27364                                  					; point at bad pathname
 27365 00003F23 C606[0592]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27366                                  					; 1 substitution
 27367 00003F28 E99706                  	jmp	COPYERR			; print msg and clean up
 27368                                  
 27369                                  ; ---------------------------------------------------------------------------
 27370                                  
 27371                                  SOURCEPROC:
 27372                                  
 27373                                  	;*	Preparatory processing for each source file.
 27374                                  	;	Called at FrstSrc for first source file.
 27375                                  
 27376 00003F2B E8E603                  	call	SOURCE_SET		; set source variables & ascii/binary
 27377 00003F2E 803E[F99D]00            	cmp	byte [Concat],0
 27378 00003F33 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27379                                  
 27380                                  ; ---------------------------------------------------------------------------
 27381                                  
 27382                                  FRSTSRC:
 27383 00003F35 31C0                    	xor	ax,ax
 27384 00003F37 A2[039E]                	mov	[CFLAG],al		; 'destination not created'
 27385 00003F3A A3[099E]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27386 00003F3D A2[049E]                	mov	[DestClosed],al		; 'destination not closed'
 27387                                  
 27388                                  LEAVECFLAG:
 27389 00003F40 8936[38A2]              	mov	[SRCPT],si		; save cmd-line ptr
 27390 00003F44 BF[C69C]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27391                                  						;   current dir
 27392 00003F47 BD[82A1]                	mov	bp,SrcVars		; BP = base of source variables
 27393 00003F4A E8DB07                  	call	BUILDPATH		; cd to source dir, figure
 27394                                  						;   out stuff about source
 27395 00003F4D 8B36[84A1]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27396 00003F51 C3                      	retn
 27397                                  
 27398                                  ; ---------------------------------------------------------------------------
 27399                                  
 27400                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27401                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27402                                  NEXTSRC:
 27403                                  	;*	Next source. Come here after handling each pathname.
 27404                                  	;	We're done unless there are additional source pathnames
 27405                                  	;	to be appended.
 27406                                  	;
 27407                                  	;	Note that all files matching an ambiguous pathname
 27408                                  	;	are processed before coming here.
 27409                                  
 27410 00003F52 803E[41A2]00            	cmp	byte [PLUS],0
 27411                                  	;jne	short MORECP		; copying "+" sources - keep going
 27412                                  	; 26/04/2023
 27413                                  ;ENDCOPYJ2:
 27414                                  	;jmp	short ENDCOPY
 27415 00003F57 749B                    	je	short ENDCOPY
 27416                                  MORECP:
 27417 00003F59 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27418 00003F5B 8B36[38A2]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27419                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27420 00003F5F B32B                    	mov	bl,'+' ; 2Bh
 27421                                  SCANSRC:
 27422 00003F61 BF[E1A1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27423 00003F64 E84009                  	call	cparse			; parse first source name
 27424                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27425                                  	; 26/04/2023
 27426 00003F67 728B                    	jb	short ENDCOPY
 27427                                  
 27428 00003F69 F6C780                  	test	bh,80h
 27429                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27430                                  	; 26/04/2023
 27431 00003F6C 7486                    	jz	short ENDCOPY
 27432                                  
 27433 00003F6E F6C701                  	test	bh,1
 27434 00003F71 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27435                                  
 27436                                  	;	ScanBuf contains the next source pathname.
 27437                                  
 27438 00003F73 E8B5FF                  	call	SOURCEPROC		; prepare this source
 27439 00003F76 803E[7BA0]01            	cmp	byte [comma],1		; was +,, found last time?
 27440 00003F7B 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27441 00003F7D C606[7CA0]01            	mov	byte [plus_comma],1	; yes - set flag
 27442 00003F82 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27443                                  
 27444                                  NOSTAMP:
 27445 00003F84 C606[7CA0]00            	mov	byte [plus_comma],0	; reset +,, flag
 27446                                  
 27447                                  ; ---------------------------------------------------------------------------
 27448                                  
 27449                                  FIRSTENT:
 27450                                  
 27451                                  ;M047
 27452                                  ; The only case we need to worry about is when the source is wildcarded and
 27453                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27454                                  ;concatenation. We check for this case.
 27455                                  ;
 27456                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27457                                  ;right place to do this check.
 27458                                  
 27459                                  	;	This is where we enter the loop with the first source.
 27460                                  
 27461 00003F89 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27462 00003F8C B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27463 00003F8F CD21                    	int	21h		; DOS -	PARSE FILENAME
 27464                                  				; DS:SI	-> string to parse
 27465                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27466                                  				; AL = bit mask	to control parsing
 27467 00003F91 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27468 00003F94 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27469 00003F96 A1[87A1]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27470 00003F99 80FC3A                  	cmp	ah,':'
 27471 00003F9C 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27472 00003F9E B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27473                                  DRVSPEC1:
 27474 00003FA0 0C20                    	or	al,20h			; AL = lowercase drive letter
 27475 00003FA2 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27476                                  	;mov	[5Ch],al
 27477 00003FA4 A25C00                  	mov	[FCB],al		; put drive id in FCB
 27478                                  
 27479                                  	;	FCB contains drive and filename to search.
 27480                                  		
 27481 00003FA7 B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 27482 00003FA9 E86D01                  	call	SEARCH
 27483                                  SRCHDONE:
 27484 00003FAC 9C                      	pushf				; save flags from Search
 27485 00003FAD E81CEA                  	call	RestUDir1		; restore users current directory
 27486 00003FB0 9D                      	popf				; restore flags from search
 27487 00003FB1 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27488 00003FB3 E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27489                                  
 27490                                  NEXTAMBIG0:
 27491 00003FB6 30C0                    	xor	al,al
 27492 00003FB8 8606[0B9E]              	xchg	al,[FRSTSRCH]
 27493 00003FBC 08C0                    	or	al,al
 27494 00003FBE 740B                    	jz	short NEXTAMBIG
 27495                                  SETNMEL:
 27496 00003FC0 B90C00                  	mov	cx,12
 27497 00003FC3 BF[65A0]                	mov	di,SDIRBUF
 27498 00003FC6 BE[1FA0]                	mov	si,DIRBUF
 27499 00003FC9 F3A4                    	rep	movsb			; save very first source name
 27500                                  NEXTAMBIG:
 27501 00003FCB 30C0                    	xor	al,al
 27502 00003FCD A2[3BA2]                	mov	[NOWRITE],al		; turn off nowrite
 27503 00003FD0 8B3E[84A1]              	mov	di,[SrcTail]
 27504 00003FD4 BE[20A0]                	mov	si,DIRBUF+1
 27505 00003FD7 E86EEB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27506                                  ;MELDO:
 27507                                  	; ****************************************
 27508                                  	; 12/06/2023
 27509                                  	; Retro DOS v4.2 COMMAND.COM
 27510                                  	; MSDOS 6.22 COMMAND.COM code only !
 27511                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27512                                  	; ****************************************
 27513                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:41DBh
 27514                                  MELDO0:
 27515 00003FDA 803E[57A2]00            	cmp	byte [cox_y_override],0 ; /Y switch override (question) enabled ?
 27516 00003FDF 746C                    	jz	short MELDO ; no
 27517                                  	; ----------------------
 27518                                  	; yes
 27519 00003FE1 E85406                  	call	BUILDDEST
 27520 00003FE4 BE[87A1]                	mov	si,SrcBuf
 27521 00003FE7 BF[129B]                	mov	di,SRCXNAME
 27522                                  	;mov	ah,60h
 27523 00003FEA B460                    	mov	ah,xNameTrans ; 60h
 27524 00003FEC CD21                    	int	21h	; DOS - RESOLVE PATH STRING TO CANONICAL PATH STRING
 27525                                  			; DS:SI -> ASCIZ relative path string or directory name
 27526                                  			; ES:DI -> 128-byte buffer for ASCIZ canonical fully qualified name
 27527 00003FEE E8A308                  	call	COMPNAME
 27528 00003FF1 7540                    	jnz	short MELDO1    	; different file names
 27529 00003FF3 803E[F99D]00            	cmp	byte [Concat],0
 27530 00003FF8 7539                    	jnz	short MELDO1		; concatenating
 27531                                  	; "File cannot be copied onto itself"
 27532 00003FFA BA[AE93]                	mov	dx,file_name_ptr
 27533 00003FFD E83D15                  	call	std_printf
 27534 00004000 E819EB                  	call	CRLF2
 27535 00004003 BA[2C92]                	mov	dx,OVERWR_PTR
 27536 00004006 E9B905                  	jmp	COPYERR
 27537                                  ;MELDO1:
 27538                                  	;cmp	byte [CFLAG],0		; destination file created flag
 27539                                  	;jnz	short MELDO		; yes, new (created) file
 27540                                  	;				; no, overwrite question (must be confirmed)
 27541                                  	;call	get_answer_YNA
 27542                                  	;jb	short MELDO2    	; answer is no
 27543                                  	;cmp	byte [Concat],0
 27544                                  	;jnz	short MELDO
 27545                                  	;cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27546                                  	;jnz	short DOREAD    	; yes
 27547                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27548                                  MELDO2:
 27549 00004009 803E[7FA1]00            	cmp	byte [MELCOPY],0	; is 'Mel Hallerman copy' false ?
 27550 0000400E 7507                    	jnz	short MELDO3    	; no (, it is true)
 27551 00004010 803E[F99D]00            	cmp	byte [Concat],0
 27552 00004015 7408                    	jz	short MELDO4
 27553                                  MELDO3:
 27554 00004017 C606[049E]01            	mov	byte [DestClosed],1
 27555 0000401C E9D5FE                  	jmp	ENDCOPY
 27556                                  MELDO4:
 27557 0000401F E8EB00                  	call	SEARCHNEXT
 27558 00004022 74A7                    	jz	short NEXTAMBIG
 27559 00004024 803E[59A2]00            	cmp	byte [cox_src_file],0
 27560                                  	;jz	short MELDO5
 27561                                  	;jmp	NEXTSRC
 27562                                  	; 18/06/2023
 27563 00004029 7505                    	jnz	short NEXTSRCJ
 27564                                  MELDO5:
 27565 0000402B C606[049E]01            	mov	byte [DestClosed],1
 27566                                  NEXTSRCJ:	; 18/06/2023
 27567 00004030 E91FFF                  	jmp	NEXTSRC
 27568                                  
 27569                                  	; 12/06/2023
 27570                                  MELDO1:
 27571 00004033 803E[039E]00            	cmp	byte [CFLAG],0		; destination file created flag
 27572 00004038 7513                    	jnz	short MELDO     	; yes, new (created) file
 27573                                  					; no, overwrite question (must be confirmed)
 27574 0000403A E81803                  	call	get_answer_YNA
 27575 0000403D 72CA                    	jb	short MELDO2    	; answer is no
 27576 0000403F 803E[F99D]00            	cmp	byte [Concat],0
 27577 00004044 7507                    	jnz	short MELDO
 27578 00004046 803E[58A2]00            	cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27579 0000404B 7517                    	jnz	short DOREAD    	; yes
 27580                                  	; 12/06/2023
 27581                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27582                                  
 27583                                  	; ****************************************
 27584                                  	; 12/06/2023
 27585                                  MELDO:
 27586 0000404D 803E[F99D]00            	cmp	byte [Concat],0
 27587 00004052 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27588 00004054 F606[86A1]02            	test	byte [SrcInfo],2	; wildcard - show name
 27589 00004059 7409                    	jz	short DOREAD
 27590                                  SHOWCPNAM:
 27591                                  	; 25/03/2023
 27592                                  	; MSDOS 3.3
 27593                                  	;mov	dx,SRCBUF
 27594                                  	;mov	[STRING_PTR_2],dx
 27595                                  	;mov	dx,STRINGBUF2PTR
 27596                                  	;call	STD_PRINTF
 27597                                  	;call	CRLF2
 27598                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27599                                  	; MSDOS 6.0 (& MSDOS 5.0
 27600 0000405B BA[AE93]                	mov	dx,file_name_ptr
 27601 0000405E E8DC14                  	call	std_printf
 27602 00004061 E8B8EA                  	call	CRLF2
 27603                                  DOREAD:
 27604 00004064 E8C300                  	call	DOCOPY
 27605 00004067 803E[F99D]00            	cmp	byte [Concat],0
 27606 0000406C 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27607                                  
 27608 0000406E E8B801                  	call	CLOSEDEST		; close current destination
 27609 00004071 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27610                                  
 27611 00004073 C606[039E]00            	mov	byte [CFLAG],0		; 'destination not created'
 27612                                  NODCLOSE:
 27613 00004078 803E[F99D]00            	cmp	byte [Concat],0		
 27614 0000407D 740A                    	jz	short NOFLUSH
 27615                                  
 27616                                  ;	Concatenating - flush output between source files so LostErr
 27617                                  ;	stuff works correctly.
 27618                                  
 27619                                  	;invoke	FlshFil  ; MSDOS 6.0
 27620                                  	; 25/03/2023
 27621 0000407F E80304                  	call	FlshFil
 27622                                  	;call	FLUSHFIL ; MSDOS 3.3
 27623                                  
 27624 00004082 F606[7FA1]FF            	test	byte [MELCOPY],0FFh
 27625                                  	;jz	short NOFLUSH
 27626                                  	;jmp	short DOMELCOPY
 27627                                  	; 25/03/2023
 27628 00004087 750D                    	jnz	short DOMELCOPY
 27629                                  NOFLUSH:
 27630 00004089 E88100                  	call	SEARCHNEXT		; try next match
 27631 0000408C 75A2                    	jnz	short NEXTSRCJ		; not found - finished with 
 27632                                  					;   this source spec
 27633 0000408E C606[049E]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27634 00004093 E935FF                  	jmp	NEXTAMBIG		; do next ambig match
 27635                                  
 27636                                  DOMELCOPY:
 27637 00004096 803E[7FA1]FF            	cmp	byte [MELCOPY],0FFh
 27638 0000409B 740D                    	je	short CONTMEL
 27639 0000409D 8B36[38A2]              	mov	si,[SRCPT]
 27640 000040A1 8936[80A1]              	mov	[MELSTART],si
 27641 000040A5 C606[7FA1]FF            	mov	byte [MELCOPY],0FFh
 27642                                  
 27643                                  CONTMEL:
 27644 000040AA 31ED                    	xor	bp,bp
 27645 000040AC 8B36[38A2]              	mov	si,[SRCPT]
 27646                                  	;mov	bl,[PLUS_CHR]
 27647                                  	; 25/03/2023
 27648 000040B0 B32B                    	mov	bl,'+'
 27649                                  SCANSRC2:
 27650 000040B2 BF[E1A1]                	mov	di,ScanBuf
 27651 000040B5 E8EF07                  	call	cparse
 27652 000040B8 F6C780                  	test	bh,80h
 27653 000040BB 742F                    	jz	short NEXTMEL		; no "+" - go back to start
 27654 000040BD F6C701                  	test	bh,1
 27655 000040C0 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27656 000040C2 E866FE                  	call	SOURCEPROC
 27657 000040C5 E804E9                  	call	RestUDir1
 27658 000040C8 BF[A09F]                	mov	di,DESTFCB2
 27659 000040CB B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27660 000040CE CD21                    	int	21h		; DOS -	PARSE FILENAME
 27661                                  				; DS:SI	-> string to parse
 27662                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27663                                  				; AL = bit mask	to control parsing
 27664 000040D0 BB[66A0]                	mov	bx,SDIRBUF+1
 27665 000040D3 BE[A19F]                	mov	si,DESTFCB2+1
 27666 000040D6 8B3E[84A1]              	mov	di,[SrcTail]
 27667                                  
 27668 000040DA E81C06                  	call	BUILDNAME
 27669                                  
 27670 000040DD 803E[F99D]00            	cmp	byte [Concat],0
 27671 000040E2 7405                    	je	short MELDOJ		; not concatenating - continue
 27672                                  
 27673                                  	;	Yes, turn off nowrite because this part of the code 
 27674                                  	;	is only reached after the first file has been dealt with.
 27675                                  
 27676 000040E4 C606[3BA2]00            	mov	byte [NOWRITE],0
 27677                                  MELDOJ:
 27678 000040E9 E961FF                  	jmp	MELDO
 27679                                  	; 18/06/2023
 27680                                  ;NEXTSRCJ:
 27681                                  	;jmp	NEXTSRC
 27682                                  
 27683                                  NEXTMEL:
 27684 000040EC E83A01                  	call	CLOSEDEST
 27685 000040EF 31C0                    	xor	ax,ax
 27686 000040F1 A2[039E]                	mov	[CFLAG],al
 27687 000040F4 A3[099E]                	mov	[NXTADD],ax
 27688 000040F7 A2[049E]                	mov	[SPECDRV],al
 27689 000040FA 8B36[80A1]              	mov	si,[MELSTART]
 27690 000040FE 8936[38A2]              	mov	[SRCPT],si
 27691 00004102 E80800                  	call	SEARCHNEXT
 27692 00004105 7403                    	jz	short SETNMELJ
 27693 00004107 E9EDFD                  	jmp	ENDCOPY2
 27694                                  SETNMELJ:
 27695 0000410A E9B3FE                  	jmp	SETNMEL
 27696                                  
 27697                                  ; ---------------------------------------------------------------------------
 27698                                  
 27699                                  SEARCHNEXT:
 27700 0000410D B412                    	mov	ah,Dir_Search_Next ; 12h
 27701 0000410F F606[86A1]02            	test	byte [SrcInfo],2
 27702 00004114 7503                    	jnz	short SEARCH		; do search-next if ambig
 27703 00004116 08E4                    	or	ah,ah			; reset zero flag
 27704 00004118 C3                      	retn
 27705                                  
 27706                                  ; ---------------------------------------------------------------------------
 27707                                  
 27708                                  SEARCH:
 27709 00004119 50                      	push	ax
 27710 0000411A B41A                    	mov	ah,Set_DMA ; 1Ah
 27711 0000411C BA[1FA0]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27712 0000411F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27713                                  			; DS:DX	-> disk	transfer buffer
 27714 00004121 58                      	pop	ax		; restore search first/next command
 27715 00004122 BA5C00                  	mov	dx,FCB ; 5Ch
 27716 00004125 CD21                    	int	21h		; Do the search
 27717 00004127 08C0                    	or	al,al
 27718 00004129 C3                      	retn
 27719                                  
 27720                                  ; ---------------------------------------------------------------------------
 27721                                  
 27722                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27723                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27724                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4335h
 27725                                  DOCOPY:
 27726 0000412A BE[87A1]                	mov	si,SrcBuf	; do name translate of source
 27727 0000412D BF[129B]                	mov	di,SRCXNAME	; save for name comparison
 27728 00004130 B460                    	mov	ah,xNameTrans ; 60h
 27729                                  	;mov	ah,60h
 27730 00004132 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27731                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27732                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27733 00004134 C606[F79D]00            	mov	byte [RDEOF],0	; no EOF yet
 27734                                  
 27735                                  	; MSDOS 6.0
 27736                                  	;mov	ax,ExtOpen shl 8	; open the file
 27737                                  	; 26/03/2023
 27738 00004139 B8006C                  	mov	ax,6C00h
 27739                                  ;M046
 27740                                  ; For reads, the sharing mode should be deny none so that any process can
 27741                                  ;open this file again in any other sharing mode. This is mainly to allow
 27742                                  ;multiple command.com's to access the same file without getting sharing
 27743                                  ;violations
 27744                                  ;
 27745                                  	;mov	bx,deny_none|read_open_mode
 27746 0000413C BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27747 0000413F 31C9                    	xor	cx,cx			; no special files
 27748                                  	;mov	dx,read_open_flag	; set up open flags
 27749 00004141 BA0101                  	mov	dx,101h
 27750 00004144 CD21                    	int	21h
 27751                                  	; 26/03/2023
 27752 00004146 7230                    	jc	short Error_On_Source
 27753                                  	;jnc	short OPENOK
 27754                                  
 27755                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27756                                  	;	They asked for it...
 27757                                  
 27758                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27759                                  
 27760                                  	; 26/03/2023
 27761                                  	; MSDOS 3.3
 27762                                  	;mov	dx,SRCBUF
 27763                                  	;mov	ax,OPEN*256 ; 3D00h
 27764                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27765                                  	;			; DS:DX	-> ASCIZ filename
 27766                                  	;			; AL = access mode
 27767                                  	;			; 0 - read
 27768                                  	;jnc	short OPENOK
 27769                                  	;call	GET_EXT_ERR_NUMBER
 27770                                  	;pushf
 27771                                  	;cmp	ax,65
 27772                                  	;jnz	short DOCOPY_ERR
 27773                                  	;mov	dx,ACCDENPTR
 27774                                  	;call	STD_PRINTF
 27775                                  ;DOCOPY_ERR:
 27776                                  	;popf
 27777                                  	;retn
 27778                                  
 27779                                  	; 26/03/2023
 27780                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27781                                  OPENOK:
 27782 00004148 89C3                    	mov	bx,ax
 27783 0000414A 891E[DEA1]              	mov	[SRCHAND],bx		; save handle
 27784 0000414E B80057                  	mov	ax,File_Times*256 ; 5700h
 27785 00004151 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27786                                  				; BX = file handle
 27787                                  
 27788 00004153 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 27789                                  
 27790 00004155 8916[43A2]              	mov	[CPDATE],dx		; save date
 27791 00004159 890E[45A2]              	mov	[CPTIME],cx		; save time
 27792                                  
 27793                                  	; MSDOS 6.0
 27794                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27795                                  	; 26/04/2023
 27796                                  No_Copy_Xa:
 27797                                  	; 26/03/2023
 27798                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27799                                  
 27800                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27801 0000415D B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27802 00004160 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27803                                  				; BX = file or device handle
 27804                                  	;and	dl,devid_ISDEV ; 80h
 27805                                  	; 18/04/2023
 27806 00004162 80E280                  	and	dl,80h ; devid_ISDEV
 27807 00004165 8816[E0A1]              	mov	[SRCISDEV],dl		; set source info
 27808 00004169 7436                    	jz	short COPYLP		; source not a device
 27809 0000416B 803E[3CA2]00            	cmp	byte [BINARY],0
 27810 00004170 742F                    	je	short COPYLP		; ascii device ok
 27811 00004172 BA[6793]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27812 00004175 E94A04                  	jmp	COPYERR
 27813                                  
 27814                                  Error_On_Source:			;AN022; we have a BAD error
 27815 00004178 E8C3E0                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27816 0000417B C706[06A1][87A1]        	mov	word [string_ptr_2],SrcBuf
 27817                                  				;AN022; get address of failed string
 27818 00004181 C606[0592]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27819                                  				;AN022; put number of subst in control block
 27820 00004186 E8AC13                  	call	std_eprintf		;AN022; print it
 27821                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27822 00004189 8B1E[DEA1]              	mov	bx,[SRCHAND]
 27823                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27824                                  	;je	short No_Close_Src	;AN022; no - don't close
 27825 0000418D 09DB                    	or	bx,bx
 27826 0000418F 7403                    	jz	short No_Close_Src
 27827                                  	;call	CLOSESRC		;AN022; clean up
 27828                                  	; 26/03/2023
 27829 00004191 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27830                                  No_Close_Src:				;AN022;
 27831 00004194 803E[039E]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27832 00004199 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27833 0000419B E956FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27834                                  EndCopyJ3:				;AN022;
 27835 0000419E E956FD                  	jmp	ENDCOPY2		;AN022;
 27836                                  
 27837                                  	; 26/04/2023
 27838                                  ;No_Copy_Xa:
 27839                                  ;	; 26/03/2023
 27840                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27841                                  ;
 27842                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27843                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27844                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27845                                  ;				; BX = file or device handle
 27846                                  ;	;and	dl,devid_ISDEV ; 80h
 27847                                  ;	; 18/04/2023
 27848                                  ;	and	dl,80h ; devid_ISDEV
 27849                                  ;	mov	[SRCISDEV],dl		; set source info
 27850                                  ;	jz	short COPYLP		; source not a device
 27851                                  ;	cmp	byte [BINARY],0
 27852                                  ;	je	short COPYLP		; ascii device ok
 27853                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27854                                  ;	jmp	COPYERR
 27855                                  
 27856                                  COPYLP:
 27857                                  	; 26/03/2023
 27858 000041A1 8B1E[DEA1]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27859 000041A5 8B0E[059E]              	mov	cx,[BYTCNT]
 27860 000041A9 8B16[099E]              	mov	dx,[NXTADD]
 27861 000041AD 29D1                    	sub	cx,dx			; compute available space
 27862 000041AF 750E                    	jnz	short GOTROOM
 27863 000041B1 E8D102                  	call	FlshFil   ; MSDOS 6.0
 27864                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27865 000041B4 803E[3FA2]00            	cmp	byte [TERMREAD],0
 27866 000041B9 7565                    	jne	short CLOSESRC		; give up
 27867 000041BB 8B0E[059E]              	mov	cx,[BYTCNT]
 27868                                  GOTROOM:
 27869 000041BF 1E                      	push	ds
 27870 000041C0 8E1E[E69D]              	mov	ds,[TPA]
 27871 000041C4 B43F                    	mov	ah,READ ; 3Fh
 27872 000041C6 CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27873                                  				; BX = file handle,CX = number of bytes to read
 27874                                  				; DS:DX	-> buffer
 27875 000041C8 1F                      	pop	ds
 27876                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27877                                  	; 26/03/2023
 27878 000041C9 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27879 000041CB 89C1                    	mov	cx,ax			; get count
 27880 000041CD E351                    	jcxz	CLOSESRC		; no more to read
 27881 000041CF 803E[E0A1]00            	cmp	byte [SRCISDEV],0
 27882 000041D4 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27883 000041D6 803E[40A2]00            	cmp	byte [ASCII],0
 27884 000041DB 741B                    	je	short BINREAD
 27885                                  NOTESTA:
 27886 000041DD 89CA                    	mov	dx,cx
 27887 000041DF 8B3E[099E]              	mov	di,[NXTADD]
 27888 000041E3 B01A                    	mov	al,1Ah
 27889 000041E5 06                      	push	es
 27890 000041E6 8E06[E69D]              	mov	es,[TPA]		; scan for EOF
 27891 000041EA F2AE                    	repne	scasb
 27892 000041EC 07                      	pop	es
 27893 000041ED 7505                    	jnz	short USEALL
 27894 000041EF FE06[F79D]              	inc	byte [RDEOF]
 27895 000041F3 41                      	inc	cx
 27896                                  USEALL:
 27897 000041F4 29CA                    	sub	dx,cx
 27898 000041F6 89D1                    	mov	cx,dx
 27899                                  BINREAD:
 27900 000041F8 030E[099E]              	add	cx,[NXTADD]
 27901 000041FC 890E[099E]              	mov	[NXTADD],cx
 27902 00004200 3B0E[059E]              	cmp	cx,[BYTCNT]		; is buffer full?
 27903 00004204 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27904                                  	; 26/03/2023
 27905 00004206 E87C02                  	call	FlshFil
 27906                                  	;call	FLUSHFIL
 27907 00004209 803E[3FA2]00            	cmp	byte [TERMREAD],0
 27908 0000420E 7510                    	jne	short CLOSESRC		; give up
 27909 00004210 EB8F                    	jmp	short COPYLP
 27910                                  TESTDEV:
 27911 00004212 803E[E0A1]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27912 00004217 7407                    	je	short CLOSESRC
 27913 00004219 803E[F79D]00            	cmp	byte [RDEOF],0
 27914 0000421E 7481                    	je	short COPYLP		; on device, go till ^Z
 27915                                  CLOSESRC:
 27916 00004220 8B1E[DEA1]              	mov	bx,[SRCHAND]
 27917                                  CLOSESRC2:
 27918 00004224 B43E                    	mov	ah,CLOSE ; 3Eh
 27919 00004226 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27920                                  				; BX = file handle
 27921                                  CLOSESRCDEST_RETN:
 27922 00004228 C3                      	retn
 27923                                  
 27924                                  ; ---------------------------------------------------------------------------
 27925                                  
 27926                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27927                                  CLOSEDEST:
 27928                                  
 27929                                  	;	We are called to close the destination.
 27930                                  	;	We need to note whether or not there is any internal data left
 27931                                  	;	to be flushed out.
 27932                                  
 27933 00004229 803E[049E]00            	cmp	byte [DestClosed],0
 27934 0000422E 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27935 00004230 A0[FF9D]                	mov	al,[DestSwitch]
 27936 00004233 E8E803                  	call	SETASC			; check for b or a switch
 27937 00004236 742E                    	jz	short BINCLOS		;   on destination
 27938 00004238 8B1E[099E]              	mov	bx,[NXTADD]
 27939                                  ;
 27940                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27941                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27942                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27943                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27944                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27945                                  ;performance overhead on single ASCII file copies which now always involve
 27946                                  ;2 writes instead of 1 before. Is this really that important?
 27947                                  ;
 27948                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27949                                  ;M048;	jne	short PutZ
 27950                                  
 27951                                  	; 26/03/2023
 27952                                  	; MSDOS 3.3
 27953                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27954                                  	;jne	short PUTZ
 27955                                  
 27956                                  	; 26/03/2023
 27957 0000423C E83902                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27958 0000423F 7402                    	jz	short NOCONC
 27959                                  CONCHNG:
 27960 00004241 F9                      	stc
 27961 00004242 C3                      	retn
 27962                                  
 27963                                  NOCONC:	
 27964 00004243 31DB                    	xor	bx,bx
 27965                                  PUTZ:
 27966 00004245 1E                      	push	ds
 27967 00004246 8E1E[E69D]              	mov	ds,[TPA]
 27968 0000424A C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27969 0000424E 1F                      	pop	ds
 27970 0000424F FF06[099E]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27971 00004253 C606[3BA2]00            	mov	byte [NOWRITE],0
 27972 00004258 A1[3DA2]                	mov	ax,[WRITTEN]
 27973 0000425B 0306[099E]              	add	ax,[NXTADD]
 27974 0000425F 7205                    	jc	short BINCLOS	; > 1
 27975 00004261 83F801                  	cmp	ax,1
 27976 00004264 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27977                                  BINCLOS:
 27978 00004266 E80F02                  	call	TRYFLUSH
 27979 00004269 75D6                    	jnz	short CONCHNG
 27980                                  
 27981                                  	; 26/04/2023
 27982 0000426B 833E[3DA2]00            	cmp	word [WRITTEN],0
 27983                                  	; 26/03/2023
 27984 00004270 7503                    	jnz	short NO_FORGET
 27985                                  FORGETITJ:
 27986                                  	;jz	short FORGETIT	; never wrote nothing
 27987                                  	; 26/03/2023
 27988 00004272 E98500                  	jmp	FORGETIT ; 18/04/2023
 27989                                  NO_FORGET:			; wrote something
 27990 00004275 8B1E[7BA1]              	mov	bx,[DESTHAND]
 27991 00004279 8B0E[45A2]              	mov	cx,[CPTIME]
 27992 0000427D 8B16[43A2]              	mov	dx,[CPDATE]
 27993 00004281 803E[3AA2]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27994 00004286 7431                    	je	short DODCLOSE	; if no, copy date & time
 27995 00004288 B42C                    	mov	ah,Get_Time ; 2Ch
 27996 0000428A CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27997                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27998                                  				; DL = hundredths of seconds
 27999 0000428C D0E1                    	shl	cl,1
 28000 0000428E D0E1                    	shl	cl,1		; left justify min in cl
 28001 00004290 D1E1                    	shl	cx,1
 28002 00004292 D1E1                    	shl	cx,1
 28003 00004294 D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 28004 00004296 D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 28005 00004298 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 28006 0000429A 51                      	push	cx		; save packed time
 28007 0000429B B42A                    	mov	ah,Get_Date ; 2Ah
 28008 0000429D CD21                    	int	21h		; DOS -	GET CURRENT DATE
 28009                                  				; Return: DL = day,DH = month,	CX = year
 28010                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 28011 0000429F 81E9BC07                	sub	cx,1980
 28012 000042A3 86E9                    	xchg	ch,cl
 28013 000042A5 D1E1                    	shl	cx,1		; year to high 7 bits
 28014 000042A7 D0E6                    	shl	dh,1		; month to high 3 bits
 28015 000042A9 D0E6                    	shl	dh,1
 28016 000042AB D0E6                    	shl	dh,1
 28017 000042AD D0E6                    	shl	dh,1
 28018 000042AF D0E6                    	shl	dh,1		; most sig bit of month in carry
 28019 000042B1 80D500                  	adc	ch,0		; put that bit next to year
 28020 000042B4 08F2                    	or	dl,dh		; or low three of month into day
 28021 000042B6 88EE                    	mov	dh,ch		; get year and high bit of month
 28022 000042B8 59                      	pop	cx
 28023                                  DODCLOSE:
 28024 000042B9 83FB00                  	cmp	bx,0
 28025 000042BC 7E36                    	jle	short CLOSEDONE
 28026 000042BE B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 28027 000042C1 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 28028                                  				; BX = file handle,CX = time to be set
 28029                                  				; DX = date to be set
 28030                                  	; 26/03/2023
 28031                                  	; MSDOS 6.0
 28032 000042C3 721A                    	jc	short Cleanup_Err ;AN022; handle error
 28033                                  
 28034                                  	;	See if the destination has *anything* in it.
 28035                                  	;	If not, just close and delete it.
 28036                                  
 28037 000042C5 B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 28038 000042C8 31D2                    	xor	dx,dx
 28039 000042CA 89D1                    	mov	cx,dx
 28040 000042CC CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28041                                  			; AL = method: offset from end of file
 28042                                  	;	DX:AX is file size
 28043                                  
 28044 000042CE 09C2                    	or	dx,ax
 28045 000042D0 9C                      	pushf
 28046 000042D1 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 28047 000042D4 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28048                                  			; BX = file or device handle
 28049 000042D6 52                      	push	dx		; save them away
 28050 000042D7 B43E                    	mov	ah,CLOSE ; 3Eh
 28051 000042D9 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28052                                  			; BX = file handle
 28053 000042DB 5A                      	pop	dx
 28054                                  
 28055                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 28056                                  	; MSDOS 6.0
 28057 000042DC 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 28058 000042DE 9D                      	popf			;AN022; get the flags back
 28059                                  Cleanup_Err: 			;AN022;
 28060 000042DF E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 28061                                  	; 26/03/2023
 28062                                  	;call	DestDelete	;AN022; attempt to delete the target
 28063                                  	;jmp	short FILECLOSED
 28064                                  	;			;AN022; close the file
 28065                                  	; 26/03/2023
 28066                                  DestDel_fclosed:
 28067 000042E2 E82700                  	call	DestDelete
 28068                                  FILECLOSED:
 28069 000042E5 FE06[049E]              	inc	byte [DestClosed]
 28070                                  RET50:
 28071 000042E9 F8                      	clc
 28072 000042EA C3                      	retn
 28073                                  	
 28074                                  Close_Cont:			;AN022; no error - co
 28075                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28076 000042EB 9D                      	popf
 28077 000042EC 7506                    	jnz	short CLOSEDONE
 28078 000042EE F7C28000                	test	dx,80h		; is the destination a device?
 28079                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 28080                                  	;call	DestDelete
 28081                                  	;jmp	short FILECLOSED
 28082                                  	; 26/03/2023
 28083 000042F2 74EE                    	jz	short DestDel_fclosed
 28084                                  CLOSEDONE:
 28085 000042F4 FF06[129E]              	inc	word [FileCnt]
 28086                                  	; 26/03/2023
 28087 000042F8 EBEB                    	jmp	short FILECLOSED
 28088                                  	
 28089                                  ;FILECLOSED:
 28090                                  ;	inc	byte [DestClosed]
 28091                                  ;RET50:
 28092                                  	;clc
 28093                                  	;retn
 28094                                  
 28095                                  FORGETIT:
 28096 000042FA 8B1E[7BA1]              	mov	bx,[DESTHAND]
 28097 000042FE E8B8FF                  	call	DODCLOSE	 ; close the dest	
 28098 00004301 E80800                  	call	DestDelete
 28099 00004304 C706[129E]0000          	mov	word [FileCnt],0 ; no files transferred
 28100 0000430A EBDD                    	jmp	short RET50
 28101                                  
 28102                                  ; ---------------------------------------------------------------------------
 28103                                  
 28104                                  	; 26/03/2023
 28105                                  DestDelete:
 28106 0000430C BA[24A1]                	mov	dx,DestBuf
 28107 0000430F B441                    	mov	ah,Unlink ; 41h
 28108 00004311 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 28109                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 28110                                  			;		(no wildcards allowed)
 28111 00004313 C3                      	retn
 28112                                  
 28113                                  ; ---------------------------------------------------------------------------
 28114                                  
 28115                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28116                                  SOURCE_SET:
 28117 00004314 56                      	push	si
 28118 00004315 A1[5CA2]                	mov	ax,[STARTEL]
 28119 00004318 BE[E1A1]                	mov	si,ScanBuf	; adjust to copy
 28120 0000431B 29F0                    	sub	ax,si
 28121 0000431D BF[87A1]                	mov	di,SrcBuf
 28122 00004320 01F8                    	add	ax,di
 28123 00004322 A3[84A1]                	mov	[SrcTail],ax
 28124 00004325 880E[83A1]              	mov	[SrcSiz],cl	; save its size
 28125 00004329 41                      	inc	cx		; include the nul
 28126 0000432A F3A4                    	rep	movsb		; save this source
 28127 0000432C 883E[86A1]              	mov	[SrcInfo],bh	; save info about it
 28128 00004330 5E                      	pop	si
 28129 00004331 89E8                    	mov	ax,bp		; switches so far
 28130 00004333 E8E802                  	call	SETASC		; set a,b switches accordingly
 28131 00004336 E88EE9                  	call	SWITCH		; get any more switches on this arg
 28132                                  	;call	SETASC		; set
 28133                                  	;retn
 28134                                  	; 26/03/2023
 28135 00004339 E9E202                  	jmp	SETASC
 28136                                  
 28137                                  ; =============== S U B	R O U T	I N E =======================================
 28138                                  
 28139                                  ; MSDOS 6.0
 28140                                  
 28141                                  ;****************************************************************
 28142                                  ;*
 28143                                  ;* ROUTINE:	CleanupErr
 28144                                  ;*
 28145                                  ;* FUNCTION:	Issues extended error message for destination
 28146                                  ;*		if not alreay issued
 28147                                  ;*
 28148                                  ;* INPUT:	return from INT 21
 28149                                  ;*
 28150                                  ;* OUTPUT:	none
 28151                                  ;*
 28152                                  ;****************************************************************
 28153                                  
 28154                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28155                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28156                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 28157                                  CleanUpErr:	;proc near		;AN022;
 28158                                  
 28159 0000433C 803E[99A2]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 28160 00004341 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 28161 00004343 E8F8DE                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 28162 00004346 C706[06A1][24A1]        	mov	word [string_ptr_2],DestBuf 
 28163                                  					;AN022; get address of failed string
 28164 0000434C C606[0592]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28165                                  					;AN022; put number of subst in control block
 28166 00004351 E8E111                  	call	std_eprintf		;AN022; issue the error message
 28167                                  CleanupErr_Cont:			;AN022;
 28168                                  getansw_8:	; 12/06/2023
 28169 00004354 C3                      	retn				;AN022; return to caller
 28170                                  
 28171                                  ;CleanUpErr	endp			;AN022;
 28172                                  
 28173                                  
 28174                                  ; 12/06/2023
 28175                                  ; ---------------------------------------------------------------------------
 28176                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 28177                                  ; -----------------------------------------
 28178                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 28179                                  ; ---------------------------------------------------------------------------
 28180                                  
 28181                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28182                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:456Dh
 28183                                  
 28184                                  get_answer_YNA:
 28185 00004355 C606[58A2]00            	mov	byte [cox_dest_file],0	; clear validation flag
 28186 0000435A B80043                  	mov	ax,4300h
 28187 0000435D BA[24A1]                	mov	dx,DestBuf
 28188 00004360 CD21                    	int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
 28189                                  				; DS:DX	-> ASCIZ file name or directory
 28190                                  				; name without trailing	slash
 28191                                  	;jnc	short getansw_1
 28192                                  	;jmp	getansw_5
 28193                                  	; 12/06/2023
 28194 00004362 F5                      	cmc
 28195 00004363 73EF                    	jnc	short getansw_8 
 28196                                  getansw_1:
 28197 00004365 FE06[58A2]              	inc	byte [cox_dest_file]	; valid destination file
 28198 00004369 8D36[4CA2]              	lea	si,cox_sublist_buff
 28199 0000436D C7040B00                	mov	word [si],11		; sublist size, 11 bytes
 28200 00004371 C74402[24A1]            	mov	word [si+2],DestBuf	; sublist value	(pointer)
 28201 00004376 8C5C04                  	mov	[si+4],ds		; sublist segment
 28202                                  	;mov	byte [si+6],1		; sub id (N of %N)
 28203 00004379 C6440710                	mov	byte [si+7],10h		; data type flags
 28204                                  	;mov	byte [si+8],0		; maximum length (chars)
 28205                                  	;mov	byte [si+9],0		; minimum length (chars)
 28206                                  	;mov	byte [si+10],0		; pad field character (0)
 28207                                  	; 12/06/2023
 28208 0000437D 31C9                    	xor	cx,cx
 28209 0000437F 894C08                  	mov	[si+8],cx ; 0
 28210 00004382 884C0A                  	mov	[si+10],cl ; 0
 28211 00004385 FEC1                    	inc	cl
 28212 00004387 884C06                  	mov	[si+6],cl ; 1	
 28213                                  
 28214                                  	; 12/06/2023
 28215                                  	;lea	si,cox_sublist_buff
 28216 0000438A B84F04                  	mov	ax,1103			; message number
 28217                                  					; 'Overwrite %1 (Yes/No/All)?'
 28218 0000438D BB0200                  	mov	bx,2			; std error (file handle = 2)
 28219                                  	; 12/06/2023
 28220                                  	;mov	cx,1			; byte count
 28221                                  	; cx = 1
 28222                                  	;mov	dh,0FFh			; message class	(utility)
 28223                                  	;xor	dl,dl			; control flag = 0
 28224 00004390 31D2                    	xor	dx,dx
 28225 00004392 FECE                    	dec	dh  ; dh = 0FFh
 28226 00004394 E87314                  	call	SYSDISPMSG
 28227                                  	; 12/06/2023
 28228                                  	;xor	bx,bx
 28229                                  	; bh = 0
 28230                                  getansw_2:
 28231 00004397 B8080C                  	mov	ax,0C08h
 28232 0000439A CD21                    	int	21h		; DOS -	CLEAR KEYBOARD BUFFER
 28233                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 28234                                  	;cmp	al,0
 28235                                  	;jz	short getansw_2
 28236                                  	; 12/06/2023
 28237 0000439C 20C0                    	and	al,al
 28238 0000439E 74F7                    	jz	short getansw_2
 28239 000043A0 3C0D                    	cmp	al,0Dh
 28240 000043A2 743B                    	je	short getansw_4
 28241 000043A4 88C3                    	mov	bl,al
 28242 000043A6 88C2                    	mov	dl,al
 28243 000043A8 B82065                  	mov	ax,6520h
 28244 000043AB CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28245                                  				; AL = function	-
 28246 000043AD 3A16[DF6E]              	cmp	dl,[_Y_es]		; 'Y' ?
 28247 000043B1 740C                    	je	short getansw_3
 28248 000043B3 3A16[E06E]              	cmp	dl,[_N_o]		; 'N' ?
 28249 000043B7 7406                    	je	short getansw_3
 28250 000043B9 3A16[E16E]              	cmp	dl,[_A_ll]		; 'A' ?
 28251 000043BD 75D8                    	jne	short getansw_2
 28252                                  getansw_3:
 28253 000043BF 88DF                    	mov	bh,bl
 28254 000043C1 53                      	push	bx
 28255 000043C2 881E[DE6E]              	mov	[MSG_1104],bl
 28256 000043C6 B440                    	mov	ah,40h
 28257 000043C8 BB0200                  	mov	bx,2			; std error (file handle = 2)
 28258 000043CB B90100                  	mov	cx,1			; byte count
 28259 000043CE BA[DE6E]                	mov	dx,MSG_1104
 28260 000043D1 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28261                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28262 000043D3 B440                    	mov	ah,40h
 28263 000043D5 C606[DE6E]08            	mov	byte [MSG_1104],8	; backspace (move cursor to back)
 28264 000043DA CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28265                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28266 000043DC 5B                      	pop	bx
 28267 000043DD EBB8                    	jmp	short getansw_2
 28268                                  getansw_4:
 28269                                  	;cmp	bh,0
 28270                                  	;jz	short getansw_2
 28271                                  	; 12/06/2023
 28272 000043DF 08FF                    	or	bh,bh
 28273 000043E1 74B4                    	jz	short getansw_2
 28274 000043E3 88FA                    	mov	dl,bh
 28275 000043E5 B82065                  	mov	ax,6520h
 28276 000043E8 CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28277                                  				; AL = function	-
 28278 000043EA 52                      	push	dx
 28279 000043EB B82E04                  	mov	ax,1070			; message number
 28280 000043EE BB0200                  	mov	bx,2			; std error (file handle = 2)
 28281 000043F1 31C9                    	xor	cx,cx
 28282                                  	;mov	dh,0FFh			; message class	(utility)
 28283                                  	;xor	dl,dl
 28284                                  	; 12/06/2023
 28285 000043F3 31D2                    	xor	dx,dx
 28286 000043F5 FECE                    	dec	dh  ; dh = 0FFh
 28287 000043F7 E81014                  	call	SYSDISPMSG
 28288 000043FA 5A                      	pop	dx
 28289 000043FB 3A16[DF6E]              	cmp	dl,[_Y_es]
 28290 000043FF 740B                    	jz	short getansw_5
 28291 00004401 3A16[E06E]              	cmp	dl,[_N_o]
 28292 00004405 7406                    	jz	short getansw_6
 28293 00004407 C606[57A2]00            	mov	byte [cox_y_override],0
 28294                                  	; 12/06/2023
 28295                                  	;jmp	short $+2
 28296                                  getansw_5:
 28297                                  	; 12/06/2023
 28298                                  	;clc
 28299                                  	; cf = 0
 28300                                  	;jmp	short getansw_7
 28301                                  	; 12/06/2023
 28302 0000440C C3                      	retn
 28303                                  getansw_6:
 28304                                  gcpcmdo_2:	; 12/06/2023
 28305                                  gecpcmd_3:	; 12/06/2023
 28306 0000440D F9                      	stc
 28307                                  getansw_7:
 28308 0000440E C3                      	retn
 28309                                  
 28310                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28311                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:463Ah
 28312                                  init_copycmd_option:
 28313 0000440F C606[57A2]01            	mov	byte [cox_y_override],1 ; suppress copy overwrite confirmation
 28314 00004414 06                      	push	es
 28315 00004415 8E06[E49D]              	mov	es,[RESSEG]
 28316 00004419 268E06[FA03]            	mov	es,[es:EnvirSeg]
 28317 0000441E 8D36[2099]              	lea	si,copycmd		; "COPYCMD="
 28318 00004422 B90800                  	mov	cx,8
 28319 00004425 E83500                  	call	getenv_copycmd
 28320 00004428 7216                    	jc	short icpcmd_3
 28321 0000442A E82000                  	call	get_copycmd_option	; copycmd=/Y or copycmd=/-Y
 28322 0000442D 720F                    	jc	short icpcmd_2
 28323 0000442F 47                      	inc	di			; skip '/'
 28324 00004430 268A05                  	mov	al,[es:di]
 28325 00004433 24DF                    	and	al,0DFh			; convert to uppercase
 28326 00004435 3C59                    	cmp	al,'Y'
 28327 00004437 7505                    	jnz	short icpcmd_2
 28328                                  icpcmd_1:
 28329 00004439 C606[57A2]00            	mov	byte [cox_y_override],0	; clear copy overwrite question/confirmation
 28330                                  					; (don't suppress)
 28331                                  icpcmd_2:
 28332 0000443E 07                      	pop	es
 28333 0000443F C3                      	retn
 28334                                  icpcmd_3:				; ...
 28335 00004440 8E06[E49D]              	mov	es,[RESSEG]
 28336 00004444 803E[B001]00            	cmp	byte [cox_Y_option],0	; default (/Y) switch option (1 = enabled)
 28337 00004449 74F3                    	jz	short icpcmd_2
 28338 0000444B EBEC                    	jmp	short icpcmd_1
 28339                                  
 28340                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28341                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4679h
 28342                                  get_copycmd_option:
 28343 0000444D 26803D00                	cmp	byte [es:di],0
 28344 00004451 74BA                    	jz	short gcpcmdo_2
 28345 00004453 26803D2F                	cmp	byte [es:di],'/'
 28346 00004457 7403                    	jz	short gcpcmdo_1
 28347 00004459 47                      	inc	di
 28348 0000445A EBF1                    	jmp	short get_copycmd_option
 28349                                  gcpcmdo_1:
 28350                                  	; 12/06/2023
 28351                                  	;clc
 28352                                  	; cf = 0
 28353                                  	;jmp	short gcpcmdo_3
 28354                                  	; 12/06/2023
 28355 0000445C C3                      	retn
 28356                                  	; 12/06/2023
 28357                                  ;gcpcmdo_2:
 28358                                  ;	stc
 28359                                  ;gcpcmdo_3:
 28360                                  ;	retn
 28361                                  
 28362                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28363                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:468Dh
 28364                                  getenv_copycmd:
 28365 0000445D 31FF                    	xor	di,di
 28366 0000445F 30C0                    	xor	al,al
 28367                                  gecpcmd_1:
 28368                                  	;cmp	byte [es:di],0
 28369                                  	; 12/06/2023
 28370 00004461 263805                  	cmp	[es:di],al ; 0
 28371 00004464 74A7                    	jz	short gecpcmd_3
 28372 00004466 51                      	push	cx
 28373 00004467 56                      	push	si
 28374 00004468 F3A6                    	repe	cmpsb
 28375 0000446A 5E                      	pop	si
 28376 0000446B 59                      	pop	cx
 28377 0000446C 7409                    	jz	short gecpcmd_2 ; cf = 0
 28378 0000446E 51                      	push	cx
 28379 0000446F B90080                  	mov	cx,32768
 28380 00004472 F2AE                    	repne	scasb	; al = 0
 28381 00004474 59                      	pop	cx
 28382 00004475 EBEA                    	jmp	short gecpcmd_1
 28383                                  gecpcmd_2:
 28384                                  	;clc
 28385                                  	; 12/06/2023
 28386                                  	; cf = 0
 28387                                  	;jmp	short gecpcmd_4
 28388                                  	; 12/06/2023
 28389 00004477 C3                      	retn
 28390                                  	; 12/06/2023
 28391                                  ;gecpcmd_3:
 28392                                  ;	stc
 28393                                  ;gecpcmd_4:
 28394                                  ;	retn
 28395                                  
 28396                                  ;============================================================================
 28397                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 28398                                  ;============================================================================
 28399                                  ; 01/10/2018 - Retro DOS v3.0
 28400                                  
 28401                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 28402                                  
 28403                                  ; =============== S U B	R O U T	I N E =======================================
 28404                                  
 28405                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 28406                                  ;
 28407                                  ;	EXIT	ZR set if concatenate flag unchanged
 28408                                  
 28409                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28410                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 28411                                  
 28412                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28413                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46ADh
 28414                                  TRYFLUSH:
 28415 00004478 A0[F99D]                	mov	al,[Concat]
 28416 0000447B 50                      	push	ax
 28417                                  	;call	FLUSHFIL
 28418 0000447C E80600                  	call	FlshFil
 28419 0000447F 58                      	pop	ax
 28420 00004480 3A06[F99D]              	cmp	al,[Concat]
 28421 00004484 C3                      	retn
 28422                                  
 28423                                  ; =============== S U B	R O U T	I N E =======================================
 28424                                  
 28425                                  	; 26/03/2023
 28426                                  	; MSDOS 3.3
 28427                                  ;FLUSHFIL:
 28428                                  	;mov	al,[BINARY]
 28429                                  	;mov	ah,[ASCII]
 28430                                  	;push	ax
 28431                                  	;call	FLSHFIL
 28432                                  	;pop	ax
 28433                                  	;mov	[ASCII],ah
 28434                                  	;mov	[BINARY],al
 28435                                  	;retn
 28436                                  
 28437                                  ; =============== S U B	R O U T	I N E =======================================
 28438                                  
 28439                                  ;***	Flshfil - write out any data remaining in copy buffer.
 28440                                  ;
 28441                                  ;	Inputs:
 28442                                  ;	  [NXTADD] = No. of bytes to write
 28443                                  ;	  [CFLAG] <> 0 if file has been created
 28444                                  ;	Outputs:
 28445                                  ;	  [NXTADD] = 0
 28446                                  
 28447                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28448                                  	;
 28449                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 28450                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46BAh
 28451                                  FlshFil:
 28452 00004485 C606[3FA2]00            	mov	byte [TERMREAD],0
 28453 0000448A 803E[039E]00            	cmp	byte [CFLAG],0
 28454 0000448F 7403                    	jz	short NotExists
 28455 00004491 E99600                  	jmp	Exists
 28456                                  NotExists:
 28457 00004494 E8A101                  	call	BUILDDEST		; find out all about the destination
 28458 00004497 E8FA03                  	call	COMPNAME		; source and dest. the same?
 28459 0000449A 7519                    	jnz	short ProcDest		; if not, go ahead
 28460 0000449C 803E[E0A1]00            	cmp	byte [SRCISDEV],0
 28461 000044A1 7512                    	jnz	short ProcDest		; same name on device ok
 28462 000044A3 803E[F99D]00            	cmp	byte [Concat],0		; concatenation?
 28463 000044A8 BA[2C92]                	mov	dx,OVERWR_PTR
 28464                                  	;je	short COPERR		; not concatenating - overwrite error
 28465                                  	; 26/03/2023
 28466 000044AB 7503                    	jne	short No_Concat_Err
 28467 000044AD E91201                  	jmp	COPYERR
 28468                                  	
 28469                                  No_Concat_Err:	; concatenating
 28470 000044B0 C606[3BA2]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 28471                                  ProcDest:
 28472                                  	; MSDOS 6.0
 28473                                  	;mov	ax,(ExtOpen<<8)		; open the file
 28474                                  	; 26/03/2023
 28475 000044B5 B8006C                  	mov	ax,6C00h
 28476 000044B8 BE[24A1]                	mov	si,DestBuf		; get file name
 28477                                  ;M046
 28478                                  ; For writes, we want to deny writes by anyone else at the same time that we
 28479                                  ;are writing to it. For instance, on a network, 2 workstations could try
 28480                                  ;writing to the same file. Also, because we opened the source file with
 28481                                  ;DENY NONE, it is fine if the source and destination files are the same as
 28482                                  ;would happen when we append to an existing file.
 28483                                  
 28484                                  	; 26/03/2023
 28485                                  	;mov	bx,deny_write|write_open_mode
 28486 000044BB BB2100                  	mov	bx,21h			; get open mode for copy; M046
 28487 000044BE 31C9                    	xor	cx,cx			; no special files
 28488                                  	;mov	dx,write_open_flag	; set up open flags
 28489 000044C0 BA0101                  	mov	dx,101h	
 28490                                  
 28491 000044C3 803E[3BA2]00            	cmp	byte [NOWRITE],0
 28492 000044C8 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 28493                                  	;mov	dx,creat_open_flag	; set up create flags
 28494 000044CA BA1201                  	mov	dx,112h
 28495                                  
 28496                                  	; 26/03/2023
 28497                                  	; MSDOS 3.3
 28498                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 28499                                  	;cmp	byte [NOWRITE],0
 28500                                  	;jne	short DODESTOPEN
 28501                                  	;mov	ah,CREAT ; 3Ch
 28502                                  	;xor	cx,cx
 28503                                  ;DODESTOPEN:
 28504                                  	;mov	dx,DESTBUF
 28505                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 28506                                  	;		; CX = attributes for file
 28507                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 28508                                  
 28509                                  ; 26/03/2023
 28510                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 28511                                  ;	;mov	dx,FULDIRPTR
 28512                                  ;	;call	GET_EXT_ERR_NUMBER
 28513                                  ;	;jc	short COPERR
 28514                                  ;
 28515                                  ;	; 01/10/2018
 28516                                  ;	;jnc	short DEST_OPEN_OKAY
 28517                                  ;		
 28518                                  ;	;mov	dx,FULDIRPTR
 28519                                  ;	;call	GET_EXT_ERR_NUMBER
 28520                                  ;	;jmp	short COPERR
 28521                                  ;
 28522                                  ;	jc	short DEST_OPEN_ERROR
 28523                                  
 28524                                  	; 26/03/2023
 28525                                  DoDestOpen:
 28526 000044CD CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 28527                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 28528                                  			; BH = flags
 28529                                  			; CX = create attribute
 28530                                  			; DL = action if file exists/does not exists
 28531                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 28532                                  
 28533                                  ;	We assume that the error is normal.
 28534                                  ;	TriageError will correct the DX value appropriately.
 28535                                  	
 28536 000044CF 7311                    	jnc	short Dest_Open_Okay
 28537                                  Xa_Set_Error:				;AN030; error occurred on XA
 28538 000044D1 E86ADD                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 28539                                  
 28540                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 28541                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 28542                                  Ext_Err_Set:				;AN030;
 28543 000044D4 C706[06A1][24A1]        	mov	word [string_ptr_2],DestBuf
 28544                                  					;AN000; get address of failed string
 28545 000044DA C606[0592]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28546                                  					;AN030; put number of subst in control block
 28547                                  CopErrJ2:				;AN030;
 28548 000044DF E9E000                  	jmp	COPYERR			;AN030; go issue message
 28549                                  
 28550                                  ;DEST_OPEN_OKAY:
 28551                                  	; 26/03/2023
 28552                                  Dest_Open_Okay:
 28553 000044E2 A3[7BA1]                	mov	[DESTHAND],ax		; save handle
 28554 000044E5 C606[039E]01            	mov	byte [CFLAG],1		; destination now exists
 28555 000044EA 89C3                    	mov	bx,ax
 28556 000044EC B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 28557 000044EF CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 28558                                  			   	; BX = file or device handle
 28559                                  
 28560 000044F1 8816[7DA1]              	mov	[DESTISDEV],dl		; set dest info
 28561                                  	; 18/04/2023
 28562 000044F5 F6C280                  	test	dl,80h
 28563                                  	;test	dl,devid_ISDEV
 28564 000044F8 7430                    	jz	short Exists		; Dest not a device
 28565                                  
 28566                                  ;	Destination is device.
 28567                                  
 28568 000044FA A0[FF9D]                	mov	al,[DestSwitch]
 28569                                  	; 26/03/2023
 28570 000044FD 240C                    	and	al,0Ch
 28571                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 28572 000044FF 7509                    	jnz	short TestBoth
 28573 00004501 A0[40A2]                	mov	al,[ASCII]		; neither set, use current setting
 28574 00004504 0A06[3CA2]              	or	al,[BINARY]
 28575 00004508 7416                    	jz	short ExSetA		; neither set, default to ascii
 28576                                  TestBoth:
 28577 0000450A 7A1E                    	jpe	short Exists		; both are set, ignore
 28578 0000450C A808                    	test	al,8
 28579                                  	;test	al,SWITCHB
 28580 0000450E 741A                    	jz	short Exists
 28581                                  	;mov	ax,(IOCTL shl 8) or 1
 28582 00004510 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28583 00004513 30F6                    	xor	dh,dh
 28584                                  	; 18/04/2023
 28585 00004515 80CA20                  	or	dl,20h
 28586                                  	;or	dl,devid_RAW
 28587 00004518 8816[7DA1]              	mov	[DESTISDEV],dl
 28588 0000451C CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28589                                  			; BX = device handle,DH = 0
 28590                                  			; DL = device information to set (bits 0-7 from	function 0)
 28591 0000451E EB0A                    	jmp	short Exists
 28592                                  
 28593                                  	; 26/03/2023
 28594                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28595                                  ;DEST_OPEN_ERROR:
 28596                                  	;mov	dx,FULDIRPTR
 28597                                  	;call	GET_EXT_ERR_NUMBER
 28598                                  ;COPERR:
 28599                                  	; 26/03/2023
 28600                                  ;CopyErrj:
 28601                                  	;jmp	short COPYERR
 28602                                  
 28603                                  ExSetA:
 28604                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28605                                  
 28606 00004520 C606[40A2]04            	mov	byte [ASCII],4
 28607                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28608 00004525 800E[3AA2]04            	or	byte [INEXACT],4
 28609                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28610                                  Exists:
 28611 0000452A 803E[3BA2]00            	cmp	byte [NOWRITE],0
 28612 0000452F 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28613 00004531 803E[7CA0]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28614 00004536 741D                    	jz	short NoChecking
 28615 00004538 E85903                  	call	COMPNAME		; source and dest. the same?
 28616 0000453B 7518                    	jnz	short NoChecking	; if not, go ahead
 28617 0000453D 803E[E0A1]00            	cmp	byte [SRCISDEV],0
 28618 00004542 7511                    	jne	short NoChecking	; same name on device ok
 28619                                  
 28620                                  ;	At this point we know in append (would have gotten overwrite error
 28621                                  ;	on first destination create otherwise), and user trying to specify
 28622                                  ;	destination which has been scribbled already (if dest had been named
 28623                                  ;	first, NoWrite would be set).
 28624                                  
 28625 00004544 BA[2F92]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28626                                  	;invoke	Std_EprintF		;ac022;
 28627                                  	; 26/03/2023
 28628 00004547 E8EB0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28629                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28630 0000454A C706[099E]0000          	mov	word [NXTADD],0		; set return
 28631 00004550 FE06[3FA2]              	inc	byte [TERMREAD]		; tell read to give up
 28632                                  Ret60:
 28633 00004554 C3                      	retn
 28634                                  
 28635                                  NoChecking:
 28636 00004555 8B1E[7BA1]              	mov	bx,[DESTHAND]		; get handle
 28637 00004559 31C9                    	xor	cx,cx
 28638 0000455B 870E[099E]              	xchg	cx,[NXTADD]
 28639 0000455F E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28640 00004561 FF06[3DA2]              	inc	word [WRITTEN]		; flag that we wrote something
 28641 00004565 803E[3BA2]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28642 0000456A 7514                    	jnz	short SeekEnd
 28643 0000456C 31D2                    	xor	dx,dx
 28644 0000456E 1E                      	push	ds
 28645 0000456F 8E1E[E69D]              	mov	ds,[TPA]
 28646 00004573 B440                    	mov	ah,Write ; 40h
 28647 00004575 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28648                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28649 00004577 1F                      	pop	ds
 28650 00004578 BA[1792]                	mov	dx,NOSPACE_PTR
 28651                                  	;jc	short COPERRP		; failure
 28652                                  	; 26/03/2023
 28653                                  	; MSDOS 6.0
 28654 0000457B 7326                    	jnc	short NoChecking2
 28655 0000457D E951FF                  	jmp	Xa_Set_Error
 28656                                  
 28657                                  	; 18/04/2023
 28658                                  	; 26/03/2023
 28659                                  SeekEnd:
 28660 00004580 31D2                    	xor	dx,dx
 28661 00004582 87D1                    	xchg	dx,cx
 28662                                  	;mov	ax,(LSEEK shl 8) or 1
 28663 00004584 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28664 00004587 CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28665                                  				; AL = method: offset from present location
 28666                                  
 28667                                  	; 26/03/2023
 28668                                  	; MSDOS 6.0
 28669                                  
 28670                                  ;	Save the file pointer in DX:AX to restore the file
 28671                                  ;	with in case the copy should fail.
 28672                                  
 28673 00004589 A3[47A2]                	mov	[OFilePtr_Lo],ax
 28674 0000458C 8916[49A2]              	mov	[OFilePtr_Hi],dx
 28675                                  
 28676                                  	; 26/03/2023
 28677                                  	; MSDOS 3.3  MSDOS 6.0
 28678                                  
 28679 00004590 803E[F79D]00            	cmp	byte [RDEOF],0
 28680 00004595 740B                    	jz	short Retz60
 28681                                  
 28682                                  ;	^Z has been read - we must set the file size to the current
 28683                                  ;	file pointer location
 28684                                  
 28685 00004597 B440                    	mov	ah,Write ; 40h
 28686 00004599 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28687                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28688                                  
 28689                                  	; 26/03/2023
 28690                                  	; MSDOS 6.0
 28691 0000459B 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28692                                  
 28693                                  ;	Make note that ^Z was removed, in case the
 28694                                  ;	copy should fail and we need to restore the file.
 28695                                  
 28696 0000459D C606[4BA2]1A            	mov	byte [OCtrlZ],1Ah
 28697                                  Retz60:
 28698 000045A2 C3                      	retn
 28699                                  
 28700                                  NoChecking2:
 28701 000045A3 29C1                    	sub	cx,ax
 28702 000045A5 74AD                    	jz	short Ret60		; wrote all supposed to
 28703                                  	; 18/04/2023
 28704 000045A7 F606[7DA1]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28705                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28706 000045AC 7414                    	jz	short COPYERR		; is a file, error
 28707 000045AE F606[7DA1]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28708                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28709 000045B3 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28710 000045B5 803E[3AA2]00            	cmp	byte [INEXACT],0
 28711 000045BA 7598                    	jnz	short Ret60		; inexact so ok
 28712 000045BC 49                      	dec	cx
 28713                                  ;Retz60:
 28714 000045BD 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 28715                                  
 28716                                  DevWrtErr:
 28717 000045BF BA[9A93]                	mov	dx,DEVWMES_PTR
 28718                                  	; 26/03/2023
 28719                                  COPYERR:
 28720                                  	;invoke	Std_EPrintF		;AC022;
 28721 000045C2 E8700F                  	call	std_eprintf  ; MSDOS 6.0
 28722                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28723                                  CopErrP:
 28724 000045C5 FE06[049E]              	inc	byte [DestClosed]
 28725 000045C9 803E[039E]00            	cmp	byte [CFLAG],0
 28726 000045CE 7448                    	jz	short EndCopyJ		; never actually got it open
 28727 000045D0 8B1E[7BA1]              	mov	bx,[DESTHAND]
 28728 000045D4 83FB00                  	cmp	bx,0
 28729 000045D7 7E33                    	jle	short NoClose
 28730                                  
 28731                                  ;	Check to see if we should save part of the destination file.
 28732                                  
 28733                                  	; 26/03/2023
 28734                                  	; MSDOS 6.0
 28735 000045D9 8B0E[49A2]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 28736 000045DD 8B16[47A2]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 28737                                  			
 28738 000045E1 89C8                    	mov	ax,cx
 28739 000045E3 09D0                    	or	ax,dx
 28740 000045E5 7421                    	jz	short ceClose		; null file ptr means nothing to save
 28741                                  
 28742                                  ;	Destination was also the first source. Do the best we can to
 28743                                  ;	restore it. Truncate it back to the size we took from it (which
 28744                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 28745                                  ;	file). If a Ctrl-Z was originally read, put it back.
 28746                                  
 28747 000045E7 B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 28748 000045EA CD21                    	int	21h
 28749                                  
 28750 000045EC 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 28751 000045EE B440                    	mov	ah,Write ; 40h
 28752 000045F0 CD21                    	int	21h			; truncate file
 28753                                  
 28754 000045F2 803E[4BA2]00            	cmp	byte [OCtrlZ],0
 28755 000045F7 7408                    	je	short ceClose0		; no ctrl-z removed from original
 28756 000045F9 41                      	inc	cx			; CX = # bytes to write = 1
 28757 000045FA BA[4BA2]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 28758 000045FD B440                    	mov	ah,Write ; 40h
 28759 000045FF CD21                    	int	21h			; write ctrl-z
 28760                                  ceClose0:
 28761 00004601 B43E                    	mov	ah,CLOSE ; 3Eh
 28762 00004603 CD21                    	int	21h			; close it
 28763                                  ;;	;mov	byte [CFLAG],0
 28764 00004605 E9ECF8                  	jmp	ENDCOPY			; and go home
 28765                                  
 28766                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28767                                  ceClose:
 28768 00004608 B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 28769 0000460A CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28770                                  				; BX = file handle
 28771                                  NoClose:
 28772 0000460C BA[24A1]                	mov	dx,DestBuf
 28773 0000460F B441                    	mov	ah,Unlink ; 41h 	; and delete it
 28774 00004611 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 28775                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 28776 00004613 C606[039E]00            	mov	byte [CFLAG],0
 28777                                  EndCopyJ:
 28778 00004618 E9D9F8                  	jmp	ENDCOPY
 28779                                  
 28780                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 28781 0000461B E9B3FE                  	jmp	Xa_Set_Error
 28782                                  
 28783                                  ;============================================================================
 28784                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 28785                                  ;============================================================================
 28786                                  ; 01/10/2018 - Retro DOS v3.0
 28787                                  
 28788                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 28789                                  
 28790                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28791                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 28792                                  
 28793                                  ; =============== S U B	R O U T	I N E =======================================
 28794                                  
 28795                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 28796                                  ;
 28797                                  ;	Given switch vector in AX,
 28798                                  ;	  Set Ascii flag if /a is set
 28799                                  ;	  Clear Ascii flag if /b is set
 28800                                  ;	  Binary set if /b specified
 28801                                  ;	  Leave Ascii unchanged if neither or both are set
 28802                                  ; 	Also sets Inexact if Ascii is ever set. 
 28803                                  ;	AL = Ascii on exit, flags set
 28804                                  
 28805                                  	; 26/03/2023
 28806                                  SETASC:
 28807                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 28808 0000461E 240C                    	and	al,0Ch ; 4+8
 28809 00004620 7A10                    	jpe	short LOADSW	; even parity - both or neither
 28810 00004622 50                      	push	ax
 28811                                  	;and	al,SWITCHB  ; 8
 28812 00004623 2408                    	and	al,8
 28813 00004625 A2[3CA2]                	mov	[BINARY],al
 28814 00004628 58                      	pop	ax
 28815                                  	;and	al,SWITCHA
 28816 00004629 2404                    	and	al,4	
 28817 0000462B A2[40A2]                	mov	[ASCII],al
 28818 0000462E 0806[3AA2]              	or	[INEXACT],al
 28819                                  LOADSW:
 28820 00004632 A0[40A2]                	mov	al,[ASCII]
 28821 00004635 08C0                    	or	al,al
 28822 00004637 C3                      	retn
 28823                                  
 28824                                  ; =============== S U B	R O U T	I N E =======================================
 28825                                  
 28826                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28827                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 28828                                  BUILDDEST:
 28829 00004638 803E[1FA1]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 28830 0000463D 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 28831 0000463F BF[C69C]                	mov	di,USERDIR1
 28832 00004642 BD[1FA1]                	mov	bp,DestVars
 28833 00004645 E8E000                  	call	BUILDPATH
 28834 00004648 E881E3                  	call	RestUDir1
 28835                                  
 28836                                  ;	We now know all about the destination
 28837                                  
 28838                                  KNOWABOUTDEST:
 28839 0000464B 30C0                    	xor	al,al
 28840 0000464D 8606[7EA1]              	xchg	al,[FIRSTDEST]
 28841 00004651 08C0                    	or	al,al
 28842 00004653 7503                    	jnz	short FIRSTDST
 28843 00004655 E98D00                  	jmp	NOFIRSTDEST
 28844                                  
 28845                                  FIRSTDST:
 28846                                  ;	Create an fcb of the original dest.
 28847                                  
 28848 00004658 8B36[21A1]              	mov	si,[DestTail]
 28849 0000465C BF[DC9F]                	mov	di,DestFcb
 28850 0000465F B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 28851 00004662 CD21                    	int	21h		; DOS -	PARSE FILENAME
 28852                                  				; DS:SI	-> string to parse
 28853                                  				; ES:DI	-> buffer to fill with unopened	FCB
 28854                                  				; AL = bit mask	to control parsing
 28855 00004664 803C00                  	cmp	byte [si],0
 28856 00004667 7406                    	jz	short GOODPARSE
 28857                                  
 28858                                  	; 27/03/2023	
 28859                                  	; MSDOS 6.0
 28860                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 28861                                  	
 28862 00004669 BA[1D92]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 28863 0000466C E953FF                  	jmp	COPYERR			;AN052;
 28864                                  GOODPARSE:
 28865 0000466F A1[24A1]                	mov	ax,[DestBuf]		; AX = possible "d:"
 28866 00004672 80FC3A                  	cmp	ah,':'
 28867 00004675 7402                    	jz	short DRVSPEC4
 28868 00004677 B040                    	mov	al,'@'  ; 40h
 28869                                  DRVSPEC4:
 28870                                  ;	AX = "d:" for following FCB drive computation
 28871                                  
 28872 00004679 8A0E[40A2]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 28873 0000467D 0C20                    	or	al,20h
 28874 0000467F 2C60                    	sub	al,60h
 28875 00004681 A2[DC9F]                	mov	[DestFcb],al		; store drive # in FCB
 28876                                  
 28877                                  ;*	Figure out what copy mode we're in.
 28878                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 28879                                  ;	+n stands for additional sources delimited by +'s.
 28880                                  ;
 28881                                  ;	copy a b	not concatenating
 28882                                  ;	copy a *	not concatenating
 28883                                  ;	copy * a	concatenating
 28884                                  ;	copy * *	not concatenating
 28885                                  ;	copy a+n b	concatenating
 28886                                  ;	copy *+n a	concatenating
 28887                                  ;	copy *+n *	concatenating, Mel Hallerman style
 28888                                  
 28889                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28890                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28891                                  
 28892 00004684 A0[23A1]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28893 00004687 8A26[86A1]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28894 0000468B 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28895 0000468E 08C0                    	or	al,al
 28896 00004690 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28897                                  
 28898                                  ;	Destination is wildcarded.
 28899                                  	
 28900 00004692 38E0                    	cmp	al,ah
 28901 00004694 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28902                                  
 28903                                  ;	Source and destination are both wildcarded.
 28904                                  
 28905 00004696 803E[41A2]00            	cmp	byte [PLUS],0
 28906 0000469B 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28907                                  
 28908                                  ;	Source and destination are wildcarded, and source includes +'s.
 28909                                  ;	It's Mel Hallorman copy time.
 28910                                  
 28911 0000469D FE06[7FA1]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28912 000046A1 30C0                    	xor	al,al
 28913 000046A3 EB06                    	jmp	short SETCONC
 28914                                  
 28915                                  NOTMELCOPY:
 28916 000046A5 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28917 000046A7 20E0                    	and	al,ah
 28918 000046A9 D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28919                                  					;   (implies concatenation)
 28920                                  SETCONC:
 28921 000046AB 0A06[41A2]              	or	al,[PLUS]		; "+" always infers concatenation
 28922                                  
 28923                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28924                                  
 28925 000046AF A2[F99D]                	mov	[Concat],al
 28926 000046B2 D0E0                    	shl	al,1
 28927 000046B4 D0E0                    	shl	al,1
 28928 000046B6 A2[3AA2]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28929 000046B9 803E[3CA2]00            	cmp	byte [BINARY],0
 28930 000046BE 7525                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 28931                                  
 28932                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 28933                                  	; MSDOS 6.0 (MSDOS.50)
 28934                                  	;mov	[ASCII],al		; otherwise, concatenate in ascii mode
 28935                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:48FAh
 28936 000046C0 0806[40A2]              	or	[ASCII],al	
 28937                                  
 28938 000046C4 08C9                    	or	cl,cl
 28939 000046C6 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 28940 000046C8 08C0                    	or	al,al
 28941 000046CA 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28942                                  
 28943                                  ;	At this point there may already be binary read data in the read
 28944                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28945                                  ;	amount of data in the buffer correctly.
 28946                                  
 28947 000046CC 8B0E[099E]              	mov	cx,[NXTADD]
 28948 000046D0 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28949 000046D2 B01A                    	mov	al,1Ah
 28950 000046D4 06                      	push	es
 28951 000046D5 31FF                    	xor	di,di
 28952 000046D7 8E06[E69D]              	mov	es,[TPA]
 28953 000046DB F2AE                    	repne	scasb			; scan for EOF
 28954 000046DD 07                      	pop	es
 28955 000046DE 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28956 000046E0 4F                      	dec	di			; point at ^z
 28957 000046E1 893E[099E]              	mov	[NXTADD],di		; new buffer length
 28958                                  
 28959                                  NOFIRSTDEST:
 28960 000046E5 BB[20A0]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28961 000046E8 803E[F99D]00            	cmp	byte [Concat],0
 28962 000046ED 7403                    	jz	short GOTCHRSRC		; Not a concat
 28963 000046EF BB[66A0]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28964                                  GOTCHRSRC:
 28965 000046F2 BE[DD9F]                	mov	si,DestFcb+1		; Original dest name
 28966 000046F5 8B3E[21A1]              	mov	di,[DestTail]		; Where to put result
 28967                                  
 28968                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28969                                  
 28970                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28971                                  BUILDNAME:
 28972 000046F9 B90800                  	mov	cx,8
 28973                                  BUILDMAIN:
 28974 000046FC AC                      	lodsb
 28975 000046FD 3C3F                    	cmp	al,'?'
 28976 000046FF 7502                    	jne	short NOTAMBIG
 28977 00004701 8A07                    	mov	al,[bx]
 28978                                  NOTAMBIG:
 28979 00004703 3C20                    	cmp	al,' '
 28980 00004705 7401                    	je	short NOSTORE
 28981 00004707 AA                      	stosb
 28982                                  NOSTORE:
 28983 00004708 43                      	inc	bx
 28984 00004709 E2F1                    	loop	BUILDMAIN
 28985 0000470B B103                    	mov	cl,3
 28986                                  	;mov	al,' ' ; 20h
 28987                                  	;cmp	[si],al
 28988                                  	; 27/03/2023
 28989 0000470D 803C20                  	cmp	byte [si],20h ; ' '
 28990 00004710 7412                    	je	short ENDDEST		; No extension
 28991                                  	;mov	al,[DOT_CHR]
 28992                                  	; 27/03/2023
 28993 00004712 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28994 00004714 AA                      	stosb
 28995                                  BUILDEXT:
 28996 00004715 AC                      	lodsb
 28997 00004716 3C3F                    	cmp	al,'?'
 28998 00004718 7502                    	jne	short NOTAMBIGE
 28999 0000471A 8A07                    	mov	al,[bx]
 29000                                  NOTAMBIGE:
 29001 0000471C 3C20                    	cmp	al,' '
 29002 0000471E 7401                    	je	short NOSTOREE
 29003 00004720 AA                      	stosb
 29004                                  NOSTOREE:
 29005 00004721 43                      	inc	bx
 29006 00004722 E2F1                    	loop	BUILDEXT
 29007                                  ENDDEST:
 29008 00004724 30C0                    	xor	al,al
 29009 00004726 AA                      	stosb				; NUL terminate
 29010 00004727 C3                      	retn
 29011                                  
 29012                                  ; =============== S U B	R O U T	I N E =======================================
 29013                                  
 29014                                  	; 28/03/2023
 29015                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29016                                  	;
 29017                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29018                                  BUILDPATH:
 29019 00004728 F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 29020 0000472C 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 29021 0000472E 89EA                    	mov	dx,bp			; Set DX to spec
 29022 00004730 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 29023                                  
 29024                                  	; 27/03/2023
 29025                                  	; MSDOS 6.0
 29026 00004733 57                      	push	di			;AN000;
 29027 00004734 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 29028                                  	;mov	bx,deny_none|read_open_mode
 29029 00004737 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 29030 0000473A 31C9                    	xor	cx,cx			;AN000; no special files
 29031 0000473C 89D6                    	mov	si,dx			;AN030; get file name offset
 29032                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 29033 0000473E BA0101                  	mov	dx,101h
 29034 00004741 CD21                    	INT	21h
 29035 00004743 5F                      	pop	di			;AN000;
 29036 00004744 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 29037 00004746 E805DB                  	call	get_ext_error_number	;AN022; get the extended error
 29038                                  	;cmp	ax,2
 29039 00004749 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 29040 0000474C 7423                    	jz	short NOTPFILE		;AN022;
 29041                                  	;cmp	ax,3
 29042 0000474E 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29043 00004751 741E                    	jz	short NOTPFILE		;AN022;
 29044                                  	;cmp	ax,5
 29045 00004753 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29046 00004756 7419                    	jz	short NOTPFILE		;AN022;
 29047 00004758 E936D8                  	jmp	extend_setup		;AN022; exit with error
 29048                                  
 29049                                  	; 27/03/2023
 29050                                  	; MSDOS 3.3
 29051                                  	;mov	ax,OPEN*256 ; 3D00h
 29052                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 29053                                  	;			; DS:DX	-> ASCIZ filename
 29054                                  	;			; AL = access mode
 29055                                  	;			; 0 - read
 29056                                  	;jc	short NOTPFILE
 29057                                  
 29058                                  PURE_FILE:
 29059 0000475B 89C3                    	mov	bx,ax
 29060 0000475D B80044                  	mov	ax,IOCTL*256 ; 4400h
 29061 00004760 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 29062                                  				; BX = file or device handle
 29063 00004762 B43E                    	mov	ah,CLOSE ;3Eh
 29064 00004764 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 29065                                  				; BX = file handle
 29066                                  	; 18/04/2023
 29067 00004766 F6C280                  	test	dl,80h
 29068                                  	;test	dl,devid_ISDEV ; test dl,80h
 29069 00004769 7553                    	jnz	short ISADEV
 29070 0000476B F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 29071 0000476F 744D                    	jz	short ISADEV
 29072                                  NOTPFILE:
 29073 00004771 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 29074                                  	
 29075                                  	; 27/03/2023	
 29076                                  	; MSDOS 6.0
 29077 00004774 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 29078 00004777 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 29079                                  
 29080 00004779 80FE3A                  	cmp	dh,':'
 29081 0000477C 7402                    	je	short DRVSPEC5
 29082                                  SET_DRIVE_SPEC:
 29083 0000477E B240                    	mov	dl,'@' ; 40h
 29084                                  DRVSPEC5:
 29085 00004780 80CA20                  	or	dl,20h
 29086 00004783 80EA60                  	sub	dl,60h		; A = 1
 29087 00004786 E870E3                  	call	SAVUDIR1
 29088                                  	
 29089                                  	; 27/03/2023
 29090                                  	; MSDOS 6.0
 29091 00004789 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 29092 0000478B E8C0DA                  	call	get_ext_error_number	;AN022; get the extended error
 29093 0000478E E900D8                  	jmp	extend_setup		;AN022; exit with error
 29094                                  
 29095                                  CURDIR_OK:
 29096 00004791 89EA                    	mov	dx,bp
 29097                                  	;add	dx,5
 29098 00004793 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 29099                                  	;mov	bh,[bp+4]
 29100 00004796 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29101 00004799 80E706                  	and	bh,6
 29102 0000479C 80FF06                  	cmp	bh,6			; Ambig and path ?
 29103 0000479F 7518                    	jne	short CHECKAMB		; jmp if no
 29104                                  	;mov	si,[bp+2]
 29105 000047A1 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29106 000047A4 B33A                    	mov	bl,':'
 29107 000047A6 385CFE                  	cmp	[si-2],bl
 29108 000047A9 7506                    	jne	short KNOWNOTSPEC
 29109                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 29110                                  					; Know is d:/file
 29111                                  	;mov	byte [bp+0],2
 29112 000047AB C6460002                	mov	byte [bp],2
 29113 000047AF EB05                    	jmp	short DOPCDJ
 29114                                  KNOWNOTSPEC:
 29115                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 29116                                  					; Know is path/file
 29117                                  	;mov	byte [bp+0],1		
 29118 000047B1 C6460001                	mov	byte [bp],1
 29119 000047B5 4E                      	dec	si
 29120                                  DOPCDJ:
 29121 000047B6 E98300                  	jmp	DOPCD
 29122                                  CHECKAMB:
 29123 000047B9 80FF02                  	cmp	bh,2
 29124 000047BC 7505                    	jnz	short CHECKCD
 29125                                  ISSIMPFILE:
 29126                                  ISADEV:
 29127                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29128                                  	;mov	byte [bp+0],0		
 29129 000047BE C6460000                	mov	byte [bp],0
 29130 000047C2 C3                      	retn
 29131                                  CHECKCD:
 29132 000047C3 E868EA                  	call	SetRest1
 29133 000047C6 B43B                    	mov	ah,CHDir ; 3Bh
 29134 000047C8 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29135                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29136 000047CA 7239                    	jb	short NOTPDIR
 29137 000047CC 89D7                    	mov	di,dx
 29138 000047CE 31C0                    	xor	ax,ax
 29139 000047D0 89C1                    	mov	cx,ax
 29140 000047D2 49                      	dec	cx
 29141                                  	; 14/06/2023
 29142                                  	;repne	scasb	 ; MSDOS 3.3
 29143                                  
 29144                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29145                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 29146                                  	; MSDOS 6.0
 29147                                  Kloop:					;AN000;  3/3/KK
 29148 000047D3 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 29149 000047D6 47                      	inc	di			;AN000;  3/3/KK
 29150 000047D7 08C0                    	or	al,al			;AN000;  3/3/KK
 29151 000047D9 740C                    	jz	short DONE		;AN000;  3/3/KK
 29152 000047DB 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 29153 000047DD E82AE1                  	call	testkanj		;AN000;  3/3/KK
 29154 000047E0 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 29155 000047E2 47                      	inc	di			;AN000;  3/3/KK
 29156 000047E3 FEC4                    	inc	ah			;AN000;  3/3/KK
 29157 000047E5 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 29158                                  DONE:
 29159 000047E7 4F                      	dec	di
 29160 000047E8 A0[E99D]                	mov	al,[DIRCHAR]
 29161                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29162                                  	;mov	byte [bp+0],2
 29163 000047EB C6460002                	mov	byte [bp],2
 29164                                  	; 27/03/2023
 29165                                  	; MSDOS 6.0
 29166 000047EF 08E4                    	or	ah,ah			;AN000; 3/3/KK
 29167 000047F1 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 29168                                  	;
 29169 000047F3 3A45FF                  	cmp	al,[di-1]
 29170 000047F6 7405                    	jz	short GOTSRCSLSH
 29171                                  _STORE_PCHAR:
 29172 000047F8 AA                      	stosb
 29173                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 29174                                  	;mov	byte [bp+0],1
 29175 000047F9 C6460001                	mov	byte [bp],1
 29176                                  GOTSRCSLSH:
 29177                                  	;or	byte [bp+4],6
 29178 000047FD 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 29179 00004801 E87400                  	call	SETSTARS
 29180                                  NOTPDIR_RETN:
 29181 00004804 C3                      	retn
 29182                                  
 29183                                  	; 28/03/2023
 29184                                  NOTPDIR:
 29185                                  	; MSDOS 6.0
 29186 00004805 E846DA                  	call	get_ext_error_number	;AN022; get the extended error
 29187                                  	;cmp	ax,3
 29188 00004808 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29189 0000480B 7405                    	je	short NOTPDIR_TRY	;AN022;
 29190                                  	;cmp	ax,5
 29191 0000480D 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29192 00004810 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 29193                                  NOTPDIR_TRY:
 29194                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29195                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29196                                  	;mov	byte [bp+0],0
 29197 00004812 C6460000                	mov	byte [bp],0
 29198                                  	;mov	bh,[bp+4]
 29199 00004816 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29200 00004819 F6C704                  	test	bh,4
 29201 0000481C 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 29202                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29203                                  	;mov	byte [bp+0],2		
 29204 0000481E C6460002                	mov	byte [bp],2
 29205                                  	;mov	si,[bp+2]
 29206 00004822 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29207 00004825 803C00                  	cmp	byte [si],0
 29208 00004828 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 29209                                  	;mov	bl,[DOT_CHR]
 29210                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 29211                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 29212 0000482A B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 29213 0000482C 381C                    	cmp	[si],bl
 29214 0000482E 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 29215 00004830 B33A                    	mov	bl,':'  ; 3Ah
 29216 00004832 385CFE                  	cmp	[si-2],bl
 29217 00004835 7405                    	je	short DOPCD		; Know d:/file
 29218                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 29219                                  					; Know path/file
 29220                                  	;mov	byte [bp+0],1
 29221 00004837 C6460001                	mov	byte [bp],1
 29222 0000483B 4E                      	dec	si			; Point at last '/'
 29223                                  DOPCD:
 29224 0000483C 30DB                    	xor	bl,bl
 29225 0000483E 861C                    	xchg	bl,[si]			; Stick in a NUL
 29226 00004840 E8EBE9                  	call	SetRest1
 29227                                  
 29228                                  	; 28/03/2023
 29229                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29230 00004843 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 29231 00004845 771B                    	ja	short LookBack		;AN000;  3/3/KK
 29232 00004847 56                      	push	si			;AN000;  3/3/KK
 29233 00004848 51                      	push	cx			;AN000;  3/3/KK
 29234 00004849 89F1                    	mov	cx,si			;AN000;  3/3/KK
 29235 0000484B 89D6                    	mov	si,dx			;AN000;  3/3/KK
 29236                                  Kloop2: 				;AN000;  3/3/KK
 29237 0000484D AC                      	lodsb				;AN000;  3/3/KK
 29238 0000484E E8B9E0                  	call	testkanj		;AN000;  3/3/KK
 29239 00004851 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 29240 00004853 AC                      	lodsb				;AN000;  3/3/KK
 29241 00004854 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29242 00004856 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 29243 00004858 59                      	pop	cx			;AN000;  3/3/KK
 29244 00004859 5E                      	pop	si			;AN000;  3/3/KK
 29245 0000485A EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 29246                                  					;		 trailing path sep
 29247                                  NotKanj4:				;AN000;  3/3/KK
 29248 0000485C 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29249 0000485E 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 29250 00004860 59                      	pop	cx			;AN000;  3/3/KK
 29251 00004861 5E                      	pop	si			;AN000;  3/3/KK
 29252                                  LookBack:				;AN000;  3/3/KK
 29253                                  	; 28/03/2023
 29254                                  	; MSDOS 3.3 & MSDOS 6.0
 29255 00004862 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 29256 00004865 740E                    	je	short BADCDERRJ2
 29257                                  DoCdr:
 29258 00004867 B43B                    	mov	ah,CHDir ; 3Bh
 29259 00004869 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29260                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29261 0000486B 861C                    	xchg	bl,[si]
 29262 0000486D 7395                    	jnc	short NOTPDIR_RETN
 29263                                  	
 29264                                  	; 28/03/2023
 29265                                  	; MSDOS 3.3
 29266                                  ;BADCDERRJ2:
 29267                                  	;stc
 29268                                  	;jmp	BADCDERR
 29269                                  
 29270                                  	; 28/03/2023
 29271                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29272 0000486F E8DCD9                  	call	get_ext_error_number	;AN022; get the extended error
 29273                                  EXTEND_SETUPJ:					;AN022;
 29274 00004872 E91CD7                  	jmp	extend_setup		;AN022; go issue the error message
 29275                                  BADCDERRJ2:
 29276 00004875 E916D7                  	jmp	badpath_err		;AC022; go issue path not found message
 29277                                  
 29278                                  ; =============== S U B	R O U T	I N E =======================================
 29279                                  
 29280                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29281                                  SETSTARS:
 29282                                  	;mov	[bp+2],di
 29283 00004878 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 29284                                  	;add	byte [bp+1],12
 29285 0000487B 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 29286                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 29287                                  	; 28/03/2023
 29288                                  	; MSDOS 6.0
 29289 0000487F B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 29290                                  	;mov	ax,'?.' ; dot_qmark
 29291                                  
 29292 00004882 B90800                  	mov	cx,8
 29293 00004885 F3AA                    	rep	stosb
 29294 00004887 86C4                    	xchg	al,ah
 29295 00004889 AA                      	stosb
 29296 0000488A 86C4                    	xchg	al,ah
 29297 0000488C B103                    	mov	cl,3
 29298 0000488E F3AA                    	rep	stosb
 29299 00004890 30C0                    	xor	al,al
 29300 00004892 AA                      	stosb
 29301 00004893 C3                      	retn
 29302                                  
 29303                                  ; =============== S U B	R O U T	I N E =======================================
 29304                                  
 29305                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29306                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 29307                                  COMPNAME:
 29308 00004894 BE[24A1]                	mov	si,DestBuf	; do name translate of target
 29309 00004897 BF[699B]                	mov	di,TRGXNAME	; save for name comparison
 29310 0000489A B460                    	mov	ah,xNameTrans ; 60h
 29311                                  	;mov	ah,60h
 29312 0000489C CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 29313                                  			; DS:SI	-> ASCIZ relative path string or directory name
 29314                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 29315 0000489E BE[129B]                	mov	si,SRCXNAME	; get name translate of source
 29316 000048A1 BF[699B]                	mov	di,TRGXNAME	; get name translate of target
 29317                                  	;call	STRCOMP
 29318                                  	;retn
 29319                                  	; 28/03/2023
 29320 000048A4 E9C4E2                  	jmp	STRCOMP
 29321                                  
 29322                                  ;============================================================================
 29323                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 29324                                  ;============================================================================
 29325                                  ; 30/09/2018 - Retro DOS v3.0
 29326                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29327                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29328                                  
 29329                                  ;-----------------------------------------------------------------------;
 29330                                  ; ENTRY:								;
 29331                                  ;	DS:SI	Points input buffer					;
 29332                                  ;	ES:DI	Points to the token buffer				;
 29333                                  ;	BL	Special delimiter for this call 			;
 29334                                  ;		    Always checked last 				;
 29335                                  ;		    set it to space if there is no special delimiter	;
 29336                                  ; EXIT: 								;
 29337                                  ;	DS:SI	Points to next char in the input buffer 		;
 29338                                  ;	ES:DI	Points to the token buffer				;
 29339                                  ;	[STARTEL] Points to start of last element of path in token	;
 29340                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 29341                                  ;	CX	Character count 					;
 29342                                  ;	BH	Condition Code						;
 29343                                  ;			Bit 1H of BH set if switch character		;
 29344                                  ;				Token buffer contains char after	;
 29345                                  ;				switch character			;
 29346                                  ;				BP has switch bits set (ORing only)	;
 29347                                  ;			Bit 2H of BH set if ? or * in token		;
 29348                                  ;				if * found element ? filled		;
 29349                                  ;			Bit 4H of BH set if path sep in token		;
 29350                                  ;			Bit 80H of BH set if the special delimiter	;
 29351                                  ;			   was skipped at the start of this token	;
 29352                                  ;		Token buffer always starts d: for non switch tokens	;
 29353                                  ;	CARRY SET							;
 29354                                  ;	    if CR on input						;
 29355                                  ;		token buffer not altered				;
 29356                                  ;									;
 29357                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 29358                                  ; MODIFIES:								;
 29359                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 29360                                  ;									;
 29361                                  ;-----------------------------------------------------------------------;
 29362                                  
 29363                                  ; Modifications to cparse: recognition of right and left parentheses
 29364                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 29365                                  ;
 29366                                  ; Both modifications were installed in the course of adding a coherent
 29367                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 29368                                  ; structure for command-line arguments. This parser relies on cparse to
 29369                                  ; recognize individual tokens.
 29370                                  ;
 29371                                  ; To process for-loops correctly, parentheses must therefore be
 29372                                  ; recognized as tokens. The upper-case conversion code was removed so
 29373                                  ; that commands (such as for and echo) would be able to use the "original"
 29374                                  ; text of the command line.
 29375                                  ;
 29376                                  ; Note also the modification to prevent the automatic conversion of colons
 29377                                  ; into spaces WITHIN THE SOURCE TEXT!
 29378                                  ;
 29379                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 29380                                  ; on the command line.
 29381                                  ;
 29382                                  ; Alan L, OS/MSDOS				    14 August 1983
 29383                                  
 29384                                  ; ---------------------------------------------------------------------------
 29385                                  
 29386                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 29387                                  
 29388                                  ;FSWITCH	EQU	8000h
 29389                                  ;FBADSWITCH	EQU	4000h
 29390                                  
 29391                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 29392                                  
 29393                                  ; =============== S U B	R O U T	I N E =======================================
 29394                                  		
 29395                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29396                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 29397                                  
 29398                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29399                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 4AE3h
 29400                                  cparse:
 29401 000048A7 31C0                    	xor	ax,ax
 29402 000048A9 893E[5CA2]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 29403 000048AD A2[5FA2]                	mov	[ELPOS],al		; Start in 8 char prefix
 29404                                  	; MSDOS 3.3
 29405                                  	;mov	[SOURCE],al		
 29406                                  	; MSDOS 6.0
 29407 000048B0 A2[60A2]                	mov	[SKPDEL], al		; No skip delimiter yet
 29408 000048B3 88C7                    	mov	bh,al			; Init nothing
 29409 000048B5 9C                      	pushf				; save flags
 29410 000048B6 57                      	push	di			; save the token buffer addrss
 29411 000048B7 31C9                    	xor	cx,cx			; no chars in token buffer
 29412 000048B9 880E[7BA0]              	mov	[comma],cl		; reset comma flag
 29413                                  moredelim:
 29414 000048BD AC                      	lodsb
 29415 000048BE E870E2                  	call	DELIM
 29416 000048C1 751D                    	jnz	short SCANCDONE
 29417 000048C3 3C20                    	cmp	al,' '
 29418 000048C5 74F6                    	jz	short moredelim
 29419 000048C7 3C09                    	cmp	al,9
 29420 000048C9 74F2                    	jz	short moredelim
 29421                                  	;xchg	al,[SOURCE]
 29422                                  	; 28/03/2023
 29423 000048CB 8606[60A2]              	xchg	al,[SKPDEL]
 29424 000048CF 08C0                    	or	al,al
 29425 000048D1 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 29426 000048D3 F6C780                  	test	bh,80h			; has a special char been found?
 29427 000048D6 7405                    	jz	short no_comma		; no - just exit
 29428 000048D8 C606[7BA0]01            	mov	byte [comma],1		; set comma flag
 29429                                  no_comma:
 29430 000048DD E92A01                  	jmp	x_done			; Nul argument
 29431                                  
 29432                                  SCANCDONE:
 29433                                  	; 28/03/2023
 29434                                  	; MSDOS 6.0
 29435                                  	; -----------------------------------
 29436                                  	; Mod to avoid upper-case conversion.
 29437                                  	; -----------------------------------
 29438                                  	; MSDOS 3.3
 29439                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29440                                  	;jnz	short cpcont1		; 3/3/KK
 29441                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29442                                  cpcont1:
 29443                                  	; -----------------------------------
 29444                                  	; 28/03/2023
 29445 000048E0 38D8                    	cmp	al,bl			; Special delimiter?
 29446 000048E2 7505                    	jne	short nospec
 29447 000048E4 80CF80                  	or	bh,80h
 29448 000048E7 EBD4                    	jmp	short moredelim
 29449                                  nospec:
 29450 000048E9 3C0D                    	cmp	al,0Dh			; a CR?
 29451 000048EB 7503                    	jne	short ncperror
 29452 000048ED E91501                  	jmp	cperror
 29453                                  ncperror:
 29454 000048F0 3A06[E89D]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 29455 000048F4 7503                    	jne	short na_switch		; yes, process...
 29456 000048F6 E91401                  	jmp	a_switch
 29457                                  na_switch:
 29458 000048F9 B23A                    	mov	dl,':'
 29459 000048FB 3814                    	cmp	[si],dl
 29460 000048FD 751D                    	jne	short anum_chard	; Drive not specified
 29461                                  	; 28/03/2023
 29462                                  	; MSDOS 6.0 
 29463 000048FF 803E[0AA1]01            	cmp	byte [cpyflag],1	; 3/3/KK
 29464 00004904 7503                    	jne	short cpcont2		; 3/3/KK
 29465 00004906 E82BE0                  	call	UPCONV			; 3/3/KK
 29466                                  cpcont2:
 29467 00004909 E85901                  	call	move_char
 29468 0000490C AC                      	lodsb				; Get the ':'
 29469 0000490D E85501                  	call	move_char
 29470 00004910 893E[5CA2]              	mov	[STARTEL],di
 29471 00004914 C606[5EA2]00            	mov	byte [ELCNT],0
 29472 00004919 E9B300                  	jmp	anum_test
 29473                                  anum_chard:
 29474 0000491C 893E[5CA2]              	mov	[STARTEL],di
 29475 00004920 C606[5EA2]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 29476 00004925 803E[0AA1]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 29477 0000492A 751D                    	jnz	short anum_char		; No, don't add drive spec.
 29478 0000492C E888E2                  	call	pathchrcmp		; Starts with a pathchar?
 29479 0000492F 7518                    	jnz	short anum_char		; no
 29480 00004931 50                      	push	ax
 29481 00004932 A0[F89D]                	mov	al,[CURDRV]		; Insert drive spec
 29482                                  	;add	al,[CAPITAL_A]
 29483                                  	; 28/03/2023
 29484                                  	; MSDOS 6.0
 29485 00004935 0441                    	add	al,'A' ; 41h
 29486 00004937 E82B01                  	call	move_char
 29487 0000493A B03A                    	mov	al,':' ; 3Ah
 29488 0000493C E82601                  	call	move_char
 29489 0000493F 58                      	pop	ax
 29490 00004940 893E[5CA2]              	mov	[STARTEL],di
 29491 00004944 C606[5EA2]00            	mov	byte [ELCNT],0
 29492                                  anum_char:
 29493                                  	; 28/03/2023
 29494                                  	; MSDOS 6.0
 29495 00004949 E8BEDF                  	call	testkanj		;AC048			
 29496 0000494C 7406                    	jz	short NOTKANJ		;AC048;
 29497 0000494E E81401                  	call	move_char
 29498 00004951 AC                      	lodsb
 29499 00004952 EB78                    	jmp	short notspecial
 29500                                  
 29501                                  NOTKANJ:				;AN048; If not kanji
 29502 00004954 803E[0AA1]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 29503 00004959 7503                    	jne	short TESTDOT 		;AN048;
 29504 0000495B E8D6DF                  	call	UPCONV			;AN048; upper case the char
 29505                                  TESTDOT:
 29506                                  	; 28/03/2023
 29507                                  	;cmp	al,dot_chr  ; 2Eh
 29508 0000495E 3C2E                    	cmp	al,'.'
 29509 00004960 7509                    	jne	short testquest
 29510 00004962 FE06[5FA2]              	inc	byte [ELPOS] 		; flag in extension
 29511 00004966 C606[5EA2]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 29512                                  testquest:
 29513 0000496B 3C3F                    	cmp	al,'?'  ; 3Fh
 29514 0000496D 7503                    	jnz	short testsplat
 29515 0000496F 80CF02                  	or	bh,2
 29516                                  testsplat:
 29517                                  	;cmp	al,[STAR]
 29518 00004972 3C2A                    	cmp	al,star	; 2Ah
 29519                                  	; 27/04/2023
 29520                                  	;cmp	al,'*' 
 29521 00004974 7530                    	jne	short testpath
 29522 00004976 80CF02                  	or	bh,2
 29523 00004979 803E[98A2]00            	cmp	byte [expand_star],0
 29524 0000497E 7504                    	jne	short expand_filename
 29525 00004980 EB24                    	jmp	short testpath
 29526                                  
 29527                                  BADPERR2J:
 29528                                  	;jmp	BADPERR2
 29529                                  	; 28/03/2023
 29530                                  	; MSDOS 6.0
 29531 00004982 EB75                    	jmp	short BADPERR2
 29532                                  
 29533                                  expand_filename:
 29534 00004984 B407                    	mov	ah,7
 29535 00004986 803E[5FA2]00            	cmp	byte [ELPOS],0
 29536 0000498B 7402                    	jz	short gotelcnt
 29537 0000498D B402                    	mov	ah,2
 29538                                  gotelcnt:
 29539 0000498F B03F                    	mov	al,'?'
 29540 00004991 2A26[5EA2]              	sub	ah,[ELCNT]
 29541 00004995 72EB                    	jb	short BADPERR2J
 29542 00004997 86E1                    	xchg	ah,cl
 29543 00004999 E309                    	jcxz	testpathx
 29544                                  qmove:
 29545 0000499B 86E1                    	xchg	ah,cl
 29546 0000499D E8C500                  	call	move_char
 29547 000049A0 86E1                    	xchg	ah,cl
 29548 000049A2 E2F7                    	loop	qmove
 29549                                  testpathx:
 29550 000049A4 86E1                    	xchg	ah,cl
 29551                                  testpath:
 29552 000049A6 E80EE2                  	call	pathchrcmp
 29553 000049A9 7521                    	jnz	short notspecial
 29554 000049AB 80CF04                  	or	bh,4
 29555 000049AE 803E[98A2]00            	cmp	byte [expand_star],0
 29556 000049B3 7405                    	jz	short no_err_check
 29557 000049B5 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 29558 000049B8 7545                    	jnz	short BADPERR
 29559                                  no_err_check:
 29560 000049BA 893E[5CA2]              	mov	[STARTEL],di	  	; New element
 29561 000049BE FF06[5CA2]              	inc	word [STARTEL]	  	; Point to char after /
 29562 000049C2 C606[5EA2]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 29563 000049C7 C606[5FA2]00            	mov	byte [ELPOS],0
 29564                                  notspecial:
 29565 000049CC E89600                  	call	move_char		; just an alphanum string
 29566                                  anum_test:
 29567 000049CF AC                      	lodsb
 29568                                  
 29569                                  	; 28/03/2023
 29570                                  	; MSDOS 6.0
 29571                                  	; -----------------------------------
 29572                                  	; Mod to avoid upper-case conversion.
 29573                                  	; -----------------------------------
 29574                                  	; MSDOS 3.3
 29575                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29576                                  	;jnz	short cpcont3		; 3/3/KK
 29577                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29578                                  cpcont3:
 29579                                  	; -----------------------------------
 29580                                  
 29581 000049D0 E85EE1                  	call	DELIM
 29582 000049D3 7435                    	jz	short x_done
 29583 000049D5 3C0D                    	cmp	al,0Dh
 29584 000049D7 7431                    	je	short x_done
 29585 000049D9 3A06[E89D]              	cmp	al,[SWITCHAR]
 29586 000049DD 742B                    	je	short x_done
 29587 000049DF 38D8                    	cmp	al,bl
 29588 000049E1 7427                    	je	short x_done
 29589 000049E3 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 29590                                  	; 28/03/2023
 29591                                  	; MSDOS 3.3
 29592                                  	;jnz	short ANUM_CHARJ 
 29593                                  	; MSDOS 6.0
 29594 000049E5 7403                    	je	short FOO15
 29595 000049E7 E95FFF                  	jmp	anum_char
 29596                                  
 29597                                  ; Modification made for parseline.
 29598                                  ; Why would it be necessary to change colons to spaces? In this
 29599                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29600                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29601                                  
 29602                                  FOO15:
 29603 000049EA 803E[0AA1]02            	cmp	byte [cpyflag],2
 29604 000049EF 7505                    	jnz	short cpcont4
 29605 000049F1 E87100                  	call	move_char
 29606 000049F4 EBD9                    	jmp	short anum_test
 29607                                  cpcont4:
 29608 000049F6 46                      	inc	si			; Skip the ':'
 29609 000049F7 EB11                    	jmp	short x_done
 29610                                  
 29611                                  	; 28/03/2023
 29612                                  ;ANUM_CHARJ:
 29613                                  	;jmp	anum_char
 29614                                  
 29615                                  BADPERR2:
 29616 000049F9 BA[1492]                	mov	dx,BADCPMES_PTR
 29617 000049FC E99EE4                  	jmp	cerror
 29618                                  
 29619                                  BADPERR:
 29620                                  	; 28/03/2023
 29621                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29622                                  BADCDERR:
 29623                                  	; MSDOS 6.0
 29624 000049FF BA[3E93]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29625 00004A02 E998E4                  	jmp	cerror			;AC022;  message
 29626                                  	
 29627                                  cperror:
 29628 00004A05 4E                      	dec	si			; adjust the pointer
 29629 00004A06 5F                      	pop	di			; retrive token buffer address
 29630 00004A07 9D                      	popf				; restore flags
 29631 00004A08 F9                      	stc				; set the carry bit
 29632 00004A09 C3                      	retn
 29633                                  
 29634                                  x_done:
 29635 00004A0A 4E                      	dec	si			; adjust for next round
 29636                                  
 29637                                  ; Mod to recognize right and left parens as integral tokens.
 29638                                  ;x_done2:
 29639 00004A0B EB51                    	jmp	short out_token
 29640                                  
 29641                                  a_switch:
 29642 00004A0D 80CF01                  	or	bh,1			; Indicate switch
 29643                                  	;or	bp,FSWITCH ; 8000h
 29644                                  	; 28/03/2023
 29645 00004A10 81CD0080                	or	bp,8000h
 29646 00004A14 E812E1                  	call	scanoff
 29647 00004A17 46                      	inc	si
 29648                                  	; 28/03/2023
 29649                                  	; MSDOS 6.0
 29650 00004A18 E8EFDE                  	call	testkanj		;AN057; See if DBCS lead byte
 29651 00004A1B 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29652 00004A1D E84500                  	call	move_char		;AN057; DBCS - store first byte
 29653 00004A20 AC                      	lodsb				;AN057; get second byte
 29654 00004A21 E84100                  	call	move_char		;AN057; store second byte
 29655                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29656 00004A24 81CD0040                	or	bp,4000h
 29657 00004A28 EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29658                                  a_switch_notkanj:			;AN057;
 29659 00004A2A 3C0D                    	cmp	al,0Dh
 29660 00004A2C 7509                    	jne	short Store_swt
 29661 00004A2E B000                    	mov	al,0
 29662 00004A30 AA                      	stosb
 29663                                  	;or	bp,FBADSWITCH ; 4000h
 29664 00004A31 81CD0040                	or	bp,4000h
 29665 00004A35 EBCE                    	jmp	short cperror		; Trailing switch character error
 29666                                  					;   BP = fSwitch but no switch
 29667                                  					;   bit is set (unknown switch)
 29668                                  Store_swt:
 29669 00004A37 E82B00                  	call	move_char		; store the character
 29670                                  
 29671                                  ; This upconv call must stay. It is used to identify copy-switches
 29672                                  ; on the command line, and won't store anything into the output buffer.
 29673                                  
 29674                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29675                                  	; 28/03/2023
 29676 00004A3A E8F7DE                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29677                                  	
 29678 00004A3D 06                      	push	es
 29679 00004A3E 57                      	push	di
 29680 00004A3F 51                      	push	cx
 29681 00004A40 0E                      	push	cs
 29682 00004A41 07                      	pop	es
 29683                                  	; 28/03/2023
 29684                                  	; MSDOS 3.3
 29685                                  	;;mov	di,SWITCH_LIST ; "VBAPW"
 29686                                  	; MSDOS 6.0
 29687                                  	;mov	di,switch_list ; "?VBAPW"
 29688                                  	; 14/06/*2023
 29689                                  	; MSDOS 6.22
 29690 00004A42 BF[9297]                	mov	di,switch_list ; "-Y?VBAPW"
 29691                                  
 29692                                  	; MSDOS 3.3
 29693                                  	;mov	cx,SWCOUNT ; 5
 29694                                  	; MSDOS 6.0
 29695                                  	;mov	cx,6  ; SWCOUNT = 6
 29696                                  	; 14/06/2023
 29697                                  	; MSDOS 6.22
 29698 00004A45 B90800                  	mov	cx,8  ; SWCOUNT = 8	
 29699                                  
 29700                                  	;or	bp,FBADSWITCH  ; 4000h
 29701 00004A48 81CD0040                	or	bp,4000h
 29702 00004A4C F2AE                    	repne	scasb
 29703 00004A4E 750B                    	jnz	short out_tokenp
 29704                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29705 00004A50 81E5FFBF                	and	bp,0BFFFh
 29706 00004A54 B80100                  	mov	ax,1
 29707 00004A57 D3E0                    	shl	ax,cl
 29708 00004A59 09C5                    	or	bp,ax
 29709                                  out_tokenp:
 29710 00004A5B 59                      	pop	cx
 29711 00004A5C 5F                      	pop	di
 29712 00004A5D 07                      	pop	es
 29713                                  out_token:
 29714 00004A5E B000                    	mov	al,0			; null at the end
 29715 00004A60 AA                      	stosb
 29716 00004A61 5F                      	pop	di			; restore token buffer pointer	
 29717 00004A62 9D                      	popf
 29718 00004A63 F8                      	clc				; clear carry flag
 29719 00004A64 C3                      	retn
 29720                                  
 29721                                  ; =============== S U B	R O U T	I N E =======================================
 29722                                  
 29723                                  	; 28/03/2023
 29724                                  move_char:
 29725 00004A65 AA                      	stosb				; store char in token buffer
 29726 00004A66 41                      	inc	cx			; increment char count
 29727 00004A67 FE06[5EA2]              	inc	byte [ELCNT]		; increment element count for * substi
 29728 00004A6B C3                      	retn
 29729                                  
 29730                                  ;============================================================================
 29731                                  ; PARSE.ASM, MSDOS 6.0, 1991
 29732                                  ;============================================================================
 29733                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29734                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29735                                  
 29736                                  ; -----------------------------
 29737                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 29738                                  ; -----------------------------
 29739                                  
 29740                                  ;**** Equation field
 29741                                  ;-------- Character code definition
 29742                                  
 29743                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 29744                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 29745                                  $P_Period	   equ	"."             ;AN020;
 29746                                  $P_Slash	   equ	"/"             ;AN020;
 29747                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 29748                                  $P_Comma	   equ	","             ;AN000;
 29749                                  $P_Switch	   equ	"/"             ;AN000;
 29750                                  $P_Keyword	   equ	"="             ;AN000;
 29751                                  $P_Colon	   equ	":"             ;AN000;
 29752                                  $P_Plus 	   equ	"+"             ;AN000;
 29753                                  $P_Minus	   equ	"-"             ;AN000;
 29754                                  $P_Rparen	   equ	")"             ;AN000;
 29755                                  $P_Lparen	   equ	"("             ;AN000;
 29756                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 29757                                  $P_DQuote	   equ	'"'             ;AN000;
 29758                                  $P_NULL 	   equ	0		;AN000;
 29759                                  $P_TAB		   equ	9		;AN000;
 29760                                  $P_CR		   equ	0Dh		;AN000;
 29761                                  $P_LF		   equ	0Ah		;AN000;
 29762                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 29763                                  
 29764                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 29765                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 29766                                  
 29767                                  $P_error_filespec  equ  1
 29768                                  
 29769                                  ;----------------------------------------------------------------------------
 29770                                  ; PARMS LABEL	BYTE
 29771                                  ;	DW	PARMSX
 29772                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 29773                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29774                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 29775                                  ;				; TYPICAL ARE ";", "="
 29776                                  ;				; "," & WHITESPACE ALWAYS
 29777                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 29778                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 29779                                  ;----------------------------------------------------------------------------
 29780                                  
 29781                                  struc $P_PARMS_BLK			;AN000;
 29782 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 29783 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 29784 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 29785                                  endstruc 				;AN000;
 29786                                  
 29787                                  $P_Len_PARMS	   equ	4		;AN000;
 29788                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 29789                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 29790                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 29791                                  
 29792                                  ;----------------------------------------------------------------------------
 29793                                  ; PARMSX LABEL	BYTE
 29794                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 29795                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 29796                                  ;	:				; REPEATS maxp-1 TIMES
 29797                                  ;	DB	maxs			; # OF SWITCHES
 29798                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 29799                                  ;	:				; REPEATS maxs-1 TIMES
 29800                                  ;	DB	maxk			; # OF KEYWORD
 29801                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 29802                                  ;	:				; REPEATS maxk-1 TIMES
 29803                                  ;----------------------------------------------------------------------------
 29804                                  
 29805                                  struc $P_PARMSX_BLK			;AN000;
 29806 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 29807 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 29808 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 29809                                  endstruc				;AN000;
 29810                                  
 29811                                  ; 31/03/2023
 29812                                  ;----------------------------------------------------------------------------
 29813                                  ; << Control field definition >>
 29814                                  ;
 29815                                  ;CONTROL   LABEL   BYTE
 29816                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 29817                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 29818                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 29819                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 29820                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 29821                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 29822                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 29823                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 29824                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 29825                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 29826                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 29827                                  ;				; 0002H=REPEATS ALLOWED
 29828                                  ;				; 0001H=OPTIONAL
 29829                                  ;	   DW FUNCTION_FLAGS
 29830                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 29831                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 29832                                  ;				; 0010H=REMOVE ":" AT END
 29833                                  ; (tm10)			; 0020H=colon is not necessary for switch
 29834                                  ;
 29835                                  ;	   DW RESULT		; RESULT BUFFER
 29836                                  ;	   DW VALUES		; VALUE LISTS
 29837                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 29838                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 29839                                  ;	   :
 29840                                  ;
 29841                                  ;Note:
 29842                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 29843                                  ;      DATE bit simalteniously.
 29844                                  ;
 29845                                  ;      The parser examins each bit along with the following priority.
 29846                                  ;
 29847                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 29848                                  ;      FILE SPEC -> SIMPLE STRING.
 29849                                  ;
 29850                                  ;
 29851                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 29852                                  ;      in the result buffer is capitalized.
 29853                                  ;
 29854                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 29855                                  ;
 29856                                  ;
 29857                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 29858                                  ;      switch, for example, '/A', then STRING points to;
 29859                                  ;
 29860                                  ;		DB    1 	; number of following synonyms
 29861                                  ;		DB   '/A',0
 29862                                  ;
 29863                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 29864                                  ;
 29865                                  ;		DB    1 	; number of following synonyms
 29866                                  ;		DB   'CODEPAGE=',0
 29867                                  ;
 29868                                  ;
 29869                                  ;    - "..." must consist of upper case characters only because the parser
 29870                                  ;      performs pattern matching after converting input to upper case (by
 29871                                  ;      using the current country upper case table)
 29872                                  ;
 29873                                  ;
 29874                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 29875                                  ;      example /A and /B, the format will be;
 29876                                  ;
 29877                                  ;		DB    2 	; number of following synonyms
 29878                                  ;		DB    '/A',0
 29879                                  ;		DB    '/B',0
 29880                                  ;----------------------------------------------------------------------------
 29881                                  
 29882                                  ;**** Match_Flags
 29883                                  
 29884                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 29885                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 29886                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 29887                                  $P_Date_S	   equ	1000h		;AN000; Date string
 29888                                  $P_Time_S	   equ	0800h		;AN000; Time string
 29889                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 29890                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 29891                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 29892                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 29893                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 29894                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 29895                                  $P_Optional	   equ	0001h		;AN000; Optional
 29896                                  
 29897                                  ;**** Function flags
 29898                                  
 29899                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 29900                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 29901                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 29902                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 29903                                  
 29904                                  ;-------------------------------- Control block structure
 29905                                  struc $P_CONTROL_BLK
 29906 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 29907 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 29908 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 29909 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 29910 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 29911 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29912                                  endstruc
 29913                                  
 29914                                  ; 31/03/2023
 29915                                  ;----------------------------------------------------------------------------
 29916                                  ;
 29917                                  ;VALUES LABEL	BYTE
 29918                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29919                                  ;	+-
 29920                                  ;	| DB	nrng		; NUMBER OF RANGES
 29921                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29922                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29923                                  ;	|	:
 29924                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29925                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29926                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29927                                  ;	|	:
 29928                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29929                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29930                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29931                                  ;	+-	:
 29932                                  ;
 29933                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29934                                  ;
 29935                                  ;Note:
 29936                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29937                                  ;      when no choice lists are provided.
 29938                                  ;
 29939                                  ;    - STRING must consist of upper case characters only because the parser
 29940                                  ;      performs pattern matching after converting input to upper case (by
 29941                                  ;      using the current country upper case table)
 29942                                  ;----------------------------------------------------------------------------
 29943                                  
 29944                                  $P_nval_None	equ 0		;AN000; no value list ID
 29945                                  $P_nval_Range	equ 1		;AN000; range list ID
 29946                                  $P_nval_Value	equ 2		;AN000; value list ID
 29947                                  $P_nval_String	equ 3		;AN000; string list ID
 29948                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29949                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29950                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29951                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29952                                  
 29953                                  struc $P_VAL_LIST
 29954 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29955 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29956 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29957 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29958 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29959                                  endstruc
 29960                                  
 29961                                  ; 31/03/2023
 29962                                  ;----------------------------------------------------------------------------
 29963                                  ;
 29964                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29965                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29966                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29967                                  ;					;	3=STRING, 4=COMPLEX,
 29968                                  ;					;	5=FILESPEC, 6=DRIVE
 29969                                  ;					;	7=DATE, 8=TIME
 29970                                  ;					;	9=QUOTED STRING
 29971                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29972                                  ;
 29973                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29974                                  ;
 29975                                  ;       +-
 29976                                  ;       | DD	n			; VALUE IF NUMBER
 29977                                  ;       | or
 29978                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29979                                  ;       |				; (ES presents Segment address)
 29980                                  ;       | or
 29981                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29982                                  ;       | or
 29983                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29984                                  ;       | or
 29985                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29986                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29987                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29988                                  ;       | or
 29989                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29990                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29991                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29992                                  ;       |	DB HUNDREDTHS ;(0-99)
 29993                                  ;       +-
 29994                                  ;
 29995                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29996                                  ;      list.
 29997                                  ;
 29998                                  ;      YEAR: If the input value for the year is less than 100, parser
 29999                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 30000                                  ;	     the year value, he returns 1987.
 30001                                  ;----------------------------------------------------------------------------
 30002                                  
 30003                                  ;-------------------------------- Result block structure
 30004                                  struc $P_RESULT_BLK;
 30005 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 30006 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 30007 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 30008 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 30009                                  endstruc
 30010                                  
 30011                                  ;**** values for the type field in the result block
 30012                                  
 30013                                  $P_EOL		 equ 0		;AN000; End of line
 30014                                  $P_Number	 equ 1		;AN000; Number
 30015                                  $P_List_Idx	 equ 2		;AN000; List Index
 30016                                  $P_String	 equ 3		;AN000; String
 30017                                  $P_Complex	 equ 4		;AN000; Complex
 30018                                  $P_File_Spec	 equ 5		;AN000; File Spec
 30019                                  $P_Drive	 equ 6		;AN000; Drive
 30020                                  $P_Date_F	 equ 7		;AN000; Date
 30021                                  $P_Time_F	 equ 8		;AN000; Time
 30022                                  $P_Quoted_String equ 9		;AN000; Quoted String
 30023                                  
 30024                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 30025                                  
 30026                                  ;**** Return code
 30027                                  ;
 30028                                  ; following return code will be returned in the AX register.
 30029                                  
 30030                                  $P_No_Error	 equ 0		;AN000; No error
 30031                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 30032                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 30033                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 30034                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 30035                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 30036                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 30037                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 30038                                  $P_Syntax	 equ 9		;AN000; Syntax error
 30039                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 30040                                  
 30041                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 30042                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 30043                                  $P_Neg		 equ 02h	;AN000; Negative value
 30044                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 30045                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 30046                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 30047                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 30048                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 30049                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 30050                                  
 30051                                  ;-------- Masks
 30052                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 30053                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 30054                                  
 30055                                  ;-------------
 30056                                  
 30057                                  struc $P_DOS_TBL
 30058 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 30059 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 30060 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 30061                                  endstruc
 30062                                  
 30063                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 30064                                  				;AN000; following parameters are set
 30065                                  				;AN000; to get casemap table.
 30066                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 30067                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 30068                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 30069                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 30070                                  				; By this call following information
 30071                                  				; is returned.
 30072                                  
 30073                                  ; 03/04/2023
 30074                                  ;-------------------------------- country dependent information
 30075                                  
 30076                                  $P_DOS_Get_CDI	equ 3800h
 30077                                  
 30078                                  struc $P_CDI
 30079 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 30080 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 30081 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 30082 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 30083 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 30084 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 30085 0000000E ??                      		resb 1		;AN000;
 30086 0000000F ??                      		resb 1		;AN000;
 30087 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 30088 00000011 ????????                		resw 2		;AN000;
 30089 00000015 ????                    		resb 2		;AN000;
 30090 00000017 <res Ah>                		resw 5		;AN000;
 30091                                  endstruc
 30092                                  
 30093                                  $P_Date_MDY	equ 0		;AN000;
 30094                                  $P_Date_DMY	equ 1		;AN000;
 30095                                  $P_Date_YMD	equ 2		;AN000;
 30096                                  
 30097                                  ; ----------------------------
 30098                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 30099                                  ; ----------------------------
 30100                                  
 30101                                  ;***********************************************************************
 30102                                  ; SysParse;
 30103                                  ;
 30104                                  ;  Function : Parser Entry
 30105                                  ;
 30106                                  ;  Input: DS:SI -> command line
 30107                                  ;	  ES:DI -> parameter block
 30108                                  ;	  psdata_seg -> psdata.inc
 30109                                  ;	  CX = operand ordinal
 30110                                  ;
 30111                                  ;	  Note:  ES is the segment containing all the control blocks defined
 30112                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 30113                                  ;		 is in DS.
 30114                                  ;
 30115                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 30116                                  ;		    invalid value list. But this parser does NOT implement
 30117                                  ;		    this feature. Therefore CY always zero.
 30118                                  ;
 30119                                  ;	   CY = 0   AX = return code
 30120                                  ;		    BL = terminated delimiter code
 30121                                  ;		    CX = new operand ordinal
 30122                                  ;		    SI = set past scaned operand
 30123                                  ;		    DX = selected result buffer
 30124                                  ;
 30125                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 30126                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 30127                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 30128                                  ;
 30129                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 30130                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 30131                                  ;
 30132                                  ;-------- Modification History -----------------------------------------
 30133                                  ;
 30134                                  ;  4/04/87 : Created by K. K,
 30135                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 30136                                  ;	   : JMP SHORT assemble error (tm02)
 30137                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 30138                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 30139                                  ;	     DateSW equ 1)	      (tm04)
 30140                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 30141                                  ;				      (tm05) in PSDATA.INC
 30142                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 30143                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 30144                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 30145                                  ;	     value-list block	      (tm07)
 30146                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 30147                                  ;	     switch (keyword) or not. If there is, backup si for next call
 30148                                  ;	     (tm08)
 30149                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 30150                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 30151                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 30152                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 30153                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 30154                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 30155                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 30156                                  ;					  (tm12)
 30157                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 30158                                  ;					  (tm13)
 30159                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 30160                                  ;					  (tm14)
 30161                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 30162                                  ;					  (tm15)
 30163                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 30164                                  ;
 30165                                  ;  7/24/87 : Quoted strings being returned with quotes.
 30166                                  ;
 30167                                  ;  7/28/87 : Kerry S (;AN018;)
 30168                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 30169                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 30170                                  ;	     affected: $P_Chk_SW_Control.
 30171                                  ;
 30172                                  ;  7/29/87 : Kerry S (;AN019;)
 30173                                  ;	     Now allow the optional bit in match flags for switches.  This
 30174                                  ;	     allows the switch to be encountered with a value or without a
 30175                                  ;	     value and no error is returned.
 30176                                  ;
 30177                                  ;
 30178                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 30179                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 30180                                  ;	     within a date response, instead of checking just for the one
 30181                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 30182                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 30183                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 30184                                  ;
 30185                                  ;  9/1/87  : Kerry S (;AN021)
 30186                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 30187                                  ;	     the command line with the string in the control block the
 30188                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 30189                                  ;	     on the command line and assuming a match.	This allowed a shorter
 30190                                  ;	     string on the command line than in the synonym list in the control
 30191                                  ;	     block.  I put in a test for a null in the control block so the
 30192                                  ;	     string in the control block must be the same length as the string
 30193                                  ;	     preceeding the colon or equal on the command line.
 30194                                  ;
 30195                                  ;  8/28/87 : Kerry S (;AN022;)
 30196                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 30197                                  ;	     problems for people who included it themselves in a segment other
 30198                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 30199                                  ;	     segment.
 30200                                  ;
 30201                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 30202                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 30203                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 30204                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 30205                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 30206                                  ;	     BL be used if TIME is being parsed.
 30207                                  ;
 30208                                  ;  9/24/87 : Ed K
 30209                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 30210                                  ;	     invocations with their normally expanded code; made comments
 30211                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 30212                                  ;
 30213                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 30214                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 30215                                  ;	     pointed to by non-existant CONTROL.
 30216                                  ;
 30217                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 30218                                  ;	     A quoted text string can be framed only by double quote.  Remove
 30219                                  ;	     support to frame quoted text string with single quote.
 30220                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 30221                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 30222                                  ;	     single quote in PROC prologues are left as is for history reasons.
 30223                                  ;
 30224                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 30225                                  ;	     quote chars within a quoted string is supposed to be reported as
 30226                                  ;	     one quote character, but is reported as two quotes.  This changed
 30227                                  ;	     two instructions in PROC $P_Quoted_Str.
 30228                                  ;
 30229                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 30230                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 30231                                  ;
 30232                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 30233                                  ;
 30234                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 30235                                  ;	     psdata buffer should have psdata_seg.
 30236                                  ;
 30237                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 30238                                  ;	     positional missing.
 30239                                  ;
 30240                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 30241                                  ;	     as a line delimiter, should use carriage return.
 30242                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 30243                                  ;
 30244                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 30245                                  ;
 30246                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 30247                                  ;	     endless loop since SI is returned still pointing to start
 30248                                  ;	     of that parm.
 30249                                  ;
 30250                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 30251                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 30252                                  ;	     when tried to fix it on previous version, changed similar
 30253                                  ;	     but wrong place.
 30254                                  ;
 30255                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 30256                                  ;	     delimiters between hours, minutes, seconds for time. And period
 30257                                  ;	     and comma are valid delimiters between seconds and 100th second.
 30258                                  ;
 30259                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 30260                                  ;	     in a filespec, then flag an error.
 30261                                  ;
 30262                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 30263                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 30264                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 30265                                  ;  -->	     local parser data. Why were some references to local data changed
 30266                                  ;	     to do this before, but not all ?????
 30267                                  ;
 30268                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 30269                                  ;
 30270                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 30271                                  ;
 30272                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 30273                                  ;
 30274                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 30275                                  ;
 30276                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 30277                                  ;	     separator in TIME before hundredths field.
 30278                                  ;
 30279                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 30280                                  ;			strings as keywords.
 30281                                  ;
 30282                                  ;***********************************************************************
 30283                                  
 30284                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30285                                  cmd_parse:
 30286                                  	;call	sysparse
 30287                                  	;retn
 30288                                  
 30289                                  ; -----------------------------------
 30290                                  
 30291                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30292                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 30293                                  
 30294                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30295                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4CABh
 30296                                  sysparse:
 30297 00004A6C 2EC706[3F99]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 30298 00004A73 2E890E[C999]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 30299 00004A78 2E8926[CB99]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 30300 00004A7D 2E8936[CD99]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 30301                                  $P_Redo_Time:				;AN039; try to parse time again
 30302 00004A82 FC                      	cld				;AN000; confirm forward direction
 30303 00004A83 2E890E[3299]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 30304                                  	;mov	word [cs:$P_RC],$P_No_Error
 30305 00004A88 2EC706[3499]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 30306 00004A8F 2EC706[4799]0000        	mov	word [cs:$P_Found_SYNONYM],0
 30307                                  					;AC034; initalize synonym pointer
 30308 00004A96 2EC706[3899]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 30309                                  
 30310                                  ;M029 -- Begin changes
 30311                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 30312                                  ;entry to SysParse. This is in the non-checksum region and any program that
 30313                                  ;corrupts this table but does not corrupt the checksum region will leave
 30314                                  ;command.com parsing in an inconsistent state.
 30315                                  ; NB: The special characters string has been hardcoded here. If any change
 30316                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 30317                                  
 30318 00004A9D 2EC706[049A]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 30319 00004AA4 2EC706[069A]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 30320 00004AAB 2EC706[089A]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 30321 00004AB2 2EC706[0A9A]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 30322                                  
 30323                                  ;M029 -- End of changes
 30324                                  
 30325 00004AB9 E83609                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 30326 00004ABC 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 30327                                  
 30328                                  ;--------------------------- End of Line
 30329                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 30330 00004ABE B8FFFF                  	mov	ax,0FFFFh
 30331 00004AC1 53                      	push	bx			;AN000;
 30332                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30333 00004AC2 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 30334                                  	
 30335                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 30336 00004AC5 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 30337 00004AC8 7304                    	jae	short $P_Fin		;AN000; positional found.
 30338                                  
 30339                                  	;mov	ax,2
 30340 00004ACA B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 30341                                  	; 27/04/2023
 30342 00004ACD F8                      	clc
 30343                                  $P_Fin: 				;AN000;
 30344 00004ACE 5B                      	pop	bx			;AN000;
 30345                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 30346                                  	; 27/04/2023
 30347                                  	; cf = 0
 30348                                  	;clc
 30349 00004ACF C3                      	retn
 30350                                  
 30351                                  ;---------------------------
 30352                                  $P_Start:				;AN000;
 30353 00004AD0 2E8936[4199]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 30354 00004AD5 53                      	push	bx			;AN000; quoted string or file spec.
 30355 00004AD6 57                      	push	di			;AN000;
 30356 00004AD7 55                      	push	bp			;AN000;
 30357 00004AD8 8D1E[4999]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 30358 00004ADC 2EF606[4099]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30359                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 30360 00004AE2 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 30361                                  $P_Pack_Loop:				;AN000;
 30362 00004AE4 AC                      	lodsb				;AN000; Pick a operand from buffer
 30363 00004AE5 E8BF09                  	call	$P_Chk_Switch		;AN000; Check switch character
 30364 00004AE8 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 30365                                  
 30366 00004AEA E82709                  	call	$P_Chk_EOL		;AN000; Check EOL character
 30367 00004AED 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 30368                                  
 30369 00004AEF E85409                  	call	$P_Chk_Delim		;AN000; Check delimiter
 30370 00004AF2 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 30371                                  
 30372 00004AF4 2EF606[4099]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30373                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 30374 00004AFA 7505                    	jnz	short $P_Pack_End_backup_si
 30375                                  					;AN000; (tm08)
 30376 00004AFC E8F308                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 30377 00004AFF EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 30378                                  
 30379                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 30380 00004B01 2EF606[4099]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 30381                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 30382 00004B07 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 30383                                  
 30384 00004B09 4E                      	dec	si			;AN000; (tm08)
 30385 00004B0A EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 30386                                  $P_PL01:				;AN000;
 30387 00004B0C 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 30388                                  	;cmp	al,'='
 30389 00004B0F 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 30390 00004B11 7506                    	jne	short $P_PL00 		;AN000; then
 30391                                  
 30392 00004B13 2E800E[4099]01          	or	byte [cs:$P_Flags2],$P_equ
 30393                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 30394                                  $P_PL00:				;AN000;
 30395 00004B19 43                      	inc	bx			;AN000; ready to see next byte
 30396 00004B1A E8B509                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 30397 00004B1D 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 30398                                  
 30399 00004B1F AC                      	lodsb				;AN000; if yes, store
 30400 00004B20 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 30401 00004B23 43                      	inc	bx			;AN000; update pointer
 30402 00004B24 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 30403                                  
 30404                                  $P_Pack_End_BY_EOL:			;AN000;
 30405 00004B26 4E                      	dec	si			;AN000; backup si pointer
 30406                                  $P_Pack_End:				;AN000;
 30407 00004B27 2E8936[3699]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 30408                                  	;mov	byte [cs:bx],0
 30409 00004B2C 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 30410 00004B30 2E891E[4599]            	mov	[cs:$P_Save_EOB],bx
 30411                                  					;AC034; 3/17/87 keep the address for later use of complex
 30412                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30413 00004B35 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 30414 00004B38 8D36[4999]              	lea	si,$P_STRING_BUF	;AC034;
 30415                                  	;cmp	byte [cs:si],'/'
 30416 00004B3C 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 30417 00004B40 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 30418                                  
 30419 00004B42 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 30420 00004B46 7408                    	je	short $P_Positional_Manager
 30421                                  					;M005;if so, process as one!
 30422 00004B48 2EF606[4099]01          	test	byte [cs:$P_Flags2],$P_equ
 30423                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 30424 00004B4E 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 30425                                  
 30426                                  $P_Positional_Manager:			;AN000; else process as positional
 30427                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30428 00004B50 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30429 00004B54 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30430 00004B56 2E3906[3299]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 30431 00004B5B 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 30432                                  
 30433 00004B5D 2EA1[3299]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 30434 00004B61 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 30435 00004B63 43                      	inc	bx			;AC035; add '2' to
 30436 00004B64 43                      	inc	bx			;AC035;  BX reg
 30437                                  					;AN000; now bx points to 1st CONTROL
 30438 00004B65 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 30439 00004B67 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 30440 00004B6A E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 30441 00004B6D EB69                    	jmp	short $P_Return_to_Caller
 30442                                  					;AN000; and return to the caller
 30443                                  $P_Too_Many_Error:			;AN000;
 30444                                  	;mov	word [cs:$P_RC],1
 30445 00004B6F 2EC706[3499]0100        	mov	word [cs:$P_RC],$P_Too_Many
 30446                                  					;AC034; set exit code
 30447 00004B76 EB60                    	jmp	short $P_Return_to_Caller
 30448                                  					;AN000; and return to the caller
 30449                                  $P_SW_Manager:				;AN000;
 30450                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30451 00004B78 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30452 00004B7C 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30453 00004B7E 40                      	inc	ax			;AN000;
 30454 00004B7F D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 30455 00004B81 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 30456 00004B83 268A0F                  	mov	cl,[es:bx]		;AN000;
 30457 00004B86 30ED                    	xor	ch,ch			;AN000; cx = maxs
 30458 00004B88 09C9                    	or	cx,cx			;AN000; at least one switch ?
 30459 00004B8A 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 30460 00004B8C 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 30461                                  $P_SW_Mgr_Loop: 			;AN000;
 30462 00004B8D 53                      	push	bx			;AN000;
 30463 00004B8E 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 30464 00004B91 E8C100                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 30465 00004B94 5B                      	pop	bx			;AN000;
 30466 00004B95 7341                    	jnc	short $P_Return_to_Caller
 30467                                  					;AN000; if the CONTROL is for the switch, exit
 30468 00004B97 43                      	inc	bx			;AC035; add '2' to
 30469 00004B98 43                      	inc	bx			;AC035;  BX reg
 30470                                  					;AN000; else bx points to the next CONTROL
 30471 00004B99 E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 30472                                  $P_SW_Not_Found:			;AN000;
 30473                                  	;mov	word [cs:$P_RC],3
 30474 00004B9B 2EC706[3499]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 30475                                  					;AC034; here no CONTROL for the switch has
 30476 00004BA2 EB34                    	jmp	short $P_Return_to_Caller0
 30477                                  					;AN000; not been found, means error.
 30478                                  $P_Key_Manager: 			;AN000;
 30479                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30480 00004BA4 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30481 00004BA8 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30482 00004BAA 40                      	inc	ax			;AN000;
 30483 00004BAB D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 30484 00004BAD 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 30485 00004BAF 268A07                  	mov	al,[es:bx]		;AN000;
 30486 00004BB2 30E4                    	xor	ah,ah			;AN000; ax = maxs
 30487 00004BB4 D1E0                    	shl	ax,1			;AN000;
 30488 00004BB6 40                      	inc	ax			;AN000; ax = ax*2+1
 30489 00004BB7 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 30490 00004BB9 268A0F                  	mov	cl,[es:bx]		;AN000;
 30491 00004BBC 30ED                    	xor	ch,ch			;AN000; cx = maxk
 30492 00004BBE 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 30493 00004BC0 740F                    	jz	short $P_Key_Not_Found	;AN000;
 30494 00004BC2 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 30495                                  $P_Key_Mgr_Loop:			;AN000;
 30496 00004BC3 53                      	push	bx			;AN000;
 30497 00004BC4 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 30498 00004BC7 E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 30499 00004BCA 5B                      	pop	bx			;AN000;
 30500 00004BCB 730B                    	jnc	short $P_Return_to_Caller
 30501                                  					;AN000; if the CONTROL is for the keyword, exit
 30502 00004BCD 43                      	inc	bx			;AC035; add '2' to
 30503 00004BCE 43                      	inc	bx			;AC035;  BX reg
 30504                                  					;AN000; else bx points to the next CONTROL
 30505 00004BCF E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 30506                                  $P_Key_Not_Found:			;AN000;
 30507                                  	;mov	word [cs:$P_RC],4
 30508 00004BD1 2EC706[3499]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 30509                                  					;AC034; here no CONTROL for the keyword has
 30510                                  $P_Return_to_Caller0:
 30511                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 30512 00004BD8 5D                      	pop	bp			;AN000;
 30513 00004BD9 5F                      	pop	di			;AN000;
 30514 00004BDA 5B                      	pop	bx			;AN000;
 30515 00004BDB 2E8B0E[3299]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 30516 00004BE0 2EA1[3499]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 30517 00004BE4 2E8B36[3699]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 30518 00004BE9 2E8B16[3899]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 30519 00004BEE 2E8A1E[3A99]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 30520                                  $P_Single_Exit: 			;AN000;
 30521 00004BF3 F8                      	clc				;AN000;
 30522 00004BF4 C3                      	retn				;AN000;
 30523                                  
 30524                                  ;***********************************************************************
 30525                                  ; $P_Chk_Pos_Control
 30526                                  ;
 30527                                  ; Function: Parse CONTROL block for a positional
 30528                                  ;
 30529                                  ; Input:     ES:BX -> CONTROL block
 30530                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30531                                  ;
 30532                                  ; Output:    None
 30533                                  ;
 30534                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 30535                                  ;
 30536                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 30537                                  ;***********************************************************************
 30538                                  
 30539                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30540                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 30541                                  
 30542                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30543                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E35h
 30544                                  $P_Chk_Pos_Control:
 30545 00004BF5 50                      	push	ax			;AN000;
 30546                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30547 00004BF6 268B07                  	mov	ax,[es:bx]		;AN000;
 30548                                  	;test	ax,2
 30549 00004BF9 A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 30550 00004BFC 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 30551                                  
 30552 00004BFE 2EFF06[3299]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 30553                                  $P_CPC00:				;AN000;
 30554                                  	;cmp	byte [cs:si],0
 30555 00004C03 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 30556 00004C07 7516                    	jne	short $P_CPC01		;AN000;
 30557                                  
 30558                                  	;test	ax,1
 30559 00004C09 A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 30560 00004C0C 7509                    	jnz	short $P_CPC02		;AN000;
 30561                                  
 30562 00004C0E 2EC706[3499]0200        	mov	word [cs:$P_RC],$P_Op_Missing ; 2
 30563                                  					;AC034; no, then error	 3/17/87
 30564 00004C15 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 30565                                  $P_CPC02:				;AN000;
 30566                                  	; 27/04/2023
 30567                                  	;push	ax ; *			;AN000;
 30568                                  	;
 30569                                  	;;mov	al,3
 30570                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 30571                                  	;;mov	ah,0FFh
 30572                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 30573                                  	;31/03/2023
 30574 00004C17 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30575 00004C1A E89500                  	call	$P_Fill_Result		;AN000;
 30576                                  	; 27/04/2023
 30577                                  	;pop	ax ; *			;AN000;
 30578 00004C1D EB03                    	jmp	short $P_CPC_Exit	;AN000;
 30579                                  $P_CPC01:				;AN000;
 30580 00004C1F E81101                  	call	$P_Check_Match_Flags	;AN000;
 30581                                  $P_CPC_Exit:				;AN000;
 30582 00004C22 58                      	pop	ax			;AN000;
 30583 00004C23 C3                      	retn				;AN000;
 30584                                  
 30585                                  ;***********************************************************************
 30586                                  ; $P_Chk_Key_Control
 30587                                  ;
 30588                                  ; Function: Parse CONTROL block for a keyword
 30589                                  ;
 30590                                  ; Input:     ES:BX -> CONTROL block
 30591                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30592                                  ;
 30593                                  ; Output:    CY = 1 : not match
 30594                                  ;
 30595                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30596                                  ;
 30597                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30598                                  ;***********************************************************************
 30599                                  
 30600                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30601                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30602                                  $P_Chk_Key_Control:			;AN000;
 30603 00004C24 F9                      	stc				;AN000;this logic works when the KeySW
 30604 00004C25 C3                      	retn				;AN000;is reset.
 30605                                  
 30606                                  ;***********************************************************************
 30607                                  ; $P_Search_KEYorSW:
 30608                                  ;
 30609                                  ; Function: Seach specified keyword or switch from CONTROL
 30610                                  ;
 30611                                  ; Input:     ES:BX -> CONTROL block
 30612                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30613                                  ;
 30614                                  ; Output:    CY = 1 : not match
 30615                                  ;
 30616                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30617                                  ;***********************************************************************
 30618                                  
 30619                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30620                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30621                                  $P_Search_KEYorSW:
 30622 00004C26 55                      	push	bp			;AN000;
 30623 00004C27 51                      	push	cx			;AN000;
 30624 00004C28 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30625                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30626                                  	; 14/06/2023
 30627                                  	;xor	ch,ch			;AN000; and set it to cx
 30628                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30629 00004C2C 08C9                    	or	cl,cl
 30630 00004C2E 740E                    	jz	short $P_KEYorSW_Not_Found
 30631                                  					;AN000; then indicate not found by CY
 30632 00004C30 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30633                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30634                                  $P_KEYorSW_Loop:			;AN000;
 30635 00004C34 E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30636 00004C37 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30637 00004C39 E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30638 00004C3C E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30639                                  $P_KEYorSW_Not_Found:			;AN000;
 30640 00004C3E F9                      	stc				;AN000; indicate not found in synonym list
 30641 00004C3F EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30642                                  $P_KEYorSW_Found:			;AN000;
 30643 00004C41 2E892E[4799]            	mov	[cs:$P_Found_SYNONYM],bp
 30644                                  					;AC034; set synonym pointer
 30645                                  	; 27/04/2023
 30646                                  	; cf = 0
 30647                                  	;clc				;AN000; indicate found
 30648                                  $P_KEYorSW_Exit:			;AN000;
 30649 00004C46 59                      	pop	cx			;AN000;
 30650 00004C47 5D                      	pop	bp			;AN000;
 30651 00004C48 C3                      	retn				;AN000;
 30652                                  
 30653                                  ;***********************************************************************
 30654                                  ; $P_MoveBP_NUL
 30655                                  ;***********************************************************************
 30656                                  
 30657                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30658                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30659                                  $P_MoveBP_NUL:
 30660                                  $P_MBP_Loop:				;AN000;
 30661                                  	;cmp	byte [es:bp+0],0
 30662 00004C49 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30663 00004C4E 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30664 00004C50 45                      	inc	bp			;AN000; until
 30665 00004C51 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30666                                  $P_MBP_Exit:				;AN000;
 30667 00004C53 45                      	inc	bp			;AN000; bp points to next to NULL
 30668 00004C54 C3                      	retn				;AN000;
 30669                                  
 30670                                  ;***********************************************************************
 30671                                  ; $P_Chk_SW_Control
 30672                                  ;
 30673                                  ; Function: Parse CONTROL block for a switch
 30674                                  ;
 30675                                  ; Input:     ES:BX -> CONTROL block
 30676                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30677                                  ;
 30678                                  ; Output:    CY = 1 : not match
 30679                                  ;
 30680                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30681                                  ;
 30682                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30683                                  ;***********************************************************************
 30684                                  
 30685                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30686                                  	;
 30687                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30688                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E9Ah 
 30689                                  $P_Chk_SW_Control:
 30690 00004C55 2E800E[4099]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 30691                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 30692 00004C5B E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 30693 00004C5E 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 30694                                  
 30695 00004C60 2E8026[4099]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 30696                                  	;and	byte [cs:$P_Flags2],0EFh
 30697                                  					;AC034; reset the indicator previously set
 30698 00004C66 50                      	push	ax			;AN000;       /switch:
 30699 00004C67 2EA1[4399]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 30700 00004C6B 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 30701 00004C6D 2E0106[4199]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 30702 00004C72 58                      	pop	ax			;AN000;
 30703                                  
 30704 00004C73 2E8B36[4399]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 30705                                  	;cmp	byte [cs:si],0
 30706 00004C78 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 30707 00004C7C 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 30708                                  
 30709                                  	;cmp	byte [cs:si],':'
 30710 00004C7E 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 30711                                  					;AN000; if no, the switch terminated by colon ?
 30712 00004C83 7509                    	jne	short $P_Chk_if_data_required
 30713                                  					;AN000; if yes,
 30714                                  
 30715 00004C85 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax
 30716                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 30717 00004C8C EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 30718                                  
 30719                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 30720                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 30721                                  	; 27/04/2023
 30722 00004C8E 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 30723 00004C92 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 30724                                  
 30725                                  	;;test	word [es:bx],1 ; $P_Optional
 30726                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 30727 00004C94 26F60701                	test	byte [es:bx],$P_Optional
 30728                                  					;AN019; see if no value is valid
 30729 00004C98 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 30730                                  
 30731 00004C9A 2EC706[3499]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 30732                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 30733 00004CA1 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 30734                                  
 30735                                  $P_CSW00:				;AN000;
 30736 00004CA3 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 30737 00004CA6 F8                      	clc				;AN000; indicate match
 30738                                  	;jmp	short $P_Chk_SW_Single_Exit
 30739 00004CA7 C3                      	retn	; 31/03/2023		;AN000;
 30740                                  	; 31/03/2023
 30741                                  ;$P_Chk_SW_Err0: 			;AN000;
 30742                                  ;	stc				;AN000; not found in switch synonym list
 30743                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 30744                                  ;	retn	; 31/03/2023		;AN000;
 30745                                  	
 30746                                  $P_Chk_SW_Exit: 			;AN000;
 30747 00004CA8 50                      	push	ax			;AN000;
 30748                                  	; 31/03/2023
 30749 00004CA9 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30750                                  	;;mov	al,3
 30751                                  	;;mov	ah,0FFh
 30752                                  	;mov	al,$P_String		;AN000; set
 30753                                  	;mov	ah,$P_No_Tag		;AN000;    result
 30754 00004CAC E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 30755 00004CAF 58                      	pop	ax			;AN000;
 30756 00004CB0 F8                      	clc				;AN000;
 30757                                  	; 31/03/2023
 30758                                  $P_Chk_SW_Err0:
 30759                                  $P_Chk_SW_Single_Exit:			;AN000;
 30760 00004CB1 C3                      	retn				;AN000;
 30761                                  
 30762                                  ;***********************************************************************
 30763                                  ; $P_Fill_Result
 30764                                  ;
 30765                                  ; Function: Fill the result buffer
 30766                                  ;
 30767                                  ; Input:    AH = Item tag
 30768                                  ;	    AL = type
 30769                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 30770                                  ;		  AL = 2: DX has index(offset) into value list
 30771                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 30772                                  ;		  AL = 7: DX has year, CL has month and CH has date
 30773                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 30774                                  ;			  amd CH has hundredths
 30775                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 30776                                  ;	    ES:BX -> CONTROL block
 30777                                  ;
 30778                                  ; Output:   None
 30779                                  ;
 30780                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 30781                                  ;
 30782                                  ; Vars: $P_DX(W)
 30783                                  ;***********************************************************************
 30784                                  
 30785                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30786                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30787                                  $P_Fill_Result:
 30788 00004CB2 57                      	push	di			;AN000;
 30789 00004CB3 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 30790                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 30791 00004CB7 2E893E[3899]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 30792                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 30793                                  	;;mov	[es:di],al		;AN000; store type
 30794                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 30795                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 30796                                  	; 31/03/2023
 30797 00004CBC 268905                  	mov	[es:di],ax
 30798 00004CBF 50                      	push	ax			;AN000;
 30799 00004CC0 2EA1[4799]              	mov	ax,[cs:$P_Found_SYNONYM]
 30800                                  					;AC034; if yes,
 30801 00004CC4 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 30802                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 30803 00004CC8 58                      	pop	ax			;AN000;
 30804                                  $P_RLT04:				;AN000;
 30805                                  	;cmp	al,1
 30806 00004CC9 3C01                    	cmp	al,$P_Number		;AN000; if number
 30807 00004CCB 750A                    	jne	short $P_RLT00		;AN000;
 30808                                  $P_RLT02:				;AN000;
 30809 00004CCD 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30810                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 30811 00004CD1 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 30812                                  	;mov	[es:di+6],cx		;AN000;	number
 30813 00004CD5 EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 30814                                  $P_RLT00:				;AN000;
 30815                                  	;cmp	al,2
 30816 00004CD7 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 30817 00004CD9 7506                    	jne	short $P_RLT01		;AN000;
 30818 00004CDB 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 30819                                  	;mov	[es:di+4],dx		;AN000; then store list index
 30820 00004CDF EB50                    	jmp	short $P_RLT_Exit	;AN000;
 30821                                  $P_RLT01:				;AN000;
 30822                                  	;cmp	al,7
 30823 00004CE1 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 30824 00004CE3 74E8                    	je	short $P_RLT02		;AN000;
 30825                                  	;cmp	al,8
 30826 00004CE5 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 30827 00004CE7 74E4                    	je	short $P_RLT02		;AN000;
 30828                                  	;cmp	al,6
 30829 00004CE9 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 30830 00004CEB 7506                    	jne	short $P_RLT03		;AN000;
 30831                                  
 30832 00004CED 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 30833                                  	;mov	[es:di+4],dl		;AN000; store drive number
 30834 00004CF1 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 30835                                  
 30836                                  $P_RLT03:				;AN000;
 30837                                  	;cmp	al,4
 30838 00004CF3 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 30839 00004CF5 750F                    	jne	short $P_RLT05		;AN000;
 30840                                  
 30841 00004CF7 2EA1[4199]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 30842 00004CFB 40                      	inc	ax			;AN000; skip left Parentheses
 30843 00004CFC 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 30844                                  	;mov	[es:di+4],ax		;AN000; store offset
 30845 00004D00 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 30846                                  	;mov	[es:di+6],ds		;AN000; store segment
 30847 00004D04 EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 30848                                  
 30849                                  $P_RLT05:				;AN000;
 30850                                  ;------------------------  AL = 3, 5, or 9
 30851 00004D06 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 30852                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 30853 00004D0A 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 30854                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 30855                                  
 30856 00004D0E 50                      	push	ax			;AN000;
 30857 00004D0F 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 30858                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 30859 00004D14 7404                    	jz	short $P_RLT_CAP00	;AN000;
 30860                                  
 30861                                  	;mov	al,4
 30862 00004D16 B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 30863 00004D18 EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 30864                                  
 30865                                  $P_RLT_CAP00:				;AN000;
 30866 00004D1A 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 30867                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 30868 00004D1F 7405                    	jz	short $P_RLT_CAP01	;AN000;
 30869                                  
 30870                                  	;mov	al,2
 30871 00004D21 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 30872                                  $P_RLT_CAP02:				;AN000;
 30873 00004D23 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 30874                                  $P_RLT_CAP01:				;AN000;
 30875 00004D26 58                      	pop	ax			;AN000;
 30876 00004D27 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 30877                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 30878 00004D2C 7403                    	jz	short $P_RLT_Exit	;AN000;
 30879                                  
 30880 00004D2E E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 30881                                  $P_RLT_Exit:				;AN000;
 30882 00004D31 5F                      	pop	di			;AN000;
 30883 00004D32 C3                      	retn				;AN000;
 30884                                  
 30885                                  ;***********************************************************************
 30886                                  ; $P_Check_Match_Flags
 30887                                  ;
 30888                                  ; Function:  Check the mutch_flags and make the exit code and set the
 30889                                  ;	     result buffer
 30890                                  ;
 30891                                  ;	    Check for types in this order:
 30892                                  ;		Complex
 30893                                  ;		Date
 30894                                  ;		Time
 30895                                  ;		Drive
 30896                                  ;		Filespec
 30897                                  ;		Quoted String
 30898                                  ;		Simple String
 30899                                  ;
 30900                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30901                                  ;	     ES:BX -> CONTROL block
 30902                                  ;
 30903                                  ; Output:    None
 30904                                  ;
 30905                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 30906                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 30907                                  ;	     $P_Drive_Format
 30908                                  ;***********************************************************************
 30909                                  
 30910                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30911                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30912                                  $P_Check_Match_Flags:
 30913 00004D33 2EC606[0D9A]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 30914                                  					;AN033;AC034;; clear filespec error flag.
 30915 00004D39 50                      	push	ax			;AN000;
 30916                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30917 00004D3A 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 30918 00004D3D 09C0                    	or	ax,ax			;AC035; test ax for zero
 30919 00004D3F 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 30920 00004D41 50                      	push	ax			;AN000; (tm12)
 30921 00004D42 53                      	push	bx			;AN000; (tm12)
 30922 00004D43 52                      	push	dx			;AN000; (tm12)
 30923 00004D44 57                      	push	di			;AN000; (tm12)
 30924 00004D45 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax
 30925                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30926                                  	; 31/03/2023
 30927 00004D4C B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30928                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30929                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30930 00004D4F E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30931 00004D52 5F                      	pop	di			;AN000; (tm12)
 30932 00004D53 5A                      	pop	dx			;AN000; (tm12)
 30933 00004D54 5B                      	pop	bx			;AN000; (tm12)
 30934 00004D55 58                      	pop	ax			;AN000; (tm12)
 30935                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30936                                  	; 31/03/2023
 30937                                  $P_Bridge:	; 18/04/2023		;AN000;
 30938 00004D56 E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30939                                  $P_Mat: 				;AN000; (tm12)
 30940                                  $P_Match01:				;AN000;
 30941                                  	;test	ax,1000h
 30942 00004D59 A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30943 00004D5C 7412                    	jz	short $P_Match02	;AN000;
 30944 00004D5E 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 30945                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30946 00004D65 E86503                  	call	$P_Date_Format		;AN000; do process
 30947 00004D68 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 30948                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30949                                  	; 18/04/2023
 30950 00004D6E 75E6                    	jne	short $P_Bridge		;AN000;
 30951                                  $P_Match02:				;AN000;
 30952                                  	;test	ax,800h
 30953 00004D70 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30954 00004D73 7412                    	jz	short $P_Match03	;AN000;
 30955 00004D75 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 30956                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30957 00004D7C E86004                  	call	$P_Time_Format		;AN000; do process
 30958 00004D7F 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 30959                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30960                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30961                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30962                                  	; 31/03/2023
 30963 00004D85 756E                    	jne	short $P_Match_Exit
 30964                                  ;$P_Bridge:				;AN000;
 30965                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30966                                  $P_Match03:				;AN000;
 30967                                  	;test	ax,8000h
 30968 00004D87 A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30969 00004D8A 7412                    	jz	short $P_Match04	;AN000;
 30970 00004D8C 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 30971                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30972 00004D93 E82C01                  	call	$P_Value		;AN000; do process
 30973 00004D96 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 30974                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30975 00004D9C 7557                    	jne	short $P_Match_Exit	;AN000;
 30976                                  $P_Match04:				;AN000;
 30977                                  	;test	ax,4000h
 30978 00004D9E A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30979 00004DA1 7412                    	jz	short $P_Match05	;AN000;
 30980 00004DA3 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 30981                                  					;AC034; assume no error
 30982 00004DAA E8F100                  	call	$P_SValue		;AN000; do process
 30983 00004DAD 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 30984                                  					;AC034; if error, examine the next type
 30985 00004DB3 7540                    	jne	short $P_Match_Exit	;AN000;
 30986                                  $P_Match05:				;AN000;
 30987                                  	;test	ax,100h
 30988 00004DB5 A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30989 00004DB8 7415                    	jz	short $P_Match06	;AN000;
 30990 00004DBA 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 30991                                  					;AC034; assume no error
 30992 00004DC1 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 30993 00004DC4 E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30994 00004DC7 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 30995                                  					;AC034; if error, examinee the next type
 30996 00004DCD 7526                    	jne	short $P_Match_Exit	;AN000;
 30997                                  $P_Match06:				;AN000;
 30998                                  	;test	ax,200h
 30999 00004DCF A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 31000 00004DD2 7412                    	jz	short $P_Match07	;AN000;
 31001 00004DD4 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 31002                                  					;AC034; assume no error
 31003 00004DDB E84E05                  	call	$P_File_Format		;AN000; do process
 31004 00004DDE 2E833E[3499]09          	cmp	word [cs:$P_RC],$P_Syntax
 31005                                  					;AC034; if error, examine the next type
 31006 00004DE4 750F                    	jne	short $P_Match_Exit	;AN000;
 31007                                  $P_Match07:				;AN000;
 31008                                  $P_Match08:				;AN000;
 31009                                  	;test	ax,2000h
 31010 00004DE6 A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 31011 00004DE9 740A                    	jz	short $P_Match09	;AN000;
 31012 00004DEB 2EC706[3499]0000        	mov	word [cs:$P_RC],$P_No_Error
 31013                                  					;AC034; assume no error
 31014 00004DF2 E8D601                  	call	$P_Simple_String	;AN000; do process
 31015                                  $P_Match09:				;AN000;
 31016                                  $P_Match_Exit:				;AN000;
 31017 00004DF5 2E833E[0D9A]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 31018                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 31019 00004DFB 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31020 00004DFD 2E833E[3499]00          	cmp	word [cs:$P_RC],$P_No_Error
 31021                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 31022 00004E03 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31023 00004E05 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax
 31024                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 31025                                  $P_Match2_Exit: 			;AN033;
 31026 00004E0C 58                      	pop	ax			;AN000;
 31027 00004E0D C3                      	retn
 31028                                  
 31029                                  ;***********************************************************************
 31030                                  ; $P_Remove_Colon;
 31031                                  ;
 31032                                  ; Function: Remove colon at end
 31033                                  ;
 31034                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 31035                                  ;
 31036                                  ; Output:   None
 31037                                  ;
 31038                                  ; Use:	$P_Chk_DBCS
 31039                                  ;***********************************************************************
 31040                                  
 31041                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31042                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31043                                  $P_Remove_Colon:
 31044 00004E0E 50                      	push	ax			;AN000;
 31045 00004E0F 56                      	push	si			;AN000;
 31046                                  $P_RCOL_Loop:				;AN000;
 31047 00004E10 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31048 00004E13 08C0                    	or	al,al			;AN000; end of string ?
 31049 00004E15 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 31050                                  
 31051 00004E17 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 31052 00004E19 750E                    	jne	short $P_RCOL00		;AN000;
 31053                                  
 31054                                  	;cmp	byte [cs:si+1],0
 31055 00004E1B 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 31056 00004E20 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 31057                                  
 31058 00004E22 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 31059                                  	; 31/03/2023
 31060                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 31061                                  $P_RCOL_Exit:
 31062 00004E26 5E                      	pop	si
 31063 00004E27 58                      	pop	ax
 31064 00004E28 C3                      	retn
 31065                                  
 31066                                  $P_RCOL00:				;AN000;
 31067 00004E29 E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 31068 00004E2C 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 31069                                  
 31070 00004E2E 46                      	inc	si			;AN000; if yes, skip trailing byte
 31071                                  $P_RCOL01:				;AN000;
 31072 00004E2F 46                      	inc	si			;AN000; si points to next byte
 31073 00004E30 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 31074                                  
 31075                                  	; 31/03/2023
 31076                                  ;$P_RCOL_Exit:				;AN000;
 31077                                  	;pop	si			;AN000;
 31078                                  	;pop	ax			;AN000;
 31079                                  	;retn
 31080                                  
 31081                                  ;***********************************************************************
 31082                                  ; $P_Do_CAPS_String;
 31083                                  ;
 31084                                  ; Function: Perform capitalization along with the file case map table
 31085                                  ;	    or character case map table.
 31086                                  ;
 31087                                  ; Input:    AL = 2 : Use character table
 31088                                  ;	    AL = 4 : Use file table
 31089                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 31090                                  ;
 31091                                  ; Output:   None
 31092                                  ;
 31093                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 31094                                  ;***********************************************************************
 31095                                  
 31096                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31097                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31098                                  $P_Do_CAPS_String:
 31099 00004E32 56                      	push	si			;AN000;
 31100 00004E33 52                      	push	dx			;AN000;
 31101 00004E34 88C2                    	mov	dl,al			;AN000; save info id
 31102                                  $P_DCS_Loop:				;AN000;
 31103 00004E36 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 31104 00004E39 E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 31105 00004E3C 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 31106                                  
 31107 00004E3E 08C0                    	or	al,al			;AN000; end of string ?
 31108 00004E40 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 31109                                  
 31110 00004E42 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 31111 00004E45 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 31112 00004E48 EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 31113                                  $P_DCS00:				;AN000;
 31114 00004E4A 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 31115                                  $P_DCS01:				;AN000;
 31116 00004E4B 46                      	inc	si			;AN000; si point to next byte
 31117 00004E4C EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 31118                                  $P_DCS_Exit:				;AN000;
 31119 00004E4E 5A                      	pop	dx			;AN000;
 31120 00004E4F 5E                      	pop	si			;AN000;
 31121 00004E50 C3                      	retn
 31122                                  
 31123                                  ;***********************************************************************
 31124                                  ; $P_Do_CAPS_Char;
 31125                                  ;
 31126                                  ; Function: Perform capitalization along with the file case map table
 31127                                  ;	    or character case map table.
 31128                                  ;
 31129                                  ; Input:    DL = 2 : Use character table
 31130                                  ;	    DL = 4 : Use file table
 31131                                  ;	    AL = character to be capitalized
 31132                                  ;
 31133                                  ; Output:   None
 31134                                  ;
 31135                                  ; Use:	INT 21h /w AH=65h
 31136                                  ;***********************************************************************
 31137                                  
 31138                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31139                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31140                                  $P_Do_CAPS_Char:
 31141 00004E51 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 31142 00004E53 730B                    	jae	short $P_DCC_Go		;AN000;
 31143                                  
 31144 00004E55 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 31145 00004E57 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 31146                                  
 31147 00004E59 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 31148 00004E5B 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 31149                                  
 31150 00004E5D 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 31151                                  	;jmp	short $P_CAPS_Ret	;AN000;
 31152                                  	; 18/04/2023
 31153 00004E5F C3                      	retn
 31154                                  
 31155                                  $P_DCC_Go:				;AN000;
 31156 00004E60 53                      	push	bx			;AN000;
 31157 00004E61 06                      	push	es			;AN000;
 31158 00004E62 57                      	push	di			;AN000;
 31159                                  	; 18/04/2023
 31160 00004E63 8D3E[FF99]              	lea	di,$P_File_CAP_Ptr	;AC034;
 31161 00004E67 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 31162 00004E6A 7404                    	je	short $P_DCC00		;AN000;
 31163                                  	; 27/04/2023
 31164 00004E6C 8D3E[FA99]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 31165                                  $P_DCC00:				;AN000;
 31166 00004E70 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 31167 00004E73 7417                    	je	short $P_DCC01		;AN000; if no,
 31168                                  
 31169                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 31170                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 31171                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 31172                                  
 31173 00004E75 50                      	push	ax			;AN000; get CAPS table thru DOS call
 31174 00004E76 51                      	push	cx			;AN000;
 31175 00004E77 52                      	push	dx			;AN000;
 31176 00004E78 0E                      	push	cs			;AC036; pass current base seg into
 31177                                  					;(Note: this used to push CS. BUG...
 31178 00004E79 07                      	pop	es			;AN000;   ES reg, required for
 31179                                  					;get extended country information
 31180                                  	; 31/03/2023
 31181 00004E7A B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 31182                                  	;mov	ah,65h
 31183 00004E7C 88D0                    	mov	al,dl			;AN000; upper case table
 31184                                  	;mov	bx,-1 ; 0FFFFh
 31185                                  	;mov	cx,5
 31186                                  	;mov	dx,-1
 31187 00004E7E BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 31188 00004E81 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 31189 00004E84 BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 31190                                  					;DI already set to point to buffer
 31191 00004E87 CD21                    	int	21h			;AN000; es:di point to buffer that
 31192                                  					;now has been filled in with info
 31193 00004E89 5A                      	pop	dx			;AN000;
 31194 00004E8A 59                      	pop	cx			;AN000;
 31195 00004E8B 58                      	pop	ax			;AN000;
 31196                                  
 31197                                  $P_DCC01:				;AN000;
 31198                                  
 31199                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 31200                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 31201                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 31202                                  
 31203 00004E8C 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 31204                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 31205 00004E90 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 31206                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 31207 00004E94 43                      	inc	bx			;AC035; add '2' to
 31208 00004E95 43                      	inc	bx			;AC035;  BX reg
 31209                                  					;AN000; skip length field
 31210 00004E96 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 31211                                  	;xlat	es:[bx] 		;AN000; perform case map
 31212                                  	; 31/03/2023
 31213 00004E98 26D7                    	es	xlat
 31214                                  
 31215 00004E9A 5F                      	pop	di			;AN000;
 31216 00004E9B 07                      	pop	es			;AN000;
 31217 00004E9C 5B                      	pop	bx			;AN000;
 31218                                  $P_CAPS_Ret:				;AN000;
 31219 00004E9D C3                      	retn
 31220                                  
 31221                                  ;***********************************************************************
 31222                                  ; $P_Value / $P_SValue
 31223                                  ;
 31224                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 31225                                  ;	     and make result buffer.
 31226                                  ;	     $P_SValue is an entry point for the signed value
 31227                                  ;	     and this will simply call $P_Value after the handling
 31228                                  ;	     of the sign character, "+" or "-"
 31229                                  ;
 31230                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31231                                  ;	     ES:BX -> CONTROL block
 31232                                  ;
 31233                                  ; Output:    None
 31234                                  ;
 31235                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 31236                                  ;
 31237                                  ; Vars: $P_RC(W), $P_Flags(RW)
 31238                                  ;***********************************************************************
 31239                                  
 31240                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31241                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31242                                  $P_SValue:
 31243 00004E9E 50                      	push	ax			;AN000;
 31244                                  	;or	byte [cs:$P_Flags2],80h
 31245 00004E9F 2E800E[4099]80          	or	byte [cs:$P_Flags2],$P_Signed
 31246                                  					;AC034; indicate a signed numeric
 31247                                  	;and	byte [cs:$P_Flags2],0FDh
 31248 00004EA5 2E8026[4099]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 31249                                  					;AC034; assume positive value
 31250 00004EAB 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 31251 00004EAE 3C2B                    	cmp	al,'+' ; 2Bh
 31252                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 31253 00004EB0 740A                    	je	short $P_SVal00		;AN000;
 31254                                  
 31255 00004EB2 3C2D                    	cmp	al,'-' ; 2Dh
 31256                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 31257 00004EB4 7507                    	jne	short $P_Sval01		;AN000; else
 31258                                  
 31259 00004EB6 2E800E[4099]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 31260                                  					;AC034; set this is negative value
 31261                                  $P_SVal00:				;AN000;
 31262 00004EBC 46                      	inc	si			;AN000; skip sign char
 31263                                  $P_Sval01:				;AN000;
 31264 00004EBD E80200                  	call	$P_Value		;AN000; and process value
 31265 00004EC0 58                      	pop	ax			;AN000;
 31266 00004EC1 C3                      	retn				;AN000;
 31267                                  
 31268                                  ;***********************************************************************
 31269                                  
 31270                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31271                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 31272                                  
 31273                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31274                                  	; MSDOS 6.2 COMMAND.COM - TRANGROUP:5119h
 31275                                  $P_Value:
 31276 00004EC2 50                      	push	ax			;AN000;
 31277 00004EC3 51                      	push	cx			;AN000;
 31278 00004EC4 52                      	push	dx			;AN000;
 31279 00004EC5 56                      	push	si			;AN000;
 31280 00004EC6 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 31281 00004EC8 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 31282 00004ECA 53                      	push	bx			;AN000; save control pointer
 31283                                  $P_Value_Loop:				;AN000;
 31284 00004ECB 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31285 00004ECE 08C0                    	or	al,al			;AN000; end of line ?
 31286 00004ED0 7442                    	jz	short $P_Value00	;AN000;
 31287                                  
 31288 00004ED2 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 31289 00004ED5 7239                    	jc	short $P_Value_Err0	;AN000;
 31290                                  
 31291 00004ED7 30E4                    	xor	ah,ah			;AN000;
 31292 00004ED9 89C5                    	mov	bp,ax			;AN000; save binary number
 31293 00004EDB D1E2                    	shl	dx,1			;AN000; to have 2*x
 31294 00004EDD D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31295 00004EDF E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31296 00004EE2 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31297                                  
 31298 00004EE4 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 31299 00004EE6 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 31300 00004EE8 D1E2                    	shl	dx,1			;AN000; to have 4*x
 31301 00004EEA D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31302 00004EEC E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31303 00004EEF 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31304                                  
 31305 00004EF1 D1E2                    	shl	dx,1			;AN000; to have 8*x
 31306 00004EF3 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 31307 00004EF5 E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31308 00004EF8 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31309                                  
 31310 00004EFA 01DA                    	add	dx,bx			;AN000; now have 10*x
 31311 00004EFC 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 31312 00004EFE E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31313 00004F01 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31314                                  
 31315 00004F03 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 31316 00004F05 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 31317 00004F08 E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31318 00004F0B 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 31319                                  
 31320 00004F0D 46                      	inc	si			;AN000; update pointer
 31321 00004F0E EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 31322                                  
 31323                                  $P_Value_Err0:				;AN000;
 31324 00004F10 5B                      	pop	bx			;AN000;
 31325 00004F11 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 31326                                  
 31327                                  $P_Value00:				;AN000;
 31328 00004F14 5B                      	pop	bx			;AN000; restore control pointer
 31329 00004F15 2EF606[4099]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 31330                                  					;AC034; here cx,dx = 32bit value
 31331 00004F1B 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 31332                                  
 31333 00004F1D F7D1                    	not	cx			;AN000; +
 31334 00004F1F F7D2                    	not	dx			;AN000; |- Make 2's complement
 31335 00004F21 83C201                  	add	dx,1			;AN000; |
 31336 00004F24 83D100                  	adc	cx,0			;AN000; +
 31337                                  $P_Value01:				;AN000; / nval =0
 31338 00004F27 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31339                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 31340 00004F2B 268A04                  	mov	al,[es:si]		;AN000; get nval
 31341 00004F2E 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 31342 00004F30 7505                    	jne	short $P_Value02	;AN000;
 31343                                  
 31344                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 31345                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 31346                                  	; 31/03/2023
 31347 00004F32 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31348 00004F35 EB6F                    	jmp	short $P_Value_Exit	;AN000;
 31349                                  
 31350                                  $P_Value02:				;AN000; / nval = 1
 31351 00004F37 46                      	inc	si			;AN000;
 31352 00004F38 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 31353 00004F3B 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 31354 00004F3D 745D                    	je	short $P_Value03	;AN000; (tm07)
 31355                                  
 31356 00004F3F 46                      	inc	si			;AN000; si points to 1st item_tag
 31357                                  $P_Val02_Loop:				;AN000;
 31358 00004F40 2EF606[4099]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 31359                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 31360 00004F46 751E                    	jnz	short $P_Val02_Sign	;AN000;
 31361                                  
 31362 00004F48 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31363                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31364 00004F4C 723B                    	jb	short $P_Val02_Next	;AN000;
 31365 00004F4E 7706                    	ja	short $P_Val_In		;AN000;
 31366                                  
 31367 00004F50 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31368                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31369 00004F54 7233                    	jb	short $P_Val02_Next	;AN000;
 31370                                  
 31371                                  $P_Val_In:				;AN000;
 31372 00004F56 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31373                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 31374 00004F5A 772D                    	ja	short $P_Val02_Next	;AN000;
 31375 00004F5C 7224                    	jb	short $P_Val_Found	;AN000;
 31376                                  
 31377 00004F5E 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31378                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31379 00004F62 7725                    	ja	short $P_Val02_Next	;AN000;
 31380                                  
 31381 00004F64 EB1C                    	jmp	short $P_Val_Found	;AN000;
 31382                                  
 31383                                  $P_Val02_Sign:				;AN000;
 31384 00004F66 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31385                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31386 00004F6A 7C1D                    	jl	short $P_Val02_Next	;AN000;
 31387 00004F6C 7F06                    	jg	short $P_SVal_In	;AN000;
 31388                                  
 31389 00004F6E 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31390                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31391 00004F72 7C15                    	jl	short $P_Val02_Next	;AN000;
 31392                                  
 31393                                  $P_SVal_In:				;AN000;
 31394 00004F74 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31395                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 31396 00004F78 7F0F                    	jg	short $P_Val02_Next	;AN000;
 31397 00004F7A 7C06                    	jl	short $P_Val_Found	;AN000;
 31398                                  
 31399 00004F7C 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31400                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31401 00004F80 7F07                    	jg	short $P_Val02_Next	;AN000;
 31402                                  
 31403                                  	;jmp	short $P_Val_Found	;AN000;
 31404                                  	; 27/04/2023
 31405                                  $P_Val_Found:				;AN000;
 31406 00004F82 B001                    	mov	al,$P_Number ; 1	;AN000;
 31407 00004F84 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31408 00004F87 EB1D                    	jmp	short $P_Value_Exit	;AN000;
 31409                                  
 31410                                  $P_Val02_Next:				;AN000;
 31411 00004F89 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 31412 00004F8C FEC8                    	dec	al			;AN000; loop nrng times in AL
 31413 00004F8E 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 31414                                  					; / Not found
 31415 00004F90 2EC706[3499]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 31416                                  	;mov	word [cs:$P_RC],6	;AC034;
 31417                                  	
 31418                                  	;mov	al,$P_Number ; 1	;AN000;
 31419                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31420                                  	; 31/03/2023
 31421 00004F97 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31422 00004F9A EB0A                    	jmp	short $P_Value_Exit	;AN000;
 31423                                  
 31424                                  	; 27/04/2023
 31425                                  ;$P_Val_Found:				;AN000;
 31426                                  	;mov	al,$P_Number ; 1	;AN000;
 31427                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31428                                  	;jmp	short $P_Value_Exit	;AN000;
 31429                                  
 31430                                  $P_Value03:				;AN000; / nval = 2
 31431                                  $P_Value04:				;AN000; / nval = 3 or else
 31432                                  $P_Value_Err:				;AN000;
 31433 00004F9C 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31434                                  					;AC034;
 31435                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31436                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31437                                  	; 31/03/2023
 31438 00004FA3 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31439                                  $P_Value_Exit:				;AN000;
 31440 00004FA6 E809FD                  	call	$P_Fill_Result		;AN000;
 31441 00004FA9 5E                      	pop	si			;AN000;
 31442 00004FAA 5A                      	pop	dx			;AN000;
 31443 00004FAB 59                      	pop	cx			;AN000;
 31444 00004FAC 58                      	pop	ax			;AN000;
 31445 00004FAD C3                      	retn				;AN000;
 31446                                  
 31447                                  ;***********************************************************************
 31448                                  ; $P_Check_OVF
 31449                                  ;
 31450                                  ; Function:  Check if overflow is occurred with consideration of
 31451                                  ;	     signed or un-signed numeric value
 31452                                  ;
 31453                                  ; Input:     Flag register
 31454                                  ;
 31455                                  ; Output:    CY = 1  :	Overflow
 31456                                  ;
 31457                                  ; Vars:     $P_Flags(R)
 31458                                  ;***********************************************************************
 31459                                  
 31460                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31461                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31462                                  $P_Check_OVF:
 31463 00004FAE 9C                      	pushf				;AN000;
 31464 00004FAF 2EF606[4099]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 31465                                  					;AC034; is it negative value ?
 31466 00004FB5 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 31467 00004FB7 9D                      	popf				;AN000; by the CY bit
 31468 00004FB8 C3                      	retn				;AN000;
 31469                                  $P_COVF:				;AN000;
 31470 00004FB9 9D                      	popf				;AN000; else,
 31471 00004FBA 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 31472 00004FBC F8                      	clc				;AN000; indicate it with CY bit
 31473 00004FBD C3                      	retn				;AN000; CY=0 means no overflow
 31474                                  $P_0099Err:	; 31/03/2023
 31475                                  $P_COVF00:				;AN000;
 31476 00004FBE F9                      	stc				;AN000; and CY=1 means overflow
 31477                                  $P_0099Err2:	; 31/03/2023
 31478 00004FBF C3                      	retn				;AN000;
 31479                                  
 31480                                  ;***********************************************************************
 31481                                  ; $P_0099;
 31482                                  ;
 31483                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 31484                                  ;
 31485                                  ; Input:     AL = character code
 31486                                  ;
 31487                                  ; Output:    CY = 1 : AL is not number
 31488                                  ;	     CY = 0 : AL contains binary value
 31489                                  ;***********************************************************************
 31490                                  
 31491                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31492                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31493                                  $P_0099:
 31494 00004FC0 3C30                    	cmp	al,"0"                  ;AN000;
 31495                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31496                                  	; 31/03/2023
 31497 00004FC2 72FB                    	jb	short $P_0099Err2
 31498                                  
 31499 00004FC4 3C39                    	cmp	al,"9"                  ;AN000;
 31500 00004FC6 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31501                                  
 31502 00004FC8 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 31503                                  	; 31/03/2023
 31504                                  	;clc				;AN000; indicate no error
 31505 00004FCA C3                      	retn				;AN000;
 31506                                  	 ;31/03/2023
 31507                                  ;$P_0099Err:				;AN000;
 31508                                  ;	stc				;AN000; indicate error
 31509                                  ;	retn				;AN000;
 31510                                  
 31511                                  ;***********************************************************************
 31512                                  ; $P_Simple_String
 31513                                  ;
 31514                                  ; Function:  See value list for the simple string
 31515                                  ;	     and make result buffer.
 31516                                  ;
 31517                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31518                                  ;	     ES:BX -> CONTROL block
 31519                                  ;
 31520                                  ; Output:    None
 31521                                  ;
 31522                                  ; Use:	$P_Fill_Result, $P_String_Comp
 31523                                  ;
 31524                                  ; Vars: $P_RC(W)
 31525                                  ;***********************************************************************
 31526                                  
 31527                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31528                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31529                                  $P_Simple_String:
 31530 00004FCB 50                      	push	ax			;AN000;
 31531 00004FCC 53                      	push	bx			;AN000;
 31532 00004FCD 52                      	push	dx			;AN000;
 31533 00004FCE 57                      	push	di			;AN000;
 31534 00004FCF 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31535                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 31536 00004FD3 268A05                  	mov	al,[es:di]		;AN000; get nval
 31537 00004FD6 08C0                    	or	al,al			;AN000; no value list ?
 31538 00004FD8 7502                    	jnz	short $P_Sim00		;AN000; then
 31539                                  	; 31/03/2023
 31540                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31541 00004FDA EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 31542                                  $P_Sim00:				;AN000;
 31543 00004FDC 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 31544 00004FDE 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 31545                                  
 31546 00004FE0 47                      	inc	di			;AN000;
 31547 00004FE1 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 31548 00004FE4 B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 31549 00004FE6 F6E4                    	mul	ah			;AN000;  Skip nrng field
 31550 00004FE8 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 31551 00004FE9 01C7                    	add	di,ax			;AN000; di points to nnval
 31552 00004FEB 268A05                  	mov	al,[es:di]		;AN000; get nnval
 31553 00004FEE B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 31554 00004FF0 F6E4                    	mul	ah			;AN000; Skip nnval field
 31555 00004FF2 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 31556 00004FF3 01C7                    	add	di,ax			;AN000; di points to nstrval
 31557 00004FF5 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 31558 00004FF8 47                      	inc	di			;AC035; add '2' to
 31559 00004FF9 47                      	inc	di			;AC035;  DI reg
 31560                                  					;AN000; di points to 1st string in list
 31561                                  $P_Sim_Loop:				;AN000;
 31562 00004FFA 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 31563 00004FFD E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 31564 00005000 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 31565                                  
 31566 00005002 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 31567 00005005 FEC8                    	dec	al			;AN000; loop nstval times in AL
 31568 00005007 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 31569                                  					;AN000; / Not found
 31570 00005009 2EC706[3499]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 31571                                  	;mov	[cs:$P_RC],8		;AC034;
 31572                                  	; 31/03/2023
 31573                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31574 00005010 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 31575                                  $P_Sim_Found:				;AN000;
 31576 00005012 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 31577 00005016 B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 31578 00005018 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 31579 0000501B EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 31580                                  $P_Sim01:				;AN000;
 31581 0000501D 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax
 31582                                  	;mov	word [cs:$P_RC],9	;AC034;
 31583                                  $P_Sim_Exit:
 31584                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31585                                  ;$P_Sim_Exit:				;AN000;
 31586                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31587                                  	; 31/03/2023
 31588 00005024 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31589                                  $P_Sim_Exit0:				;AN000;
 31590 00005027 E888FC                  	call	$P_Fill_Result		;AN000;
 31591 0000502A 5F                      	pop	di			;AN000;
 31592 0000502B 5A                      	pop	dx			;AN000;
 31593 0000502C 5B                      	pop	bx			;AN000;
 31594 0000502D 58                      	pop	ax			;AN000;
 31595 0000502E C3                      	retn				;AN000;
 31596                                  
 31597                                  ;***********************************************************************
 31598                                  ; $P_String_Comp:
 31599                                  ;
 31600                                  ; Function:  Compare two string
 31601                                  ;
 31602                                  ; Input:     psdata_seg:SI -> 1st string
 31603                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 31604                                  ;	     ES:BX -> CONTROL block
 31605                                  ;
 31606                                  ; Output:    CY = 1 if not match
 31607                                  ;
 31608                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 31609                                  ;
 31610                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 31611                                  ;***********************************************************************
 31612                                  
 31613                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31614                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31615                                  $P_String_Comp:
 31616 0000502F 50                      	push	ax			;AN000;
 31617 00005030 55                      	push	bp			;AN000;
 31618 00005031 52                      	push	dx			;AN000;
 31619 00005032 56                      	push	si			;AN000;
 31620 00005033 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31621                                  $P_SCOM_Loop:				;AN000;
 31622 00005035 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31623 00005038 E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31624 0000503B 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31625                                  
 31626 0000503D E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31627                                  	
 31628 00005040 2EF606[4099]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31629                                  					;AC034; keyword search ?
 31630 00005046 740D                    	jz	short $P_SCOM04		;AN000;
 31631                                  
 31632                                  	;cmp	al,'=' ; 3Dh
 31633 00005048 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31634 0000504A 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31635                                  
 31636 0000504C 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31637 00005051 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31638                                  
 31639 00005053 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31640                                  
 31641                                  $P_SCOM04:				;AN000;
 31642 00005055 2EF606[4099]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31643                                  					;AC034; switch search ?
 31644 0000505B 740E                    	jz	short $P_SCOM03		;AN000;
 31645                                  
 31646 0000505D 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 31647 0000505F 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 31648                                  
 31649 00005061 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 31650 00005066 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 31651                                  
 31652                                  $P_SCOM05:				;AN000;   found a match
 31653 00005068 46                      	inc	si			;AN000; si points to just after "=" or ":"
 31654 00005069 EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 31655                                  
 31656                                  $P_SCOM03:				;AN000;
 31657 0000506B 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 31658 0000506F 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 31659                                  
 31660 00005071 08C0                    	or	al,al			;AN000; end of line
 31661 00005073 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 31662                                  
 31663 00005075 46                      	inc	si			;AN000; update operand pointer
 31664 00005076 45                      	inc	bp			;AN000;    and synonym pointer
 31665 00005077 EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 31666                                  
 31667                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 31668 00005079 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 31669 0000507D 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 31670                                  
 31671 0000507F 46                      	inc	si			;AN000; else, load next byte
 31672 00005080 2E8A04                  	mov	al,[cs:si]		;AN000; and
 31673 00005083 45                      	inc	bp			;AN000;
 31674 00005084 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 31675 00005088 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 31676                                  
 31677 0000508A 46                      	inc	si			;AN000; else update operand pointer
 31678 0000508B 45                      	inc	bp			;AN000; 	and synonym pointer
 31679                                  $P_SCOM01:				;AN000;
 31680 0000508C EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 31681                                  
 31682                                  $P_SCOM_Differ0:			;AN000;
 31683 0000508E 2EF606[4099]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 31684                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 31685 00005094 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 31686                                  
 31687                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 31688                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 31689                                  	; 03/04/2023
 31690 00005096 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 31691 0000509B 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 31692                                  
 31693 0000509D 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 31694 000050A2 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 31695                                  
 31696                                  $P_not_applicable:			;AN000;(tm10)
 31697                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31698                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 31699                                  	; 03/04/2023
 31700 000050A4 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31701 000050A8 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 31702                                  
 31703 000050AA 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 31704 000050AC 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 31705                                  
 31706 000050AE 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 31707                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 31708                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 31709                                  	; 01/04/2023
 31710 000050B3 740E                    	je	short $P_SCOM_Same
 31711                                  $P_SCOM_Differ:
 31712 000050B5 F9                      	stc
 31713 000050B6 EB10                    	jmp	short $P_SCOM_Exit
 31714                                  
 31715                                  $P_SCOM02:				;AN000;
 31716 000050B8 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 31717 000050BA 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 31718                                  
 31719                                  	;cmp	byte [es:bp],':'
 31720 000050BC 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 31721                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 31722                                  	; 01/04/2023
 31723 000050C1 75F2                    	jne	short $P_SCOM_Differ
 31724                                  ;$P_SCOM_Differ: 			;AN000;
 31725                                  	;stc				;AN000; indicate not found
 31726                                  	;jmp	short $P_SCOM_Exit	;AN000;
 31727                                  
 31728                                  $P_SCOM_Same:				;AN000;
 31729 000050C3 2E8936[4399]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 31730                                  	; 01/04/2023
 31731                                  	;clc
 31732                                  	; cf = 0			;AN000; indicate found
 31733                                  $P_SCOM_Exit:				;AN000;
 31734 000050C8 5E                      	pop	si			;AN000;
 31735 000050C9 5A                      	pop	dx			;AN000;
 31736 000050CA 5D                      	pop	bp			;AN000;
 31737 000050CB 58                      	pop	ax			;AN000;
 31738 000050CC C3                      	retn				;AN000;
 31739                                  
 31740                                  ;***********************************************************************
 31741                                  ; $P_Date_Format
 31742                                  ;
 31743                                  ; Function:  Convert a date string to DOS date format for int 21h
 31744                                  ;	     with format validation.
 31745                                  ;
 31746                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31747                                  ;	     ES:BX -> CONTROL block
 31748                                  ;
 31749                                  ; Output:    None
 31750                                  ;
 31751                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 31752                                  ;
 31753                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 31754                                  ;***********************************************************************
 31755                                  
 31756                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31757                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31758                                  $P_Date_Format:
 31759 000050CD 50                      	push	ax			;AN000;
 31760 000050CE 51                      	push	cx			;AN000;
 31761 000050CF 52                      	push	dx			;AN000;
 31762 000050D0 56                      	push	si			;AN000;
 31763 000050D1 53                      	push	bx			;AN000;
 31764 000050D2 56                      	push	si			;AN000;
 31765 000050D3 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 31766                                  	; 03/04/2023
 31767                                  	;pop	si			;AN000;
 31768                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31769                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31770                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31771 000050D6 31F6                    	xor	si,si
 31772 000050D8 2E8936[F299]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 31773 000050DD 2E8936[F499]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 31774                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 31775 000050E2 5E                      	pop	si
 31776 000050E3 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 31777 000050E6 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 31778 000050E8 2EA3[F299]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 31779 000050EC 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31780 000050EE 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31781 000050F0 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 31782 000050F3 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 31783 000050F5 2EA3[F499]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 31784 000050F9 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 31785 000050FB 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 31786 000050FD E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 31787                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 31788 00005100 7260                    	jc	short $P_DateF_Error	;AN000;
 31789 00005102 2EA3[F699]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31790 00005106 08DB                    	or	bl,bl			;AN000; end of line ?
 31791 00005108 7558                    	jnz	short $P_DateF_Error	;AN000;
 31792                                  $P_DateF_YMD:				;AN000;
 31793 0000510A 2E8B1E[D099]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 31794                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 31795 0000510F 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 31796 00005112 7422                    	je	short $P_DateF00	;AN000;
 31797 00005114 2EA1[F299]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31798 00005118 08E4                    	or	ah,ah			;AN000;
 31799 0000511A 7546                    	jnz	short $P_DateF_Error	;AN000;
 31800 0000511C 88C1                    	mov	cl,al			;AN000; set month
 31801 0000511E 2EA1[F499]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31802 00005122 08E4                    	or	ah,ah			;AN000; if overflow, error.
 31803 00005124 753C                    	jnz	short $P_DateF_Error	;AN000;
 31804 00005126 88C5                    	mov	ch,al			;AN000; set date
 31805 00005128 2E8B16[F699]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 31806 0000512D 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 31807 00005130 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 31808 00005132 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 31809                                  $P_DateF01:				;AN000;
 31810 00005134 EB19                    	jmp	short $P_DateF02	;AN000;
 31811                                  $P_DateF00:				;AN000; / here format = YMD
 31812 00005136 2E8B16[F299]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 31813 0000513B 2EA1[F499]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31814 0000513F 08E4                    	or	ah,ah			;AN000; if overflow, error
 31815 00005141 751F                    	jnz	short $P_DateF_Error	;AN000;
 31816                                  
 31817 00005143 88C1                    	mov	cl,al			;AN000; set month
 31818 00005145 2EA1[F699]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31819 00005149 08E4                    	or	ah,ah			;AN000; if overflow, error
 31820 0000514B 7515                    	jnz	short $P_DateF_Error	;AN000;
 31821 0000514D 88C5                    	mov	ch,al			;AN000; set date
 31822                                  $P_DateF02:				;AN000;
 31823 0000514F 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 31824 00005152 7304                    	jae	short $P_DateF03	;AN000;
 31825 00005154 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 31826                                  $P_DateF03:				;AN000;
 31827 00005158 5B                      	pop	bx			;AN000; recover CONTROL block
 31828 00005159 5E                      	pop	si			;AN000; recover string pointer
 31829                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31830                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 31831                                  	; 03/04/2023
 31832 0000515A B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 31833 0000515D E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 31834 00005160 EB0F                    	jmp	short $P_Date_Format_Exit
 31835                                  					;AN000;	to Date
 31836                                  $P_DateF_Error: 			;AN000;
 31837 00005162 5B                      	pop	bx			;AN000; recover CONTROL block
 31838 00005163 5E                      	pop	si			;AN000; recover string pointer
 31839                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31840                                  	;mov	al,$P_String ; 3	;AN000;   result
 31841                                  	; 03/04/2023
 31842 00005164 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31843 00005167 E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 31844                                  					;AN000; to string
 31845 0000516A 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31846                                  					;AC034; indicate syntax error
 31847                                  $P_Date_Format_Exit:			;AN000;
 31848 00005171 5A                      	pop	dx			;AN000;
 31849 00005172 59                      	pop	cx			;AN000;
 31850 00005173 58                      	pop	ax			;AN000;
 31851 00005174 C3                      	retn				;AN000;
 31852                                  
 31853                                  ;***********************************************************************
 31854                                  ; $P_Set_CDI:
 31855                                  ;
 31856                                  ; Function: Read CDI from DOS if it has not been read yet
 31857                                  ;
 31858                                  ; Input:    None
 31859                                  ;
 31860                                  ; Output:   psdata_seg:SI -> CDI
 31861                                  ;
 31862                                  ; Use:	INT 21h w/ AH = 38h
 31863                                  ;***********************************************************************
 31864                                  
 31865                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31866                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31867                                  $P_Set_CDI:
 31868                                  	; 18/04/2023
 31869 00005175 8D36[D099]              	lea	si,$P_Country_Info	;AC034;
 31870                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 31871 00005179 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 31872                                  					;AN000; already read ?
 31873                                  	;je	short $P_Read_CDI	;AN000;
 31874                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 31875                                  	; 03/04/2023
 31876 0000517D 750F                    	jne	short $P_Set_CDI_Exit
 31877                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 31878 0000517F 1E                      	push	ds			;AN000;
 31879 00005180 52                      	push	dx			;AN000;
 31880 00005181 50                      	push	ax			;AN000;
 31881 00005182 0E                      	push	cs			;AC023;
 31882 00005183 1F                      	pop	ds			;AN000; set segment register
 31883                                  	;mov	ax,3800h
 31884 00005184 B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 31885 00005187 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 31886 00005189 CD21                    	int	21h			;AN000;
 31887 0000518B 58                      	pop	ax			;AN000;
 31888 0000518C 5A                      	pop	dx			;AN000;
 31889 0000518D 1F                      	pop	ds			;AN000;
 31890                                  $P_Set_CDI_Exit:			;AN000;
 31891 0000518E C3                      	retn				;AN000;
 31892                                  
 31893                                  ;***********************************************************************
 31894                                  ; $P_Get_DecNum:
 31895                                  ;
 31896                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 31897                                  ;	     or NULL encountered. And make a decimal number.
 31898                                  ;
 31899                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31900                                  ;
 31901                                  ; Output:    BL = delimiter code or NULL
 31902                                  ;	     AX = Decimal number
 31903                                  ;	     SI advanced to the next number
 31904                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 31905                                  ;
 31906                                  ; Use:	$P_0099
 31907                                  ;***********************************************************************
 31908                                  
 31909                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31910                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31911                                  $P_Get_DecNum:
 31912 0000518F 51                      	push	cx			;AN000;
 31913 00005190 52                      	push	dx			;AN000;
 31914 00005191 31C9                    	xor	cx,cx			;AN000; cx will have final value
 31915                                  $P_GetNum_Loop: 			;AN000;
 31916 00005193 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31917 00005196 08C0                    	or	al,al			;AN000; end of line ?
 31918 00005198 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 31919 0000519A 2E803E[CF99]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 31920 000051A0 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 31921                                  
 31922                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 31923                                  	;cmp	bl,$P_colon_period
 31924 000051A2 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 31925 000051A5 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 31926                                  
 31927 000051A7 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31928 000051A9 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31929                                  
 31930                                  	; 03/04/2023
 31931 000051AB EB08                    	jmp	short $P_Do_Time_Delim1
 31932                                  ;$P_Do_Time_Delim1:			;AN000;
 31933                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31934                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31935                                  	;
 31936                                  	;jmp	short $P_Neither_Delims ;AN023;
 31937                                  
 31938                                  $P_Do_Date_Delims:			;AN000;
 31939                                  ;Regardless of the date delimiter character specified in the country
 31940                                  ;dependent information, check for the presence of any one of these
 31941                                  ;three field delimiters: "-", "/", or ".".
 31942 000051AD 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31943 000051AF 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31944                                  
 31945 000051B1 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31946 000051B3 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31947                                  
 31948                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31949 000051B5 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31950 000051B7 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31951                                  
 31952                                  $P_Neither_Delims:			;AN023;
 31953 000051B9 E804FE                  	call	$P_0099 		;AN000; convert it to binary
 31954 000051BC 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31955                                  
 31956 000051BE B400                    	mov	ah,0			;AN000;
 31957 000051C0 91                      	xchg	ax,cx			;AN000;
 31958 000051C1 BA0A00                  	mov	dx,10			;AN000;
 31959 000051C4 F7E2                    	mul	dx			;AN000; ax = ax * 10
 31960 000051C6 09D2                    	or	dx,dx			;AN000; overflow
 31961 000051C8 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31962                                  
 31963 000051CA 01C8                    	add	ax,cx			;AN000;
 31964 000051CC 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31965                                  
 31966 000051CE 91                      	xchg	ax,cx			;AN000;
 31967 000051CF 46                      	inc	si			;AN000;
 31968 000051D0 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31969                                  
 31970                                  $P_GetNum00:				;AN000;
 31971 000051D2 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31972                                  	;03/04/2023
 31973                                  	; cf=0
 31974                                  	;clc				;AN000; indicate no error
 31975 000051D4 EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31976                                  
 31977                                  $P_GetNum01:				;AN000;
 31978 000051D6 46                      	inc	si			;AN000; si points to next number
 31979                                  	;03/04/2023
 31980                                  	; cf=0
 31981                                  	;clc				;AN000; indicate no error
 31982 000051D7 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31983                                  
 31984                                  $P_GetNum02:				;AN000;
 31985 000051D9 F9                      	stc				;AN000; indicate error
 31986                                  $P_GetNum_Exit: 			;AN000;
 31987 000051DA 89C8                    	mov	ax,cx			;AN000;return value
 31988 000051DC 5A                      	pop	dx			;AN000;
 31989 000051DD 59                      	pop	cx			;AN000;
 31990 000051DE C3                      	retn				;AN000;
 31991                                  
 31992                                  ;***********************************************************************
 31993                                  ; $P_Time_Format
 31994                                  ;
 31995                                  ; Function:  Convert a time string to DOS time format for int 21h
 31996                                  ;	     with format validation.
 31997                                  ;
 31998                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31999                                  ;	     ES:BX -> CONTROL block
 32000                                  ;
 32001                                  ; Output:    None
 32002                                  ;
 32003                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 32004                                  ;
 32005                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 32006                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 32007                                  ;***********************************************************************
 32008                                  
 32009                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32010                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32011                                  $P_Time_Format:				;AN000;
 32012 000051DF 50                      	push	ax			;AN000;
 32013 000051E0 51                      	push	cx			;AN000;
 32014 000051E1 52                      	push	dx			;AN000;
 32015 000051E2 56                      	push	si			;AN000;
 32016 000051E3 53                      	push	bx			;AN000;
 32017 000051E4 56                      	push	si			;AN000;
 32018 000051E5 E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 32019                                  					; information before process
 32020                                  	;test	byte [cs:si+11h], 1
 32021 000051E8 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 32022                                  					;AN000; 24 hour system
 32023 000051ED 5E                      	pop	si			;AN000;
 32024 000051EE 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 32025 000051F0 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 32026                                  $P_TimeF00:				;AN000;
 32027                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 32028                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 32029                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 32030                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 32031                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 32032                                  	; 03/04/2023
 32033 000051F3 31DB                    	xor	bx,bx
 32034 000051F5 2E891E[F299]            	mov	[cs:$P_1st_Val],bx ; 0
 32035 000051FA 2E891E[F499]            	mov	[cs:$P_2nd_Val],bx ; 0
 32036 000051FF 2E891E[F699]            	mov	[cs:$P_3rd_Val],bx ; 0
 32037 00005204 2E891E[F899]            	mov	[cs:$P_4th_Val],bx ; 0
 32038                                  	;inc	bl
 32039                                  	;mov	[cs:$P_Got_Time],bl ; 1
 32040                                  
 32041                                  	;mov	bl,$P_colon_period
 32042                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 32043                                  					; delimiters between hours,
 32044                                  					;  minutes,seconds
 32045                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 32046 00005209 FEC3                    	inc	bl ; bl = 1
 32047 0000520B 2E881E[CF99]            	mov	[cs:$P_Got_Time],bl ; 1
 32048                                  	;
 32049 00005210 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 32050 00005213 725D                    	jc	short $P_TimeF_Err0	;AN000;
 32051 00005215 2EA3[F299]              	mov	[cs:$P_1st_Val],ax	;AC034;
 32052 00005219 08DB                    	or	bl,bl			;AN000; end of line ?
 32053 0000521B 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 32054 0000521D E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 32055 00005220 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 32056 00005222 2EA3[F499]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 32057 00005226 08DB                    	or	bl,bl			;AN000; end of line ?
 32058 00005228 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 32059 0000522A B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 32060 0000522C E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 32061 0000522F 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 32062 00005231 2EA3[F699]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 32063 00005235 08DB                    	or	bl,bl			;AN000; end of line ?
 32064 00005237 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 32065                                  					;AN039;   GO TO 4TH NUMBER
 32066                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 32067 00005239 2EF606[3F99]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 32068                                  					;AN039;    BEEN REPEATED?
 32069 0000523F 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 32070                                  					;AN039;   the end of line
 32071                                  					;AN039; no, time has not been repeated
 32072 00005241 2E8B36[3699]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 32073                                  					;AN039;   in command line
 32074 00005246 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 32075                                  					;AN039; look at delimiter
 32076                                  					;AN039;   from command line
 32077 0000524A 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 32078                                  					;AN039;  really end of line
 32079                                  					;AN039; is comma before hundredths,
 32080                                  					;AN039;   redo TIME
 32081 0000524C C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 32082                                  					;AN039; change that ambiguous
 32083                                  					;AN039;    comma to a decimal point
 32084                                  					;AN039;     parse can understand
 32085 00005250 2EC706[3F99]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 32086                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 32087 00005257 2E800E[3F99]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 32088                                  					;AN039; is being repeated
 32089 0000525D 2E8B0E[C999]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 32090 00005262 2E8B26[CB99]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 32091                                  					;AN039;   OF STACK FROM SP
 32092 00005267 2E8B36[CD99]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 32093                                  					;AN039;   PARSE POINTER FROM SI
 32094 0000526C E913F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 32095                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 32096 0000526F E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 32097                                  $P_TimeF_Err0:				;AN000; Bridge
 32098 00005272 725E                    	jc	short $P_TimeF_Error	;AN000;
 32099                                  	;
 32100 00005274 2EA3[F899]              	mov	[cs:$P_4th_Val],ax	;AC034;
 32101 00005278 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 32102 0000527A 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 32103                                  $P_TimeF_Rlt:				;AN000;
 32104 0000527C 2EA1[F299]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 32105 00005280 08E4                    	or	ah,ah			;AN000; if overflow then error
 32106 00005282 754E                    	jnz	short $P_TimeF_Err	;AN000;
 32107                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 32108 00005284 2EF606[3F99]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 32109 0000528A 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 32110                                  					;since "AM" was specified,
 32111 0000528C 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 32112 0000528E 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 32113 00005290 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 32114 00005292 30C0                    	xor	al,al			;AN038; set hour = zero
 32115                                  $P_Time_notAM:				;AN038;
 32116                                  	;test	byte [cs:$P_Flags2],$P_Time12
 32117 00005294 2EF606[4099]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 32118 0000529A 740C                    	jz	short $P_TimeSkip00	;AN000; then
 32119 0000529C 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 32120 0000529E 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 32121 000052A0 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 32122 000052A2 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 32123 000052A4 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 32124 000052A6 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 32125                                  $P_TimeSkip00:				;AN000;
 32126 000052A8 88C2                    	mov	dl,al			;AN000; set hour
 32127 000052AA 2EA1[F499]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32128 000052AE 08E4                    	or	ah,ah			;AN000; if overflow then error
 32129 000052B0 7520                    	jnz	short $P_TimeF_Err	;AN000;
 32130 000052B2 88C6                    	mov	dh,al			;AN000; set minute
 32131 000052B4 2EA1[F699]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 32132 000052B8 08E4                    	or	ah,ah			;AN000; if overflow then error
 32133 000052BA 7516                    	jnz	short $P_TimeF_Err	;AN000;
 32134 000052BC 88C1                    	mov	cl,al			;AN000; set second
 32135 000052BE 2EA1[F899]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 32136 000052C2 08E4                    	or	ah,ah			;AN000; if overflow then error
 32137 000052C4 750C                    	jnz	short $P_TimeF_Err	;AN000;
 32138 000052C6 88C5                    	mov	ch,al			;AN000; set hundredth
 32139 000052C8 5B                      	pop	bx			;AN000; recover CONTROL block
 32140 000052C9 5E                      	pop	si			;AN000; recover string pointer
 32141                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32142                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 32143                                  	; 03/04/2023
 32144 000052CA B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 32145 000052CD E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 32146 000052D0 EB0F                    	jmp	short $P_Time_Format_Exit
 32147                                  					;AN000; to time
 32148                                  $P_TimeF_Error: 			;AN000;
 32149                                  $P_TimeF_Err:				;AN000;
 32150 000052D2 5B                      	pop	bx			;AN000; recover CONTROL block
 32151 000052D3 5E                      	pop	si			;AN000; recover string pointer
 32152                                  	;mov	ah,$P_No_Tag		;AN000; set
 32153                                  	;mov	al,$P_String		;AN000;     result
 32154                                  	; 03/04/2023
 32155 000052D4 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 32156 000052D7 E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 32157                                  					;AN000; to string
 32158 000052DA 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 32159                                  					;AC034; return syntax error
 32160                                  $P_Time_Format_Exit:			;AN000;
 32161 000052E1 2EC606[CF99]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 32162 000052E7 5A                      	pop	dx			;AN000;
 32163 000052E8 59                      	pop	cx			;AN000;
 32164 000052E9 58                      	pop	ax			;AN000;
 32165 000052EA C3                      	retn
 32166                                  
 32167                                  ;***********************************************************************
 32168                                  ; $P_Time_2412:
 32169                                  ;
 32170                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 32171                                  ;
 32172                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32173                                  ;
 32174                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 32175                                  ;	     or "pm"
 32176                                  ;
 32177                                  ; Vars:  $P_Flags(W)
 32178                                  ;***********************************************************************
 32179                                  
 32180                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32181                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32182                                  $P_Time_2412:				;AN000;
 32183 000052EB 50                      	push	ax			;AN000;
 32184 000052EC 56                      	push	si			;AN000;
 32185                                  $P_T12_Loop:				;AN000;
 32186 000052ED 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 32187 000052F0 46                      	inc	si			;AN000;     si
 32188 000052F1 08C0                    	or	al,al			;AN000;       to
 32189 000052F3 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 32190                                  
 32191 000052F5 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 32192                                  	;or	al,20h
 32193 000052F9 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32194 000052FB 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 32195 000052FD 7425                    	je	short $P_T1200		;AN000;
 32196                                  
 32197 000052FF 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 32198 00005301 7413                    	je	short $P_T1201		;AN000;
 32199                                  
 32200 00005303 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 32201 00005305 751A                    	jne	short $P_T12_Exit	;AN000;
 32202                                  
 32203 00005307 4E                      	dec	si			;AN000;
 32204 00005308 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 32205                                  	;or	al,20h
 32206 0000530C 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32207 0000530E 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 32208 00005310 7412                    	je	short $P_T1200		;AN000;
 32209                                  
 32210 00005312 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 32211                                  	;je	short $P_T1201		;AN000; go process "a"
 32212                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 32213                                  	; 05/04/2023
 32214 00005314 750B                    	jne	short $P_T12_Exit
 32215                                  
 32216                                  ;$P_T1200:				;AN000; "P" found
 32217                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 32218                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32219                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32220                                  
 32221                                  $P_T1201:				;AN000; "A" found
 32222                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 32223 00005316 2E800E[3F99]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 32224                                  $P_Tclr_chr:				;AN038;
 32225 0000531C 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 32226                                  $P_T12_Exit:				;AN000;
 32227 00005321 5E                      	pop	si			;AN000;
 32228 00005322 58                      	pop	ax			;AN000;
 32229 00005323 C3                      	retn				;AN000;
 32230                                  
 32231                                  	; 05/04/2023
 32232                                  $P_T1200:				;AN000; "P" found
 32233                                  	;or	byte [cs:$P_Flags2],$P_Time12
 32234 00005324 2E800E[4099]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32235 0000532A EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32236                                  
 32237                                  ;***********************************************************************
 32238                                  ; $P_File_Format;
 32239                                  ;
 32240                                  ; Function:  Check if the input string is valid file spec format.
 32241                                  ;	     And set the result buffer.
 32242                                  ;
 32243                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32244                                  ;	     ES:BX -> CONTROL block
 32245                                  ;
 32246                                  ; Output:    None
 32247                                  ;
 32248                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 32249                                  ;
 32250                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 32251                                  ;	$P_SaveSI_Cmpx(R)
 32252                                  ;***********************************************************************
 32253                                  
 32254                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32255                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 32256                                  
 32257                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32258                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:55B4h
 32259                                  $P_File_Format:
 32260 0000532C 50                      	push	ax			;AN000;
 32261 0000532D 57                      	push	di			;AN000;
 32262 0000532E 56                      	push	si			;AN000;
 32263 0000532F 2E8B3E[4199]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 32264 00005334 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 32265 00005337 08C0                    	or	al,al			;AN000; end of line ?
 32266 00005339 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 32267 0000533B E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 32268 0000533E 7523                    	jne	short $P_FileF03	;AN000; if yes,
 32269 00005340 2EC606[0D9A]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 32270                                  					;AN033;AC034;; set error flag- bad char.
 32271 00005346 5E                      	pop	si			;AN033;
 32272 00005347 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 32273 0000534B 5F                      	pop	di			;AN033;
 32274 0000534C EB3E                    	jmp	short $P_FileF02	;AN033;
 32275                                  $P_FileF_Err:				;AN000;
 32276 0000534E 5E                      	pop	si			;AN000;
 32277 0000534F 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 32278 00005353 5F                      	pop	di			;AN000;
 32279                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 32280                                  	;test	word [es:bx],1		;AN000; is it optional ?
 32281 00005354 26F60701                	test	byte [es:bx],$P_Optional ; 1
 32282 00005358 7532                    	jnz	short $P_FileF02	;AN000;
 32283 0000535A 2EC706[3499]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 32284                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 32285 00005361 EB29                    	jmp	short $P_FileF02	;AN000;
 32286                                  $P_FileF03:				;AN000;
 32287 00005363 58                      	pop	ax			;AN000; discard save si
 32288 00005364 56                      	push	si			;AN000; save new si
 32289                                  $P_FileF_Loop1: 			;AN000;
 32290 00005365 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 32291 00005368 08C0                    	or	al,al			;AN000; end of line ?
 32292 0000536A 741E                    	jz	short $P_FileF_RLT	;AN000;
 32293 0000536C E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 32294 0000536F 740B                    	jz	short $P_FileF00	;AN000;
 32295 00005371 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 32296 00005374 7302                    	jnc	short $P_FileF01	;AN000;
 32297 00005376 47                      	inc	di			;AN000; if yes, skip next byte
 32298 00005377 46                      	inc	si			;AN000;
 32299                                  $P_FileF01:				;AN000;
 32300 00005378 47                      	inc	di			;AN000;
 32301 00005379 46                      	inc	si			;AN000;
 32302 0000537A EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 32303                                  $P_FileF00:				;AN000;
 32304 0000537C 2EA2[3A99]              	mov	[cs:$P_Terminator],al	;AC034;
 32305 00005380 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 32306 00005384 47                      	inc	di			;AN000;
 32307 00005385 2E893E[3699]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 32308                                  $P_FileF_RLT:				;AN000;
 32309 0000538A 5E                      	pop	si			;AN000;
 32310 0000538B 5F                      	pop	di			;AN000;
 32311                                  $P_FileF02:				;AN000;
 32312 0000538C 58                      	pop	ax			;AN000; (tm14)
 32313                                  	;;test	ax,200h
 32314                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 32315                                  	; 05/04/2023
 32316 0000538D F6C402                  	test	ah,($P_File_Spc>>8)
 32317 00005390 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 32318 00005392 50                      	push	ax			;AN000; (tm14)
 32319                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32320                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 32321                                  	; 05/04/2023
 32322 00005393 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 32323 00005396 E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 32324 00005399 58                      	pop	ax			;AN000;
 32325                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 32326 0000539A C3                      	retn				;AN000;
 32327                                  
 32328                                  ;***********************************************************************
 32329                                  ; $P_FileSp_Chk
 32330                                  ;
 32331                                  ; Function:  Check if the input byte is one of file special characters
 32332                                  ;
 32333                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32334                                  ;	     AL = character code to be examineed
 32335                                  ;
 32336                                  ; Output:    ZF = 1 , AL is one of special characters
 32337                                  ;***********************************************************************
 32338                                  
 32339                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32340                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32341                                  $P_FileSp_Chk:
 32342 0000539B 53                      	push	bx			;AN000;
 32343 0000539C 51                      	push	cx			;AN000;
 32344                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 32345 0000539D 8D1E[049A]              	lea	bx,$P_FileSp_Char ; "[]|<>+=;\""
 32346 000053A1 B90900                  	mov	cx,$P_FileSp_Len ; 9
 32347                                  	;mov	cx,9			;AN000; load length of it
 32348                                  $P_FileSp_Loop: 			;AN000;
 32349 000053A4 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 32350 000053A7 7404                    	je	short $P_FileSp_Exit	;AN000;
 32351 000053A9 43                      	inc	bx			;AN000;
 32352 000053AA E2F8                    	loop	$P_FileSp_Loop		;AN000;
 32353 000053AC 41                      	inc	cx			;AN000; reset ZF
 32354                                  $P_FileSp_Exit: 			;AN000;
 32355 000053AD 59                      	pop	cx			;AN000;
 32356 000053AE 5B                      	pop	bx			;AN000;
 32357 000053AF C3                      	retn				;AN000;
 32358                                  
 32359                                  ;***********************************************************************
 32360                                  ; $P_Drive_Format;
 32361                                  ;
 32362                                  ; Function:  Check if the input string is valid drive only format.
 32363                                  ;	     And set the result buffer.
 32364                                  ;
 32365                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32366                                  ;	     ES:BX -> CONTROL block
 32367                                  ;
 32368                                  ; Output:    None
 32369                                  ;
 32370                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 32371                                  ;
 32372                                  ; Vars: $P_RC(W)
 32373                                  ;***********************************************************************
 32374                                  
 32375                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32376                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32377                                  $P_Drive_Format:
 32378 000053B0 50                      	push	ax			;AN000;
 32379 000053B1 52                      	push	dx			;AN000;
 32380 000053B2 2E8A04                  	mov	al,[cs:si]		;AN000;
 32381 000053B5 08C0                    	or	al,al			;AN000; if null string
 32382 000053B7 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 32383 000053B9 E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 32384 000053BC 722A                    	jc	short $P_Drv_Err	;AN000;
 32385                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 32386 000053BE 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 32387 000053C3 740D                    	je	short $P_DrvF00		;AN000;
 32388                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 32389                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 32390 000053C5 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 32391 000053C9 741D                    	jz	short $P_Drv_Err	;AN000;
 32392 000053CB 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 32393 000053D0 7516                    	jne	short $P_Drv_Err	;AN000;
 32394                                  $P_DrvF00:				;AN000;
 32395 000053D2 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 32396 000053D4 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 32397 000053D6 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 32398 000053D8 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 32399 000053DA 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 32400 000053DC 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 32401 000053DE 88C2                    	mov	dl,al			;AN000; set
 32402                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 32403                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 32404                                  	; 05/04/2023
 32405 000053E0 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 32406 000053E3 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 32407 000053E6 EB07                    	jmp	short $P_Drv_Exit	;AN000;
 32408                                  $P_Drv_Err:				;AN000;
 32409 000053E8 2EC706[3499]0900        	mov	word [cs:$P_RC],$P_Syntax
 32410                                  	;mov	word [cs:$P_RC],9	;AC034;
 32411                                  $P_Drv_Exit:				;AN000;
 32412 000053EF 5A                      	pop	dx			;AN000;
 32413 000053F0 58                      	pop	ax			;AN000;
 32414 000053F1 C3                      	retn				;AN000;
 32415                                  
 32416                                  ;***********************************************************************
 32417                                  ; $P_Skip_Delim;
 32418                                  ;
 32419                                  ; Function: Skip delimiters specified in the PARMS list, white space
 32420                                  ;	    and comma.
 32421                                  ;
 32422                                  ; Input:    DS:SI -> Command String
 32423                                  ;	    ES:DI -> Parameter List
 32424                                  ;
 32425                                  ; Output:   CY = 1 if the end of line encounterd
 32426                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 32427                                  ;	    AL = Last examineed character
 32428                                  ;
 32429                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 32430                                  ;
 32431                                  ; Vars:     $P_Flags(R)
 32432                                  ;***********************************************************************
 32433                                  
 32434                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32435                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32436                                  $P_Skip_Delim:				;AN000;
 32437                                  $P_Skip_Delim_Loop:			;AN000;
 32438 000053F2 AC                      	lodsb				;AN000;
 32439 000053F3 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 32440 000053F6 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 32441                                  
 32442 000053F8 E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 32443 000053FB 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 32444                                  
 32445 000053FD 2EF606[4099]20          	test	byte [cs:$P_Flags2],$P_Extra
 32446                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 32447 00005403 74ED                    	jz	short $P_Skip_Delim_Loop
 32448                                  					;AN000; if no, loop
 32449 00005405 2EF606[4099]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 32450                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 32451                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 32452                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 32453                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 32454                                  	; 05/04/2023
 32455 0000540B 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 32456                                  $P_Exit_At_Extra:			;AN000;
 32457                                  	; cf = 0
 32458                                  	;clc				;AN000; indicate extra delim
 32459 0000540D C3                      	retn				;AN000;
 32460                                  
 32461                                  $P_Skip_Delim_CY:			;AN000;
 32462 0000540E F9                      	stc				;AN000; indicate EOL
 32463 0000540F EB01                    	jmp	short $P_Skip_Delim_Exit
 32464                                  					;AN000;
 32465                                  $P_Skip_Delim_NCY:			;AN000;
 32466 00005411 F8                      	clc				;AN000; indicate non delim
 32467                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 32468 00005412 4E                      	dec	si ; *			;AN000;  backup index pointer
 32469 00005413 C3                      	retn				;AN000;
 32470                                  	; 05/04/2023
 32471                                  ;$P_Exit_At_Extra:			;AN000;
 32472                                  	;clc				;AN000; indicate extra delim
 32473                                  	;retn				;AN000;
 32474                                  
 32475                                  ;***********************************************************************
 32476                                  ; $P_Chk_EOL;
 32477                                  ;
 32478                                  ; Function: Check if AL is one of End of Line characters.
 32479                                  ;
 32480                                  ; Input:    AL = character code
 32481                                  ;	    ES:DI -> Parameter List
 32482                                  ;
 32483                                  ; Output:   ZF = 1 if one of End of Line characters
 32484                                  ;***********************************************************************
 32485                                  
 32486                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32487                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32488                                  $P_Chk_EOL:
 32489 00005414 53                      	push	bx			;AN000;
 32490 00005415 51                      	push	cx			;AN000;
 32491 00005416 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 32492 00005418 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32493 0000541A 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 32494 0000541C 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32495 0000541E 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 32496                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 32497 00005423 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 32498 00005425 31DB                    	xor	bx,bx			;AN000;
 32499 00005427 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32500                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 32501 0000542B 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 32502 0000542E 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 32503                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 32504 00005432 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 32505 00005434 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 32506 00005436 268A09                  	mov	cl,[es:bx+di]		;AN000;
 32507                                  $P_Chk_EOL_Loop:			;AN000;
 32508 00005439 43                      	inc	bx			;AN000;
 32509 0000543A 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 32510 0000543D 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32511 0000543F E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 32512                                  $P_Chk_EOL_NZ:				;AN000;
 32513 00005441 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 32514                                  $P_Chk_EOL_Exit:			;AN000;
 32515 00005443 59                      	pop	cx			;AN000;
 32516 00005444 5B                      	pop	bx			;AN000;
 32517 00005445 C3                      	retn				;AN000;
 32518                                  
 32519                                  ;***********************************************************************
 32520                                  ; $P_Chk_Delim;
 32521                                  ;
 32522                                  ; Function: Check if AL is one of delimiter characters.
 32523                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 32524                                  ;	    blanks.
 32525                                  ;
 32526                                  ; Input:    AL = character code
 32527                                  ;	    DS:SI -> Next Character
 32528                                  ;	    ES:DI -> Parameter List
 32529                                  ;
 32530                                  ; Output:   ZF = 1 if one of delimiter characters
 32531                                  ;	    SI points to the next character
 32532                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 32533                                  ;***********************************************************************
 32534                                  
 32535                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32536                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32537                                  $P_Chk_Delim:
 32538 00005446 53                      	push	bx			;AN000;
 32539 00005447 51                      	push	cx			;AN000;
 32540 00005448 2EC606[3A99]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 32541                                  					;AC034; Assume terminated by space
 32542 0000544E 2E8026[4099]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 32543                                  					;AC034;
 32544 00005454 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 32545 00005456 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 32546                                  
 32547 00005458 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 32548 0000545A 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 32549                                  
 32550 0000545C 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 32551 0000545E 7431                    	je	short $P_Chk_Delim_Exit0
 32552                                  					;AN000;
 32553                                  $P_Chk_Delim00: 			;AN000;
 32554 00005460 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 32555 00005462 750C                    	jne	short $P_Chk_Delim01	;AN000;
 32556 00005464 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 32557                                  					;AN000; 2nd byte of DBCS Space ?
 32558 00005467 7507                    	jne	short $P_Chk_Delim01	;AN000;
 32559 00005469 B020                    	mov	al,$P_Space ; 20h	;AN000;
 32560 0000546B 46                      	inc	si			;AN000; make si point to next character
 32561 0000546C 38C0                    	cmp	al,al			;AN000; Set ZF
 32562 0000546E EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32563                                  
 32564                                  $P_Chk_Delim01: 			;AN000;
 32565                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 32566 00005470 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 32567                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 32568 00005475 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 32569                                  
 32570 00005477 31C9                    	xor	cx,cx			;AN000;
 32571 00005479 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32572                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 32573 0000547D 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 32574 0000547F 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 32575                                  
 32576 00005481 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 32577                                  $P_Chk_Delim_Loop:			;AN000;
 32578 00005484 43                      	inc	bx			;AN000;
 32579 00005485 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 32580 00005488 7407                    	je	short $P_Chk_Delim_Exit0
 32581                                  					;AN000;
 32582 0000548A E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 32583                                  
 32584                                  $P_Chk_Delim_NZ:			;AN000;
 32585 0000548C 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 32586                                  $P_Chk_Delim_Exit:			;AN000;
 32587 0000548E 59                      	pop	cx			;AN000;
 32588 0000548F 5B                      	pop	bx			;AN000;
 32589 00005490 C3                      	retn				;AN000;
 32590                                  
 32591                                  $P_Chk_Delim_Exit0:			;AN000;
 32592 00005491 2EA2[3A99]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 32593 00005495 2EF606[4099]01          	test	byte [cs:$P_Flags2],$P_equ
 32594                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 32595 0000549B 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 32596                                  
 32597 0000549D 2E800E[4099]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 32598                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 32599                                  $P_No_Set_Extra:			;AN027;
 32600 000054A3 38C0                    	cmp	al,al			;AN000; set ZF
 32601 000054A5 EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32602                                  
 32603                                  ;***********************************************************************
 32604                                  ; $P_Chk_Switch;
 32605                                  ;
 32606                                  ; Function: Check if AL is the switch character not in first position of
 32607                                  ;	    $P_STRING_BUF
 32608                                  ;
 32609                                  ; Input:    AL = character code
 32610                                  ;	    BX = current pointer within $P_String_Buf
 32611                                  ;	    SI =>next char on command line (following the one in AL)
 32612                                  ;
 32613                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 32614                                  ;		 position, and has no chance of being part of a date string,
 32615                                  ;		 i.e. should be treated as a delimiter.
 32616                                  ;
 32617                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 32618                                  ;		 position, or is a slash but may be part of a date string, i.e.
 32619                                  ;		 should not be treated as a delimiter.
 32620                                  ;
 32621                                  ; Vars:  $P_Terminator(W)
 32622                                  ;
 32623                                  ; Use:	 $P_0099
 32624                                  ;***********************************************************************
 32625                                  
 32626                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32627                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32628                                  $P_Chk_Switch:
 32629                                  	; 18/04/2023
 32630 000054A7 8D2E[4999]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 32631                                  
 32632 000054AB 39EB                    	cmp	bx,bp			;AN000;
 32633 000054AD 7418                    	je	short $P_STRUC_L2	;AN000;
 32634                                  
 32635 000054AF 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32636 000054B1 7512                    	jne	short $P_STRUC_L5	;AN000;
 32637                                  
 32638 000054B3 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 32639 000054B4 50                      	push	ax			;AN020;save input char
 32640 000054B5 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 32641 000054B9 E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 32642 000054BC 7205                    	jc	short $P_STRUC_L7	;AN000;
 32643                                  
 32644 000054BE 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 32645 000054C0 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 32646                                  $P_STRUC_L7:				;AN000;
 32647 000054C3 58                      	pop	ax			;AN020;restore AL to input char
 32648                                  	;jmp	short $P_STRUC_L1	;AN000;
 32649                                  	; 18/04/2023
 32650 000054C4 C3                      	retn
 32651                                  
 32652                                  $P_STRUC_L5:				;AN000;
 32653 000054C5 F8                      	clc				;AN020;not a slash
 32654                                  	;jmp	short $P_STRUC_L1	;AN000;
 32655                                  	 ;18/04/2023
 32656 000054C6 C3                      	retn
 32657                                  
 32658                                  $P_STRUC_L2:				;AN000;
 32659 000054C7 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 32660                                  	;jne	short $P_STRUC_L12	;AN000;
 32661                                  	; 18/04/2023
 32662 000054C9 75FA                    	jne	short $P_STRUC_L5
 32663                                  
 32664 000054CB 2E800E[4099]40          	or	byte [cs:$P_Flags2],$P_SW
 32665                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 32666                                  	; 18/04/2023
 32667                                  ;$P_STRUC_L12:				;AN000;
 32668                                  	;clc				;AN020;CF=0 indicating first char
 32669                                  $P_STRUC_L1:				;AN000;
 32670 000054D1 C3                      	retn				;AN000;
 32671                                  
 32672                                  ;**************************************************************************
 32673                                  ; $P_Chk_DBCS:
 32674                                  ;
 32675                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 32676                                  ;
 32677                                  ;  Input:
 32678                                  ;	  AL	= Code to be examineed
 32679                                  ;
 32680                                  ;  Output:
 32681                                  ;	  If CF is on then a lead byte of DBCS
 32682                                  ;
 32683                                  ; Use: INT 21h w/AH=63
 32684                                  ;
 32685                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 32686                                  ;***************************************************************************
 32687                                  
 32688                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32689                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32690                                  $P_Chk_DBCS:
 32691 000054D2 1E                      	push	ds			;AN000;
 32692 000054D3 56                      	push	si			;AN000;
 32693 000054D4 53                      	push	bx			;AN000; (tm11)
 32694 000054D5 2E833E[3D99]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 32695                                  					;AC034; ALREADY SET ?
 32696 000054DB 7527                    	jne	short $P_DBCS00		;AN000;
 32697 000054DD 50                      	push	ax			;AN000;
 32698 000054DE 1E                      	push	ds			;AN000; (tm11)
 32699 000054DF 51                      	push	cx			;AN000;
 32700 000054E0 52                      	push	dx			;AN000;
 32701 000054E1 57                      	push	di			;AN000;
 32702 000054E2 55                      	push	bp			;AN000;
 32703 000054E3 06                      	push	es			;AN000;
 32704 000054E4 31F6                    	xor	si,si			;AN000;
 32705 000054E6 8EDE                    	mov	ds,si			;AN000;
 32706                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 32707 000054E8 B80063                  	mov	ax,6300h
 32708 000054EB CD21                    	int	21h			;AN000;
 32709 000054ED 8CDB                    	mov	bx,ds			;AN000; (tm11)
 32710 000054EF 09DB                    	or	bx,bx			;AN000; (tm11)
 32711 000054F1 07                      	pop	es			;AN000;
 32712 000054F2 5D                      	pop	bp			;AN000;
 32713 000054F3 5F                      	pop	di			;AN000;
 32714 000054F4 5A                      	pop	dx			;AN000;
 32715 000054F5 59                      	pop	cx			;AN000;
 32716 000054F6 1F                      	pop	ds			;AN000; (tm11)
 32717 000054F7 58                      	pop	ax			;AN000;
 32718 000054F8 7429                    	jz	short $P_NON_DBCS	;AN000;
 32719                                  $P_DBCS02:				;AN000;
 32720 000054FA 2E8936[3B99]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 32721 000054FF 2E891E[3D99]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 32722                                  $P_DBCS00:				;AN000;
 32723 00005504 2E8B36[3B99]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 32724 00005509 2E8E1E[3D99]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 32725                                  $P_DBCS_LOOP:				;AN000;
 32726 0000550E 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 32727 00005511 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 32728 00005513 3A04                    	cmp	al,[si] 		;AN000;
 32729 00005515 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 32730 00005517 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 32731 0000551A 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 32732 0000551C F9                      	stc				;AN000; if yes, indicate DBCS and exit
 32733 0000551D EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 32734                                  $P_DBCS01:				;AN000;
 32735 0000551F 46                      	inc	si			;AC035; add '2' to
 32736 00005520 46                      	inc	si			;AC035;  SI reg
 32737                                  					;AN000; get next vector
 32738 00005521 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 32739                                  
 32740                                  $P_NON_DBCS:				;AN000;
 32741                                  	; 18/04/2023
 32742                                  	; cf=0
 32743                                  	;clc				;AN000; indicate SBCS
 32744                                  $P_DBCS_EXIT:				;AN000;
 32745 00005523 5B                      	pop	bx			;AN000; (tm11)
 32746 00005524 5E                      	pop	si			;AN000;
 32747 00005525 1F                      	pop	ds			;AN000;
 32748 00005526 C3                      	retn				;AN000;
 32749                                  
 32750                                  ;============================================================================
 32751                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 32752                                  ;============================================================================
 32753                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32754                                  
 32755                                  ; ****************************************************************
 32756                                  ; *
 32757                                  ; * ROUTINE:	 CMD_PARSE
 32758                                  ; *
 32759                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 32760                                  ; *		 SYSPARSE.
 32761                                  ; *
 32762                                  ; * INPUT:	 inputs to SYSPARSE
 32763                                  ; *
 32764                                  ; * OUTPUT:	 outputs from SYSPARSE
 32765                                  ; *
 32766                                  ; ****************************************************************
 32767                                  
 32768                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32769                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 32770                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32771                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:57BBh
 32772                                  ;cmd_parse:
 32773                                  	;call	sysparse		;AN000;
 32774                                  	;retn				;AN000;
 32775                                  	; 06/04/2023
 32776                                  	;jmp	sysparse
 32777                                  
 32778                                  append_parse:
 32779 00005527 E842F5                  	call	sysparse		;AN010;
 32780 0000552A CB                      	retf				;AN010;
 32781                                  
 32782                                  ;============================================================================
 32783                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32784                                  ;============================================================================
 32785                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32786                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 32787                                  
 32788                                  ; ----------------------------
 32789                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32790                                  ; ----------------------------
 32791                                  
 32792                                  ;; Replacable parameters are described by a sublist structure
 32793                                  
 32794                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32795 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32796 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32797 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32798 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32799 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32800 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32801 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32802 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32803                                  endstruc
 32804                                  
 32805                                  ; ---------------------------------------------------------------------------
 32806                                  ; ---------------------------------------------------------------------------
 32807                                  
 32808                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32809                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32810                                  
 32811                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 32812                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57C3h
 32813                                  
 32814                                  Printf_Init:
 32815 0000552B E80F00                  	call	std_printf
 32816 0000552E CB                      	retf
 32817                                  
 32818                                  Printf_Crlf:
 32819 0000552F E80B00                  	call	std_printf
 32820                                  	;call	CRLF2
 32821                                  	;retn
 32822                                  	; 07/04/2023
 32823 00005532 E9E7D5                  	jmp	CRLF2
 32824                                  
 32825                                  ;****************************************************************
 32826                                  ;*
 32827                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32828                                  ;*
 32829                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32830                                  ;*		Set up substitutions if utility message.  Make
 32831                                  ;*		sure any changes to message variables in TDATA
 32832                                  ;*		are reset to avoid reloading the transient.
 32833                                  ;*
 32834                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32835                                  ;*		Msg_Cont_Flag	-  set to control flags
 32836                                  ;*		DS	points to transient segment
 32837                                  ;*
 32838                                  ;*		if utility message:
 32839                                  ;*		DX	points to a block with message number
 32840                                  ;*			(word), number of substitutions (byte),
 32841                                  ;*			followed by substitution list if there
 32842                                  ;*			are substitutions.  If substitutions
 32843                                  ;*			are not in transient segment they must
 32844                                  ;*			be set.
 32845                                  ;*		else
 32846                                  ;*		AX	set to message number
 32847                                  ;*
 32848                                  ;* OUTPUT:	none
 32849                                  ;*
 32850                                  ;****************************************************************
 32851                                  
 32852                                  std_eprintf:
 32853 00005535 C706[109B]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32854 0000553B EB06                    	jmp	short new_printf		;AC000;
 32855                                  
 32856                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32857                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32858                                  
 32859                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 32860                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57D6h
 32861                                  
 32862                                  std_printf:
 32863 0000553D C706[109B]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32864                                  
 32865                                  new_printf:
 32866 00005543 50                      	push	ax				;AN000;save registers
 32867 00005544 53                      	push	bx				;AN000;
 32868 00005545 51                      	push	cx				;AN000;
 32869 00005546 06                      	push	es				;AN000;get local ES
 32870 00005547 1E                      	push	ds				;AN000;
 32871 00005548 07                      	pop	es				;AN000;
 32872 00005549 57                      	push	di				;AN000;
 32873 0000554A 56                      	push	si				;AN000;
 32874 0000554B 52                      	push	dx				;AN000;
 32875                                  
 32876                                  	; 07/04/2023
 32877                                  	;mov	word [print_err_flag],0		;AN000;
 32878 0000554C 31C9                    	xor	cx,cx
 32879 0000554E 890E[9DA2]              	mov	[print_err_flag],cx ; 0
 32880                                  
 32881 00005552 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32882 00005554 AD                      	lodsw					;AN000;load message number
 32883                                  	; 15/06/2023
 32884                                  	;push	ax				;AN000;save it
 32885                                  	;lodsb					;AN000;get number of substitutions
 32886                                  	;mov	cl,al				;AN000;set up CX as # of subst
 32887                                  	;; 07/04/2023
 32888                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 32889                                  	;pop	ax				;AN000;get message number back
 32890                                  	; 15/06/2023
 32891 00005555 8A0C                    	mov	cl,[si]
 32892 00005557 46                      	inc	si
 32893                                  
 32894                                  	;cmp	cx,0				;AN000;Any substitutions?
 32895                                  	; 07/04/2023
 32896 00005558 21C9                    	and	cx,cx
 32897 0000555A 745C                    	jz	short ready_to_print		;AN000;No - continue
 32898                                  
 32899 0000555C BF[9FA2]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32900 0000555F 57                      	push	di				;AN061; save it
 32901 00005560 51                      	push	cx				;AN061; save number of subst
 32902                                  
 32903                                  move_subst:
 32904 00005561 51                      	push	cx				;AN061;save number of subst
 32905 00005562 89F3                    	mov	bx,si				;AN061;save start of sublist
 32906                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32907                                  	; 07/04/2023
 32908 00005564 B10B                    	mov	cl,parm_block_size ; 11
 32909 00005566 F3A4                    	rep	movsb				;AN061;move sublist
 32910                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32911 00005568 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32912                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32913 0000556C 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32914                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32915                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32916 0000556E 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32917                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32918                                  	;mov	word [bx+4],0			;AN061;
 32919 00005571 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32920                                  
 32921                                  move_subst_cont:				;AN061;
 32922 00005574 59                      	pop	cx				;AN061;get number of subst back
 32923 00005575 E2EA                    	loop	move_subst			;AN061;move cx sublists
 32924                                  
 32925 00005577 59                      	pop	cx				;AN061;get number of subst
 32926 00005578 50                      	push	ax				;AN061;save message number
 32927 00005579 803E[0192]FF            	cmp	byte [msg_disp_class],util_msg_class
 32928                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32929 0000557E 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32930                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32931 00005580 C606[99A2]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32932 00005585 BF[0392]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32933 00005588 31C0                    	xor	ax,ax				;AN061;clear ax register
 32934 0000558A AB                      	stosw					;AN061;clear out message number
 32935 0000558B AA                      	stosb					;AN061;clear out subst count
 32936                                  
 32937                                  check_fix:					;AN061;
 32938 0000558C 58                      	pop	ax				;AN061;get message number back
 32939 0000558D 5F                      	pop	di				;AN061;get start of sublists
 32940 0000558E 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32941 00005590 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32942 00005592 51                      	push	cx				;AN061;save number of subst
 32943                                  
 32944                                  set_subst:					;AN061;store the segment of the subst
 32945 00005593 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32946                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32947 00005597 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32948 00005599 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32949                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32950                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32951 0000559D 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32952 0000559F 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32953                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32954                                  
 32955                                  subst_seg_set:					;AN061;
 32956 000055A2 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32957 000055A5 E2EC                    	loop	set_subst			;AN061;loop CX times
 32958 000055A7 59                      	pop	cx				;AN061;get number of subst back
 32959                                  
 32960 000055A8 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32961 000055AA 817F02[06A1]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32962                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32963 000055AF 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32964                                  	; 01/05/2023
 32965 000055B1 8B16[06A1]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32966 000055B5 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32967                                  						;AN061;put it into the subst block
 32968                                  	;mov	[bx+2],dx
 32969                                  
 32970                                  ready_to_print:
 32971 000055B8 8B1E[109B]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32972 000055BC 8A16[0292]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32973 000055C0 8A36[0192]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32974 000055C4 C606[0292]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32975                                  						;AN061;reset flags to avoid
 32976 000055C9 C606[0192]FF            	mov	byte [msg_disp_class],util_msg_class
 32977                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32978                                  
 32979 000055CE 1E                      	push	ds				;AN026;
 32980 000055CF 06                      	push	es				;AN026;
 32981                                  
 32982 000055D0 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32983                                  
 32984 000055D3 07                      	pop	es				;AN026; restore registers
 32985 000055D4 1F                      	pop	ds				;AN026;
 32986                                  
 32987 000055D5 7303                    	jnc	short print_success		;AN000; everything went okay
 32988 000055D7 A3[9DA2]                	mov	[print_err_flag],ax		;AN000;
 32989                                  
 32990                                  print_success:
 32991 000055DA 5A                      	pop	dx				;AN061;restore dx
 32992 000055DB 5E                      	pop	si				;AN000;restore registers
 32993 000055DC 5F                      	pop	di				;AN000;
 32994 000055DD 07                      	pop	es				;AN000;restore registers
 32995 000055DE 59                      	pop	cx				;AN000;
 32996 000055DF 5B                      	pop	bx				;AN000;
 32997 000055E0 58                      	pop	ax				;AN000;
 32998 000055E1 833E[9DA2]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32999 000055E6 7501                    	jnz	short print_err			;AN000;
 33000                                  
 33001 000055E8 C3                      	retn					;AC000;
 33002                                  
 33003                                  print_err:
 33004 000055E9 0E                      	push	cs
 33005 000055EA 07                      	pop	es
 33006 000055EB 833E[109B]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 33007 000055F0 7503                    	jne	short not_stderr		;AN026;no - continue
 33008 000055F2 E90FAB                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 33009                                  
 33010                                  not_stderr:
 33011 000055F5 A1[9DA2]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 33012 000055F8 8E06[E49D]              	mov	es,[RESSEG]			; No, set up for error, load the
 33013                                  						;  right error msg, and jmp to cerror.
 33014 000055FC 26F606[D302]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 33015 00005602 7408                    	jz	short _go_to_error
 33016 00005604 E8AEDE                  	call	PipeOff
 33017 00005607 BA[6493]                	mov	dx,PIPEEMES_PTR
 33018 0000560A EB0B                    	jmp	short print_err_exit			;AC000;
 33019                                  
 33020                                  _go_to_error:
 33021 0000560C C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class
 33022                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 33023 00005611 BA[0392]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 33024 00005614 A3[0392]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 33025                                  
 33026                                  print_err_exit: 				;AC000;
 33027 00005617 0E                      	push	cs
 33028 00005618 07                      	pop	es
 33029 00005619 E981D8                  	jmp	cerror
 33030                                  
 33031                                  ;****************************************************************
 33032                                  ;*
 33033                                  ;* ROUTINE:	TSYSLOADMSG
 33034                                  ;*
 33035                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 33036                                  ;*		names since these routines are also used in the
 33037                                  ;*		resident.
 33038                                  ;*
 33039                                  ;* INPUT:	Inputs to SYSLOADMSG
 33040                                  ;*
 33041                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 33042                                  ;*
 33043                                  ;****************************************************************
 33044                                  
 33045                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33046                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33047                                  TSYSLOADMSG:
 33048 0000561C 53                      	push	bx				;AN000;
 33049 0000561D E80800                  	call	SYSLOADMSG			;AN000; call routine
 33050 00005620 5B                      	pop	bx				;AN000;
 33051 00005621 C3                      	retn					;AN000; exit
 33052                                  
 33053                                  ;****************************************************************
 33054                                  ;*
 33055                                  ;* ROUTINE:	TSYSGETMSG
 33056                                  ;*
 33057                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 33058                                  ;*		names since these routines are also used in the
 33059                                  ;*		resident.
 33060                                  ;*
 33061                                  ;* INPUT:	Inputs to SYSGETMSG
 33062                                  ;*
 33063                                  ;* OUTPUT:	Outputs from SYSGETMSG
 33064                                  ;*
 33065                                  ;****************************************************************
 33066                                  
 33067                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33068                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33069                                  TSYSGETMSG:
 33070 00005622 51                      	push	cx				;AN000;
 33071 00005623 E8B500                  	call	SYSGETMSG			;AN000; call routine
 33072 00005626 59                      	pop	cx				;AN000;
 33073 00005627 C3                      	retn					;AN000; exit
 33074                                  
 33075                                  ;============================================================================
 33076                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 33077                                  ;============================================================================
 33078                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33079                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33080                                  
 33081                                  ; ---------------------------------------------------------------------------
 33082                                  ; MODULE NAME: MSGSERV.SAL
 33083                                  ;
 33084                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 33085                                  ;
 33086                                  ; FUNCTION: This module incorporates all the messages services and
 33087                                  ;	    is called upon at build time to INCLUDE the code requested
 33088                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 33089                                  ;
 33090                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 33091                                  ;	    requested procedure.
 33092                                  ;
 33093                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 33094                                  ;	    function requested.
 33095                                  ;
 33096                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 33097                                  ;
 33098                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 33099                                  ;
 33100                                  ; INTERNAL REFERENCES: (list of included subroutines)
 33101                                  ;
 33102                                  ;	- SYSLOADMSG
 33103                                  ;	- SYSDISPMSG
 33104                                  ;	- SYSGETMSG
 33105                                  ;
 33106                                  ; EXTERNAL REFERENCES: None
 33107                                  ;
 33108                                  ; NOTES: At build time, some modules must be included. These are only included
 33109                                  ;	 once using assembler switches. Other logic is included at the request
 33110                                  ;	 of the utility.
 33111                                  ;
 33112                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 33113                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 33114                                  ;	 storage and multiple EQUates.
 33115                                  ;
 33116                                  ; REVISION HISTORY: Created MAY 1987
 33117                                  ;
 33118                                  ;     Label: DOS - - Message Retriever
 33119                                  ;	     (c) Copyright 1988 Microsoft
 33120                                  ; ---------------------------------------------------------------------------
 33121                                  
 33122                                  ;	Revision History
 33123                                  ;	================
 33124                                  ;
 33125                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 33126                                  ;				$M_DISPLAY_H_STRING to properly
 33127                                  ;				handle Ctrl-Z being passed
 33128                                  ;
 33129                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 33130                                  ;				these routines are no longer assembled.
 33131                                  ;
 33132                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 33133                                  ;				CR-LF string also gets reinitialized
 33134                                  ;				on every cycle.
 33135                                  ;
 33136                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 33137                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 33138                                  
 33139                                  ; ---------------------------------------------------------------------------
 33140                                  
 33141                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33142                                  
 33143                                  ;;; Replacable parameters are described by a sublist structure
 33144                                  ;
 33145                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 33146                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33147                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33148                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33149                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 33150                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33151                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33152                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33153                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33154                                  ;endstruc
 33155                                  
 33156                                  ;; Each class will be defined by this structure.
 33157                                  
 33158                                  struc $M_CLASS_ID		;;AN000;;
 33159 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 33160 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 33161 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 33162                                   .size:
 33163                                  endstruc
 33164                                  
 33165                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 33166                                  
 33167                                  ;; Each message will be defined by this structure.
 33168                                  
 33169                                  struc $M_ID			;;AN000;;
 33170 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 33171 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 33172                                   .size:	
 33173                                  endstruc
 33174                                  
 33175                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 33176                                  
 33177                                  ; ---------------------------
 33178                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33179                                  ; ---------------------------
 33180                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 33181                                  
 33182                                  ; --------------------------- 
 33183                                  
 33184                                  ; 07/04/2023
 33185                                  $M_NUM_CLS equ 3
 33186                                  
 33187                                  ;; Resident data area definition of variables
 33188                                  
 33189                                  struc $M_RES_ADDRS			;;AN000;;
 33190 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 33191 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 33192 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 33193 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 33194 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 33195 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 33196 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 33197 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 33198 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 33199 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 33200 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33201 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33202 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33203 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33204 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33205 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33206 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33207 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33208 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33209 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33210 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33211 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33212 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33213                                   .size:
 33214                                  endstruc				;;AN000;;
 33215                                  
 33216                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33217                                  
 33218                                  ;; Important fields of the Get Country Information call
 33219                                  
 33220                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33221 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33222                                  					;;AN000;; Go past first part of struc
 33223 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33224 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33225 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33226 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33227 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33228 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33229 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33230 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33231 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33232                                  endstruc				;;AN000;;
 33233                                  
 33234                                  ; ---------------------------------------------------------------------------
 33235                                  
 33236                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33237                                  ;;
 33238                                  ;;	PROC NAME: SYSLOADMSG
 33239                                  ;;
 33240                                  ;;	FUNCTION:
 33241                                  ;;	INPUTS:
 33242                                  ;;
 33243                                  ;;	OUTPUTS:
 33244                                  ;;
 33245                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33246                                  
 33247                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33248                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33249                                  
 33250                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33251                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:58CBh
 33252                                  
 33253                                  SYSLOADMSG:
 33254 00005628 50                      	push	ax				;;AN000;
 33255 00005629 53                      	push	bx				;;AN000;
 33256 0000562A 52                      	push	dx				;;AN000;
 33257 0000562B 06                      	push	es				;;AN000;
 33258 0000562C 57                      	push	di				;;AN000;
 33259 0000562D 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33260 0000562F 8EC1                    	mov	es,cx				;;AN000;
 33261 00005631 31FF                    	xor	di,di				;;AN000;
 33262 00005633 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33263 00005636 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33264 00005638 CD2F                    	int	2Fh				;;AN000;; Private interface
 33265                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33266                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33267                                  		; Return: ES:DI -> error table
 33268                                  	
 33269 0000563A 8C06[189A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33270                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33271 0000563E 893E[169A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33272                                  	;mov	[$M_RT+8],di			;;AN000;;
 33273                                  
 33274 00005642 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33275 00005645 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33276 00005647 CD2F                    	int	2Fh				;;AN000;; Private interface
 33277                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33278                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33279                                  		; ES:DI -> error table
 33280                                  
 33281 00005649 8C06[209A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33282                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33283 0000564D 893E[1E9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33284                                  	;mov	[$M_RT+16],di			;;AN000;;
 33285                                  
 33286 00005651 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33287 00005654 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33288 00005656 CD2F                    	int	2Fh				;;AN000;; Private interface
 33289                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33290                                  		; DL = subfunction - get ??? error table
 33291                                  		; ES:DI -> error table
 33292                                  
 33293 00005658 8C06[309A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33294                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33295 0000565C 893E[2E9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33296                                  	;mov	[$M_RT+32],di			;;AN000;;
 33297                                  
 33298 00005660 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33299 00005663 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33300 00005665 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33301                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33302                                  		; DL = subfunction - get ??? error table
 33303                                  		; ES:DI -> error table
 33304                                  
 33305 00005667 8C06[149A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33306                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33307 0000566B 893E[129A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33308                                  	;mov	[$M_RT+4],di			;;AN001;;
 33309                                  
 33310 0000566F E86A3B                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33311                                  						;;AN000;;
 33312 00005672 8C06[109A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33313                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33314 00005676 893E[0E9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33315                                  	;mov	[$M_RT+0],di			;;AN000;;
 33316 0000567A 8C06[2C9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33317                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33318 0000567E 893E[2A9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33319                                  	;mov	[$M_RT+28],di			;;AN000;;
 33320                                  
 33321 00005682 E8753B                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33322                                  
 33323 00005685 8C06[249A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33324                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33325 00005689 893E[229A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33326                                  	;mov	[$M_RT+20],di			;;AN000;;
 33327                                  
 33328 0000568D B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33329 00005690 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33330 00005692 CD2F                    	int	2Fh				;;AN001;; Private interface
 33331                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33332                                  		; DL = subfunction - get ??? error table
 33333                                  		; ES:DI -> error table
 33334                                  
 33335 00005694 8C06[389A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33336                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33337 00005698 893E[369A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33338                                  	;mov	[$M_RT+40],di			;;AN001;;
 33339                                  
 33340                                  ;M016; M020
 33341                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33342                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33343                                  
 33344 0000569C C706[519A]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33345                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33346 000056A2 C606[9A9A]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33347                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33348 000056A7 C706[569A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33349                                  	;mov	word [$M_RT+72],0		; M020
 33350 000056AD C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33351                                  	;mov	word [$M_RT+74],10		; M020
 33352                                  
 33353                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33354                                  	; --------------------------
 33355                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33356                                  	; --------------------------
 33357                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33358                                  
 33359                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33360 000056B3 E8C33A                  	call    $M_CLS_3			; Get addressibility to class F
 33361 000056B6 893E[3A9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33362                                  	;mov	[$M_RT+44],di
 33363                                  	
 33364 000056BA E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33365                                  
 33366                                  	; 15/04/2023
 33367                                  	;clc					;;AN000;; Make sure carry is clear
 33368                                  	;jc	short $MIF20
 33369                                  	
 33370 000056BD 5F                      	pop	di				;;AN000;; Restore REGS
 33371 000056BE 07                      	pop	es				;;AN000;;
 33372 000056BF 5A                      	pop	dx				;;AN000;;
 33373 000056C0 5B                      	pop	bx				;;AN000;;
 33374 000056C1 58                      	pop	ax				;;AN000;;
 33375                                  	;jmp	short $MEN20
 33376                                  	; 15/04/2023
 33377 000056C2 C3                      	retn
 33378                                  
 33379                                  	; 15/04/2023
 33380                                  ;$MIF20:
 33381                                  	;add	sp,10				;;AN000;;
 33382                                  	;stc					;;AN000;; Reset carry flag
 33383                                  ;$MEN20:
 33384                                  	;retn					;;AN000;;
 33385                                  
 33386                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33387                                  ;;
 33388                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33389                                  ;;
 33390                                  ;;  Function:	Get the DBCS vector and save it for later use
 33391                                  ;;
 33392                                  ;;  Inputs:	None
 33393                                  ;;
 33394                                  ;;  Outputs:	None
 33395                                  ;;
 33396                                  ;;  Regs Changed:
 33397                                  ;;
 33398                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33399                                  
 33400                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33401                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33402                                  $M_GET_DBCS_VEC:
 33403 000056C3 50                      	push	ax				;;AN000;; Save character to check
 33404 000056C4 56                      	push	si				;;AN000;;
 33405 000056C5 1E                      	push	ds				;;AN000;;
 33406 000056C6 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33407 000056C9 CD21                    	int	21h				;;AN000;; Get environment pointer
 33408 000056CB 1E                      	push	ds				;;AN000;; Get environment pointer
 33409 000056CC 07                      	pop	es				;;AN000;; Get environment pointer
 33410 000056CD 1F                      	pop	ds				;;AN000;; Get environment pointer
 33411 000056CE 7208                    	jc	short $MIF23
 33412                                  	
 33413 000056D0 8936[4A9A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33414                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33415 000056D4 8C06[4C9A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33416                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33417                                  $MIF23:
 33418 000056D8 5E                      	pop	si				;;AN000;;
 33419 000056D9 58                      	pop	ax				;;AN000;; Retrieve character to check
 33420 000056DA C3                      	retn					;;AN000;; Return
 33421                                  
 33422                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33423                                  ;;
 33424                                  ;;  Proc Name:	SYSGETMSG
 33425                                  ;;
 33426                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33427                                  ;;		message text to the caller based on a message number.
 33428                                  ;;		The GET function will not display the message thus assumes
 33429                                  ;;		caller will handle replaceable parameters.
 33430                                  ;;
 33431                                  ;;  Inputs:
 33432                                  ;;
 33433                                  ;;  Outputs:
 33434                                  ;;
 33435                                  ;;  Psuedocode:
 33436                                  ;;		Call $M_GET_MSG_ADDRESS
 33437                                  ;;		IF MSG_NUM exists THEN
 33438                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33439                                  ;;		   CARRY_FLAG = 0
 33440                                  ;;		ELSE
 33441                                  ;;		   CARRY_FLAG = 1
 33442                                  ;;		ENDIF
 33443                                  ;;
 33444                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33445                                  
 33446                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33447                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33448                                  
 33449                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33450                                  
 33451                                  SYSGETMSG:
 33452                                  	;; Save registers needed later
 33453 000056DB 50                      	push	ax				;;AN000;; Save changed regs
 33454 000056DC 06                      	push	es				;;AN000;;
 33455 000056DD 57                      	push	di				;;AN000;;
 33456 000056DE 55                      	push	bp				;;AN000;;
 33457                                  
 33458 000056DF E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33459 000056E2 720D                    	jc	short $MIF31
 33460                                  	
 33461 000056E4 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33462                                  	;clc					;;AN000;;
 33463 000056E7 7404                    	je	short $MIF32			;;AN000;;
 33464                                  	; 15/06/2023
 33465 000056E9 F8                      	clc	
 33466                                  
 33467 000056EA 06                      	push	es				;;AN000;;
 33468                                  	;pop	ds				;;AN000;;
 33469 000056EB EB01                    	jmp	short $MEN32
 33470                                  $MIF32:
 33471 000056ED 0E                      	push	cs				;;AN000;;			
 33472                                  	;pop	ds				;;AN000;;
 33473                                  $MEN32:
 33474                                  	; 07/04/2023
 33475 000056EE 1F                      	pop	ds
 33476 000056EF 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33477                                  $MIF31:
 33478 000056F1 5D                      	pop	bp				;;AN000;; Restore changed regs
 33479 000056F2 5F                      	pop	di				;;AN000;;
 33480 000056F3 07                      	pop	es				;;AN000;;
 33481 000056F4 58                      	pop	ax				;;AN000;;
 33482 000056F5 C3                      	retn					;;AN000;; Return
 33483                                  
 33484                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33485                                  ;;
 33486                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33487                                  ;;
 33488                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33489                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33490                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33491                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33492                                  ;;	REGS CHANGED: ES,DI,CX
 33493                                  ;;
 33494                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33495                                  
 33496                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33497                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33498                                  $M_GET_MSG_ADDRESS:
 33499 000056F6 56                      	push	si				;;AN000;;
 33500 000056F7 53                      	push	bx				;;AN000;;
 33501 000056F8 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33502 000056FA 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33503                                  $MDO36:
 33504 000056FC 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33505 000056FF 7508                    	jne	short $MIF37			;;AN000;; No
 33506                                  
 33507                                  	; 07/04/2023
 33508                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33509 00005701 8BBC[3A9A]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33510                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33511 00005705 89FB                    	mov	bx,di				;;AN000;;
 33512 00005707 EB21                    	jmp	short $MEN37
 33513                                  $MIF37:
 33514 00005709 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33515 0000570C 7406                    	jz	short $MIF39
 33516                                  	
 33517                                  	; 07/04/2023
 33518                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33519 0000570E C4BC[1E9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33520                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33521                                  
 33522                                  	; 07/04/2023
 33523                                  	;mov	bx,es ; *			;;AN000;;
 33524 00005712 EB14                    	jmp	short $MEN39
 33525                                  $MIF39:
 33526 00005714 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33527 00005717 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33528                                  
 33529 00005719 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33530 0000571C 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33531                                  
 33532                                  	; 07/04/2023
 33533                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33534 0000571E C4BC[2A9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33535                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33536                                  	
 33537                                  	; 07/04/2023
 33538                                  	;mov	bx,es ; *			;;AN000;;
 33539 00005722 EB04                    	jmp	short $MEN41
 33540                                  $MIF41:
 33541                                  	; 07/04/2023
 33542                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33543 00005724 C4BC[0E9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33544                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33545                                  	
 33546                                  	; 07/04/2023
 33547                                  	;mov	bx,es ; *			;;AN000;;
 33548                                  $MEN41:
 33549                                  $MEN39:
 33550                                  	; 07/04/2023
 33551 00005728 8CC3                    	mov	bx,es ; *
 33552                                  $MEN37:						;;AN000;;
 33553 0000572A 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33554 0000572D 7515                    	jne	short $MIF46			;;AN000;; No
 33555                                  
 33556 0000572F 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33557 00005732 7503                    	jne	short $MIF47			;;AN000;; No
 33558 00005734 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33559                                  	; 07/04/2023
 33560                                  	;jmp	short $MEN47 ; **-
 33561 00005735 EB1B                    	jmp	short $MEN36 ; **-
 33562                                  $MIF47:
 33563 00005737 A3[569A]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],ax
 33564                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33565 0000573A B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33566 0000573D BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33567 00005740 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33568                                  	; 28/04/2023
 33569                                  	; 07/04/2023
 33570                                  	;clc	; **+				;;AN000;;
 33571                                  ;$MEN47:
 33572                                  	;jmp	short $MEN46 ; ***
 33573 00005742 EB0A                    	jmp	short $MEN47 ; ***
 33574                                  $MIF46:
 33575                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33576 00005744 21DB                    	and	bx,bx ; 0 ?
 33577 00005746 7403                    	jz	short $MIF51			;;AN000;; No
 33578                                  	
 33579 00005748 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33580                                  $MIF51:
 33581 0000574B 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33582                                  	; 07/04/2023
 33583                                  	;clc					;;AN000;;
 33584                                  ;$MEN46:
 33585                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33586                                  $MEN47:	; 07/04/2023	; **+
 33587 0000574E 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33588                                  	;jnz	short $MXL2			;;AN000;; Yes
 33589                                  	;jmp	short $MDO36
 33590                                  	; 07/04/2023
 33591 00005750 74AA                    	jz	short $MDO36	
 33592                                  $MXL2:
 33593                                  $MEN36:
 33594 00005752 9C                      	pushf 					;;AN006;; Save the flag state
 33595                                  	
 33596 00005753 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33597                                  	;jne	short $MIF56			;;AN006;; No
 33598                                  	; 28/04/2023
 33599 00005756 752A                    	jne	short $M_MYRET	
 33600                                  
 33601 00005758 52                      	push	dx				;;AN006;; Save all needed registers
 33602 00005759 55                      	push	bp				;;AN006;;
 33603 0000575A 51                      	push	cx				;;AN006;;
 33604 0000575B 06                      	push	es				;;AN006;;
 33605 0000575C 57                      	push	di				;;AN006;;
 33606 0000575D 50                      	push	ax				;;AN006;;
 33607                                  
 33608 0000575E B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33609 00005761 CD2F                    	int	2Fh				;;AN006;;
 33610                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33611                                  		; Return: AL = 00h not installed, OK to install
 33612                                  		; 01h not installed, can't install
 33613                                  		; FFh installed
 33614                                  
 33615 00005763 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33616 00005765 58                      	pop	ax				;;AN006;; Restore msg number
 33617 00005766 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33618                                  
 33619 00005768 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33620 0000576A B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33621 0000576D CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33622                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33623                                  
 33624                                  	;jmp	short $MEN57			;;AN006;;
 33625                                  	; 28/04/2023
 33626 0000576F 720B                    	jc	short $MEN57
 33627                                  $MIF60:
 33628 00005771 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33629 00005774 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33630                                  $MEN60:
 33631 00005777 5D                      	pop	bp				;;AN006;; Restore other Regs
 33632 00005778 5A                      	pop	dx				;;AN006;;
 33633                                  $MIF56:
 33634                                  	; 07/04/2023
 33635                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33636 00005779 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33637                                  
 33638                                  $MIF57:
 33639 0000577B F9                      	stc					;;AN006;; Carry conditon
 33640                                  $MEN57:
 33641                                  	; 28/04/2023
 33642                                  	;jnc	short $MIF60			;;AN006;;
 33643                                  
 33644 0000577C 5F                      	pop	di				;;AN006;;
 33645 0000577D 07                      	pop	es				;;AN006;; Restore old pointer
 33646 0000577E 59                      	pop	cx				;;AN006;;
 33647 0000577F EBF6                    	jmp	short $MEN60
 33648                                  
 33649                                  ;$MIF60:
 33650                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33651                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33652                                  ;$MEN60:
 33653                                  ;	pop	bp				;;AN006;; Restore other Regs
 33654                                  ;	pop	dx				;;AN006;;
 33655                                  ;$MIF56:
 33656                                  ;	; 07/04/2023
 33657                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33658                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33659                                  
 33660                                  ; 07/04/2023
 33661                                  ; ---------------------------
 33662                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33663                                  ; ---------------------------
 33664                                  	; $M_POPF macro
 33665                                  	;jmp	short $+3
 33666                                  m_popf_iret:
 33667 00005781 CF                      	iret
 33668                                  $M_MYRET:
 33669 00005782 0E                      	push	cs
 33670 00005783 E8FBFF                  	call	m_popf_iret
 33671                                  	;;; end macro	
 33672                                  ; ---------------------------
 33673                                  
 33674 00005786 5B                      	pop	bx				;;AN000;;
 33675 00005787 5E                      	pop	si				;;AN000;;
 33676 00005788 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33677                                  
 33678                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33679                                  
 33680                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33681                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33682                                  $M_SET_LEN_IN_CX:			
 33683 00005789 57                      	push	di				;;AN006;; Save position
 33684 0000578A 50                      	push	ax				;;AN006;;
 33685 0000578B B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33686 0000578E 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33687 00005790 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33688 00005792 F7D1                    	not	cx				;;AN006;; Change decrement into number
 33689 00005794 49                      	dec	cx				;;AN006;; Don't include the zero
 33690 00005795 58                      	pop	ax				;;AN006;;
 33691 00005796 5F                      	pop	di				;;AN006;; Restore position
 33692 00005797 C3                      	retn					;;AN006;;
 33693                                  
 33694                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33695                                  ;;
 33696                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33697                                  ;;
 33698                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33699                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33700                                  ;;		   CX contains the number of messages in class
 33701                                  ;;		   DH contains the message class
 33702                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33703                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33704                                  ;;
 33705                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33706                                  
 33707                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33708                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33709                                  $M_FIND_SPECIFIED_MSG:
 33710 00005798 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33711 0000579B 751F                    	jne	short $MIF64
 33712 0000579D 833E[369A]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33713                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33714                                  	; 15/06/2023
 33715 000057A2 7418                    	je	short $MIF64
 33716                                  
 33717 000057A4 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33718 000057A7 750B                    	jne	short $MIF65
 33719                                  	
 33720 000057A9 50                      	push	ax				;;AN004;; Reset the special message number
 33721 000057AA A1[569A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33722                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33723 000057AD FF1E[369A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33724                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33725 000057B1 58                      	pop	ax				;;AN004;; Reset the special message number
 33726                                  	; 28/04/2023
 33727 000057B2 EB04                    	jmp	short $MEN65
 33728                                  	; 18/04/2023
 33729                                  	;jmp	short $MEN64
 33730                                  $MIF65:
 33731 000057B4 FF1E[369A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33732                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33733                                  $MEN65:
 33734                                  	; 28/04/2023
 33735 000057B8 7344                    	jnc	short $MIF75
 33736                                  	;
 33737 000057BA EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33738                                  $MIF64:
 33739 000057BC 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33740 000057BE 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33741 000057C1 7406                    	je	short $MIF69
 33742                                  	
 33743 000057C3 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33744                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33745 000057C7 EB09                    	jmp	short $MEN69
 33746                                  $MIF69:
 33747                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33748                                  	;cmp	[cs:di+0],dh
 33749 000057C9 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33750 000057CC 7504                    	jne	short $MIF71
 33751                                  
 33752 000057CE 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33753                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33754                                  $MIF71:						;;AN001;;
 33755                                  $MEN69:
 33756 000057D2 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33757                                  	; 02/05/2023
 33758                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33759                                  $MEN64:
 33760                                  	;jnc	short $MIF75
 33761                                  	; 28/04/2023
 33762                                  	; (or instruction clears carry flag)
 33763                                  	;clc					;;AN004;; No, reset carry
 33764                                  $MDO76:
 33765 000057D5 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33766 000057D7 7417                    	jz	short $MEN76
 33767                                  
 33768 000057D9 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33769 000057DC 7405                    	je	short $MIF78
 33770                                  
 33771                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33772 000057DE 263B05                  	cmp	ax,[es:di]
 33773 000057E1 EB03                    	jmp	short $MEN78
 33774                                  $MIF78:
 33775                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33776 000057E3 2E3B05                  	cmp	ax,[cs:di]
 33777                                  $MEN78:
 33778                                  	;jne	short $MIF76
 33779                                  	;jmp	short $MSR76
 33780                                  	; 07/04/2023
 33781 000057E6 740B                    	je	short $MSR76 ; *
 33782                                  $MIF76:
 33783 000057E8 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33784 000057E9 7405                    	jz	short $MEN76
 33785                                  
 33786 000057EB 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33787 000057EE EBE5                    	jmp	short $MDO76			;;AN000;;
 33788                                  $MEN76:
 33789 000057F0 F9                      	stc					;;AN000;;
 33790                                  ;$MSR76:	; 07/04/2023
 33791                                  	;jc	short $MIF86			;;AN000;;
 33792                                  	; 07/04/2023
 33793                                  	;jc	short $MIF91
 33794 000057F1 EB11                    	jmp	short $MIF91 ;*
 33795                                  $MSR76:	; 07/04/2023 ; *	
 33796 000057F3 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33797                                  	; 07/04/2023
 33798                                  	;clc					;;AN001;;
 33799 000057F6 7502                    	jne	short $MIF87
 33800                                  
 33801 000057F8 0E                      	push	cs				;;AN000;;
 33802 000057F9 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33803                                  $MIF87:
 33804                                  	;add	di,[es:di+2]
 33805 000057FA 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33806                                  $MIF86:
 33807                                  ;$MIF75:
 33808                                  	; 02/05/2023
 33809                                  	;jc	short $MIF91
 33810                                  $MIF75:	; 28/04/2023
 33811 000057FE 30ED                    	xor	ch,ch				;;AN000;;
 33812 00005800 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33813 00005803 47                      	inc	di				;;AN000;; Increment past length
 33814                                  $MIF91:
 33815 00005804 C606[509A]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33816                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33817 00005809 C3                      	retn					;;AN000;; Return
 33818                                  
 33819                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33820                                  ;;
 33821                                  ;;  Proc Name:	SYSDISPMSG
 33822                                  ;;
 33823                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33824                                  ;;		requested by the caller. It also provides function to display
 33825                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33826                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33827                                  ;;		defined previous to entry.
 33828                                  ;;
 33829                                  ;;		It is assumes that a PRELOAD function has already determined
 33830                                  ;;		the addressibilty internally to the message retriever services.
 33831                                  ;;  Inputs:
 33832                                  ;;
 33833                                  ;;  Outputs:
 33834                                  ;;
 33835                                  ;;  Psuedocode:
 33836                                  ;;		Save registers needed later
 33837                                  ;;		Get address of the message requested
 33838                                  ;;		IF Message number exists THEN
 33839                                  ;;		  IF replacable parameters were specified THEN
 33840                                  ;;		     Display message with replacable parms
 33841                                  ;;		  ELSE
 33842                                  ;;		     Display string without replacable parms
 33843                                  ;;		  ENDIF
 33844                                  ;;		  IF character input was requested THEN
 33845                                  ;;		     Wait for character input
 33846                                  ;;		  ENDIF
 33847                                  ;;		  Clear CARRY FLAG
 33848                                  ;;		ELSE
 33849                                  ;;		   Set CARRY FLAG
 33850                                  ;;		ENDIF
 33851                                  ;;		Return
 33852                                  ;;
 33853                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33854                                  
 33855                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33856                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33857                                  	;
 33858                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33859                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5ACBh
 33860                                  SYSDISPMSG:
 33861                                  	;; Save registers and values needed later
 33862 0000580A 50                      	push	ax				;;AN000;; Save changed REGs
 33863 0000580B 53                      	push	bx				;;AN000;;
 33864 0000580C 51                      	push	cx				;;AN000;;
 33865 0000580D 55                      	push	bp				;;AN000;;
 33866 0000580E 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33867 0000580F 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33868 00005810 52                      	push	dx				;;AN000;; Save Input/Class request
 33869                                  
 33870 00005811 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33871 00005813 891E[4E9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33872                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33873 00005817 8836[539A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33874                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33875                                  
 33876                                  	;; Get address of the message requested
 33877 0000581B E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33878                                  
 33879 0000581E 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33880 00005820 7427                    	jz	short $MIF93
 33881                                  						;;AN000;; Yes, Message address in ES:DI
 33882                                  	
 33883                                  	;; Test if replacable parameters were specified
 33884 00005822 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33885 00005824 7505                    	jnz	short $MIF94
 33886                                  
 33887                                  	;; Display string without replacable parms
 33888 00005826 E82800                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33889 00005829 EB03                    	jmp	short $MEN94
 33890                                  $MIF94:
 33891                                  	;; Display message with replacable parms
 33892 0000582B E88B01                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33893                                  $MEN94:
 33894 0000582E 7214                    	jc	short $MIF97
 33895 00005830 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33896 00005831 E8FC00                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33897 00005834 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33898 00005835 5F                      	pop	di				;;AN000;;
 33899                                  	
 33900                                  ; 15/06/2023 - MSDOS 5.0
 33901                                  ;	;jmp	short $MEN97 ; ***
 33902                                  ;	; 08/04/2023
 33903                                  ;	;jmp	short $MEN93 ; **
 33904                                  ;
 33905                                  ;	; 08/04/2023
 33906                                  ;;$MEN93:
 33907                                  ;	jc	short $MIF104
 33908                                  
 33909                                  	; 15/06/2023 Retro DOS v4.2 COMMAND.COM
 33910                                   	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5AF7h
 33911                                  
 33912                                  	; MSDOS 6.0 (MSDOS 6.22)
 33913                                  	; Test if character input was requested	;;AN000;;
 33914 00005836 08D2                    	or	dl,dl
 33915 00005838 7403                    	jz	short $MIF98
 33916                                  	;jz	short $MEN98 ; *
 33917                                  
 33918 0000583A E88E05                  	call	$M_WAIT_FOR_INPUT	; MSDOS 6.0 (to 6.22)
 33919                                  	; cf = 0 ; *
 33920                                  $MIF98:
 33921                                  	;jmp	short $MEN97
 33922                                  	;;jc	short $MIF104 ; *
 33923                                  $MEN98:
 33924                                  ;$MEN97:
 33925 0000583D 5D                      	pop	bp				;;AN000;;
 33926 0000583E 59                      	pop	cx				;;AN000;;
 33927 0000583F 5B                      	pop	bx				;;AN000;;
 33928                                  	; 15/06/2023
 33929                                  	;pop	ax	; MSDOS 5.0		;;AN000;;
 33930 00005840 83C402                  	add	sp,2	; MSDOS 6.0 (to 6.22)
 33931 00005843 C3                      	retn
 33932                                   
 33933                                  $MIF97:
 33934                                  	; 08/04/2023
 33935                                  	;add	sp,6				;;AN000;;
 33936                                  	;stc					;;AN000;; Reset carry flag
 33937                                  ;$MEN97: ; ***
 33938                                  	;jmp	short $MEN93
 33939                                  	; 08/04/2023
 33940                                  	;jmp	short $MIF104
 33941                                  	; 08/04/2023
 33942 00005844 83C40E                  	add	sp,14 ; 6+8
 33943 00005847 F9                      	stc
 33944 00005848 C3                      	retn
 33945                                  $MIF93:
 33946                                  	; 08/04/2023 - 15/06/2023
 33947                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33948                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33949                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5B06h
 33950 00005849 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33951 0000584A 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33952 0000584B 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33953                                  	;stc	; * 				;;AN000;; Set carry flag
 33954                                  	; 08/04/2023
 33955                                  	;jmp	short $MIF104 ; *
 33956                                  
 33957                                  ;$MEN93: ; **
 33958                                  ;	jc	short $MIF104
 33959                                  ;$MEN97: ; 08/04/2023
 33960                                  ;	pop	bp				;;AN000;;
 33961                                  ;	pop	cx				;;AN000;;
 33962                                  ;	pop	bx				;;AN000;;
 33963                                  ;	pop	ax				;;AN000;;
 33964                                  ;	;jmp	short $MEN104
 33965                                  ;	; 08/04/2023
 33966                                  ;	retn
 33967                                  
 33968                                  $MIF104: ; *
 33969 0000584C 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33970 0000584F F9                      	stc					;;AN000;;
 33971                                  $MEN104:
 33972 00005850 C3                      	retn					;;AN000;; Return
 33973                                  
 33974                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33975                                  ;;
 33976                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33977                                  ;;
 33978                                  ;;	FUNCTION:  Will display or write string
 33979                                  ;;	INPUTS:    ES:DI points to beginning of message
 33980                                  ;;		   CX contains the length of string to write (if applicable)
 33981                                  ;;	OUTPUTS:   None
 33982                                  ;;	REGS Revised: None
 33983                                  ;;
 33984                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33985                                  
 33986                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33987                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33988                                  $M_DISPLAY_STRING:
 33989 00005851 50                      	push	ax				;;AN000;;
 33990 00005852 53                      	push	bx				;;AN000;;
 33991 00005853 52                      	push	dx				;;AN000;;
 33992 00005854 8B1E[4E9A]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33993                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33994                                  	
 33995 00005858 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33996 0000585B 7505                    	jne	short $MIF107
 33997                                  
 33998 0000585D E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33999 00005860 EB03                    	jmp	short $MEN107
 34000                                  $MIF107:
 34001 00005862 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 34002                                  $MEN107:
 34003 00005865 730D                    	jnc	short $MIF110
 34004                                  	
 34005 00005867 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 34006                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 34007                                  	; 08/04/2023
 34008 00005869 31DB                    	xor	bx,bx
 34009 0000586B CD21                    	int	21h				;;AN000;;
 34010                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 34011                                  		; BX = version code (0000h for DOS 3.x)
 34012 0000586D 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 34013                                  $MEN110: ; 08/04/2023 ; ***
 34014 0000586F 83C406                  	add	sp,6				;;AN000;; Clean up stack
 34015 00005872 F9                      	stc					;;AN000;; Flag that there was an error
 34016                                  	;jmp	short $MEN110 ; ****
 34017                                  	; 08/04/2023
 34018 00005873 C3                      	retn
 34019                                  $MIF110:
 34020                                  	;cmp	bx,$M_NO_HANDLE
 34021 00005874 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 34022 00005877 7409                    	je	short $MIF112 ; *  ; cf = 0
 34023 00005879 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 34024 0000587B 7405                    	je	short $MIF113 ; ** ; cf = 0
 34025 0000587D E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 34026                                  	;add	sp,6				;;AN001;; Clean up stack
 34027                                  	;stc					;;AN001;; Flag that there was an error
 34028                                  	; 08/04/2023
 34029 00005880 EBED                    	jmp	short $MEN110 ; ***
 34030                                  	; 08/04/2023
 34031                                  ;$MIF112:
 34032                                  ;$MEN110: ; ****
 34033                                  	;jc	short $MIF117
 34034                                  $MIF112: ; 08/04/2023	; *
 34035                                  $MIF113:	; **
 34036 00005882 5A                      	pop	dx				;;AN000;; Restore regs
 34037 00005883 5B                      	pop	bx				;;AN000;;
 34038 00005884 58                      	pop	ax				;;AN000;;
 34039                                  $MIF117:
 34040 00005885 C3                      	retn
 34041                                  
 34042                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34043                                  ;;
 34044                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 34045                                  ;;
 34046                                  ;;	FUNCTION:  Will display a $ terminated string
 34047                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 34048                                  ;;	OUTPUTS:   None
 34049                                  ;;	REGS USED: AX,DX
 34050                                  ;;
 34051                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34052                                  
 34053                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34054                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34055                                  $M_DISPLAY_$_STRING:
 34056 00005886 1E                      	push	ds				;;AN000;;
 34057 00005887 06                      	push	es				;;AN000;;
 34058 00005888 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34059                                  
 34060                                  	; 08/04/2023
 34061 00005889 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 34062                                  
 34063                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 34064 0000588B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 34065 0000588E 7518                    	jne	short $MIF119			;;AN000;; No
 34066                                  	
 34067                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34068 00005890 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 34069 00005893 CD21                    	int	21h				;;AN000;; Write character
 34070                                  		; DOS - DISPLAY OUTPUT
 34071                                  		; DL = character to send to standard output
 34072 00005895 1F                      	pop	ds				;;AN000;;
 34073 00005896 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 34074 00005898 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 34075 0000589B 1E                      	push	ds				;;AN000;;
 34076 0000589C 06                      	push	es				;;AN000;;
 34077 0000589D 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34078 0000589E 7316                    	jnc	short $MIF120 ; *
 34079                                  
 34080 000058A0 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 34081 000058A4 CD21                    	int	21h				;;AN000;; Write character
 34082                                  		; DOS - DISPLAY OUTPUT
 34083                                  		; DL = character to send to standard output
 34084                                  	; 08/04/2023
 34085                                  	;clc					;;AN000;; Clear the DBCS indicator
 34086                                  ;$MIF120:
 34087 000058A6 EB0D                    	jmp	short $MEN119
 34088                                  $MIF119:
 34089                                  	; 08/04/2023
 34090                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34091                                  ;$MDO123:
 34092 000058A8 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 34093                                  	;jz	short $MEN123
 34094                                  	; 18/04/2023
 34095 000058AA 740A                    	jz	short $MIF120 ; cf = 0
 34096                                  $MDO123: ; 08/04/2023
 34097 000058AC 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 34098 000058AF CD21                    	int	21h				;;AN002;; Display the character
 34099                                  		; DOS - DISPLAY OUTPUT
 34100                                  		; DL = character to send to standard output
 34101 000058B1 47                      	inc	di				;;AN002;; Set pointer to next character
 34102 000058B2 49                      	dec	cx				;;AN002;; Count this character
 34103 000058B3 75F7                    	jnz	short $MDO123
 34104                                  ;$MEN123:
 34105                                  $MEN119:
 34106 000058B5 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 34107                                  $MIF120: ; 08/04/2023 ; *
 34108 000058B6 1F                      	pop	ds				;;AN000;;
 34109 000058B7 C3                      	retn
 34110                                  
 34111                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34112                                  ;;
 34113                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 34114                                  ;; truncates it at the Ctrl-Z if any present.
 34115                                  ;;
 34116                                  ;;	ENTRY:	ds:dx = String to be displayed
 34117                                  ;;		cx = number of chars to be displayed
 34118                                  ;;
 34119                                  ;;	EXIT:	cx = number of chars to be displayed
 34120                                  ;;
 34121                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34122                                  
 34123                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34124                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34125                                  scan_ctrlz:
 34126 000058B8 57                      	push	di
 34127 000058B9 50                      	push	ax
 34128 000058BA 06                      	push	es
 34129 000058BB 53                      	push	bx
 34130                                  
 34131 000058BC 89D7                    	mov	di,dx
 34132 000058BE 1E                      	push	ds
 34133 000058BF 07                      	pop	es   			;es:di points at string
 34134                                  
 34135 000058C0 89CB                    	mov	bx,cx			;save current count
 34136                                  
 34137 000058C2 B01A                    	mov	al,1Ah	; Ctrl-Z
 34138 000058C4 FC                      	cld
 34139 000058C5 F2AE                    	repne	scasb			;find first Ctrl-Z
 34140 000058C7 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 34141                                  
 34142 000058C9 29CB                    	sub	bx,cx
 34143 000058CB 4B                      	dec	bx			;bx = new count to display
 34144                                  noCtrlZ:
 34145 000058CC 89D9                    	mov	cx,bx			;cx = actual display count
 34146                                  
 34147 000058CE 5B                      	pop	bx
 34148 000058CF 07                      	pop	es
 34149 000058D0 58                      	pop	ax
 34150 000058D1 5F                      	pop	di
 34151                                  $MIF127:	; 08/04/2023
 34152 000058D2 C3                      	retn
 34153                                  
 34154                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34155                                  ;;
 34156                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 34157                                  ;;
 34158                                  ;;	FUNCTION:  Will display a string to a specified handle
 34159                                  ;;	INPUTS:    ES:DI points to beginning of message
 34160                                  ;;		   CX contains the number of bytes to write
 34161                                  ;;		   BX contains the handle to write to
 34162                                  ;;	OUPUTS:    None
 34163                                  ;;	REGS USED: AX,DX
 34164                                  ;;
 34165                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34166                                  
 34167                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34168                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34169                                  $M_DISPLAY_H_STRING:
 34170 000058D3 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 34171 000058D5 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 34172 000058D7 74F9                    	jz	short $MIF127
 34173                                  	
 34174 000058D9 1E                      	push	ds			;;AN000;;
 34175 000058DA 06                      	push	es			;;AN000;;
 34176 000058DB 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34177                                  	
 34178 000058DC B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34179 000058DE 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 34180                                  
 34181 000058E0 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 34182 000058E3 7528                    	jne	short $MIF128		;;AN000;; No
 34183                                  
 34184 000058E5 CD21                    	int	21h			;;AN000;; Write character
 34185                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34186                                  		; BX = file handle, CX = number of bytes to writ
 34187                                  
 34188 000058E7 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34189 000058E8 50                      	push	ax			;;AN000;;
 34190 000058E9 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 34191 000058EC E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 34192 000058EF 58                      	pop	ax			;;AN000;;
 34193 000058F0 1E                      	push	ds			;;AN000;;
 34194 000058F1 06                      	push	es			;;AN000;;
 34195 000058F2 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34196 000058F3 7306                    	jnc	short $MIF129
 34197                                  	
 34198 000058F5 F8                      	clc				;;AN000;; Clear the DBCS indicator
 34199 000058F6 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34200 000058F8 42                      	inc	dx			;;AN000;; Point to next character
 34201 000058F9 CD21                    	int	21h			;;AN000;; Write character
 34202                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34203                                  		; BX = file handle, CX = number of bytes to write, 
 34204                                  $MIF129:
 34205                                  ;SR;
 34206                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 34207                                  ;0 chars written making the caller think there was an error writing. To 
 34208                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 34209                                  ;the char was written, thus fooling the caller.
 34210                                  
 34211 000058FB 9C                      	pushf				;save flags
 34212 000058FC 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 34213 00005900 7502                    	jne	short m_popf_j		;no, continue
 34214                                  
 34215 00005902 89C8                    	mov	ax,cx			;yes, fake as if it was written
 34216                                  m_popf_j:
 34217                                  	; 08/04/2023
 34218                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34219 00005904 EB01                    	jmp	short m_popf		;restore flags
 34220                                  
 34221                                  ; 07/04/2023
 34222                                  ; ---------------------------
 34223                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34224                                  ; ---------------------------
 34225                                  	; $M_POPF macro
 34226                                  	;jmp	short $+3
 34227                                  intret:
 34228 00005906 CF                      	iret
 34229                                  m_popf:
 34230 00005907 0E                      	push	cs
 34231 00005908 E8FBFF                  	call	intret
 34232                                  	;;; end macro	
 34233                                  ; ---------------------------
 34234                                  
 34235 0000590B EB18                    	jmp	short $MEN128
 34236                                  
 34237                                  $MIF128:
 34238                                  ;SR;
 34239                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34240                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34241                                  
 34242 0000590D 55                      	push	bp			; M007
 34243 0000590E 51                      	push	cx
 34244 0000590F E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34245 00005912 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34246 00005914 59                      	pop	cx			;get old count back ;M007
 34247                                  	
 34248 00005915 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34249                                  	;jnc	short chk_count		;no error, adjust return count
 34250                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34251                                  	; 08/04/2023
 34252 00005917 720B                    	jc	short m_cnt_ok 
 34253                                  ;M007
 34254                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34255                                  ;return count will be much less and if this returns to the caller we can get
 34256                                  ;spurious error messages. We check here if the count returned is same as
 34257                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34258                                  ;case, we fake it as if all bytes have been written. If the return count
 34259                                  ;does not match either count, then we had some other disk error (such as
 34260                                  ;insufficient disk space) and we pass it through
 34261                                  
 34262                                  chk_count:
 34263 00005919 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34264 0000591B 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34265 0000591D 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34266 0000591F F8                      	clc				;no error either way ;M007
 34267 00005920 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34268 00005922 89C8                    	mov	ax,cx			;return old count ;M007
 34269                                  m_cnt_ok:				; M007
 34270 00005924 5D                      	pop	bp			; M007
 34271                                  $MEN128:
 34272 00005925 1F                      	pop	ds			;;AN000;;
 34273                                  ;$MIF127: ; 08/04/2023
 34274 00005926 C3                      	retn
 34275                                  
 34276                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34277                                  ;;
 34278                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34279                                  ;;
 34280                                  ;;	FUNCTION:  Will set registers for extended error #39
 34281                                  ;;	INPUTS:    None
 34282                                  ;;	OUPUTS:    AX,BX,CX set
 34283                                  ;;	REGS USED:
 34284                                  ;;
 34285                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34286                                  
 34287                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34288                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34289                                  
 34290                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34291                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5BFAh
 34292                                  
 34293                                  $M_GET_EXT_ERR_39:
 34294 00005927 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34295                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34296 0000592A BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34297                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34298 0000592D B501                    	mov	ch,1			;AN001;
 34299 0000592F C3                      	retn				;AN001;
 34300                                  
 34301                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34302                                  ;;
 34303                                  ;;	PROC NAME: $M_ADD_CRLF
 34304                                  ;;
 34305                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34306                                  ;;	INPUTS:    DX contains the Input/Class requested
 34307                                  ;;	OUTPUTS:   None
 34308                                  ;;	REGS Revised: CX,ES,DI
 34309                                  ;;
 34310                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34311                                  
 34312                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34313                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34314                                  $M_ADD_CRLF:
 34315                                  	;cmp	dh,0FFh
 34316 00005930 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34317 00005933 7411                    	je	short $MIF134		;;AN004;; Yes
 34318 00005935 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 34319 00005938 750C                    	jnz	short $MIF135
 34320                                  					;;AN004;; No	
 34321 0000593A 1E                      	push	ds			;;AN004;;
 34322 0000593B 07                      	pop	es			;;AN004;; Set ES to data segment
 34323 0000593C 8D3E[519A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34324                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34325 00005940 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34326 00005943 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34327                                  $MIF135:
 34328                                  $MIF134:
 34329 00005946 C3                      	retn				;;AN004;; Return
 34330                                  
 34331                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34332                                  ;;
 34333                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34334                                  ;;
 34335                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34336                                  ;;	INPUTS:    AL contains the byte to be checked
 34337                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34338                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34339                                  ;;	REGS USED: All restored
 34340                                  ;;
 34341                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34342                                  
 34343                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34344                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34345                                  $M_IS_IT_DBCS:
 34346 00005947 06                      	push	es			;;AN000;; Save Extra Segment register
 34347 00005948 57                      	push	di			;;AN000;; Save DI register
 34348                                  
 34349 00005949 C43E[4A9A]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34350                                  	;les	di,[$M_RT+60]		;;AN000;;
 34351 0000594D 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34352 0000594F 7417                    	jz	short $MIF138		;;AN000;; No
 34353                                  $MDO139:
 34354 00005951 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34355                                  					;;AN000;; Is this the terminating flag?
 34356 00005955 F8                      	clc				;;AN000;;
 34357 00005956 7410                    	jz	short $MEN139
 34358                                  					;;AN000;; No
 34359 00005958 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34360 0000595B 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34361 0000595D 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34362 00005961 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34363                                  					;;AN000;; Yes
 34364 00005963 F9                      	stc				;;AN000;; Set carry flag
 34365                                  $MIF141:
 34366 00005964 47                      	inc	di			;;AN000;;
 34367 00005965 47                      	inc	di			;;AN000;;
 34368 00005966 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34369                                  $MEN139:
 34370                                  $MIF138:
 34371 00005968 5F                      	pop	di			;;AN000;; Restore DI register
 34372 00005969 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34373 0000596A C3                      	retn				;;AN000;; Return
 34374                                  
 34375                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34376                                  ;;
 34377                                  ;;	PROC NAME: $M_CONVERT2ASC
 34378                                  ;;
 34379                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34380                                  ;;	INPUTS: DX:AX contains the number to be converted
 34381                                  ;;		$M_RT_DIVISOR contains the divisor
 34382                                  ;;	OUTPUTS: CX contains the number of characters
 34383                                  ;;		Top of stack  --> Last character
 34384                                  ;;				     . . .
 34385                                  ;;		Bot of stack  --> First character
 34386                                  ;;	REGS USED:
 34387                                  ;;
 34388                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34389                                  
 34390                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34391                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34392                                  $M_CONVERT2ASC:
 34393 0000596B 8F06[549A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34394                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34395                                  	
 34396 0000596F 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34397 00005971 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34398 00005972 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34399                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34400 00005973 F736[589A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34401                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34402 00005977 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34403                                  						;;AN000;;  and save reduced High Word in BX
 34404 00005978 F736[589A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34405                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34406                                  
 34407 0000597C 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34408 0000597F 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34409 00005981 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34410 00005984 EB03                    	jmp	short $MEN146
 34411                                  $MIF146:
 34412 00005986 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34413                                  $MEN146:
 34414 00005989 52                      	push	dx				;;AN000;; Save the digit on the stack
 34415 0000598A 41                      	inc	cx				;;AN000;; Count that digit
 34416 0000598B 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34417 0000598D 7504                    	jnz	short $MLL149			;;AN000;; No
 34418 0000598F 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34419 00005991 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34420                                  $MLL149:
 34421 00005993 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34422                                  ; 28/04/2023
 34423 00005996 740A                    	je	short $MIF153
 34424                                  ;	jne	short $MIF150			;;AN000;; No
 34425                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34426                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34427                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34428                                  ;	;jne	short $MIF151
 34429                                  ;	; 09/04/2023
 34430                                  ;	jne	short $MEN150
 34431                                  ;						;;AN000;; Yes
 34432                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34433                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34434                                  ;	inc	cx				;;AN000;;
 34435                                  ;$MIF151:
 34436                                  ;	jmp	short $MEN150
 34437                                  
 34438                                  $MIF150:
 34439                                  	; 15/06/2023 (6)
 34440                                  	; MSDOS 6.0
 34441                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34442                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34443                                  	; 15/06/2023 (7)
 34444                                  	; MSDOS 6.22
 34445                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34446 00005998 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark	
 34447                                  
 34448                                  ; 28/04/2023
 34449 0000599B 7405                    	je	short $MIF153
 34450                                  ;	jne	short $MIF154			;;AN000;; No
 34451                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34452                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34453                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34454                                  ;	;jne	short $MIF155			;;AN000;; No
 34455                                  ;	; 09/04/2023
 34456                                  ;	jne	short $MEN154
 34457                                  ;						;;AN000;; Yes				
 34458                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34459                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34460                                  ;	inc	cx				;;AN000;;
 34461                                  ;$MIF155:
 34462                                  ;	jmp	short $MEN154
 34463                                  
 34464                                  $MIF154:
 34465                                  	; 15/06/2023 (9)
 34466                                  	; MSDOS 6.0
 34467                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh 
 34468                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34469                                  	; 15/06/2023 (11)
 34470                                  	; MSDOS 6.22
 34471                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah 
 34472 0000599D 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34473 000059A0 750B                    	jne	short $MIF158			;;AN000;; No  
 34474                                  ; 28/04/2023
 34475                                  $MIF153:
 34476                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34477 000059A2 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34478                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34479 000059A6 7505                    	jne	short $MIF159			;;AN000;; No
 34480                                  						;;AN000;; Yes
 34481 000059A8 FF36[619A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34482                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34483 000059AC 41                      	inc	cx				;;AN000;;
 34484                                  $MIF159:
 34485                                  $MIF158:
 34486                                  $MEN154:
 34487                                  $MEN150:					;;AN000;;
 34488 000059AD 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34489                                  						;;AN000;;  and Revised Low Word
 34490 000059AE 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34491                                  	; 28/04/2023
 34492 000059B0 EBC1                    	jmp	short $MDO145
 34493                                  ;$MEN145:
 34494                                  	; 28/04/2023
 34495                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34496                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34497 000059B2 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34498 000059B4 FF36[549A]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34499                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34500 000059B8 C3                      	retn					;;AN000;; Return
 34501                                  
 34502                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34503                                  ;;
 34504                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34505                                  ;;
 34506                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34507                                  ;;	INPUTS:    ES:DI points to beginning of message
 34508                                  ;;		   DS:SI points to first sublist structure in chain
 34509                                  ;;		   BX contains the handle to write to (if applicable)
 34510                                  ;;		   CX contains the length of string to write (before substitutions)
 34511                                  ;;		   BP contains the count of replacables
 34512                                  ;;
 34513                                  ;;	OUTPUTS:
 34514                                  ;;	REGS USED: All
 34515                                  ;;
 34516                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34517                                  
 34518                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34519                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34520                                  
 34521                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34522                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:54DBh
 34523                                  
 34524                                  $M_DISPLAY_MESSAGE:
 34525                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34526                                  $MDO165:
 34527 000059B9 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34528 000059BB 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34529                                  ;; $IF NZ					;;AN000;; No
 34530 000059BD 7421                    	jz	short $MIF166			;;AN000;; Yes
 34531 000059BF B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 34532 000059C1 B000                    	mov	al,0				;;AN004;;
 34533                                  ;; $DO						;;AN000;; Scan through string until %
 34534                                  $MDO167:
 34535 000059C3 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34536                                  ;; $LEAVE E,AND					;;AN000;; No
 34537 000059C6 750A                    	jne	short $MLL168
 34538 000059C8 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34539                                  ;; $LEAVE NE,AND				;;AN000;; No
 34540 000059CC 7404                    	je	short $MLL168
 34541                                  
 34542 000059CE 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34543                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34544 000059D0 750E                    	jne	short MEN167
 34545                                  $MLL168:
 34546 000059D2 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34547 000059D5 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34548                                  ;;; $IF C					;;AN004;; Yes
 34549 000059D8 7301                    	jnc	short $MIF169
 34550 000059DA 47                      	inc	di				;;AN004;; Increment past second part
 34551                                  ;;; $ENDIF					;;AN004;;
 34552                                  $MIF169:
 34553 000059DB 47                      	inc	di				;;AN000;; Next character in string
 34554 000059DC 42                      	inc	dx				;;AN000;; Size = Size + 1
 34555 000059DD 49                      	dec	cx				;;AN000;; Decrement total size
 34556                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34557 000059DE 75E3                    	jnz	short $MDO167
 34558                                  $MEN167:
 34559                                  ;; $ENDIF					;;AN000;;
 34560                                  $MIF166:
 34561 000059E0 56                      	push	si				;;AN000;; Save beginning of sublists
 34562 000059E1 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34563 000059E3 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34564                                  ;; $IF NZ					;;AN000;; Yes
 34565 000059E5 7431                    	jz	short $MIF173
 34566 000059E7 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34567                                  
 34568                                  ;; Search through sublists to find applicable one
 34569                                  
 34570 000059E8 833E[569A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34571                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34572                                  ;;; $IF E					;;AN000;; No
 34573 000059ED 7529                    	jne	short $MIF174
 34574                                  ;;; $SEARCH					;;AN000;;
 34575                                  $MDO175:
 34576                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34577 000059EF 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34578                                  	;mov	al,[si+6]
 34579 000059F2 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34580                                  	; 28/04/2023					
 34581 000059F4 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34582                                  ;;; $EXITIF E					;;AN000;;
 34583                                  	;jne	short $MIF175
 34584                                  ;;; $ORELSE					;;AN000;; No
 34585                                  	;jmp	short $MSR175
 34586                                  	; 28/04/2023
 34587 000059F8 741E                    	je	short $MSR175
 34588                                  $MIF175:
 34589 000059FA 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34590                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34591 000059FC 7504                    	jne	short $MLL178
 34592 000059FE 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34593                                  ;;; $LEAVE Z					;;AN000;; No
 34594 00005A00 7404                    	jz	short $MEN175
 34595                                  $MLL178:
 34596                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34597                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34598                                  	;;add	si,[si+0]
 34599 00005A02 0334                    	add	si,[si]
 34600                                  ;;; ENDLOOP					;;AN000;; Yes
 34601 00005A04 EBE9                    	jmp	short $MDO175
 34602                                  $MEN175:
 34603 00005A06 803E[539A]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34604                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34605                                  ;;;; $IF E					;;AN004;; Yes
 34606 00005A0B 7508                    	jne	short $MIF180
 34607 00005A0D 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34608 00005A0E 42                      	inc	dx				;;AN000;;  at the end of the message
 34609 00005A0F 49                      	dec	cx				;;AN000;; Adjust message length
 34610 00005A10 49                      	dec	cx				;;AN000;;
 34611 00005A11 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34612 00005A12 4F                      	dec	di				;;AN000;;
 34613                                  ;;;; $ELSE					;;AN004;; No
 34614 00005A13 EB03                    	jmp	short $MEN180
 34615                                  $MIF180:
 34616 00005A15 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34617                                  ;;;; $ENDIF					;;AN004;;
 34618                                  $MEN180:
 34619                                  ;;; $ENDSRCH					;;AN000;;
 34620                                  $MSR175:
 34621                                  ;; $ENDIF					;;AN000;;
 34622                                  $MIF174:
 34623                                  ; $ENDIF					;;AN000;;
 34624                                  $MIF173:
 34625                                  ;; Prepare and display this part of message
 34626                                  
 34627 00005A18 57                      	push	di				;;AN000;; Save pointer to replace number
 34628 00005A19 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34629 00005A1B E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34630 00005A1E 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34631 00005A1F 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34632                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34633                                  	;jnc	short $MXL3
 34634                                  	;jmp	$MEN165
 34635                                  	; 02/05/2023
 34636 00005A20 7214                    	jc	short $MEN165
 34637                                  $MXL3:
 34638 00005A22 51                      	push	cx				;;AN000;;
 34639                                  
 34640                                  ;; Save and reset pointer registers
 34641                                  
 34642 00005A23 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34643                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34644 00005A25 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34645                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34646                                  ; $IF NE					;;AN000;; No
 34647 00005A29 7412                    	je	short $MIF187			;;AN000;; Yes			
 34648 00005A2B 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34649                                  ;; $IF NZ					;;AN000;; No
 34650 00005A2D 7406                    	jz	short $MIF188			;;AN000;; Yes
 34651 00005A2F 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34652 00005A30 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34653 00005A31 47                      	inc	di				;;AN000;; Go past %
 34654 00005A32 47                      	inc	di				;;AN000;; Go past replace number
 34655                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34656                                  	;jmp	short $MEN188
 34657                                  	; 28/04/2023
 34658 00005A33 EB15                    	jmp	short $MEN187
 34659                                  $MIF188:
 34660 00005A35 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34661                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34662                                  $MEN188:
 34663                                  ; $ELSE 					;;AN000;;
 34664                                  	;jmp	short $MEN187
 34665                                  	; 28/04/2023
 34666                                  	; zf = 1
 34667                                  	;jmp	short $MEN165 
 34668                                  
 34669                                  ; 28/04/2023
 34670                                  $MXL4:
 34671                                  $MLL214:
 34672                                  $MEN165:
 34673 00005A36 C706[569A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34674                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34675                                  						;;AN000;; Reset message number to null
 34676 00005A3C C3                      	retn					;;AN000;; Return
 34677                                  
 34678                                  $MIF187:
 34679 00005A3D 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34680                                  ;; $IF Z					;;AN004;; No
 34681                                  	;jnz	short $MIF192
 34682                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34683                                  ;; $ELSE					;;AN000;; No
 34684                                  	;jmp	short $MEN192
 34685                                  	; 28/04/2023
 34686 00005A3F 74F4                    	jz	short $MIF188
 34687                                  $MIF192:
 34688 00005A41 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34689                                  ;;; $IF Z					;;AN004;; No
 34690 00005A44 7502                    	jnz	short $MIF194
 34691 00005A46 31C9                    	xor	cx,cx				;;AN004;;
 34692                                  ;;; $ENDIF					;;AN000;;
 34693                                  $MIF194:
 34694 00005A48 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34695                                  ;; $ENDIF					;;AN000;;
 34696                                  $MEN192:
 34697                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34698                                  $MEN187:
 34699                                  ; $LEAVE Z					;;AN000;;
 34700 00005A4A 74EA                    	jz	short $MEN165
 34701                                  	;
 34702 00005A4C 55                      	push	bp				;;AN000;; Save the replace count
 34703 00005A4D 57                      	push	di				;;AN000;; Save location to complete message
 34704 00005A4E 06                      	push	es				;;AN000;;
 34705 00005A4F 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34706 00005A50 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34707                                  
 34708                                  ;; Determine what action is required on parameter
 34709                                  
 34710 00005A52 833E[569A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34711                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34712                                  ; $IF E						;;AN000;;
 34713 00005A57 753B                    	jne	short $MIF199
 34714                                  
 34715                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34716 00005A59 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34717                                  	;test	byte [si+7],0Fh			;;AN000;;
 34718                                  ;; $IF Z					;;AN000;;
 34719 00005A5D 7508                    	jnz	short $MIF200
 34720                                  
 34721                                  ;; Character type requested
 34722                                  
 34723                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34724 00005A5F C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34725                                  	;les	di,[si+2]
 34726 00005A62 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34727                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34728 00005A65 EB28                    	jmp	short $MEN200
 34729                                  $MIF200:
 34730                                  ;; ENDIF					;;AN000;;
 34731                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34732 00005A67 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34733                                  	;test	byte [si+7],0Dh			;;AN000;;
 34734                                  ;; $IF Z,OR					;;AN000;;
 34735 00005A6B 740C                    	jz	short $MLL202
 34736                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34737 00005A6D F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34738                                  	;test	byte [si+7],0Eh			;;AN000;;
 34739                                  ;;; $IF Z,OR					;;AN000;;
 34740 00005A71 7406                    	jz	short $MLL202
 34741                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34742 00005A73 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34743                                  	;test	byte [si+7],0Ch			;;AN000;;
 34744                                  ;;;; $IF Z 					;;AN000;;
 34745 00005A77 7508                    	jnz	short $MIF202
 34746                                  $MLL202:
 34747                                  
 34748                                  ;; Numeric type requested
 34749                                  
 34750                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34751 00005A79 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34752                                  	;les	di,[si+2]
 34753 00005A7C E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34754                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34755 00005A7F EB0E                    	jmp	short $MEN202
 34756                                  $MIF202:
 34757                                  ;;;; ENDIF					;;AN000;;
 34758                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34759 00005A81 F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34760                                  	;test	byte [si+7],0Bh			;;AN000;;
 34761                                  ;;;; $IF E					;;AN000;;
 34762 00005A85 7505                    	jnz	short $MIF204
 34763                                  
 34764                                  ;; Date type requested
 34765                                  
 34766 00005A87 E8EC01                  	call	$M_DATE_REPLACE			;;AN000;;
 34767                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34768 00005A8A EB03                    	jmp	short $MEN204
 34769                                  $MIF204:					;;AN000;;
 34770                                  
 34771                                  ;; Time type requested (Default if we have not matched until here)
 34772                                  
 34773 00005A8C E89E02                  	call	$M_TIME_REPLACE			;;AN000;;
 34774                                  
 34775                                  ;;;; $ENDIF					;;AN000;;
 34776                                  $MEN204:
 34777                                  ;;; $ENDIF					;;AN000;;
 34778                                  $MEN202:
 34779                                  ;; $ENDIF					;;AN000;;
 34780                                  $MEN200:
 34781                                  
 34782                                  ;; With the replace information of the Stack, display the replaceable field
 34783                                  
 34784 00005A8F E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34785                                  
 34786                                  ;; None of the above - Extended/Parse replace
 34787                                  ; $ELSE 					;;AN000;;
 34788 00005A92 EB03                    	jmp	short $MEN199
 34789                                  $MIF199:
 34790 00005A94 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34791                                  ; $ENDIF					;;AN000;;
 34792                                  $MEN199:
 34793                                  
 34794                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34795                                  
 34796                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34797 00005A97 7207                    	jc	short $MIF211
 34798                                  	;
 34799 00005A99 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34800 00005A9A 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34801 00005A9B 5F                      	pop	di				;;AN000;;
 34802 00005A9C 5D                      	pop	bp				;;AN000;; Get replacment count
 34803 00005A9D 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34804                                  ; $ELSE						;;AN000;;
 34805 00005A9E EB03                    	jmp	short $MEN211
 34806                                  $MIF211:
 34807 00005AA0 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34808                                  	; 28/04/2023
 34809                                  	;stc					;;AN000;;
 34810                                  ; $ENDIF					;;AN000;;
 34811                                  $MEN211:
 34812 00005AA3 833E[569A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34813                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34814                                  ; $ENDDO NE,OR					;;AN000;;
 34815 00005AA8 758C                    	jne	short $MLL214
 34816                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34817                                  	; 10/04/2023
 34818                                  	;jc	short $MXL4
 34819 00005AAA E90CFF                  	jmp	$MDO165
 34820                                  
 34821                                  ; 28/04/2023
 34822                                  ;$MXL4:
 34823                                  ;$MLL214:
 34824                                  ;$MEN165:
 34825                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34826                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34827                                  ;						;;AN000;; Reset message number to null
 34828                                  ;	retn					;;AN000;; Return
 34829                                  
 34830                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34831                                  ;;
 34832                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34833                                  ;;
 34834                                  ;;	FUNCTION:
 34835                                  ;;	INPUTS:
 34836                                  ;;	OUPUTS:
 34837                                  ;;
 34838                                  ;;	REGS USED:
 34839                                  ;;
 34840                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34841                                  
 34842                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34843                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34844                                  
 34845                                  $M_EXT_PAR_REPLACE:
 34846 00005AAD 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34847 00005AAF A1[569A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34848                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34849 00005AB2 C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34850                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34851 00005AB8 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34852                                  $MDO215:
 34853 00005ABB 58                      	pop	ax				;;AN000;; Get character in register
 34854 00005ABC 8887[5A9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34855                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34856 00005AC0 43                      	inc	bx				;;AN000;; Increase buffer count
 34857 00005AC1 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34858 00005AC4 7503                    	jne	short $MIF216			;;AN000;; No
 34859 00005AC6 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34860                                  $MIF216:
 34861 00005AC9 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34862 00005ACB 75EE                    	jnz	short $MDO215
 34863                                  
 34864 00005ACD B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34865 00005AD0 8987[5A9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34866                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34867 00005AD4 43                      	inc	bx				;;AN000;; Increase buffer count
 34868 00005AD5 43                      	inc	bx				;;AN000;; Increase buffer count
 34869                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34870                                  	;retn					;;AN000::
 34871                                  	; 11/04/2023
 34872                                  	;jmp	$M_FLUSH_BUF
 34873                                  
 34874                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34875                                  ;;
 34876                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34877                                  ;;
 34878                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34879                                  ;;	INPUTS: DI contains the number of bytes to display
 34880                                  ;;	OUTPUTS: BX reset to zero
 34881                                  ;;
 34882                                  ;;	REGS USED:
 34883                                  ;;
 34884                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34885                                  	
 34886                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34887                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34888                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34889                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5E95h
 34890                                  $M_FLUSH_BUF:
 34891 00005AD6 51                      	push	cx				;;AN000;; Save changed regs
 34892 00005AD7 06                      	push	es				;;AN000;;
 34893 00005AD8 57                      	push	di				;;AN000;;
 34894 00005AD9 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34895 00005ADA 07                      	pop	es				;;AN000;;
 34896 00005ADB 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34897 00005ADD 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34898 00005ADF 8D3E[5A9A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34899                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34900 00005AE3 E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34901 00005AE6 7204                    	jc	short $MIF314
 34902 00005AE8 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34903 00005AE9 07                      	pop	es				;;AN000;;
 34904 00005AEA 59                      	pop	cx				;;AN000;;
 34905                                  	;jmp	short $MEN314
 34906                                  	; 11/04/2023
 34907 00005AEB C3                      	retn
 34908                                  $MIF314:
 34909 00005AEC 83C406                  	add	sp,6				;;AN000;; Fix stack
 34910 00005AEF F9                      	stc					;;AN000;;
 34911                                  $MEN314:
 34912 00005AF0 C3                      	retn					;;AN000;; Return
 34913                                  
 34914                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34915                                  ;;
 34916                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34917                                  
 34918                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34919                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34920                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34921                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5DD6h
 34922                                  $M_DISPLAY_REPLACE:
 34923 00005AF1 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34924                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34925 00005AF3 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34926                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34927 00005AF7 7511                    	jne	short $MIF276
 34928                                  	
 34929 00005AF9 C787[5A9A]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34930                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34931                                  	
 34932 00005AFF 43                      	inc	bx				;;AN000;; Increment count
 34933 00005B00 43                      	inc	bx				;;AN000;; Increment count
 34934                                  	
 34935 00005B01 C687[5A9A]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h ; $M_SPACE
 34936                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34937                                  	
 34938 00005B06 43                      	inc	bx				;;AN000;; Increment count
 34939 00005B07 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34940                                  $MIF276:
 34941 00005B0A 5D                      	pop	bp				;;AN000;; Remember the return address
 34942 00005B0B 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34943 00005B0D 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34944                                  
 34945 00005B0F 880E[509A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34946                                  	;mov	[$M_RT+66],cl
 34947                                  	
 34948                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34949 00005B13 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34950                                  	;mov	al,[si+9]
 34951                                  	
 34952 00005B16 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34953 00005B18 761E                    	jna	short $MIF278
 34954 00005B1A 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34955 00005B1C 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34956                                  	
 34957                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34958 00005B1E F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34959                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34960 00005B22 7414                    	jz	short $MIF279			;;AN000;; No
 34961                                  $MDO280:
 34962                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34963 00005B24 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34964                                  	;mov	al,[si+0Ah]
 34965 00005B27 8887[5A9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34966                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34967                                  	
 34968 00005B2B 43                      	inc	bx				;;AN000;;
 34969 00005B2C 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34970 00005B2F 7503                    	jne	short $MIF281
 34971 00005B31 E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34972                                  $MIF281:
 34973 00005B34 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34974 00005B36 75EC                    	jnz	short $MDO280
 34975                                  $MIF279:
 34976                                  $MIF278:
 34977                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34978 00005B38 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34979                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34980 00005B3C 740C                    	je	short $MIF286
 34981                                  	
 34982                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34983 00005B3E 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34984                                  	;;cmp	byte [si+8],cl
 34985 00005B41 7307                    	jnb	short $MIF287
 34986                                  
 34987                                  	; 03/05/2023
 34988                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34989                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34990                                  	;;sub	cl,[si+8]
 34991 00005B43 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34992                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34993                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34994                                  	;;mov	cl,[si+8]
 34995                                  	; 03/05/2023
 34996 00005B45 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34997 00005B48 28CA                    	sub	dl,cl
 34998                                  $MIF287:
 34999                                  $MIF286:
 35000 00005B4A 09C9                    	or	cx,cx				;;AN000;;
 35001 00005B4C 7424                    	jz	short $MIF290			;;AN000;;
 35002                                  $MDO291:
 35003                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 35004 00005B4E F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35005                                  	;test	byte [si+7],0Fh			;;AN000;;
 35006 00005B52 750C                    	jnz	short $MIF292
 35007                                  
 35008                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35009 00005B54 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35010                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 35011 00005B58 7406                    	jz	short $MIF292			;;AN000;; No
 35012                                  
 35013 00005B5A 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 35014 00005B5D 47                      	inc	di				;;AN000;; Next character in string
 35015 00005B5E EB01                    	jmp	short $MEN292
 35016                                  $MIF292:
 35017 00005B60 58                      	pop	ax				;;AN000;; Get character in register
 35018                                  $MEN292:
 35019                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35020 00005B61 8887[5A9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35021                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 35022                                  	; 03/05/2023
 35023 00005B65 43                      	inc	bx				;;AN000;; Increase buffer count
 35024 00005B66 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 35025 00005B69 7503                    	jne	short $MIF295			;;AN000;;
 35026 00005B6B E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35027                                  $MIF295:
 35028 00005B6E FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 35029 00005B70 75DC                    	jnz	short $MDO291
 35030                                  $MIF290:
 35031                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 35032 00005B72 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 35033                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 35034 00005B76 7518                    	jnz	short $MIF299			;;AN000;; Yes
 35035 00005B78 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 35036 00005B7A 7414                    	jz	short $MIF300
 35037                                  $MDO301:
 35038                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 35039 00005B7C 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35040                                  	;mov	al,[si+0Ah]
 35041                                  
 35042                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35043 00005B7F 8887[5A9A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35044                                  	; 03/05/2023
 35045                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 35046                                  
 35047 00005B83 43                      	inc	bx				;;AN000;;
 35048 00005B84 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 35049 00005B87 7503                    	jne	short $MIF302			;;AN000;; No
 35050                                  						;;AN000;; Yes
 35051 00005B89 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35052                                  $MIF302:
 35053 00005B8C FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 35054 00005B8E 75EC                    	jnz	short $MDO301			;;AN000;;
 35055                                  $MIF300:
 35056                                  $MIF299:
 35057                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 35058 00005B90 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35059                                  	;test	byte [si+7],0Fh			;;AN000;;
 35060 00005B94 7506                    	jnz	short $MIF307
 35061                                  	
 35062                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35063 00005B96 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35064                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 35065                                  	; 11/04/2023
 35066                                  	;jz	short $MIF307			;;AN000;;
 35067                                  	;jmp	short $MEN307			;;AN000;;
 35068 00005B9A 750C                    	jnz	short $MEN307
 35069                                  $MIF307:
 35070 00005B9C 08D2                    	or	dl,dl				;;AN000;;
 35071 00005B9E 7408                    	jz	short $MIF309			;;AN000;;
 35072                                  $MDO310:
 35073 00005BA0 8F06[549A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 35074                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 35075 00005BA4 FECA                    	dec	dl				;;AN000;; Are we done?
 35076 00005BA6 75F8                    	jnz	short $MDO310
 35077                                  $MIF309:
 35078                                  $MEN307:
 35079 00005BA8 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 35080 00005BAB 55                      	push	bp				;;AN000;; Restore the return address
 35081 00005BAC C3                      	retn					;;AN000;;
 35082                                  
 35083                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35084                                  ;;
 35085                                  ;;	PROC NAME: $M_CHAR_REPLACE
 35086                                  ;;
 35087                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 35088                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35089                                  ;;		ES:DI contains the VALUE from SUBLIST
 35090                                  ;;	OUTPUTS: CX contains number of characters on stack
 35091                                  ;;		 Top of stack  --> Last character
 35092                                  ;;					. . .
 35093                                  ;;		 Bot of stack  --> First character
 35094                                  ;;
 35095                                  ;;	OTHER REGS Revised: AX
 35096                                  ;;
 35097                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35098                                  
 35099                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35100                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35101                                  $M_CHAR_REPLACE:
 35102 00005BAD 5D                      	pop	bp				;;AN000;; Save return address
 35103                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 35104 00005BAE F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 35105                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 35106 00005BB2 7512                    	jnz	short $MIF317			;;AN000;; No
 35107 00005BB4 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35108 00005BB7 50                      	push	ax				;;AN000;; Put it on the stack
 35109 00005BB8 41                      	inc	cx				;;AN000;; Increase the count
 35110 00005BB9 E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 35111 00005BBC 7306                    	jnc	short $MIF318
 35112 00005BBE 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 35113 00005BC2 50                      	push	ax				;;AN000;; Put it on the stack
 35114 00005BC3 F8                      	clc					;;AN000;; Clear the carry
 35115                                  $MIF318:
 35116 00005BC4 EB0D                    	jmp	short $MEN317
 35117                                  $MIF317:
 35118                                  $MDO321:
 35119 00005BC6 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35120 00005BC9 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 35121 00005BCB 7404                    	jz	short $MEN321			;;AN000;; Yes
 35122 00005BCD 47                      	inc	di				;;AN000;; Next character
 35123 00005BCE 41                      	inc	cx				;;AN000;; Increment the count
 35124 00005BCF EBF5                    	jmp	short $MDO321
 35125                                  $MEN321:
 35126 00005BD1 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 35127                                  $MEN317:
 35128 00005BD3 55                      	push	bp				;;AN000;; Restore return address
 35129 00005BD4 C3                      	retn					;;AN000;;	
 35130                                  
 35131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35132                                  ;;
 35133                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 35134                                  ;;
 35135                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 35136                                  ;;		  and prepare to display
 35137                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35138                                  ;;		ES:DI contains the VALUE from SUBLIST
 35139                                  ;;	OUTPUTS: CX contains number of characters on stack
 35140                                  ;;		 Top of stack  --> Last character
 35141                                  ;;					. . .
 35142                                  ;;		 Bot of stack  --> First character
 35143                                  ;;	OTHER REGS Revised: BX,DX,AX
 35144                                  ;;
 35145                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35146                                  
 35147                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35148                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35149                                  $M_BIN2ASC_REPLACE:
 35150 00005BD5 5D                      	pop	bp				;;AN000;; Save return address
 35151 00005BD6 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35152 00005BD8 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 35153 00005BDA C706[589A]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 35154                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 35155                                  
 35156 00005BE0 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 35157                                  
 35158                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 35159 00005BE2 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35160                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 35161 00005BE6 7511                    	jnz	short $MIF325			;;AN000;; No
 35162                                  	
 35163 00005BE8 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 35164                                  
 35165                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35166 00005BEB F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35167                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 35168 00005BEF 753D                    	jnz	short $MIF326			;;AN000;; No
 35169                                  			 
 35170 00005BF1 A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 35171 00005BF3 7433                    	jz	short $MIF327			;;AN000;; No
 35172                                  						;;AN000;; Yes				
 35173                                  	; 12/04/2023
 35174                                  	;inc	bx				;;AN000;; Remember that it was negative
 35175 00005BF5 247F                    	and	al,01111111b			;;AN000;; Make it positive
 35176                                  
 35177                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 35178                                  	;jmp	short $MIF327
 35179 00005BF7 EB2E                    	jmp	short $MIF350 ; inc bx
 35180                                  
 35181                                  ; 12/04/2023
 35182                                  %if 0
 35183                                  
 35184                                  $MIF327:
 35185                                  $MIF335:	; 12/04/2023
 35186                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35187                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35188                                  $MIF326:
 35189                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35190                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35191                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35192                                  	jnz	short $MIF330			;;AN000;; No
 35193                                  						;;AN000;; Yes
 35194                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35195                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35196                                  $MIF330:
 35197                                  	jmp	short $MEN325
 35198                                  
 35199                                  %endif
 35200                                  
 35201                                  $MIF325:
 35202                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 35203 00005BF9 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35204                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 35205 00005BFD 7513                    	jnz	short $MIF333			;;AN000;; No
 35206                                  						;;AN000;; Yes
 35207 00005BFF 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 35208                                  
 35209                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35210 00005C02 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35211                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35212 00005C06 7526                    	jnz	short $MIF334			;;AN000;; No
 35213                                  						;;AN000;; Yes
 35214 00005C08 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 35215 00005C0B 741B                    	jz	short $MIF335			;;AN000;; No
 35216                                  						;;AN000;; Yes
 35217                                  	; 12/04/2023
 35218                                  	;inc	bx				;;AN000;; Remember that it was negative
 35219 00005C0D 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 35220                                  
 35221                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35222                                  	;jmp	short $MIF335
 35223 00005C10 EB15                    	jmp	short $MIF350 ; inc bx
 35224                                  
 35225                                  ; 12/04/2023
 35226                                  %if 0
 35227                                  
 35228                                  $MIF335:
 35229                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35230                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35231                                  $MIF334:
 35232                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 35233                                  	jnz	short $MIF338
 35234                                  
 35235                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35236                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35237                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35238                                  	jnz	short $MIF338			;;AN000;; No
 35239                                  						;;AN000;; Yes
 35240                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35241                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35242                                  $MIF338:
 35243                                  	jmp	short $MEN333			;;AN000;;
 35244                                  %endif
 35245                                  
 35246                                  $MIF333:
 35247 00005C12 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35248 00005C15 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35249                                  
 35250                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35251 00005C19 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35252                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35253 00005C1D 750F                    	jnz	short $MIF341			;;AN000;; No
 35254                                  						;;AN000;; Yes
 35255 00005C1F F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35256 00005C22 7404                    	jz	short $MIF342			;;AN000;; No
 35257                                  						;;AN000;; Yes
 35258                                  	; 12/04/2023
 35259                                  	;inc	bx				;;AN000;; Remember that it was negative
 35260 00005C24 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35261                                  	
 35262                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35263                                  $MIF350:
 35264 00005C27 43                      	inc	bx
 35265                                  $MIF342:
 35266                                  	; 12/04/2023
 35267                                  $MIF327:
 35268                                  $MIF335:
 35269 00005C28 C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35270                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35271                                  $MIF341:
 35272                                  $MIF326:
 35273                                  	; 18/04/2023
 35274                                  $MIF334:
 35275                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35276 00005C2E F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35277                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35278 00005C32 7506                    	jnz	short $MIF345			;;AN000;; No
 35279                                  						;;AN000;; Yes
 35280 00005C34 C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35281                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35282                                  
 35283                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35284                                  	; ****************************************
 35285                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5F64h
 35286                                  $MIF345:
 35287                                  	; *** (Disassembled MSDOS 6.22 COMMAND.COM source code.)
 35288                                  $MEN333:
 35289 00005C3A F6440740                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],40h
 35290                                  	;test	byte [si+7],40h		; MSDOS 6.22
 35291                                  				; (Custom/International flag for thousand separator)
 35292 00005C3E 7428                    	jz	short $MEN325
 35293 00005C40 50                      	push	ax			; MSDOS 6.22
 35294 00005C41 52                      	push	dx
 35295 00005C42 B438                    	mov	ah,38h	 ; International
 35296 00005C44 30C0                    	xor	al,al
 35297 00005C46 8D16[5A9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35298 00005C4A CD21                    	int	21h		; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 35299                                  				; get current-country info
 35300                                  				; DS:DX -> buffer for returned info
 35301 00005C4C 7305                    	jnb	short $MEN341		; (use country depended thousand separator)
 35302 00005C4E C606[619A]2C            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA],','
 35303                                  $MEN341:
 35304 00005C53 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35305                                  	;mov	al,[si+0Ah]		; (save pad character)
 35306 00005C56 89C7                    	mov	di,ax
 35307 00005C58 5A                      	pop	dx
 35308 00005C59 58                      	pop	ax
 35309 00005C5A C6440A2C                	mov	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','  ; $M_COMMA
 35310                                  	;mov	byte [si+0Ah],','	; (comma is needed for converting procedure)
 35311 00005C5E E80AFD                  	call	$M_CONVERT2ASC
 35312 00005C61 89F8                    	mov	ax,di
 35313 00005C63 88440A                  	mov	[si+$M_SUBLIST_STRUC.$M_S_PAD],al
 35314                                  	;mov	[si+0Ah],al		; (restore pad character)
 35315 00005C66 EB03                    	jmp	short $MEN345		; MSDOS 6.22
 35316                                  	; *** (end of disassembled MSDOS 6.22 COMMAND.COM source code porehion) 
 35317                                  	; ****************************************
 35318                                  ;$MIF345:
 35319                                  ;$MEN333:
 35320                                  $MEN325:
 35321 00005C68 E800FD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35322                                  $MEN345: 	; 15/06/2023 - MSDOS 6.22
 35323 00005C6B 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35324 00005C6D 7405                    	jz	short $MIF349			;;AN000;; No
 35325                                  						;;AN000;; Yes
 35326 00005C6F 31D2                    	xor	dx,dx				;;AN000;;
 35327 00005C71 B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35328 00005C73 52                      	push	dx				;;AN000;;
 35329                                  $MIF349:
 35330 00005C74 55                      	push	bp				;;AN000;; Restore return address
 35331 00005C75 C3                      	retn					;;AN000;; Return
 35332                                  
 35333                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35334                                  ;;
 35335                                  ;;	PROC NAME: $M_DATE_REPLACE
 35336                                  ;;
 35337                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35338                                  ;;		  country format and prepare to display
 35339                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35340                                  ;;		ES:DI points at VALUE from SUBLIST
 35341                                  ;;	OUTPUTS: CX contains number of characters on stack
 35342                                  ;;		 Top of stack  --> Last character
 35343                                  ;;					. . .
 35344                                  ;;		 Bot of stack  --> First character
 35345                                  ;;	OTHER REGS Revised: DX,AX
 35346                                  ;;
 35347                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35348                                  
 35349                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35350                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35351                                  $M_DATE_REPLACE:
 35352 00005C76 5D                      	pop	bp				;;AN000;; Save return address
 35353                                  
 35354 00005C77 C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35355                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35356                                  	
 35357 00005C7D E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35358                                  						;;AN000;; All O.K.?
 35359 00005C80 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35360                                  	; 12/04/2023
 35361                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35362                                  	
 35363                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35364                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35365                                  	;jne	short $MIF351
 35366                                  	; 12/04/2023
 35367 00005C82 A1[5A9A]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35368 00005C85 09C0                    	or	ax,ax
 35369 00005C87 751D                    	jnz	short $MIF351
 35370                                  
 35371 00005C89 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35372 00005C8C E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35373                                  
 35374 00005C8F FF36[659A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35375                                  	;push	word [$M_RT+87]			;;AN000;;
 35376                                  	
 35377 00005C93 41                      	inc	cx				;;AN000;; Increment count
 35378 00005C94 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35379                                  
 35380 00005C96 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35381                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35382 00005C99 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35383                                  	
 35384 00005C9C FF36[659A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35385                                  	;push	word [$M_RT+87]			;;AN000;;
 35386                                  
 35387 00005CA0 41                      	inc	cx				;;AN000;; Increment count
 35388 00005CA1 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35389                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35390                                  	; 12/04/2023
 35391                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35392 00005CA4 EB3C                    	jmp	short $MIF354 ; **
 35393                                  $MIF351:
 35394                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35395                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35396                                  	;jne	short $MIF353
 35397                                  	; 12/04/2023
 35398                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35399 00005CA6 48                      	dec	ax 
 35400 00005CA7 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35401                                  
 35402 00005CA9 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35403 00005CAC E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35404                                  
 35405 00005CAF FF36[659A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35406                                  	;push	word [$M_RT+87]			;;AN000;;
 35407                                  	
 35408 00005CB3 41                      	inc	cx				;;AN000;; Increment count
 35409 00005CB4 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35410                                  
 35411 00005CB6 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35412                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35413 00005CB9 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35414                                  
 35415 00005CBC FF36[659A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35416                                  	;push	word [$M_RT+87]			;;AN000;;
 35417                                  
 35418 00005CC0 41                      	inc	cx				;;AN000;;
 35419                                  	      
 35420 00005CC1 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35421                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35422                                  
 35423                                  	; 12/04/2023
 35424                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35425 00005CC4 EB1C                    	jmp	short $MIF354 ; **
 35426                                  	; 12/04/2023
 35427                                  $MIF352:
 35428                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35429 00005CC6 48                      	dec	ax
 35430                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35431                                  	;xor	ax,ax
 35432                                  	;jmp	short $MIF355
 35433                                  	; 12/04/2023
 35434 00005CC7 751C                    	jnz	short $MIF355
 35435                                  $MIF353:
 35436                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35437                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35438                                  	;jne	short $MIF355
 35439                                  
 35440 00005CC9 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35441                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35442 00005CCC E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35443                                  	
 35444 00005CCF FF36[659A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35445                                  	;push	word [$M_RT+87]			;;AN000;;
 35446                                  
 35447 00005CD3 41                      	inc	cx				;;AN000;;
 35448                                  
 35449 00005CD4 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35450                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35451 00005CD7 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35452                                  	
 35453 00005CDA FF36[659A]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35454                                  	;push	word [$M_RT+87]			;;AN000;;
 35455                                  	
 35456 00005CDE 41                      	inc	cx				;;AN000;;
 35457                                  
 35458 00005CDF E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35459                                  	; 12/04/2023
 35460                                  $MIF354:
 35461 00005CE2 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35462                                  $MIF355:
 35463 00005CE5 55                      	push	bp				;;AN000;; Restore return address
 35464 00005CE6 C3                      	retn					;;AN000;; Return
 35465                                  
 35466                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35467                                  ;;
 35468                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35469                                  
 35470                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35471                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35472                                  $M_GET_DATE:
 35473                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35474                                  	;mov	al,0 				;;AN000;; Get current country info
 35475                                  	; 12/04/2023
 35476 00005CE7 B80038                  	mov	ax,3800h
 35477                                  	;
 35478 00005CEA 8D16[5A9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35479                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35480 00005CEE CD21                    	int	21h				;;AN000;;
 35481 00005CF0 730B                    	jnc	short $MIF357
 35482                                  	;
 35483 00005CF2 C706[5A9A]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35484                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35485 00005CF8 C606[659A]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35486                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35487                                  $MIF357:
 35488 00005CFD C3                      	retn					;;AN000;;
 35489                                  
 35490                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35491                                  ;;
 35492                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35493                                  
 35494                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35495                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35496                                  $M_YEAR:
 35497 00005CFE 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35498                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35499                                  
 35500                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35501 00005D01 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35502                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35503 00005D05 7508                    	jnz	short $MIF359			;;AN000;; No
 35504                                  						;;AN000;; Yes
 35505 00005D07 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35506 00005D0A 7603                    	jna	short $MIF360			;;AN000;;
 35507 00005D0C B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35508                                  $MIF360:
 35509                                  $MIF359:
 35510 00005D0F C3                      	retn					;;AN000;;
 35511                                  
 35512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35513                                  ;;
 35514                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35515                                  
 35516                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35517                                  $M_CONVERTDATE:
 35518                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35519 00005D10 8F06[5A9A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35520                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35521 00005D14 880E[509A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35522                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35523 00005D18 E850FC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35524 00005D1B 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35525 00005D1C 3A0E[509A]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35526 00005D20 7505                    	jne	short $MIF363			;;AN000;; No
 35527 00005D22 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35528 00005D25 50                      	push	ax				;;AN000;; Save it
 35529 00005D26 41                      	inc	cx				;;AN000;; Count it
 35530                                  $MIF363:
 35531 00005D27 41                      	inc	cx				;;AN000;; Restore CX
 35532 00005D28 FF36[5A9A]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35533                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35534 00005D2C C3                      	retn
 35535                                  
 35536                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35537                                  ;;
 35538                                  ;;	PROC NAME: $M_TIME_REPLACE
 35539                                  ;;
 35540                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35541                                  ;;		  and prepare to display
 35542                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35543                                  ;;		ES:DI points at VALUE from SUBLIST
 35544                                  ;;	OUTPUTS: CX contains number of characters on stack
 35545                                  ;;		 Top of stack  --> Last character
 35546                                  ;;					. . .
 35547                                  ;;		 Bot of stack  --> First character
 35548                                  ;;	REGS USED: BP,CX,AX
 35549                                  ;;
 35550                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35551                                  
 35552                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35553                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM							     ;;
 35554                                  $M_TIME_REPLACE:
 35555 00005D2D 5D                      	pop	bp				;;AN000;; Save return address
 35556                                  
 35557 00005D2E C706[589A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35558                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35559                                  
 35560 00005D34 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35561                                  
 35562                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35563 00005D37 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35564                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35565 00005D3B 741A                    	jz	short $MIF365			;;AN000;; No
 35566                                  						;;AN000;; Yes
 35567 00005D3D 803E[6B9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35568                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35569 00005D42 7513                    	jne	short $MIF366			;;AN000;; No
 35570                                  						;;AN000;; Yes
 35571 00005D44 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35572                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35573 00005D47 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35574 00005D49 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35575 00005D4B 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35576 00005D4D 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35577                                  $MLL367:
 35578 00005D4F B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35579                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35580                                  	;inc	cx				;;AN000;;
 35581                                  	;jmp	short $MEN367			;;AN000;;
 35582                                  	; 12/04/2023
 35583 00005D51 EB02                    	jmp	short $MEN367 ; *
 35584                                  $MIF367:
 35585 00005D53 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35586                                  $MEN367:	; * ; 12/04/2023
 35587 00005D55 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35588 00005D56 41                      	inc	cx				;;AN000;;
 35589                                  ;$MEN367:
 35590                                  $MIF366:
 35591                                  $MIF365:					;;AN000;;
 35592 00005D57 31C0                    	xor	ax,ax				;;AN000;;
 35593 00005D59 31D2                    	xor	dx,dx				;;AN000;;
 35594                                  	
 35595                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35596 00005D5B F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35597                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35598 00005D5F 740B                    	jz	short $MIF372			;;AN000;;
 35599                                  
 35600 00005D61 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35601                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35602 00005D64 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 35603                                  
 35604 00005D67 FF36[639A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35605                                  	;push	word [$M_RT+85]			;;AN000;;
 35606 00005D6B 41                      	inc	cx				;;AN000;;
 35607                                  $MIF372:
 35608                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35609 00005D6C F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35610                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35611 00005D70 7506                    	jnz	short $MLL374			;;AN000;; No
 35612                                  
 35613                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35614 00005D72 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35615                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35616 00005D76 740B                    	jz	short $MIF374			;;AN000;; No
 35617                                  $MLL374:
 35618 00005D78 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35619                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35620 00005D7B E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 35621                                  
 35622 00005D7E FF36[679A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35623                                  	;push	word [$M_RT+89]			;;AN000;;
 35624 00005D82 41                      	inc	cx				;;AN000;;
 35625                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35626 00005D83 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35627                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35628 00005D86 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 35629                                  
 35630 00005D89 FF36[679A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35631                                  	;push	word [$M_RT+89]			;;AN000;;
 35632 00005D8D 41                      	inc	cx				;;AN000;;
 35633                                  
 35634 00005D8E 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35635                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35636                                  
 35637                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35638 00005D91 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35639                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35640 00005D95 7413                    	jz	short $MIF376			;;AN000;; No
 35641                                  
 35642 00005D97 803E[6B9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35643                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35644 00005D9C 750C                    	jne	short $MIF377			;;AN000;; No
 35645                                  
 35646 00005D9E 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35647 00005DA0 7C02                    	jnge	short $MIF378 ; jl
 35648 00005DA2 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35649                                  $MIF378:
 35650                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35651                                  	;jne	short $MIF380			;;AN000;; No
 35652                                  	; 12/04/2023
 35653 00005DA4 20C0                    	and	al,al
 35654 00005DA6 7502                    	jnz	short $MIF380	
 35655 00005DA8 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35656                                  $MIF380:
 35657                                  $MIF377:
 35658                                  $MIF376:
 35659 00005DAA E8BEFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35660 00005DAD 55                      	push	bp				;;AN000;; Restore return address
 35661 00005DAE C3                      	retn					;;AN000;; Return
 35662                                  
 35663                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35664                                  ;;
 35665                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35666                                  
 35667                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35668                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35669                                  $M_GET_TIME:
 35670                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35671                                  	;mov	al,0 				;;AN000;; Get current country info
 35672                                  	; 12/04/2023
 35673 00005DAF B80038                  	mov	ax,3800h
 35674                                  	;
 35675 00005DB2 8D16[5A9A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35676                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35677 00005DB6 CD21                    	int	21h				;;AN000;;
 35678 00005DB8 7310                    	jnc	short $MIF384
 35679                                  
 35680 00005DBA C706[6B9A]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35681                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35682 00005DC0 C606[679A]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35683                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35684 00005DC5 C606[639A]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35685                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35686                                  $MIF384:
 35687 00005DCA C3                      	retn					;;AN000;;
 35688                                  
 35689                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35690                                  ;;
 35691                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35692                                  
 35693                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35694                                  
 35695                                  ; 12/04/2023 
 35696                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35697                                  %if 0
 35698                                  $M_CONVERTTIME:
 35699                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35700                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35701                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35702                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35703                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35704                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35705                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35706                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35707                                  	jne	short $MIF386			;;AN000;; No
 35708                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35709                                  	push	ax				;;AN000;; Save it
 35710                                  	inc	cx				;;AN000;; Count itount it
 35711                                  $MIF386:
 35712                                  	inc	cx				;;AN000;; Restore CX
 35713                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35714                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35715                                  	retn
 35716                                  %endif
 35717                                  
 35718                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35719                                  ;;
 35720                                  ;;	PROC NAME: $M_WAIT_FOR_INPUT
 35721                                  ;;
 35722                                  ;;	FUNCTION:  To accept keyed input and return extended key value
 35723                                  ;;		   in AX register
 35724                                  ;;	INPUTS:    DL contains the DOS function requested for input
 35725                                  ;;	OUTPUTS:   AX contains the extended key value that was read
 35726                                  ;;	REGS USED:
 35727                                  ;;
 35728                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35729                                  
 35730                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35731                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6123h
 35732                                  $M_WAIT_FOR_INPUT:
 35733 00005DCB 51                      	push	cx				;;AN000;; Save CX
 35734 00005DCC 52                      	push	dx				;;AN000;; Save DX
 35735 00005DCD 1E                      	push	ds				;;AN000;; Save Data segment
 35736                                  
 35737 00005DCE 80FAC0                  	cmp	dl,0C0h ; DOS_CLR_KEYB_BUF_MASK	;;AN001;; Are we to clear the keyboard buffer?
 35738 00005DD1 7608                    	jna	short $MIF388	; jbe		;;AN001;; No,
 35739                                  						;;AN001;; Yes,
 35740 00005DD3 88D0                    	mov	al,dl				;;AN001;; Mov function into AL
 35741 00005DD5 240F                    	and	al,0Fh	; LOW_NIB_MASK		;;AN001;; Mask out the C in high nibble
 35742 00005DD7 B40C                    	mov	ah,0Ch	; DOS_CLR_KEYB_BUF 	;;AN001;; Set input function
 35743 00005DD9 EB02                    	jmp	short $MEN388
 35744                                  $MIF388:
 35745 00005DDB 88D4                    	mov	ah,dl				;;AN000;; Put DOS function in AH
 35746                                  $MEN388:
 35747 00005DDD 06                      	push	es				;;AN000;; Get output buffer segment
 35748 00005DDE 1F                      	pop	ds				;;AN000;;
 35749 00005DDF 89FA                    	mov	dx,di				;;AN000;; Get output buffer offset in case needed
 35750 00005DE1 CD21                    	int	21h				;;AN000;; Get keyboard input
 35751 00005DE3 1F                      	pop	ds				;;AN000;;
 35752 00005DE4 80FA0A                  	cmp	dl,0Ah	; DOS_BUF_KEYB_INP	;;AN000;;
 35753                                  	;clc					;;AN000;;
 35754 00005DE7 7412                    	je	short $MIF391
 35755 00005DE9 E85BFB                  	call	$M_IS_IT_DBCS			;;AN000;; Is this character DBCS?
 35756 00005DEC 730B                    	jnc	short $MIF392
 35757 00005DEE 88C1                    	mov	cl,al				;;AN000;; Save first character
 35758 00005DF0 88D4                    	mov	ah,dl				;;AN001;; Get back function
 35759 00005DF2 CD21                    	int	21h				;;AN000;; Get keyboard input
 35760 00005DF4 88CC                    	mov	ah,cl				;;AN000;; Retreive first character  AX = xxxx
 35761 00005DF6 F8                      	clc					;;AN000;; Clear carry condition
 35762 00005DF7 EB02                    	jmp	short $MEN392
 35763                                  $MIF392:
 35764 00005DF9 B400                    	mov	ah,0				;;AN000;; AX = 00xx where xx is SBCS
 35765                                  $MEN392:
 35766                                  $MIF391:
 35767                                  	;jc	short $MIF396 ; 15/06/2023
 35768 00005DFB 5A                      	pop	dx				;;AN000;;
 35769 00005DFC 59                      	pop	cx				;;AN000;;
 35770                                  	;jmp	short $MEN396
 35771 00005DFD C3                      	retn
 35772                                  
 35773                                  	; 15/06/2023
 35774                                  ;$MIF396:
 35775                                  	;add	sp,4				;;AN000;;
 35776                                  	;stc					;;AN000;; Reset carry flag
 35777                                  ;$MEN396:
 35778                                  	;retn					;;AN000;; Return
 35779                                  
 35780                                  ; ----------------------------
 35781                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35782                                  ; ----------------------------
 35783                                  ; include msgdcl.inc
 35784                                  ; ----------------------------
 35785                                  
 35786                                  ;============================================================================
 35787                                  ; HIGHLOAD.INC, MSDOS 6.0, 1992
 35788                                  ;============================================================================
 35789                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35790                                  
 35791                                  ;****************************************************************************
 35792                                  ;
 35793                                  ; This file contains routines needed to parse and implement user-given
 35794                                  ; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
 35795                                  ; and Parsevar() are used to parse this data and place it in encoded form into
 35796                                  ; the variables in highvar.inc, for use by the rest of the routines.
 35797                                  ;
 35798                                  ; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
 35799                                  ;    DEVICEHIGH SIZE=hhhhhh module opts
 35800                                  ; Or, DeviceHigh and LoadHigh accept any of the following:
 35801                                  ;    DH/LH module opts
 35802                                  ;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
 35803                                  ;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
 35804                                  ; The initial UMB,SIZE pair designates the module's load address; the remainder
 35805                                  ; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
 35806                                  ; available during the load.
 35807                                  ;
 35808                                  ; When an actual load is ready to be performed, a call to HideUMBs() will
 35809                                  ; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
 35810                                  ; upper-memory block which was not specified by the user... in addition, if
 35811                                  ; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
 35812                                  ; elements in that umb SAVE the lower-half of the newly-shrunken one are also
 35813                                  ; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
 35814                                  ; free any UMBs so allocated.
 35815                                  ;
 35816                                  ; When a device driver loads, there is the additional problem of allocating its
 35817                                  ; initial load site; this should be restricted to the first UMB specified on
 35818                                  ; the command-line.  The function FreezeUM temporarily allocates all remaining
 35819                                  ; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
 35820                                  ; UMB.  Then the initial allocation may be made, and a call to UnFreeze will
 35821                                  ; return any so-allocated memory elements to FREE, for the true load.  Note
 35822                                  ; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
 35823                                  ;
 35824                                  ;****************************************************************************
 35825                                  
 35826                                  ;___PROCEDURES_______________________________________________________________
 35827                                  ;
 35828                                  ;   AddrToUmb   - converts a segment address in AX to its appropriate UMB #
 35829                                  ;   BigFree     - makes ES:0 point to the largest free MCB in UMB given as AL
 35830                                  ;   FixMem      - scans the UM chain and concatenates adjacent free MCBs
 35831                                  ;   FreezeUM    - Marks FROZEN all UM elements now FREE, save those in load UMB
 35832                                  ;   GetLoadSize - Returns the load UMB minimum size (0 if not specified)
 35833                                  ;   GetLoadUMB  - Returns the load UMB number in AL (-1 if not specified)
 35834                                  ;   GetSize     - Returns the UMB in AL's minimum size (0 if not specified)
 35835                                  ;   GetXNum     - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 35836                                  ;   HideUMBs    - links UMBs and hides upper-memory as appropriate
 35837                                  ;   InitVar     - initializes all the variables used in ParseVar and HideUMBs
 35838                                  ;   NextMCB     - moves an MCB pointer forward to the next MCB
 35839                                  ;   ParseVar    - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 35840                                  ;   PrTable     - produces a printout of the variables in highvar.inc
 35841                                  ;   StoLoadSize - Overrides the load UMB minimum size with what's in AX
 35842                                  ;   StoLoadUMB  - Overrides the load UMB number with what's in AL
 35843                                  ;   UmbHead     - returns in AX the address of the first UMB block (0x9FFF)
 35844                                  ;   UnFreeze    - Marks FROZEN elements as FREE
 35845                                  ;
 35846                                  ;___VARIABLES________________________________________________________________
 35847                                  ;
 35848                                  ;   gnradix     - After a call to GetXNum, is 16 or 10, depending on the # read
 35849                                  ;
 35850                                  ;   Internal:
 35851                                  ;___PROCEDURES_______________________________________________________________
 35852                                  ;
 35853                                  ;   convUMB     - checks after GetXNum to convert an address to a UMB number
 35854                                  ;   findUMB     - makes ES:0 point to the first MCB in UMB given as AL
 35855                                  ;   fm_link     - links UMBs not already linked in
 35856                                  ;   fm_unlink   - unlinks UMBs if fm_umb is set to 0
 35857                                  ;   frezMCB     - marks as 8+FROZEN the MCB at ES:0
 35858                                  ;   hideMCB     - marks as HIDDEN the MCB at ES:0
 35859                                  ;   hideUMB     - marks as HIDDEN all FREE elements in UMB passed as AL
 35860                                  ;   hideUMB?    - hides as appropriate the UMB in CL
 35861                                  ;   hl_unlink   - unlinks UMBs if fm_umb is set to 0; restores strategy too
 35862                                  ;   incArgc     - increments fm_argc, for use with LH command-line parsing
 35863                                  ;   isEOL       - returns with ZF set iff AL contains CR or LF, or 0
 35864                                  ;   isFreeMCB   - returns with ZF set if current MCB (ES:0) is FREE
 35865                                  ;   isFrozMCB   - returns with ZF set if current MCB (ES:0) is FROZEN
 35866                                  ;   isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 35867                                  ;   isSysMCB    - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 35868                                  ;   isTiny      - returns with ZF set if user didn't specify /S
 35869                                  ;   isWhite     - returns with ZF set iff AL contains whitespace (or "=")
 35870                                  ;   loadLow     - returns AL==0 if UMB0 == 0, else AL==1
 35871                                  ;   mul32       - multiplies the number in DX:AX by gnradix
 35872                                  ;   parseL      - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 35873                                  ;   setUMBs     - links umbs and sets allocation strategy for a load
 35874                                  ;   shrinkMCB   - breaks an MCB into two pieces, the lowest one's size==AX
 35875                                  ;   stowSiz     - marks a given UMB as having a given minimum size
 35876                                  ;   stowUMB     - marks a given UMB as used, if it hasn't been so marked before
 35877                                  ;   toDigit     - converts a character-digit to its binary counterpart
 35878                                  ;   toPara      - divides DX:AX by 16; result in AX only
 35879                                  ;   toUpper     - accepts one argument (probly a register), and upper-cases it.
 35880                                  ;   unHideMCB   - marks as FREE the MCB at ES:0
 35881                                  ;   unMarkUMB   - marks a given UMB as unused, even if previously marked used
 35882                                  ;
 35883                                  ;****************************************************************************
 35884                                  
 35885                                  ;DOS_CHECK_STRATEGY equ 5800h ; Int 21h, Func 58h, Svc 0 = check alloc strat
 35886                                  ;DOS_SET_STRATEGY   equ 5801h ; Int 21h, Func 58h, Svc 1 = set alloc strategy
 35887                                  ;DOS_CHECK_UMBLINK  equ 5802h ; Int 21h, Func 58h, Svc 2 = check link state
 35888                                  ;DOS_SET_UMBLINK    equ 5803h ; Int 21h, Func 58h, Svc 3 = set link state
 35889                                  ;DOS_GET_DOS_LISTS  equ   52h ; Int 21h, Func 52h = return list of lists
 35890                                  ;DOS_UMB_HEAD       equ   8Ch ; Offset from ES (after func52h) to get UMBHead
 35891                                  
 35892                                  ; -----------------------------------------------------------------------------
 35893                                  ;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
 35894                                  ; -----------------------------------------------------------------------------
 35895                                  ; ENTRY:       None
 35896                                  ; EXIT:        Variables listed in highvar.inc are initialized
 35897                                  ; ERROR EXIT:  None
 35898                                  ; USES:        Flags, variables in highvar.inc
 35899                                  ; -----------------------------------------------------------------------------
 35900                                  ; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
 35901                                  ; are largely ignored, but it is initialized nonetheless.
 35902                                  ; -----------------------------------------------------------------------------
 35903                                  
 35904                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 35905                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:615Fh
 35906                                  InitVar:	; proc	near
 35907                                  	;push	ax
 35908                                  	;push	cx
 35909                                  	;push	di
 35910 00005DFE 06                      	push	es ; * es = ds
 35911 00005DFF 8E06[E49D]              	mov	es,[RESSEG]		;Point ES into appropriate data segment
 35912 00005E03 31C0                    	xor	ax,ax
 35913                                  	;mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
 35914                                  	;mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
 35915 00005E05 26A3[F604]              	mov	[es:fInHigh],ax ; 16/06/2023
 35916 00005E09 26A3[F804]              	mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
 35917 00005E0D 26C606[FA04]FF          	mov	byte [es:UmbLoad],0FFh ;UNSPECIFIED
 35918                                  					;Later is the # of the 1st spec'd UMB
 35919 00005E13 26A2[2D05]              	mov	[es:fm_argc],al		;Start with zero args having been read
 35920                                  
 35921 00005E17 FC                      	cld
 35922                                  
 35923 00005E18 B91000                  	mov	cx,16 ; MAXUMB		;For each entry
 35924 00005E1B BF[FB04]                	mov	di,UmbUsed		;on the UmbUsed array,
 35925 00005E1E F3AA                    	rep	stosb			;	Store 0
 35926                                  
 35927                                  	;mov	cx,16 ; MAXUMB		;Okay... for each entry
 35928 00005E20 B110                    	mov	cl,16
 35929 00005E22 BF[0B05]                	mov	di,UmbSize		;on the UmbSize array,
 35930 00005E25 F3AB                    	rep	stosw			;	Store 0
 35931                                  
 35932 00005E27 07                      	pop	es ; * es = ds
 35933                                  	;pop	di
 35934                                  	;pop	cx
 35935                                  	;pop	ax
 35936 00005E28 C3                       	retn
 35937                                  
 35938                                  ;InitVar endp
 35939                                  
 35940                                  ; -----------------------------------------------------------------------------
 35941                                  ;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
 35942                                  ; -----------------------------------------------------------------------------
 35943                                  ; ENTRY   : None
 35944                                  ; EXIT    : None
 35945                                  ; ERROR   : None
 35946                                  ; USES    : Flags, fm_umb, fm_strat
 35947                                  ; -----------------------------------------------------------------------------
 35948                                  
 35949                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 35950                                  FixMem:
 35951                                  	;push	ax
 35952                                  	;push	bx
 35953                                  	;push	cx
 35954                                  	;push	dx
 35955 00005E29 06                      	push	es
 35956                                  
 35957 00005E2A E84900                  	call	fm_link			; Link in UMBs
 35958                                  
 35959 00005E2D E82302                  	call	UmbHead			; Get first upper-memory MCB address (0x9FFF)
 35960 00005E30 723F                    	jc	short fmX		; (if couldn't get it, leave now).
 35961                                  
 35962 00005E32 8EC0                    	mov	es,ax			; It returns in AX, so move it to ES.
 35963                                  
 35964                                  ; - Walk MCB Chain ------------------------------------------------------------
 35965                                  
 35966 00005E34 31D2                    	xor	dx,dx			; We're keeping the address of the last MCB
 35967 00005E36 89D1                    	mov 	cx,dx			; in CX... and the last owner
 35968 00005E38 42                      	inc	dx			; in dx as we go through the loop:
 35969                                  
 35970                                  ; ------------------------------------------
 35971                                  ; FM10--DX  = last MCB's owner's PSP address
 35972                                  ;       CX  = last MCB's address (segment)
 35973                                  ; ------------------------------------------
 35974                                  
 35975                                  fm10:	
 35976 00005E39 26A00000                	mov	al,[es:arena_signature]	; if 'Z', don't repeat loop
 35977                                  	;mov	al,[es:0]
 35978 00005E3D 268B1E0100              	mov	bx,[es:arena_owner]	; if not zero, do nothing
 35979                                  	;mov	bx,[es:1]
 35980 00005E42 09D3                    	or	bx,dx			; dx was owner of previous MCB
 35981 00005E44 7516                    	jnz	short fm30		; If not both zero, don't cat.
 35982                                  
 35983                                  ; - Coalesce memory blocks at ES:00 and CX:00 ---------------------------------
 35984                                  
 35985                                  fm20:	
 35986 00005E46 268B1E0300              	mov	bx,[es:arena_size]	; Grab this block's Size,
 35987                                  	;mov	bx,[es:3]
 35988 00005E4B 8EC1                    	mov	es,cx			; Go back to prev MCB's address
 35989 00005E4D 26A20000                	mov	[es:arena_signature], al ; & move the SECOND sig here
 35990                                  	;mov	[es:0],al
 35991                                  
 35992 00005E51 26031E0300              	add	bx,[es:arena_size]	; Size += first MCB's size
 35993                                  	;add	bx,1			; And add one for the header
 35994 00005E56 43                      	inc	bx
 35995 00005E57 26891E0300              	mov	[es:arena_size],bx	; Write the size
 35996                                  
 35997                                  	; ---------------------------------------------------------------------
 35998                                  fm30:	
 35999 00005E5C 8CC1                    	mov	cx,es			; Put this address on the stack
 36000 00005E5E 268B160100              	mov	dx,[es:arena_owner]	; And remember its owner
 36001                                  	;mov	dx,[es:1]
 36002                                  
 36003                                  	;NextMCB es,bx			; Move to the next MCB
 36004                                  	
 36005 00005E63 8CC3                    	mov	bx,es
 36006                                  	;add	bx,[es:3]
 36007 00005E65 26031E0300              	add	bx,[es:arena_size]
 36008 00005E6A 43                      	inc	bx
 36009 00005E6B 8EC3                    	mov	es,bx
 36010                                  
 36011                                  	;cmp	al,'Z'	; cmp al,5Ah
 36012 00005E6D 3C5A                    	cmp	al,arena_signature_end
 36013 00005E6F 75C8                    	jnz	short fm10		; If signature != 'Z', there are more.
 36014                                  fmX:	
 36015 00005E71 E81900                  	call	fm_unlink		; Unlink UMBs
 36016                                  
 36017 00005E74 07                      	pop	es
 36018                                  	;pop	dx
 36019                                  	;pop	cx
 36020                                  	;pop	bx
 36021                                  	;pop	ax
 36022 00005E75 C3                      	retn
 36023                                  
 36024                                  ; -----------------------------------------------------------------------------
 36025                                  ; 16/06/2023
 36026                                  
 36027                                  ;INT 21h - DOS 5+ - GET OR SET UMB LINK STATE
 36028                                  ; .......................................................
 36029                                  ;     AH = 58h
 36030                                  ;     AL = subfunction
 36031                                  ;	02h get UMB link state
 36032                                  ;	    Return:
 36033                                  ;		AL = current link state
 36034                                  ;		  00h - UMBs not part of DOS memory chain
 36035                                  ;		  01h - UMBs in DOS memory chain
 36036                                  ;	03h set UMB link state
 36037                                  ;	    BX = new link state
 36038                                  ;		0000h - remove UMBs from DOS memory chain
 36039                                  ;		0001h - add UMBs to DOS memory chain
 36040                                  ;
 36041                                  ;Return: CF clear if successful
 36042                                  ;	CF set on error
 36043                                  ;	AX = error code (01h) (see #01680)
 36044                                  ; .......................................................
 36045                                  
 36046                                  ; -----------------------------------------------------------------------------
 36047                                  ;*** fm_link - links UMBs not already linked in
 36048                                  ; -----------------------------------------------------------------------------
 36049                                  ; ENTRY:    None
 36050                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 36051                                  ; ERROR:    None
 36052                                  ; USES:     AX, BX, fm_umb
 36053                                  ; -----------------------------------------------------------------------------
 36054                                  
 36055                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36056                                  fm_link:
 36057 00005E76 B80258                  	mov	ax,5802h ; DOS_CHECK_UMBLINK
 36058 00005E79 CD21                    	int	21h			; Current link-state is now in al
 36059                                  
 36060                                  	;putdata fm_umb,al		; So store it in fm_umb for later
 36061                                  
 36062                                  	;push	es
 36063                                  	;mov	es,[RESSEG]
 36064                                  	;mov	[es:fm_umb],al
 36065                                  	;pop	es
 36066 00005E7B 1E                      	push	ds
 36067 00005E7C 8E1E[E49D]              	mov	ds,[RESSEG]
 36068 00005E80 A2[2B05]                	mov	[fm_umb],al
 36069 00005E83 1F                      	pop	ds
 36070                                  
 36071 00005E84 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36072 00005E87 BB0100                  	mov	bx,1
 36073 00005E8A CD21                    	int	21h
 36074 00005E8C C3                      	retn
 36075                                  
 36076                                  ; -----------------------------------------------------------------------------
 36077                                  ;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
 36078                                  ; -----------------------------------------------------------------------------
 36079                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 36080                                  ; EXIT:     None
 36081                                  ; ERROR:    None
 36082                                  ; USES:     AX, BX
 36083                                  ; -----------------------------------------------------------------------------
 36084                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36085                                  fm_unlink:
 36086 00005E8D 31DB                    	xor	bx,bx
 36087                                  	
 36088                                  	;getdata bl,fm_umb		; fm_umb already has the old link-state
 36089                                  
 36090 00005E8F 1E                      	push    ds
 36091 00005E90 8E1E[E49D]              	mov     ds,[RESSEG]
 36092 00005E94 8A1E[2B05]              	mov     bl,[fm_umb]
 36093 00005E98 1F                      	pop     ds
 36094                                  	
 36095 00005E99 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36096 00005E9C CD21                    	int	21h			; so just use that, and call int 21h
 36097 00005E9E C3                      	retn
 36098                                  
 36099                                  ; -----------------------------------------------------------------------------
 36100                                  ;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 36101                                  ; laid out in highvar.inc
 36102                                  ; -----------------------------------------------------------------------------
 36103                                  ; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
 36104                                  ; EXIT:     ES:SI points to first character in child program name
 36105                                  ; ERROR:    ES:SI points to character which caused error, carry set, AX == code
 36106                                  ; USES:     ES:SI, AX, flags, variables in highvar.inc
 36107                                  ; -----------------------------------------------------------------------------
 36108                                  ; Error codes (in AX if carry set on return):
 36109                                  ;
 36110                                  
 36111                                  ;PV_InvArg	equ	1	; Invalid argument passed
 36112                                  ;PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
 36113                                  ;PV_InvSwt	equ	3	; Unrecognized switch passed
 36114                                  
 36115                                  ;
 36116                                  ; This routine exects ES:SI to point to a string much like the following:
 36117                                  ;    "/S/L:1,200;2 module options"
 36118                                  ; Optionally, the string can begin with whitespace; neither /S nor /L is
 36119                                  ; required, though that's what this routine is supposed to parse.
 36120                                  ;
 36121                                  
 36122                                  ;optS		equ	'S'	; /S
 36123                                  ;optL		equ	'L'	; /L:...
 36124                                  
 36125                                  ;
 36126                                  ; -----------------------------------------------------------------------------
 36127                                  ; LoadHigh has a list of arguments, returned by cparse, which is used to create
 36128                                  ; a command-line for spawning a child process. For a typical LH command, say,
 36129                                  ;     lh /l:1,1000;2 print/d:lpt2
 36130                                  ; the arguments would look like (one per line):
 36131                                  ;     lh
 36132                                  ;     /l
 36133                                  ;     1
 36134                                  ;     1000
 36135                                  ;     2
 36136                                  ;     print
 36137                                  ;     /d
 36138                                  ;     :lpt2
 36139                                  ; In short, if "print" were, say, "43", there'd be no way to determine which
 36140                                  ; arg was the filename. So, inside this routine, we keep a running counter
 36141                                  ; of the number of arguments LH will need to skip in order to get to the
 36142                                  ; program name. The "lh" is implicit--it'll always have to skip that. So if
 36143                                  ; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
 36144                                  ; for:
 36145                                  ;    Each /L
 36146                                  ;    Each /S (there should be only one)
 36147                                  ;    Each UMB number (they follow ":" or ";")
 36148                                  ;    Each UMB size   (they follow ",")
 36149                                  ; So, in the above example, fm_argc would be 4-- and LH would skip right to
 36150                                  ; "print". Note that InitVar initializes fm_argc to zero.
 36151                                  ; -----------------------------------------------------------------------------
 36152                                  
 36153                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36154                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6216h
 36155                                  ParseVar:	; proc	near
 36156                                  	;push	di
 36157                                  	;push	ds ; *
 36158                                  	;push	es
 36159                                  	;
 36160                                  	; 16/06/2023
 36161                                  	; es = ds (from 'ParseLhCmd')
 36162                                  	;push	es		; Make DS:SI point to it, as well as ES:SI
 36163                                  	;pop	ds		; (regardless if we're in devhigh or loadhigh)
 36164                                  	
 36165 00005E9F FC                      	cld
 36166                                  
 36167                                  ; ------------------------------------------------
 36168                                  ; PV10--ES:SI = any whitespace on the command-line
 36169                                  ; ------------------------------------------------
 36170                                  
 36171                                  pv10:	
 36172 00005EA0 AC                      	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
 36173 00005EA1 E8A800                  	call	isWhite
 36174 00005EA4 74FA                    	jz	short pv10	;       ES:SI==" /L..."--keep eating.
 36175 00005EA6 3C2F                    	cmp	al,'/' ; SWTCH
 36176 00005EA8 7404                    	je	short pv20	;       ES:SI=="/L..."--go process a switch
 36177                                  
 36178 00005EAA 4E                      	dec	si		; Backup--it's now "odule options", and we need
 36179 00005EAB F8                      	clc			; that "m" we just read (or whatever it is).
 36180 00005EAC EB2C                    	jmp	short pvX	; Then return with carry clear == we're done.
 36181                                  pv20:
 36182 00005EAE AC                      	lodsb			; Just read 'S' or 'L', hopefully
 36183                                  
 36184                                  	;toUpper al		; So we make it upper-case, and...
 36185 00005EAF 24DF                    	and	al,0DFh
 36186                                  
 36187 00005EB1 3C53                    	cmp	al,'S' ; optS	; just read 'S'?
 36188 00005EB3 7510                    	jne	short pv30
 36189                                  
 36190 00005EB5 E87E00                  	call	incArgc		; If it's /S, it's another arg for LH to skip.
 36191                                  
 36192                                  	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
 36193                                  
 36194                                  	;push	es
 36195                                  	;mov	es,[RESSEG]
 36196                                  	;mov	byte [es:fUmbTiny],1
 36197                                  	;pop	es
 36198 00005EB8 1E                      	push	ds
 36199 00005EB9 8E1E[E49D]              	mov	ds,[RESSEG]
 36200 00005EBD C606[F704]01            	mov	byte [fUmbTiny],1
 36201 00005EC2 1F                      	pop	ds
 36202                                  
 36203 00005EC3 EBDB                    	jmp	short pv10	; possibly even "/L...".
 36204                                  pv30:	
 36205 00005EC5 3C4C                    	cmp	al,'L' ; optL	; If it's not 'L' either, then it's a bad
 36206 00005EC7 750B                    	jne	short pvE1	; switch!
 36207                                  
 36208 00005EC9 E86A00                  	call	incArgc		; If it's /L, it's another arg for LH to skip.
 36209                                  
 36210 00005ECC E80C00                  	call	parseL
 36211 00005ECF 73CF                    	jnc	short pv10	; If no carry, go back and look for more
 36212                                  
 36213 00005ED1 4E                      	dec	si		; Else, back up and exit.
 36214 00005ED2 EB03                    	jmp	short pvErr	; AX has already been set by parseL
 36215                                  pvE1:	
 36216 00005ED4 B80300                  	mov	ax,3 ; PV_InvSwt
 36217                                  				; Unrecognized switch passed
 36218                                  pvErr:
 36219 00005ED7 4E                      	dec	si
 36220 00005ED8 4E                      	dec	si
 36221 00005ED9 F9                      	stc
 36222                                  pvX:	
 36223                                  	;pop	es
 36224                                  	;pop	ds ; *
 36225                                  	;pop	di
 36226 00005EDA C3                      	retn
 36227                                  
 36228                                  ;ParseVar endp
 36229                                  
 36230                                  ; -----------------------------------------------------------------------------
 36231                                  ;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 36232                                  ; -----------------------------------------------------------------------------
 36233                                  ; ENTRY:    ES:SI points to colon
 36234                                  ; EXIT:     ES:SI points to first character not parsed
 36235                                  ; ERROR:    Carry set; rewind three characters and return (see ParseVar)
 36236                                  ; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
 36237                                  ; -----------------------------------------------------------------------------
 36238                                  ; If the string here is terminated with anything other than whitespace or a
 36239                                  ; switchchar (perhaps it's /S or another /L:... ), then we return with carry
 36240                                  ; set, indicating that they've screwed up the syntax.  The 3-character rewind
 36241                                  ; makes sure the app /L: is reported as being the culprit.
 36242                                  ; -----------------------------------------------------------------------------
 36243                                  
 36244                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36245                                  parseL:
 36246 00005EDB AC                      	lodsb
 36247 00005EDC 3C3A                    	cmp	al,':'		; Make sure they did /L:
 36248 00005EDE 754A                    	jne	short plE1	; If they didn't, return with carry set.
 36249                                  
 36250                                  ; ------------------------------------------
 36251                                  ; PL10--ES:SI = a UMB number, after /L: or ;
 36252                                  ; ------------------------------------------
 36253                                  
 36254                                  pl10:
 36255 00005EE0 E8FD00                  	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
 36256 00005EE3 724B                    	jc	short plE2	; And error if it's a bad number.
 36257 00005EE5 E8C801                  	call	convUMB		; Convert any address to a UMB number
 36258                                  
 36259 00005EE8 88C1                    	mov	cl,al	; !*	; Remember the UMB number
 36260 00005EEA E88300                  	call	stowUMB		; Mark this UMB # as used;
 36261 00005EED 7241                    	jc	short plE2	; If it was already marked, it'll error
 36262                                  
 36263 00005EEF E84400                  	call	incArgc		; Each UMB number is another arg for LH to skip
 36264                                  
 36265 00005EF2 AC                      	lodsb
 36266 00005EF3 3C3B                    	cmp	al,';'		; Did "umb;" ?
 36267 00005EF5 74E9                    	je	short pl10	; Yep: go back and get another UMB.
 36268                                  
 36269 00005EF7 E85200                  	call	isWhite		; Did "umb " ?
 36270 00005EFA 7439                    	jz	short plX	; Yep: return (it'll go back to whitespace)
 36271                                  
 36272 00005EFC E84200                  	call	isEOL		; Did "umb" ?
 36273 00005EFF 7433                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36274                                  
 36275 00005F01 3C2F                    	cmp	al,'/' ; SWTCH	; Did "umb/" ? (as in, "/L:1,100;2/S")
 36276 00005F03 742F                    	je	short plSwX	; If so, back up ES:SI one character and return
 36277                                  
 36278 00005F05 3C2C                    	cmp	al,','		; Did "umb," ?
 36279 00005F07 7521                    	jne	short plE1	; Just what the heck DID they do? Return error.
 36280                                  
 36281                                  ; --- Read a size -------------------------------------------------------------
 36282                                  
 36283 00005F09 E8D400                  	call	GetXNum		; Stop on "size;" or "size " or anything else
 36284 00005F0C 721C                    	jc	short plE1	; And error if it's a bad size.
 36285                                  
 36286 00005F0E E83401                  	call	toPara		; Convert from bytes to paragraphs
 36287                                  
 36288 00005F11 E88600                  	call	stowSiz		; CL still has the UMB number for this routine
 36289                                  
 36290 00005F14 E81F00                  	call	incArgc		; Each UMB size is another arg for LH to skip
 36291                                  
 36292 00005F17 AC                      	lodsb
 36293 00005F18 3C3B                    	cmp	al,';'		; They did "umb,size;", so get another UMB.
 36294 00005F1A 74C4                    	je	short pl10		;
 36295                                  
 36296 00005F1C E82D00                  	call	isWhite		; Did it end with whitespace?
 36297 00005F1F 7414                    	jz	short plX	; If so, we're done here--go back.
 36298                                  
 36299 00005F21 E81D00                  	call	isEOL		; Did they do "umb,size" and end??? (stupid)
 36300 00005F24 740E                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36301                                  
 36302 00005F26 3C2F                    	cmp	al,'/' ; SWTCH	; Did they do "umb,size/" ?
 36303 00005F28 740A                    	je	short plSwX	; If so, again, we're done here.
 36304                                  plE1:	
 36305 00005F2A B80100                  	mov	ax,1 ; PV_InvArg
 36306                                  				; If not, we don't know WHAT they did...
 36307 00005F2D 4E                      	dec	si
 36308 00005F2E F9                      	stc
 36309 00005F2F C3                      	retn
 36310                                  plE2:
 36311                                  	; cf = 1 
 36312 00005F30 B80200                  	mov	ax,2 ; PV_BadUMB
 36313                                  				; In this case, they've specified a UMB twice
 36314                                  	;stc
 36315 00005F33 C3                      	retn
 36316                                  plSwX:
 36317 00005F34 4E                      	dec	si		; If we hit a '/' character, back up one char
 36318                                  				; so the whitespace checker will see it too.
 36319                                  plX:
 36320                                  	; cf = 0
 36321                                  	;clc			; Then just return with carry clear, so
 36322 00005F35 C3                      	retn			; ParseVar will go about its business.
 36323                                  
 36324                                  ; -----------------------------------------------------------------------------
 36325                                  ;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
 36326                                  ; -----------------------------------------------------------------------------
 36327                                  ; ENTRY:    None
 36328                                  ; EXIT:     None
 36329                                  ; ERROR:    None
 36330                                  ; USES:     fm_argc, flags
 36331                                  ; -----------------------------------------------------------------------------
 36332                                  
 36333                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36334                                  incArgc:
 36335                                  	;push	ax
 36336                                  
 36337                                  	;;getdata al,fm_argc	; Obtain previous value of fm_argc,
 36338                                  	;
 36339                                  	;push	ds		; getdata (macro)
 36340                                  	;			; getdata al, fm_argc
 36341                                  	;mov	ds,[RESSEG]
 36342                                  	;mov	al,[fm_argc]	; Obtain previous value of fm_argc,
 36343                                  	;pop	ds
 36344                                  	;
 36345                                  	;inc	al		; Increment it,
 36346                                  	;
 36347                                  	;;putdata fm_argc,al	; And store it right back.
 36348                                  	;
 36349                                  	;push	es		; putdata (macro)
 36350                                  	;			; putdata fm_argc, al
 36351                                  	;mov	es,[RESSEG]
 36352                                  	;mov	[es:fm_argc],al	; and store it right back.
 36353                                  	;pop	es
 36354                                  
 36355                                  	; 16/06/2023
 36356 00005F36 1E                      	push	ds
 36357 00005F37 8E1E[E49D]              	mov	ds,[RESSEG]
 36358 00005F3B FE06[2D05]              	inc	byte [fm_argc]	; increment fm_argc
 36359 00005F3F 1F                      	pop	ds
 36360                                  
 36361                                  	;pop	ax
 36362 00005F40 C3                      	retn
 36363                                  
 36364                                  ; -----------------------------------------------------------------------------
 36365                                  ;*** isEOL - returns with ZF set iff AL contains CR or LF, or 0
 36366                                  ; -----------------------------------------------------------------------------
 36367                                  ; ENTRY:    AL contains character to test
 36368                                  ; EXIT:     ZF set if AL contains CR or LF, or 0
 36369                                  ; ERROR:    None
 36370                                  ; USES:     ZF
 36371                                  ; -----------------------------------------------------------------------------
 36372                                  
 36373                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36374                                  isEOL:
 36375                                  	;cmp	al,0		; Null-terminator
 36376 00005F41 20C0                    	and	al,al
 36377 00005F43 7406                    	jz	short ieX
 36378 00005F45 3C0D                    	cmp	al,0Dh ; CR	; Carriage Return
 36379 00005F47 7402                    	je	short ieX
 36380 00005F49 3C0A                    	cmp	al,0Ah ; LF	; LineFeed
 36381                                  ieX:
 36382 00005F4B C3                      	retn
 36383                                  
 36384                                  
 36385                                  ; -----------------------------------------------------------------------------
 36386                                  ;*** isWhite - returns with ZF set iff AL contains whitespace (or "=")
 36387                                  ; -----------------------------------------------------------------------------
 36388                                  ; ENTRY:    AL contains character to test
 36389                                  ; EXIT:     ZF set if AL contains space, tab, or equals
 36390                                  ; ERROR:    None
 36391                                  ; USES:     ZF
 36392                                  ; -----------------------------------------------------------------------------
 36393                                  
 36394                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36395                                  isWhite:
 36396 00005F4C 3C20                    	cmp	al,' '		; Space
 36397 00005F4E 7406                    	je	short iwX
 36398 00005F50 3C3D                    	cmp	al,'='		; Equals (treat as whitespace)
 36399 00005F52 7402                    	je	short iwX
 36400 00005F54 3C09                    	cmp	al,09h ; TAB	; Tab
 36401                                  iwX:
 36402 00005F56 C3                      	retn
 36403                                  
 36404                                  ; -----------------------------------------------------------------------------
 36405                                  ;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
 36406                                  ; -----------------------------------------------------------------------------
 36407                                  ; ENTRY:    AL contains UMB number
 36408                                  ; EXIT:     None
 36409                                  ; ERROR:    None
 36410                                  ; USES:     Flags, variables in highvar.inc
 36411                                  ; -----------------------------------------------------------------------------
 36412                                  
 36413                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36414                                  unMarkUMB:
 36415                                  	;;pushreg <ax,bx,di,es>
 36416                                  	;push	ax ; ***
 36417                                  	
 36418                                  	;push	bx ; **
 36419                                  	
 36420                                  	;push	di
 36421                                  	;push	es
 36422 00005F57 1E                      	push	ds ; *	
 36423                                  
 36424                                  	;;dataseg es
 36425                                  	;mov	es,[RESSEG]
 36426                                  
 36427 00005F58 8E1E[E49D]              	mov	ds,[RESSEG] ; *
 36428                                  	
 36429                                  	;xor	ah,ah ; 0
 36430                                  	;mov	bx,ax
 36431                                  	;mov	byte [es:bx+UmbUsed],0
 36432                                  	;mov	[bx+UmbUsed],ah ; marks the UMB as unused
 36433 00005F5C 88C3                    	mov	bl,al
 36434 00005F5E 30FF                    	xor	bh,bh ; 0	
 36435 00005F60 88BF[FB04]              	mov	[bx+UmbUsed],bh ; 0 ; **
 36436                                  
 36437                                  	;cmp	[es:UmbLoad],al
 36438                                  	;jnz	short umu10
 36439 00005F64 3806[FA04]              	cmp	[UmbLoad],al
 36440 00005F68 7504                    	jne	short umu10
 36441                                  
 36442                                  	;mov	byte [es:UmbLoad],0
 36443                                  	;mov	[UmbLoad],ah	; If unmarked the load UMB, load into convent.
 36444 00005F6A 883E[FA04]              	mov	[UmbLoad],bh ; 0 ; **
 36445                                  umu10:	
 36446 00005F6E 1F                      	pop	ds ; *
 36447                                  	;;popreg <es,di,bx,ax>
 36448                                  	;pop	es
 36449                                  	;pop	di
 36450                                  	
 36451                                  	;pop	bx ; **
 36452                                  	
 36453                                  	;pop	ax ; ***
 36454                                  
 36455                                  	;;normseg es
 36456                                  	
 36457 00005F6F C3                      	retn
 36458                                  
 36459                                  ; -----------------------------------------------------------------------------
 36460                                  ;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
 36461                                  ;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
 36462                                  ; listed in the /L:... chain.  If it's the first one specified, it sets UmbLoad
 36463                                  ; to that UMB #... and in any case, it marks the UMB as specified.
 36464                                  ; -----------------------------------------------------------------------------
 36465                                  ; ENTRY:    AL contains UMB number, as specified by the user
 36466                                  ; EXIT:     None
 36467                                  ; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
 36468                                  ; USES:     AX, Flags, variables in highvar.inc
 36469                                  ; -----------------------------------------------------------------------------
 36470                                  
 36471                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36472                                  stowUMB:
 36473 00005F70 3C10                    	cmp	al,16 ; MAXUMB
 36474 00005F72 7202                    	jb	short su10
 36475 00005F74 F9                      	stc
 36476 00005F75 C3                      	retn			; Ooops-- UMB>=MAXUMB
 36477                                  su10:
 36478                                  	;pushreg <bx,di,si,ds,es>
 36479                                  	;dataseg es		; Point ES into appropriate data segment
 36480                                  	;dataseg ds		; Point DS into appropriate data segment
 36481                                  
 36482                                  	;push	bx ; **
 36483                                  	
 36484                                  	;push	di
 36485                                  	;push	si
 36486                                  
 36487 00005F76 1E                      	push	ds ; *
 36488                                  
 36489                                  	;push	es
 36490                                  	;mov	es,[RESSEG]
 36491 00005F77 8E1E[E49D]              	mov	ds,[RESSEG]
 36492                                  
 36493 00005F7B 803E[FA04]FF            	cmp	byte [UmbLoad],0FFh ; UNSPECIFIED
 36494                                  				; If this, we haven't been here before
 36495 00005F80 7503                    	jne	short su20
 36496 00005F82 A2[FA04]                	mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
 36497                                  su20:	
 36498 00005F85 08C0                    	or	al,al		; If they gave UMB 0, there's really nothing
 36499 00005F87 740F                    	jz	short su30	; that we should do here.
 36500                                  
 36501                                  	;mov	bl,al
 36502                                  	;xor	bh,bh
 36503                                  	;mov	ax,1		; Now, AX = 1, and BX = UMB Number
 36504 00005F89 30E4                    	xor	ah,ah
 36505 00005F8B 89C3                    	mov	bx,ax
 36506 00005F8D B001                    	mov	al,1
 36507                                  
 36508                                  	;xchg	[es:bx+UmbUsed],al
 36509 00005F8F 8687[FB04]              	xchg	[bx+UmbUsed],al
 36510                                  
 36511 00005F93 08C0                    	or	al,al		; If it was already 1, then al==1... and that
 36512 00005F95 7401                    	jz	short su30	; means an error.
 36513                                  
 36514 00005F97 F9                      	stc			; OOOPS! This one's been used before. :(
 36515                                  su30:	
 36516                                  	;popreg	<es,ds,si,di,bx>
 36517                                  	;normseg ds
 36518                                  	;normseg es
 36519                                  	;retn
 36520                                  
 36521                                  	;pop	es
 36522                                  	
 36523 00005F98 1F                      	pop	ds ; *
 36524                                  	
 36525                                  	;pop	si
 36526                                  	;pop	di
 36527                                  	
 36528                                  	;pop	bx ; **
 36529                                  
 36530 00005F99 C3                      	retn
 36531                                  
 36532                                  ; -----------------------------------------------------------------------------
 36533                                  ;*** stowSiz - marks a given UMB as having a given minimum size
 36534                                  ; -----------------------------------------------------------------------------
 36535                                  ; ENTRY:    CL contains UMB number, AX contains size
 36536                                  ; EXIT:     None
 36537                                  ; ERROR:    None
 36538                                  ; USES:     AX, DX, Flags, variables in highvar.inc
 36539                                  ; -----------------------------------------------------------------------------
 36540                                  	
 36541                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36542                                  stowSiz:
 36543                                  	;pushreg <bx,di,es>
 36544                                  	;dataseg es		; Point ES into appropriate data seg
 36545                                  
 36546                                  	;push	bx ; **
 36547                                  	
 36548                                  	;push	di
 36549                                  	;push	es
 36550                                  	;mov	es,[RESSEG]
 36551 00005F9A 1E                      	push	ds ; *
 36552 00005F9B 8E1E[E49D]              	mov	ds,[RESSEG]
 36553                                  
 36554 00005F9F 88CB                    	mov	bl,cl		; Now bl==UMB number, AX==size
 36555 00005FA1 B700                    	mov	bh,0		;     bx==UMB number, AX==size
 36556 00005FA3 D0E3                    	shl	bl,1		;     bx==offset into array, AX=size
 36557                                  	;mov	[es:bx+UmbSize],ax
 36558 00005FA5 8987[0B05]              	mov	[bx+UmbSize],ax	; Store the size
 36559                                  
 36560 00005FA9 1F                      	pop	ds ; *
 36561                                  
 36562                                  	;popreg	<es,di,bx>
 36563                                  	;normseg es		; Return ES to where it was
 36564                                  
 36565                                  	;pop	es
 36566                                  	;pop	di
 36567                                  	
 36568                                  	;pop	bx ; **
 36569                                  
 36570 00005FAA C3                      	retn
 36571                                  
 36572                                  ; -----------------------------------------------------------------------------
 36573                                  ;*** toDigit - converts a character-digit to its binary counterpart
 36574                                  ;            -- verifies that CL contains a valid character-digit; if so, it
 36575                                  ; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).  A-F
 36576                                  ; are considered valid iff gnradix is 16.
 36577                                  ; -----------------------------------------------------------------------------
 36578                                  ; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
 36579                                  ; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
 36580                                  ; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
 36581                                  ; USES:     CL, Flags
 36582                                  ; -----------------------------------------------------------------------------
 36583                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 36584                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 36585                                  ; will be 10 or 16.
 36586                                  ; -----------------------------------------------------------------------------
 36587                                  
 36588                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36589                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6358h
 36590                                  gnradix:
 36591 00005FAB 0000                    	dw	0		; Must be a word--16x16 multiplication
 36592                                  
 36593                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36594                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:635Ah
 36595                                  toDigit:
 36596                                  	;cmp	word [gnradix],16
 36597 00005FAD 803E[AB5F]10            	cmp	byte [gnradix],16
 36598 00005FB2 751C                    	jne	short td20	; Don't check hex digits if radix isn't 16
 36599                                  
 36600 00005FB4 80F961                  	cmp	cl,'a'
 36601 00005FB7 7209                    	jb	short td10
 36602 00005FB9 80F966                  	cmp	cl,'f'
 36603 00005FBC 7720                    	ja	short tdE	; Nothing valid above 'z' at all...
 36604 00005FBE 80E957                  	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
 36605                                  ;	clc			; <- CLC is implicit from last SUB
 36606 00005FC1 C3                      	retn
 36607                                  td10:
 36608 00005FC2 80F941                  	cmp	cl,'A'
 36609 00005FC5 7209                    	jb	short td20	; Below 'A'?  Not a letter...
 36610 00005FC7 80F946                  	cmp	cl,'F'
 36611 00005FCA 7712                    	ja	short tdE	; Above 'F'?  Not a digit.
 36612 00005FCC 80E937                  	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
 36613                                  ;	clc			; <- CLC is implicit from last SUB
 36614                                  tdErr:
 36615 00005FCF C3                      	retn
 36616                                  td20:
 36617 00005FD0 80F930                  	cmp	cl,'0'		; If less than zero,
 36618                                  	;jb	short tdE	; Done.
 36619 00005FD3 72FA                    	jb	short tdErr ; cf = 1
 36620 00005FD5 80F939                  	cmp	cl,'9'		; Or, if greater than nine,
 36621 00005FD8 7704                    	ja	short tdE	; Done.
 36622 00005FDA 80E930                  	sub	cl,'0'	  ; 30h	; Okay--make '0'==0 and return.
 36623                                  ;	clc			; <- CLC is implicit from last SUB
 36624 00005FDD C3                      	retn
 36625                                  tdE:
 36626 00005FDE F9                      	stc
 36627 00005FDF C3                      	retn
 36628                                  
 36629                                  ; -----------------------------------------------------------------------------
 36630                                  ;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 36631                                  ; -----------------------------------------------------------------------------
 36632                                  ; ENTRY:    ES:SI points to an ascii string to scan
 36633                                  ; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
 36634                                  ; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
 36635                                  ; USES:     ES:SI, DX, AX, Flags, gnradix
 36636                                  ; -----------------------------------------------------------------------------
 36637                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 36638                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 36639                                  ; will be 10 or 16.
 36640                                  ; -----------------------------------------------------------------------------
 36641                                  
 36642                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36643                                  GetXNum:
 36644                                  	;pushreg <bx,cx,ds>
 36645                                  	
 36646                                  	;push	bx ; **
 36647 00005FE0 51                      	push	cx ; *
 36648                                  	
 36649                                  	;push	ds
 36650                                  
 36651 00005FE1 FC                      	cld
 36652 00005FE2 31C0                    	xor	ax,ax
 36653 00005FE4 31DB                    	xor	bx,bx
 36654 00005FE6 31C9                    	xor	cx,cx
 36655 00005FE8 31D2                    	xor	dx,dx		; Start with 0 (makes sense)
 36656                                  
 36657                                  	;mov	word [gnradix],10 ; And default to a radix of 10 (dec)
 36658 00005FEA C606[AB5F]0A            	mov	byte [gnradix],10
 36659                                  
 36660 00005FEF 268A0C                  	mov	cl,[es:si]	; Now AX=0, BX=0, CH=0/CL=char, DX=0
 36661 00005FF2 E8B8FF                  	call	toDigit
 36662 00005FF5 722D                    	jc	short gxnE	; If it's not a digit, leave now.
 36663                                  
 36664 00005FF7 08C9                    	or	cl,cl
 36665 00005FF9 7515                    	jnz	short gxn20	; Doesn't have '0x'
 36666 00005FFB 268A4C01                	mov	cl,[es:si+1]
 36667 00005FFF 80F978                  	cmp	cl,'x'		; Either 'x'...
 36668 00006002 7405                    	je	short gxn10
 36669 00006004 80F958                  	cmp	cl,'X'		; ...or 'X' means it's hexadecimal
 36670 00006007 7507                    	jne	short gxn20
 36671                                  
 36672                                  gxn10:
 36673                                  	;mov	word [gnradix],16
 36674 00006009 C606[AB5F]10            	mov	byte [gnradix],16
 36675 0000600E 46                      	inc	si		; Since we read "0x", march over it.
 36676 0000600F 46                      	inc	si
 36677                                  
 36678                                  ; ------------------------------------------------------
 36679                                  ; GXN20--ES:SI = a digit in a number; if not, we're done
 36680                                  ;        DX:AX = current total
 36681                                  ;        BX    = 0
 36682                                  ;        CH    = 0
 36683                                  ; ------------------------------------------------------
 36684                                  
 36685                                  gxn20:
 36686 00006010 268A0C                  	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
 36687 00006013 46                      	inc	si
 36688                                  
 36689 00006014 E896FF                  	call	toDigit		; Accepts only valid digits, A-F -> 10-16
 36690 00006017 720D                    	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.
 36691                                  
 36692 00006019 E80E00                  	call	mul32		; Multiply DX:AX by gnradix
 36693 0000601C 7206                    	jc	short gxnX	; (if it's too big, error out)
 36694                                  
 36695 0000601E 01C8                    	add	ax,cx		; Add the digit
 36696 00006020 11DA                    	adc	dx,bx		; (BX is 0!)--Adds 1 if last add wrapped
 36697                                  	;jc	short gxnX	; If _that_ wrapped, it's too big.
 36698                                  	;jmp	short gxn20
 36699 00006022 73EC                    	jnc	short gxn20
 36700                                  gxnE:
 36701                                  	; cf = 1
 36702                                  	;stc			; In this case, we need to set the carry
 36703                                  	;jmp	short gxnX	; and leave--there were no digits given.
 36704                                  ;gxnQ:
 36705                                  	;dec	si		; Don't read in the offensive character.
 36706                                  	;clc			; And clear carry, so they know it's okay.
 36707                                  gxnX:
 36708                                  	;popreg	<ds,cx,bx>
 36709                                  
 36710                                  	;pop	ds
 36711                                  
 36712 00006024 59                      	pop	cx ; *
 36713                                  	;pop	bx ; **
 36714                                  
 36715 00006025 C3                      	retn
 36716                                  gxnQ:
 36717 00006026 4E                      	dec	si
 36718 00006027 F8                      	clc
 36719 00006028 EBFA                    	jmp	short gxnX
 36720                                  
 36721                                  ; -----------------------------------------------------------------------------
 36722                                  ;*** mul32 - multiplies the number in DX:AX by gnradix
 36723                                  ; -----------------------------------------------------------------------------
 36724                                  ; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
 36725                                  ; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
 36726                                  ; ERROR:   Carry set if number was too large
 36727                                  ; USES:    Flags, AX, DX
 36728                                  ; -----------------------------------------------------------------------------
 36729                                  
 36730                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36731                                  mul32:
 36732 0000602A 50                      	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
 36733 0000602B 89D0                    	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
 36734 0000602D F726[AB5F]              	mul	word [gnradix]	; DX=?,      AX=new:hi, TOS=old:lo, BX=0
 36735 00006031 7210                    	jc	short m32E	; Too big?
 36736                                  
 36737 00006033 89C2                    	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
 36738 00006035 58                      	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig,   BX=0
 36739                                  
 36740 00006036 87D3                    	xchg	dx,bx		; DX=0,      AX=old:lo, TOS=orig,   BX=new:hi
 36741 00006038 F726[AB5F]              	mul	word [gnradix]	; DX=carry,  AX=new:lo, TOS=orig,   BX=new:hi
 36742 0000603C 87D3                    	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 36743 0000603E 01DA                    	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 36744 00006040 31DB                    	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=0
 36745 00006042 C3                      	retn
 36746                                  m32E:
 36747 00006043 58                      	pop	ax
 36748 00006044 C3                      	retn
 36749                                  
 36750                                  ; -----------------------------------------------------------------------------
 36751                                  ;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
 36752                                  ; -----------------------------------------------------------------------------
 36753                                  ; ENTRY:   DX:AX = the number to be divided
 36754                                  ; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
 36755                                  ; ERROR:   None
 36756                                  ; USES:    Flags, AX, DX
 36757                                  ; -----------------------------------------------------------------------------
 36758                                  ; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
 36759                                  ;       can't ensure a 386 host machine. Sorry.
 36760                                  ; -----------------------------------------------------------------------------
 36761                                  
 36762                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36763                                  toPara:
 36764 00006045 51                      	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
 36765                                  
 36766 00006046 B104                    	mov	cl,4		;
 36767 00006048 D3E8                    	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
 36768 0000604A 92                      	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
 36769 0000604B B10C                    	mov	cl,12
 36770 0000604D D3E0                    	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
 36771 0000604F 09D0                    	or	ax,dx		;    AX=hhhh LLLL llll llll
 36772                                  
 36773 00006051 59                      	pop	cx
 36774 00006052 C3                      	retn
 36775                                  
 36776                                  ; -----------------------------------------------------------------------------
 36777                                  ;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
 36778                                  ; -----------------------------------------------------------------------------
 36779                                  ; ENTRY:  Nothing
 36780                                  ; EXIT:   AX contains 0x9FFF for most systems
 36781                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 36782                                  ; USES:   Flags, AX
 36783                                  ; -----------------------------------------------------------------------------
 36784                                  ; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
 36785                                  ; to be precise, before a UMB provider is around.  In this event, the pointer
 36786                                  ; is always set to 0xFFFF; it changes once a provider is around.  On most
 36787                                  ; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
 36788                                  ; -----------------------------------------------------------------------------
 36789                                  
 36790                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36791                                  UmbHead:
 36792                                  	;pushreg <si,ds,es>
 36793                                  	
 36794                                  	;push	si
 36795                                  	;push	ds
 36796                                  	;push	es
 36797                                  
 36798 00006053 B452                    	mov	ah,52h	; DOS_GET_DOS_LISTS
 36799                                  					; Call int 21h, function 52h...
 36800 00006055 CD21                    	int	21h
 36801                                  			; DOS - 2+ internal - GET LIST OF LISTS
 36802                                  			; Return: ES:BX -> DOS list of lists
 36803                                  
 36804                                  	;mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
 36805 00006057 26A18C00                	mov	ax,[es:8Ch]
 36806 0000605B 83F8FF                  	cmp	ax,0FFFFh
 36807                                  	;je	short uhE		; If it's 0xFFFF, it's an error...
 36808                                  
 36809                                  	;clc				; Else, it isn't (CLC done by prev cmp)
 36810                                  	;jmp	short uhX
 36811                                  	; 17/06/2023
 36812 0000605E F5                      	cmc	; cf = 0 <--> cf = 1
 36813                                  uhE:
 36814                                  	;stc
 36815                                  uhX:	
 36816                                  	;popreg	<es,ds,si>
 36817                                  	
 36818                                  	;pop	es
 36819                                  	;pop	ds
 36820                                  	;pop	si
 36821                                  
 36822 0000605F C3                      	retn
 36823                                  
 36824                                  ; -----------------------------------------------------------------------------
 36825                                  ;*** isSysMCB - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 36826                                  ; -----------------------------------------------------------------------------
 36827                                  ; ENTRY:  ES:0 should point to a valid MCB
 36828                                  ; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
 36829                                  ; USES:   Flags
 36830                                  ; -----------------------------------------------------------------------------
 36831                                  
 36832                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36833                                  isSysMCB:
 36834                                  	;push	ax
 36835                                  	
 36836                                  	;mov	ax,[es:1]
 36837 00006060 26A10100                	mov	ax,[es:arena_owner]	; Check the owner...
 36838 00006064 83F808                  	cmp	ax,8 ; SystemPSPOwner	; 8 (for US OR Japan) is valid
 36839 00006067 7405                    	jz	short ism10
 36840 00006069 83F809                  	cmp	ax,9 ; JapanPSPOwner	; 9 (for Japan) is valid
 36841                                  	;jz	short ism10
 36842                                  	;jmp	short ismX		; Anything else isn't.
 36843 0000606C 7507                    	jnz	short ismX
 36844                                  ism10:
 36845                                  	;mov	ax,[es:8]
 36846 0000606E 26A10800                	mov	ax,[es:arena_name]	; Check the name...
 36847 00006072 3D5343                  	cmp	ax,'SC' ; cmp ax,4353h
 36848                                  ismX:
 36849                                  	;pop	ax
 36850 00006075 C3                      	retn
 36851                                  
 36852                                  ; -----------------------------------------------------------------------------
 36853                                  ;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
 36854                                  ; -----------------------------------------------------------------------------
 36855                                  ; ENTRY:  AX contains a segment address
 36856                                  ; EXIT:   AX will contain the UMB number which contains the address (0==conv)
 36857                                  ; ERROR:  If the address is above UM Range, AX will return as FFFF.
 36858                                  ; USES:   Flags, AX
 36859                                  ; -----------------------------------------------------------------------------
 36860                                  ; An address in the following areas is treated as:
 36861                                  ;    0      <-> umbhead (0x9FFF)          = Conventional memory
 36862                                  ;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
 36863                                  ;      ...
 36864                                  ;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
 36865                                  ; -----------------------------------------------------------------------------
 36866                                  
 36867                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36868                                  AddrToUmb:
 36869                                  	;pushreg <cx,dx,es>
 36870                                  	
 36871                                  	;push	cx
 36872                                  	;push	dx
 36873 00006076 06                      	push	es
 36874                                  
 36875 00006077 89C2                    	mov	dx,ax		; DX = address to search for
 36876                                  
 36877 00006079 E8D7FF                  	call	UmbHead		; AX = first segment
 36878 0000607C 722B                    	jc	short atuE	; If it couldn't get it, error out.
 36879                                  
 36880                                  	;mov	es,ax ; *	; ES = first UMB segment
 36881 0000607E 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)
 36882                                  
 36883                                  ; ----------------------------------------
 36884                                  ; ATU10--ES - Current MCB address
 36885                                  ;        DX - Address given for conversion
 36886                                  ;        CX - Current UMB #
 36887                                  ; ----------------------------------------
 36888                                  
 36889                                  	; 17/06/2023
 36890                                  atu10:
 36891 00006080 8EC0                    	mov	es,ax ; *
 36892                                  ;atu10:
 36893                                  	;mov	ax,es
 36894 00006082 39D0                            cmp	ax,dx		; Present segment >= given segment?
 36895 00006084 7326                    	jae	short atuX	; Yep--done.
 36896                                  
 36897 00006086 E8D7FF                  	call	isSysMCB	; Returns with ZF set if this is a system MCB
 36898 00006089 7501                    	jnz	short atu20
 36899                                  
 36900 0000608B 41                      	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
 36901                                  atu20:
 36902                                  	;mov	al,[es:0]
 36903 0000608C 26A00000                	mov	al,[es:arena_signature]
 36904                                  	;cmp	al,'Z' ; 5Ah
 36905 00006090 3C5A                    	cmp	al,arena_signature_end
 36906 00006092 740A                    	je	short atu30	; 'Z' means this was the last MCB... that's it.
 36907                                  
 36908                                  	;NextMCB es,ax
 36909 00006094 8CC0                    	mov	ax,es
 36910                                  	;add	ax,[es:3]	; NextMCB (macro)
 36911 00006096 2603060300              	add	ax,[es:arena_size]
 36912 0000609B 40                      	inc	ax
 36913                                  	;mov	es,ax ; * ; 17/06/2023
 36914 0000609C EBE2                    	jmp	short atu10
 36915                                  
 36916                                  ; -----------------------------------------------------------------------------
 36917                                  ; if we get to atu30, they specified a number that was past the last MCB.
 36918                                  ; make sure it's not _inside_ that MCB before we return an error condition.
 36919                                  ; -----------------------------------------------------------------------------
 36920                                  
 36921                                  atu30:
 36922 0000609E 8CC0                    	mov	ax,es
 36923                                  	;add	ax,[es:3]
 36924 000060A0 2603060300              	add	ax,[es:arena_size]
 36925 000060A5 39D0                    	cmp	ax,dx		; Present >= given?
 36926 000060A7 7303                    	jae	short atuX	; Yep! It _was_ inside.
 36927                                  atuE:
 36928 000060A9 31C9                    	xor	cx,cx		; Else, fall through with UMB # == -1
 36929 000060AB 49                      	dec	cx		; (that makes it return 0xFFFF and sets CF)
 36930                                  atuX:	
 36931 000060AC 89C8                    	mov	ax,cx		; Return the UMB number in AX
 36932                                  	
 36933                                  	;popreg	<es,dx,cx>
 36934                                  
 36935 000060AE 07                      	pop	es
 36936                                  	;pop	dx
 36937                                  	;pop	cx
 36938                                  	
 36939 000060AF C3                      	retn
 36940                                  
 36941                                  ; -----------------------------------------------------------------------------
 36942                                  ;*** convUMB - checks after GetXNum to convert an address to a UMB number
 36943                                  ;            -- if GetXNum read a hex number, we interperete that as a segment
 36944                                  ; address rather than a UMB number... and use that address to look up a UMB.
 36945                                  ; This routine checks for that condition and calls AddrToUmb if necessary.
 36946                                  ; -----------------------------------------------------------------------------
 36947                                  ; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
 36948                                  ; EXIT:   AX will contain a UMB number
 36949                                  ; ERROR:  None
 36950                                  ; USES:   Flags, AX
 36951                                  ; -----------------------------------------------------------------------------
 36952                                  
 36953                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36954                                  convUMB:
 36955                                  	;cmp	word [gnradix],16
 36956 000060B0 803E[AB5F]10            	cmp	byte [gnradix],16
 36957 000060B5 7509                    	jne	short cu10	; If it didn't read in hex, it's not an address
 36958 000060B7 E8BCFF                  	call	AddrToUmb	; Else, convert the address to a UMB number
 36959 000060BA 83F8FF                  	cmp	ax,0FFFFh
 36960 000060BD 7501                    	jne	short cu10
 36961 000060BF 40                      	inc	ax ; ax = 0	; If too high, ignore it (make it conventional)
 36962                                  cu10:
 36963 000060C0 C3                      	retn
 36964                                  
 36965                                  ; -----------------------------------------------------------------------------
 36966                                  ;*** setUMBs - links umbs and sets allocation strategy for a load
 36967                                  ;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
 36968                                  ; of the usual HIGH_FIRST.  See the code.
 36969                                  ; -----------------------------------------------------------------------------
 36970                                  ; ENTRY:  None
 36971                                  ; EXIT:   None
 36972                                  ; ERROR:  None
 36973                                  ; USES:   Flags, fm_umb, fm_strat
 36974                                  ; -----------------------------------------------------------------------------
 36975                                  
 36976                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 36977                                  setUMBs:
 36978                                  	;pushreg <ax,bx>
 36979                                  	
 36980                                  	;push	ax
 36981                                  	;push	bx
 36982                                  
 36983 000060C1 E8B2FD                  	call	fm_link
 36984                                  
 36985 000060C4 B80058                  	mov	ax,5800h ; DOS_CHECK_STRATEGY
 36986 000060C7 CD21                    	int	21h
 36987                                  
 36988                                  	;putdata fm_strat,al	; Store the current strategy for later restore
 36989                                  
 36990                                  	;push	es
 36991                                  	;mov	es,[RESSEG]
 36992                                  	;mov	[es:fm_strat],al ; store the current strategy
 36993                                  	;pop	es
 36994 000060C9 1E                      	push	ds ; *
 36995 000060CA 8E1E[E49D]              	mov	ds,[RESSEG]
 36996 000060CE A2[2C05]                	mov	[fm_strat],al
 36997                                  	;pop	ds ; *
 36998                                  
 36999 000060D1 83E07F                  	and	ax,007Fh	; 0000.0000.0111.1111 == All that other stuff
 37000 000060D4 50                      	push	ax ; **		; Watch this carefully...
 37001                                  
 37002 000060D5 E80C00                  	call	loadLow		; returns al==0 if load low, al==1 if loadhigh
 37003 000060D8 D0C8                    	ror	al,1		; Shift that to al==0 or al==0x80
 37004                                  
 37005 000060DA 5B                      	pop	bx ; **		; ...pushed as AX above
 37006                                  	
 37007 000060DB 1F                      	pop	ds ; *
 37008                                  	
 37009 000060DC 08C3                    	or	bl,al		; Now we have 0000.0000.?111.1111 in BX;
 37010                                  
 37011 000060DE B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 37012                                  				; with ? ==1 if load highfirst. Perfect!
 37013 000060E1 CD21                    	int	21h
 37014                                  
 37015                                  	;popreg	<bx,ax>
 37016                                  
 37017                                  	;pop	bx
 37018                                  	;pop	ax
 37019                                  
 37020 000060E3 C3                      	retn
 37021                                  
 37022                                  ; -----------------------------------------------------------------------------
 37023                                  ;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
 37024                                  ; -----------------------------------------------------------------------------
 37025                                  ; ENTRY:  None
 37026                                  ; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
 37027                                  ;         Carry set if UMB0 not specified (_NOT_ an error)
 37028                                  ; ERROR:  None
 37029                                  ; USES:   Flags, fm_strat, fm_umb
 37030                                  ; -----------------------------------------------------------------------------
 37031                                  ; We want to set the memory strategy to LOW_FIRST if the user specified a
 37032                                  ; load UMB, and it is 0.  That 0 can be either from the user having _specified_
 37033                                  ; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
 37034                                  ; such that the load UMB is too small, and shouldn't be used.
 37035                                  ; -----------------------------------------------------------------------------
 37036                                  
 37037                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37038                                  loadLow:
 37039                                  	;push	ds ; *	
 37040                                  	
 37041                                  	;dataseg ds		; Point DS into appropriate data segment
 37042                                  	;mov	ds,[RESSEG]
 37043                                  
 37044                                  	; * ; ds = [RESSEG] from 'setUMBs') ; 17/06/2023
 37045                                  
 37046 000060E4 A0[FA04]                	mov	al,[UmbLoad]
 37047 000060E7 3CFF                    	cmp	al,0FFh ; UNSPECIFIED
 37048 000060E9 7503                    	jne	short ll10
 37049                                  
 37050                                  	;mov	al,1		; Return with AL==1 && STC if no UMBs specified
 37051 000060EB F9                      	stc
 37052                                  	;jmp	short llX
 37053 000060EC EB04                    	jmp	short lly ; 17/06/2023
 37054                                  ll10:
 37055 000060EE 08C0                    	or	al,al		; AL=the load UMB: Is it == 0?
 37056 000060F0 7402                    	jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit
 37057                                  	; cf= 0
 37058                                  
 37059                                  	;mov	al,1
 37060                                  	;clc	
 37061                                  lly:		; 17/06/2023
 37062 000060F2 B001                    	mov	al,1
 37063                                  llX:
 37064                                  	;pop	ds ; *		; Return DS to where it was
 37065                                  	
 37066                                  	;normseg ds		;
 37067                                  	
 37068 000060F4 C3                      	retn
 37069                                  
 37070                                  ; -----------------------------------------------------------------------------
 37071                                  ;*** HideUMBs - links UMBs and hides upper-memory as appropriate
 37072                                  ; -----------------------------------------------------------------------------
 37073                                  ; ENTRY:  None
 37074                                  ; EXIT:   None
 37075                                  ; ERROR:  None
 37076                                  ; USES:   Flags, fm_strat, fm_umb
 37077                                  ; -----------------------------------------------------------------------------
 37078                                  
 37079                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37080                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:64D0h
 37081                                  HideUMBs:
 37082                                  	;pushreg <ax,cx,ds,es>
 37083                                  	
 37084                                  	;push	ax
 37085                                  	;push	cx
 37086                                  	;push	ds
 37087                                  	;push	es
 37088                                  
 37089 000060F5 E8EF01                  	call	UmbTest		; See if we REALLY linked in anything...
 37090 000060F8 7236                    	jc	short husX	; ...if not, there's nothing for us to do.
 37091                                  
 37092 000060FA E82CFD                  	call	FixMem		; Concatenate adjacent free MCBs in upper mem
 37093 000060FD E8C1FF                  	call	setUMBs		; Link UMBs and set memory-allocation strategy
 37094                                  
 37095                                  	;putdata fInHigh,1	; Remember that we're now running high
 37096                                  	;push	es
 37097                                  	;mov	es,[RESSEG]
 37098                                  	;mov	byte [es:fInHigh], 1
 37099                                  	;			; remember that we're now running high
 37100                                  	;pop	es
 37101 00006100 1E                      	push	ds
 37102 00006101 8E1E[E49D]              	mov	ds,[RESSEG]
 37103 00006105 C606[F604]01            	mov	byte [fInHigh], 1
 37104 0000610A 1F                      	pop	ds
 37105                                  
 37106 0000610B E82300                  	call	GetLoadUMB	; See if they gave us a list to leave free
 37107 0000610E 3CFF                    	cmp	al,0FFh	; UNSPECIFIED
 37108                                  				; If they didn't,
 37109 00006110 741E                    	je	short husX	; then we shouldn't do this loop:
 37110                                  
 37111 00006112 31C9                    	xor	cx,cx
 37112                                  
 37113                                  ; -----------------------------------------------
 37114                                  ; HUS10-CX - UMB number (after inc, 1==first UMB)
 37115                                  ; -----------------------------------------------
 37116                                  
 37117                                  hus10:
 37118 00006114 41                      	inc	cx		; For each UMB:
 37119 00006115 83F910                  	cmp	cx,16 ; MAXUMB
 37120 00006118 730C                    	jae	short hus20
 37121                                  
 37122 0000611A 88C8                    	mov	al,cl		; (stopping as soon as we're outside of the
 37123                                  	; 17/06/2023
 37124                                  	;push	es
 37125 0000611C E8A900                  	call	findumb		; valid range of UMBs)
 37126                                  	;pop	es		; push/pop: trash what findumb finds.  :-)
 37127 0000611F 7205                    	jc	short hus20
 37128                                  
 37129 00006121 E87901                  	call	hideUMB?	; hide what we need to hide.
 37130                                  
 37131 00006124 EBEE                    	jmp	short hus10
 37132                                  hus20:
 37133 00006126 E80800                  	call	GetLoadUMB	; Now check if they offered /L:0
 37134 00006129 08C0                    	or	al,al		; --Is the load UMB 0? (-1==unspecified)
 37135 0000612B 7503                    	jnz	short husX	; If not, we're done.
 37136                                  
 37137 0000612D E8E701                  	call	hl_unlink	; If so, however, fix UMBs and strategy.
 37138                                  husX:
 37139                                  	;popreg	<es,ds,cx,ax>
 37140                                  	
 37141                                  	;pop	es
 37142                                  	;pop	ds
 37143                                  	;pop	cx
 37144                                  	;pop	ax
 37145                                  
 37146 00006130 C3                      	retn
 37147                                  
 37148                                  ; -----------------------------------------------------------------------------
 37149                                  ;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
 37150                                  ; -----------------------------------------------------------------------------
 37151                                  ; ENTRY:  None
 37152                                  ; EXIT:   AL == load UMB
 37153                                  ; ERROR:  None
 37154                                  ; USES:   Flags, AX
 37155                                  ; -----------------------------------------------------------------------------
 37156                                  
 37157                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37158                                  GetLoadUMB:
 37159                                  	;getdata al,UmbLoad
 37160                                  
 37161 00006131 1E                      	push    ds
 37162 00006132 8E1E[E49D]              	mov     ds,[RESSEG]   ; getdata (macro)
 37163 00006136 A0[FA04]                	mov     al,[UmbLoad]
 37164 00006139 1F                      	pop     ds
 37165                                  
 37166 0000613A C3                      	retn
 37167                                  
 37168                                  ; -----------------------------------------------------------------------------
 37169                                  ;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
 37170                                  ; -----------------------------------------------------------------------------
 37171                                  ; ENTRY:  AL == a UMB number
 37172                                  ; EXIT:   AX == UMB minimum size, as specified by the user
 37173                                  ; ERROR:  None
 37174                                  ; USES:   Flags, AX
 37175                                  ; -----------------------------------------------------------------------------
 37176                                  
 37177                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37178                                  GetSize:
 37179                                  	;pushreg <bx,si,ds>
 37180                                  	;push	bx
 37181                                  	;push	si
 37182 0000613B 1E                      	push	ds
 37183                                  	
 37184                                  	;dataseg ds
 37185 0000613C 8E1E[E49D]              	mov	ds,[RESSEG]
 37186                                  
 37187 00006140 30E4                    	xor	ah,ah			;    ax==UMB
 37188                                  	;mov	bx,offset UmbSize
 37189 00006142 BB[0B05]                	mov	bx,UmbSize		;    bx==array
 37190 00006145 D0E0                    	shl	al,1	                ;    ax==offset
 37191                                  	;add	ax,bx			;    ax==element index
 37192                                  	;mov	si,ax			; ds:si==element index
 37193                                  	;lodsw				;    ax==size
 37194 00006147 01C3                    	add	bx,ax
 37195 00006149 8B07                    	mov	ax,[bx]
 37196                                  
 37197                                  	;popreg	<ds,si,bx>
 37198 0000614B 1F                      	pop	ds
 37199                                  	;pop	si
 37200                                  	;pop	bx
 37201                                  
 37202                                  	;normseg ds
 37203 0000614C C3                      	retn
 37204                                  
 37205                                  ; -----------------------------------------------------------------------------
 37206                                  ;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
 37207                                  ; -----------------------------------------------------------------------------
 37208                                  ; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
 37209                                  ; EXIT:     None; free elements in UMB marked as hidden
 37210                                  ; ERROR:    None
 37211                                  ; USES:     Flags
 37212                                  ; -----------------------------------------------------------------------------
 37213                                  
 37214                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37215                                  hideUMB:
 37216                                  	;pushreg <ax,es>
 37217                                  	
 37218                                  	;push	ax
 37219                                  	;push	es
 37220                                  
 37221 0000614D E87800                  	call	findumb		; Returns with carry if err, else ES == MCB
 37222 00006150 7221                    	jc	short huX
 37223                                  
 37224                                  ; ------------------------------------------------
 37225                                  ; HU10--ES - MCB inside UMB; if it's a system MCB,
 37226                                  ;            we're not in the same UMB, so exit.
 37227                                  ; ------------------------------------------------
 37228                                  
 37229                                  hu10:
 37230 00006152 E80BFF                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37231 00006155 741C                    	jz	short huX	; If it is, we've finished the UMB.
 37232 00006157 E82800                  	call	isFreeMCB	; Returns with ZF set if owner is 0
 37233 0000615A 7503                    	jnz	short hu20
 37234                                  
 37235 0000615C E82A00                  	call	hideMCB
 37236                                  hu20:
 37237                                  	;mov	al,[es:0]
 37238 0000615F 26A00000                	mov	al,[es:arena_signature]
 37239                                  	;cmp	al,'Z'
 37240 00006163 3C5A                    	cmp	al,arena_signature_end
 37241 00006165 740C                    	je	short huX	; 'Z' means this was the last MCB... that's it.
 37242                                  
 37243                                  	;NextMCB es,ax		; Go on forward.
 37244                                  
 37245 00006167 8CC0                     	mov	ax,es		; NextMCB (macro)
 37246                                  	;add	ax,[es:3]
 37247 00006169 2603060300              	add	ax,[es:arena_size]
 37248 0000616E 40                      	inc	ax
 37249 0000616F 8EC0                    	mov	es,ax
 37250                                  
 37251 00006171 EBDF                    	jmp	short hu10
 37252                                  huX:
 37253                                  	;popreg	<es,ax>
 37254                                  	
 37255                                  	;pop	es
 37256                                  	;pop	ax
 37257                                  
 37258 00006173 C3                      	retn
 37259                                  
 37260                                  ; -----------------------------------------------------------------------------
 37261                                  ;*** isTiny - returns with ZF set if user didn't specify /S
 37262                                  ; -----------------------------------------------------------------------------
 37263                                  ; ENTRY:    None
 37264                                  ; EXIT:     ZF set if user DIDN'T specify /S
 37265                                  ; ERROR:    None
 37266                                  ; USES:     Flags
 37267                                  ; -----------------------------------------------------------------------------
 37268                                  
 37269                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37270                                  isTiny:
 37271 00006174 50                      	push	ax
 37272                                  
 37273                                  	;getdata al,fUmbTiny
 37274 00006175 1E                      	push    ds
 37275 00006176 8E1E[E49D]              	mov     ds,[RESSEG]   ; getdata (macro)
 37276 0000617A A0[F704]                	mov     al,[fUmbTiny]
 37277 0000617D 1F                      	pop     ds
 37278                                  
 37279 0000617E 08C0                    	or	al,al
 37280 00006180 58                      	pop	ax
 37281 00006181 C3                      	retn
 37282                                  
 37283                                  ; -----------------------------------------------------------------------------
 37284                                  ;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
 37285                                  ; -----------------------------------------------------------------------------
 37286                                  ; ENTRY:    ES:0 should point to an MCB
 37287                                  ; EXIT:     ZF set if MCB is free, else !ZF
 37288                                  ; ERROR:    None
 37289                                  ; USES:     Flags
 37290                                  ; -----------------------------------------------------------------------------
 37291                                  
 37292                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37293                                  isFreeMCB:
 37294                                  	;or	word [es:1],0
 37295 00006182 26830E010000            	or	word [es:arena_owner],0
 37296 00006188 C3                      	retn
 37297                                  
 37298                                  ; -----------------------------------------------------------------------------
 37299                                  ;*** hideMCB - marks as HIDDEN the MCB at ES:0
 37300                                  ; -----------------------------------------------------------------------------
 37301                                  ; ENTRY:    ES:0 should point to an MCB
 37302                                  ; EXIT:     None; MCB marked as HIDDEN
 37303                                  ; ERROR:    None
 37304                                  ; USES:     None
 37305                                  ; -----------------------------------------------------------------------------
 37306                                  
 37307                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37308                                  hideMCB:
 37309                                  	;mov	word [es:1],8
 37310 00006189 26C70601000800          	mov	word [es:arena_owner],8 ; SystemPSPOwner
 37311                                  	;mov	word [es:8],4948h     ; 'HIDDEN  ' 
 37312 00006190 26C70608004849          	mov	word [es:arena_name+0], 'HI' ; 4948h
 37313 00006197 26C7060A004444          	mov	word [es:arena_name+2], 'DD' ; 4444h
 37314 0000619E 26C7060C00454E          	mov	word [es:arena_name+4], 'EN' ; 4E45h
 37315                                  	;mov	word [es:14],2020h
 37316 000061A5 26C7060E002020          	mov	word [es:arena_name+6], '  ' ; 2020h 
 37317 000061AC C3                      	retn
 37318                                  
 37319                                  ; -----------------------------------------------------------------------------
 37320                                  ;*** unHideMCB - marks as FREE the MCB at ES:0
 37321                                  ; -----------------------------------------------------------------------------
 37322                                  ; ENTRY:    ES:0 should point to an MCB
 37323                                  ; EXIT:     None; MCB marked as FREE
 37324                                  ; ERROR:    None
 37325                                  ; USES:     None
 37326                                  ; -----------------------------------------------------------------------------
 37327                                  
 37328                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37329                                  unHideMCB:
 37330                                  	;push	ax
 37331                                  	;mov	word [es:1],0
 37332 000061AD 26C70601000000          	mov	word [es:arena_owner],0 ; FreePSPOwner
 37333 000061B4 B82020                  	mov	ax, '  '  ; mov ax,2020h
 37334                                  	;mov	[es:8],ax
 37335 000061B7 26A30800                	mov	[es:arena_name+0],ax
 37336 000061BB 26A30A00                	mov	[es:arena_name+2],ax
 37337 000061BF 26A30C00                	mov	[es:arena_name+4],ax
 37338                                  	;mov	[es:14],ax
 37339 000061C3 26A30E00                	mov	[es:arena_name+6],ax
 37340                                  	;pop	ax
 37341 000061C7 C3                      	retn
 37342                                  
 37343                                  ; -----------------------------------------------------------------------------
 37344                                  ;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
 37345                                  ;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
 37346                                  ; -----------------------------------------------------------------------------
 37347                                  ; ENTRY:    AL should be to a valid UMB number
 37348                                  ; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
 37349                                  ; ERROR:    Carry set if couldn't reach UMB (too high)
 37350                                  ; USES:     Flags, ES
 37351                                  ; -----------------------------------------------------------------------------
 37352                                  
 37353                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37354                                  findumb:
 37355                                  	;pushreg <ax,cx,dx>
 37356                                  	
 37357                                  	;push	ax
 37358 000061C8 51                      	push	cx
 37359 000061C9 52                      	push	dx
 37360                                  
 37361 000061CA 30E4                    	xor	ah,ah		; Zap ah, so al==ax
 37362                                  
 37363 000061CC 89C2                    	mov	dx,ax		; Store the to-be-found UMB number in DX
 37364                                  
 37365 000061CE E882FE                  	call	UmbHead		; Returns first UMB segment in AX
 37366                                  
 37367 000061D1 8EC0                    	mov	es,ax
 37368 000061D3 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now...
 37369                                  
 37370                                  ; ---------------------------------------------
 37371                                  ; FU10--CX - This UMB number; 0 == conventional
 37372                                  ;       DX - The UMB number they're looking for
 37373                                  ;       ES - The current MCB address
 37374                                  ; ---------------------------------------------
 37375                                  
 37376                                  fu10:	
 37377 000061D5 39D1                    	cmp	cx,dx		; If CX==DX, we've found the UMB we're
 37378 000061D7 741B                    	je	short fuX	; searching for--so exit.
 37379                                  
 37380 000061D9 E884FE                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37381 000061DC 7501                    	jnz	short fu20
 37382                                  
 37383 000061DE 41                      	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 37384                                  fu20:
 37385                                  	;mov	al,[es:0]
 37386 000061DF 26A00000                	mov	al,[es:arena_signature]
 37387                                  	;cmp	al,'Z'
 37388 000061E3 3C5A                    	cmp	al,arena_signature_end
 37389 000061E5 740C                    	je	short fuE	; 'Z' means this was the last MCB... that's it.
 37390                                  
 37391                                  	;NextMCB es,ax		; Go on forward.
 37392                                  
 37393 000061E7 8CC0                     	mov	ax,es		; NextMCB (macro)
 37394                                  	;add	ax,[es:3]
 37395 000061E9 2603060300              	add	ax,[es:arena_size]
 37396 000061EE 40                      	inc	ax
 37397 000061EF 8EC0                    	mov	es,ax
 37398                                  
 37399 000061F1 EBE2                    	jmp	short fu10
 37400                                  fuE:
 37401 000061F3 F9                      	stc
 37402                                  fuX:
 37403                                  	;popreg	<dx,cx,ax>	; The address is already in ES.
 37404                                  	
 37405 000061F4 5A                      	pop	dx
 37406 000061F5 59                      	pop	cx
 37407                                  	
 37408                                  	;pop	ax
 37409 000061F6 C3                      	retn
 37410                                  
 37411                                  ; -----------------------------------------------------------------------------
 37412                                  ;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
 37413                                  ; -----------------------------------------------------------------------------
 37414                                  ; ENTRY:    AL should be to a valid UMB number
 37415                                  ; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
 37416                                  ; ERROR:    Carry set if couldn't reach UMB (0 or too high)
 37417                                  ; USES:     Flags, ES
 37418                                  ; -----------------------------------------------------------------------------
 37419                                  
 37420                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37421                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6624h
 37422                                  BigFree:
 37423                                  	;pushreg <bx,cx>
 37424                                  	
 37425                                  	;push	bx
 37426 000061F7 51                      	push	cx
 37427                                  
 37428 000061F8 E8CDFF                  	call	findumb			; Returns with CF if err, else ES==MCB
 37429 000061FB 7239                    	jc	short bfX		; (would be "jc bfE"; it just does stc)
 37430                                  
 37431 000061FD 31DB                    	xor	bx,bx			; Segment address of largest free MCB
 37432 000061FF 31C9                    	xor	cx,cx			; Size of largest free MCB
 37433                                  
 37434                                  ; ---------------------------------------------
 37435                                  ; BF10--ES - Current MCB address
 37436                                  ;       BX - Address of largest free MCB so far
 37437                                  ;       CX - Size of largest free MCB so far
 37438                                  ; ---------------------------------------------
 37439                                  
 37440                                  bf10:
 37441 00006201 E85CFE                  	call	isSysMCB		; If we've left the MCB, we're done.
 37442 00006204 7427                    	jz	short bf30
 37443                                  
 37444 00006206 E879FF                  	call	isFreeMCB		; Returns with ZF set if owner is 0
 37445 00006209 750E                    	jnz	short bf20
 37446                                  
 37447                                  	;cmp	cx,[es:3]
 37448 0000620B 263B0E0300              	cmp	cx,[es:arena_size]	; Compare sizes...
 37449 00006210 7F07                    	jg	short bf20		; Unless we're bigger,
 37450                                  
 37451 00006212 8CC3                    	mov	bx,es			; Store this new element's address,
 37452                                  	;mov	cx,[es:3]
 37453 00006214 268B0E0300              	mov	cx,[es:arena_size]	; and its size.
 37454                                  bf20:
 37455                                  	;mov	al,[es:0]
 37456 00006219 26A00000                	mov	al,[es:arena_signature]
 37457                                  	;cmp	al,'Z'  ; 5Ah
 37458 0000621D 3C5A                    	cmp	al,arena_signature_end
 37459 0000621F 740C                    	je	short bf30		; 'Z' means this was the last MCB.
 37460                                  
 37461                                  	;NextMCB es,ax			; Go on forward.
 37462                                  
 37463 00006221 8CC0                    	mov	ax,es 
 37464                                  	;add	ax,[es:3]
 37465 00006223 2603060300              	add	ax,[es:arena_size]
 37466 00006228 40                      	inc	ax
 37467 00006229 8EC0                    	mov	es,ax
 37468                                  
 37469 0000622B EBD4                    	jmp	short bf10
 37470                                  bf30:
 37471 0000622D 8EC3                    	mov	es,bx			; Return the address
 37472 0000622F 89C8                    	mov	ax,cx			; Return the size
 37473 00006231 09DB                    	or	bx,bx
 37474 00006233 7501                    	jnz	short bfX		; (if size==0, there's nothing free)
 37475                                  bfE:
 37476 00006235 F9                      	stc
 37477                                  bfX:
 37478                                  	;popreg	<cx,bx>
 37479                                  
 37480 00006236 59                      	pop	cx
 37481                                  	;pop	bx
 37482                                  
 37483 00006237 C3                      	retn
 37484                                  
 37485                                  ; -----------------------------------------------------------------------------
 37486                                  ;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 37487                                  ; -----------------------------------------------------------------------------
 37488                                  ; ENTRY:    AL should be to a valid UMB number
 37489                                  ; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
 37490                                  ; ERROR:    None
 37491                                  ; USES:     Flags
 37492                                  ; -----------------------------------------------------------------------------
 37493                                  
 37494                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37495                                  isSpecified:
 37496                                  	;push	ax
 37497                                  
 37498 00006238 30FF                    	xor	bh,bh
 37499 0000623A 88C3                    	mov	bl,al
 37500                                  
 37501                                  	;getdata al,DS:UmbUsed[bx]
 37502                                  
 37503 0000623C 1E                      	push	ds
 37504 0000623D 8E1E[E49D]              	mov	ds,[RESSEG]
 37505 00006241 8A87[FB04]              	mov	al,[bx+UmbUsed]
 37506 00006245 1F                      	pop     ds
 37507                                  
 37508 00006246 08C0                    	or	al,al		; Sets ZF if al==0 (ie, if unspecified)
 37509                                  
 37510                                  	;pop	ax
 37511 00006248 C3                      	retn
 37512                                  
 37513                                  ; -----------------------------------------------------------------------------
 37514                                  ;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
 37515                                  ; -----------------------------------------------------------------------------
 37516                                  ; ENTRY:    AX == new size, ES:0 == current MCB
 37517                                  ; EXIT:     None; MCB broken if carry clear
 37518                                  ; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
 37519                                  ; USES:     Flags
 37520                                  ; -----------------------------------------------------------------------------
 37521                                  ; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
 37522                                  ; the specified new size, the split is useless; if it's onnly 0x10 bytes, that
 37523                                  ; 0x10 will be used to make a header that mentions a 0-byte free space, and
 37524                                  ; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
 37525                                  ; minimum for performing a split.
 37526                                  ; -----------------------------------------------------------------------------
 37527                                  
 37528                                  ;MIN_SPLIT_SIZE	equ 20h
 37529                                  
 37530                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37531                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:667Ah
 37532                                  shrinkMCB:
 37533                                  	;pushreg <bx,cx,es>
 37534                                  
 37535                                  	;push	bx
 37536 00006249 51                      	push	cx ; *
 37537 0000624A 26                      	psuh	es ; **
 37538                                  
 37539 0000624B 89C3                    	mov	bx,ax			; Move things around... and
 37540 0000624D 8CC0                    	mov	ax,es			; save this one for later.
 37541                                  
 37542 0000624F 268B0E0300              	mov	cx,[es:arena_size]
 37543 00006254 83E920                  	sub	cx,32 ; sub cx,MIN_SPLIT_SIZE
 37544                                  	;cmp	bx,cx			; {New size} vs {Current Size-20h}
 37545                                  	;ja	short smE		; if wanted_size > cur-20h, abort.
 37546 00006257 39D9                    	cmp	cx,bx
 37547 00006259 723E                    	jb	short smE ; cf = 1 (***)
 37548                                  
 37549                                  	;mov	dl,[es:0]
 37550 0000625B 268A160000              	mov	dl,[es:arena_signature]
 37551                                  
 37552                                  	;;mov	cx,[es:3]
 37553                                  	;mov	cx,[es:arena_size] ; *!
 37554                                  
 37555 00006260 26891E0300              	mov	[es:arena_size],bx
 37556                                  	;mov	byte [es:0],'M' ; 4Dh
 37557 00006265 26C60600004D            	mov	byte [es:arena_signature],'M'
 37558                                  
 37559 0000626B 01D8                    	add	ax,bx
 37560 0000626D 40                      	inc	ax
 37561 0000626E 8EC0                    	mov	es,ax			; Move to new arena area
 37562                                  
 37563                                  	;mov	ax,cx ; !*
 37564 00006270 26A10300                	mov	ax,[es:arena_size] ; *!
 37565 00006274 29D8                    	sub	ax,bx
 37566 00006276 48                      	dec	ax			; And prepare the new size
 37567                                  
 37568                                  	;mov	[es:0],dl
 37569 00006277 2688160000              	mov	[es:arena_signature],dl
 37570                                  	;;mov	word [es:1],0
 37571                                  	;mov	word [es:arena_owner],0
 37572                                  	;mov	[es:3],ax
 37573 0000627C 26A30300                	mov	[es:arena_size],ax
 37574 00006280 B82020                  	mov	ax,'  ' ; mov ax,2020h
 37575                                  	;mov	[es:8],ax
 37576 00006283 26A30800                	mov	[es:arena_name+0],ax
 37577 00006287 26A30A00                	mov	[es:arena_name+2],ax
 37578 0000628B 26A30C00                	mov	[es:arena_name+4],ax
 37579                                  	;mov	[es:14],ax
 37580 0000628F 26A30E00                	mov	[es:arena_name+6],ax
 37581                                  
 37582                                  	;clc
 37583 00006293 31C0                    	xor	ax,ax
 37584 00006295 26A30100                	mov	[es:arena_owner],ax ; 0
 37585                                  	; cf = 0
 37586                                  	;jmp	short smX
 37587                                  smE:
 37588                                  	;stc	 ; cf = 1 (***)
 37589                                  smX:
 37590                                  	;popreg	<es,cx,bx>
 37591 00006299 07                      	pop	es ; **
 37592 0000629A 59                      	pop	cx ; *
 37593 0000629B 5B                      	pop	bx
 37594                                  
 37595 0000629C C3                      	retn
 37596                                  
 37597                                  ; -----------------------------------------------------------------------------
 37598                                  ;*** hideUMB? - hides as appropriate the UMB in CL
 37599                                  ; -----------------------------------------------------------------------------
 37600                                  ; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
 37601                                  ; EXIT:     None; UMB is hidden as necessary
 37602                                  ; ERROR:    None
 37603                                  ; USES:     Flags, AX, CX
 37604                                  ; -----------------------------------------------------------------------------
 37605                                  ; PRIMARY LOGIC:
 37606                                  ;
 37607                                  ; If the UMB is specified in the DH/LH statement, then:
 37608                                  ;    If the largest free segment is too small (check specified size), then:
 37609                                  ;       Pretend it wasn't ever specified, and fall out of this IF.
 37610                                  ;    Else, if largest free segment is LARGER than specified size, then:
 37611                                  ;       If /S was given on the command-line, then:
 37612                                  ;          Break that element into two pieces
 37613                                  ;          Set a flag that we're shrinking
 37614                                  ;       Endif
 37615                                  ;    Endif
 37616                                  ; Endif
 37617                                  ; If the UMB is NOT specified (or was removed by the above):
 37618                                  ;    Hide all free elements in the UMB
 37619                                  ;    If the flag that we're shrinking was set, then:
 37620                                  ;       UN-hide the lower portion of the shrunken UMB
 37621                                  ;    ENDIF
 37622                                  ; ENDIF
 37623                                  ; -----------------------------------------------------------------------------
 37624                                  
 37625                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37626                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:66D7h
 37627                                  hideUMB?:
 37628                                  	;pushreg <bx,dx,es>
 37629                                  
 37630                                  	;push	bx
 37631                                  	;push	dx
 37632                                  	;push	es
 37633                                  
 37634 0000629D 88C8                    	mov	al,cl
 37635 0000629F E896FF                  	call	isSpecified	; Returns ZF set if al's umb was NOT specified
 37636                                  	;jz	short hu?20
 37637                                  	; 17/06/2023
 37638 000062A2 7432                    	jz	short hu?25 ; *
 37639                                  
 37640 000062A4 88C8                    	mov	al,cl		; Retrieve the size of the largest
 37641 000062A6 E84EFF                  	call	BigFree		; free element in AX; put its address in ES
 37642                                  	;jc	short hu?20	; Oops. Errors mean skip this part.
 37643                                  	; 17/06/2023
 37644 000062A9 723B                    	jc	short hu?X ; **
 37645                                  
 37646 000062AB 50                      	push	ax		; TOS==size of BigFree in UMB (popped as BX)
 37647 000062AC 88C8                    	mov	al,cl		; Retrieve the user's specified
 37648 000062AE E88AFE                  	call	GetSize		; minimum size for this umb (into AX)
 37649 000062B1 5B                      	pop	bx		; Now BX==BigFree, AX==Specified Size
 37650                                  
 37651 000062B2 09C0                    	or	ax,ax		; If they didn't specify one,
 37652                                  	;jz	short hu?20	; Skip over all this.
 37653                                  	; 17/06/2023
 37654 000062B4 7530                    	jnz	short hu?X ; **
 37655                                  
 37656 000062B6 39D8                    	cmp	ax,bx		; Ah... if (specified > max free)
 37657 000062B8 7607                    	jbe	short hu?10
 37658                                  
 37659 000062BA 88C8                    	mov	al,cl		;  Then mark that UMB as unused. Nya nya.
 37660 000062BC E898FC                  	call	unMarkUMB
 37661                                  	;jmp	short hu?20 ; ***
 37662                                  	; 17/06/2023
 37663                                  	; ('isSpecified' would return with ZF=1) ; ***
 37664 000062BF EB15                    	jmp	short hu?25
 37665                                  hu?10:
 37666 000062C1 E8B0FE                  	call	isTiny		; Returns ZF clear if user specified /S
 37667                                  	;jz	short hu?20
 37668                                  	; 17/06/2023
 37669                                  	; ('isSpecified' would return with ZF=0) ; **
 37670 000062C4 7420                    	jz	short hu?X
 37671                                  
 37672 000062C6 E880FF                  	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
 37673                                  	;jc	short hu?20	; Ah... if didn't shrink after all, skip this:
 37674                                  	; 17/06/2023
 37675                                  	; ('isSpecified' would return with ZF=0) ; **
 37676 000062C9 721B                    	jc	short hu?X
 37677                                  
 37678 000062CB 8CC2                    	mov	dx,es
 37679 000062CD EB09                    	jmp	short hu?30	; Skip the spec check.. we wanna hide this one.
 37680                                  hu?20:
 37681                                  	;mov	al,cl
 37682 000062CF 89C8                    	mov	ax,cx
 37683 000062D1 E864FF                  	call	isSpecified	; If they specified this UMB, we're done...
 37684 000062D4 7510                    	jnz	short hu?X ; **	; so leave.
 37685                                  hu?25:	; 17/06/2023 ; *
 37686 000062D6 31D2                    	xor	dx,dx
 37687                                  hu?30:
 37688 000062D8 88C8                    	mov	al,cl
 37689                                  
 37690 000062DA E870FE                  	call	hideUMB		; Hides everything in UMB #al
 37691                                  
 37692 000062DD 09D2                    	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
 37693 000062DF 7405                    	jz	short hu?X	; So we should leave.
 37694                                  
 37695 000062E1 8EC2                    	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
 37696 000062E3 E8C7FE                  	call	unHideMCB	; Un-hides the lower portion of that MCB.
 37697                                  hu?X:
 37698                                  	;popreg	<es,dx,bx>
 37699                                  
 37700                                  	;pop	es
 37701                                  	;pop	dx
 37702                                  	;pop	bx
 37703                                  
 37704 000062E6 C3                      	retn
 37705                                  
 37706                                  ; -----------------------------------------------------------------------------
 37707                                  ;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
 37708                                  ; -----------------------------------------------------------------------------
 37709                                  ; ENTRY:    None
 37710                                  ; EXIT:     Carry is clear if UMBs are available, or set if they are not
 37711                                  ; ERROR:    None
 37712                                  ; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
 37713                                  ; -----------------------------------------------------------------------------
 37714                                  
 37715                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37716                                  UmbTest:
 37717                                  	;pushreg <ax,bx,ds,es>
 37718                                  	
 37719                                  	;push	ax
 37720                                  	;push	bx
 37721                                  	;push	ds
 37722                                  	;push	es
 37723                                  
 37724 000062E7 E88CFB                  	call	fm_link		; Link in UMBs (if not already linked)
 37725 000062EA E80600                  	call	WalkMem		; Check to see if they're really linked
 37726 000062ED 9C                      	pushf			; And remember what we found out
 37727 000062EE E89CFB                  	call	fm_unlink	; Unlink UMBs (if WE have linked 'em)
 37728 000062F1 9D                      	popf			; And restore what we found out.
 37729                                  
 37730                                  	;popreg	<es,ds,bx,ax>
 37731                                  	
 37732                                  	;pop	es
 37733                                  	;pop	ds
 37734                                  	;pop	bx
 37735                                  	;pop	ax
 37736                                  	
 37737 000062F2 C3                      	retn
 37738                                  
 37739                                  ; -----------------------------------------------------------------------------
 37740                                  ;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
 37741                                  ; -----------------------------------------------------------------------------
 37742                                  ; ENTRY:    None
 37743                                  ; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
 37744                                  ; ERROR:    None
 37745                                  ; USES:     Flags
 37746                                  ; -----------------------------------------------------------------------------
 37747                                  
 37748                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37749                                  WalkMem:
 37750                                  	;pushreg <ax,bx,es>
 37751                                  	
 37752                                  	;push	ax
 37753                                  	;push	bx
 37754 000062F3 06                      	push	es
 37755                                  
 37756 000062F4 B452                    	mov	ah,52h ; DOS_GET_DOS_LISTS
 37757                                  				; Call int 21h, function 52h...
 37758 000062F6 CD21                    	int	21h
 37759                                  
 37760 000062F8 268B47FE                	mov	ax,[es:bx-2]
 37761                                  	;mov	es,ax ; *
 37762                                  
 37763                                  ; ------------------------------
 37764                                  ; UM10: ES = Current MCB pointer
 37765                                  ; ------------------------------
 37766                                  
 37767                                  um10:	
 37768 000062FC 8EC0                    	mov	es,ax ; *
 37769                                  
 37770                                  	;mov	al,[es:0]
 37771 000062FE 26A00000                	mov	al,[es:arena_signature]
 37772                                  	;cmp	al,'Z' ; 5Ah
 37773 00006302 3C5A                    	cmp	al,arena_signature_end
 37774 00006304 740A                    	je	short um20	; If signature == 'Z', hay no more.
 37775                                  
 37776                                  	;NextMCB es,bx		; Move to the next MCB
 37777                                  	
 37778                                  	;mov	bx,es
 37779                                  	;;add	bx,[es:3]
 37780                                  	;add	bx,[es:arena_size]
 37781                                  	;inc	bx
 37782                                  	;mov	es,bx
 37783 00006306 8CC0                    	mov	ax,es
 37784 00006308 2603060300              	add	ax,[es:arena_size]
 37785 0000630D 40                      	inc	ax
 37786                                  	;mov	es,ax ; *
 37787                                  
 37788 0000630E EBEC                    	jmp	short um10	; And restart the loop.
 37789                                  um20:
 37790 00006310 8CC0                    	mov	ax,es
 37791 00006312 3DFF9F                  	cmp	ax,9FFFh	; This sets CF if ax < 9FFF.
 37792                                  
 37793                                  	;popreg	<es,bx,ax>
 37794 00006315 07                      	pop	es
 37795                                  	;pop	bx
 37796                                  	;pop	ax
 37797                                  
 37798 00006316 C3                      	retn
 37799                                  
 37800                                  ; -----------------------------------------------------------------------------
 37801                                  ;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
 37802                                  ; -----------------------------------------------------------------------------
 37803                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 37804                                  ; EXIT:     None
 37805                                  ; ERROR:    None
 37806                                  ; USES:     AX, BX
 37807                                  ; -----------------------------------------------------------------------------
 37808                                  
 37809                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37810                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:681Ch
 37811                                  hl_unlink:
 37812 00006317 1E                      	push	ds ; *
 37813                                  
 37814 00006318 30FF                    	xor	bh,bh
 37815                                  	;getdata bl,fm_umb	; Restore original link-state
 37816                                  
 37817                                  	;push	ds
 37818 0000631A 8E1E[E49D]              	mov	ds,[RESSEG]
 37819 0000631E 8A1E[2B05]              	mov	bl,[fm_umb]	; Restore original link-state
 37820                                  	;pop	ds
 37821                                  	
 37822 00006322 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 37823 00006325 CD21                    	int	21h
 37824                                  
 37825 00006327 30FF                    	xor	bh,bh
 37826                                  
 37827                                  	;getdata bl,fm_strat	; Restore original mem-alloc strategy
 37828                                  
 37829                                  	;push	ds
 37830                                  	;mov	ds,[RESSEG]
 37831 00006329 8A1E[2C05]              	mov	bl,[fm_strat]	;Restore original mem-alloc strategy
 37832                                  	;pop	ds
 37833                                  
 37834 0000632D B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 37835 00006330 CD21                    	int	21h
 37836                                  
 37837 00006332 1F                      	pop	ds ; *
 37838                                  
 37839 00006333 C3                      	retn
 37840                                  
 37841                                  ;============================================================================
 37842                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 37843                                  ;============================================================================
 37844                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37845                                  
 37846                                  ; This is a new module added to support loading programs into UMBs provided
 37847                                  ; by DOS 5.0. 
 37848                                  ; ---------------------------------------------------------------------------
 37849                                  ; Usage:
 37850                                  ;
 37851                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 37852                                  ;
 37853                                  ; <filespec> has to be a filename that is not wildcarded.
 37854                                  
 37855                                  ; ---------------------------------------------------------------------------
 37856                                  ;
 37857                                  ;	Revision History
 37858                                  ;	================
 37859                                  ;
 37860                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 37861                                  ;				loading and high and also remember
 37862                                  ;				current UMB state.
 37863                                  ;
 37864                                  ;	M016	SR	08/09/90	Give special error message on attempt
 37865                                  ;				to loadhigh batch files and invalid
 37866                                  ;				filename on Loadhigh command line.
 37867                                  ;
 37868                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 37869                                  ;				after the program name also as part
 37870                                  ;				of the command line being passed to
 37871                                  ;				the program to be invoked.
 37872                                  ;
 37873                                  ; ---------------------------------------------------------------------------
 37874                                  
 37875                                  ; ---------------------------------------------------------------------------
 37876                                  ;
 37877                                  ;	include highload.inc		; Grab code for ParseVar and such
 37878                                  
 37879                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 37880                                  
 37881                                  ;
 37882                                  ; ---------------------------------------------------------------------------
 37883                                  
 37884                                  ;****	LoadHigh -- Main routine for Loadhigh command
 37885                                  ;
 37886                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 37887                                  ;		CS = DS = SS = TRANGROUP
 37888                                  ;
 37889                                  ;	EXIT	None
 37890                                  ;
 37891                                  ;	USED	ax, bx, cx, dx, si, di, es
 37892                                  ;
 37893                                  ;	ERROR EXITS
 37894                                  ;		Message pointers are setup at the error locations and then
 37895                                  ;	we jump back to CERROR which is the transient error recycle point.
 37896                                  ;	Apart from parse errors, the other errors handled are too many
 37897                                  ;	switches anf invalid filenames.
 37898                                  ;
 37899                                  ;	EFFECTS
 37900                                  ;		The allocation strategy and the state of the arena chain are
 37901                                  ;	put in the requested state according to the given options. If a 
 37902                                  ;	filename is also given, it is executed as well.
 37903                                  ; ---------------------------------------------------------------------------
 37904                                  
 37905                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37906                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 37907                                  
 37908                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 37909                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:683Fh
 37910                                  LoadHigh:
 37911 00006334 1E                      	push	ds
 37912 00006335 07                      	pop	es
 37913                                  	
 37914                                  	; 16/06/2023
 37915                                  	;call	SkipLhDelims	; MSDOS 5.0 !
 37916                                  
 37917                                  ;Get command tail to be passed to the program. This includes any whitespace
 37918                                  ;chars between the program name and its parameters as well.
 37919                                  ;On return, ds:si points at the start of the command tail.
 37920                                  
 37921                                  	; 16/06/2023
 37922                                  	;push	si		; MSDOS 5.0 !
 37923 00006336 E81300                  	call	ParseLhCmd
 37924                                  	;pop	si		; MSDOS 5.0 !	
 37925 00006339 720E                    	jc	short LhErr
 37926                                  	
 37927 0000633B E86500                  	call	SetupCmdLine		;setup pgm's command line
 37928                                  
 37929 0000633E E88700                  	call	SetupPath		;setup path for file
 37930 00006341 7206                    	jc	short LhErr		;file not found
 37931                                  
 37932                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 37933                                  ;be reset after return from the Exec
 37934                                  ;We will also set a resident flag to indicate that UMBs were activated for
 37935                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 37936                                  
 37937 00006343 E8AFFD                  	call	HideUMBs		;prepare upper-memory for load
 37938                                  
 37939 00006346 E901CB                  	jmp	LH_EXECUTE		;go and exec file ;M051
 37940                                  
 37941                                  LhErr:
 37942                                  ;The error message has been setup at this stage
 37943                                  
 37944 00006349 E951CB                  	jmp	cerror			;print error message and recycle 
 37945                                  
 37946                                  ; ---------------------------------------------------------------------------
 37947                                  					
 37948                                  ;*** 	ParseLhCmd - parses any command-line options
 37949                                  ;
 37950                                  ;	ENTRY	None
 37951                                  ;
 37952                                  ;	EXIT	Carry clear -- command line parsed successfully
 37953                                  ;		Carry set -- appropriate error message setup
 37954                                  ;
 37955                                  ;	USED	ax, si
 37956                                  ;
 37957                                  ;	EFFECTS
 37958                                  ;		Options set up (see highvar.inc)
 37959                                  ;		Filename to be executed setup
 37960                                  ;
 37961                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 37962                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 37963                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 37964                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 37965                                  ;	prepare the command-line for that program.
 37966                                  ; ---------------------------------------------------------------------------
 37967                                  
 37968                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 37969                                  %if 0
 37970                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37971                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 37972                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 37973                                  	; 11/06/2023
 37974                                  ParseLhCmd:
 37975                                  	;mov	si,81h
 37976                                  	mov	si,iCmdLine	;ds:si points at command line
 37977                                  
 37978                                  	mov	word [COMSW],0
 37979                                  	mov	di,Parse_LoadHi
 37980                                  	xor	cx,cx
 37981                                  	call	Parse_With_Msg
 37982                                  
 37983                                  	; 11/06/2023
 37984                                  	;cmp	ax,0FFFFh ; -1
 37985                                  	;jz	short PLhCmd2
 37986                                  	;cmp	ax,0
 37987                                  	;jnz	short PLhCmd1
 37988                                  	; 11/06/2023
 37989                                  	inc	ax ; cmp ax,-1
 37990                                  	jz	short PLhCmd2 ; 0FFFFh -> 0
 37991                                  	dec	ax ; cmp ax,0
 37992                                  	jnz	short PLhCmd1 ; 1 -> 0
 37993                                  	; ax = 0
 37994                                  
 37995                                  	mov	bx,dx
 37996                                  	; 14/04/2023
 37997                                  	;call	LhCopyFilename
 37998                                  	;; 13/04/2023
 37999                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 38000                                  	;;jmp	short PLhCmd2
 38001                                  	;retn
 38002                                  	; 14/04/2023
 38003                                  	jmp	short LhCopyFilename
 38004                                  PLhCmd1:
 38005                                  	stc
 38006                                  PLhCmd2:
 38007                                  	retn
 38008                                  %endif
 38009                                  
 38010                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38011                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6857h
 38012                                  	; MSDOS 6.0
 38013                                  ParseLhCmd:
 38014                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38015                                  	
 38016                                  	;mov	si,81h
 38017 0000634C BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 38018                                  
 38019                                  	; es = ds (from 'LoadHigh') 
 38020                                  	;push	es		;Store ES 'cause we're gonna change it:
 38021                                  
 38022                                  	;push	ds
 38023                                  	;pop	es		;Make sure es:si points to cmd line as well
 38024                                  
 38025 0000634F E8ACFA                  	call	InitVar		;Initialize data for ParseVar
 38026                                  
 38027 00006352 E84AFB                  	call	ParseVar	;And parse the command line
 38028                                  
 38029                                  	;pop	es		;Restore ES now; we're done with it.
 38030                                  
 38031 00006355 7317                    	jnc	short plcC	;If no error, continue on our way.
 38032                                  
 38033 00006357 83F802                  	cmp	ax,2 ; PV_BadUMB
 38034                                  				;Bad UMB passed?
 38035 0000635A 7505                    	jne	short plc10
 38036                                  	;mov	dx,offset TRANGROUP:LhBadUMB_Ptr
 38037 0000635C BA[8594]                	mov	dx,LhBadUMB_Ptr
 38038 0000635F F9                      	stc
 38039 00006360 C3                      	retn
 38040                                  plc10:	
 38041                                  	;mov	dx,offset TRANGROUP:LhInvSwt_Ptr
 38042 00006361 BA[8294]                	mov	dx,LhInvSwt_Ptr
 38043 00006364 83F803                  	cmp	ax,3 ; PV_InvSwt
 38044                                  				;Unrecognized switch passed?
 38045 00006367 7403                    	je	short plc20
 38046                                  	;mov	dx,offset TRANGROUP:LhInvArg_Ptr
 38047 00006369 BA[7C94]                	mov	dx,LhInvArg_Ptr
 38048                                  plc20:
 38049 0000636C F9                      	stc
 38050 0000636D C3                      	retn
 38051                                  plcC:
 38052                                  	;call	LhCopyFilename	;copy filename into our buffer
 38053                                  	;retn			;Return-- carry=status
 38054                                  	; 16/06/2023
 38055                                  	;jmp	short LhCopyFilename
 38056                                  
 38057                                  ; ---------------------------------------------------------------------------
 38058                                  
 38059                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38060                                  
 38061                                  ; ---------------------------------------------------------------------------
 38062                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 38063                                  ; ---------------------------------------------------------------------------
 38064                                  
 38065                                  	; 13/04/2023
 38066                                  	; MSDOS 5.0 COMMAND.COM only !
 38067                                  	; (Procedure names are not from original Microsoft source code!)
 38068                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38069                                  ;set_strategy:
 38070                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 38071                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38072                                  	;		; AL = function code: get allocation strategy
 38073                                  	;mov	bx,ax
 38074                                  	;or	bx,80h
 38075                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 38076                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38077                                  	;		; AL = function code: set allocation strategy
 38078                                  	;retn
 38079                                  
 38080                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38081                                  ;set_umblink:
 38082                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 38083                                  	;mov	bx,1
 38084                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38085                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 38086                                  	;retn
 38087                                  
 38088                                  ; ---------------------------------------------------------------------------
 38089                                  
 38090                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 38091                                  ;
 38092                                  ;	ENTRY	ds:si points at primary argument (filename)
 38093                                  ;
 38094                                  ;	EXIT	Carry set -- filename has wildcards. In this event, DX will
 38095                                  ;				already contain an appropriate error number.
 38096                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 38097                                  ;				points to first character (most likely space)
 38098                                  ;				after filename.
 38099                                  ;
 38100                                  ;	USED	ax, si
 38101                                  ;
 38102                                  ;	EFFECTS
 38103                                  ;		ExecPath contains the filename
 38104                                  ;
 38105                                  ; If there are any wildcards in the filename, then we have an error
 38106                                  ; ---------------------------------------------------------------------------
 38107                                  
 38108                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38109                                  %if 0
 38110                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38111                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 38112                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38113                                  LhCopyFilename:
 38114                                  	push	ds
 38115                                  	push	si
 38116                                  	push	di
 38117                                  	lds	si,[bx+4]
 38118                                  	mov	di,EXECPATH
 38119                                  lhcpfn1:
 38120                                  	lodsb
 38121                                  	cmp	al,2Ah ; '*'
 38122                                  	jz	short lhfilerr
 38123                                  	cmp	al,3Fh ; '?'
 38124                                  	jz	short lhfilerr
 38125                                  	stosb
 38126                                  	or	al,al
 38127                                  	jnz	short lhcpfn1
 38128                                  	; 14/04/2023
 38129                                  	; cf = 0
 38130                                  	;clc
 38131                                  lhfilerr2:
 38132                                  	pop	di
 38133                                  	pop	si
 38134                                  	pop	ds
 38135                                  	retn
 38136                                  lhfilerr:
 38137                                  	mov	dx,LhInvFil_Ptr
 38138                                  	stc
 38139                                  	jmp	short lhfilerr2
 38140                                  
 38141                                  %endif
 38142                                  
 38143                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38144                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6881h
 38145                                  	; MSDOS 6.0
 38146                                  LhCopyFilename:
 38147                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38148                                  
 38149                                  	;mov	di,offset TRANGROUP:ExecPath
 38150 0000636E BF[0C9D]                	mov	di,EXECPATH
 38151                                  
 38152                                  	;mov	cx,0	; Copied zero characters
 38153 00006371 29C9                    	sub	cx,cx
 38154                                  ;@@:
 38155                                  lhcpfn1:
 38156 00006373 AC                      	lodsb
 38157 00006374 3C2A                    	cmp	al,'*'			;wildcard?
 38158 00006376 7421                    	je	short lhfilerr		;yes, error
 38159 00006378 3C3F                    	cmp	al,'?'			;wildcard?
 38160 0000637A 741D                    	je	short lhfilerr		;yes, error
 38161                                  
 38162 0000637C 3C0D                    	cmp	al,0Dh			;carriage return?
 38163                                  	;jz	@f
 38164 0000637E 7410                    	je	short lhcpfn2
 38165 00006380 3C2F                    	cmp	al,'/' ; SwitChar	;'/'?
 38166                                  	;jz	@f
 38167 00006382 740C                    	je	short lhcpfn2
 38168 00006384 08C0                    	or	al,al			;EOS?
 38169                                  	;jz	@f
 38170 00006386 7408                    	jz	short lhcpfn2
 38171 00006388 3C20                    	cmp	al,' '			;Space?
 38172                                  	;jz	@f
 38173 0000638A 7404                    	je	short lhcpfn2
 38174                                  	
 38175                                  	;or	al,al
 38176                                  	;;jz	@f
 38177                                  	;je	short lhcpfn2	
 38178                                  
 38179 0000638C AA                      	stosb				;store char
 38180 0000638D 41                      	inc	cx			;And remember that we did one more
 38181                                  	;jmp	short @b
 38182 0000638E EBE3                    	jmp	short lhcpfn1
 38183                                  ;@@:
 38184                                  lhcpfn2:
 38185 00006390 30C0                    	xor	al,al			;Indicate EOS reached
 38186 00006392 AA                      	stosb				;store char
 38187                                  
 38188 00006393 09C9                    	or	cx,cx			;If we didn't copy any characters,
 38189 00006395 7407                    	jz	short lhmissing	; they didn't give a filename.
 38190                                  
 38191 00006397 4E                      	dec	si			;Move back to the delimiting character
 38192                                  	; cf = 0
 38193                                  	;clc				;And indicate no error occurred
 38194 00006398 C3                      	retn
 38195                                  lhfilerr:
 38196                                  	;mov	dx,offset TRANGROUP:LhInvFil_Ptr
 38197 00006399 BA[7694]                	mov	dx,LhInvFil_Ptr		;"Invalid Filename" ; M016
 38198 0000639C F9                      	stc
 38199 0000639D C3                      	retn
 38200                                  lhmissing:
 38201                                  	;mov	dx,offset TRANGROUP:ReqParmMiss
 38202 0000639E BA[7F94]                	mov	dx,ReqParmMiss		;"Required parm missing"
 38203 000063A1 F9                      	stc
 38204 000063A2 C3                      	retn
 38205                                  
 38206                                  ; ---------------------------------------------------------------------------
 38207                                  	
 38208                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38209                                  %if 0
 38210                                  	; 14/04/2023
 38211                                  	; 13/04/2023
 38212                                  	; MSDOS 5.0 COMMAND.COM only !
 38213                                  	; (Procedure name is not from original Microsoft source code!)
 38214                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38215                                  set_strategy:
 38216                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38217                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38218                                  			; AL = function code: get allocation strategy
 38219                                  	mov	bx,ax
 38220                                  	or	bx,80h
 38221                                  	mov	ax,5801h	; DOS_SET_STRATEGY
 38222                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38223                                  			; AL = function code: set allocation strategy
 38224                                  	retn
 38225                                  
 38226                                  ; ---------------------------------------------------------------------------
 38227                                  
 38228                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38229                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 38230                                  	; MSDOS 5.0 COMMAND.COM only !
 38231                                  	; (Procedure name is not from original Microsoft source code!)
 38232                                  SkipLhDelims:
 38233                                  	mov	si,81h
 38234                                  	call	scanoff
 38235                                  stfn1:
 38236                                  	lodsb
 38237                                  	call	DELIM
 38238                                  	jz	short stfn2
 38239                                  	cmp	al,0Dh
 38240                                  	jz	short stfn2
 38241                                  	cmp	al,[SWITCHAR]
 38242                                  	jnz	short stfn1
 38243                                  stfn2:
 38244                                  	dec	si
 38245                                  	retn
 38246                                  
 38247                                  %endif
 38248                                  
 38249                                  ; ---------------------------------------------------------------------------
 38250                                  
 38251                                  ;***	SetupCmdLine -- prepare command line for the program
 38252                                  ;
 38253                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 38254                                  ;
 38255                                  ;	EXIT	None
 38256                                  ;
 38257                                  ;	USED
 38258                                  ;
 38259                                  ;	EFFECTS		
 38260                                  ;		The rest of the command line following the pgm name is 
 38261                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 38262                                  ;	and a new command line length is put in
 38263                                  ; ---------------------------------------------------------------------------
 38264                                  
 38265                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38266                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 38267                                  
 38268                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38269                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68BEh
 38270                                  SetupCmdLine:
 38271                                  	;mov	di,81h
 38272 000063A3 BF8100                  	mov	di,iCmdLine
 38273 000063A6 30C9                    	xor	cl,cl
 38274 000063A8 FEC9                    	dec	cl			;just CR means count = 0
 38275                                  SetCmdL1:
 38276 000063AA AC                      	lodsb
 38277 000063AB AA                      	stosb
 38278 000063AC FEC1                    	inc	cl			;update count
 38279                                  	
 38280                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38281                                  	; MSDOS 6.0
 38282                                  	; 14/04/2023
 38283                                  	; * ; MSDOS 6.0 only !
 38284 000063AE 08C0                    	or	al,al	; *
 38285 000063B0 7404                    	jz	short SetCmdL2 ; *
 38286                                  	
 38287 000063B2 3C0D                    	cmp	al,0Dh			;carriage return?
 38288 000063B4 75F4                    	jnz	short SetCmdL1		;no, continue storing
 38289                                  SetCmdL2:
 38290 000063B6 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 38291 000063BB C3                      	retn
 38292                                  
 38293                                  ; ---------------------------------------------------------------------------
 38294                                  
 38295                                  ;***	LhSetupErrMsg -- Sets up error messages
 38296                                  ;
 38297                                  ;	ENTRY	ax = error message number
 38298                                  ;
 38299                                  ;	EXIT	None
 38300                                  ;
 38301                                  ;	USED	dx
 38302                                  ;
 38303                                  ;	EFFECTS
 38304                                  ;		Everything setup to display error message
 38305                                  ; ---------------------------------------------------------------------------
 38306                                  	
 38307                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38308                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38309                                  LhSetupErrMsg:
 38310 000063BC C606[0192]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 38311 000063C1 BA[0392]                	mov	dx,extend_buf_ptr
 38312 000063C4 A3[0392]                	mov	[extend_buf_ptr],ax
 38313 000063C7 C3                      	retn
 38314                                  
 38315                                  ; ---------------------------------------------------------------------------
 38316                                  
 38317                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38318                                  %if 0
 38319                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38320                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 38321                                  	; MSDOS 5.0 COMMAND.COM only !
 38322                                  	; (Procedure name is not from original Microsoft source code!)
 38323                                  check_umblink:
 38324                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38325                                  	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38326                                  			 ; AL = function code: get allocation strategy
 38327                                  	mov	bl,al
 38328                                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 38329                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38330                                  			; AL = function code: (DOS 5beta) get UMB link state
 38331                                  	mov	bh,al
 38332                                  	xchg	ax,bx
 38333                                  	rol	al,1
 38334                                  	and	al,1
 38335                                  	shl	ah,1
 38336                                  	or	al,ah
 38337                                  	retn
 38338                                  
 38339                                  ; ---------------------------------------------------------------------------
 38340                                  
 38341                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38342                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 38343                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38344                                  HideUMBs:
 38345                                  	push	ds
 38346                                  	call	check_umblink
 38347                                  	mov	ds,[RESSEG]
 38348                                  	mov	[fInHigh],al
 38349                                  	or	byte [fInHigh],80h
 38350                                  	pop	ds
 38351                                  	call	set_strategy
 38352                                  	;call	set_umblink
 38353                                  	;retn
 38354                                  	; 14/04/023
 38355                                  	;jmp	short set_ubmlink
 38356                                  
 38357                                  ; ---------------------------------------------------------------------------
 38358                                  
 38359                                  	; 14/04/2023
 38360                                  	; 13/04/2023
 38361                                  	; MSDOS 5.0 COMMAND.COM only !
 38362                                  	; (Procedure name is not from original Microsoft source code!)
 38363                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38364                                  set_umblink:
 38365                                  	mov	ax,5803h	; DOS_SET_UMBLINK
 38366                                  	mov	bx,1
 38367                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38368                                  			; AL = function code: (DOS 5beta) set UMB link state
 38369                                  	retn
 38370                                  %endif
 38371                                  
 38372                                  ; ---------------------------------------------------------------------------
 38373                                  
 38374                                  ;***	SetupPath -- Do path search for the file to be executed
 38375                                  ;
 38376                                  ;	ENTRY	None
 38377                                  ;
 38378                                  ;	EXIT	Carry set if file not found or not executable file
 38379                                  ;
 38380                                  ;	EFFECTS
 38381                                  ;		ExecPath contains the full path of the file to be executed
 38382                                  ; ---------------------------------------------------------------------------
 38383                                  
 38384                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38385                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 38386                                  
 38387                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38388                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68E3h
 38389                                  SetupPath:
 38390                                  
 38391                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 38392                                  ;because the path search routine that we are about to invoke expects the
 38393                                  ;filename to search for to be argv[0].
 38394                                  ;
 38395                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 38396                                  ;over it by doing the whole move again (smaller, of course, this time).
 38397                                  
 38398                                  
 38399                                  	;mov	ax,arg.argvcnt		;total number of arguments
 38400                                  	; 14/04/2023
 38401                                  	;mov	ax,[ARG_ARGVCNT]
 38402 000063C8 A1[76A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 38403                                  
 38404 000063CB 48                      	dec	ax			;less one - skip "LoadHigh"
 38405                                  	;mov	bx,SIZE Argv_ele
 38406 000063CC BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 38407                                  	;mov	bx,11
 38408 000063CF F7E3                    	mul	bx			;dx:ax = size of argument lists
 38409                                  
 38410                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38411                                  	; --------------------------------------
 38412                                  	; MSDOS 6.0
 38413                                  
 38414                                  	;getdata cl,fm_argc		;CL = number of arguments to skip
 38415 000063D1 1E                      	push	ds              ; getdata (macro)
 38416 000063D2 8E1E[E49D]              	mov	ds,[RESSEG]
 38417 000063D6 8A0E[2D05]              	mov	cl,[fm_argc]
 38418 000063DA 1F                      	pop	ds
 38419                                  	
 38420 000063DB FEC1                    	inc	cl			;Skip one arg, to get over "lh"
 38421                                  
 38422                                  ;Move argv[1]..argv[n] to argv[0]..argv[n-1]. Here, AX == the overall size
 38423                                  ;of the argument lists.
 38424                                  
 38425                                  argloop:
 38426 000063DD E31B                    	jcxz	argdone			;If we've finished copying args, leave.
 38427                                  
 38428 000063DF 49                      	dec	cx			;One less time we'll go through this.
 38429                                  
 38430 000063E0 50                      	push	ax			;Copy ( size of remaining list ) bytes
 38431 000063E1 51                      	push	cx			;And remember how many args there were
 38432                                  
 38433                                  	; --------------------------------------
 38434                                  
 38435                                  	; 14/04/2023
 38436 000063E2 89C1                    	mov	cx,ax			;size to move
 38437                                  
 38438                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 38439                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 38440 000063E4 BF[B6A2]                	mov	di,ARG	
 38441 000063E7 89FE                    	mov	si,di			;
 38442                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 38443 000063E9 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 38444                                  	
 38445                                  	; 14/04/2023
 38446                                  	;mov	cx,ax
 38447                                  
 38448 000063EC FC                      	cld
 38449 000063ED F3A4                    	rep	movsb			;Move the argument list
 38450                                  	
 38451                                  	;dec	arg.argvcnt		;Fake one less argument, and
 38452                                  	;dec	word [ARG_ARGVCNT]
 38453 000063EF FF0E[76A5]              	dec	word [ARG+ARG_UNIT.argvcnt]
 38454                                  
 38455                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38456                                  	; --------------------------------------
 38457                                  	; MSDOS 6.0
 38458                                  	
 38459                                  	;sub	ax,ARGV_ELE.SIZE ; 11	;there's one argument we don't copy.
 38460                                  
 38461 000063F3 59                      	pop	cx
 38462 000063F4 58                      	pop	ax			;Restore the size of the arg list
 38463                                  	; 17/06/2023
 38464                                  	;jmp	short argloop
 38465                                  	
 38466                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38467 000063F5 83E80B                  	sub	ax,ARGV_ELE.SIZE ; 11
 38468 000063F8 77E3                    	ja	short argloop
 38469                                  	; --------------------------------------
 38470                                  	
 38471                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 38472                                  
 38473                                  	; 17/06/2023
 38474                                  argdone:
 38475 000063FA E8C3D2                  	call	path_search		;look in the path
 38476                                  
 38477                                  ;ax = 0, no file found
 38478                                  ;ax < 4, batch file found -- cant be executed
 38479                                  ;ax = 4,8 => .com or .exe file found
 38480                                  
 38481 000063FD 09C0                    	or	ax,ax			;any file found?
 38482 000063FF 740B                    	jz	short no_exec_file	;no, error
 38483                                  
 38484 00006401 83F804                  	cmp	ax,4			;executable file?
 38485                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 38486                                  	;clc
 38487                                  	;retn
 38488                                  	; 14/04/2023
 38489 00006404 7201                    	jb	short no_exec_bat
 38490 00006406 C3                      	retn 
 38491                                  
 38492                                  no_exec_bat:
 38493 00006407 BA[7394]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 38494 0000640A EB06                    	jmp	short lhsp_errret	;return error; M016
 38495                                  
 38496                                  no_exec_file:
 38497 0000640C B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 38498 0000640F E8AAFF                  	call	LhSetupErrMsg		;setup error message
 38499                                  lhsp_errret:				; M016
 38500 00006412 F9                      	stc
 38501 00006413 C3                      	retn
 38502                                  
 38503                                  ;============================================================================
 38504                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 38505                                  ;============================================================================
 38506                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38507                                  
 38508                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 38509                                  
 38510                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38511                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6930h
 38512                                  
 38513                                  ; ---------------------------------------------------------------------------
 38514                                  ; Class 3 message table/structure
 38515                                  ; ---------------------------------------------------------------------------
 38516                                  
 38517                                  $M_CLASS_3_STRUC:
 38518 00006414 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 38519                                  	;dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 38520                                  	;db 162			; Total number of messages
 38521                                  	; 17/06/2023
 38522 00006415 0616                    	dw 1606h		; MSDOS 6.22 COMMAND.COM (hb=22,lb=6)	
 38523 00006417 BB                      	db 187			; Total number of messages
 38524                                  $M_ID_3_1:
 38525                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 38526 00006418 FC03                    	dw 1020			; Message Number = 1020
 38527                                  	;dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 38528                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38529 0000641A EC02                    	dw MSG_1020-$+2 ; 2ECh	; Message offset from message number (6934h+02ECh=6C20h)
 38530                                  $M_ID_3_2:
 38531 0000641C F703                    	dw 1015			; Message Number = 1015
 38532                                  	;dw MSG_1015-$+2 ; 294h ; Message offset from message number (5A4Ch+0294h=5CE0h)
 38533                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38534 0000641E F802                    	dw MSG_1015-$+2 ; 2F8h	; Message offset from message number (6938h+02F8h=6C30h)
 38535                                  $M_ID_3_3:	; 26/04/2023
 38536                                  			; 17/06/2023
 38537 00006420 EC031803                	dw 1004,MSG_1004-$ ; 792
 38538 00006424 02042E03                	dw 1026,MSG_1026-$ ; 814
 38539 00006428 07043E03                	dw 1031,MSG_1031-$ ; 830
 38540 0000642C 0B044903                	dw 1035,MSG_1035-$ ; 841
 38541 00006430 26045403                	dw 1062,MSG_1062-$ ; 852
 38542 00006434 04045F03                	dw 1028,MSG_1028-$ ; 863
 38543 00006438 15047D03                	dw 1045,MSG_1045-$ ; 893
 38544 0000643C 11049603                	dw 1041,MSG_1041-$ ; 918
 38545 00006440 1204B403                	dw 1042,MSG_1042-$ ; 948
 38546                                  $M_ID_3_12:
 38547 00006444 1304CB03                	dw 1043,MSG_1043-$ ; 971
 38548 00006448 EA03E703                	dw 1002,MSG_1002-$ ; 999
 38549 0000644C EB030B04                	dw 1003,MSG_1003-$ ; 1035
 38550 00006450 EF032304                	dw 1007,MSG_1007-$ ; 1059
 38551 00006454 F0033A04                	dw 1008,MSG_1008-$ ; 1082
 38552 00006458 F1034C04                	dw 1009,MSG_1009-$ ; 1100
 38553 0000645C F2035D04                	dw 1010,MSG_1010-$ ; 1117
 38554 00006460 F3037904                	dw 1011,MSG_1011-$ ; 1145
 38555 00006464 F6039004                	dw 1014,MSG_1014-$ ; 1168
 38556 00006468 F8039D04                	dw 1016,MSG_1016-$ ; 1181
 38557 0000646C F903C304                	dw 1017,MSG_1017-$ ; 1219
 38558 00006470 FA03E404                	dw 1018,MSG_1018-$ ; 1252
 38559                                  $M_ID_3_24:
 38560 00006474 FB03F404                	dw 1019,MSG_1019-$ ; 1268
 38561 00006478 FD03FC04                	dw 1021,MSG_1021-$ ; 1276
 38562 0000647C FE031605                	dw 1022,MSG_1022-$ ; 1302
 38563 00006480 FF033905                	dw 1023,MSG_1023-$ ; 1337
 38564 00006484 00046105                	dw 1024,MSG_1024-$ ; 1377
 38565 00006488 01047405                	dw 1025,MSG_1025-$ ; 1396
 38566 0000648C 03048805                	dw 1027,MSG_1027-$ ; 1416
 38567 00006490 0504A505                	dw 1029,MSG_1029-$ ; 1445
 38568 00006494 0604B305                	dw 1030,MSG_1030-$ ; 1459
 38569 00006498 0804BE05                	dw 1032,MSG_1032-$ ; 1470
 38570 0000649C 0904D205                	dw 1033,MSG_1033-$ ; 1490
 38571 000064A0 0A04E405                	dw 1034,MSG_1034-$ ; 1508
 38572 000064A4 0C04F605                	dw 1036,MSG_1036-$ ; 1526
 38573 000064A8 0D040706                	dw 1037,MSG_1037-$ ; 1543
 38574 000064AC 0E041406                	dw 1038,MSG_1038-$ ; 1556
 38575 000064B0 0F042306                	dw 1039,MSG_1039-$ ; 1571
 38576                                  $M_ID_3_40:
 38577 000064B4 10045C06                	dw 1040,MSG_1040-$ ; 1628
 38578 000064B8 14046D06                	dw 1044,MSG_1044-$ ; 1645
 38579 000064BC 16047D06                	dw 1046,MSG_1046-$ ; 1661
 38580 000064C0 1704B006                	dw 1047,MSG_1047-$ ; 1712
 38581 000064C4 1804C506                	dw 1048,MSG_1048-$ ; 1733
 38582 000064C8 1904D306                	dw 1049,MSG_1049-$ ; 1747
 38583 000064CC 1A04D906                	dw 1050,MSG_1050-$ ; 1753
 38584 000064D0 1B04F406                	dw 1051,MSG_1051-$ ; 1780
 38585 000064D4 1C040107                	dw 1052,MSG_1052-$ ; 1793
 38586 000064D8 1D041407                	dw 1053,MSG_1053-$ ; 1812
 38587 000064DC 1E043607                	dw 1054,MSG_1054-$ ; 1846
 38588                                  $M_ID_3_51:
 38589 000064E0 1F045907                	dw 1055,MSG_1055-$ ; 1881
 38590 000064E4 20046307                	dw 1056,MSG_1056-$ ; 1891
 38591 000064E8 21046E07                	dw 1057,MSG_1057-$ ; 1902
 38592 000064EC 23047707                	dw 1059,MSG_1059-$ ; 1911
 38593 000064F0 24047807                	dw 1060,MSG_1060-$ ; 1912
 38594 000064F4 25047807                	dw 1061,MSG_1061-$ ; 1912
 38595 000064F8 27048E07                	dw 1063,MSG_1063-$ ; 1934
 38596 000064FC 28048D07                	dw 1064,MSG_1064-$ ; 1933
 38597 00006500 29048C07                	dw 1065,MSG_1065-$ ; 1932
 38598 00006504 2A048B07                	dw 1066,MSG_1066-$ ; 1931
 38599 00006508 2B048A07                	dw 1067,MSG_1067-$ ; 1930
 38600 0000650C 2C048807                	dw 1068,MSG_1068-$ ; 1928
 38601 00006510 2D048F07                	dw 1069,MSG_1069-$ ; 1935
 38602 00006514 2E048F07                	dw 1070,MSG_1070-$ ; 1935
 38603 00006518 2F048E07                	dw 1071,MSG_1071-$ ; 1934
 38604 0000651C 30048D07                	dw 1072,MSG_1072-$ ; 1933
 38605                                  $M_ID_3_67:
 38606 00006520 31049307                	dw 1073,MSG_1073-$ ; 1939
 38607 00006524 32049907                	dw 1074,MSG_1074-$ ; 1945
 38608 00006528 33049F07                	dw 1075,MSG_1075-$ ; 1951
 38609 0000652C 3404A107                	dw 1076,MSG_1076-$ ; 1953
 38610 00006530 3504A007                	dw 1077,MSG_1077-$ ; 1952
 38611 00006534 3604A407                	dw 1078,MSG_1078-$ ; 1956
 38612 00006538 3704BB07                	dw 1079,MSG_1079-$ ; 1979
 38613 0000653C 3804C207                	dw 1080,MSG_1080-$ ; 1986
 38614 00006540 3904D407                	dw 1081,MSG_1081-$ ; 2004
 38615                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38616 00006544 3A04FB07                	dw 1082,MSG_1082-$ ; 2043	
 38617 00006548 3B04FF07                	dw 1083,MSG_1083-$ ; 2047	
 38618                                  	;
 38619 0000654C 3C04FE07                	dw 1084,MSG_1084-$ ; 2046
 38620 00006550 42040A08                	dw 1090,MSG_1090-$ ; 2058
 38621 00006554 43041408                	dw 1091,MSG_1091-$ ; 2068
 38622 00006558 44041E08                	dw 1092,MSG_1092-$ ; 2078
 38623 0000655C 45042808                	dw 1093,MSG_1093-$ ; 2088
 38624 00006560 46043908                	dw 1094,MSG_1094-$ ; 2105
 38625 00006564 47045208                	dw 1095,MSG_1095-$ ; 2130
 38626 00006568 48046B08                	dw 1096,MSG_1096-$ ; 2155
 38627                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38628 0000656C 49049808                	dw 1097,MSG_1097-$ ; 2200
 38629 00006570 4A04B108                	dw 1098,MSG_1098-$ ; 2225
 38630 00006574 4B04CA08                	dw 1099,MSG_1099-$ ; 2250
 38631 00006578 4C04DC08                	dw 1100,MSG_1100-$ ; 2268
 38632 0000657C 4D04FE08                	dw 1101,MSG_1101-$ ; 2302
 38633 00006580 4E040909                	dw 1102,MSG_1102-$ ; 2313
 38634 00006584 4F043F09                	dw 1103,MSG_1103-$ ; 2367
 38635 00006588 50045609                	dw 1104,MSG_1104-$ ; 2390
 38636 0000658C 51045609                	dw 1105,MSG_1105-$ ; 2390 ; TRANGROUP:6AA8h 
 38637                                  ;$M_ID_3_84:
 38638                                  $M_ID_3_95: ; 17/06/2023	
 38639 00006590 B0045709                	dw 1200,MSG_1200-$ ; 2391
 38640 00006594 14055409                	dw 1300,MSG_1300-$ ; 2388
 38641 00006598 2805D709                	dw 1320,MSG_1320-$ ; 2519
 38642 0000659C 2905130A                	dw 1321,MSG_1321-$ ; 2579
 38643 000065A0 3C05800A                	dw 1340,MSG_1340-$ ; 2688
 38644 000065A4 3D05D80A                	dw 1341,MSG_1341-$ ; 2776
 38645 000065A8 3E05370B                	dw 1342,MSG_1342-$ ; 2871
 38646 000065AC 5005C50B                	dw 1360,MSG_1360-$ ; 3013
 38647 000065B0 7805DD0B                	dw 1400,MSG_1400-$ ; 3037
 38648 000065B4 7905760C                	dw 1401,MSG_1401-$ ; 3190
 38649 000065B8 7A05DB0C                	dw 1402,MSG_1402-$ ; 3291
 38650 000065BC 7B054E0D                	dw 1403,MSG_1403-$ ; 3406
 38651 000065C0 7C058A0D                	dw 1404,MSG_1404-$ ; 3466 ; TRANGROUP:6ADCh 
 38652                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38653 000065C4 7D05FB0D                	dw 1405,MSG_1405-$ ; 3579 ; TRANGROUP:6AE0h 
 38654 000065C8 7E056A0E                	dw 1406,MSG_1406-$ ; 3690
 38655 000065CC 7F05A90E                	dw 1407,MSG_1407-$ ; 3753 ; (MSG_1404 for MSDOS 5.0 COMMAND.COM)
 38656                                  	;
 38657 000065D0 8C052D0F                	dw 1420,MSG_1420-$ ; 3885
 38658 000065D4 A005B40F                	dw 1440,MSG_1440-$ ; 4020
 38659 000065D8 A1050E10                	dw 1441,MSG_1441-$ ; 4110
 38660                                  ;$M_ID_3_100:
 38661                                  $M_ID_3_114: ; 17/06/2023
 38662 000065DC B4058E10                	dw 1460,MSG_1460-$ ; 4238
 38663 000065E0 B505EF10                	dw 1461,MSG_1461-$ ; 4335
 38664 000065E4 B6056F11                	dw 1462,MSG_1462-$ ; 4463
 38665 000065E8 C805BB11                	dw 1480,MSG_1480-$ ; 4539
 38666 000065EC C9054112                	dw 1481,MSG_1481-$ ; 4673
 38667 000065F0 CA055C12                	dw 1482,MSG_1482-$ ; 4700
 38668 000065F4 CB05A912                	dw 1483,MSG_1483-$ ; 4777
 38669 000065F8 CC05FF12                	dw 1484,MSG_1484-$ ; 4863
 38670 000065FC CD057A13                	dw 1485,MSG_1485-$ ; 4986
 38671 00006600 CE05F213                	dw 1486,MSG_1486-$ ; 5106
 38672 00006604 CF058414                	dw 1487,MSG_1487-$ ; 5252
 38673 00006608 D005C714                	dw 1488,MSG_1488-$ ; 5319
 38674                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38675 0000660C D1054315                	dw 1489,MSG_1489-$ ; 5443
 38676 00006610 D2058115                	dw 1490,MSG_1490-$ ; 5505
 38677 00006614 D3059915                	dw 1491,MSG_1491-$ ; 5529
 38678 00006618 D405E815                	dw 1492,MSG_1492-$ ; 5608
 38679 0000661C D5057716                	dw 1493,MSG_1493-$ ; 5751
 38680 00006620 D6058A16                	dw 1494,MSG_1494-$ ; 5770
 38681                                  ;$M_ID_3_112:
 38682                                  $M_ID_3_132: ; 17/06/2023
 38683 00006624 DC05A416                	dw 1500,MSG_1500-$ ; 5796
 38684 00006628 F005DF16                	dw 1520,MSG_1520-$ ; 5855
 38685 0000662C 04061917                	dw 1540,MSG_1540-$ ; 5913
 38686 00006630 05067317                	dw 1541,MSG_1541-$ ; 6003
 38687 00006634 0606DB17                	dw 1542,MSG_1542-$ ; 6107
 38688 00006638 18061318                	dw 1560,MSG_1560-$ ; 6163
 38689 0000663C 19064718                	dw 1561,MSG_1561-$ ; 6215
 38690 00006640 1A06C018                	dw 1562,MSG_1562-$ ; 6336
 38691 00006644 1B06EC18                	dw 1563,MSG_1563-$ ; 6380
 38692 00006648 1C061319                	dw 1564,MSG_1564-$ ; 6419
 38693 0000664C 1D064D19                	dw 1565,MSG_1565-$ ; 6477
 38694 00006650 1E067E19                	dw 1566,MSG_1566-$ ; 6526
 38695 00006654 1F06A719                	dw 1567,MSG_1567-$ ; 6567
 38696 00006658 20061D1A                	dw 1568,MSG_1568-$ ; 6685
 38697 0000665C 2C06661A                	dw 1580,MSG_1580-$ ; 6758
 38698                                  ;$M_ID_3_127:
 38699                                  $M_ID_3_147: ; 17/06/2023
 38700 00006660 4006AA1A                	dw 1600,MSG_1600-$ ; 6826
 38701 00006664 4106C31A                	dw 1601,MSG_1601-$ ; 6851
 38702 00006668 4206131B                	dw 1602,MSG_1602-$ ; 6931
 38703 0000666C 5406B01B                	dw 1620,MSG_1620-$ ; 7088
 38704 00006670 5506041C                	dw 1621,MSG_1621-$ ; 7172
 38705 00006674 5606821C                	dw 1622,MSG_1622-$ ; 7298
 38706 00006678 6806CA1C                	dw 1640,MSG_1640-$ ; 7370
 38707 0000667C 6906F41C                	dw 1641,MSG_1641-$ ; 7412
 38708 00006680 7C06741D                	dw 1660,MSG_1660-$ ; 7540
 38709 00006684 9006B71D                	dw 1680,MSG_1680-$ ; 7607
 38710 00006688 A406D91D                	dw 1700,MSG_1700-$ ; 7641
 38711 0000668C B806871E                	dw 1720,MSG_1720-$ ; 7815
 38712 00006690 CC06D61E                	dw 1740,MSG_1740-$ ; 7894
 38713 00006694 CD062E1F                	dw 1741,MSG_1741-$ ; 7982
 38714 00006698 E0069D1F                	dw 1760,MSG_1760-$ ; 8093
 38715 0000669C F406E61F                	dw 1780,MSG_1780-$ ; 8166
 38716                                  ;$M_ID_3_143:
 38717                                  $M_ID_3_163: ; 17/06/2023
 38718 000066A0 08074E20                	dw 1800,MSG_1800-$ ; 8270
 38719 000066A4 09079820                	dw 1801,MSG_1801-$ ; 8344
 38720 000066A8 1C07EC20                	dw 1820,MSG_1820-$ ; 8428
 38721 000066AC 1D073021                	dw 1821,MSG_1821-$ ; 8496
 38722 000066B0 3007B721                	dw 1840,MSG_1840-$ ; 8631
 38723 000066B4 4407FE21                	dw 1860,MSG_1860-$ ; 8702
 38724 000066B8 45075522                	dw 1861,MSG_1861-$ ; 8789
 38725 000066BC 46079822                	dw 1862,MSG_1862-$ ; 8856
 38726 000066C0 47071223                	dw 1863,MSG_1863-$ ; 8978
 38727 000066C4 4807B123                	dw 1864,MSG_1864-$ ; 9137
 38728 000066C8 49071424                	dw 1865,MSG_1865-$ ; 9236
 38729 000066CC 4A077B24                	dw 1866,MSG_1866-$ ; 9339
 38730 000066D0 5807DF24                	dw 1880,MSG_1880-$ ; 9439
 38731 000066D4 59075325                	dw 1881,MSG_1881-$ ; 9555
 38732 000066D8 5A07CD25                	dw 1882,MSG_1882-$ ; 9677
 38733 000066DC 5B072026                	dw 1883,MSG_1883-$ ; 9760
 38734 000066E0 6C07BF26                	dw 1900,MSG_1900-$ ; 9919
 38735 000066E4 8007D326                	dw 1920,MSG_1920-$ ; 9939
 38736 000066E8 8107FF26                	dw 1921,MSG_1921-$ ; 9983
 38737                                  ;$M_ID_3_162:
 38738                                  $M_ID_3_182: ; 17/06/2023
 38739 000066EC 82079927                	dw 1922,MSG_1922-$ ; 9285
 38740                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38741 000066F0 83074C28                	dw 1923,MSG_1923-$ ; 10316
 38742 000066F4 8407CE28                	dw 1924,MSG_1924-$ ; 10446
 38743 000066F8 85074A29                	dw 1925,MSG_1925-$ ; 10570
 38744 000066FC 8607CA29                	dw 1926,MSG_1926-$ ; 10698
 38745                                  $M_ID_3_187:	; 17/06/2023
 38746 00006700 8707                    	dw 1927	; 19/06/2023	; Message Number = 1927
 38747 00006702 1E2A                    	dw MSG_1927-$+2	; 10782	; Message offset from message number
 38748                                  				; (Msg addr: 6C1Ch+2A1Eh = TRANGROUP:963Ah)
 38749                                  
 38750                                  ; ---------------------------------------------------------------------------
 38751                                  ; Class 3 messages
 38752                                  ; ---------------------------------------------------------------------------
 38753                                  	
 38754                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38755                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 38756                                  
 38757                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38758                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6C20h
 38759                                  
 38760                                  MSG_1020:	; COMMON4
 38761 00006704 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 38762 00006705 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 38762 0000670E 667265650D0A       
 38763                                  MSG_1015:	; COMMON18
 38764 00006714 23                      	db 35
 38765 00006715 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 38765 0000671E 6F7420626520636F70-
 38765 00006727 696564206F6E746F20-
 38765 00006730 697473656C660D0A   
 38766                                  MSG_1004:	; COMMON20
 38767 00006738 19                      	db 25
 38768 00006739 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 38768 00006742 656E74206469736B20-
 38768 0000674B 73706163650D0A     
 38769                                  MSG_1026:	; COMMON22
 38770 00006752 13                      	db 19
 38771 00006753 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 38771 0000675C 6F646520706167650D-
 38771 00006765 0A                 
 38772                                  MSG_1031:	; COMMON23
 38773 00006766 0E                      	db 14
 38774 00006767 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 38774 00006770 6174650D0A         
 38775                                  MSG_1035:	; COMMON24
 38776 00006775 0E                      	db 14
 38777 00006776 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 38777 0000677F 696D650D0A         
 38778                                  MSG_1062:	; COMMON25
 38779 00006784 0E                      	db 14
 38780 00006785 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 38780 0000678E 6174680D0A         
 38781                                  MSG_1028:	; COMMON28
 38782 00006793 21                      	db 33
 38783 00006794 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 38783 0000679D 206B657920746F2063-
 38783 000067A6 6F6E74696E7565202E-
 38783 000067AF 202E202E0D0A       
 38784                                  MSG_1045:	; COMMON32
 38785 000067B5 1C                      	db 28
 38786 000067B6 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 38786 000067BF 206372656174652064-
 38786 000067C8 69726563746F72790D-
 38786 000067D1 0A                 
 38787                                  MSG_1041:	; COMMON33
 38788 000067D2 21                      	db 33
 38789 000067D3 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 38789 000067DC 206472697665202531-
 38789 000067E5 20686173206E6F206C-
 38789 000067EE 6162656C0D0A       
 38790                                  MSG_1042:	; COMMON34
 38791 000067F4 1A                      	db 26
 38792 000067F5 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 38792 000067FE 206472697665202531-
 38792 00006807 2069732025320D0A   
 38793                                  MSG_1043:	; COMMON36
 38794 0000680F 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 38795 00006810 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 38795 00006819 7269616C204E756D62-
 38795 00006822 65722069732025312D-
 38795 0000682B 25320D0A           
 38796                                  MSG_1002:
 38797 0000682F 27                              db 39
 38798 00006830 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 38798 00006839 2066696C65206E616D-
 38798 00006842 65206F722066696C65-
 38798 0000684B 206E6F7420666F756E-
 38798 00006854 640D0A             
 38799                                  MSG_1003:
 38800 00006857 1B                      	db 27
 38801 00006858 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 38801 00006861 617468206F72206669-
 38801 0000686A 6C65206E616D650D0A 
 38802                                  MSG_1007:
 38803 00006873 1A                      	db 26
 38804 00006874 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 38804 0000687D 7669726F6E6D656E74-
 38804 00006886 2073706163650D0A   
 38805                                  MSG_1008:
 38806 0000688E 15                      	db 21
 38807 0000688F 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 38807 00006898 74696F6E206572726F-
 38807 000068A1 720D0A             
 38808                                  MSG_1009:
 38809 000068A4 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 38810 000068A5 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 38810 000068AE 65206D697373696E67-
 38810 000068B7 0D0A               
 38811                                  MSG_1010:
 38812 000068B9 1F                      	db 31
 38813 000068BA 0D0A                    	db 0Dh,0Ah
 38814 000068BC 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 38814 000068C5 736B20776974682062-
 38814 000068CE 617463682066696C65-
 38814 000068D7 0D0A               
 38815                                  MSG_1011:
 38816 000068D9 1A                      	db 26
 38817 000068DA 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 38817 000068E3 6E64206F722066696C-
 38817 000068EC 65206E616D650D0A   
 38818                                  MSG_1014:	; EXTEND5
 38819 000068F4 10                      	db 16
 38820 000068F5 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 38820 000068FE 6E696564200D0A     
 38821                                  MSG_1016:
 38822 00006905 29                      	db 41
 38823 00006906 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 38823 0000690F 662064657374696E61-
 38823 00006918 74696F6E206C6F7374-
 38823 00006921 206265666F72652063-
 38823 0000692A 6F70790D0A         
 38824                                  MSG_1017:
 38825 0000692F 24                      	db 36
 38826 00006930 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 38826 00006939 696C656E616D65206F-
 38826 00006942 722066696C65206E6F-
 38826 0000694B 7420666F756E640D0A 
 38827                                  MSG_1018:
 38828 00006954 13                      	db 19
 38829 00006955 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 38829 0000695E 2920636F706965640D-
 38829 00006967 0A                 
 38830                                  MSG_1019:
 38831 00006968 0B                      	db 11
 38832 00006969 25312066696C652873-     	db '%1 file(s) '
 38832 00006972 2920               
 38833                                  MSG_1021:	; EXTEND15
 38834 00006974 1D                      	db 29
 38835 00006975 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 38835 0000697E 726976652073706563-
 38835 00006987 696669636174696F6E-
 38835 00006990 0D0A               
 38836                                  MSG_1022:
 38837 00006992 26                      	db 38
 38838 00006993 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 38838 0000699C 202531206E6F742070-
 38838 000069A5 726570617265642066-
 38838 000069AE 6F722073797374656D-
 38838 000069B7 0D0A               
 38839                                  MSG_1023:
 38840 000069B9 2B                      	db 43
 38841 000069BA 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 38841 000069C3 202531206E6F742070-
 38841 000069CC 726570617265642066-
 38841 000069D5 6F7220616C6C206465-
 38841 000069DE 76696365730D0A     
 38842                                  MSG_1024:
 38843 000069E5 16                      	db 22
 38844 000069E6 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 38844 000069EF 646520706167653A20-
 38844 000069F8 25310D0A           
 38845                                  MSG_1025:
 38846 000069FC 17                      	db 23
 38847 000069FD 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 38847 00006A06 6F7420696E7374616C-
 38847 00006A0F 6C65640D0A         
 38848                                  MSG_1027:
 38849 00006A14 20                      	db 32
 38850 00006A15 43757272656E742064-     	db 'Current drive is no longer valid'
 38850 00006A1E 72697665206973206E-
 38850 00006A27 6F206C6F6E67657220-
 38850 00006A30 76616C6964         
 38851                                  MSG_1029:
 38852 00006A35 11                      	db 17
 38853 00006A36 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 38853 00006A3F 20666F756E640D0A   
 38854                                  MSG_1030:
 38855 00006A47 0E                      	db 14
 38856 00006A48 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 38856 00006A51 726F720D0A         
 38857                                  MSG_1032:
 38858 00006A56 17                      	db 23
 38859 00006A57 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 38859 00006A60 617465206973202531-
 38859 00006A69 2025320D0A         
 38860                                  MSG_1033:
 38861 00006A6E 15                      	db 21
 38862 00006A6F 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 38862 00006A78 576564546875467269-
 38862 00006A81 536174             
 38863                                  MSG_1034:
 38864 00006A84 15                      	db 21
 38865 00006A85 456E746572206E6577-     	db 'Enter new date (%1): '
 38865 00006A8E 206461746520282531-
 38865 00006A97 293A20             
 38866                                  MSG_1036:
 38867 00006A9A 14                      	db 20
 38868 00006A9B 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 38868 00006AA4 696D65206973202531-
 38868 00006AAD 0D0A               
 38869                                  MSG_1037:
 38870 00006AAF 10                      	db 16
 38871 00006AB0 456E746572206E6577-     	db 'Enter new time: '
 38871 00006AB9 2074696D653A20     
 38872                                  MSG_1038:
 38873 00006AC0 12                              db 18
 38874 00006AC1 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 38874 00006ACA 74652028592F4E293F 
 38875                                  MSG_1039:
 38876 00006AD3 3C                              db 60
 38877 00006AD4 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 38877 00006ADD 20696E206469726563-
 38877 00006AE6 746F72792077696C6C-
 38877 00006AEF 2062652064656C6574-
 38877 00006AF8 6564210D0A         
 38878 00006AFD 41726520796F752073-     	db 'Are you sure (Y/N)?'
 38878 00006B06 7572652028592F4E29-
 38878 00006B0F 3F                 
 38879                                  MSG_1040:
 38880 00006B10 14                      	db 20
 38881 00006B11 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 38881 00006B1A 7273696F6E2025312E-
 38881 00006B23 2532               
 38882                                  MSG_1044:
 38883 00006B25 13                      	db 19
 38884 00006B26 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 38884 00006B2F 69726563746F72790D-
 38884 00006B38 0A                 
 38885                                  MSG_1046:
 38886 00006B39 36                      	db 54
 38887 00006B3A 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 38887 00006B43 6174682C206E6F7420-
 38887 00006B4C 6469726563746F7279-
 38887 00006B55 2C0D0A             
 38888 00006B58 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 38888 00006B61 6F7279206E6F742065-
 38888 00006B6A 6D7074790D0A       
 38889                                  MSG_1047:
 38890 00006B70 18                      	db 24
 38891 00006B71 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 38891 00006B7A 696679204F4E206F72-
 38891 00006B83 204F46460D0A       
 38892                                  MSG_1048:
 38893 00006B89 11                      	db 17
 38894 00006B8A 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 38894 00006B93 206F662025310D0A   
 38895                                  MSG_1049:
 38896 00006B9B 09                      	db 9
 38897 00006B9C 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 38898                                  MSG_1050:
 38899 00006BA5 1E                      	db 30
 38900 00006BA6 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 38900 00006BAF 7269766520696E2073-
 38900 00006BB8 656172636820706174-
 38900 00006BC1 680D0A             
 38901                                  MSG_1051:
 38902 00006BC4 10                      	db 16
 38903 00006BC5 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 38903 00006BCE 65766963650D0A     
 38904                                  MSG_1052:
 38905 00006BD5 16                      	db 22
 38906 00006BD6 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 38906 00006BDF 74206265206E657374-
 38906 00006BE8 65640D0A           
 38907                                  MSG_1053:
 38908 00006BEC 25                      	db 37
 38909 00006BED 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 38909 00006BF6 6174652066696C6520-
 38909 00006BFF 6572726F7220647572-
 38909 00006C08 696E6720706970650D-
 38909 00006C11 0A                 
 38910                                  MSG_1054:
 38911 00006C12 26                      	db 38
 38912 00006C13 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 38912 00006C1C 2062696E6172792072-
 38912 00006C25 656164732066726F6D-
 38912 00006C2E 206120646576696365-
 38912 00006C37 0D0A               
 38913                                  
 38914                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 38915                                  	; 17/06/2023
 38916                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7155h)
 38917                                  MSG_1055:
 38918 00006C39 0D                      	db 13
 38919 00006C3A 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 38919 00006C43 25310D0A           
 38920                                  MSG_1056:
 38921 00006C47 0E                      	db 14
 38922 00006C48 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 38922 00006C51 2025310D0A         
 38923                                  MSG_1057:
 38924 00006C56 0C                      	db 12
 38925 00006C57 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 38925 00006C60 310D0A             
 38926                                  MSG_1059:
 38927 00006C63 04                      	db 4
 38928 00006C64 6F666600                	db 'off',0
 38929                                  MSG_1060:
 38930 00006C68 03                      	db 3
 38931 00006C69 6F6E00                  	db 'on',0
 38932                                  MSG_1061:
 38933 00006C6C 19                      	db 25
 38934 00006C6D 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 38934 00006C76 74696E6720746F2064-
 38934 00006C7F 65766963650D0A     
 38935                                  MSG_1063:
 38936 00006C86 02                      	db 2
 38937 00006C87 2531                    	db '%1'
 38938                                  MSG_1064:
 38939 00006C89 02                      	db 2
 38940 00006C8A 2531                    	db '%1'
 38941                                  MSG_1065:
 38942 00006C8C 02                      	db 2
 38943 00006C8D 2531                    	db '%1'
 38944                                  MSG_1066:
 38945 00006C8F 02                      	db 2
 38946 00006C90 2531                    	db '%1'
 38947                                  MSG_1067:
 38948 00006C92 01                      	db 1
 38949 00006C93 09                      	db 9
 38950                                  MSG_1068:
 38951 00006C94 0A                      	db 10
 38952 00006C95 203C4449523E202020-     	db ' <DIR>    '
 38952 00006C9E 20                 
 38953                                  MSG_1069:
 38954 00006C9F 03                      	db 3
 38955 00006CA0 082008                  	db 8, 20h, 8
 38956                                  MSG_1070:	; CRLF		
 38957 00006CA3 02                      	db 2
 38958 00006CA4 0D                      	db 0Dh
 38959 00006CA5 0A                      	db 0Ah
 38960                                  MSG_1071:
 38961 00006CA6 02                      	db 2
 38962 00006CA7 2531                    	db '%1'
 38963                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38964                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:71C5h
 38965                                  MSG_1072:
 38966                                  	;db 8
 38967                                  	;db 'mm-dd-yy'
 38968 00006CA9 09                      	db 9
 38969 00006CAA 6D6D2D64642D797900      	db 'mm-dd-yy',0
 38970                                  MSG_1073:
 38971                                  	;db 8
 38972                                  	;db 'dd-mm-yy'
 38973 00006CB3 09                      	db 9
 38974 00006CB4 64642D6D6D2D797900      	db 'dd-mm-yy',0
 38975                                  MSG_1074:
 38976                                  	;db 8
 38977                                  	;db 'yy-mm-dd'
 38978 00006CBD 09                      	db 9
 38979 00006CBE 79792D6D6D2D646400      	db 'yy-mm-dd',0
 38980                                  MSG_1075:
 38981 00006CC7 05                      	db 5
 38982 00006CC8 2531202532              	db '%1 %2'
 38983                                  MSG_1076:
 38984 00006CCD 02                      	db 2
 38985 00006CCE 2531                    	db '%1'
 38986                                  MSG_1077:
 38987 00006CD0 07                      	db 7
 38988 00006CD1 20253120202532          	db ' %1  %2'
 38989                                  MSG_1078:
 38990 00006CD8 1A                      	db 26
 38991 00006CD9 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 38991 00006CE2 20616C726561647920-
 38991 00006CEB 6578697374730D0A   
 38992                                  MSG_1079:
 38993 00006CF3 0A                      	db 10
 38994 00006CF4 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 38994 00006CFD 0A                 
 38995                                  MSG_1080:
 38996 00006CFE 15                      	db 21
 38997 00006CFF 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 38997 00006D08 6573206C6973746564-
 38997 00006D11 3A0D0A             
 38998                                  MSG_1081:
 38999 00006D14 2A                      	db 42
 39000 00006D15 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 39000 00006D1E 63757272656420696E-
 39000 00006D27 20656E7669726F6E6D-
 39000 00006D30 656E74207661726961-
 39000 00006D39 626C65290D0A       
 39001                                  	;
 39002                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 39003                                  MSG_1082:
 39004 00006D3F 07                              db 7
 39005 00006D40 205B592F4E5D3F          	db ' [Y/N]?'
 39006                                  MSG_1083:
 39007 00006D47 02                      	db 2
 39008 00006D48 594E                    	db 'YN'
 39009                                  	;
 39010                                  MSG_1084:
 39011 00006D4A 0F                      	db 15
 39012 00006D4B 28636F6E74696E7569-     	db '(continuing %1)'
 39012 00006D54 6E6720253129       
 39013                                  MSG_1090:
 39014 00006D5A 0D                      	db 13
 39015 00006D5B 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 39015 00006D64 25310D0A           
 39016                                  MSG_1091:
 39017 00006D68 0D                      	db 13
 39018 00006D69 444F5320697320696E-     	db 'DOS is in ROM'
 39018 00006D72 20524F4D           
 39019                                  MSG_1092:
 39020 00006D76 0D                      	db 13
 39021 00006D77 444F5320697320696E-     	db 'DOS is in HMA'
 39021 00006D80 20484D41           
 39022                                  MSG_1093:
 39023 00006D84 14                      	db 20
 39024 00006D85 444F5320697320696E-     	db 'DOS is in low memory'
 39024 00006D8E 206C6F77206D656D6F-
 39024 00006D97 7279               
 39025                                  MSG_1094:
 39026 00006D99 1C                      	db 28
 39027 00006D9A 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 39027 00006DA3 616468696768206261-
 39027 00006DAC 7463682066696C650D-
 39027 00006DB5 0A                 
 39028                                  MSG_1095:
 39029 00006DB6 1C                      	db 28
 39030 00006DB7 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 39030 00006DC0 20496E76616C696420-
 39030 00006DC9 66696C656E616D650D-
 39030 00006DD2 0A                 
 39031                                  MSG_1096:
 39032 00006DD3 30                      	db 48
 39033 00006DD4 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 39033 00006DDD 656E20737065636966-
 39033 00006DE6 69656420636F756E74-
 39033 00006DEF 727920696E666F726D-
 39033 00006DF8 6174696F6E2066696C-
 39033 00006E01 650D0A             
 39034                                  
 39035                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39036                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7320h
 39037                                  MSG_1097:
 39038 00006E04 1C                      	db 28
 39039 00006E05 4C6F6164486967683A-     	db 'LoadHigh: Invalid argument',0Dh,0Ah
 39039 00006E0E 20496E76616C696420-
 39039 00006E17 617267756D656E740D-
 39039 00006E20 0A                 
 39040                                  MSG_1098:
 39041 00006E21 1C                      	db 28
 39042 00006E22 526571756972656420-     	db 'Required parameter missing',0Dh,0Ah
 39042 00006E2B 706172616D65746572-
 39042 00006E34 206D697373696E670D-
 39042 00006E3D 0A                 
 39043                                  MSG_1099:
 39044 00006E3E 15                      	db 21
 39045 00006E3F 556E7265636F676E69-     	db 'Unrecognized switch',0Dh,0Ah
 39045 00006E48 7A6564207377697463-
 39045 00006E51 680D0A             
 39046                                  MSG_1100:
 39047 00006E54 25                      	db 37
 39048 00006E55 412062616420554D42-     	db 'A bad UMB number has been specified',0Dh,0Ah
 39048 00006E5E 206E756D6265722068-
 39048 00006E67 6173206265656E2073-
 39048 00006E70 70656369666965640D-
 39048 00006E79 0A                 
 39049                                  MSG_1101:
 39050 00006E7A 0E                      	db 14
 39051 00006E7B 202025312E25322074-     	db '  %1.%2 to 1.0'
 39051 00006E84 6F20312E30         
 39052                                  MSG_1102:
 39053 00006E89 39                      	db 57
 39054 00006E8A 202020202020202020-     	db '                 %1.%2 to 1.0 average compression ratio',0Dh,0Ah
 39054 00006E93 202020202020202025-
 39054 00006E9C 312E253220746F2031-
 39054 00006EA5 2E3020617665726167-
 39054 00006EAE 6520636F6D70726573-
 39054 00006EB7 73696F6E2072617469-
 39054 00006EC0 6F0D0A             
 39055                                  MSG_1103:
 39056 00006EC3 1A                      	db 26
 39057 00006EC4 4F7665727772697465-     	db 'Overwrite %1 (Yes/No/All)?'
 39057 00006ECD 20253120285965732F-
 39057 00006ED6 4E6F2F416C6C293F   
 39058                                  MSG_1104:
 39059 00006EDE 03                      	db 3
 39060 00006EDF 59                      _Y_es:	db 'Y'
 39061 00006EE0 4E                      _N_o:	db 'N'
 39062 00006EE1 41                      _A_ll:	db 'A'
 39063                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:73FEh)
 39064                                  MSG_1105:
 39065 00006EE2 04                      	db 4
 39066 00006EE3 20202020                	db '    '
 39067                                  	
 39068                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 39069                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7403h
 39070                                  MSG_1200:
 39071 00006EE7 00                      	db 0	; /? unimplemented
 39072                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7404h)
 39073                                  MSG_1300:
 39074 00006EE8 86                      	db 134
 39075 00006EE9 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 39075 00006EF2 6C6561727320657874-
 39075 00006EFB 656E64656420435452-
 39075 00006F04 4C2B4320636865636B-
 39075 00006F0D 696E672E0D0A       
 39076 00006F13 0D0A                    	db 0Dh,0Ah
 39077 00006F15 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 39077 00006F1E 207C204F46465D0D0A 
 39078 00006F27 0D0A                    	db 0Dh,0Ah
 39079 00006F29 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 39079 00006F32 4B20776974686F7574-
 39079 00006F3B 206120706172616D65-
 39079 00006F44 74657220746F206469-
 39079 00006F4D 73706C617920746865-
 39079 00006F56 2063757272656E7420-
 39079 00006F5F 425245414B20736574-
 39079 00006F68 74696E672E0D0A     
 39080                                  MSG_1320:
 39081 00006F6F 3F                      	db 63
 39082 00006F70 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 39082 00006F79 6F7220736574732074-
 39082 00006F82 686520616374697665-
 39082 00006F8B 20636F646520706167-
 39082 00006F94 65206E756D6265722E-
 39082 00006F9D 0D0A               
 39083 00006F9F 0D0A                    	db 0Dh,0Ah
 39084 00006FA1 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 39084 00006FAA 5D0D0A             
 39085 00006FAD 0D0A                    	db 0Dh,0Ah
 39086                                  MSG_1321:
 39087 00006FAF 70                      	db 112
 39088 00006FB0 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 39088 00006FB9 706563696669657320-
 39088 00006FC2 6120636F6465207061-
 39088 00006FCB 6765206E756D626572-
 39088 00006FD4 2E0D0A             
 39089 00006FD7 0D0A                    	db 0Dh,0Ah
 39090 00006FD9 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 39090 00006FE2 20776974686F757420-
 39090 00006FEB 6120706172616D6574-
 39090 00006FF4 657220746F20646973-
 39090 00006FFD 706C61792074686520-
 39090 00007006 61637469766520636F-
 39090 0000700F 64652070616765206E-
 39090 00007018 756D6265722E0D0A   
 39091                                  MSG_1340:
 39092 00007020 5B                      	db 91
 39093 00007021 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 39093 0000702A 746865206E616D6520-
 39093 00007033 6F66206F7220636861-
 39093 0000703C 6E6765732074686520-
 39093 00007045 63757272656E742064-
 39093 0000704E 69726563746F72792E-
 39093 00007057 0D0A               
 39094 00007059 0D0A                    	db 0Dh,0Ah
 39095 0000705B 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 39095 00007064 6976653A5D5B706174-
 39095 0000706D 685D0D0A           
 39096 00007071 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 39096 0000707A 0D0A               
 39097                                  MSG_1341:
 39098 0000707C 62                      	db 98
 39099 0000707D 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 39099 00007086 3A5D5B706174685D0D-
 39099 0000708F 0A                 
 39100 00007090 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 39101 00007098 0D0A                    	db 0Dh,0Ah
 39102 0000709A 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 39102 000070A3 656369666965732074-
 39102 000070AC 68617420796F752077-
 39102 000070B5 616E7420746F206368-
 39102 000070BE 616E676520746F2074-
 39102 000070C7 686520706172656E74-
 39102 000070D0 206469726563746F72-
 39102 000070D9 792E               
 39103 000070DB 0D0A                    	db 0Dh,0Ah
 39104 000070DD 0D0A                    	db 0Dh,0Ah
 39105                                  MSG_1342:
 39106 000070DF 91                      	db 145
 39107 000070E0 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 39107 000070E9 726976653A20746F20-
 39107 000070F2 646973706C61792074-
 39107 000070FB 68652063757272656E-
 39107 00007104 74206469726563746F-
 39107 0000710D 727920696E20746865-
 39107 00007116 207370656369666965-
 39107 0000711F 6420               
 39108 00007121 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 39109 00007129 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 39109 00007132 6974686F7574207061-
 39109 0000713B 72616D657465727320-
 39109 00007144 746F20646973706C61-
 39109 0000714D 792074686520637572-
 39109 00007156 72656E742064726976-
 39109 0000715F 6520616E6420646972-
 39109 00007168 6563746F72792E0D0A 
 39110                                  MSG_1360:
 39111 00007171 1B                      	db 27
 39112 00007172 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 39112 0000717B 652073637265656E2E-
 39112 00007184 0D0A               
 39113 00007186 0D0A                    	db 0Dh,0Ah
 39114 00007188 434C530D0A              	db 'CLS',0Dh,0Ah
 39115                                  MSG_1400:
 39116                                  	;db 145
 39117                                  	;db 'Copies one or more files to another location.',0Dh,0Ah
 39118                                  	;db 0Dh,0Ah
 39119                                  	;db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39120                                  	;db '  [/A | /B]] [/V]',0Dh,0Ah
 39121                                  	;db 0Dh,0Ah
 39122                                  	
 39123                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39124                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:76A9h)
 39125 0000718D 9C                      	db 156 ; 19/06/2023	
 39126 0000718E 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 39126 00007197 65206F72206D6F7265-
 39126 000071A0 2066696C657320746F-
 39126 000071A9 20616E6F7468657220-
 39126 000071B2 6C6F636174696F6E2E-
 39126 000071BB 0D0A               
 39127 000071BD 0D0A                    	db 0Dh,0Ah
 39128 000071BF 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39128 000071C8 7C202F425D20736F75-
 39128 000071D1 726365205B2F41207C-
 39128 000071DA 202F425D205B2B2073-
 39128 000071E3 6F75726365205B2F41-
 39128 000071EC 207C202F425D205B2B-
 39128 000071F5 202E2E2E5D5D205B64-
 39128 000071FE 657374696E6174696F-
 39128 00007207 6E0D0A             
 39129 0000720A 20205B2F41207C202F-     	db '  [/A | /B]] [/V] [/Y | /-Y]',0Dh,0Ah
 39129 00007213 425D5D205B2F565D20-
 39129 0000721C 5B2F59207C202F2D59-
 39129 00007225 5D0D0A             
 39130 00007228 0D0A                    	db 0Dh,0Ah
 39131                                  MSG_1401:
 39132 0000722A 68                      	db 104
 39133 0000722B 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 39133 00007234 202020202020537065-
 39133 0000723D 636966696573207468-
 39133 00007246 652066696C65206F72-
 39133 0000724F 2066696C657320746F-
 39133 00007258 20626520636F706965-
 39133 00007261 642E0D0A           
 39134 00007265 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 39134 0000726E 202020202020496E64-
 39134 00007277 69636174657320616E-
 39134 00007280 204153434949207465-
 39134 00007289 78742066696C652E0D-
 39134 00007292 0A                 
 39135                                  MSG_1402:
 39136 00007293 76                      	db 118
 39137 00007294 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 39137 0000729D 202020202020496E64-
 39137 000072A6 696361746573206120-
 39137 000072AF 62696E617279206669-
 39137 000072B8 6C652E0D0A         
 39138 000072BD 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 39138 000072C6 74696F6E2020537065-
 39138 000072CF 636966696573207468-
 39138 000072D8 65206469726563746F-
 39138 000072E1 727920616E642F6F72-
 39138 000072EA 2066696C656E616D65-
 39138 000072F3 20666F722074686520-
 39138 000072FC 6E65772066696C6528-
 39138 00007305 73292E0D0A         
 39139                                  MSG_1403:	
 39140                                  	;db 65  ;  MSDOS 5.0
 39141                                  	; 17/06/2023
 39142 0000730A 3F                      	db 63 ; MSDOS 6.22	
 39143 0000730B 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 39143 00007314 202020202020566572-
 39143 0000731D 696669657320746861-
 39143 00007326 74206E65772066696C-
 39143 0000732F 657320617265207772-
 39143 00007338 697474656E20636F72-
 39143 00007341 726563746C792E0D0A 
 39144                                  	;db 0Dh,0Ah ; MSDOS 5.0
 39145                                  
 39146                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39147                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7866h
 39148                                  MSG_1404:
 39149 0000734A 74                              db 116
 39150 0000734B 20202F592020202020-     	db '  /Y           Suppresses prompting to confirm you want to overwrite an',0Dh,0Ah
 39150 00007354 202020202020537570-
 39150 0000735D 707265737365732070-
 39150 00007366 726F6D7074696E6720-
 39150 0000736F 746F20636F6E666972-
 39150 00007378 6D20796F752077616E-
 39150 00007381 7420746F206F766572-
 39150 0000738A 777269746520616E0D-
 39150 00007393 0A                 
 39151 00007394 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39151 0000739D 202020202020657869-
 39151 000073A6 7374696E6720646573-
 39151 000073AF 74696E6174696F6E20-
 39151 000073B8 66696C652E0D0A     
 39152                                  MSG_1405:
 39153 000073BF 72                      	db 114
 39154 000073C0 20202F2D5920202020-     	db '  /-Y          Causes prompting to confirm you want to overwrite an',0Dh,0Ah
 39154 000073C9 202020202020436175-
 39154 000073D2 7365732070726F6D70-
 39154 000073DB 74696E6720746F2063-
 39154 000073E4 6F6E6669726D20796F-
 39154 000073ED 752077616E7420746F-
 39154 000073F6 206F76657277726974-
 39154 000073FF 6520616E0D0A       
 39155 00007405 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39155 0000740E 202020202020657869-
 39155 00007417 7374696E6720646573-
 39155 00007420 74696E6174696F6E20-
 39155 00007429 66696C652E0D0A     
 39156 00007430 0D0A                    	db 0Dh,0Ah
 39157                                  MSG_1406:
 39158 00007432 42                      	db 66
 39159 00007433 546865207377697463-     	db 'The switch /Y may be preset in the COPYCMD environment variable.',0Dh,0Ah
 39159 0000743C 68202F59206D617920-
 39159 00007445 626520707265736574-
 39159 0000744E 20696E207468652043-
 39159 00007457 4F5059434D4420656E-
 39159 00007460 7669726F6E6D656E74-
 39159 00007469 207661726961626C65-
 39159 00007472 2E0D0A             
 39160                                  
 39161                                  ;MSG_1404: ; MSDOS 5.0 (TRANGROUP:681Ch)
 39162                                  MSG_1407:  ; MSDOS 6.22	(TRANGROUP:7991h)
 39163 00007475 87                      	db 135
 39164 00007476 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 39164 0000747F 2066696C65732C2073-
 39164 00007488 706563696679206120-
 39164 00007491 73696E676C65206669-
 39164 0000749A 6C6520666F72206465-
 39164 000074A3 7374696E6174696F6E-
 39164 000074AC 2C20627574206D756C-
 39164 000074B5 7469706C652066696C-
 39164 000074BE 65730D0A           
 39165 000074C2 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 39165 000074CB 6520287573696E6720-
 39165 000074D4 77696C646361726473-
 39165 000074DD 206F722066696C6531-
 39165 000074E6 2B66696C65322B6669-
 39165 000074EF 6C653320666F726D61-
 39165 000074F8 74292E0D0A         
 39166                                  MSG_1420:
 39167 000074FD 8A                      	db 138
 39168 000074FE 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 39168 00007507 6865207465726D696E-
 39168 00007510 616C20646576696365-
 39168 00007519 207573656420746F20-
 39168 00007522 636F6E74726F6C2079-
 39168 0000752B 6F7572207379737465-
 39168 00007534 6D2E0D0A           
 39169 00007538 0D0A                    	db 0Dh,0Ah
 39170 0000753A 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 39170 00007543 63650D0A           
 39171 00007547 0D0A                    	db 0Dh,0Ah
 39172 00007549 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 39172 00007552 202054686520746572-
 39172 0000755B 6D696E616C20646576-
 39172 00007564 69636520796F752077-
 39172 0000756D 616E7420746F207573-
 39172 00007576 652C20737563682061-
 39172 0000757F 7320434F4D312E0D0A 
 39173                                  MSG_1440:
 39174                                  	;db 45
 39175                                  	;db 'Displays or sets the date.',0Dh,0Ah
 39176                                  	;db 0Dh,0Ah
 39177                                  	;db 'DATE [date]',0Dh,0Ah
 39178                                  	;db 0Dh,0Ah
 39179                                  
 39180                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39181                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7AA4h)
 39182 00007588 5D                      	db 93
 39183 00007589 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 39183 00007592 6F7220736574732074-
 39183 0000759B 686520646174652E0D-
 39183 000075A4 0A                 
 39184 000075A5 0D0A                    	db 0Dh,0Ah
 39185 000075A7 44415445205B6D6D2D-     	db 'DATE [mm-dd-yy]',0Dh,0Ah
 39185 000075B0 64642D79795D0D0A   
 39186 000075B8 0D0A                    	db 0Dh,0Ah
 39187 000075BA 20206D6D2D64642D79-     	db '  mm-dd-yy    Sets the date you specify.',0Dh,0Ah
 39187 000075C3 792020202053657473-
 39187 000075CC 207468652064617465-
 39187 000075D5 20796F752073706563-
 39187 000075DE 6966792E0D0A       
 39188 000075E4 0D0A                    	db 0Dh,0Ah
 39189                                  MSG_1441:
 39190 000075E6 83                      	db 131
 39191 000075E7 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 39191 000075F0 20776974686F757420-
 39191 000075F9 706172616D65746572-
 39191 00007602 7320746F2064697370-
 39191 0000760B 6C6179207468652063-
 39191 00007614 757272656E74206461-
 39191 0000761D 74652073657474696E-
 39191 00007626 6720616E640D0A     
 39192 0000762D 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 39192 00007636 666F722061206E6577-
 39192 0000763F 206F6E652E20205072-
 39192 00007648 65737320454E544552-
 39192 00007651 20746F206B65657020-
 39192 0000765A 7468652073616D6520-
 39192 00007663 646174652E0D0A     
 39193                                  MSG_1460:	
 39194 0000766A 64                      	db 100
 39195 0000766B 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 39195 00007674 6E65206F72206D6F72-
 39195 0000767D 652066696C65732E0D-
 39195 00007686 0A                 
 39196 00007687 0D0A                    	db 0Dh,0Ah
 39197 00007689 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 39197 00007692 653A5D5B706174685D-
 39197 0000769B 66696C656E616D6520-
 39197 000076A4 5B2F505D0D0A       
 39198 000076AA 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 39198 000076B3 6976653A5D5B706174-
 39198 000076BC 685D66696C656E616D-
 39198 000076C5 65205B2F505D0D0A   
 39199 000076CD 0D0A                    	db 0Dh,0Ah
 39200                                  MSG_1461:
 39201 000076CF 83                      	db 131
 39202 000076D0 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 39202 000076D9 5D5B706174685D6669-
 39202 000076E2 6C656E616D65202053-
 39202 000076EB 706563696669657320-
 39202 000076F4 7468652066696C6528-
 39202 000076FD 732920746F2064656C-
 39202 00007706 6574652E2020537065-
 39202 0000770F 63696679206D756C74-
 39202 00007718 69706C650D0A       
 39203 0000771E 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 39203 00007727 202020202020202020-
 39203 00007730 202020202020202066-
 39203 00007739 696C65732062792075-
 39203 00007742 73696E672077696C64-
 39203 0000774B 63617264732E0D0A   
 39204                                  MSG_1462:
 39205 00007753 4F                      	db 79
 39206 00007754 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 39206 0000775D 202020202020202020-
 39206 00007766 202020202020202050-
 39206 0000776F 726F6D70747320666F-
 39206 00007778 7220636F6E6669726D-
 39206 00007781 6174696F6E20626566-
 39206 0000778A 6F72652064656C6574-
 39206 00007793 696E67206561636820-
 39206 0000779C 66696C652E0D0A     
 39207                                  
 39208                                  ; 17/06/2023
 39209                                  %if 0	; MSDOS 5.0 DIR Help messages 
 39210                                  
 39211                                  MSG_1480:
 39212                                  	db 162
 39213                                  	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39214                                  	db 0Dh,0Ah
 39215                                  	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 39216                                  	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 39217                                  	db 0Dh,0Ah
 39218                                  MSG_1481:
 39219                                  	db 93
 39220                                  	db '  [drive:][path][filename]',0Dh,0Ah
 39221                                  	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39222                                  MSG_1482:
 39223                                  	db 97
 39224                                  	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 39225                                  	db '  /W          Uses wide list format.',0Dh,0Ah
 39226                                  MSG_1483:	
 39227                                  	db 122
 39228                                  	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 39229                                  	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 39230                                  MSG_1484:
 39231                                  	db 191
 39232                                  	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 39233                                  	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 39234                                  	db '  /O          List by files in sorted order.',0Dh,0Ah
 39235                                  MSG_1485:
 39236                                  	db 155
 39237                                  	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39238                                  	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39239                                  MSG_1486:
 39240                                  	db 150
 39241                                  	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39242                                  	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39243                                  MSG_1487:
 39244                                  	db 102
 39245                                  	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 39246                                  	db '  /L          Uses lowercase.',0Dh,0Ah
 39247                                  	db 0Dh,0Ah
 39248                                  MSG_1488:
 39249                                  	db 146
 39250                                  	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39251                                  	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39252                                  %endif
 39253                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39254                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7CBFh
 39255                                  MSG_1480:
 39256 000077A3 89                      	db 137
 39257 000077A4 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39257 000077AD 61206C697374206F66-
 39257 000077B6 2066696C657320616E-
 39257 000077BF 642073756264697265-
 39257 000077C8 63746F726965732069-
 39257 000077D1 6E2061206469726563-
 39257 000077DA 746F72792E0D0A     
 39258 000077E1 0D0A                    	db 0Dh,0Ah
 39259 000077E3 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attribs]] [/O[[:]sortord]]',0Dh,0Ah
 39259 000077EC 653A5D5B706174685D-
 39259 000077F5 5B66696C656E616D65-
 39259 000077FE 5D205B2F505D205B2F-
 39259 00007807 575D205B2F415B5B3A-
 39259 00007810 5D617474726962735D-
 39259 00007819 5D205B2F4F5B5B3A5D-
 39259 00007822 736F72746F72645D5D-
 39259 0000782B 0D0A               
 39260                                  MSG_1481:
 39261 0000782D 1E                      	db 30
 39262 0000782E 202020205B2F535D20-     	db '    [/S] [/B] [/L] [/C[H]]',0Dh,0Ah
 39262 00007837 5B2F425D205B2F4C5D-
 39262 00007840 205B2F435B485D5D0D-
 39262 00007849 0A                 
 39263 0000784A 0D0A                    	db 0Dh,0Ah
 39264                                  MSG_1482:
 39265 0000784C 50                      	db 80
 39266 0000784D 20205B64726976653A-     	db '  [drive:][path][filename]   Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39266 00007856 5D5B706174685D5B66-
 39266 0000785F 696C656E616D655D20-
 39266 00007868 202053706563696669-
 39266 00007871 65732064726976652C-
 39266 0000787A 206469726563746F72-
 39266 00007883 792C20616E642F6F72-
 39266 0000788C 2066696C657320746F-
 39266 00007895 206C6973742E0D0A   
 39267                                  MSG_1483:
 39268 0000789D 59                      	db 89
 39269 0000789E 20202F502020202020-     	db '  /P      Pauses after each screenful of information.',0Dh,0Ah
 39269 000078A7 205061757365732061-
 39269 000078B0 667465722065616368-
 39269 000078B9 2073637265656E6675-
 39269 000078C2 6C206F6620696E666F-
 39269 000078CB 726D6174696F6E2E0D-
 39269 000078D4 0A                 
 39270 000078D5 20202F572020202020-     	db '  /W      Uses wide list format.',0Dh,0Ah
 39270 000078DE 205573657320776964-
 39270 000078E7 65206C69737420666F-
 39270 000078F0 726D61742E0D0A     
 39271                                  MSG_1484:
 39272 000078F7 7E                      	db 126
 39273 000078F8 20202F412020202020-     	db '  /A      Displays files with specified attributes.',0Dh,0Ah
 39273 00007901 20446973706C617973-
 39273 0000790A 2066696C6573207769-
 39273 00007913 746820737065636966-
 39273 0000791C 696564206174747269-
 39273 00007925 62757465732E0D0A   
 39274 0000792D 202061747472696273-     	db '  attribs   D  Directories   R  Read-only files         H  Hidden files',0Dh,0Ah
 39274 00007936 202020442020446972-
 39274 0000793F 6563746F7269657320-
 39274 00007948 202052202052656164-
 39274 00007951 2D6F6E6C792066696C-
 39274 0000795A 657320202020202020-
 39274 00007963 202048202048696464-
 39274 0000796C 656E2066696C65730D-
 39274 00007975 0A                 
 39275                                  MSG_1485:
 39276 00007976 7B                      	db 123
 39277 00007977 202020202020202020-     	db '            S  System files  A  Files ready to archive  -  Prefix meaning "not"',0Dh,0Ah
 39277 00007980 202020532020537973-
 39277 00007989 74656D2066696C6573-
 39277 00007992 202041202046696C65-
 39277 0000799B 732072656164792074-
 39277 000079A4 6F2061726368697665-
 39277 000079AD 20202D202050726566-
 39277 000079B6 6978206D65616E696E-
 39277 000079BF 6720226E6F74220D0A 
 39278 000079C8 20202F4F2020202020-     	db '  /O      List by files in sorted order.',0Dh,0Ah
 39278 000079D1 204C69737420627920-
 39278 000079DA 66696C657320696E20-
 39278 000079E3 736F72746564206F72-
 39278 000079EC 6465722E0D0A       
 39279                                  MSG_1486:
 39280 000079F2 95                      	db 149
 39281 000079F3 2020736F72746F7264-     	db '  sortord   N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39281 000079FC 2020204E2020427920-
 39281 00007A05 6E616D652028616C70-
 39281 00007A0E 686162657469632920-
 39281 00007A17 202020202020532020-
 39281 00007A20 42792073697A652028-
 39281 00007A29 736D616C6C65737420-
 39281 00007A32 6669727374290D0A   
 39282 00007A3A 202020202020202020-     	db '            E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39282 00007A43 202020452020427920-
 39282 00007A4C 657874656E73696F6E-
 39282 00007A55 2028616C7068616265-
 39282 00007A5E 746963292020442020-
 39282 00007A67 427920646174652026-
 39282 00007A70 2074696D6520286561-
 39282 00007A79 726C69657374206669-
 39282 00007A82 727374290D0A       
 39283                                  MSG_1487:
 39284 00007A88 46                      	db 70
 39285 00007A89 202020202020202020-     	db '            G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39285 00007A92 20202047202047726F-
 39285 00007A9B 757020646972656374-
 39285 00007AA4 6F7269657320666972-
 39285 00007AAD 7374202020202D2020-
 39285 00007AB6 50726566697820746F-
 39285 00007ABF 207265766572736520-
 39285 00007AC8 6F726465720D0A     
 39286                                  MSG_1488:
 39287 00007ACF 7F                      	db 127
 39288 00007AD0 202020202020202020-     	db '            C  By compression ratio (smallest first)',0Dh,0Ah
 39288 00007AD9 202020432020427920-
 39288 00007AE2 636F6D707265737369-
 39288 00007AEB 6F6E20726174696F20-
 39288 00007AF4 28736D616C6C657374-
 39288 00007AFD 206669727374290D0A 
 39289 00007B06 20202F532020202020-     	db '  /S      Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39289 00007B0F 20446973706C617973-
 39289 00007B18 2066696C657320696E-
 39289 00007B21 207370656369666965-
 39289 00007B2A 64206469726563746F-
 39289 00007B33 727920616E6420616C-
 39289 00007B3C 6C2073756264697265-
 39289 00007B45 63746F726965732E0D-
 39289 00007B4E 0A                 
 39290                                  MSG_1489:
 39291 00007B4F 41                      	db 65
 39292 00007B50 20202F422020202020-     	db '  /B      Uses bare format (no heading information or summary).',0Dh,0Ah
 39292 00007B59 205573657320626172-
 39292 00007B62 6520666F726D617420-
 39292 00007B6B 286E6F206865616469-
 39292 00007B74 6E6720696E666F726D-
 39292 00007B7D 6174696F6E206F7220-
 39292 00007B86 73756D6D617279292E-
 39292 00007B8F 0D0A               
 39293                                  MSG_1490:
 39294 00007B91 1B                      	db 27
 39295 00007B92 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39295 00007B9B 2055736573206C6F77-
 39295 00007BA4 6572636173652E0D0A 
 39296                                  MSG_1491:
 39297 00007BAD 52                      	db 82
 39298 00007BAE 20202F435B485D2020-     	db '  /C[H]   Displays file compression ratio; /CH uses host allocation unit size.',0Dh,0Ah
 39298 00007BB7 20446973706C617973-
 39298 00007BC0 2066696C6520636F6D-
 39298 00007BC9 7072657373696F6E20-
 39298 00007BD2 726174696F3B202F43-
 39298 00007BDB 48207573657320686F-
 39298 00007BE4 737420616C6C6F6361-
 39298 00007BED 74696F6E20756E6974-
 39298 00007BF6 2073697A652E0D0A   
 39299 00007BFE 0D0A                    	db 0Dh,0Ah
 39300                                  MSG_1492:
 39301 00007C00 92                      	db 146
 39302 00007C01 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39302 00007C0A 6D6179206265207072-
 39302 00007C13 6573657420696E2074-
 39302 00007C1C 686520444952434D44-
 39302 00007C25 20656E7669726F6E6D-
 39302 00007C2E 656E74207661726961-
 39302 00007C37 626C652E20204F7665-
 39302 00007C40 72726964650D0A     
 39303 00007C47 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39303 00007C50 697463686573206279-
 39303 00007C59 20707265666978696E-
 39303 00007C62 6720616E7920737769-
 39303 00007C6B 746368207769746820-
 39303 00007C74 2D202868797068656E-
 39303 00007C7D 292D2D666F72206578-
 39303 00007C86 616D706C652C202F2D-
 39303 00007C8F 572E0D0A           
 39304                                  MSG_1493:
 39305 00007C93 16                      	db 22
 39306 00007C94 202020205B2F535D20-     	db '    [/S] [/B] [/L]',0Dh,0Ah
 39306 00007C9D 5B2F425D205B2F4C5D-
 39306 00007CA6 0D0A               
 39307 00007CA8 0D0A                    	db 0Dh,0Ah
 39308                                  MSG_1494:
 39309 00007CAA 1D                      	db 29
 39310 00007CAB 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39310 00007CB4 2055736573206C6F77-
 39310 00007CBD 6572636173652E0D0A 
 39311 00007CC6 0D0A                    	db 0Dh,0Ah
 39312                                  
 39313                                  MSG_1500:
 39314 00007CC8 3E                      	db 62
 39315 00007CC9 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 39315 00007CD2 20434F4D4D414E442E-
 39315 00007CDB 434F4D2070726F6772-
 39315 00007CE4 616D2028636F6D6D61-
 39315 00007CED 6E6420696E74657270-
 39315 00007CF6 7265746572292E0D0A 
 39316 00007CFF 0D0A                    	db 0Dh,0Ah
 39317 00007D01 455849540D0A            	db 'EXIT',0Dh,0Ah
 39318                                  MSG_1520:
 39319 00007D07 3D                      	db 61
 39320 00007D08 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 39320 00007D11 206469726563746F72-
 39320 00007D1A 792E0D0A           
 39321 00007D1E 0D0A                    	db 0Dh,0Ah
 39322 00007D20 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 39322 00007D29 6976653A5D70617468-
 39322 00007D32 0D0A               
 39323 00007D34 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 39323 00007D3D 3A5D706174680D0A   
 39324                                  MSG_1540:
 39325 00007D45 5D                      	db 93
 39326 00007D46 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 39326 00007D4F 6F7220736574732061-
 39326 00007D58 207365617263682070-
 39326 00007D61 61746820666F722065-
 39326 00007D6A 786563757461626C65-
 39326 00007D73 2066696C65732E0D0A 
 39327 00007D7C 0D0A                    	db 0Dh,0Ah
 39328 00007D7E 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 39328 00007D87 6976653A5D70617468-
 39328 00007D90 5B3B2E2E2E5D5D0D0A 
 39329 00007D99 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 39330 00007DA1 0D0A                    	db 0Dh,0Ah
 39331                                  MSG_1541:
 39332 00007DA3 6B                      	db 107
 39333 00007DA4 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 39333 00007DAD 203B20746F20636C65-
 39333 00007DB6 617220616C6C207365-
 39333 00007DBF 617263682D70617468-
 39333 00007DC8 2073657474696E6773-
 39333 00007DD1 20616E642064697265-
 39333 00007DDA 6374204D532D444F53-
 39333 00007DE3 20746F207365617263-
 39333 00007DEC 680D0A             
 39334 00007DEF 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 39334 00007DF8 68652063757272656E-
 39334 00007E01 74206469726563746F-
 39334 00007E0A 72792E0D0A         
 39335                                  MSG_1542:	
 39336 00007E0F 3B                      	db 59
 39337 00007E10 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 39337 00007E19 20776974686F757420-
 39337 00007E22 706172616D65746572-
 39337 00007E2B 7320746F2064697370-
 39337 00007E34 6C6179207468652063-
 39337 00007E3D 757272656E74207061-
 39337 00007E46 74682E0D0A         
 39338                                  MSG_1560:
 39339 00007E4B 37                      	db 55
 39340 00007E4C 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 39340 00007E55 6865204D532D444F53-
 39340 00007E5E 20636F6D6D616E6420-
 39340 00007E67 70726F6D70742E0D0A 
 39341 00007E70 0D0A                    	db 0Dh,0Ah
 39342 00007E72 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 39342 00007E7B 6578745D0D0A       
 39343 00007E81 0D0A                    	db 0Dh,0Ah
 39344                                  MSG_1561:	
 39345 00007E83 7C                      	db 124
 39346 00007E84 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 39346 00007E8D 205370656369666965-
 39346 00007E96 732061206E65772063-
 39346 00007E9F 6F6D6D616E64207072-
 39346 00007EA8 6F6D70742E0D0A     
 39347 00007EAF 0D0A                    	db 0Dh,0Ah
 39348 00007EB1 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 39348 00007EBA 6E206265206D616465-
 39348 00007EC3 207570206F66206E6F-
 39348 00007ECC 726D616C2063686172-
 39348 00007ED5 61637465727320616E-
 39348 00007EDE 642074686520666F6C-
 39348 00007EE7 6C6F77696E67207370-
 39348 00007EF0 656369616C20636F64-
 39348 00007EF9 65733A0D0A         
 39349 00007EFE 0D0A                    	db 0Dh,0Ah
 39350                                  MSG_1562:
 39351 00007F00 2F                      	db 47
 39352 00007F01 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 39352 00007F0A 28657175616C207369-
 39352 00007F13 676E290D0A         
 39353 00007F18 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 39353 00007F21 28646F6C6C61722073-
 39353 00007F2A 69676E290D0A       
 39354                                  MSG_1563:
 39355 00007F30 2A                      	db 42
 39356 00007F31 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 39356 00007F3A 7272656E742074696D-
 39356 00007F43 650D0A             
 39357 00007F46 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 39357 00007F4F 7272656E7420646174-
 39357 00007F58 650D0A             
 39358                                  MSG_1564:
 39359 00007F5B 3D                      	db 61
 39360 00007F5C 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 39360 00007F65 7272656E7420647269-
 39360 00007F6E 766520616E64207061-
 39360 00007F77 74680D0A           
 39361 00007F7B 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 39361 00007F84 2D444F532076657273-
 39361 00007F8D 696F6E206E756D6265-
 39361 00007F96 720D0A             
 39362                                  MSG_1565:
 39363 00007F99 34                      	db 52
 39364 00007F9A 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 39364 00007FA3 7272656E7420647269-
 39364 00007FAC 76650D0A           
 39365 00007FB0 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 39365 00007FB9 28677265617465722D-
 39365 00007FC2 7468616E207369676E-
 39365 00007FCB 290D0A             
 39366                                  MSG_1566:
 39367 00007FCE 2C                      	db 44
 39368 00007FCF 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 39368 00007FD8 286C6573732D746861-
 39368 00007FE1 6E207369676E290D0A 
 39369 00007FEA 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 39369 00007FF3 2870697065290D0A   
 39370                                  MSG_1567:
 39371 00007FFB 79                      	db 121
 39372 00007FFC 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 39372 00008005 636B73706163652028-
 39372 0000800E 657261736573207072-
 39372 00008017 6576696F7573206368-
 39372 00008020 61726163746572290D-
 39372 00008029 0A                 
 39373 0000802A 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 39373 00008033 6361706520636F6465-
 39373 0000803C 202841534349492063-
 39373 00008045 6F6465203237290D0A 
 39374 0000804E 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 39374 00008057 727269616765207265-
 39374 00008060 7475726E20616E6420-
 39374 00008069 6C696E65666565640D-
 39374 00008072 0A                 
 39375 00008073 0D0A                    	db 0Dh,0Ah
 39376                                  MSG_1568:
 39377 00008075 4C                      	db 76
 39378 00008076 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 39378 0000807F 505420776974686F75-
 39378 00008088 7420706172616D6574-
 39378 00008091 65727320746F207265-
 39378 0000809A 736574207468652070-
 39378 000080A3 726F6D707420746F20-
 39378 000080AC 746865206465666175-
 39378 000080B5 6C742073657474696E-
 39378 000080BE 672E0D0A           
 39379                                  MSG_1580:
 39380 000080C2 47                      	db 71
 39381 000080C3 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 39381 000080CC 64656C657465732920-
 39381 000080D5 61206469726563746F-
 39381 000080DE 72792E0D0A         
 39382 000080E3 0D0A                    	db 0Dh,0Ah
 39383 000080E5 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 39383 000080EE 6976653A5D70617468-
 39383 000080F7 0D0A               
 39384 000080F9 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 39384 00008102 3A5D706174680D0A   
 39385                                  MSG_1600:
 39386 0000810A 1C                      	db 28
 39387 0000810B 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 39387 00008114 2066696C65206F7220-
 39387 0000811D 66696C65732E0D0A   
 39388 00008125 0D0A                    	db 0Dh,0Ah
 39389                                  MSG_1601:
 39390 00008127 53                      	db 83
 39391 00008128 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 39391 00008131 726976653A5D5B7061-
 39391 0000813A 74685D66696C656E61-
 39391 00008143 6D65312066696C656E-
 39391 0000814C 616D65320D0A       
 39392 00008152 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 39392 0000815B 653A5D5B706174685D-
 39392 00008164 66696C656E616D6531-
 39392 0000816D 2066696C656E616D65-
 39392 00008176 320D0A             
 39393 00008179 0D0A                    	db 0Dh,0Ah
 39394                                  MSG_1602:
 39395                                  	;db 77
 39396                                  	;db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39397                                  
 39398                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39399                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:8697h
 39400                                  MSG_1602:
 39401 0000817B A0                      	db 160
 39402 0000817C 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39402 00008185 20796F752063616E6E-
 39402 0000818E 6F7420737065636966-
 39402 00008197 792061206E65772064-
 39402 000081A0 72697665206F722070-
 39402 000081A9 61746820666F722079-
 39402 000081B2 6F7572206465737469-
 39402 000081BB 6E6174696F6E206669-
 39402 000081C4 6C652E0D0A         
 39403 000081C9 0D0A                    	db 0Dh,0Ah
 39404 000081CB 557365204D4F564520-     	db 'Use MOVE to rename a directory, or to move files from one directory to another.',0Dh,0Ah
 39404 000081D4 746F2072656E616D65-
 39404 000081DD 206120646972656374-
 39404 000081E6 6F72792C206F722074-
 39404 000081EF 6F206D6F7665206669-
 39404 000081F8 6C65732066726F6D20-
 39404 00008201 6F6E65206469726563-
 39404 0000820A 746F727920746F2061-
 39404 00008213 6E6F746865722E0D0A 
 39405                                  MSG_1620:
 39406 0000821C 57                      	db 87
 39407 0000821D 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 39407 00008226 20736574732C206F72-
 39407 0000822F 2072656D6F76657320-
 39407 00008238 4D532D444F5320656E-
 39407 00008241 7669726F6E6D656E74-
 39407 0000824A 207661726961626C65-
 39407 00008253 732E0D0A           
 39408 00008257 0D0A                    	db 0Dh,0Ah
 39409 00008259 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 39409 00008262 61626C653D5B737472-
 39409 0000826B 696E675D5D0D0A     
 39410 00008272 0D0A                    	db 0Dh,0Ah
 39411                                  MSG_1621:
 39412 00008274 81                      	db 129
 39413 00008275 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 39413 0000827E 652020537065636966-
 39413 00008287 696573207468652065-
 39413 00008290 6E7669726F6E6D656E-
 39413 00008299 742D7661726961626C-
 39413 000082A2 65206E616D652E0D0A 
 39414 000082AB 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 39414 000082B4 202020537065636966-
 39414 000082BD 696573206120736572-
 39414 000082C6 696573206F66206368-
 39414 000082CF 617261637465727320-
 39414 000082D8 746F2061737369676E-
 39414 000082E1 20746F207468652076-
 39414 000082EA 61726961626C652E0D-
 39414 000082F3 0A                 
 39415 000082F4 0D0A                    	db 0Dh,0Ah
 39416                                  MSG_1622:
 39417 000082F6 4B                      	db 75
 39418 000082F7 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 39418 00008300 776974686F75742070-
 39418 00008309 6172616D6574657273-
 39418 00008312 20746F20646973706C-
 39418 0000831B 617920746865206375-
 39418 00008324 7272656E7420656E76-
 39418 0000832D 69726F6E6D656E7420-
 39418 00008336 7661726961626C6573-
 39418 0000833F 2E0D0A             
 39419                                  MSG_1640:
 39420                                  	;db 52
 39421                                  	;db 'Displays or sets the system time.',0Dh,0Ah
 39422                                  	;db 0Dh,0Ah
 39423                                  	;db 'TIME [time]',0Dh,0Ah
 39424                                  	;db 0Dh,0Ah
 39425                                  
 39426                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39427                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:885Eh)
 39428 00008342 2D                      	db 45
 39429 00008343 446973706C61797320-     	db 'Displays or sets the time.',0Dh,0Ah
 39429 0000834C 6F7220736574732074-
 39429 00008355 68652074696D652E0D-
 39429 0000835E 0A                 
 39430 0000835F 0D0A                    	db 0Dh,0Ah
 39431 00008361 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 39431 0000836A 655D0D0A           
 39432 0000836E 0D0A                    	db 0Dh,0Ah
 39433                                  MSG_1641:
 39434 00008370 83                      	db 131
 39435 00008371 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 39435 0000837A 2077697468206E6F20-
 39435 00008383 706172616D65746572-
 39435 0000838C 7320746F2064697370-
 39435 00008395 6C6179207468652063-
 39435 0000839E 757272656E74207469-
 39435 000083A7 6D652073657474696E-
 39435 000083B0 6720616E6420612070-
 39435 000083B9 726F6D70740D0A     
 39436 000083C0 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 39436 000083C9 206F6E652E20205072-
 39436 000083D2 65737320454E544552-
 39436 000083DB 20746F206B65657020-
 39436 000083E4 7468652073616D6520-
 39436 000083ED 74696D652E0D0A     
 39437                                  MSG_1660:
 39438 000083F4 46                      	db 70
 39439 000083F5 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 39439 000083FE 74686520636F6E7465-
 39439 00008407 6E7473206F66206120-
 39439 00008410 746578742066696C65-
 39439 00008419 2E0D0A             
 39440 0000841C 0D0A                    	db 0Dh,0Ah
 39441 0000841E 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 39441 00008427 76653A5D5B70617468-
 39441 00008430 5D66696C656E616D65-
 39441 00008439 0D0A               
 39442                                  MSG_1680:
 39443 0000843B 25                      	db 37
 39444 0000843C 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 39444 00008445 746865204D532D444F-
 39444 0000844E 532076657273696F6E-
 39444 00008457 2E0D0A             
 39445 0000845A 0D0A                    	db 0Dh,0Ah
 39446 0000845C 5645520D0A              	db 'VER',0Dh,0Ah
 39447                                  MSG_1700:
 39448 00008461 B1                      	db 177
 39449 00008462 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 39449 0000846B 444F53207768657468-
 39449 00008474 657220746F20766572-
 39449 0000847D 696679207468617420-
 39449 00008486 796F75722066696C65-
 39449 0000848F 732061726520777269-
 39449 00008498 7474656E20636F7272-
 39449 000084A1 6563746C7920746F20-
 39449 000084AA 610D0A             
 39450 000084AD 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 39451 000084B4 0D0A                    	db 0Dh,0Ah
 39452 000084B6 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 39452 000084BF 4E207C204F46465D0D-
 39452 000084C8 0A                 
 39453 000084C9 0D0A                    	db 0Dh,0Ah
 39454 000084CB 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 39454 000084D4 465920776974686F75-
 39454 000084DD 74206120706172616D-
 39454 000084E6 6574657220746F2064-
 39454 000084EF 6973706C6179207468-
 39454 000084F8 652063757272656E74-
 39454 00008501 205645524946592073-
 39454 0000850A 657474696E672E0D0A 
 39455                                  MSG_1720:              
 39456 00008513 52                      	db 82
 39457 00008514 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 39457 0000851D 746865206469736B20-
 39457 00008526 766F6C756D65206C61-
 39457 0000852F 62656C20616E642073-
 39457 00008538 657269616C206E756D-
 39457 00008541 6265722C2069662074-
 39457 0000854A 686579206578697374-
 39457 00008553 2E0D0A             
 39458 00008556 0D0A                    	db 0Dh,0Ah
 39459 00008558 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 39459 00008561 653A5D0D0A         
 39460                                  MSG_1740:
 39461 00008566 5B                      	db 91
 39462 00008567 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 39462 00008570 206261746368207072-
 39462 00008579 6F6772616D2066726F-
 39462 00008582 6D20616E6F74686572-
 39462 0000858B 2E0D0A             
 39463 0000858E 0D0A                    	db 0Dh,0Ah
 39464 00008590 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 39464 00008599 76653A5D5B70617468-
 39464 000085A2 5D66696C656E616D65-
 39464 000085AB 205B62617463682D70-
 39464 000085B4 6172616D6574657273-
 39464 000085BD 5D0D0A             
 39465 000085C0 0D0A                    	db 0Dh,0Ah
 39466                                  MSG_1741:
 39467 000085C2 72                      	db 114
 39468 000085C3 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 39468 000085CC 6172616D6574657273-
 39468 000085D5 202020537065636966-
 39468 000085DE 69657320616E792063-
 39468 000085E7 6F6D6D616E642D6C69-
 39468 000085F0 6E6520696E666F726D-
 39468 000085F9 6174696F6E20726571-
 39468 00008602 756972656420627920-
 39468 0000860B 7468650D0A         
 39469 00008610 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 39469 00008619 202020202020202020-
 39469 00008622 202020626174636820-
 39469 0000862B 70726F6772616D2E0D-
 39469 00008634 0A                 
 39470                                  MSG_1760:	
 39471 00008635 4C                      	db 76
 39472 00008636 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 39472 0000863F 6F6D6D656E74732028-
 39472 00008648 72656D61726B732920-
 39472 00008651 696E20612062617463-
 39472 0000865A 682066696C65206F72-
 39472 00008663 20434F4E4649472E53-
 39472 0000866C 59532E0D0A         
 39473 00008671 0D0A                    	db 0Dh,0Ah
 39474 00008673 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 39474 0000867C 656E745D0D0A       
 39475                                  MSG_1780:
 39476 00008682 6B                      	db 107
 39477 00008683 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 39477 0000868C 70726F63657373696E-
 39477 00008695 67206F662061206261-
 39477 0000869E 7463682070726F6772-
 39477 000086A7 616D20616E64206469-
 39477 000086B0 73706C617973207468-
 39477 000086B9 65206D657373616765-
 39477 000086C2 2022               
 39478 000086C4 507265737320616E79-     	db 'Press any',0Dh,0Ah
 39478 000086CD 0D0A               
 39479 000086CF 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 39479 000086D8 6E74696E75652E2E2E-
 39479 000086E1 2E220D0A           
 39480 000086E5 0D0A                    	db 0Dh,0Ah
 39481 000086E7 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 39482                                  MSG_1800:
 39483 000086EE 4D                      	db 77
 39484 000086EF 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 39484 000086F8 6D657373616765732C-
 39484 00008701 206F72207475726E73-
 39484 0000870A 20636F6D6D616E642D-
 39484 00008713 6563686F696E67206F-
 39484 0000871C 6E206F72206F66662E-
 39484 00008725 0D0A               
 39485 00008727 0D0A                    	db 0Dh,0Ah
 39486 00008729 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 39486 00008732 4E207C204F46465D0D-
 39486 0000873B 0A                 
 39487                                  MSG_1801:
 39488 0000873C 57                      	db 87
 39489 0000873D 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 39489 00008746 6573736167655D0D0A 
 39490 0000874F 0D0A                    	db 0Dh,0Ah
 39491 00008751 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 39491 0000875A 20776974686F757420-
 39491 00008763 706172616D65746572-
 39491 0000876C 7320746F2064697370-
 39491 00008775 6C6179207468652063-
 39491 0000877E 757272656E74206563-
 39491 00008787 686F2073657474696E-
 39491 00008790 672E               
 39492 00008792 0D0A                    	db 0Dh,0Ah
 39493                                  MSG_1820:
 39494 00008794 47                      	db 71
 39495 00008795 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 39495 0000879E 532D444F5320746F20-
 39495 000087A7 61206C6162656C6C65-
 39495 000087B0 64206C696E6520696E-
 39495 000087B9 206120626174636820-
 39495 000087C2 70726F6772616D2E0D-
 39495 000087CB 0A                 
 39496 000087CC 0D0A                    	db 0Dh,0Ah
 39497 000087CE 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 39497 000087D7 6C0D0A             
 39498 000087DA 0D0A                    	db 0Dh,0Ah
 39499                                  MSG_1821:
 39500 000087DC 8A                      	db 138
 39501 000087DD 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 39501 000087E6 205370656369666965-
 39501 000087EF 732061207465787420-
 39501 000087F8 737472696E67207573-
 39501 00008801 656420696E20746865-
 39501 0000880A 206261746368207072-
 39501 00008813 6F6772616D20617320-
 39501 0000881C 61206C6162656C2E0D-
 39501 00008825 0A                 
 39502 00008826 0D0A                    	db 0Dh,0Ah
 39503 00008828 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 39503 00008831 61206C6162656C206F-
 39503 0000883A 6E2061206C696E6520-
 39503 00008843 627920697473656C66-
 39503 0000884C 2C20626567696E6E69-
 39503 00008855 6E6720776974682061-
 39503 0000885E 20636F6C6F6E2E0D0A 
 39504                                  MSG_1840:
 39505 00008867 4A                      	db 74
 39506 00008868 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 39506 00008871 686520706F73697469-
 39506 0000887A 6F6E206F6620726570-
 39506 00008883 6C61636561626C6520-
 39506 0000888C 706172616D65746572-
 39506 00008895 7320696E2061206261-
 39506 0000889E 7463682066696C652E-
 39506 000088A7 0D0A               
 39507 000088A9 0D0A                    	db 0Dh,0Ah
 39508 000088AB 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 39509                                  MSG_1860:
 39510 000088B2 5A                      	db 90
 39511 000088B3 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 39511 000088BC 636F6E646974696F6E-
 39511 000088C5 616C2070726F636573-
 39511 000088CE 73696E6720696E2062-
 39511 000088D7 617463682070726F67-
 39511 000088E0 72616D732E0D0A     
 39512 000088E7 0D0A                    	db 0Dh,0Ah
 39513 000088E9 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 39513 000088F2 4552524F524C455645-
 39513 000088FB 4C206E756D62657220-
 39513 00008904 636F6D6D616E640D0A 
 39514                                  MSG_1861:
 39515 0000890D 46                      	db 70
 39516 0000890E 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 39516 00008917 737472696E67313D3D-
 39516 00008920 737472696E67322063-
 39516 00008929 6F6D6D616E640D0A   
 39517 00008931 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 39517 0000893A 45584953542066696C-
 39517 00008943 656E616D6520636F6D-
 39517 0000894C 6D616E640D0A       
 39518 00008952 0D0A                    	db 0Dh,0Ah
 39519                                  MSG_1862:
 39520 00008954 7D                      	db 125
 39521 00008955 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 39521 0000895E 202020202020202020-
 39521 00008967 202053706563696669-
 39521 00008970 65732074686174204D-
 39521 00008979 532D444F532073686F-
 39521 00008982 756C64206361727279-
 39521 0000898B 206F75742074686520-
 39521 00008994 636F6D6D616E64206F-
 39521 0000899D 6E6C790D0A         
 39522 000089A2 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 39522 000089AB 202020202020202020-
 39522 000089B4 202069662074686520-
 39522 000089BD 636F6E646974696F6E-
 39522 000089C6 2069732066616C7365-
 39522 000089CF 2E0D0A             
 39523                                  MSG_1863:
 39524 000089D2 A2                      	db 162
 39525 000089D3 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 39525 000089DC 56454C206E756D6265-
 39525 000089E5 722053706563696669-
 39525 000089EE 657320612074727565-
 39525 000089F7 20636F6E646974696F-
 39525 00008A00 6E2069662074686520-
 39525 00008A09 6C6173742070726F67-
 39525 00008A12 72616D2072756E2072-
 39525 00008A1B 657475726E65640D0A 
 39526 00008A24 202020202020202020-     	db '                    '
 39526 00008A2D 202020202020202020-
 39526 00008A36 2020               
 39527 00008A38 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 39527 00008A41 6F646520657175616C-
 39527 00008A4A 20746F206F72206772-
 39527 00008A53 656174657220746861-
 39527 00008A5C 6E20746865206E756D-
 39527 00008A65 626572207370656369-
 39527 00008A6E 666965642E0D0A     
 39528                                  MSG_1864:
 39529 00008A75 66                      	db 102
 39530 00008A76 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 39530 00008A7F 202020202020202020-
 39530 00008A88 202053706563696669-
 39530 00008A91 65732074686520636F-
 39530 00008A9A 6D6D616E6420746F20-
 39530 00008AA3 6361727279206F7574-
 39530 00008AAC 206966207468652063-
 39530 00008AB5 6F6E646974696F6E20-
 39530 00008ABE 69730D0A           
 39531 00008AC2 202020202020202020-     	db '                    met.',0Dh,0Ah
 39531 00008ACB 202020202020202020-
 39531 00008AD4 20206D65742E0D0A   
 39532                                  MSG_1865:
 39533 00008ADC 6A                      	db 106
 39534 00008ADD 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 39534 00008AE6 3D3D737472696E6732-
 39534 00008AEF 202053706563696669-
 39534 00008AF8 657320612074727565-
 39534 00008B01 20636F6E646974696F-
 39534 00008B0A 6E2069662074686520-
 39534 00008B13 737065636966696564-
 39534 00008B1C 207465787420737472-
 39534 00008B25 696E67730D0A       
 39535 00008B2B 202020202020202020-     	db '                    match.',0Dh,0Ah
 39535 00008B34 202020202020202020-
 39535 00008B3D 20206D617463682E0D-
 39535 00008B46 0A                 
 39536                                  MSG_1866:
 39537 00008B47 67                      	db 103
 39538 00008B48 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 39538 00008B51 696C656E616D652020-
 39538 00008B5A 202053706563696669-
 39538 00008B63 657320612074727565-
 39538 00008B6C 20636F6E646974696F-
 39538 00008B75 6E2069662074686520-
 39538 00008B7E 737065636966696564-
 39538 00008B87 2066696C656E616D65-
 39538 00008B90 0D0A               
 39539 00008B92 202020202020202020-     	db '                    exists.',0Dh,0Ah
 39539 00008B9B 202020202020202020-
 39539 00008BA4 20206578697374732E-
 39539 00008BAD 0D0A               
 39540                                  MSG_1880:
 39541 00008BAF 77                      	db 119
 39542 00008BB0 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 39542 00008BB9 656369666965642063-
 39542 00008BC2 6F6D6D616E6420666F-
 39542 00008BCB 722065616368206669-
 39542 00008BD4 6C6520696E20612073-
 39542 00008BDD 6574206F662066696C-
 39542 00008BE6 65732E0D0A         
 39543 00008BEB 0D0A                    	db 0Dh,0Ah
 39544 00008BED 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 39544 00008BF6 61626C6520494E2028-
 39544 00008BFF 7365742920444F2063-
 39544 00008C08 6F6D6D616E64205B63-
 39544 00008C11 6F6D6D616E642D7061-
 39544 00008C1A 72616D65746572735D-
 39544 00008C23 0D0A               
 39545 00008C25 0D0A                    	db 0Dh,0Ah
 39546                                  MSG_1881:
 39547 00008C27 7D                      	db 125
 39548 00008C28 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 39548 00008C31 6C6520205370656369-
 39548 00008C3A 666965732061207265-
 39548 00008C43 706C61636561626C65-
 39548 00008C4C 20706172616D657465-
 39548 00008C55 722E0D0A           
 39549 00008C59 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 39549 00008C62 202020205370656369-
 39549 00008C6B 666965732061207365-
 39549 00008C74 74206F66206F6E6520-
 39549 00008C7D 6F72206D6F72652066-
 39549 00008C86 696C65732E20205769-
 39549 00008C8F 6C646361726473206D-
 39549 00008C98 617920626520757365-
 39549 00008CA1 642E0D0A           
 39550                                  MSG_1882:
 39551 00008CA5 56                      	db 86
 39552 00008CA6 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 39552 00008CAF 202020205370656369-
 39552 00008CB8 666965732074686520-
 39552 00008CC1 636F6D6D616E642074-
 39552 00008CCA 6F206361727279206F-
 39552 00008CD3 757420666F72206561-
 39552 00008CDC 63682066696C652E0D-
 39552 00008CE5 0A                 
 39553 00008CE6 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 39553 00008CEF 2D706172616D657465-
 39553 00008CF8 72730D0A           
 39554                                  MSG_1883:
 39555 00008CFC A2                      	db 162
 39556 00008CFD 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 39556 00008D06 202020205370656369-
 39556 00008D0F 666965732070617261-
 39556 00008D18 6D6574657273206F72-
 39556 00008D21 207377697463686573-
 39556 00008D2A 20666F722074686520-
 39556 00008D33 737065636966696564-
 39556 00008D3C 20636F6D6D616E642E-
 39556 00008D45 0D0A               
 39557 00008D47 0D0A                    	db 0Dh,0Ah
 39558 00008D49 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 39558 00008D52 6520464F5220636F6D-
 39558 00008D5B 6D616E6420696E2061-
 39558 00008D64 206261746368207072-
 39558 00008D6D 6F6772616D2C207370-
 39558 00008D76 656369667920252576-
 39558 00008D7F 61726961626C652069-
 39558 00008D88 6E7374656164206F66-
 39558 00008D91 0D0A               
 39559 00008D93 257661726961626C65-     	db '%variable.',0Dh,0Ah
 39559 00008D9C 2E0D0A             
 39560                                  MSG_1900:
 39561 00008D9F 17                      	db 23
 39562 00008DA0 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 39562 00008DA9 636F6D6D616E64206E-
 39562 00008DB2 616D650D0A         
 39563                                  MSG_1920:
 39564 00008DB7 2F                      	db 47
 39565 00008DB8 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 39565 00008DC1 726F6772616D20696E-
 39565 00008DCA 746F20746865207570-
 39565 00008DD3 706572206D656D6F72-
 39565 00008DDC 7920617265612E0D0A 
 39566 00008DE5 0D0A                    	db 0Dh,0Ah
 39567                                  MSG_1921:
 39568                                  	;db 88
 39569                                  	;db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39570                                  	;db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 39571                                  	;db 0Dh,0Ah
 39572                                  
 39573                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39574                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9303h
 39575 00008DE7 9D                      	db 157
 39576 00008DE8 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39576 00008DF1 5B64726976653A5D5B-
 39576 00008DFA 706174685D66696C65-
 39576 00008E03 6E616D65205B706172-
 39576 00008E0C 616D65746572735D0D-
 39576 00008E15 0A                 
 39577 00008E16 4C4F41444849474820-     	db 'LOADHIGH [/L:region1[,minsize1][;region2[,minsize2]...] [/S]]',0Dh,0Ah
 39577 00008E1F 5B2F4C3A726567696F-
 39577 00008E28 6E315B2C6D696E7369-
 39577 00008E31 7A65315D5B3B726567-
 39577 00008E3A 696F6E325B2C6D696E-
 39577 00008E43 73697A65325D2E2E2E-
 39577 00008E4C 5D205B2F535D5D0D0A 
 39578 00008E55 202020202020202020-     	db '         [drive:][path]filename [parameters]',0Dh,0Ah
 39578 00008E5E 5B64726976653A5D5B-
 39578 00008E67 706174685D66696C65-
 39578 00008E70 6E616D65205B706172-
 39578 00008E79 616D65746572735D0D-
 39578 00008E82 0A                 
 39579 00008E83 0D0A                    	db 0Dh,0Ah
 39580                                  	
 39581                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:8111h)
 39582                                  ;MSG_1922: 	; MSDOS 5.0 COMMAND.COM
 39583                                  	;db 113
 39584                                  	;db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 39585                                  	;db '               program you want to load.',0Dh,0Ah
 39586                                  
 39587                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39588                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:93A1h
 39589                                  MSG_1922:
 39590 00008E85 B6                      	db 182
 39591 00008E86 2F4C3A726567696F6E-     	db '/L:region1[,minsize1][;region2[,minsize2]]...',0Dh,0Ah
 39591 00008E8F 315B2C6D696E73697A-
 39591 00008E98 65315D5B3B72656769-
 39591 00008EA1 6F6E325B2C6D696E73-
 39591 00008EAA 697A65325D5D2E2E2E-
 39591 00008EB3 0D0A               
 39592 00008EB5 202020202020202020-     	db '            Specifies the region(s) of memory into which to load',0Dh,0Ah
 39592 00008EBE 202020537065636966-
 39592 00008EC7 696573207468652072-
 39592 00008ED0 6567696F6E28732920-
 39592 00008ED9 6F66206D656D6F7279-
 39592 00008EE2 20696E746F20776869-
 39592 00008EEB 636820746F206C6F61-
 39592 00008EF4 640D0A             
 39593 00008EF7 202020202020202020-     	db '            the program.  Region1 specifies the number of the first',0Dh,0Ah
 39593 00008F00 202020746865207072-
 39593 00008F09 6F6772616D2E202052-
 39593 00008F12 6567696F6E31207370-
 39593 00008F1B 656369666965732074-
 39593 00008F24 6865206E756D626572-
 39593 00008F2D 206F66207468652066-
 39593 00008F36 697273740D0A       
 39594                                  MSG_1923:
 39595 00008F3C 85                      	db 133
 39596 00008F3D 202020202020202020-     	db '            memory region; minsize1 specifies the minimum size, if',0Dh,0Ah
 39596 00008F46 2020206D656D6F7279-
 39596 00008F4F 20726567696F6E3B20-
 39596 00008F58 6D696E73697A653120-
 39596 00008F61 737065636966696573-
 39596 00008F6A 20746865206D696E69-
 39596 00008F73 6D756D2073697A652C-
 39596 00008F7C 2069660D0A         
 39597 00008F81 202020202020202020-     	db '            any, for region1.  Region2 and minsize2 specify the',0Dh
 39597 00008F8A 202020616E792C2066-
 39597 00008F93 6F7220726567696F6E-
 39597 00008F9C 312E2020526567696F-
 39597 00008FA5 6E3220616E64206D69-
 39597 00008FAE 6E73697A6532207370-
 39597 00008FB7 656369667920746865-
 39597 00008FC0 0D                 
 39598 00008FC1 0A                      	db 0Ah
 39599                                  MSG_1924:
 39600 00008FC2 7F                      	db 127
 39601 00008FC3 202020202020202020-     	db '            number and minimum size of the second region, if any.',0Dh,0Ah
 39601 00008FCC 2020206E756D626572-
 39601 00008FD5 20616E64206D696E69-
 39601 00008FDE 6D756D2073697A6520-
 39601 00008FE7 6F6620746865207365-
 39601 00008FF0 636F6E642072656769-
 39601 00008FF9 6F6E2C20696620616E-
 39601 00009002 792E0D0A           
 39602 00009006 202020202020202020-     	db '            You can specify as many regions as you want.',0Dh,0Ah
 39602 0000900F 202020596F75206361-
 39602 00009018 6E2073706563696679-
 39602 00009021 206173206D616E7920-
 39602 0000902A 726567696F6E732061-
 39602 00009033 7320796F752077616E-
 39602 0000903C 742E0D0A           
 39603 00009040 0D0A                    	db 0Dh,0Ah
 39604                                  MSG_1925:
 39605 00009042 83                      	db 131
 39606 00009043 2F5320202020202020-     	db '/S          Shrinks a UMB to its minimum size while the program',0Dh,0Ah
 39606 0000904C 202020536872696E6B-
 39606 00009055 73206120554D422074-
 39606 0000905E 6F20697473206D696E-
 39606 00009067 696D756D2073697A65-
 39606 00009070 207768696C65207468-
 39606 00009079 652070726F6772616D-
 39606 00009082 0D0A               
 39607 00009084 202020202020202020-     	db '            is loading.  /S is normally used only by MemMaker.',0Dh,0Ah
 39607 0000908D 2020206973206C6F61-
 39607 00009096 64696E672E20202F53-
 39607 0000909F 206973206E6F726D61-
 39607 000090A8 6C6C79207573656420-
 39607 000090B1 6F6E6C79206279204D-
 39607 000090BA 656D4D616B65722E0D-
 39607 000090C3 0A                 
 39608 000090C4 0D0A                    	db 0Dh,0Ah
 39609                                  MSG_1926:
 39610 000090C6 57                      	db 87
 39611 000090C7 5B64726976653A5D5B-     	db '[drive:][path]filename',0Dh,0Ah
 39611 000090D0 706174685D66696C65-
 39611 000090D9 6E616D650D0A       
 39612 000090DF 202020202020202020-     	db '            Specifies the location and name of the program.',0Dh,0Ah
 39612 000090E8 202020537065636966-
 39612 000090F1 69657320746865206C-
 39612 000090FA 6F636174696F6E2061-
 39612 00009103 6E64206E616D65206F-
 39612 0000910C 66207468652070726F-
 39612 00009115 6772616D2E0D0A     
 39613 0000911C 0D0A                    	db 0Dh,0Ah
 39614                                  
 39615                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39616                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:963Ah
 39617                                  MSG_1927:
 39618 0000911E 5A                      	db 90
 39619 0000911F 706172616D65746572-     	db 'parameters  Specifies any command-line information required by',0Dh,0Ah
 39619 00009128 732020537065636966-
 39619 00009131 69657320616E792063-
 39619 0000913A 6F6D6D616E642D6C69-
 39619 00009143 6E6520696E666F726D-
 39619 0000914C 6174696F6E20726571-
 39619 00009155 75697265642062790D-
 39619 0000915E 0A                 
 39620 0000915F 202020202020202020-     	db '            the program.',0Dh,0Ah
 39620 00009168 202020746865207072-
 39620 00009171 6F6772616D2E0D0A   
 39621                                  
 39622                                  ; ---------------------------------------------------------------------------
 39623                                  
 39624                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39625                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 39626                                  
 39627                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39628                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9695h
 39629                                  
 39630                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39631                                  
 39632                                  $M_CLS_3:
 39633 00009179 0E                      	push	cs		; CLASS_F
 39634 0000917A 07                      	pop	es
 39635 0000917B 8D3E[1464]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 39636                                  	; 15/04/2023
 39637                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 39638                                  	; 17/06/2023
 39639 0000917F 81C16B2D                	add	cx,11627	; ADD CX,$-$M_CLASS_3_STRUC ; 969Bh-6930h
 39640 00009183 C3                      	retn
 39641                                  
 39642                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39643                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 39644                                  
 39645                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39646                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96A0h
 39647                                  
 39648                                  ; ---------------------------------------------------------------------------
 39649                                  ; Class 1 messages
 39650                                  ; ---------------------------------------------------------------------------
 39651                                  	
 39652                                  $M_CLASS_1_STRUC:
 39653 00009184 01                      	db 1			; $M_CLASS_ID
 39654                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 39655                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39656 00009185 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 39657 00009187 04                      	db 4			; Class_1_MessageCount
 39658                                  $M_ID_1_1:
 39659 00009188 0200                    	dw 2			; Message Number = 2
 39660 0000918A 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 39661                                  $M_ID_1_2:
 39662 0000918C 0300                    	dw 3			; Message Number = 3
 39663 0000918E 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 39664                                  $M_ID_1_3:
 39665 00009190 0800                    	dw 8			; Message Number = 8
 39666 00009192 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 39667                                  $M_ID_1_4:
 39668 00009194 FFFF                    	dw 0FFFFh		; Message Number = -1
 39669 00009196 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 39670                                  
 39671                                  ; ---------------------------------------------------------------------------
 39672                                  
 39673                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 39674                                  EXTEND2:
 39675 00009198 0E                      	db 14
 39676 00009199 46696C65206E6F7420-     	db 'File not found'
 39676 000091A2 666F756E64         
 39677                                  EXTEND3:
 39678 000091A7 0E                      	db 14
 39679 000091A8 50617468206E6F7420-     	db 'Path not found'
 39679 000091B1 666F756E64         
 39680                                  EXTEND8:
 39681 000091B6 13                      	db 19
 39682 000091B7 496E73756666696369-     	db 'Insufficient memory'
 39682 000091C0 656E74206D656D6F72-
 39682 000091C9 79                 
 39683                                  EXTEND999:
 39684 000091CA 11                      	db 17
 39685 000091CB 457874656E64656420-     	db 'Extended Error %1'
 39685 000091D4 4572726F72202531   
 39686                                  
 39687                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39688                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 39689                                  
 39690                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39691                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96F8h
 39692                                  
 39693                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39694                                  $M_MSGSERV_1:
 39695 000091DC 0E                      	push	cs
 39696 000091DD 07                      	pop	es
 39697 000091DE 8D3E[8491]              	lea	di,$M_CLASS_1_STRUC
 39698                                  	; 15/04/2023
 39699                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 39700                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 39701                                  				; 96FEh-96A0h = 5Eh = 94
 39702 000091E2 C3                      	retn
 39703                                  
 39704                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39705                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 39706                                  
 39707                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39708                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9702h
 39709                                  
 39710                                  ; ---------------------------------------------------------------------------
 39711                                  ; Class 2 messages
 39712                                  ; ---------------------------------------------------------------------------
 39713                                  	
 39714                                  $M_CLASS_2_STRUC:
 39715 000091E3 02                      	db 2			; $M_CLASS_ID
 39716                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 39717                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39718 000091E4 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 39719 000091E6 01                      	db 1			; Class_2_MessageCount
 39720                                  $M_ID_2_1:
 39721 000091E7 FFFF                    	dw 0FFFFh		; Message Number = -1
 39722 000091E9 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 39723                                  ; ---------------------------------------------------------------------------
 39724                                  
 39725                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 39726                                  PARSE999:
 39727 000091EB 0E                      	db 14
 39728 000091EC 506172736520457272-     	db 'Parse Error %1'
 39728 000091F5 6F72202531         
 39729                                  
 39730                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39731                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 39732                                  
 39733                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39734                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9719h
 39735                                  
 39736                                  ; --------------- S U B R O U T I N E ---------------------------------------
 39737                                  $M_MSGSERV_2:
 39738 000091FA 0E                      	push	cs
 39739 000091FB 07                      	pop	es
 39740 000091FC 8D3E[E391]              	lea	di,$M_CLASS_2_STRUC
 39741                                  	; 15/04/2023
 39742                                  	;add	cx,29		; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 39743                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 39744                                  				; 971Fh-9702h = 1Dh = 29
 39745 00009200 C3                      	retn
 39746                                  
 39747                                  ;============================================================================
 39748                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 39749                                  ;============================================================================
 39750                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39751                                  ; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39752                                  
 39753                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 39754                                  	
 39755                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9723h
 39756                                  
 39757                                  ;****************************************************
 39758                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 39759                                  ;****************************************************
 39760                                  
 39761                                  msg_disp_class:
 39762 00009201 FF                      	db	util_msg_class ; 0FFh
 39763                                  msg_cont_flag:
 39764 00009202 00                      	db	no_cont_flag ; 0
 39765                                  
 39766                                  ;  extended error string output
 39767                                  extend_buf_ptr:
 39768 00009203 0000                    	dw	0			;AN000;set to no message
 39769                                  extend_buf_sub:
 39770 00009205 00                      	db	0			;AN000;set to no substitutions
 39771 00009206 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39772 00009207 00                      	db	0			;AN000;reserved
 39773                                  extend_buf_off:
 39774 00009208 [06A1]                  	dw	string_ptr_2		;AN000;offset of arg
 39775                                  extend_buf_seg:
 39776 0000920A 0000                    	dw	0			;AN000;segment of arg
 39777 0000920C 00                      	db	0			;AN000;first subst
 39778 0000920D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 39779 0000920E 80                      	db	128			;AN000;maximum width
 39780 0000920F 00                      	db	0			;AN000;minimum width
 39781 00009210 20                      	db	blank ; 20h		;AN000;pad character
 39782                                  
 39783                                  ;  "Duplicate file name or file not found"
 39784                                  RENERR_PTR:
 39785 00009211 EA03                    	dw	1002			;AN000;message number
 39786 00009213 00                      	db	no_subst ; 0		;AN000;number of subst
 39787                                  
 39788                                  ;  "Invalid path or file name"
 39789                                  BADCPMES_PTR:
 39790 00009214 EB03                    	dw	1003			;AN000;message number
 39791 00009216 00                      	db	no_subst ; 0		;AN000;number of subst
 39792                                  
 39793                                  ;  "Insufficient disk space"
 39794                                  NOSPACE_PTR:
 39795 00009217 EC03                    	dw	1004			;AN000;message number
 39796 00009219 00                      	db	no_subst ; 0		;AN000;number of subst
 39797                                  
 39798                                  ;  "Out of environment space"
 39799                                  ENVERR_PTR:
 39800 0000921A EF03                    	dw	1007			;AN000;message number
 39801 0000921C 00                      	db	no_subst ; 0		;AN000;number of subst
 39802                                  
 39803                                  ;  "File creation error"
 39804                                  FULLDIR_PTR:
 39805 0000921D F003                    	dw	1008			;AN000;message number
 39806 0000921F 00                      	db	no_subst ; 0		;AN000;number of subst
 39807                                  
 39808                                  ;  "Batch file missing",13,10
 39809                                  BADBAT_PTR:
 39810 00009220 F103                    	dw	1009			;AN000;message number
 39811 00009222 00                      	db	no_subst ; 0		;AN000;number of subst
 39812                                  
 39813                                  ;  "Insert disk with batch file",13,10
 39814                                  NEEDBAT_PTR:
 39815 00009223 F203                    	dw	1010			;AN000;message number
 39816 00009225 00                      	db	no_subst ; 0		;AN000;number of subst
 39817                                  
 39818                                  ;  "Bad command or file name",13,10
 39819                                  BADNAM_PTR:
 39820 00009226 F303                    	dw	1011			;AN000;message number
 39821 00009228 00                      	db	no_subst ; 0		;AN000;number of subst
 39822                                  
 39823                                  ;  "Access denied",13,10
 39824                                  ACCDEN_PTR:
 39825 00009229 F603                    	dw	1014			;AN000;message number
 39826 0000922B 00                      	db	no_subst ; 0		;AN000;number of subst
 39827                                  
 39828                                  ;  "File cannot be copied onto itself",13,10
 39829                                  OVERWR_PTR:
 39830 0000922C F703                    	dw	1015			;AN000;message number
 39831 0000922E 00                      	db	no_subst ; 0		;AN000;number of subst
 39832                                  
 39833                                  ;  "Content of destination lost before copy",13,10
 39834                                  LOSTERR_PTR:
 39835 0000922F F803                    	dw	1016			;AN000;message number
 39836 00009231 00                      	db	no_subst ; 0		;AN000;number of subst
 39837                                  
 39838                                  ;  "Invalid filename or file not found",13,10
 39839                                  INORNOT_PTR:
 39840 00009232 F903                    	dw	1017			;AN000;message number
 39841 00009234 00                      	db	no_subst		;AN000;number of subst
 39842                                  
 39843                                  ;  "%1 File(s) copied",13,10
 39844                                  copied_ptr:
 39845 00009235 FA03                    	dw	1018			;AN000;message number
 39846 00009237 01                      	db	1			;AN000;number of subst
 39847 00009238 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39848 00009239 00                      	db	0			;AN000;reserved
 39849 0000923A [08A1]                  	dw	Copy_num		;AN000;offset of arg
 39850 0000923C 0000                    	dw	0			;AN000;segment of arg
 39851 0000923E 01                      	db	1			;AN000;first subst
 39852 0000923F A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 39853                                  					;AN000;binary to decimal
 39854 00009240 09                      	db	9			;AN000;maximum width
 39855 00009241 09                      	db	9			;AN000;minimum width
 39856 00009242 20                      	db	blank ; 20h		;AN000;pad character
 39857                                  
 39858                                  ;  "%1 File(s) "
 39859                                  dirmes_ptr:
 39860 00009243 FB03                    	dw	1019			;AN000;message number
 39861 00009245 01                      	db	1			;AN000;number of subst
 39862 00009246 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39863 00009247 00                      	db	0			;AN000;reserved
 39864 00009248 [0BA1]                  	dw	Dir_Num			;AN000;offset of arg
 39865 0000924A 0000                    	dw	0			;AN000;segment of arg
 39866 0000924C 01                      	db	1			;AN000;first subst
 39867                                  	; MSDOS 5.0 COMMAND.COM
 39868                                  	;db	0A1h ; Right_Align+Unsgn_Bin_Word
 39869                                  	; 17/06/2023
 39870                                  screen_f_3:
 39871 0000924D E1                      	db	0E1h ; MSDOS 6.22 COMMAND.COM
 39872                                  					;AN000;binary to decimal
 39873 0000924E 09                      	db	9			;AN000;maximum width
 39874 0000924F 09                      	db	9			;AN000;minimum width
 39875 00009250 20                      	db	blank ; 20h		;AN000;pad character
 39876                                  
 39877                                  ;  "%1 bytes free",13,10
 39878                                  bytmes_ptr:
 39879 00009251 FC03                    	dw	1020			;AN000;message number
 39880 00009253 01                      	db	1			;AN000;number of subst
 39881 00009254 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39882 00009255 00                      	db	0			;AN000;reserved
 39883 00009256 [0FA1]                  	dw	Bytes_Free		;AN000;offset of arg
 39884 00009258 0000                    	dw	0			;AN000;segment of arg
 39885 0000925A 01                      	db	1			;AN000;first subst
 39886                                  	; MSDOS 5.0 COMMAND.COM
 39887                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 39888                                  	; 17/06/2023
 39889                                  screen_f_6:
 39890 0000925B F1                      	db	0F1h
 39891                                  					;AN000;long binary to decimal
 39892                                  	; MSDOS 5.0 COMMAND.COM
 39893                                  	;db	28			;AN000;maximum width
 39894                                  	;db	28			;AN000;minimum width
 39895                                  	; 17/06/2023
 39896                                  screen_f_7:
 39897 0000925C 20                      	db	32 ; MSDOS 6.22 COMMAND.COM
 39898 0000925D 20                      	db	32
 39899                                  
 39900 0000925E 20                      	db	blank ; 20h		;AN000;pad character
 39901                                  
 39902                                  ;  "Invalid drive specification",13,10
 39903                                  baddrv_ptr:
 39904 0000925F FD03                    	dw	1021			;AN000;message number
 39905 00009261 00                      	db	no_subst ; 0		;AN000;number of subst
 39906                                  
 39907                                  ;  "Code page %1 not prepared for system",13,10
 39908                                  cp_not_set_ptr:
 39909 00009262 FE03                    	dw	1022			;AN000;message number
 39910 00009264 01                      	db	1			;AN000;number of subst
 39911 00009265 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39912 00009266 00                      	db	0			;AN000;reserved
 39913 00009267 [80A0]                  	dw	system_cpage		;AN000;offset of arg
 39914 00009269 0000                    	dw	0			;AN000;segment of arg
 39915 0000926B 01                      	db	1			;AN000;first subst
 39916 0000926C A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 39917                                  					;AN000;binary to decimal
 39918 0000926D 05                      	db	5			;AN000;maximum width
 39919 0000926E 01                      	db	1			;AN000;minimum width
 39920 0000926F 20                      	db	blank ; 20h		;AN000;pad character
 39921                                  
 39922                                  ;  "Code page %1 not prepared for all devices",13,10
 39923                                  cp_not_all_ptr:
 39924 00009270 FF03                    	dw	1023			;AN000;message number
 39925 00009272 01                      	db	1			;AN000;number of subst
 39926 00009273 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 39927 00009274 00                      	db	0			;AN000;reserved
 39928 00009275 [80A0]                  	dw	system_cpage		;AN000;offset of arg
 39929 00009277 0000                    	dw	0			;AN000;segment of arg
 39930 00009279 01                      	db	1			;AN000;first subst
 39931 0000927A A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 39932                                  					;AN000;binary to decimal
 39933 0000927B 05                      	db	5			;AN000;maximum width
 39934 0000927C 01                      	db	1			;AN000;minimum width
 39935 0000927D 20                      	db	blank ; 20h		;AN000;pad character
 39936                                  
 39937                                  ;  "Active code page: %1",13,10
 39938                                  cp_active_ptr:
 39939 0000927E 0004                    	dw	1024			;AN000;message number
 39940 00009280 01                      	db	1			;AN000;number of subst
 39941 00009281 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39942 00009282 00                      	db	0			;AN000;reserved
 39943 00009283 [80A0]                  	dw	system_cpage		;AN000;offset of arg
 39944 00009285 0000                    	dw	0			;AN000;segment of arg
 39945 00009287 01                      	db	1			;AN000;first subst
 39946 00009288 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 39947                                  					;AN000;binary to decimal
 39948 00009289 05                      	db	5			;AN000;maximum width
 39949 0000928A 01                      	db	1			;AN000;minimum width
 39950 0000928B 20                      	db	blank ; 20h		;AN000;pad character
 39951                                  
 39952                                  ;  "NLSFUNC not installed",13,10
 39953                                  NLSFUNC_PTR:
 39954 0000928C 0104                    	dw	1025			;AN000;message number
 39955 0000928E 00                      	db	no_subst ; 0		;AN000;number of subst
 39956                                  
 39957                                  ;  "Invalid code page",13,10
 39958                                  INV_CODE_PAGE:
 39959 0000928F 0204                    	dw	1026			;AN000;message number
 39960 00009291 00                      	db	no_subst ; 0		;AN000;number of subst
 39961                                  
 39962                                  ;  "Current drive is no longer valid"
 39963                                  BADCURDRV:
 39964 00009292 0304                    	dw	1027			;AN000;message number
 39965 00009294 00                      	db	no_subst ; 0		;AN000;number of subst
 39966                                  
 39967                                  ;  "Press any key to continue"
 39968                                  PAUSEMES_PTR:
 39969 00009295 0404                    	dw	1028			;AN000;message number
 39970 00009297 00                      	db	no_subst ; 0		;AN000;number of subst
 39971                                  
 39972                                  ;  "Label not found",13,10
 39973                                  BADLAB_PTR:
 39974 00009298 0504                    	dw	1029			;AN000;message number
 39975 0000929A 00                      	db	no_subst ; 0		;AN000;number of subst
 39976                                  
 39977                                  ;  "Syntax error",13,10
 39978                                  SYNTMES_PTR:
 39979 0000929B 0604                    	dw	1030			;AN000;message number
 39980 0000929D 00                      	db	no_subst ; 0		;AN000;number of subst
 39981                                  
 39982                                  ;  "Invalid date",13,10
 39983                                  BADDAT_PTR:
 39984 0000929E 0704                    	dw	1031			;AN000;message number
 39985 000092A0 00                      	db	no_subst ; 0		;AN000;number of subst
 39986                                  
 39987                                  ;  "Current date is %1 %2",13,10
 39988                                  CurDat_Ptr:
 39989 000092A1 0804                    	dw	1032			;AN000;message number
 39990 000092A3 02                      	db	2			;AN000;number of subst
 39991 000092A4 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 39992 000092A5 00                      	db	0			;AN000;reserved
 39993 000092A6 [82A0]                  	dw	Arg_Buf			;AN000;offset of arg
 39994 000092A8 0000                    	dw	0			;AN000;segment of arg
 39995 000092AA 01                      	db	1			;AN000;first subst
 39996 000092AB 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 39997 000092AC 03                      	db	3			;AN000;maximum width
 39998 000092AD 03                      	db	3			;AN000;minimum width
 39999 000092AE 20                       	db	blank ; 20h		;AN000;pad character
 40000 000092AF 0B                      	db	parm_block_size 	;AN000;size of sublist
 40001 000092B0 00                      	db	0			;AN000;reserved
 40002                                  CurDat_yr:
 40003 000092B1 0000                    	dw	0			;AN000;year
 40004                                  CurDat_mo_day:
 40005 000092B3 0000                    	dw	0			;AN000;month,day
 40006 000092B5 02                      	db	2			;AN000;second subst
 40007 000092B6 34                      	db	34h ; DATE_MDY_4	;AN000;date
 40008 000092B7 0A                      	db	10			;AN000;maximum width
 40009 000092B8 0A                      	db	10			;AN000;minimum width
 40010 000092B9 20                      	db	blank ; 20h		;AN000;pad character
 40011                                  
 40012                                  ;  "SunMonTueWedThuFriSat"
 40013                                  WeekTab:
 40014 000092BA 0904                    	dw	1033			;AN000;message number
 40015 000092BC 00                      	db	no_subst ; 0		;AN000;number of subst
 40016                                  
 40017                                  ;  "Enter new date (%1):"
 40018                                  
 40019                                  NewDat_Ptr:
 40020 000092BD 0A04                    	dw	1034			;AN000;message number
 40021 000092BF 01                      	db	1			;AN000;number of subst
 40022 000092C0 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40023 000092C1 00                      	db	0			;AN000;reserved
 40024                                  NewDat_Format:
 40025 000092C2 0000                    	dw	0			;AN000;offset of replacement
 40026 000092C4 0000                    	dw	0			;AN000;segment of arg
 40027 000092C6 01                      	db	1			;AN000;first subst
 40028 000092C7 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40029 000092C8 08                      	db	8			;AN000;maximum width
 40030 000092C9 08                      	db	8			;AN000;minimum width
 40031 000092CA 20                      	db	blank ; 20h		;AN000;pad character
 40032                                  
 40033                                  ;  "Invalid time",13,10
 40034                                  
 40035                                  BadTim_Ptr:
 40036 000092CB 0B04                    	dw	1035			;AN000;message number
 40037 000092CD 00                      	db	no_subst ; 0		;AN000;number of subst
 40038                                  
 40039                                  ;  "Current time is %1",13,10
 40040                                  CurTim_Ptr:
 40041 000092CE 0C04                    	dw	1036			;AN000;message number
 40042 000092D0 01                      	db	1			;AN000;number of subst
 40043 000092D1 0B                      	db	parm_block_size 	;AN000;size of sublist
 40044 000092D2 00                      	db	0			;AN000;reserved
 40045                                  CurTim_hr_min:
 40046 000092D3 0000                    	dw	0			;AN000;hours,minutes
 40047                                  CurTim_Sec_hn:
 40048 000092D5 0000                    	dw	0			;AN000;seconds,hundredths
 40049 000092D7 01                      	db	1			;AN000;first subst
 40050 000092D8 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 40051                                  					;AC059;time
 40052 000092D9 0C                      	db	12			;AC059;maximum width
 40053 000092DA 0C                      	db	12			;AC059;minimum width
 40054 000092DB 20                      	db	blank ; 20h		;AN000;pad character
 40055                                  
 40056                                  ;  "Enter new time:"
 40057                                  NewTim_Ptr:
 40058 000092DC 0D04                    	dw	1037			;AN000;message number
 40059 000092DE 00                      	db	no_subst ; 0		;AN000;number of subst
 40060                                  
 40061                                  ;  ",    Delete (Y/N)?",13,10
 40062                                  Del_Y_N_Ptr:
 40063 000092DF 0E04                    	dw	1038			;AN000;message number
 40064 000092E1 00                      	db	no_subst ; 0		;AN000;number of subst
 40065                                  
 40066                                  ;  "All files in directory will be deleted!",13,10
 40067                                  ;  "Are you sure (Y/N)?",13,10
 40068                                  SureMes_Ptr:
 40069 000092E2 0F04                    	dw	1039			;AN000;message number
 40070 000092E4 00                      	db	no_subst ; 0		;AN000;number of subst
 40071                                  
 40072                                  ;  "Microsoft DOS Version %1.%2",13,10
 40073                                  VerMes_Ptr:
 40074 000092E5 1004                    	dw	1040			;AN000;message number
 40075 000092E7 02                      	db	2			;AN000;number of subst
 40076 000092E8 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40077 000092E9 00                      	db	0			;AN000;reserved
 40078 000092EA [13A1]                  	dw	Major_Ver_Num		;AN000;offset of arg
 40079 000092EC 0000                    	dw	0			;AN000;segment of arg
 40080 000092EE 01                      	db	1			;AN000;first subst
 40081 000092EF A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40082                                  					;AN000;binary to decimal
 40083 000092F0 01                      	db	1			;AN000;maximum width
 40084 000092F1 01                      	db	1			;AN000;minimum width
 40085 000092F2 20                      	db	blank ; 20h		;AN000;pad character
 40086 000092F3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40087 000092F4 00                      	db	0			;AN000;reserved
 40088 000092F5 [15A1]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 40089 000092F7 0000                    	dw	0			;AN000;segment of arg
 40090 000092F9 02                      	db	2			;AN000;second subst
 40091 000092FA A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40092                                  					;AN000;binary to decimal
 40093 000092FB 02                      	db	2			;AN000;maximum width
 40094 000092FC 02                      	db	2			;AN000;minimum width
 40095 000092FD 30                      	db	'0' ; 30h		;AN000;pad character
 40096                                  
 40097                                  ;  "Volume in drive %1 has no label",13,10
 40098                                  VolMes_Ptr_2:
 40099 000092FE 1104                    	dw	1041			;AN000;message number
 40100 00009300 01                      	db	1			;AN000;number of subst
 40101 00009301 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40102 00009302 00                      	db	0			;AN000;reserved
 40103 00009303 [19A1]                  	dw	vol_drv			;AN000;offset of drive
 40104 00009305 0000                    	dw	0			;AN000;segment of arg
 40105 00009307 01                      	db	1			;AN000;first subst
 40106 00009308 00                      	db	0 ; Char_field_Char 	;AN000;character
 40107 00009309 80                      	db	128			;AN000;maximum width
 40108 0000930A 01                      	db	1			;AN000;minimum width
 40109 0000930B 20                      	db	blank ; 20h		;AN000;pad character
 40110                                  
 40111                                  ;  "Volume in drive %1 is %2",13,10
 40112                                  VolMes_Ptr:
 40113 0000930C 1204                    	dw	1042			;AN000;message number
 40114 0000930E 02                      	db	2			;AN000;number of subst
 40115 0000930F 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40116 00009310 00                      	db	0			;AN000;reserved
 40117 00009311 [19A1]                  	dw	vol_drv			;AN000;offset of drive
 40118 00009313 0000                    	dw	0			;AN000;segment of arg
 40119 00009315 01                      	db	1			;AN000;first subst
 40120 00009316 00                      	db	00000000b		;AN000;character
 40121 00009317 80                      	db	128			;AN000;maximum width
 40122 00009318 01                      	db	1			;AN000;minimum width
 40123 00009319 20                      	db	blank ; 20h		;AN000;pad character
 40124 0000931A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40125 0000931B 00                      	db	0			;AN000;reserved
 40126 0000931C [509F]                  	dw	CHARBUF			;AN000;offset of string
 40127 0000931E 0000                    	dw	0			;AN000;segment of arg
 40128 00009320 02                      	db	2			;AN000;second subst
 40129 00009321 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40130 00009322 80                      	db	128			;AN000;maximum width
 40131 00009323 01                      	db	1			;AN000;minimum width
 40132 00009324 20                      	db	blank ; 20h		;AN000;pad character
 40133                                  
 40134                                  ;  "Volume Serial Number is %1-%2",13,10
 40135                                  VolSerMes_Ptr:
 40136 00009325 1304                    	dw	1043			;AN000;message number
 40137 00009327 02                      	db	2			;AN000;number of subst
 40138 00009328 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40139 00009329 00                      	db	0			;AN000;reserved
 40140 0000932A [83A2]                  	dw	vol_serial+2		;AN000;offset of serial
 40141 0000932C 0000                    	dw	0			;AN000;segment of arg
 40142 0000932E 01                      	db	1			;AN000;first subst
 40143 0000932F A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 40144                                  					;AN000;binary to hex
 40145 00009330 04                      	db	4			;AN000;maximum width
 40146 00009331 04                      	db	4			;AN000;minimum width
 40147 00009332 30                      	db	'0' ; 30h		;AN000;pad character
 40148 00009333 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40149 00009334 00                      	db	0			;AN000;reserved
 40150 00009335 [81A2]                  	dw	vol_serial		;AN000;offset of serial
 40151 00009337 0000                    	dw	0			;AN000;segment of arg
 40152 00009339 02                      	db	2			;AN000;second subst
 40153 0000933A A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 40154                                  					;AN000;binary to hex
 40155 0000933B 04                      	db	4			;AN000;maximum width
 40156 0000933C 04                      	db	4			;AN000;minimum width
 40157 0000933D 30                      	db	'0' ; 30h		;AN000;pad character
 40158                                  
 40159                                  ;  "Invalid directory",13,10
 40160                                  badcd_ptr:
 40161 0000933E 1404                    	dw	1044			;AN000;message number
 40162 00009340 00                      	db	no_subst ; 0		;AN000;number of subst
 40163                                  
 40164                                  ;  "Unable to create directory",13,10
 40165                                  badmkd_ptr:
 40166 00009341 1504                    	dw	1045			;AN000;message number
 40167 00009343 00                      	db	no_subst ; 0		;AN000;number of subst
 40168                                  
 40169                                  ;  "Invalid path, not directory,",13,10
 40170                                  ;  "or directory not empty",13,10
 40171                                  badrmd_ptr:
 40172 00009344 1604                    	dw	1046			;AN000;message number
 40173 00009346 00                      	db	no_subst ; 0		;AN000;number of subst
 40174                                  
 40175                                  ;  "Must specify ON or OFF",13,10
 40176                                  bad_on_off_ptr:
 40177 00009347 1704                    	dw	1047			;AN000;message number
 40178 00009349 00                      	db	no_subst ; 0		;AN000;number of subst
 40179                                  
 40180                                  ;  "Directory of %1",13,10
 40181                                  dirhead_ptr:
 40182 0000934A 1804                    	dw	1048			;AN000;message number
 40183 0000934C 01                      	db	1			;AN000;number of subst
 40184 0000934D 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40185 0000934E 00                      	db	0			;AN000;reserved
 40186 0000934F [1FA0]                  	dw	BWDBUF			;AN000;offset of arg
 40187 00009351 0000                    	dw	0			;AN000;segment of arg
 40188 00009353 01                      	db	1			;AN000;first subst
 40189 00009354 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40190 00009355 80                      	db	128			;AN000;maximum width
 40191 00009356 00                      	db	0			;AN000;minimum width
 40192 00009357 20                      	db	blank ; 20h		;AN000;pad character
 40193                                  
 40194                                  ;  "No Path",13,10
 40195                                  NULLPATH_PTR:
 40196 00009358 1904                    	dw	1049			;AN000;message number
 40197 0000935A 00                      	db	no_subst ; 0		;AN000;number of subst
 40198                                  
 40199                                  ;  "Invalid drive in search path",13,10
 40200                                  BADPMES_PTR:
 40201 0000935B 1A04                    	dw	1050			;AN000;message number
 40202 0000935D 00                      	db	no_subst ; 0		;AN000;number of subst
 40203                                  
 40204                                  ;  "Invalid device",13,10
 40205                                  BADDEV_PTR:
 40206 0000935E 1B04                    	dw	1051			;AN000;message number
 40207 00009360 00                      	db	no_subst ; 0		;AN000;number of subst
 40208                                  
 40209                                  ;  "FOR cannot be nested",13,10
 40210                                  FORNESTMES_PTR:
 40211 00009361 1C04                    	dw	1052			;AN000;message number
 40212 00009363 00                      	db	no_subst ; 0		;AN000;number of subst
 40213                                  
 40214                                  ;  "Intermediate file error during pipe",13,10
 40215                                  PIPEEMES_PTR:
 40216 00009364 1D04                    	dw	1053			;AN000;message number
 40217 00009366 00                      	db	no_subst ; 0		;AN000;number of subst
 40218                                  
 40219                                  ;  "Cannot do binary reads from a device",13,10
 40220                                  INBDEV_PTR:
 40221 00009367 1E04                    	dw	1054			;AN000;message number
 40222 00009369 00                      	db	no_subst ; 0		;AN000;number of subst
 40223                                  
 40224                                  ;  "BREAK is %1",13,10
 40225                                  CtrlcMes_Ptr:
 40226 0000936A 1F04                    	dw	1055			;AN000;message number
 40227 0000936C 01                      	db	1			;AN000;number of subst
 40228 0000936D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40229 0000936E 00                      	db	0			;AN000;reserved
 40230 0000936F 0000                    	dw	0			;AN000;offset of on/off (new)
 40231 00009371 0000                    	dw	0			;AN000;segment of arg
 40232 00009373 01                      	db	1			;AN000;first subst
 40233 00009374 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40234 00009375 80                      	db	128			;AN000;maximum width
 40235 00009376 01                      	db	1			;AN000;minimum width
 40236 00009377 20                      	db	blank ; 20h		;AN000;pad character
 40237                                  
 40238                                  ;  "VERIFY is %1",13,10
 40239                                  VeriMes_Ptr:
 40240 00009378 2004                    	dw	1056			;AN000;message number
 40241 0000937A 01                      	db	1			;AN000;number of subst
 40242 0000937B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40243 0000937C 00                      	db	0			;AN000;reserved
 40244 0000937D 0000                    	dw	0			;AN000;offset of on/off (new)
 40245 0000937F 0000                    	dw	0			;AN000;segment of arg
 40246 00009381 01                      	db	1			;AN000;first subst
 40247 00009382 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40248 00009383 80                      	db	128			;AN000;maximum width
 40249 00009384 01                      	db	1			;AN000;minimum width
 40250 00009385 20                      	db	blank ; 20h		;AN000;pad character
 40251                                  
 40252                                  ;  "ECHO is %1",13,10
 40253                                  EchoMes_Ptr:
 40254 00009386 2104                    	dw	1057			;AN000;message number
 40255 00009388 01                      	db	1			;AN000;number of subst
 40256 00009389 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40257 0000938A 00                      	db	0			;AN000;reserved
 40258 0000938B 0000                    	dw	0			;AN000;offset of on/off (new)
 40259 0000938D 0000                    	dw	0			;AN000;segment of arg
 40260 0000938F 01                      	db	1			;AN000;first subst
 40261 00009390 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40262 00009391 80                      	db	128			;AN000;maximum width
 40263 00009392 01                      	db	1			;AN000;minimum width
 40264 00009393 20                      	db	blank ; 20h		;AN000;pad character
 40265                                  
 40266                                  ;  "off"
 40267                                  OFFMES_PTR:
 40268 00009394 2304                    	dw	1059			;AN000;message number
 40269 00009396 00                      	db	no_subst		;AN000;number of subst
 40270                                  
 40271                                  ;  "on"
 40272                                  ONMES_PTR:
 40273 00009397 2404                    	dw	1060			;AN000;message number
 40274 00009399 00                      	db	no_subst ; 0		;AN000;number of subst
 40275                                  
 40276                                  ;  "Error writing to device",13,10
 40277                                  DEVWMES_PTR:
 40278 0000939A 2504                    	dw	1061			;AN000;message number
 40279 0000939C 00                      	db	no_subst ; 0		;AN000;number of subst
 40280                                  
 40281                                  ;  "Invalid path",13,10
 40282                                  INVAL_PATH_PTR:
 40283 0000939D 2604                    	dw	1062			;AN000;message number
 40284 0000939F 00                      	db	no_subst ; 0		;AN000;number of subst
 40285                                  
 40286                                  ;  unformatted string output
 40287                                  arg_buf_ptr:
 40288 000093A0 2704                    	dw	1063			;AN000;message number
 40289 000093A2 01                      	db	1			;AN000;number of subst
 40290 000093A3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40291 000093A4 00                      	db	0			;AN000;reserved
 40292 000093A5 [82A0]                  	dw	Arg_Buf 		;AN000;offset of arg
 40293 000093A7 0000                    	dw	0			;AN000;segment of arg
 40294 000093A9 01                      	db	1			;AN000;first subst
 40295 000093AA 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40296 000093AB 80                      	db	128			;AN000;maximum width
 40297 000093AC 00                      	db	0			;AN000;minimum width
 40298 000093AD 20                      	db	blank ; 20h		;AN000;pad character
 40299                                  
 40300                                  ;  file name output
 40301                                  file_name_ptr:
 40302 000093AE 2804                    	dw	1064			;AN000;message number
 40303 000093B0 01                      	db	1			;AN000;number of subst
 40304 000093B1 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40305 000093B2 00                      	db	0			;AN000;reserved
 40306 000093B3 [87A1]                  	dw	SrcBuf			;AN000;offset of arg
 40307 000093B5 0000                    	dw	0			;AN000;segment of arg
 40308 000093B7 01                      	db	1			;AN000;first subst
 40309 000093B8 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40310 000093B9 80                      	db	128			;AN000;maximum width
 40311 000093BA 00                      	db	0			;AN000;minimum width
 40312 000093BB 20                      	db	blank ; 20h		;AN000;pad character
 40313                                  
 40314                                  ;  file size output for dir
 40315                                  disp_file_size_ptr:
 40316 000093BC 2904                    	dw	1065			;AN000;message number
 40317 000093BE 01                      	db	1			;AN000;number of subst
 40318 000093BF 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40319 000093C0 00                      	db	0			;AN000;reserved
 40320 000093C1 [02A1]                  	dw	File_Size_Low		;AN000;offset of arg
 40321 000093C3 0000                    	dw	0			;AN000;segment of arg
 40322 000093C5 01                      	db	1			;AN000;first subst
 40323                                  	; MSDOS 5.0 COMMAND.COM
 40324                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40325                                  	; 17/06/2023
 40326                                  screen_f_1:
 40327 000093C6 F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40328                                  					;AN000;long binary to decimal
 40329                                  	; MSDOS 5.0 COMMAND.COM
 40330                                  	;db	10			;AN000;maximum width
 40331                                  	;db	10			;AN000;minimum width
 40332                                  screen_f_2:
 40333 000093C7 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM		
 40334 000093C8 0E                      	db	14
 40335                                  	
 40336 000093C9 20                      	db	blank ; 20h		;AN000;pad character
 40337                                  
 40338                                  ;  unformatted string output
 40339                                  ; %s
 40340                                  string_buf_ptr:
 40341 000093CA 2A04                    	dw	1066			;AN000;message number
 40342 000093CC 01                      	db	1			;AN000;number of subst
 40343 000093CD 0B                      	db	parm_block_size 	;AN000;size of sublist
 40344 000093CE 00                      	db	0			;AN000;reserved
 40345 000093CF [06A1]                  	dw	string_ptr_2		;AN000;offset of arg
 40346 000093D1 0000                    	dw	0			;AN000;segment of arg
 40347 000093D3 01                      	db	1			;AN000;first subst
 40348 000093D4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40349 000093D5 80                      	db	128			;AN000;maximum width
 40350 000093D6 00                      	db	0			;AN000;minimum width
 40351 000093D7 20                      	db	blank ; 20h		;AN000;pad character
 40352 000093D8 00                      	db	0			;AN000;
 40353                                  
 40354                                  ;  tab character
 40355                                  tab_ptr:
 40356 000093D9 2B04                    	dw	1067			;AN000;message number
 40357 000093DB 00                      	db	no_subst ; 0		;AN000;number of subst
 40358                                  
 40359                                  ;  " <DIR>   "
 40360                                  dmes_ptr:
 40361 000093DC 2C04                    	dw	1068			;AN000;message number
 40362 000093DE 00                      	db	no_subst ; 0		;AN000;number of subst
 40363                                  
 40364                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40365                                  space_4_ptr :
 40366 000093DF 5104                    	dw	1105 
 40367 000093E1 00                      	db	no_subst ; 0
 40368                                  
 40369                                  ;  destructive back space
 40370                                  dback_ptr:
 40371 000093E2 2D04                    	dw	1069			;AN000;message number
 40372 000093E4 00                      	db	no_subst ; 0		;AN000;number of subst
 40373                                  
 40374                                  ;  carriage return / line feed
 40375                                  acrlf_ptr:
 40376 000093E5 2E04                    	dw	1070			;AN000;message number
 40377 000093E7 00                      	db	no_subst ; 0		;AN000;number of subst
 40378                                  
 40379                                  ;  "mm-dd-yy"
 40380                                  usadat_ptr:
 40381 000093E8 3004                    	dw	1072			;AN000;message number
 40382 000093EA 00                      	db	no_subst ; 0		;AN000;number of subst
 40383                                  
 40384                                  ;  "dd-mm-yy"
 40385                                  eurdat_ptr:
 40386 000093EB 3104                    	dw	1073			;AN000;message number
 40387 000093ED 00                      	db	no_subst ; 0		;AN000;number of subst
 40388                                  
 40389                                  ;  "yy-mm-dd"
 40390                                  japdat_ptr:
 40391 000093EE 3204                    	dw	1074			;AN000;message number
 40392 000093F0 00                      	db	no_subst ; 0		;AN000;number of subst
 40393                                  
 40394                                  ;  date string for prompt
 40395                                  promptdat_ptr:
 40396 000093F1 3304                    	dw	1075			;AN000;message number
 40397 000093F3 02                      	db	2			;AN000;number of subst
 40398 000093F4 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40399 000093F5 00                      	db	0			;AN000;reserved
 40400 000093F6 [82A0]                  	dw	Arg_Buf			;AN000;offset of arg
 40401 000093F8 0000                    	dw	0			;AN000;segment of arg
 40402 000093FA 01                      	db	1			;AN000;first subst
 40403 000093FB 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 40404 000093FC 03                      	db	3			;AN000;maximum width
 40405 000093FD 03                      	db	3			;AN000;minimum width
 40406 000093FE 20                       	db	blank ; 20h		;AN000;pad character
 40407 000093FF 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 40408 00009400 00                      	db	0			;AN000;reserved
 40409                                  promptDat_yr:
 40410 00009401 0000                    	dw	0			;AN000;year
 40411                                  promptDat_moday:
 40412 00009403 0000                    	dw	0			;AN000;month,day
 40413 00009405 02                      	db	2			;AN000;second subst
 40414 00009406 34                       	db	34h ; DATE_MDY_4	;AN000;date
 40415 00009407 0A                      	db	10			;AN000;maximum width
 40416 00009408 08                      	db	8			;AN000;minimum width
 40417 00009409 20                      	db	blank ; 20h		;AN000;pad character
 40418                                  
 40419                                  ;  Time for prompt
 40420                                  promtim_ptr:
 40421 0000940A 3404                    	dw	1076			;AN000;message number
 40422 0000940C 01                      	db	1			;AN000;number of subst
 40423 0000940D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40424 0000940E 00                      	db	0			;AN000;reserved
 40425                                  PromTim_hr_min:
 40426 0000940F 0000                    	dw	0			;AN000;hours,minutes
 40427                                  PromTim_Sec_hn:
 40428 00009411 0000                    	dw	0			;AN000;seconds,hundredths
 40429 00009413 01                      	db	1			;AN000;first subst
 40430 00009414 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 40431                                  					;AC013;time
 40432 00009415 0B                      	db	11			;AN000;maximum width
 40433 00009416 0B                      	db	11			;AC013;minimum width
 40434 00009417 20                      	db	blank ; 20h		;AN000;pad character
 40435                                  
 40436                                  ;  Date and time for DIR
 40437                                  dirdattim_ptr:
 40438 00009418 3504                    	dw	1077			;AN000;message number
 40439 0000941A 02                      	db	2			;AN000;number of subst
 40440 0000941B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40441 0000941C 00                      	db	0			;AN000;reserved
 40442                                  DirDat_Yr:
 40443 0000941D 0000                    	dw	0			;AN000;year
 40444                                  DirDat_Mo_Day:
 40445 0000941F 0000                    	dw	0			;AN000;month,day
 40446 00009421 01                      	db	1			;AN000;first subst
 40447 00009422 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 40448                                  					;AN000;date
 40449 00009423 0A                      	db	10			;AN000;maximum width
 40450 00009424 08                      	db	8			;AN000;minimum width
 40451 00009425 20                      	db	blank ; 20h		;AN000;pad character
 40452 00009426 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40453 00009427 00                      	db	0			;AN000;reserved
 40454                                  DirTim_Hr_Min:
 40455 00009428 0000                    	dw	0			;AN000;hours,minutes
 40456                                  DirTim_Sec_hn:
 40457 0000942A 0000                    	dw	0			;AN000;seconds,hundredths
 40458 0000942C 02                      	db	2			;AN000;second subst
 40459 0000942D 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 40460                                  					;AN000;time
 40461 0000942E 06                      	db	6			;AN000;maximum width
 40462 0000942F 06                      	db	6			;AN000;minimum width
 40463 00009430 20                      	db	blank ; 20h		;AN000;pad character
 40464                                  
 40465                                  ;  "Directory already exists"
 40466                                  MD_EXISTS_PTR:
 40467 00009431 3604                    	dw	1078			;AN000;message number
 40468 00009433 00                      	db	no_subst		;AN000;number of subst
 40469                                  
 40470                                  ;  "%1 bytes",13,10
 40471                                  bytes_ptr:
 40472 00009434 3704                    	dw	1079			; message number
 40473 00009436 01                      	db	1			; number of subst
 40474 00009437 0B                      	db	parm_block_size ; 11	; size of sublist
 40475 00009438 00                      	db	0			; reserved
 40476 00009439 [149E]                  	dw	FileSiz			; offset of arg
 40477 0000943B 0000                    	dw	0			; segment of arg
 40478 0000943D 01                      	db	1			; first subst
 40479                                  	; MSDOS 5.0 COMMAND.COM
 40480                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40481                                  	; 17/06/2023
 40482                                  screen_f_4:
 40483 0000943E F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40484                                  					; long binary to decimal
 40485                                  	; MSDOS 5.0 COMMAND.COM
 40486                                  	;db	10			; maximum width
 40487                                  	;db	10			; minimum width
 40488                                  screen_f_5:
 40489 0000943F 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM
 40490 00009440 0E                      	db	14	
 40491                                  
 40492 00009441 20                      	db	blank ; 20h		; pad character
 40493                                  
 40494                                  ;  "Total:",13,10
 40495                                  total_ptr:
 40496 00009442 3804                    	dw	1080			; message number
 40497 00009444 00                      	db	no_subst ; 0		; number of subst
 40498                                  
 40499                                  ;  "Error parsing environment variable:",13,10
 40500                                  errparsenv_ptr:
 40501 00009445 3904                    	dw	1081			; message number
 40502 00009447 00                      	db	no_subst ; 0		; number of subst
 40503                                  
 40504                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40505                                  	; (MSDOS 6.22 COMMAN.COM - TRANGROUP:996Ah)
 40506                                  cox_Y_quest_ptr:
 40507 00009448 3A04                    	dw	1082
 40508 0000944A 00                      	db	no_subst ; 0
 40509                                  cox_Y_answ_ptr:
 40510 0000944B 3B04                    	dw	1083
 40511 0000944D 00                      	db	no_subst ; 0
 40512                                  
 40513                                  ;  "(continuing %1)",13,10
 40514                                  dircont_ptr:
 40515 0000944E 3C04                    	dw	1084			;AN000;message number
 40516 00009450 01                      	db	1			;AN000;number of subst
 40517 00009451 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40518 00009452 00                      	db	0			;AN000;reserved
 40519 00009453 [1FA0]                  	dw	BWDBUF			;AN000;offset of arg
 40520 00009455 0000                    	dw	0			;AN000;segment of arg
 40521 00009457 01                      	db	1			;AN000;first subst
 40522 00009458 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40523 00009459 80                      	db	128			;AN000;maximum width
 40524 0000945A 00                      	db	0			;AN000;minimum width
 40525 0000945B 20                      	db	blank ; 20h		;AN000;pad character
 40526                                  
 40527                                  ;  "Revision %1",CR,LF
 40528                                  dosrev_ptr:
 40529 0000945C 4204                    	dw	1090
 40530 0000945E 01                      	db	1			; one substitution
 40531 0000945F 0B                      	db	parm_block_size ; 11
 40532 00009460 00                      	db	0
 40533 00009461 [17A1]                  	dw	One_Char_Val		; ptr to char
 40534 00009463 0000                    	dw	0			; segment addr?
 40535 00009465 01                      	db	1			; 1st substitution
 40536 00009466 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 40537 00009467 01                      	db	1			; max width
 40538 00009468 01                      	db	1			; min width
 40539 00009469 20                      	db	blank ; 20h		; pad char
 40540                                  
 40541                                  ;  "DOS is in ROM"
 40542                                  DosRom_Ptr:
 40543 0000946A 4304                    	dw	1091
 40544 0000946C 00                      	db	no_subst ; 0		
 40545                                  
 40546                                  ;  "DOS is in HMA"
 40547                                  DosHma_Ptr:
 40548 0000946D 4404                    	dw	1092
 40549 0000946F 00                      	db	no_subst ; 0		
 40550                                  
 40551                                  ;  "DOS is in low memory"
 40552                                  DosLow_Ptr:
 40553 00009470 4504                    	dw	1093
 40554 00009472 00                      	db	no_subst ; 0		
 40555                                  
 40556                                  ;  "Cannot Loadhigh batch file" ;M016
 40557                                  NoExecBat_Ptr:
 40558 00009473 4604                    	dw	1094			; M016
 40559 00009475 00                      	db	no_subst ; 0		; M016
 40560                                  
 40561                                  ;  "LoadHigh: Invalid filename" ; M016
 40562                                  LhInvFil_Ptr:
 40563 00009476 4704                    	dw	1095			; M016
 40564 00009478 00                      	db	no_subst ; 0		; M016
 40565                                  
 40566                                  ;  "Could not open specified country information file" ; M045
 40567                                  NoCntry_Ptr:
 40568 00009479 4804                    	dw	1096			; M045
 40569 0000947B 00                      	db	no_subst ; 0		; M045
 40570                                  
 40571                                  ; 15/04/2023
 40572                                  ; MSDOS 6.0 COMMAND.COM only !
 40573                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40574                                  ;%if 0
 40575                                  
 40576                                  ;* The next four errors emulate those reported by the normal parse
 40577                                  ;  mechanism, with a little more accurate wording; that parser has been
 40578                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 40579                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 40580                                  ;  parser, so they've been added here.
 40581                                  
 40582                                  ;  "LoadHigh: Invalid argument"
 40583                                  LhInvArg_Ptr:
 40584 0000947C 4904                    	dw	1097
 40585 0000947E 00                      	db	no_subst ; 0		
 40586                                  
 40587                                  ;  "Required parameter missing"
 40588                                  ReqParmMiss:
 40589 0000947F 4A04                    	dw	1098
 40590 00009481 00                      	db	no_subst ; 0		
 40591                                  
 40592                                  ;  "Unrecognized switch"
 40593                                  LhInvSwt_Ptr:
 40594 00009482 4B04                    	dw	1099
 40595 00009484 00                      	db	no_subst ; 0		
 40596                                  
 40597                                  ;  "A bad UMB number has been specified"
 40598                                  LhBadUMB_Ptr:
 40599 00009485 4C04                    	dw	1100
 40600 00009487 00                      	db	no_subst ; 0
 40601                                  ;%endif	
 40602                                  
 40603                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40604                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99AAh
 40605                                  
 40606                                  DirCompRatio_Ptr:
 40607 00009488 4D04                    	dw	1101			;message number
 40608 0000948A 02                      	db	2			;number of subst
 40609 0000948B 0B                      	db	parm_block_size ; 11	;size of sublist
 40610 0000948C 00                      	db	0			;reserved
 40611 0000948D [0DA1]                  	dw	Dir_CRatio_1		;offset of arg
 40612 0000948F 0000                    	dw	0			;segment of arg
 40613 00009491 01                      	db	1			;first subst
 40614 00009492 91                      	db	91h			;format
 40615 00009493 02                      	db	2			;maximum width
 40616 00009494 02                      	db	2			;minimum width
 40617 00009495 20                      	db	blank ; 20h		;pad character
 40618 00009496 0B                      	db	parm_block_size  ; 11	;size of sublist
 40619 00009497 00                      	db	0			; reserved
 40620 00009498 [0EA1]                  	dw	Dir_CRatio_2		;offset of arg
 40621 0000949A 0000                    	dw	0			;segment of arg
 40622 0000949C 02                      	db	2			;second subst
 40623 0000949D 11                      	db	11h			;format
 40624 0000949E 01                      	db	1			;maximum width
 40625 0000949F 01                      	db	1			;minimum width
 40626 000094A0 20                      	db	blank ; 20h		;pad character
 40627                                  
 40628                                  AveCompRatio_Ptr:
 40629 000094A1 4E04                    	dw	1102			;message number
 40630 000094A3 02                      	db	2			;number of subst
 40631 000094A4 0B                      	db	parm_block_size ; 11	;size of sublist
 40632 000094A5 00                      	db	0			;reserved
 40633 000094A6 [0DA1]                  	dw	Dir_CRatio_1		;offset of arg
 40634 000094A8 0000                    	dw	0			;segment of arg
 40635 000094AA 01                      	db	1			;first subst
 40636 000094AB 91                      	db	91h			;format
 40637 000094AC 02                      	db	2			;maximum width
 40638 000094AD 02                      	db	2			;minimum width
 40639 000094AE 20                      	db	blank ; 20h		;pad character
 40640 000094AF 0B                      	db	parm_block_size  ; 11	;size of sublist
 40641 000094B0 00                      	db	0			; reserved
 40642 000094B1 [0EA1]                  	dw	Dir_CRatio_2		;offset of arg
 40643 000094B3 0000                    	dw	0			;segment of arg
 40644 000094B5 02                      	db	2			;second subst
 40645 000094B6 11                      	db	11h			;format
 40646 000094B7 01                      	db	1			;maximum width
 40647 000094B8 01                      	db	1			;minimum width
 40648 000094B9 20                      	db	blank ; 20h		;pad character
 40649                                  
 40650                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40651                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 40652                                  
 40653                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40654                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99DCh
 40655                                  
 40656                                  ; ---------------------------------------------------------------------------
 40657                                  
 40658                                  PATH_TEXT:
 40659 000094BA 504154483D              	db	"PATH="
 40660                                  PROMPT_TEXT:
 40661 000094BF 50524F4D50543D          	db	"PROMPT="
 40662                                  COMSPECSTR:
 40663 000094C6 434F4D535045433D        	db	"COMSPEC="
 40664                                  DirEnvVar:
 40665 000094CE 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 40666                                  
 40667                                  ;============================================================================
 40668                                  ; TDATA.ASM, MSDOS 6.0, 1991
 40669                                  ;============================================================================
 40670                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40671                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40672                                  
 40673                                  	; 15/04/2023
 40674 000094D5 00                      	db	0
 40675                                  align 2
 40676                                  
 40677                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 40678                                  ; ---------------------------------------------------------------------------
 40679                                  	; 18/06/2023
 40680                                  	;db	0
 40681                                  
 40682                                  ; Lists of help message numbers for internal commands and /?
 40683                                  
 40684                                  	; 18/06/2023
 40685                                  ;;NoHelpMsgs:
 40686                                  	;dw	1200,0		;M014
 40687                                  
 40688                                  	; 18/06/2023
 40689                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99F7h
 40690                                  
 40691                                  BreakHelpMsgs:
 40692 000094D6 14050000                	dw	1300,0
 40693                                  ChcpHelpMsgs:
 40694 000094DA 280529050000            	dw	1320,1321,0
 40695                                  CdHelpMsgs:
 40696 000094E0 3C053D053E050000        	dw	1340,1341,1342,0
 40697                                  ClsHelpMsgs:
 40698 000094E8 50050000                	dw	1360,0
 40699                                  CopyHelpMsgs:
 40700                                  	;dw	1400,1401,1402,1403,1404,0
 40701                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40702 000094EC 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,1405,1406,1407,0
 40702 000094F5 057D057E057F050000 
 40703                                  CttyHelpMsgs:
 40704 000094FE 8C050000                	dw	1420,0
 40705                                  DateHelpMsgs:
 40706 00009502 A005A1050000            	dw	1440,1441,0
 40707                                  DelHelpMsgs:
 40708 00009508 B405B505B6050000        	dw	1460,1461,1462,0
 40709                                  DirHelpMsgs:
 40710 00009510 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 40710 00009519 05CD05CE05CF05D005 
 40711                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 40712                                  	; MSDOS 6.0 COMMAND.COM
 40713 00009522 D105D205D305D405        	dw	1489,1490,1491,1492
 40714 0000952A 0000                    	dw	0
 40715                                  ExitHelpMsgs:
 40716 0000952C DC050000                	dw	1500,0
 40717                                  MdHelpMsgs:
 40718 00009530 F0050000                	dw	1520,0
 40719                                  PathHelpMsgs:
 40720 00009534 0406050606060000        	dw	1540,1541,1542,0
 40721                                  PromptHelpMsgs:
 40722 0000953C 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 40722 00009545 061D061E061F062006-
 40722 0000954E 0000               
 40723                                  RdHelpMsgs:
 40724 00009550 2C060000                	dw	1580,0
 40725                                  RenHelpMsgs:
 40726 00009554 4006410642060000        	dw	1600,1601,1602,0
 40727                                  SetHelpMsgs:
 40728 0000955C 5406550656060000        	dw	1620,1621,1622,0
 40729                                  TimeHelpMsgs:
 40730 00009564 680669060000            	dw	1640,1641,0
 40731                                  TypeHelpMsgs:
 40732 0000956A 7C060000                	dw	1660,0
 40733                                  VerHelpMsgs:
 40734 0000956E 90060000                	dw	1680,0
 40735                                  VerifyHelpMsgs:
 40736 00009572 A4060000                	dw	1700,0
 40737                                  VolHelpMsgs:
 40738 00009576 B8060000                	dw	1720,0
 40739                                  CallHelpMsgs:
 40740 0000957A CC06CD060000            	dw	1740,1741,0	;M014
 40741                                  RemHelpMsgs:
 40742 00009580 E0060000                	dw	1760,0		;M014
 40743                                  PauseHelpMsgs:
 40744 00009584 F4060000                	dw	1780,0		;M014
 40745                                  EchoHelpMsgs:
 40746 00009588 080709070000            	dw	1800,1801,0	;M014
 40747                                  GotoHelpMsgs:
 40748 0000958E 1C071D070000            	dw	1820,1821,0	;M014
 40749                                  ShiftHelpMsgs:
 40750 00009594 30070000                	dw	1840,0		;M014
 40751                                  IfHelpMsgs:
 40752 00009598 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 40752 000095A1 0749074A070000     
 40753                                  ForHelpMsgs:
 40754 000095A8 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 40754 000095B1 00                 
 40755                                  TruenameHelpMsgs:
 40756 000095B2 6C070000                	 dw	1900,0		;M014
 40757                                  LoadhighHelpMsgs:
 40758 000095B6 800781078207            	dw	1920,1921,1922
 40759                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 40760                                  	; MSDOS 6.0 COMMAND.COM
 40761 000095BC 830784078507860787-     	dw	1923,1924,1925,1926,1927 ;M014
 40761 000095C5 07                 
 40762 000095C6 0000                    	dw	0
 40763                                  
 40764                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 40765                                  CLSSTRING:
 40766 000095C8 041B5B324A              	db	4,1Bh,"[2J"		; ANSI Clear screen
 40767                                  
 40768                                  PROMPT_TABLE:
 40769 000095CD 42                      	db	"B"
 40770 000095CE [4623]                  	dw	Print_B
 40771 000095D0 44                      	db	"D"
 40772 000095D1 [2A3C]                  	dw	PRINT_DATE
 40773 000095D3 45                      	db	"E"
 40774 000095D4 [3A23]                  	dw	PRINT_ESC
 40775 000095D6 47                      	db	"G"
 40776 000095D7 [3E23]                  	dw	PRINT_G
 40777 000095D9 48                      	db	"H"
 40778 000095DA [3023]                  	dw	PRINT_BACK
 40779 000095DC 4C                      	db	"L"
 40780 000095DD [4223]                  	dw	PRINT_L
 40781 000095DF 4E                      	db	"N"
 40782 000095E0 [5723]                  	dw	PRINT_DRIVE
 40783 000095E2 50                      	db	"P"
 40784 000095E3 [5F23]                  	dw	build_dir_for_prompt
 40785 000095E5 51                      	db	"Q"
 40786 000095E6 [3623]                  	dw	PRINT_EQ
 40787 000095E8 54                      	db	"T"
 40788 000095E9 [CD34]                  	dw	PRINT_TIME
 40789 000095EB 56                      	db	"V"
 40790 000095EC [C622]                  	dw	PRINT_VERSION
 40791 000095EE 5F                      	db	"_"
 40792 000095EF [1C2B]                  	dw	CRLF2
 40793 000095F1 24                      	db	"$"
 40794 000095F2 [4823]                  	dw	PRINT_CHAR
 40795 000095F4 00                      	db	0			; NUL TERMINATED
 40796                                  
 40797                                  ; Table of IF conditionals
 40798                                  IFTAB:
 40799 000095F5 034E4F54                	db	3,"NOT"			; First byte is count
 40800 000095F9 [B80B]                  	dw	IFNOT
 40801 000095FB 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 40801 00009604 454C               
 40802 00009606 [770C]                  	dw	IFERLEV
 40803 00009608 054558495354            	db	5,"EXIST"
 40804 0000960E [0C0C]                  	dw	IFEXISTS
 40805 00009610 00                      	db	0
 40806                                  
 40807                                  ; Table for internal command names
 40808                                  COMTAB:
 40809 00009611 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 40810 00009616 [3F11]                  	dw	CATALOG			; In TCMD1.ASM
 40811 00009618 [1095]                  	dw	DirHelpMsgs
 40812                                  
 40813 0000961A 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 40814 00009620 [EC0C]                  	dw	_$CALL			; In TBATCH2.ASM
 40815 00009622 [7A95]                  	dw	CallHelpMsgs
 40816                                  
 40817 00009624 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 40818 0000962A [A225]                  	dw	CHCP			; In TCMD2B.ASM
 40819 0000962C [DA94]                  	dw	ChcpHelpMsgs
 40820                                  
 40821 0000962E 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 40822 00009636 [9F1F]                  	dw	CRENAME			; In TCMD1.ASM
 40823 00009638 [5495]                  	dw	RenHelpMsgs
 40824                                  
 40825 0000963A 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 40826 0000963F [9F1F]                  	dw	CRENAME			; In TCMD1.ASM
 40827 00009641 [5495]                  	dw	RenHelpMsgs
 40828                                  	
 40829 00009643 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 40830 0000964A [1D1F]                  	dw	ERASE			; In TCMD1.ASM
 40831 0000964C [0895]                  	dw	DelHelpMsgs
 40832                                  	
 40833 0000964E 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 40834 00009653 [1D1F]                  	dw	ERASE			; In TCMD1.ASM
 40835 00009655 [0895]                  	dw	DelHelpMsgs
 40836                                  	
 40837 00009657 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 40838 0000965D [4620]                  	dw	TYPEFIL			; In TCMD1.ASM
 40839 0000965F [6A95]                  	dw	TypeHelpMsgs
 40840                                  	
 40841 00009661 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 40842 00009666 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 40843 00009668 [8095]                  	dw	RemHelpMsgs
 40844                                  	
 40845 0000966A 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 40846 00009670 [773C]                  	dw	COPY			; In COPY.ASM
 40847 00009672 [EC94]                  	dw	CopyHelpMsgs
 40848                                  	
 40849 00009674 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 40850 0000967B [111F]                  	dw	PAUSE			; In TCMD1.ASM
 40851 0000967D [8495]                  	dw	PauseHelpMsgs
 40852                                  	
 40853 0000967F 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 40854 00009685 [E033]                  	dw	DATE			; In TPIPE.ASM
 40855 00009687 [0295]                  	dw	DateHelpMsgs
 40856                                  	
 40857 00009689 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 40858 0000968F [3F34]                  	dw	CTIME			; In TPIPE.ASM
 40859 00009691 [6495]                  	dw	TimeHelpMsgs
 40860                                  	
 40861 00009693 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 40862 00009698 [6522]                  	dw	VERSION			; In TCMD2.ASM
 40863 0000969A [6E95]                  	dw	VerHelpMsgs
 40864                                  	
 40865 0000969C 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 40866 000096A1 [6D21]                  	dw	VOLUME			; In TCMD1.ASM
 40867 000096A3 [7695]                  	dw	VolHelpMsgs
 40868                                  	
 40869 000096A5 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 40870 000096A9 [E529]                  	dw	_$CHDIR			; In TENV.ASM
 40871 000096AB [E094]                  	dw	CdHelpMsgs
 40872                                  	
 40873 000096AD 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 40874 000096B4 [E529]                  	dw	_$CHDIR			; In TENV.ASM
 40875 000096B6 [E094]                  	dw	CdHelpMsgs
 40876                                  	
 40877 000096B8 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 40878 000096BC [4A2A]                  	dw	_$MKDIR			; In TENV.ASM
 40879 000096BE [3095]                  	dw	MdHelpMsgs
 40880                                  	
 40881 000096C0 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 40882 000096C7 [4A2A]                  	dw	_$MKDIR			; In TENV.ASM
 40883 000096C9 [3095]                  	dw	MdHelpMsgs
 40884                                  	
 40885 000096CB 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 40886 000096CF [8C2A]                  	dw	_$RMDIR			; In TENV.ASM
 40887 000096D1 [5095]                  	dw	RdHelpMsgs
 40888                                  	
 40889 000096D3 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 40890 000096DA [8C2A]                  	dw	_$RMDIR			; In TENV.ASM
 40891 000096DC [5095]                  	dw	RdHelpMsgs
 40892                                  	
 40893 000096DE 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 40894 000096E5 [743B]                  	dw	CNTRLC			; In TUCODE.ASM
 40895 000096E7 [D694]                  	dw	BreakHelpMsgs
 40896                                  	
 40897 000096E9 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 40898 000096F1 [B63B]                  	dw	VERIFY			; In TUCODE.ASM
 40899 000096F3 [7295]                  	dw	VerifyHelpMsgs
 40900                                  	
 40901 000096F5 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 40902 000096FA [4F27]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 40903 000096FC [5C95]                  	dw	SetHelpMsgs
 40904                                  	
 40905 000096FE 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 40906 00009706 [3527]                  	dw	ADD_PROMPT		; In TENV.ASM
 40907 00009708 [3C95]                  	dw	PromptHelpMsgs
 40908                                  	
 40909 0000970A 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 40910 00009710 [C623]                  	dw	PATH			; In TCMD2.ASM
 40911 00009712 [3495]                  	dw	PathHelpMsgs
 40912                                  	
 40913 00009714 044558495400            	db	4,"EXIT",0
 40914 0000971A [9726]                  	dw	_$EXIT			; In TCMD2.ASM
 40915 0000971C [2C95]                  	dw	ExitHelpMsgs
 40916                                  	
 40917 0000971E 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 40918 00009724 [0425]                  	dw	CTTY			; In TCMD2.ASM
 40919 00009726 [FE94]                  	dw	CttyHelpMsgs
 40920                                  	
 40921 00009728 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 40922 0000972E [3B3B]                  	dw	_ECHO			; In TUCODE.ASM
 40923 00009730 [8895]                  	dw	EchoHelpMsgs
 40924                                  	
 40925 00009732 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 40926 00009738 [200D]                  	dw	_GOTO			; In TBATCH.ASM
 40927 0000973A [8E95]                  	dw	GotoHelpMsgs
 40928                                  	
 40929 0000973C 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 40930 00009743 [A50C]                  	dw	_SHIFT			; In TBATCH.ASM
 40931 00009745 [9495]                  	dw	ShiftHelpMsgs
 40932                                  	
 40933 00009747 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 40934 0000974B [510B]                  	dw	_$IF			; In TBATCH.ASM
 40935 0000974D [9895]                  	dw	IfHelpMsgs
 40936                                  	
 40937 0000974F 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 40938 00009754 [D80F]                  	dw	_$FOR			; In TBATCH.ASM
 40939 00009756 [A895]                  	dw	ForHelpMsgs
 40940                                  	
 40941 00009758 03434C5300              	db	3,"CLS",0
 40942 0000975D [6B24]                  	dw	CLS			; In TCMD2.ASM
 40943 0000975F [E894]                  	dw	ClsHelpMsgs
 40944                                  	
 40945 00009761 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 40945 0000976A 03                 
 40946 0000976B [2026]                  	dw	TRUENAME		;AN000;
 40947 0000976D [B295]                  	dw	TruenameHelpMsgs
 40948                                  	
 40949 0000976F 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 40949 00009778 02                 
 40950 00009779 [3463]                  	dw	LoadHigh		; In loadhi.asm ; M003
 40951 0000977B [B695]                  	dw	LoadhighHelpMsgs	; M003
 40952                                  	
 40953 0000977D 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 40954 00009781 [3463]                  	dw	LoadHigh		; In loadhi.asm ; M003
 40955 00009783 [B695]                  	dw	LoadhighHelpMsgs	; M003
 40956                                  	
 40957 00009785 00                      	db	0			; Terminate command table
 40958                                  
 40959                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 40960                                  
 40961 00009786 2E434F4D                comext:	db	".COM"
 40962 0000978A 2E455845                exeext:	db	".EXE"
 40963 0000978E 2E424154                batext:	db	".BAT"
 40964                                  
 40965                                  switch_list:
 40966                                  	; MSDOS 5.0 (& 6.0) COMMAND.COM
 40967                                  	;db	"?VBAPW"		; flags we can recognize
 40968                                  	; 18/06/2023
 40969                                  	; MSDOS 6.22 COMMAND.COM
 40970 00009792 2D593F5642415057        	db "-Y?VBAPW"
 40971                                  
 40972                                  AttrLtrs:
 40973 0000979A 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 40974                                  
 40975                                  ;	Attribute letters in AttrLtrs must appear in the order that
 40976                                  ;	attribute bits occur in the attribute byte returned by
 40977                                  ;	directory searches, starting with bit 0.
 40978                                  ;	The volume label attribute is lowercased to keep it from
 40979                                  ;	being matched (by an uppercase comparison).
 40980                                  
 40981                                  OrderLtrs:
 40982                                  	; MSDOS 5.0
 40983                                  	;db	"NEDSG"			; sort order letters for DIR
 40984                                  	; 18/06/2023
 40985                                  	; MSDOS 6.0 COMMAND.COM
 40986 000097A0 4E4544534743            	db	"NEDSGC"		; sort order letters for DIR
 40987                                  
 40988                                  ;	Sort order letters stand for file name, extension,
 40989                                  ;	date/time, size, grouped (directory files before others),
 40990                                  ;	and compression ratio. DIR routines rely on the specific
 40991                                  ;	order of the letters in this list.
 40992                                  
 40993                                  comspec_flag:
 40994 000097A6 00                      	db	0                       ;AN071;
 40995                                  
 40996                                  BATBUFLEN:
 40997 000097A7 2000                    	dw	BatLen ; 32
 40998                                  
 40999                                  ; *****************************************************
 41000                                  ; EMG 4.00
 41001                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 41002                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 41003                                  ; *****************************************************
 41004                                  
 41005                                  ; COMMON PARSE BLOCKS
 41006                                  
 41007                                  ; Indicates no value list for PARSE.
 41008                                  
 41009                                  NO_VALUES:
 41010 000097A9 0000                    	dw	0			;AN000;  no values
 41011                                  
 41012                                  NULL_VALUE_LIST:  ; for unvalidated value
 41013 000097AB 00                       	db	0                       ; no value lists
 41014                                  
 41015                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41016                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 41017                                  
 41018                                  ; PARSE control block for a required file specification (upper cased)
 41019                                  
 41020                                  FILE_REQUIRED:
 41021 000097AC 0002                    	dw	0200h			;AN000;  filespec - required
 41022 000097AE 0100                    	dw	1			;AN000;  capitalize - file table
 41023 000097B0 [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41024 000097B2 [A997]                  	dw	NO_VALUES		;AN000;
 41025 000097B4 00                      	db	0			;AN000;  no keywords
 41026                                  
 41027                                  ; PARSE control block for an optional file specification (upper cased)
 41028                                  ; or drive number
 41029                                  
 41030                                  FILE_OPTIONAL:
 41031 000097B5 0103                    	dw	0301h			;AN000;  filespec or drive number
 41032                                  					;	 optional
 41033 000097B7 0100                    	dw	1			;AN000;  capitalize - file table
 41034 000097B9 [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41035 000097BB [A997]                  	dw	NO_VALUES		;AN000;
 41036 000097BD 00                      	db	0			;AN000;  no keywords
 41037                                  
 41038                                  ; PARSE control block for an optional file specification (upper cased)
 41039                                  
 41040                                  FILE_OPTIONAL2:
 41041 000097BE 0102                    	dw	0201h                   ;AN000;  filespec optional
 41042 000097C0 0100                    	dw	1                       ;AN000;  capitalize - file table
 41043 000097C2 [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41044 000097C4 [A997]                  	dw	NO_VALUES		;AN000;
 41045 000097C6 00                      	db	0			;AN000;  no keywords
 41046                                  
 41047                                  ; PARSE control block for an optional /P switch
 41048                                  
 41049                                  SLASH_P_SWITCH:
 41050 000097C7 0000                    	dw	0			;AN000;  no match flags
 41051 000097C9 0200                    	dw	2			;AN000;  capitalize - char table
 41052 000097CB [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41053 000097CD [A997]                  	dw	NO_VALUES		;AN000;
 41054 000097CF 01                      	db	1			;AN000;  1 keyword
 41055                                  SLASH_P_SYN:
 41056 000097D0 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 41057                                  
 41058                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 41059                                  
 41060                                  ; The following parse control block can be used for any command which
 41061                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 41062                                  ; the equal sign as an additional delimiter. Returns verified result
 41063                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 41064                                  ; internal commands.
 41065                                  
 41066                                  PARSE_BREAK:
 41067 000097D3 [D697]                  	dw	BREAK_PARMS		;AN000;
 41068 000097D5 00                      	db	0			;AN032; no extra delimiter
 41069                                  
 41070                                  BREAK_PARMS:
 41071 000097D6 0001                    	db	0,1			;AN000;  1 positional parm
 41072 000097D8 [DC97]                  	dw	BREAK_CONTROL1		;AN000;
 41073 000097DA 00                      	db	0			;AN000;  no switches
 41074 000097DB 00                      	db	0			;AN000;  no keywords
 41075                                  
 41076                                  BREAK_CONTROL1:
 41077 000097DC 0120                    	dw	2001h			;AN000;  string value - optional
 41078 000097DE 0200                    	dw	2			;AN000;  capitalize - char table
 41079 000097E0 [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41080 000097E2 [E597]                  	dw	BREAK_VALUES		;AN000;
 41081 000097E4 00                      	db	0			;AN000;  no keywords
 41082                                  
 41083                                  BREAK_VALUES:
 41084 000097E5 03                      	db	3			;AN000;
 41085 000097E6 00                      	db	0			;AN000;  no ranges
 41086 000097E7 00                      	db	0			;AN000;  no numeric values
 41087 000097E8 02                      	db	2			;AN000;  2 string values
 41088 000097E9 00                      	db	0			;AN000;  returned if ON
 41089 000097EA [EF97]                  	dw	BREAK_ON		;AN000;  point to ON string
 41090 000097EC 66                      	db	'f'                     ;AN000;  returned if OFF
 41091 000097ED [F297]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 41092                                  
 41093                                  BREAK_ON:
 41094 000097EF 4F4E00                  	db	"ON",0                  ;AN000;
 41095                                  BREAK_OFF:
 41096 000097F2 4F464600                	db	"OFF",0                 ;AN000;
 41097                                  
 41098                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41099                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 41100                                  
 41101                                  ; PARSE BLOCK FOR CHCP
 41102                                  
 41103                                  ; The following parse control block can be used for any command which
 41104                                  ; needs only one optional three digit decimal parameter for operands.
 41105                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 41106                                  ; CHCP internal command.
 41107                                  
 41108                                  CHCP_MINVAL	EQU	100			;AN000;
 41109                                  CHCP_MAXVAL	EQU	999			;AN000;
 41110                                  
 41111                                  PARSE_CHCP:
 41112 000097F6 [F997]                  	dw	CHCP_PARMS			;AN000;
 41113 000097F8 00                      	db	0				;AN000;  no extra delimiter
 41114                                  CHCP_PARMS:
 41115 000097F9 0001                    	db	0,1				;AN000;  1 positional parm
 41116 000097FB [FF97]                  	dw	CHCP_CONTROL1			;AN000;
 41117 000097FD 00                      	db	0				;AN000;  no switches
 41118 000097FE 00                      	db	0				;AN000;  no keywords
 41119                                  
 41120                                  CHCP_CONTROL1:
 41121 000097FF 0180                    	dw	8001h				;AN000;  numeric value - optional
 41122 00009801 0000                    	dw	0				;AN000;  no function flags
 41123 00009803 [57AA]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 41124 00009805 [0898]                  	dw	CHCP_VALUES			;AN000;
 41125 00009807 00                      	db	0				;AN000;  no keywords
 41126                                  
 41127                                  CHCP_VALUES:
 41128 00009808 01                      	db	1				;AN000;
 41129 00009809 01                      	db	1				;AN000;  1 range
 41130 0000980A 01                      	db	1				;AN000;  returned if result
 41131 0000980B 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 41132 00009813 00                      	db	0				;AN000;  no numeric values
 41133 00009814 00                      	db	0				;AN000;  no string values
 41134                                  
 41135                                  ; PARSE BLOCK FOR DATE
 41136                                  
 41137                                  ; The following parse control block can be used for any command which
 41138                                  ; needs only an optional date string as an operand. Returns unverified
 41139                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 41140                                  
 41141                                  PARSE_DATE:
 41142 00009815 [1898]                  	dw	DATE_PARMS			;AN000;
 41143 00009817 00                      	db	0				;AN000;  no extra delimiter
 41144                                  DATE_PARMS:
 41145 00009818 0001                    	db	0,1				;AN000;  1 positional parm
 41146 0000981A [1E98]                  	dw	DATE_CONTROL1			;AN000;
 41147 0000981C 00                      	db	0				;AN000;  no switches
 41148 0000981D 00                      	db	0				;AN000;  no keywords
 41149                                  
 41150                                  DATE_CONTROL1:
 41151 0000981E 0110                    	dw	1001h				;AN000;  date - optional
 41152 00009820 0000                    	dw	0				;AN000;  no function flags
 41153 00009822 [5FAA]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 41154 00009824 [A997]                  	dw	NO_VALUES			;AN000;
 41155 00009826 00                      	db	0				;AN000;  no keywords
 41156                                  
 41157                                  ; PARSE BLOCK FOR TIME
 41158                                  
 41159                                  ; The following parse control block can be used for any command which
 41160                                  ; needs only an optional time string as an operand. Returns unverified
 41161                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 41162                                  
 41163                                  PARSE_TIME:
 41164 00009827 [2A98]                  	dw	TIME_PARMS			;AN000;
 41165 00009829 00                      	db	0				;AN000;  no extra delimiter
 41166                                  TIME_PARMS:
 41167 0000982A 0001                    	db	0,1				;AN000;  1 positional parm
 41168 0000982C [3098]                  	dw	TIME_CONTROL1			;AN000;
 41169 0000982E 00                      	db	0				;AN000;  no switches
 41170 0000982F 00                      	db	0				;AN000;  no keywords
 41171                                  
 41172                                  TIME_CONTROL1:
 41173 00009830 0108                    	dw	0801h				;AN000;  TIME - optional
 41174 00009832 0000                    	dw	0				;AN000;  no function flags
 41175 00009834 [67AA]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 41176 00009836 [A997]                  	dw	NO_VALUES			;AN000;
 41177 00009838 00                      	db	0				;AN000;  no keywords
 41178                                  
 41179                                  ; PARSE BLOCK FOR VOL
 41180                                  
 41181                                  ; The following parse control block can be used for any command which
 41182                                  ; needs only an optional drive letter as an operand.  Returns unverified
 41183                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 41184                                  ; internal command.
 41185                                  
 41186                                  PARSE_VOL:
 41187 00009839 [3C98]                  	dw	VOL_PARMS			;AN000;
 41188 0000983B 00                      	db	0				;AN000;  no extra delimiter
 41189                                  VOL_PARMS:
 41190 0000983C 0001                    	db	0,1				;AN000;  1 positional parm
 41191 0000983E [4298]                  	dw	DRIVE_CONTROL1			;AN000;
 41192 00009840 00                      	db	0				;AN000;  no switches
 41193 00009841 00                      	db	0				;AN000;  no keywords
 41194                                  
 41195                                  DRIVE_CONTROL1:
 41196 00009842 0101                    	dw	0101h				;AN000;  DRIVE - optional
 41197 00009844 0100                    	dw	1				;AN000;  capitalize - file table
 41198 00009846 [6FAA]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 41199 00009848 [A997]                  	dw	NO_VALUES			;AN000;
 41200 0000984A 00                      	db	0				;AN000;  no keywords
 41201                                  
 41202                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 41203                                  
 41204                                  ; The following parse control block can be used for any command which
 41205                                  ; needs only one required file specification as an operand. Returns a
 41206                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41207                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 41208                                  
 41209                                  PARSE_MRDIR:
 41210 0000984B [4E98]                  	dw	MRDIR_PARMS			;AN000;
 41211 0000984D 00                      	db	0				;AN000;  no extra delimiter
 41212                                  MRDIR_PARMS:
 41213 0000984E 0101                    	db	1,1				;AN000;  1 positional parm
 41214 00009850 [AC97]                  	dw	FILE_REQUIRED			;AN000;
 41215 00009852 00                      	db	0				;AN000;  no switches
 41216 00009853 00                      	db	0				;AN000;  no keywords
 41217                                  
 41218                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 41219                                  
 41220                                  ; The following parse control block can be used for any command which
 41221                                  ; needs only one optional file specification an operand. Returns a
 41222                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41223                                  ; for the CHDIR and TRUENAME internal commands.
 41224                                  
 41225                                  PARSE_CHDIR:
 41226 00009854 [5798]                  	dw	CHDIR_PARMS			;AN000;
 41227 00009856 00                      	db	0				;AN000;  no extra delimiter
 41228                                  CHDIR_PARMS:
 41229 00009857 0001                    	db	0,1				;AN000;  1 positional parm
 41230 00009859 [B597]                  	dw	FILE_OPTIONAL			;AN000;
 41231 0000985B 00                      	db	0				;AN000;  no switches
 41232 0000985C 00                      	db	0				;AN000;  no keywords
 41233                                  
 41234                                  ; PARSE BLOCK FOR ERASE
 41235                                  
 41236                                  ; The following parse control block is used for the DEL/ERASE internal
 41237                                  ; commands. This command has one required file specification and an
 41238                                  ; optional switch (/p) as operands. The verified switch or unverified
 41239                                  ; file specification is returned in PARSE1_OUTPUT.
 41240                                  
 41241                                  PARSE_ERASE:
 41242 0000985D [6098]                  	dw	ERASE_PARMS			;AN000;
 41243 0000985F 00                      	db	0				;AN000;  no extra delimiter
 41244                                  
 41245                                  ERASE_PARMS:
 41246 00009860 0101                    	db	1,1				;AN000;  1 positional parm
 41247 00009862 [AC97]                  	dw	FILE_REQUIRED			;AN000;
 41248 00009864 01                      	db	1				;AN000;  1 switch
 41249 00009865 [C797]                  	dw	SLASH_P_SWITCH			;AN000;
 41250 00009867 00                      	db	0				;AN000;  no keywords
 41251                                  
 41252                                  ; PARSE BLOCK FOR DIR
 41253                                  
 41254                                  ; The following parse control block is used for the DIR internal command.
 41255                                  ; This command has one optional file specification and several optional
 41256                                  ; switches. Switches, switch values, and the filespec are returned in 
 41257                                  ; PARSE1_OUTPUT.
 41258                                  ;
 41259                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 41260                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 41261                                  ; do not require colons, and are not checked against a value list.
 41262                                  ;
 41263                                  ; Switch /h has been removed from the DIR command	;M008
 41264                                  ; Switch /? is no longer handled internally		;M008
 41265                                  ;
 41266                                  ; A list of pointers to all the switch synonyms is provided here to
 41267                                  ; help identify which switch has been matched.
 41268                                  
 41269                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41270                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 41271                                  
 41272                                  PARSE_DIR:
 41273 00009868 [6B98]                  	dw	DIR_PARMS
 41274 0000986A 00                      	db	0			; no extra delimiters
 41275                                  DIR_PARMS:
 41276 0000986B 0001                    	db	0,1			; 1 optional positional param
 41277 0000986D [BE97]                  	dw	FILE_OPTIONAL2
 41278 0000986F 02                      	db	2			; 2 kinds of switches
 41279 00009870 [7598]                  	dw	DIR_SW_VALUED
 41280 00009872 [8798]                  	dw	DIR_SW_UNVALUED
 41281 00009874 00                      	db	0			; no keywords
 41282                                  
 41283                                  DIR_SW_VALUED:
 41284 00009875 0120                    	dw	2001h			; optional string value
 41285 00009877 2100                    	dw	21h			; optional colon; capitalize 
 41286 00009879 [57AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41287 0000987B [AB97]                  	dw	NULL_VALUE_LIST		; don't validate value
 41288                                  
 41289                                  	; 18/06/2023
 41290                                  	;db	2
 41291                                  
 41292                                  ; MSDOS 6.0 COMMAND.COM
 41293                                  ;ifdef DBLSPACE_HOOKS
 41294                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41295 0000987D 03                      	db	3		; 3 'synonyms'
 41296                                  ;else
 41297                                  ;	db	2		; 2 'synonyms'
 41298                                  ;endif
 41299                                  
 41300                                  DIR_SW_A:
 41301 0000987E 2F4100                  	db	"/A",0
 41302                                  DIR_SW_O:
 41303 00009881 2F4F00                  	db	"/O",0
 41304                                  
 41305                                  ; MSDOS 6.0 COMMAND.COM
 41306                                  ;ifdef DBLSPACE_HOOKS
 41307                                  	; 18/06/2023
 41308                                  DIR_SW_C:
 41309 00009884 2F4300                  	db	"/C",0
 41310                                  ;endif
 41311                                  
 41312                                  DIR_SW_UNVALUED:
 41313 00009887 0000                    	dw	0			; no value
 41314 00009889 0000                    	dw	0			; no format functions
 41315 0000988B [57AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41316 0000988D [A997]                  	dw	NO_VALUES
 41317                                  
 41318                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41319                                  	;;db	12
 41320                                  	
 41321                                  	; 18/06/2023
 41322                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 41323                                  	;db	14		; 14 'synonyms' !?
 41324                                  
 41325                                  ; MSDOS 6.0 COMMAND.COM
 41326                                  ;ifdef DBLSPACE_HOOKS
 41327                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41328                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DB0h
 41329 0000988F 0D                      	db	13		; 13 'synonyms'
 41330                                  ;else
 41331                                  ;	db	12		; 12 'synonyms'
 41332                                  ;endif
 41333                                  
 41334                                  DIR_SW_NEG_A:
 41335 00009890 2F2D4100                	db	"/-A",0
 41336                                  DIR_SW_NEG_O:
 41337 00009894 2F2D4F00                	db	"/-O",0
 41338                                  DIR_SW_S:
 41339 00009898 2F5300                  	db	"/S",0
 41340                                  DIR_SW_NEG_S:
 41341 0000989B 2F2D5300                	db	"/-S",0
 41342                                  DIR_SW_B:
 41343 0000989F 2F4200                  	db	"/B",0
 41344                                  DIR_SW_NEG_B:
 41345 000098A2 2F2D4200                	db	"/-B",0
 41346                                  DIR_SW_W:
 41347 000098A6 2F5700                  	db	"/W",0
 41348                                  DIR_SW_NEG_W:
 41349 000098A9 2F2D5700                	db	"/-W",0
 41350                                  DIR_SW_P:
 41351 000098AD 2F5000                  	db	"/P",0
 41352                                  DIR_SW_NEG_P:
 41353 000098B0 2F2D5000                	db	"/-P",0
 41354                                  DIR_SW_L:
 41355 000098B4 2F4C00                  	db	"/L",0		;M010
 41356                                  DIR_SW_NEG_L:
 41357 000098B7 2F2D4C00                	db	"/-L",0 	;M010
 41358                                  
 41359                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41360                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 41361                                  DIR_SW_NEG_C:
 41362 000098BB 2F2D4300                	db	"/-C",0
 41363                                  
 41364                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 41365                                  ; identification. Order is critical - DIR routines rely on the
 41366                                  ; specific order in this list. Negated options appear at odd 
 41367                                  ; positions in the list, and simple on/off options appear first.
 41368                                  
 41369                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41370                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DE0h
 41371                                  Dir_Sw_Ptrs:			; list of ptrs to switch synonyms
 41372                                  	; 18/06/2023
 41373                                  	; MSDOS 6.0 COMMAND.COM ; *
 41374 000098BF [BB98]                  	dw	DIR_SW_NEG_C	; * 
 41375                                  Dir_Sw_Ptrs_2:
 41376 000098C1 [8498]                  	dw	DIR_SW_C	; *
 41377                                  	; MSDOS 5.0 COMMAND.COM	
 41378                                  ;Dir_Sw_Ptrs:
 41379 000098C3 [A998]                  	dw	DIR_SW_NEG_W
 41380                                  ;Dir_Sw_Ptrs_2:
 41381 000098C5 [A698]                  	dw	DIR_SW_W
 41382 000098C7 [B098]                  	dw	DIR_SW_NEG_P
 41383 000098C9 [AD98]                  	dw	DIR_SW_P
 41384 000098CB [9B98]                  	dw	DIR_SW_NEG_S
 41385 000098CD [9898]                  	dw	DIR_SW_S
 41386 000098CF [A298]                  	dw	DIR_SW_NEG_B
 41387 000098D1 [9F98]                  	dw	DIR_SW_B
 41388 000098D3 [B798]                  	dw	DIR_SW_NEG_L	;M010
 41389 000098D5 [B498]                  	dw	DIR_SW_L	;M010
 41390 000098D7 [9498]                  	dw	DIR_SW_NEG_O
 41391 000098D9 [8198]                  	dw	DIR_SW_O
 41392 000098DB [9098]                  	dw	DIR_SW_NEG_A
 41393 000098DD [7E98]                  	dw	DIR_SW_A
 41394                                  
 41395                                  ; PARSE BLOCK FOR RENAME
 41396                                  
 41397                                  ; The following parse control block can be used for any command which
 41398                                  ; needs only two required file specifications as operands. Returns
 41399                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 41400                                  ; Currently used for the RENAME internal command.
 41401                                  
 41402                                  PARSE_RENAME:
 41403 000098DF [E298]                  	dw	RENAME_PARMS		;AN000;
 41404 000098E1 00                      	db	0			;AN000;  no extra delimiter
 41405                                  RENAME_PARMS:
 41406 000098E2 0202                    	db	2,2			;AN000;  2 positional parms
 41407 000098E4 [AC97]                  	dw	FILE_REQUIRED		;AN000;
 41408 000098E6 [AC97]                  	dw	FILE_REQUIRED		;AN000;
 41409 000098E8 00                      	db	0			;AN000;  no switches
 41410 000098E9 00                      	db	0			;AN000;  no keywords
 41411                                  
 41412                                  ; PARSE BLOCK FOR CTTY
 41413                                  
 41414                                  ; The following parse control block can be used for any command which
 41415                                  ; needs one required device name as an operand. Returns a pointer to
 41416                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 41417                                  ; internal command.
 41418                                  
 41419                                  PARSE_CTTY:
 41420 000098EA [ED98]                  	dw	CTTY_PARMS		;AN000;
 41421 000098EC 00                      	db	0			;AN000;  no extra delimiter
 41422                                  CTTY_PARMS:
 41423 000098ED 0101                    	db	1,1			;AN000;  1 positional parm
 41424 000098EF [F398]                  	dw	CTTY_CONTROL1		;AN000;
 41425 000098F1 00                      	db	0			;AN000;  no switches
 41426 000098F2 00                      	db	0			;AN000;  no keywords
 41427                                  CTTY_CONTROL1:
 41428 000098F3 0020                    	dw	2000h			;AN000;  string value - required
 41429 000098F5 1100                    	dw	11h			;AN000;  capitalize - file table
 41430                                  					;AN000;  remove colon at end
 41431 000098F7 [57AA]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41432 000098F9 [A997]                  	dw	NO_VALUES		;AN000;
 41433 000098FB 00                      	db	0			;AN000;  no keywords
 41434                                  
 41435                                  ; PARSE BLOCK FOR VER
 41436                                  
 41437                                  ; The following parse control block can be used for any command which
 41438                                  ; needs an optional switch "/debug". Currently used for the VER command.
 41439                                  
 41440                                  PARSE_VER:
 41441 000098FC [FF98]                  	dw	VER_PARMS
 41442 000098FE 00                      	db	0			; no extra delimiters
 41443                                  VER_PARMS:
 41444 000098FF 0000                    	db	0,0			; no positional parameters
 41445 00009901 01                      	db	1			; one switch
 41446 00009902 [0599]                  	dw	SLASH_R
 41447 00009904 00                      	db	0			; no keywords
 41448                                  SLASH_R:
 41449 00009905 0000                    	dw	0			; no values
 41450 00009907 0200                    	dw	2			; capitalize by filename table
 41451 00009909 [57AA]                  	dw	PARSE1_OUTPUT		; result buffer
 41452 0000990B [A997]                  	dw	NO_VALUES		; no values
 41453 0000990D 01                      	db	1			; one synonym
 41454                                  SLASH_R_SYN:
 41455 0000990E 2F5200                  	db	"/R",0
 41456                                  
 41457                                  ; M003 ; Start of changes for LoadHigh support
 41458                                  
 41459                                  ;Parse Control Block for LOADHIGH command
 41460                                  
 41461                                  Parse_LoadHi:
 41462 00009911 [1499]                  	dw	LoadHi_Parms		;extended parm table
 41463 00009913 00                      	db	0			;no extra delimiters
 41464                                  
 41465                                  LoadHi_Parms:
 41466 00009914 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 41467 00009916 [AC97]                  	dw	FILE_REQUIRED		;control struc for filename
 41468 00009918 00                      	db	0			;no switches
 41469 00009919 00                      	db	0			;no keywords
 41470                                  
 41471                                  ; M003 ; End of changes for LoadHigh support
 41472                                  
 41473                                  TempVarName:
 41474 0000991A 54454D503D00            	db	"TEMP=",0
 41475                                  
 41476                                  	; 16/04/2023 - Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 41477                                  ;TRANDATAEND:		; TRANGROUP:88C2h
 41478                                  
 41479                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41480                                  copycmd:
 41481 00009920 434F5059434D443D        	db 'COPYCMD='
 41482                                  sCVFRoot:
 41483 00009928 5C44424C5350414345-     	db '\DBLSPACE.'
 41483 00009931 2E                 
 41484                                  
 41485                                  	; 18/06/2023
 41486                                  	; MSDOS 6.22 COMMAND.COM
 41487                                  TRANDATAEND:		; TRANGROUP:9E53h
 41488                                  
 41489                                  ;============================================================================
 41490                                  ; PSDATA.INC, MSDOS 6.0, 1991
 41491                                  ;============================================================================
 41492                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41493                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41494                                  
 41495                                  ; 18/04/2023
 41496                                  TRANSPACESTART:
 41497                                  
 41498                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 41499                                  	
 41500                                  	; 18/06/2023
 41501                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9E53h
 41502                                  
 41503                                  ;********************** Local Data *************************************
 41504                                  
 41505                                  $P_ORDINAL:
 41506 00009932 0000                    	dw	0		;AN000; Operand ordinal save area
 41507                                  $P_RC:
 41508 00009934 0000                    	dw	0		;AN000; Return code from parser
 41509                                  $P_SI_Save:
 41510 00009936 0000                    	dw	0		;AN000; Pointer of command buffer
 41511                                  $P_DX:
 41512 00009938 0000                    	dw	0		;AN000; Return result buffer address
 41513                                  $P_Terminator:
 41514 0000993A 00                      	db	0		;AN000; Terminator code (ASCII)
 41515                                  $P_DBCSEV_OFF:
 41516 0000993B 0000                    	dw	0		;AN000; Offset of DBCS EV
 41517                                  $P_DBCSEV_SEG:
 41518 0000993D 0000                    	dw	0		;AN000; Segment of DBCS EV
 41519                                  $P_Flags:			;AN000; Parser internal flags
 41520                                  $P_Flags1:
 41521 0000993F 00                      	db	0		;AN038; to reference first byte flags
 41522                                  $P_Flags2:
 41523 00009940 00                      	db	0		;AN038; to reference second byte flags only
 41524                                  $P_SaveSI_Cmpx:
 41525 00009941 0000                    	dw	0		;AN000; save si for later use by complex
 41526                                  $P_KEYorSW_Ptr:
 41527 00009943 0000                    	dw	0		;AN000; points next to "=" or ":" code
 41528                                  $P_Save_EOB:
 41529 00009945 0000                    	dw	0		;AN000; save pointer to EOB
 41530                                  $P_Found_SYNONYM:
 41531 00009947 0000                    	dw	0		;AN000; es:@ points to found synonym
 41532                                  $P_STRING_BUF:
 41533 00009949 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 41534                                  $P_ORIG_ORD:
 41535 000099C9 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 41536                                  $P_ORIG_STACK:
 41537 000099CB 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 41538                                  $P_ORIG_SI:
 41539 000099CD 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 41540                                  $P_Got_Time:
 41541 000099CF 00                      	db	0		;AN023; if 1, use Time delimiters
 41542                                  $P_Country_Info:
 41543 000099D0 FFFF                    	dw	-1 ; 0FFFFh
 41544 000099D2 00<rep 20h>             	times	32 db 0	
 41545                                  $P_1st_Val:
 41546 000099F2 0000                    	dw	0		;AN000; used when process date or time
 41547                                  $P_2nd_Val:
 41548 000099F4 0000                    	dw	0		;AN000; used when process date or time
 41549                                  $P_3rd_Val:
 41550 000099F6 0000                    	dw	0		;AN000; used when process date or time
 41551                                  $P_4th_Val:
 41552 000099F8 0000                    	dw	0		;AN000; used when process date or time
 41553                                  $P_Char_CAP_Ptr:
 41554 000099FA FF                      	db	0FFh		;AN000; info id
 41555 000099FB 0000                    	dw	0		;AN000; offset	of char case map table
 41556 000099FD 0000                    	dw	0		;AN000; segment of char case map table
 41557                                  $P_File_CAP_Ptr:
 41558 000099FF FF                      	db	0FFh		;AN000; info id
 41559 00009A00 0000                    	dw	0		;AN000; offset	of file case map table
 41560 00009A02 0000                    	dw	0		;AN000; segment of file case map table
 41561                                  
 41562                                  	; 18/04/2023
 41563                                  ;M029
 41564                                  ;!!!WARNING!!!
 41565                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 41566                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 41567                                  ;changes need to be made in SYSPARSE
 41568                                  
 41569                                  $P_FileSp_Char:
 41570 00009A04 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 41571                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 41572                                  
 41573                                  ;filespec error flag
 41574                                  $P_err_flag:
 41575 00009A0D 00                      	db	0		;AN033; flag set if filespec parsing error
 41576                                  				;AN033;  was detected.
 41577                                  
 41578                                  ;============================================================================
 41579                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 41580                                  ;============================================================================
 41581                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41582                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41583                                  
 41584                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 41585                                  
 41586                                  	; 18/06/2023
 41587                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9F2Fh
 41588                                  
 41589                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 41590                                  ;;
 41591                                  ;; STRUCTURE: $M_RES_ADDRS
 41592                                  ;;
 41593                                  ;; Resident data area definition of variables
 41594                                  ;;
 41595                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 41596                                  
 41597                                  $M_RT:
 41598 00009A0E 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 41599                                  
 41600                                  ;============================================================================
 41601                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 41602                                  ;============================================================================
 41603                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41604                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41605                                  
 41606                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 41607                                  ; ---------------------------------------------------------------------------
 41608                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 41609                                  ;;M031 - changed copyright to 1991
 41610                                  ;;9/16 - changed verison to 6.0 and copyright to 1992
 41611                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 41612                                  ;;B49,50 - changed version to 6 and copyright to 1993
 41613                                  ; ---------------------------------------------------------------------------
 41614                                  	
 41615                                  	; 18/06/2023
 41616                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9FBCh
 41617                                  ;ifdef USA
 41618                                  MsDosVer6_CCopy:
 41619                                  	; MSDOS 6.0
 41620                                  	;db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 41621                                  	; 18/06/2023
 41622                                  	; MSDOS 6.22
 41623 00009A9B 4D5320444F53205665-     	db	"MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp "
 41623 00009AA4 7273696F6E20362028-
 41623 00009AAD 4329436F7079726967-
 41623 00009AB6 687420313938312D31-
 41623 00009ABF 393934204D6963726F-
 41623 00009AC8 736F667420436F7270-
 41623 00009AD1 20                 
 41624 00009AD2 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 41624 00009ADB 4D6174657269616C20-
 41624 00009AE4 2D2050726F70657274-
 41624 00009AED 79206F66204D696372-
 41624 00009AF6 6F736F667420       
 41625 00009AFC 416C6C207269676874-     	db	"All rights reserved "
 41625 00009B05 732072657365727665-
 41625 00009B0E 6420               
 41626                                  ;endif
 41627                                  
 41628                                  ; ---------------------------------------------------------------------------
 41629                                  ; 18/06/2023
 41630                                  ; 15/04/2023
 41631                                  ;MsDosVer5_CCopy:
 41632                                  	;db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 41633                                  	;db	"Licensed Material - Property of Microsoft "
 41634                                  	;db	"All rights reserved "
 41635                                  ; ---------------------------------------------------------------------------
 41636                                  ; 15/04/2023
 41637                                  	; 16/04/2023 - 21/04/2023
 41638                                  	;db 	0
 41639                                  	;db	0Dh,0Ah
 41640                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 41641                                  	;db	0
 41642                                  	;db	'by Erdogan Tan - 05/05/2023'
 41643                                  	;db	0
 41644                                  
 41645                                  	; 19/06/2023
 41646                                  	; 18/06/2023
 41647                                  	;db 	0
 41648                                  	;db	0Dh,0Ah
 41649                                  	;db	'Retro DOS v4.2 COMMAND.COM '
 41650                                  	;db	0
 41651                                  	;db	'by Erdogan Tan - 19/6/2023'
 41652                                  	;db	0
 41653                                  
 41654                                  ;============================================================================
 41655                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 41656                                  ;============================================================================
 41657                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41658                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41659                                  
 41660                                  PRINTF_HANDLE:
 41661 00009B10 0000                    	dw	0		;AC000;
 41662                                  
 41663                                  ;============================================================================
 41664                                  ; TSPC.ASM, MSDOS 6.0, 1991
 41665                                  ;============================================================================
 41666                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41667                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41668                                  
 41669                                  ;TITLE	COMMAND Transient Uninitialized DATA
 41670                                  
 41671                                  ;The TRANSPACE segment contains variable data that is considered
 41672                                  ;volatile between command cycles, and therefore is not included in the
 41673                                  ;transient checksum area. Contents of these variables MUST be
 41674                                  ;initialized before use, and must not be relied upon from command
 41675                                  ;cycle to command cycle.
 41676                                  ;
 41677                                  ;No constant data values should be stored here.
 41678                                  
 41679                                  ; ---------------------------------------------------------------------------
 41680                                  ; START OF UNITIALIZED DATA
 41681                                  ; ---------------------------------------------------------------------------
 41682                                  
 41683                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 41684                                  
 41685                                  	; 18/06/2023
 41686                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A033h
 41687                                  
 41688 00009B12 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 41689 00009B69 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 41690 00009BC0 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 41691 00009C43 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 41692 00009CC6 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 41693 00009D0C 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 41694 00009D8F 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 41695                                  
 41696                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 41697                                  HEADCALL:
 41698 00009DE2 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 41699 00009DE4 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 41700 00009DE6 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 41701                                  SWITCHAR:
 41702 00009DE8 00                      	db 0			; RSWITCHAR (db '-')
 41703                                  DIRCHAR:
 41704 00009DE9 00                      	db 0			; RDIRCHAR  (db '/')
 41705                                  EXEC_ADDR:
 41706 00009DEA 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 41707                                  				; MYSEG1    (dw 0)	
 41708                                  RCH_ADDR:
 41709 00009DEE 00000000                	dd 0			;	    (dw TREMCHECK) 	
 41710                                  				; MYSEG2    (dw 0)	
 41711 00009DF2 0000                    	dw 0			; RESTEST   (dw 0)	
 41712                                  TRAN_TPA:
 41713 00009DF4 0000                    	dw 0			; RES_TPA   (dw 0)	
 41714                                  
 41715 00009DF6 00                      CHKDRV:	db 0
 41716                                  IFNOTFLAG:
 41717                                  FILTYP:
 41718 00009DF7 00                      RDEOF:	db 0			; Misc flags
 41719 00009DF8 00                      CURDRV:	db 0
 41720                                  PARM1:
 41721 00009DF9 00                      Concat:	db 0
 41722                                  PARM2:
 41723 00009DFA 00                      ArgC:	db 0
 41724 00009DFB 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 41725 00009DFD 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 41726                                  ARG2S:				; Switches after 2nd arg		
 41727                                  DestSwitch:
 41728 00009DFF 0000                    	dw 0
 41729                                  ARGTS:
 41730                                  AllSwitch:
 41731 00009E01 0000                    	dw 0			; ALL switches except for COMSW
 41732 00009E03 00                      CFLAG:	db 0
 41733                                  DestClosed:
 41734                                  SPECDRV:
 41735 00009E04 00                      	db 0
 41736 00009E05 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 41737                                  
 41738                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41739                                  ;ifdef DBLSPACE_HOOKS
 41740                                  savBytCnt: ; MSDOS 6.0
 41741 00009E07 0000                    	dw 0
 41742                                  ;endif
 41743                                  	
 41744 00009E09 0000                    NXTADD:	dw 0
 41745                                  FRSTSRCH:
 41746 00009E0B 00                      	db 0
 41747                                  ; 15/04/2023
 41748                                  LeftOnLine:
 41749 00009E0C 00                      	db 0			; entries left on line u.b. DIR
 41750                                  PerLine:
 41751 00009E0D 00                      	db 0			; entries/line u.b. DIR
 41752 00009E0E 00                      LINCNT:	db 0
 41753 00009E0F 00                      LINLEN:	db 0
 41754                                  LeftOnPage:
 41755 00009E10 0000                    	dw 0			; lines left on page u.b. DIR
 41756                                  FileCnt:
 41757 00009E12 0000                    	dw 0			; file count u.b. DIR
 41758                                  FileSiz:
 41759 00009E14 00000000                	dd 0			; file size u.b. DIR
 41760                                  
 41761                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 41762                                  
 41763                                  FileCntTotal:
 41764 00009E18 00000000                	dd 0			; total file count u.b. DIR
 41765                                  FileSizTotal:
 41766 00009E1C 00000000                	dd 0			; total file size u.b. DIR
 41767                                  
 41768                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41769                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A33Fh
 41770                                  	; MSDOS 6.0
 41771                                  ;ifdef DBLSPACE_HOOKS
 41772                                  ccluUsed:
 41773 00009E20 0000                    	dw 0			; count of DOS clusters used
 41774                                  ccluUsedDir:
 41775 00009E22 0000                    	dw 0			
 41776                                  ccluUsedTotal:
 41777 00009E24 0000                    	dw 0			
 41778                                  csecUsed:
 41779 00009E26 00000000                	dd 0			; count of comp sectors used
 41780                                  csecUsedDir:
 41781 00009E2A 00000000                	dd 0			
 41782                                  csecUsedTotal:
 41783 00009E2E 00000000                	dd 0			
 41784                                  
 41785                                  ; Note:  keep FileCntTotal through csecUsedTotal together!
 41786                                  
 41787                                  fhCVF:
 41788 00009E32 0000                    	dw 0			; Compressed Volume File handle
 41789                                  szCVF:
 41790 00009E34 00<rep 10h>             	times	16 db 0		; "X:\\12345678.123\0"
 41791                                  MDBPB:
 41792                                  	;MD_BPB	<>		; Extended MagicDrv BPB
 41793 00009E44 00<rep 40h>             	times	64 db 0
 41794                                  csecPerCluster:
 41795 00009E84 00                      	db 0			; sectors/cluster for ratio calc
 41796                                  fUseHostSize:
 41797 00009E85 00                      	db 0			; NZ if using host cluster size
 41798                                  cFATEntries:
 41799 00009E86 0000                    	dw 0			; # FAT entries in buffers
 41800                                  entInBuf:
 41801 00009E88 0000                    	dw 0			; 1st entry # in FAT buffers
 41802                                  segFATBuf:
 41803 00009E8A 0000                    	dw 0			; seg of DOS & MD FAT buffers
 41804                                  pbufDOSFAT:
 41805 00009E8C 0000                    	dw 0			; off of DOS FAT buffer
 41806                                  pbufMDFAT:
 41807 00009E8E 0000                    	dw 0			; off of MD FAT buffer
 41808                                  bufDOSFAT:
 41809                                  	;times (cRES_FAT_ENTRIES*2) db 0
 41810 00009E90 00<rep 40h>             	times 64 db 0	 	; small DOS FAT buffer
 41811                                  bufMDFAT:
 41812                                  	;times (cRES_FAT_ENTRIES*4) db 0
 41813 00009ED0 00<rep 80h>             	times 128 db 0		; small MD FAT buffer
 41814                                  ;endif
 41815                                  
 41816                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 41817                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A46Fh
 41818                                  CHARBUF:
 41819 00009F50 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 41820                                  DESTFCB2:
 41821 00009FA0 00                      IDLEN:	db 0
 41822 00009FA1 00<rep 8h>              ID:	times	8  db 0
 41823 00009FA9 00<rep 3h>              COM:	times	3  db 0 
 41824 00009FAC 00<rep 25h>             DEST:	times	37 db 0
 41825                                  DESTNAME:
 41826 00009FD1 00<rep Bh>              	times	11 db 0
 41827                                  DESTDIR:
 41828                                  DestFcb:
 41829 00009FDC 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 41830                                  GOTOLEN: ; word
 41831                                  BWDBUF:  ; byte
 41832                                  EXEFCB:  ; word
 41833 0000A01F 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 41834                                  
 41835                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 41836                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 41837                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 41838                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 41839                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 41840                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 41841                                  
 41842                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41843                                  
 41844                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41845                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A584h
 41846                                  SDIRBUF:
 41847 0000A065 00<rep Ch>              	times 12 db 0	
 41848                                  _Bits:
 41849 0000A071 0000                    	dw 0
 41850                                  PathCnt:
 41851 0000A073 0000                    	dw 0
 41852                                  PathPos:
 41853 0000A075 0000                    	dw 0
 41854 0000A077 0000                    PathSw:	dw 0
 41855                                  AttrSpecified:
 41856 0000A079 00                      	db 0			; attribute bits u.b. DIR
 41857                                  AttrSelect:
 41858 0000A07A 00                      	db 0			; attribute bits u.b. DIR
 41859 0000A07B 00                      comma:	db 0			; flag set if +,, occurs
 41860                                  plus_comma:
 41861 0000A07C 00                      	db 0			; flag set if +,, occurs
 41862                                  DirFlag:
 41863 0000A07D 00                       	db 0			;AN015; set when pathcrunch called from DIR
 41864                                  parse_last:
 41865 0000A07E 0000                    	dw 0			;AN018; used to hold parsing position
 41866                                  system_cpage:
 41867 0000A080 0000                    	dw 0			;AC001; used for CHCP variable
 41868                                  Arg_Buf:
 41869 0000A082 00<rep 80h>             	times 128 db 0	
 41870                                  File_Size_Low:
 41871 0000A102 0000                    	dw 0	
 41872                                  File_Size_High:
 41873 0000A104 0000                    	dw 0		
 41874                                  string_ptr_2:
 41875 0000A106 0000                    	dw 0	
 41876                                  Copy_num:
 41877 0000A108 0000                    	dw 0
 41878                                  cpyflag:
 41879 0000A10A 00                      	db 0
 41880                                  Dir_Num:
 41881 0000A10B 0000                    	dw 0
 41882                                  
 41883                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41884                                  	; MSDOS 6.0
 41885                                  ;ifdef DBLSPACE_HOOKS
 41886                                  Dir_CRatio_1:
 41887 0000A10D 00                      	db 0
 41888                                  Dir_CRatio_2:
 41889 0000A10E 00                      	db 0
 41890                                  ;endif
 41891                                  
 41892                                  Bytes_Free:
 41893 0000A10F 00000000                	dd 0
 41894                                  
 41895                                  Major_Ver_Num:
 41896 0000A113 0000                    	dw 0
 41897                                  Minor_Ver_Num:
 41898 0000A115 0000                    	dw 0
 41899                                  
 41900                                  One_Char_Val:
 41901 0000A117 00                      	db 0
 41902 0000A118 00                      	db 0
 41903                                  vol_drv:
 41904 0000A119 00                      	db 0
 41905                                  ROM_CALL:
 41906 0000A11A 00                      	db 0			; flag for rom function
 41907 0000A11B 0000                    ROM_IP:	dw 0
 41908 0000A11D 0000                    ROM_CS:	dw 0
 41909                                  
 41910                                  DestVars:
 41911                                  DestIsDir:
 41912 0000A11F 00                      	db 0
 41913                                  DestSiz:
 41914 0000A120 00                      	db 0
 41915                                  DestTail:
 41916 0000A121 0000                    	dw 0
 41917                                  DestInfo:
 41918 0000A123 00                      	db 0
 41919                                  DestBuf:
 41920 0000A124 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 41921                                  EndDestBuf:
 41922                                  DESTHAND:
 41923 0000A17B 0000                    	dw 0
 41924                                  DESTISDEV:
 41925 0000A17D 00                      	db 0
 41926                                  FIRSTDEST:
 41927 0000A17E 00                      	db 0
 41928                                  MELCOPY:
 41929 0000A17F 00                      	db 0
 41930                                  MELSTART:
 41931 0000A180 0000                    	dw 0
 41932                                  SrcVars:
 41933                                  SrcIsDir:
 41934 0000A182 00                      	db 0
 41935 0000A183 00                      SrcSiz:	db 0
 41936                                  SrcTail:
 41937 0000A184 0000                    	dw 0
 41938                                  SrcInfo:
 41939 0000A186 00                      	db 0
 41940                                  SrcBuf:
 41941 0000A187 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 41942                                  SRCHAND:
 41943 0000A1DE 0000                    	dw 0
 41944                                  SRCISDEV:
 41945 0000A1E0 00                      	db 0
 41946                                  ScanBuf:
 41947 0000A1E1 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 41948                                  
 41949 0000A238 0000                    SRCPT:	dw 0
 41950                                  INEXACT:
 41951 0000A23A 00                      	db 0
 41952                                  NOWRITE:
 41953 0000A23B 00                      	db 0
 41954                                  BINARY:
 41955 0000A23C 00                      	db 0
 41956                                  WRITTEN:
 41957 0000A23D 0000                    	dw 0
 41958                                  TERMREAD:
 41959 0000A23F 00                      	db 0
 41960 0000A240 00                      ASCII:	db 0
 41961 0000A241 00                      PLUS:	db 0
 41962 0000A242 00                      objcnt:	db 0			; Used in copy
 41963 0000A243 0000                    CPDATE:	dw 0
 41964 0000A245 0000                    CPTIME:	dw 0
 41965                                  
 41966                                  OFilePtr_Lo:
 41967 0000A247 0000                    	dw 0			; original file ptr for COPY when
 41968                                  OFilePtr_Hi:
 41969 0000A249 0000                    	dw 0			; 1st source is also destination
 41970 0000A24B 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 41971                                  
 41972                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41973                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A76Bh
 41974                                  cox_sublist_buff:
 41975 0000A24C 00<rep Bh>              	times 11 db 0
 41976                                  cox_y_override:
 41977 0000A257 00                      	db 0
 41978                                  cox_dest_file:
 41979 0000A258 00                      	db 0
 41980                                  cox_src_file:
 41981 0000A259 00                      	db 0
 41982                                  
 41983                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0A779h)
 41984                                  BATHAND:
 41985 0000A25A 0000                    	dw 0			; Batch handle
 41986                                  STARTEL:
 41987 0000A25C 0000                    	dw 0
 41988 0000A25E 00                      ELCNT:	db 0
 41989 0000A25F 00                      ELPOS:	db 0
 41990                                  
 41991                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 41992                                  ; MSDOS 5.0
 41993                                  SKPDEL:
 41994                                  	; 18/06/2023
 41995 0000A260 00                      	db 0	; MSDOS 6.22 (& MSDOS 5.0)  	
 41996 0000A261 00<rep Bh>              SOURCE:	times 11 db 0
 41997                                  
 41998                                  ext_entered:
 41999 0000A26C 00                      	db 0			;AN005;
 42000                                  
 42001                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 42002                                  
 42003                                  Display_Ioctl:
 42004 0000A26D 00                      	db 0			;AN000; info level
 42005 0000A26E 00                      	db 0			;AN000; reserved
 42006 0000A26F 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 42007 0000A271 0000                    	dw 0			;AN000; control flags
 42008                                  display_mode:
 42009 0000A273 00                      	db 0			;AN000; display mode, colors
 42010 0000A274 00                      	db 0			;AN000; reserved
 42011 0000A275 0000                    	dw 0			;AN023; colors
 42012 0000A277 0000                    	dw 0			;AN000; display width (PELS)
 42013 0000A279 0000                    	dw 0			;AN000; display length (PELS)
 42014                                  display_width:
 42015 0000A27B 0000                    	dw 0			;AN000; display width
 42016                                  LinPerPag:
 42017 0000A27D 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 42018                                  
 42019                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 42020 0000A27F 0000                    	dw 0			;AN000; info level
 42021                                  vol_serial:
 42022 0000A281 00000000                	dd 0			;AN000; volume serial number
 42023                                  vol_label:
 42024 0000A285 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 42025 0000A290 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 42026                                  
 42027                                  expand_star:
 42028 0000A298 00                      	db 0
 42029                                  
 42030                                  msg_flag:
 42031 0000A299 00                      	db 0			;AN022; flag set if non-utility message issued
 42032                                  Msg_Numb:
 42033 0000A29A 0000                    	dw 0			;AN022; set with extended error message issued
 42034                                  append_exec:
 42035 0000A29C 00                      	db 0			;AN041; set if internal append executed
 42036                                  print_err_flag:
 42037 0000A29D 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 42038                                  subst_buffer:
 42039 0000A29F 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 42040                                  				;AN061;
 42041                                  ; 15/04/2023
 42042 0000A2B5 00                      KPARSE:	db 0	; 3/3/KK	
 42043                                  
 42044                                  ; Data declarations taken out of parse.asm
 42045                                  
 42046                                  ; MSDOS 6.0
 42047                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 42048                                  ;argbufptr	dw	?		; index for argv[].argpointer
 42049                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 42050                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 42051                                  ;comptr		dw	?		; ptr into combuf
 42052                                  
 42053                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 42054                                  
 42055                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42056                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A7D5h
 42057                                  ARG:
 42058                                  ARG_ARGV:
 42059                                  ARGV0_ARGPOINTER:
 42060 0000A2B6 0000                    	dw 0	; ARGV[0]
 42061                                  ARGV0_ARG_FLAGS:
 42062 0000A2B8 00                      	db 0
 42063                                  ARGV0_ARGSTARTEL:
 42064 0000A2B9 0000                    	dw 0
 42065                                  ARGV0_ARGLEN:
 42066 0000A2BB 0000                    	dw 0
 42067                                  ARGV0_ARGSW_WORD:
 42068 0000A2BD 0000                    	dw 0
 42069                                  ARGV0_OCOMPTR:
 42070 0000A2BF 0000                    	dw 0
 42071                                  ARGV1_ARGPOINTER:
 42072 0000A2C1 0000                    	dw 0	; ARGV[1]	
 42073 0000A2C3 00<rep 5h>              	times 5 db 0
 42074                                  ARGV1_ARGSW_WORD:
 42075 0000A2C8 0000                    	dw 0
 42076 0000A2CA 0000                    	dw 0
 42077                                  ARGV2_ARGPOINTER:
 42078 0000A2CC 0000                    	dw 0	; ARGV[2]
 42079 0000A2CE 00<rep 5h>              	times 5 db 0
 42080                                  ARGV2_ARGSW_WORD:
 42081 0000A2D3 0000                    	dw 0
 42082 0000A2D5 0000                    	dw 0
 42083 0000A2D7 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 42084                                  ARG_ARGVCNT:
 42085 0000A576 0000                    	dw 0
 42086                                  ARG_ARGSWINFO:
 42087 0000A578 0000                    	dw 0
 42088                                  ARG_ARGBUF:
 42089 0000A57A 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 42090                                  ARG_ARGFORCOMBUF:
 42091 0000A77A 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 42092                                  
 42093                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 42094                                  	; 18/06/2023
 42095                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0AD19h
 42096                                  ARGBUF_PTR:
 42097 0000A7FA 0000                    	dw 0			; index for argv[].argpointer
 42098 0000A7FC 00<rep 80h>             TPBUF:	times 128 db 0		; temporary buffer
 42099                                  LASTARG:
 42100 0000A87C 0000                    	dw 0			; point at which to accumulate switch info
 42101 0000A87E 0000                    COMPTR:	dw 0			; ptr into combuf
 42102                                  
 42103                                  ; Data declarations taken out of path.asm
 42104                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 42105                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 42106                                  ;psep_char	DB	?		; '/' or '\'
 42107                                  ;search_best	DB	(?)		; best code, best filename so far
 42108                                  ;fname_max_len	equ	13
 42109                                  ;search_best_buf DB	fname_max_len DUP (?)
 42110                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 42111                                  ;search_error	DW	(?)		; address of error message to be printed
 42112                                  
 42113                                  FINDBUFLEN equ FIND_BUF.size ; 43
 42114                                  
 42115                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 42116                                  
 42117                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42118                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AD9Fh
 42119                                  
 42120 0000A880 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 42121                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 42122                                  pathinfo:
 42123                                  ;pathinfo_0:
 42124 0000A8AB 0000                    	dw 0
 42125                                  ;pathinfo_2:
 42126 0000A8AD 0000                    	dw 0
 42127                                  ;pathinfo_4:
 42128 0000A8AF 0000                    	dw 0
 42129                                  psep_char:
 42130 0000A8B1 00                      	db 0
 42131                                  search_best:
 42132 0000A8B2 00                      	db 0
 42133                                  FNAME_MAX_LEN equ 13
 42134                                  search_best_buf:
 42135 0000A8B3 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 42136                                  search_curdir_buf:
 42137 0000A8C0 00<rep 40h>             	times 64 db 0
 42138                                  search_error:
 42139 0000A900 0000                    	dw 0
 42140                                  
 42141                                  ; Data declarations taken out of tbatch.asm
 42142                                  
 42143                                  ;if_not_count	DW	?
 42144                                  ;
 42145                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 42146                                  ;
 42147                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 42148                                  
 42149                                  ; 31/03/2023
 42150                                  ;STACK:	;LABEL	WORD
 42151                                  
 42152                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 42153                                  
 42154                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42155                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AE21h
 42156                                  
 42157                                  IF_NOT_COUNT:
 42158 0000A902 0000                    	dw 0
 42159 0000A904 00                      zflag:	db 0
 42160                                  
 42161 0000A905 90                      align 2	; 18/06/2023
 42162                                  
 42163 0000A906 00<rep 100h>            	times 256 db 0 
 42164                                  
 42165                                  	; 16/04/2023
 42166                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 42167                                  
 42168                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42169                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AF24h
 42170                                  STACK:
 42171                                  
 42172                                  ;INTERNATVARS	internat_block <>
 42173                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 42174                                  
 42175                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 42176                                  INTERNATVARS:
 42177                                  		; (24+8 = 32 bytes)
 42178                                  DATE_TIME_FORMAT:
 42179 0000AA06 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 42180                                  CURRENCY_SYM:
 42181 0000AA08 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 42182                                  THOUS_SEP:
 42183 0000AA0D 0000                    	db 0,0			; Thousands separator 2 bytes
 42184                                  DECIMAL_SEP:
 42185 0000AA0F 0000                    	db 0,0			; Decimal separator 2 bytes
 42186                                  DATE_SEP:
 42187 0000AA11 0000                    	db 0,0			; Date separator 2 bytes
 42188                                  TIME_SEP:
 42189 0000AA13 0000                    	db 0,0			; Time separator 2 bytes	
 42190                                  BIT_FIELD:
 42191 0000AA15 00                      	db 0			; Bit values
 42192                                  				;   Bit 0 = 0 if currency symbol first
 42193                                  				;	  = 1 if currency symbol last
 42194                                  				;   Bit 1 = 0 if No space after currency symbol
 42195                                  				;	  = 1 if space after currency symbol
 42196                                  CURRENCY_CENTS:
 42197 0000AA16 00                      	db 0			; Number of places after currency dec point
 42198                                  TIME_24:
 42199 0000AA17 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 42200                                  MAP_CALL:
 42201 0000AA18 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 42202                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 42203                                  				;  in pieces.
 42204                                  DATA_SEP:
 42205 0000AA1C 0000                    	db 0,0			; Data list separator character		
 42206                                  
 42207 0000AA1E 00<rep 8h>              	times 8 db 0
 42208                                  
 42209                                  ; Max size of the block returned by the INTERNATIONAL call
 42210                                  
 42211                                  INTERNAT_BLOCK_SIZE EQU	32
 42212                                  
 42213                                  ;;	Buffer for DOS function 64h (Get extended country information)
 42214                                  ;;	subfunctions 2, 4, 6, or 7:
 42215                                  ;
 42216                                  ;CountryPtrInfo	label	byte
 42217                                  ;CountryPtrId	db	?
 42218                                  ;CountryPtr	dd	?
 42219                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 42220                                  	
 42221                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 42222                                  CountryPtrInfo:
 42223                                  CountryPtrId:	
 42224 0000AA26 00                      	db 0
 42225                                  CountryPtr:
 42226 0000AA27 00000000                	dd 0
 42227                                  
 42228                                  OldCtrlCHandler:
 42229 0000AA2B 00000000                	dd 0			; previous int 23 vector		
 42230                                  
 42231                                  BATLEN equ 32
 42232                                  
 42233                                  BATBUFPOS:
 42234 0000AA2F 0000                    	dw 0			; integer position in buffer of next byte
 42235                                  
 42236 0000AA31 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 42237                                  BATBUFEND:
 42238 0000AA51 0000                    	dw 0
 42239                                  TypeFilSiz:
 42240 0000AA53 00000000                	dd 0			; stores size of file to be typed
 42241                                  
 42242                                  ; *****************************************************
 42243                                  ; EMG 4.00
 42244                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 42245                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 42246                                  ; *****************************************************
 42247                                  ;
 42248                                  ; COMMON PARSE OUTPUT BLOCKS
 42249                                  
 42250                                  ; Common output blocks for PARSE number, complex, or string values.
 42251                                  
 42252                                  PARSE1_OUTPUT:
 42253                                  PARSE1_TYPE:
 42254 0000AA57 00                      	db 0			;AN000;  type
 42255                                  PARSE1_CODE:
 42256 0000AA58 00                      	db 0			;AN000;  return value
 42257                                  PARSE1_SYN:
 42258 0000AA59 0000                    	dw 0			;AN000;  es offset of synonym
 42259                                  PARSE1_ADDR:
 42260 0000AA5B 00000000                	dd 0			;AN000;  numeric value / address
 42261                                  				;	 of string value
 42262                                  
 42263                                  ;  Common output block for PARSE date strings.
 42264                                  
 42265                                  DATE_OUTPUT:
 42266                                  DATE_TYPE:
 42267 0000AA5F 00                      	db 0			;AN000;  type
 42268 0000AA60 00                      	db 0			;AN000;  return value
 42269 0000AA61 0000                    	dw 0			;AN000;  es offset of synonym
 42270                                  DATE_YEAR:
 42271 0000AA63 0000                    	dw 0			;AN000;  year
 42272                                  DATE_MONTH:
 42273 0000AA65 00                      	db 0			;AN000;  month
 42274                                  DATE_DAY:
 42275 0000AA66 00                      	db 0			;AN000;  day
 42276                                  
 42277                                  ;  Common output block for PARSE time strings.
 42278                                  
 42279                                  TIME_OUTPUT:
 42280                                  TIME_TYPE:
 42281 0000AA67 00                      	db 0			;AN000;  type
 42282 0000AA68 00                      	db 0			;AN000;  return value
 42283 0000AA69 0000                    	dw 0			;AN000;  es offset of synonym
 42284                                  TIME_HOUR:
 42285 0000AA6B 00                      	db 0			;AN000;  hour
 42286                                  TIME_MINUTES:
 42287 0000AA6C 00                      	db 0			;AN000;  minutes
 42288                                  TIME_SECONDS:
 42289 0000AA6D 00                      	db 0			;AN000;  seconds
 42290                                  TIME_FRACTION:
 42291 0000AA6E 00                      	db 0			;AN000;  hundredths
 42292                                  
 42293                                  ;  Common output block for PARSE drive specifier (one based drive number).
 42294                                  
 42295                                  DRIVE_OUTPUT:
 42296                                  DRIVE_TYPE:
 42297 0000AA6F 00                      	db 0			;AN000;  type
 42298                                  DRIVE_VALUE:
 42299 0000AA70 00                      	db 0			;AN000;  return value
 42300 0000AA71 0000                    	dw 0			;AN000;  es offset of synonym
 42301                                  DRIVE_NUMBER:
 42302 0000AA73 00                      	db 0			;AN000;  drive number
 42303 0000AA74 000000                  	db 0,0,0		;AN000;  reserved
 42304                                  
 42305                                  	; 18/04/2023
 42306                                  	; 16/04/2023
 42307                                  ;TRANSPACEEND:	; 98C5h
 42308                                  		; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 42309                                  
 42310                                  	; 18/06/2023
 42311                                  ;TRANSPACEEND:	; 0AF95h 
 42312                                  		; End of MSDOS 6.22 COMMAND.COM (1994) Transient portion
 42313                                  
 42314                                  ; ----------------------------------------------------------------------------
 42315                                  ; 18/06/2023
 42316                                  ; 20/04/2023
 42317                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
